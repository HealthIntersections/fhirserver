unit FHIR.R4.Turtle;

{$I fhir.r4.inc}

{
  Copyright (c) 2011+, HL7 and Health Intersections Pty Ltd (http://www.healthintersections.com.au)
  All rights reserved.
  
  Redistribution and use in source and binary forms, with or without modification, 
  are permitted provided that the following conditions are met:
  
   * Redistributions of source code must retain the above copyright notice, this 
     list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above copyright notice, 
     this list of conditions and the following disclaimer in the documentation 
     and/or other materials provided with the distribution.
   * Neither the name of HL7 nor the names of its contributors may be used to 
     endorse or promote products derived from this software without specific 
     prior written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
  POSSIBILITY OF SUCH DAMAGE.
  
}

interface

// FHIR v4.0.0 generated 2018-12-13T15:48:02+11:00

uses
  SysUtils, Classes, 
  FHIR.Support.Base, FHIR.Support.Utilities, FHIR.Support.Collections, FHIR.Support.Turtle, 
  FHIR.Base.Parser, FHIR.Base.Objects, 
  FHIR.R4.ParserBase, FHIR.R4.Resources, FHIR.R4.Constants, FHIR.R4.Types;

Type

  TFHIRTurtleParser = class (TFHIRTurtleParserBase4)
  protected
    function ParseElement(obj : TTurtleComplex) : TFhirElement; overload;

    procedure ParseElementProperties(obj : TTurtleComplex; element : TFhirElement);
    procedure ParseBackboneElementProperties(obj : TTurtleComplex; element : TFhirBackboneElement); overload;
    procedure ParseBackboneElementProperties(obj : TTurtleComplex; element : TFhirBackboneType); overload;
    function ParseBackboneElement(obj : TTurtleComplex) : TFhirBackboneElement; overload;
    function ParseBackboneType(obj : TTurtleComplex) : TFhirBackboneType; overload;
    procedure ParseBackboneTypeProperties(obj : TTurtleComplex; result : TFhirBackboneType); overload;

    function ParseEnum(obj : TTurtleComplex; Const aNames, aSystems : Array Of String) : TFHIREnum; overload;
    function ParseDate(obj : TTurtleComplex) : TFHIRDate; overload;
    function ParseDateTime(obj : TTurtleComplex) : TFHIRDateTime; overload;
    function ParseString(obj : TTurtleComplex) : TFHIRString; overload;
    function ParseInteger(obj : TTurtleComplex) : TFHIRInteger; overload;
    function ParseUri(obj : TTurtleComplex) : TFHIRUri; overload;
    function ParseInstant(obj : TTurtleComplex) : TFHIRInstant; overload;
    function ParseXhtml(obj : TTurtleComplex) : TFHIRXhtml; overload;
    function ParseBoolean(obj : TTurtleComplex) : TFHIRBoolean; overload;
    function ParseBase64Binary(obj : TTurtleComplex) : TFHIRBase64Binary; overload;
    function ParseTime(obj : TTurtleComplex) : TFHIRTime; overload;
    function ParseDecimal(obj : TTurtleComplex) : TFHIRDecimal; overload;
    function ParseCode(obj : TTurtleComplex) : TFHIRCode; overload;
    function ParseCanonical(obj : TTurtleComplex) : TFHIRCanonical; overload;
    function ParseOid(obj : TTurtleComplex) : TFHIROid; overload;
    function ParseUuid(obj : TTurtleComplex) : TFHIRUuid; overload;
    function ParseUrl(obj : TTurtleComplex) : TFHIRUrl; overload;
    function ParseMarkdown(obj : TTurtleComplex) : TFHIRMarkdown; overload;
    function ParseUnsignedInt(obj : TTurtleComplex) : TFHIRUnsignedInt; overload;
    function ParseId(obj : TTurtleComplex) : TFHIRId; overload;
    function ParsePositiveInt(obj : TTurtleComplex) : TFHIRPositiveInt; overload;

    procedure ParseResourceProperties(obj : TTurtleComplex; resource : TFhirResource);
    procedure ParseDomainResourceProperties(obj : TTurtleComplex; resource : TFhirDomainResource);
{$IFDEF FHIR_PARAMETERS}
    function ParseParametersParameter(obj : TTurtleComplex) : TFhirParametersParameter; overload; {b\}
    procedure ParseParametersParameterProperties(obj : TTurtleComplex; result : TFhirParametersParameter); overload; {b\}
    function ParseParameters(obj : TTurtleComplex) : TFhirParameters; overload;
    procedure ParseParametersProperties(obj : TTurtleComplex; result : TFhirParameters); overload;
{$ENDIF FHIR_PARAMETERS}

    function ParseExtension(obj : TTurtleComplex) : TFhirExtension; overload;
    procedure ParseExtensionProperties(obj : TTurtleComplex; result : TFhirExtension); overload;
    function ParseNarrative(obj : TTurtleComplex) : TFhirNarrative; overload;
    procedure ParseNarrativeProperties(obj : TTurtleComplex; result : TFhirNarrative); overload;
    function ParseContributor(obj : TTurtleComplex) : TFhirContributor; overload;
    procedure ParseContributorProperties(obj : TTurtleComplex; result : TFhirContributor); overload;
    function ParseAttachment(obj : TTurtleComplex) : TFhirAttachment; overload;
    procedure ParseAttachmentProperties(obj : TTurtleComplex; result : TFhirAttachment); overload;
    function ParseDataRequirementCodeFilter(obj : TTurtleComplex) : TFhirDataRequirementCodeFilter; overload; {b\}
    procedure ParseDataRequirementCodeFilterProperties(obj : TTurtleComplex; result : TFhirDataRequirementCodeFilter); overload; {b\}
    function ParseDataRequirementDateFilter(obj : TTurtleComplex) : TFhirDataRequirementDateFilter; overload; {b\}
    procedure ParseDataRequirementDateFilterProperties(obj : TTurtleComplex; result : TFhirDataRequirementDateFilter); overload; {b\}
    function ParseDataRequirementSort(obj : TTurtleComplex) : TFhirDataRequirementSort; overload; {b\}
    procedure ParseDataRequirementSortProperties(obj : TTurtleComplex; result : TFhirDataRequirementSort); overload; {b\}
    function ParseDataRequirement(obj : TTurtleComplex) : TFhirDataRequirement; overload;
    procedure ParseDataRequirementProperties(obj : TTurtleComplex; result : TFhirDataRequirement); overload;
    function ParseDosageDoseAndRate(obj : TTurtleComplex) : TFhirDosageDoseAndRate; overload; {b\}
    procedure ParseDosageDoseAndRateProperties(obj : TTurtleComplex; result : TFhirDosageDoseAndRate); overload; {b\}
    function ParseDosage(obj : TTurtleComplex) : TFhirDosage; overload;
    procedure ParseDosageProperties(obj : TTurtleComplex; result : TFhirDosage); overload;
    function ParseMoney(obj : TTurtleComplex) : TFhirMoney; overload;
    procedure ParseMoneyProperties(obj : TTurtleComplex; result : TFhirMoney); overload;
    function ParseMarketingStatus(obj : TTurtleComplex) : TFhirMarketingStatus; overload;
    procedure ParseMarketingStatusProperties(obj : TTurtleComplex; result : TFhirMarketingStatus); overload;
    function ParseIdentifier(obj : TTurtleComplex) : TFhirIdentifier; overload;
    procedure ParseIdentifierProperties(obj : TTurtleComplex; result : TFhirIdentifier); overload;
    function ParseSubstanceAmountReferenceRange(obj : TTurtleComplex) : TFhirSubstanceAmountReferenceRange; overload; {b\}
    procedure ParseSubstanceAmountReferenceRangeProperties(obj : TTurtleComplex; result : TFhirSubstanceAmountReferenceRange); overload; {b\}
    function ParseSubstanceAmount(obj : TTurtleComplex) : TFhirSubstanceAmount; overload;
    procedure ParseSubstanceAmountProperties(obj : TTurtleComplex; result : TFhirSubstanceAmount); overload;
    function ParseCoding(obj : TTurtleComplex) : TFhirCoding; overload;
    procedure ParseCodingProperties(obj : TTurtleComplex; result : TFhirCoding); overload;
    function ParseSampledData(obj : TTurtleComplex) : TFhirSampledData; overload;
    procedure ParseSampledDataProperties(obj : TTurtleComplex; result : TFhirSampledData); overload;
    function ParsePopulation(obj : TTurtleComplex) : TFhirPopulation; overload;
    procedure ParsePopulationProperties(obj : TTurtleComplex; result : TFhirPopulation); overload;
    function ParseRatio(obj : TTurtleComplex) : TFhirRatio; overload;
    procedure ParseRatioProperties(obj : TTurtleComplex; result : TFhirRatio); overload;
    function ParseReference(obj : TTurtleComplex) : TFhirReference; overload;
    procedure ParseReferenceProperties(obj : TTurtleComplex; result : TFhirReference); overload;
    function ParseTriggerDefinition(obj : TTurtleComplex) : TFhirTriggerDefinition; overload;
    procedure ParseTriggerDefinitionProperties(obj : TTurtleComplex; result : TFhirTriggerDefinition); overload;
    function ParsePeriod(obj : TTurtleComplex) : TFhirPeriod; overload;
    procedure ParsePeriodProperties(obj : TTurtleComplex; result : TFhirPeriod); overload;
    function ParseQuantity(obj : TTurtleComplex) : TFhirQuantity; overload;
    procedure ParseQuantityProperties(obj : TTurtleComplex; result : TFhirQuantity); overload;
    function ParseRange(obj : TTurtleComplex) : TFhirRange; overload;
    procedure ParseRangeProperties(obj : TTurtleComplex; result : TFhirRange); overload;
    function ParseRelatedArtifact(obj : TTurtleComplex) : TFhirRelatedArtifact; overload;
    procedure ParseRelatedArtifactProperties(obj : TTurtleComplex; result : TFhirRelatedArtifact); overload;
    function ParseAnnotation(obj : TTurtleComplex) : TFhirAnnotation; overload;
    procedure ParseAnnotationProperties(obj : TTurtleComplex; result : TFhirAnnotation); overload;
    function ParseProductShelfLife(obj : TTurtleComplex) : TFhirProductShelfLife; overload;
    procedure ParseProductShelfLifeProperties(obj : TTurtleComplex; result : TFhirProductShelfLife); overload;
    function ParseContactDetail(obj : TTurtleComplex) : TFhirContactDetail; overload;
    procedure ParseContactDetailProperties(obj : TTurtleComplex; result : TFhirContactDetail); overload;
    function ParseExpression(obj : TTurtleComplex) : TFhirExpression; overload;
    procedure ParseExpressionProperties(obj : TTurtleComplex; result : TFhirExpression); overload;
    function ParseUsageContext(obj : TTurtleComplex) : TFhirUsageContext; overload;
    procedure ParseUsageContextProperties(obj : TTurtleComplex; result : TFhirUsageContext); overload;
    function ParseSignature(obj : TTurtleComplex) : TFhirSignature; overload;
    procedure ParseSignatureProperties(obj : TTurtleComplex; result : TFhirSignature); overload;
    function ParseProdCharacteristic(obj : TTurtleComplex) : TFhirProdCharacteristic; overload;
    procedure ParseProdCharacteristicProperties(obj : TTurtleComplex; result : TFhirProdCharacteristic); overload;
    function ParseCodeableConcept(obj : TTurtleComplex) : TFhirCodeableConcept; overload;
    procedure ParseCodeableConceptProperties(obj : TTurtleComplex; result : TFhirCodeableConcept); overload;
    function ParseParameterDefinition(obj : TTurtleComplex) : TFhirParameterDefinition; overload;
    procedure ParseParameterDefinitionProperties(obj : TTurtleComplex; result : TFhirParameterDefinition); overload;
    function ParseContactPoint(obj : TTurtleComplex) : TFhirContactPoint; overload;
    procedure ParseContactPointProperties(obj : TTurtleComplex; result : TFhirContactPoint); overload;
    function ParseHumanName(obj : TTurtleComplex) : TFhirHumanName; overload;
    procedure ParseHumanNameProperties(obj : TTurtleComplex; result : TFhirHumanName); overload;
    function ParseMeta(obj : TTurtleComplex) : TFhirMeta; overload;
    procedure ParseMetaProperties(obj : TTurtleComplex; result : TFhirMeta); overload;
    function ParseAddress(obj : TTurtleComplex) : TFhirAddress; overload;
    procedure ParseAddressProperties(obj : TTurtleComplex; result : TFhirAddress); overload;
    function ParseElementDefinitionSlicing(obj : TTurtleComplex) : TFhirElementDefinitionSlicing; overload; {b\}
    procedure ParseElementDefinitionSlicingProperties(obj : TTurtleComplex; result : TFhirElementDefinitionSlicing); overload; {b\}
    function ParseElementDefinitionSlicingDiscriminator(obj : TTurtleComplex) : TFhirElementDefinitionSlicingDiscriminator; overload; {b\}
    procedure ParseElementDefinitionSlicingDiscriminatorProperties(obj : TTurtleComplex; result : TFhirElementDefinitionSlicingDiscriminator); overload; {b\}
    function ParseElementDefinitionBase(obj : TTurtleComplex) : TFhirElementDefinitionBase; overload; {b\}
    procedure ParseElementDefinitionBaseProperties(obj : TTurtleComplex; result : TFhirElementDefinitionBase); overload; {b\}
    function ParseElementDefinitionType(obj : TTurtleComplex) : TFhirElementDefinitionType; overload; {b\}
    procedure ParseElementDefinitionTypeProperties(obj : TTurtleComplex; result : TFhirElementDefinitionType); overload; {b\}
    function ParseElementDefinitionExample(obj : TTurtleComplex) : TFhirElementDefinitionExample; overload; {b\}
    procedure ParseElementDefinitionExampleProperties(obj : TTurtleComplex; result : TFhirElementDefinitionExample); overload; {b\}
    function ParseElementDefinitionConstraint(obj : TTurtleComplex) : TFhirElementDefinitionConstraint; overload; {b\}
    procedure ParseElementDefinitionConstraintProperties(obj : TTurtleComplex; result : TFhirElementDefinitionConstraint); overload; {b\}
    function ParseElementDefinitionBinding(obj : TTurtleComplex) : TFhirElementDefinitionBinding; overload; {b\}
    procedure ParseElementDefinitionBindingProperties(obj : TTurtleComplex; result : TFhirElementDefinitionBinding); overload; {b\}
    function ParseElementDefinitionMapping(obj : TTurtleComplex) : TFhirElementDefinitionMapping; overload; {b\}
    procedure ParseElementDefinitionMappingProperties(obj : TTurtleComplex; result : TFhirElementDefinitionMapping); overload; {b\}
    function ParseElementDefinition(obj : TTurtleComplex) : TFhirElementDefinition; overload;
    procedure ParseElementDefinitionProperties(obj : TTurtleComplex; result : TFhirElementDefinition); overload;
    function ParseTimingRepeat(obj : TTurtleComplex) : TFhirTimingRepeat; overload; {b\}
    procedure ParseTimingRepeatProperties(obj : TTurtleComplex; result : TFhirTimingRepeat); overload; {b\}
    function ParseTiming(obj : TTurtleComplex) : TFhirTiming; overload;
    procedure ParseTimingProperties(obj : TTurtleComplex; result : TFhirTiming); overload;
    function ParseCount(obj : TTurtleComplex) : TFhirCount; overload;
    procedure ParseCountProperties(obj : TTurtleComplex; result : TFhirCount); overload;
    function ParseAge(obj : TTurtleComplex) : TFhirAge; overload;
    procedure ParseAgeProperties(obj : TTurtleComplex; result : TFhirAge); overload;
    function ParseDistance(obj : TTurtleComplex) : TFhirDistance; overload;
    procedure ParseDistanceProperties(obj : TTurtleComplex; result : TFhirDistance); overload;
    function ParseDuration(obj : TTurtleComplex) : TFhirDuration; overload;
    procedure ParseDurationProperties(obj : TTurtleComplex; result : TFhirDuration); overload;

{$IFDEF FHIR_ACCOUNT}
    function ParseAccountCoverage(obj : TTurtleComplex) : TFhirAccountCoverage; overload; {b\}
    procedure ParseAccountCoverageProperties(obj : TTurtleComplex; result : TFhirAccountCoverage); overload; {b\}
    function ParseAccountGuarantor(obj : TTurtleComplex) : TFhirAccountGuarantor; overload; {b\}
    procedure ParseAccountGuarantorProperties(obj : TTurtleComplex; result : TFhirAccountGuarantor); overload; {b\}
    function ParseAccount(obj : TTurtleComplex) : TFhirAccount; overload;
    procedure ParseAccountProperties(obj : TTurtleComplex; result : TFhirAccount); overload;
{$ENDIF FHIR_ACCOUNT}
{$IFDEF FHIR_ACTIVITYDEFINITION}
    function ParseActivityDefinitionParticipant(obj : TTurtleComplex) : TFhirActivityDefinitionParticipant; overload; {b\}
    procedure ParseActivityDefinitionParticipantProperties(obj : TTurtleComplex; result : TFhirActivityDefinitionParticipant); overload; {b\}
    function ParseActivityDefinitionDynamicValue(obj : TTurtleComplex) : TFhirActivityDefinitionDynamicValue; overload; {b\}
    procedure ParseActivityDefinitionDynamicValueProperties(obj : TTurtleComplex; result : TFhirActivityDefinitionDynamicValue); overload; {b\}
    function ParseActivityDefinition(obj : TTurtleComplex) : TFhirActivityDefinition; overload;
    procedure ParseActivityDefinitionProperties(obj : TTurtleComplex; result : TFhirActivityDefinition); overload;
{$ENDIF FHIR_ACTIVITYDEFINITION}
{$IFDEF FHIR_ADVERSEEVENT}
    function ParseAdverseEventSuspectEntity(obj : TTurtleComplex) : TFhirAdverseEventSuspectEntity; overload; {b\}
    procedure ParseAdverseEventSuspectEntityProperties(obj : TTurtleComplex; result : TFhirAdverseEventSuspectEntity); overload; {b\}
    function ParseAdverseEventSuspectEntityCausality(obj : TTurtleComplex) : TFhirAdverseEventSuspectEntityCausality; overload; {b\}
    procedure ParseAdverseEventSuspectEntityCausalityProperties(obj : TTurtleComplex; result : TFhirAdverseEventSuspectEntityCausality); overload; {b\}
    function ParseAdverseEvent(obj : TTurtleComplex) : TFhirAdverseEvent; overload;
    procedure ParseAdverseEventProperties(obj : TTurtleComplex; result : TFhirAdverseEvent); overload;
{$ENDIF FHIR_ADVERSEEVENT}
{$IFDEF FHIR_ALLERGYINTOLERANCE}
    function ParseAllergyIntoleranceReaction(obj : TTurtleComplex) : TFhirAllergyIntoleranceReaction; overload; {b\}
    procedure ParseAllergyIntoleranceReactionProperties(obj : TTurtleComplex; result : TFhirAllergyIntoleranceReaction); overload; {b\}
    function ParseAllergyIntolerance(obj : TTurtleComplex) : TFhirAllergyIntolerance; overload;
    procedure ParseAllergyIntoleranceProperties(obj : TTurtleComplex; result : TFhirAllergyIntolerance); overload;
{$ENDIF FHIR_ALLERGYINTOLERANCE}
{$IFDEF FHIR_APPOINTMENT}
    function ParseAppointmentParticipant(obj : TTurtleComplex) : TFhirAppointmentParticipant; overload; {b\}
    procedure ParseAppointmentParticipantProperties(obj : TTurtleComplex; result : TFhirAppointmentParticipant); overload; {b\}
    function ParseAppointment(obj : TTurtleComplex) : TFhirAppointment; overload;
    procedure ParseAppointmentProperties(obj : TTurtleComplex; result : TFhirAppointment); overload;
{$ENDIF FHIR_APPOINTMENT}
{$IFDEF FHIR_APPOINTMENTRESPONSE}
    function ParseAppointmentResponse(obj : TTurtleComplex) : TFhirAppointmentResponse; overload;
    procedure ParseAppointmentResponseProperties(obj : TTurtleComplex; result : TFhirAppointmentResponse); overload;
{$ENDIF FHIR_APPOINTMENTRESPONSE}
{$IFDEF FHIR_AUDITEVENT}
    function ParseAuditEventAgent(obj : TTurtleComplex) : TFhirAuditEventAgent; overload; {b\}
    procedure ParseAuditEventAgentProperties(obj : TTurtleComplex; result : TFhirAuditEventAgent); overload; {b\}
    function ParseAuditEventAgentNetwork(obj : TTurtleComplex) : TFhirAuditEventAgentNetwork; overload; {b\}
    procedure ParseAuditEventAgentNetworkProperties(obj : TTurtleComplex; result : TFhirAuditEventAgentNetwork); overload; {b\}
    function ParseAuditEventSource(obj : TTurtleComplex) : TFhirAuditEventSource; overload; {b\}
    procedure ParseAuditEventSourceProperties(obj : TTurtleComplex; result : TFhirAuditEventSource); overload; {b\}
    function ParseAuditEventEntity(obj : TTurtleComplex) : TFhirAuditEventEntity; overload; {b\}
    procedure ParseAuditEventEntityProperties(obj : TTurtleComplex; result : TFhirAuditEventEntity); overload; {b\}
    function ParseAuditEventEntityDetail(obj : TTurtleComplex) : TFhirAuditEventEntityDetail; overload; {b\}
    procedure ParseAuditEventEntityDetailProperties(obj : TTurtleComplex; result : TFhirAuditEventEntityDetail); overload; {b\}
    function ParseAuditEvent(obj : TTurtleComplex) : TFhirAuditEvent; overload;
    procedure ParseAuditEventProperties(obj : TTurtleComplex; result : TFhirAuditEvent); overload;
{$ENDIF FHIR_AUDITEVENT}
{$IFDEF FHIR_BASIC}
    function ParseBasic(obj : TTurtleComplex) : TFhirBasic; overload;
    procedure ParseBasicProperties(obj : TTurtleComplex; result : TFhirBasic); overload;
{$ENDIF FHIR_BASIC}
{$IFDEF FHIR_BINARY}
    function ParseBinary(obj : TTurtleComplex) : TFhirBinary; overload;
    procedure ParseBinaryProperties(obj : TTurtleComplex; result : TFhirBinary); overload;
{$ENDIF FHIR_BINARY}
{$IFDEF FHIR_BIOLOGICALLYDERIVEDPRODUCT}
    function ParseBiologicallyDerivedProductCollection(obj : TTurtleComplex) : TFhirBiologicallyDerivedProductCollection; overload; {b\}
    procedure ParseBiologicallyDerivedProductCollectionProperties(obj : TTurtleComplex; result : TFhirBiologicallyDerivedProductCollection); overload; {b\}
    function ParseBiologicallyDerivedProductProcessing(obj : TTurtleComplex) : TFhirBiologicallyDerivedProductProcessing; overload; {b\}
    procedure ParseBiologicallyDerivedProductProcessingProperties(obj : TTurtleComplex; result : TFhirBiologicallyDerivedProductProcessing); overload; {b\}
    function ParseBiologicallyDerivedProductManipulation(obj : TTurtleComplex) : TFhirBiologicallyDerivedProductManipulation; overload; {b\}
    procedure ParseBiologicallyDerivedProductManipulationProperties(obj : TTurtleComplex; result : TFhirBiologicallyDerivedProductManipulation); overload; {b\}
    function ParseBiologicallyDerivedProductStorage(obj : TTurtleComplex) : TFhirBiologicallyDerivedProductStorage; overload; {b\}
    procedure ParseBiologicallyDerivedProductStorageProperties(obj : TTurtleComplex; result : TFhirBiologicallyDerivedProductStorage); overload; {b\}
    function ParseBiologicallyDerivedProduct(obj : TTurtleComplex) : TFhirBiologicallyDerivedProduct; overload;
    procedure ParseBiologicallyDerivedProductProperties(obj : TTurtleComplex; result : TFhirBiologicallyDerivedProduct); overload;
{$ENDIF FHIR_BIOLOGICALLYDERIVEDPRODUCT}
{$IFDEF FHIR_BODYSTRUCTURE}
    function ParseBodyStructure(obj : TTurtleComplex) : TFhirBodyStructure; overload;
    procedure ParseBodyStructureProperties(obj : TTurtleComplex; result : TFhirBodyStructure); overload;
{$ENDIF FHIR_BODYSTRUCTURE}
{$IFDEF FHIR_BUNDLE}
    function ParseBundleLink(obj : TTurtleComplex) : TFhirBundleLink; overload; {b\}
    procedure ParseBundleLinkProperties(obj : TTurtleComplex; result : TFhirBundleLink); overload; {b\}
    function ParseBundleEntry(obj : TTurtleComplex) : TFhirBundleEntry; overload; {b\}
    procedure ParseBundleEntryProperties(obj : TTurtleComplex; result : TFhirBundleEntry); overload; {b\}
    function ParseBundleEntrySearch(obj : TTurtleComplex) : TFhirBundleEntrySearch; overload; {b\}
    procedure ParseBundleEntrySearchProperties(obj : TTurtleComplex; result : TFhirBundleEntrySearch); overload; {b\}
    function ParseBundleEntryRequest(obj : TTurtleComplex) : TFhirBundleEntryRequest; overload; {b\}
    procedure ParseBundleEntryRequestProperties(obj : TTurtleComplex; result : TFhirBundleEntryRequest); overload; {b\}
    function ParseBundleEntryResponse(obj : TTurtleComplex) : TFhirBundleEntryResponse; overload; {b\}
    procedure ParseBundleEntryResponseProperties(obj : TTurtleComplex; result : TFhirBundleEntryResponse); overload; {b\}
    function ParseBundle(obj : TTurtleComplex) : TFhirBundle; overload;
    procedure ParseBundleProperties(obj : TTurtleComplex; result : TFhirBundle); overload;
{$ENDIF FHIR_BUNDLE}
{$IFDEF FHIR_CAPABILITYSTATEMENT}
    function ParseCapabilityStatementSoftware(obj : TTurtleComplex) : TFhirCapabilityStatementSoftware; overload; {b\}
    procedure ParseCapabilityStatementSoftwareProperties(obj : TTurtleComplex; result : TFhirCapabilityStatementSoftware); overload; {b\}
    function ParseCapabilityStatementImplementation(obj : TTurtleComplex) : TFhirCapabilityStatementImplementation; overload; {b\}
    procedure ParseCapabilityStatementImplementationProperties(obj : TTurtleComplex; result : TFhirCapabilityStatementImplementation); overload; {b\}
    function ParseCapabilityStatementRest(obj : TTurtleComplex) : TFhirCapabilityStatementRest; overload; {b\}
    procedure ParseCapabilityStatementRestProperties(obj : TTurtleComplex; result : TFhirCapabilityStatementRest); overload; {b\}
    function ParseCapabilityStatementRestSecurity(obj : TTurtleComplex) : TFhirCapabilityStatementRestSecurity; overload; {b\}
    procedure ParseCapabilityStatementRestSecurityProperties(obj : TTurtleComplex; result : TFhirCapabilityStatementRestSecurity); overload; {b\}
    function ParseCapabilityStatementRestResource(obj : TTurtleComplex) : TFhirCapabilityStatementRestResource; overload; {b\}
    procedure ParseCapabilityStatementRestResourceProperties(obj : TTurtleComplex; result : TFhirCapabilityStatementRestResource); overload; {b\}
    function ParseCapabilityStatementRestResourceInteraction(obj : TTurtleComplex) : TFhirCapabilityStatementRestResourceInteraction; overload; {b\}
    procedure ParseCapabilityStatementRestResourceInteractionProperties(obj : TTurtleComplex; result : TFhirCapabilityStatementRestResourceInteraction); overload; {b\}
    function ParseCapabilityStatementRestResourceSearchParam(obj : TTurtleComplex) : TFhirCapabilityStatementRestResourceSearchParam; overload; {b\}
    procedure ParseCapabilityStatementRestResourceSearchParamProperties(obj : TTurtleComplex; result : TFhirCapabilityStatementRestResourceSearchParam); overload; {b\}
    function ParseCapabilityStatementRestResourceOperation(obj : TTurtleComplex) : TFhirCapabilityStatementRestResourceOperation; overload; {b\}
    procedure ParseCapabilityStatementRestResourceOperationProperties(obj : TTurtleComplex; result : TFhirCapabilityStatementRestResourceOperation); overload; {b\}
    function ParseCapabilityStatementRestInteraction(obj : TTurtleComplex) : TFhirCapabilityStatementRestInteraction; overload; {b\}
    procedure ParseCapabilityStatementRestInteractionProperties(obj : TTurtleComplex; result : TFhirCapabilityStatementRestInteraction); overload; {b\}
    function ParseCapabilityStatementMessaging(obj : TTurtleComplex) : TFhirCapabilityStatementMessaging; overload; {b\}
    procedure ParseCapabilityStatementMessagingProperties(obj : TTurtleComplex; result : TFhirCapabilityStatementMessaging); overload; {b\}
    function ParseCapabilityStatementMessagingEndpoint(obj : TTurtleComplex) : TFhirCapabilityStatementMessagingEndpoint; overload; {b\}
    procedure ParseCapabilityStatementMessagingEndpointProperties(obj : TTurtleComplex; result : TFhirCapabilityStatementMessagingEndpoint); overload; {b\}
    function ParseCapabilityStatementMessagingSupportedMessage(obj : TTurtleComplex) : TFhirCapabilityStatementMessagingSupportedMessage; overload; {b\}
    procedure ParseCapabilityStatementMessagingSupportedMessageProperties(obj : TTurtleComplex; result : TFhirCapabilityStatementMessagingSupportedMessage); overload; {b\}
    function ParseCapabilityStatementDocument(obj : TTurtleComplex) : TFhirCapabilityStatementDocument; overload; {b\}
    procedure ParseCapabilityStatementDocumentProperties(obj : TTurtleComplex; result : TFhirCapabilityStatementDocument); overload; {b\}
    function ParseCapabilityStatement(obj : TTurtleComplex) : TFhirCapabilityStatement; overload;
    procedure ParseCapabilityStatementProperties(obj : TTurtleComplex; result : TFhirCapabilityStatement); overload;
{$ENDIF FHIR_CAPABILITYSTATEMENT}
{$IFDEF FHIR_CAREPLAN}
    function ParseCarePlanActivity(obj : TTurtleComplex) : TFhirCarePlanActivity; overload; {b\}
    procedure ParseCarePlanActivityProperties(obj : TTurtleComplex; result : TFhirCarePlanActivity); overload; {b\}
    function ParseCarePlanActivityDetail(obj : TTurtleComplex) : TFhirCarePlanActivityDetail; overload; {b\}
    procedure ParseCarePlanActivityDetailProperties(obj : TTurtleComplex; result : TFhirCarePlanActivityDetail); overload; {b\}
    function ParseCarePlan(obj : TTurtleComplex) : TFhirCarePlan; overload;
    procedure ParseCarePlanProperties(obj : TTurtleComplex; result : TFhirCarePlan); overload;
{$ENDIF FHIR_CAREPLAN}
{$IFDEF FHIR_CARETEAM}
    function ParseCareTeamParticipant(obj : TTurtleComplex) : TFhirCareTeamParticipant; overload; {b\}
    procedure ParseCareTeamParticipantProperties(obj : TTurtleComplex; result : TFhirCareTeamParticipant); overload; {b\}
    function ParseCareTeam(obj : TTurtleComplex) : TFhirCareTeam; overload;
    procedure ParseCareTeamProperties(obj : TTurtleComplex; result : TFhirCareTeam); overload;
{$ENDIF FHIR_CARETEAM}
{$IFDEF FHIR_CATALOGENTRY}
    function ParseCatalogEntryRelatedEntry(obj : TTurtleComplex) : TFhirCatalogEntryRelatedEntry; overload; {b\}
    procedure ParseCatalogEntryRelatedEntryProperties(obj : TTurtleComplex; result : TFhirCatalogEntryRelatedEntry); overload; {b\}
    function ParseCatalogEntry(obj : TTurtleComplex) : TFhirCatalogEntry; overload;
    procedure ParseCatalogEntryProperties(obj : TTurtleComplex; result : TFhirCatalogEntry); overload;
{$ENDIF FHIR_CATALOGENTRY}
{$IFDEF FHIR_CHARGEITEM}
    function ParseChargeItemPerformer(obj : TTurtleComplex) : TFhirChargeItemPerformer; overload; {b\}
    procedure ParseChargeItemPerformerProperties(obj : TTurtleComplex; result : TFhirChargeItemPerformer); overload; {b\}
    function ParseChargeItem(obj : TTurtleComplex) : TFhirChargeItem; overload;
    procedure ParseChargeItemProperties(obj : TTurtleComplex; result : TFhirChargeItem); overload;
{$ENDIF FHIR_CHARGEITEM}
{$IFDEF FHIR_CHARGEITEMDEFINITION}
    function ParseChargeItemDefinitionApplicability(obj : TTurtleComplex) : TFhirChargeItemDefinitionApplicability; overload; {b\}
    procedure ParseChargeItemDefinitionApplicabilityProperties(obj : TTurtleComplex; result : TFhirChargeItemDefinitionApplicability); overload; {b\}
    function ParseChargeItemDefinitionPropertyGroup(obj : TTurtleComplex) : TFhirChargeItemDefinitionPropertyGroup; overload; {b\}
    procedure ParseChargeItemDefinitionPropertyGroupProperties(obj : TTurtleComplex; result : TFhirChargeItemDefinitionPropertyGroup); overload; {b\}
    function ParseChargeItemDefinitionPropertyGroupPriceComponent(obj : TTurtleComplex) : TFhirChargeItemDefinitionPropertyGroupPriceComponent; overload; {b\}
    procedure ParseChargeItemDefinitionPropertyGroupPriceComponentProperties(obj : TTurtleComplex; result : TFhirChargeItemDefinitionPropertyGroupPriceComponent); overload; {b\}
    function ParseChargeItemDefinition(obj : TTurtleComplex) : TFhirChargeItemDefinition; overload;
    procedure ParseChargeItemDefinitionProperties(obj : TTurtleComplex; result : TFhirChargeItemDefinition); overload;
{$ENDIF FHIR_CHARGEITEMDEFINITION}
{$IFDEF FHIR_CLAIM}
    function ParseClaimRelated(obj : TTurtleComplex) : TFhirClaimRelated; overload; {b\}
    procedure ParseClaimRelatedProperties(obj : TTurtleComplex; result : TFhirClaimRelated); overload; {b\}
    function ParseClaimPayee(obj : TTurtleComplex) : TFhirClaimPayee; overload; {b\}
    procedure ParseClaimPayeeProperties(obj : TTurtleComplex; result : TFhirClaimPayee); overload; {b\}
    function ParseClaimCareTeam(obj : TTurtleComplex) : TFhirClaimCareTeam; overload; {b\}
    procedure ParseClaimCareTeamProperties(obj : TTurtleComplex; result : TFhirClaimCareTeam); overload; {b\}
    function ParseClaimSupportingInfo(obj : TTurtleComplex) : TFhirClaimSupportingInfo; overload; {b\}
    procedure ParseClaimSupportingInfoProperties(obj : TTurtleComplex; result : TFhirClaimSupportingInfo); overload; {b\}
    function ParseClaimDiagnosis(obj : TTurtleComplex) : TFhirClaimDiagnosis; overload; {b\}
    procedure ParseClaimDiagnosisProperties(obj : TTurtleComplex; result : TFhirClaimDiagnosis); overload; {b\}
    function ParseClaimProcedure(obj : TTurtleComplex) : TFhirClaimProcedure; overload; {b\}
    procedure ParseClaimProcedureProperties(obj : TTurtleComplex; result : TFhirClaimProcedure); overload; {b\}
    function ParseClaimInsurance(obj : TTurtleComplex) : TFhirClaimInsurance; overload; {b\}
    procedure ParseClaimInsuranceProperties(obj : TTurtleComplex; result : TFhirClaimInsurance); overload; {b\}
    function ParseClaimAccident(obj : TTurtleComplex) : TFhirClaimAccident; overload; {b\}
    procedure ParseClaimAccidentProperties(obj : TTurtleComplex; result : TFhirClaimAccident); overload; {b\}
    function ParseClaimItem(obj : TTurtleComplex) : TFhirClaimItem; overload; {b\}
    procedure ParseClaimItemProperties(obj : TTurtleComplex; result : TFhirClaimItem); overload; {b\}
    function ParseClaimItemDetail(obj : TTurtleComplex) : TFhirClaimItemDetail; overload; {b\}
    procedure ParseClaimItemDetailProperties(obj : TTurtleComplex; result : TFhirClaimItemDetail); overload; {b\}
    function ParseClaimItemDetailSubDetail(obj : TTurtleComplex) : TFhirClaimItemDetailSubDetail; overload; {b\}
    procedure ParseClaimItemDetailSubDetailProperties(obj : TTurtleComplex; result : TFhirClaimItemDetailSubDetail); overload; {b\}
    function ParseClaim(obj : TTurtleComplex) : TFhirClaim; overload;
    procedure ParseClaimProperties(obj : TTurtleComplex; result : TFhirClaim); overload;
{$ENDIF FHIR_CLAIM}
{$IFDEF FHIR_CLAIMRESPONSE}
    function ParseClaimResponseItem(obj : TTurtleComplex) : TFhirClaimResponseItem; overload; {b\}
    procedure ParseClaimResponseItemProperties(obj : TTurtleComplex; result : TFhirClaimResponseItem); overload; {b\}
    function ParseClaimResponseItemAdjudication(obj : TTurtleComplex) : TFhirClaimResponseItemAdjudication; overload; {b\}
    procedure ParseClaimResponseItemAdjudicationProperties(obj : TTurtleComplex; result : TFhirClaimResponseItemAdjudication); overload; {b\}
    function ParseClaimResponseItemDetail(obj : TTurtleComplex) : TFhirClaimResponseItemDetail; overload; {b\}
    procedure ParseClaimResponseItemDetailProperties(obj : TTurtleComplex; result : TFhirClaimResponseItemDetail); overload; {b\}
    function ParseClaimResponseItemDetailSubDetail(obj : TTurtleComplex) : TFhirClaimResponseItemDetailSubDetail; overload; {b\}
    procedure ParseClaimResponseItemDetailSubDetailProperties(obj : TTurtleComplex; result : TFhirClaimResponseItemDetailSubDetail); overload; {b\}
    function ParseClaimResponseAddItem(obj : TTurtleComplex) : TFhirClaimResponseAddItem; overload; {b\}
    procedure ParseClaimResponseAddItemProperties(obj : TTurtleComplex; result : TFhirClaimResponseAddItem); overload; {b\}
    function ParseClaimResponseAddItemDetail(obj : TTurtleComplex) : TFhirClaimResponseAddItemDetail; overload; {b\}
    procedure ParseClaimResponseAddItemDetailProperties(obj : TTurtleComplex; result : TFhirClaimResponseAddItemDetail); overload; {b\}
    function ParseClaimResponseAddItemDetailSubDetail(obj : TTurtleComplex) : TFhirClaimResponseAddItemDetailSubDetail; overload; {b\}
    procedure ParseClaimResponseAddItemDetailSubDetailProperties(obj : TTurtleComplex; result : TFhirClaimResponseAddItemDetailSubDetail); overload; {b\}
    function ParseClaimResponseTotal(obj : TTurtleComplex) : TFhirClaimResponseTotal; overload; {b\}
    procedure ParseClaimResponseTotalProperties(obj : TTurtleComplex; result : TFhirClaimResponseTotal); overload; {b\}
    function ParseClaimResponsePayment(obj : TTurtleComplex) : TFhirClaimResponsePayment; overload; {b\}
    procedure ParseClaimResponsePaymentProperties(obj : TTurtleComplex; result : TFhirClaimResponsePayment); overload; {b\}
    function ParseClaimResponseProcessNote(obj : TTurtleComplex) : TFhirClaimResponseProcessNote; overload; {b\}
    procedure ParseClaimResponseProcessNoteProperties(obj : TTurtleComplex; result : TFhirClaimResponseProcessNote); overload; {b\}
    function ParseClaimResponseInsurance(obj : TTurtleComplex) : TFhirClaimResponseInsurance; overload; {b\}
    procedure ParseClaimResponseInsuranceProperties(obj : TTurtleComplex; result : TFhirClaimResponseInsurance); overload; {b\}
    function ParseClaimResponseError(obj : TTurtleComplex) : TFhirClaimResponseError; overload; {b\}
    procedure ParseClaimResponseErrorProperties(obj : TTurtleComplex; result : TFhirClaimResponseError); overload; {b\}
    function ParseClaimResponse(obj : TTurtleComplex) : TFhirClaimResponse; overload;
    procedure ParseClaimResponseProperties(obj : TTurtleComplex; result : TFhirClaimResponse); overload;
{$ENDIF FHIR_CLAIMRESPONSE}
{$IFDEF FHIR_CLINICALIMPRESSION}
    function ParseClinicalImpressionInvestigation(obj : TTurtleComplex) : TFhirClinicalImpressionInvestigation; overload; {b\}
    procedure ParseClinicalImpressionInvestigationProperties(obj : TTurtleComplex; result : TFhirClinicalImpressionInvestigation); overload; {b\}
    function ParseClinicalImpressionFinding(obj : TTurtleComplex) : TFhirClinicalImpressionFinding; overload; {b\}
    procedure ParseClinicalImpressionFindingProperties(obj : TTurtleComplex; result : TFhirClinicalImpressionFinding); overload; {b\}
    function ParseClinicalImpression(obj : TTurtleComplex) : TFhirClinicalImpression; overload;
    procedure ParseClinicalImpressionProperties(obj : TTurtleComplex; result : TFhirClinicalImpression); overload;
{$ENDIF FHIR_CLINICALIMPRESSION}
{$IFDEF FHIR_CODESYSTEM}
    function ParseCodeSystemFilter(obj : TTurtleComplex) : TFhirCodeSystemFilter; overload; {b\}
    procedure ParseCodeSystemFilterProperties(obj : TTurtleComplex; result : TFhirCodeSystemFilter); overload; {b\}
    function ParseCodeSystemProperty(obj : TTurtleComplex) : TFhirCodeSystemProperty; overload; {b\}
    procedure ParseCodeSystemPropertyProperties(obj : TTurtleComplex; result : TFhirCodeSystemProperty); overload; {b\}
    function ParseCodeSystemConcept(obj : TTurtleComplex) : TFhirCodeSystemConcept; overload; {b\}
    procedure ParseCodeSystemConceptProperties(obj : TTurtleComplex; result : TFhirCodeSystemConcept); overload; {b\}
    function ParseCodeSystemConceptDesignation(obj : TTurtleComplex) : TFhirCodeSystemConceptDesignation; overload; {b\}
    procedure ParseCodeSystemConceptDesignationProperties(obj : TTurtleComplex; result : TFhirCodeSystemConceptDesignation); overload; {b\}
    function ParseCodeSystemConceptProperty(obj : TTurtleComplex) : TFhirCodeSystemConceptProperty; overload; {b\}
    procedure ParseCodeSystemConceptPropertyProperties(obj : TTurtleComplex; result : TFhirCodeSystemConceptProperty); overload; {b\}
    function ParseCodeSystem(obj : TTurtleComplex) : TFhirCodeSystem; overload;
    procedure ParseCodeSystemProperties(obj : TTurtleComplex; result : TFhirCodeSystem); overload;
{$ENDIF FHIR_CODESYSTEM}
{$IFDEF FHIR_COMMUNICATION}
    function ParseCommunicationPayload(obj : TTurtleComplex) : TFhirCommunicationPayload; overload; {b\}
    procedure ParseCommunicationPayloadProperties(obj : TTurtleComplex; result : TFhirCommunicationPayload); overload; {b\}
    function ParseCommunication(obj : TTurtleComplex) : TFhirCommunication; overload;
    procedure ParseCommunicationProperties(obj : TTurtleComplex; result : TFhirCommunication); overload;
{$ENDIF FHIR_COMMUNICATION}
{$IFDEF FHIR_COMMUNICATIONREQUEST}
    function ParseCommunicationRequestPayload(obj : TTurtleComplex) : TFhirCommunicationRequestPayload; overload; {b\}
    procedure ParseCommunicationRequestPayloadProperties(obj : TTurtleComplex; result : TFhirCommunicationRequestPayload); overload; {b\}
    function ParseCommunicationRequest(obj : TTurtleComplex) : TFhirCommunicationRequest; overload;
    procedure ParseCommunicationRequestProperties(obj : TTurtleComplex; result : TFhirCommunicationRequest); overload;
{$ENDIF FHIR_COMMUNICATIONREQUEST}
{$IFDEF FHIR_COMPARTMENTDEFINITION}
    function ParseCompartmentDefinitionResource(obj : TTurtleComplex) : TFhirCompartmentDefinitionResource; overload; {b\}
    procedure ParseCompartmentDefinitionResourceProperties(obj : TTurtleComplex; result : TFhirCompartmentDefinitionResource); overload; {b\}
    function ParseCompartmentDefinition(obj : TTurtleComplex) : TFhirCompartmentDefinition; overload;
    procedure ParseCompartmentDefinitionProperties(obj : TTurtleComplex; result : TFhirCompartmentDefinition); overload;
{$ENDIF FHIR_COMPARTMENTDEFINITION}
{$IFDEF FHIR_COMPOSITION}
    function ParseCompositionAttester(obj : TTurtleComplex) : TFhirCompositionAttester; overload; {b\}
    procedure ParseCompositionAttesterProperties(obj : TTurtleComplex; result : TFhirCompositionAttester); overload; {b\}
    function ParseCompositionRelatesTo(obj : TTurtleComplex) : TFhirCompositionRelatesTo; overload; {b\}
    procedure ParseCompositionRelatesToProperties(obj : TTurtleComplex; result : TFhirCompositionRelatesTo); overload; {b\}
    function ParseCompositionEvent(obj : TTurtleComplex) : TFhirCompositionEvent; overload; {b\}
    procedure ParseCompositionEventProperties(obj : TTurtleComplex; result : TFhirCompositionEvent); overload; {b\}
    function ParseCompositionSection(obj : TTurtleComplex) : TFhirCompositionSection; overload; {b\}
    procedure ParseCompositionSectionProperties(obj : TTurtleComplex; result : TFhirCompositionSection); overload; {b\}
    function ParseComposition(obj : TTurtleComplex) : TFhirComposition; overload;
    procedure ParseCompositionProperties(obj : TTurtleComplex; result : TFhirComposition); overload;
{$ENDIF FHIR_COMPOSITION}
{$IFDEF FHIR_CONCEPTMAP}
    function ParseConceptMapGroup(obj : TTurtleComplex) : TFhirConceptMapGroup; overload; {b\}
    procedure ParseConceptMapGroupProperties(obj : TTurtleComplex; result : TFhirConceptMapGroup); overload; {b\}
    function ParseConceptMapGroupElement(obj : TTurtleComplex) : TFhirConceptMapGroupElement; overload; {b\}
    procedure ParseConceptMapGroupElementProperties(obj : TTurtleComplex; result : TFhirConceptMapGroupElement); overload; {b\}
    function ParseConceptMapGroupElementTarget(obj : TTurtleComplex) : TFhirConceptMapGroupElementTarget; overload; {b\}
    procedure ParseConceptMapGroupElementTargetProperties(obj : TTurtleComplex; result : TFhirConceptMapGroupElementTarget); overload; {b\}
    function ParseConceptMapGroupElementTargetDependsOn(obj : TTurtleComplex) : TFhirConceptMapGroupElementTargetDependsOn; overload; {b\}
    procedure ParseConceptMapGroupElementTargetDependsOnProperties(obj : TTurtleComplex; result : TFhirConceptMapGroupElementTargetDependsOn); overload; {b\}
    function ParseConceptMapGroupUnmapped(obj : TTurtleComplex) : TFhirConceptMapGroupUnmapped; overload; {b\}
    procedure ParseConceptMapGroupUnmappedProperties(obj : TTurtleComplex; result : TFhirConceptMapGroupUnmapped); overload; {b\}
    function ParseConceptMap(obj : TTurtleComplex) : TFhirConceptMap; overload;
    procedure ParseConceptMapProperties(obj : TTurtleComplex; result : TFhirConceptMap); overload;
{$ENDIF FHIR_CONCEPTMAP}
{$IFDEF FHIR_CONDITION}
    function ParseConditionStage(obj : TTurtleComplex) : TFhirConditionStage; overload; {b\}
    procedure ParseConditionStageProperties(obj : TTurtleComplex; result : TFhirConditionStage); overload; {b\}
    function ParseConditionEvidence(obj : TTurtleComplex) : TFhirConditionEvidence; overload; {b\}
    procedure ParseConditionEvidenceProperties(obj : TTurtleComplex; result : TFhirConditionEvidence); overload; {b\}
    function ParseCondition(obj : TTurtleComplex) : TFhirCondition; overload;
    procedure ParseConditionProperties(obj : TTurtleComplex; result : TFhirCondition); overload;
{$ENDIF FHIR_CONDITION}
{$IFDEF FHIR_CONSENT}
    function ParseConsentPolicy(obj : TTurtleComplex) : TFhirConsentPolicy; overload; {b\}
    procedure ParseConsentPolicyProperties(obj : TTurtleComplex; result : TFhirConsentPolicy); overload; {b\}
    function ParseConsentVerification(obj : TTurtleComplex) : TFhirConsentVerification; overload; {b\}
    procedure ParseConsentVerificationProperties(obj : TTurtleComplex; result : TFhirConsentVerification); overload; {b\}
    function ParseConsentProvision(obj : TTurtleComplex) : TFhirConsentProvision; overload; {b\}
    procedure ParseConsentProvisionProperties(obj : TTurtleComplex; result : TFhirConsentProvision); overload; {b\}
    function ParseConsentProvisionActor(obj : TTurtleComplex) : TFhirConsentProvisionActor; overload; {b\}
    procedure ParseConsentProvisionActorProperties(obj : TTurtleComplex; result : TFhirConsentProvisionActor); overload; {b\}
    function ParseConsentProvisionData(obj : TTurtleComplex) : TFhirConsentProvisionData; overload; {b\}
    procedure ParseConsentProvisionDataProperties(obj : TTurtleComplex; result : TFhirConsentProvisionData); overload; {b\}
    function ParseConsent(obj : TTurtleComplex) : TFhirConsent; overload;
    procedure ParseConsentProperties(obj : TTurtleComplex; result : TFhirConsent); overload;
{$ENDIF FHIR_CONSENT}
{$IFDEF FHIR_CONTRACT}
    function ParseContractContentDefinition(obj : TTurtleComplex) : TFhirContractContentDefinition; overload; {b\}
    procedure ParseContractContentDefinitionProperties(obj : TTurtleComplex; result : TFhirContractContentDefinition); overload; {b\}
    function ParseContractTerm(obj : TTurtleComplex) : TFhirContractTerm; overload; {b\}
    procedure ParseContractTermProperties(obj : TTurtleComplex; result : TFhirContractTerm); overload; {b\}
    function ParseContractTermSecurityLabel(obj : TTurtleComplex) : TFhirContractTermSecurityLabel; overload; {b\}
    procedure ParseContractTermSecurityLabelProperties(obj : TTurtleComplex; result : TFhirContractTermSecurityLabel); overload; {b\}
    function ParseContractTermOffer(obj : TTurtleComplex) : TFhirContractTermOffer; overload; {b\}
    procedure ParseContractTermOfferProperties(obj : TTurtleComplex; result : TFhirContractTermOffer); overload; {b\}
    function ParseContractTermOfferParty(obj : TTurtleComplex) : TFhirContractTermOfferParty; overload; {b\}
    procedure ParseContractTermOfferPartyProperties(obj : TTurtleComplex; result : TFhirContractTermOfferParty); overload; {b\}
    function ParseContractTermOfferAnswer(obj : TTurtleComplex) : TFhirContractTermOfferAnswer; overload; {b\}
    procedure ParseContractTermOfferAnswerProperties(obj : TTurtleComplex; result : TFhirContractTermOfferAnswer); overload; {b\}
    function ParseContractTermAsset(obj : TTurtleComplex) : TFhirContractTermAsset; overload; {b\}
    procedure ParseContractTermAssetProperties(obj : TTurtleComplex; result : TFhirContractTermAsset); overload; {b\}
    function ParseContractTermAssetContext(obj : TTurtleComplex) : TFhirContractTermAssetContext; overload; {b\}
    procedure ParseContractTermAssetContextProperties(obj : TTurtleComplex; result : TFhirContractTermAssetContext); overload; {b\}
    function ParseContractTermAssetValuedItem(obj : TTurtleComplex) : TFhirContractTermAssetValuedItem; overload; {b\}
    procedure ParseContractTermAssetValuedItemProperties(obj : TTurtleComplex; result : TFhirContractTermAssetValuedItem); overload; {b\}
    function ParseContractTermAction(obj : TTurtleComplex) : TFhirContractTermAction; overload; {b\}
    procedure ParseContractTermActionProperties(obj : TTurtleComplex; result : TFhirContractTermAction); overload; {b\}
    function ParseContractTermActionSubject(obj : TTurtleComplex) : TFhirContractTermActionSubject; overload; {b\}
    procedure ParseContractTermActionSubjectProperties(obj : TTurtleComplex; result : TFhirContractTermActionSubject); overload; {b\}
    function ParseContractSigner(obj : TTurtleComplex) : TFhirContractSigner; overload; {b\}
    procedure ParseContractSignerProperties(obj : TTurtleComplex; result : TFhirContractSigner); overload; {b\}
    function ParseContractFriendly(obj : TTurtleComplex) : TFhirContractFriendly; overload; {b\}
    procedure ParseContractFriendlyProperties(obj : TTurtleComplex; result : TFhirContractFriendly); overload; {b\}
    function ParseContractLegal(obj : TTurtleComplex) : TFhirContractLegal; overload; {b\}
    procedure ParseContractLegalProperties(obj : TTurtleComplex; result : TFhirContractLegal); overload; {b\}
    function ParseContractRule(obj : TTurtleComplex) : TFhirContractRule; overload; {b\}
    procedure ParseContractRuleProperties(obj : TTurtleComplex; result : TFhirContractRule); overload; {b\}
    function ParseContract(obj : TTurtleComplex) : TFhirContract; overload;
    procedure ParseContractProperties(obj : TTurtleComplex; result : TFhirContract); overload;
{$ENDIF FHIR_CONTRACT}
{$IFDEF FHIR_COVERAGE}
    function ParseCoverageClass(obj : TTurtleComplex) : TFhirCoverageClass; overload; {b\}
    procedure ParseCoverageClassProperties(obj : TTurtleComplex; result : TFhirCoverageClass); overload; {b\}
    function ParseCoverageCostToBeneficiary(obj : TTurtleComplex) : TFhirCoverageCostToBeneficiary; overload; {b\}
    procedure ParseCoverageCostToBeneficiaryProperties(obj : TTurtleComplex; result : TFhirCoverageCostToBeneficiary); overload; {b\}
    function ParseCoverageCostToBeneficiaryException(obj : TTurtleComplex) : TFhirCoverageCostToBeneficiaryException; overload; {b\}
    procedure ParseCoverageCostToBeneficiaryExceptionProperties(obj : TTurtleComplex; result : TFhirCoverageCostToBeneficiaryException); overload; {b\}
    function ParseCoverage(obj : TTurtleComplex) : TFhirCoverage; overload;
    procedure ParseCoverageProperties(obj : TTurtleComplex; result : TFhirCoverage); overload;
{$ENDIF FHIR_COVERAGE}
{$IFDEF FHIR_COVERAGEELIGIBILITYREQUEST}
    function ParseCoverageEligibilityRequestSupportingInfo(obj : TTurtleComplex) : TFhirCoverageEligibilityRequestSupportingInfo; overload; {b\}
    procedure ParseCoverageEligibilityRequestSupportingInfoProperties(obj : TTurtleComplex; result : TFhirCoverageEligibilityRequestSupportingInfo); overload; {b\}
    function ParseCoverageEligibilityRequestInsurance(obj : TTurtleComplex) : TFhirCoverageEligibilityRequestInsurance; overload; {b\}
    procedure ParseCoverageEligibilityRequestInsuranceProperties(obj : TTurtleComplex; result : TFhirCoverageEligibilityRequestInsurance); overload; {b\}
    function ParseCoverageEligibilityRequestItem(obj : TTurtleComplex) : TFhirCoverageEligibilityRequestItem; overload; {b\}
    procedure ParseCoverageEligibilityRequestItemProperties(obj : TTurtleComplex; result : TFhirCoverageEligibilityRequestItem); overload; {b\}
    function ParseCoverageEligibilityRequestItemDiagnosis(obj : TTurtleComplex) : TFhirCoverageEligibilityRequestItemDiagnosis; overload; {b\}
    procedure ParseCoverageEligibilityRequestItemDiagnosisProperties(obj : TTurtleComplex; result : TFhirCoverageEligibilityRequestItemDiagnosis); overload; {b\}
    function ParseCoverageEligibilityRequest(obj : TTurtleComplex) : TFhirCoverageEligibilityRequest; overload;
    procedure ParseCoverageEligibilityRequestProperties(obj : TTurtleComplex; result : TFhirCoverageEligibilityRequest); overload;
{$ENDIF FHIR_COVERAGEELIGIBILITYREQUEST}
{$IFDEF FHIR_COVERAGEELIGIBILITYRESPONSE}
    function ParseCoverageEligibilityResponseInsurance(obj : TTurtleComplex) : TFhirCoverageEligibilityResponseInsurance; overload; {b\}
    procedure ParseCoverageEligibilityResponseInsuranceProperties(obj : TTurtleComplex; result : TFhirCoverageEligibilityResponseInsurance); overload; {b\}
    function ParseCoverageEligibilityResponseInsuranceItem(obj : TTurtleComplex) : TFhirCoverageEligibilityResponseInsuranceItem; overload; {b\}
    procedure ParseCoverageEligibilityResponseInsuranceItemProperties(obj : TTurtleComplex; result : TFhirCoverageEligibilityResponseInsuranceItem); overload; {b\}
    function ParseCoverageEligibilityResponseInsuranceItemBenefit(obj : TTurtleComplex) : TFhirCoverageEligibilityResponseInsuranceItemBenefit; overload; {b\}
    procedure ParseCoverageEligibilityResponseInsuranceItemBenefitProperties(obj : TTurtleComplex; result : TFhirCoverageEligibilityResponseInsuranceItemBenefit); overload; {b\}
    function ParseCoverageEligibilityResponseError(obj : TTurtleComplex) : TFhirCoverageEligibilityResponseError; overload; {b\}
    procedure ParseCoverageEligibilityResponseErrorProperties(obj : TTurtleComplex; result : TFhirCoverageEligibilityResponseError); overload; {b\}
    function ParseCoverageEligibilityResponse(obj : TTurtleComplex) : TFhirCoverageEligibilityResponse; overload;
    procedure ParseCoverageEligibilityResponseProperties(obj : TTurtleComplex; result : TFhirCoverageEligibilityResponse); overload;
{$ENDIF FHIR_COVERAGEELIGIBILITYRESPONSE}
{$IFDEF FHIR_DETECTEDISSUE}
    function ParseDetectedIssueEvidence(obj : TTurtleComplex) : TFhirDetectedIssueEvidence; overload; {b\}
    procedure ParseDetectedIssueEvidenceProperties(obj : TTurtleComplex; result : TFhirDetectedIssueEvidence); overload; {b\}
    function ParseDetectedIssueMitigation(obj : TTurtleComplex) : TFhirDetectedIssueMitigation; overload; {b\}
    procedure ParseDetectedIssueMitigationProperties(obj : TTurtleComplex; result : TFhirDetectedIssueMitigation); overload; {b\}
    function ParseDetectedIssue(obj : TTurtleComplex) : TFhirDetectedIssue; overload;
    procedure ParseDetectedIssueProperties(obj : TTurtleComplex; result : TFhirDetectedIssue); overload;
{$ENDIF FHIR_DETECTEDISSUE}
{$IFDEF FHIR_DEVICE}
    function ParseDeviceUdiCarrier(obj : TTurtleComplex) : TFhirDeviceUdiCarrier; overload; {b\}
    procedure ParseDeviceUdiCarrierProperties(obj : TTurtleComplex; result : TFhirDeviceUdiCarrier); overload; {b\}
    function ParseDeviceDeviceName(obj : TTurtleComplex) : TFhirDeviceDeviceName; overload; {b\}
    procedure ParseDeviceDeviceNameProperties(obj : TTurtleComplex; result : TFhirDeviceDeviceName); overload; {b\}
    function ParseDeviceSpecialization(obj : TTurtleComplex) : TFhirDeviceSpecialization; overload; {b\}
    procedure ParseDeviceSpecializationProperties(obj : TTurtleComplex; result : TFhirDeviceSpecialization); overload; {b\}
    function ParseDeviceVersion(obj : TTurtleComplex) : TFhirDeviceVersion; overload; {b\}
    procedure ParseDeviceVersionProperties(obj : TTurtleComplex; result : TFhirDeviceVersion); overload; {b\}
    function ParseDeviceProperty(obj : TTurtleComplex) : TFhirDeviceProperty; overload; {b\}
    procedure ParseDevicePropertyProperties(obj : TTurtleComplex; result : TFhirDeviceProperty); overload; {b\}
    function ParseDevice(obj : TTurtleComplex) : TFhirDevice; overload;
    procedure ParseDeviceProperties(obj : TTurtleComplex; result : TFhirDevice); overload;
{$ENDIF FHIR_DEVICE}
{$IFDEF FHIR_DEVICEDEFINITION}
    function ParseDeviceDefinitionUdiDeviceIdentifier(obj : TTurtleComplex) : TFhirDeviceDefinitionUdiDeviceIdentifier; overload; {b\}
    procedure ParseDeviceDefinitionUdiDeviceIdentifierProperties(obj : TTurtleComplex; result : TFhirDeviceDefinitionUdiDeviceIdentifier); overload; {b\}
    function ParseDeviceDefinitionDeviceName(obj : TTurtleComplex) : TFhirDeviceDefinitionDeviceName; overload; {b\}
    procedure ParseDeviceDefinitionDeviceNameProperties(obj : TTurtleComplex; result : TFhirDeviceDefinitionDeviceName); overload; {b\}
    function ParseDeviceDefinitionSpecialization(obj : TTurtleComplex) : TFhirDeviceDefinitionSpecialization; overload; {b\}
    procedure ParseDeviceDefinitionSpecializationProperties(obj : TTurtleComplex; result : TFhirDeviceDefinitionSpecialization); overload; {b\}
    function ParseDeviceDefinitionCapability(obj : TTurtleComplex) : TFhirDeviceDefinitionCapability; overload; {b\}
    procedure ParseDeviceDefinitionCapabilityProperties(obj : TTurtleComplex; result : TFhirDeviceDefinitionCapability); overload; {b\}
    function ParseDeviceDefinitionProperty(obj : TTurtleComplex) : TFhirDeviceDefinitionProperty; overload; {b\}
    procedure ParseDeviceDefinitionPropertyProperties(obj : TTurtleComplex; result : TFhirDeviceDefinitionProperty); overload; {b\}
    function ParseDeviceDefinitionMaterial(obj : TTurtleComplex) : TFhirDeviceDefinitionMaterial; overload; {b\}
    procedure ParseDeviceDefinitionMaterialProperties(obj : TTurtleComplex; result : TFhirDeviceDefinitionMaterial); overload; {b\}
    function ParseDeviceDefinition(obj : TTurtleComplex) : TFhirDeviceDefinition; overload;
    procedure ParseDeviceDefinitionProperties(obj : TTurtleComplex; result : TFhirDeviceDefinition); overload;
{$ENDIF FHIR_DEVICEDEFINITION}
{$IFDEF FHIR_DEVICEMETRIC}
    function ParseDeviceMetricCalibration(obj : TTurtleComplex) : TFhirDeviceMetricCalibration; overload; {b\}
    procedure ParseDeviceMetricCalibrationProperties(obj : TTurtleComplex; result : TFhirDeviceMetricCalibration); overload; {b\}
    function ParseDeviceMetric(obj : TTurtleComplex) : TFhirDeviceMetric; overload;
    procedure ParseDeviceMetricProperties(obj : TTurtleComplex; result : TFhirDeviceMetric); overload;
{$ENDIF FHIR_DEVICEMETRIC}
{$IFDEF FHIR_DEVICEREQUEST}
    function ParseDeviceRequestParameter(obj : TTurtleComplex) : TFhirDeviceRequestParameter; overload; {b\}
    procedure ParseDeviceRequestParameterProperties(obj : TTurtleComplex; result : TFhirDeviceRequestParameter); overload; {b\}
    function ParseDeviceRequest(obj : TTurtleComplex) : TFhirDeviceRequest; overload;
    procedure ParseDeviceRequestProperties(obj : TTurtleComplex; result : TFhirDeviceRequest); overload;
{$ENDIF FHIR_DEVICEREQUEST}
{$IFDEF FHIR_DEVICEUSESTATEMENT}
    function ParseDeviceUseStatement(obj : TTurtleComplex) : TFhirDeviceUseStatement; overload;
    procedure ParseDeviceUseStatementProperties(obj : TTurtleComplex; result : TFhirDeviceUseStatement); overload;
{$ENDIF FHIR_DEVICEUSESTATEMENT}
{$IFDEF FHIR_DIAGNOSTICREPORT}
    function ParseDiagnosticReportMedia(obj : TTurtleComplex) : TFhirDiagnosticReportMedia; overload; {b\}
    procedure ParseDiagnosticReportMediaProperties(obj : TTurtleComplex; result : TFhirDiagnosticReportMedia); overload; {b\}
    function ParseDiagnosticReport(obj : TTurtleComplex) : TFhirDiagnosticReport; overload;
    procedure ParseDiagnosticReportProperties(obj : TTurtleComplex; result : TFhirDiagnosticReport); overload;
{$ENDIF FHIR_DIAGNOSTICREPORT}
{$IFDEF FHIR_DOCUMENTMANIFEST}
    function ParseDocumentManifestRelated(obj : TTurtleComplex) : TFhirDocumentManifestRelated; overload; {b\}
    procedure ParseDocumentManifestRelatedProperties(obj : TTurtleComplex; result : TFhirDocumentManifestRelated); overload; {b\}
    function ParseDocumentManifest(obj : TTurtleComplex) : TFhirDocumentManifest; overload;
    procedure ParseDocumentManifestProperties(obj : TTurtleComplex; result : TFhirDocumentManifest); overload;
{$ENDIF FHIR_DOCUMENTMANIFEST}
{$IFDEF FHIR_DOCUMENTREFERENCE}
    function ParseDocumentReferenceRelatesTo(obj : TTurtleComplex) : TFhirDocumentReferenceRelatesTo; overload; {b\}
    procedure ParseDocumentReferenceRelatesToProperties(obj : TTurtleComplex; result : TFhirDocumentReferenceRelatesTo); overload; {b\}
    function ParseDocumentReferenceContent(obj : TTurtleComplex) : TFhirDocumentReferenceContent; overload; {b\}
    procedure ParseDocumentReferenceContentProperties(obj : TTurtleComplex; result : TFhirDocumentReferenceContent); overload; {b\}
    function ParseDocumentReferenceContext(obj : TTurtleComplex) : TFhirDocumentReferenceContext; overload; {b\}
    procedure ParseDocumentReferenceContextProperties(obj : TTurtleComplex; result : TFhirDocumentReferenceContext); overload; {b\}
    function ParseDocumentReference(obj : TTurtleComplex) : TFhirDocumentReference; overload;
    procedure ParseDocumentReferenceProperties(obj : TTurtleComplex; result : TFhirDocumentReference); overload;
{$ENDIF FHIR_DOCUMENTREFERENCE}
{$IFDEF FHIR_EFFECTEVIDENCESYNTHESIS}
    function ParseEffectEvidenceSynthesisSampleSize(obj : TTurtleComplex) : TFhirEffectEvidenceSynthesisSampleSize; overload; {b\}
    procedure ParseEffectEvidenceSynthesisSampleSizeProperties(obj : TTurtleComplex; result : TFhirEffectEvidenceSynthesisSampleSize); overload; {b\}
    function ParseEffectEvidenceSynthesisResultsByExposure(obj : TTurtleComplex) : TFhirEffectEvidenceSynthesisResultsByExposure; overload; {b\}
    procedure ParseEffectEvidenceSynthesisResultsByExposureProperties(obj : TTurtleComplex; result : TFhirEffectEvidenceSynthesisResultsByExposure); overload; {b\}
    function ParseEffectEvidenceSynthesisEffectEstimate(obj : TTurtleComplex) : TFhirEffectEvidenceSynthesisEffectEstimate; overload; {b\}
    procedure ParseEffectEvidenceSynthesisEffectEstimateProperties(obj : TTurtleComplex; result : TFhirEffectEvidenceSynthesisEffectEstimate); overload; {b\}
    function ParseEffectEvidenceSynthesisEffectEstimatePrecisionEstimate(obj : TTurtleComplex) : TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate; overload; {b\}
    procedure ParseEffectEvidenceSynthesisEffectEstimatePrecisionEstimateProperties(obj : TTurtleComplex; result : TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate); overload; {b\}
    function ParseEffectEvidenceSynthesisCertainty(obj : TTurtleComplex) : TFhirEffectEvidenceSynthesisCertainty; overload; {b\}
    procedure ParseEffectEvidenceSynthesisCertaintyProperties(obj : TTurtleComplex; result : TFhirEffectEvidenceSynthesisCertainty); overload; {b\}
    function ParseEffectEvidenceSynthesisCertaintyCertaintySubcomponent(obj : TTurtleComplex) : TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent; overload; {b\}
    procedure ParseEffectEvidenceSynthesisCertaintyCertaintySubcomponentProperties(obj : TTurtleComplex; result : TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent); overload; {b\}
    function ParseEffectEvidenceSynthesis(obj : TTurtleComplex) : TFhirEffectEvidenceSynthesis; overload;
    procedure ParseEffectEvidenceSynthesisProperties(obj : TTurtleComplex; result : TFhirEffectEvidenceSynthesis); overload;
{$ENDIF FHIR_EFFECTEVIDENCESYNTHESIS}
{$IFDEF FHIR_ENCOUNTER}
    function ParseEncounterStatusHistory(obj : TTurtleComplex) : TFhirEncounterStatusHistory; overload; {b\}
    procedure ParseEncounterStatusHistoryProperties(obj : TTurtleComplex; result : TFhirEncounterStatusHistory); overload; {b\}
    function ParseEncounterClassHistory(obj : TTurtleComplex) : TFhirEncounterClassHistory; overload; {b\}
    procedure ParseEncounterClassHistoryProperties(obj : TTurtleComplex; result : TFhirEncounterClassHistory); overload; {b\}
    function ParseEncounterParticipant(obj : TTurtleComplex) : TFhirEncounterParticipant; overload; {b\}
    procedure ParseEncounterParticipantProperties(obj : TTurtleComplex; result : TFhirEncounterParticipant); overload; {b\}
    function ParseEncounterDiagnosis(obj : TTurtleComplex) : TFhirEncounterDiagnosis; overload; {b\}
    procedure ParseEncounterDiagnosisProperties(obj : TTurtleComplex; result : TFhirEncounterDiagnosis); overload; {b\}
    function ParseEncounterHospitalization(obj : TTurtleComplex) : TFhirEncounterHospitalization; overload; {b\}
    procedure ParseEncounterHospitalizationProperties(obj : TTurtleComplex; result : TFhirEncounterHospitalization); overload; {b\}
    function ParseEncounterLocation(obj : TTurtleComplex) : TFhirEncounterLocation; overload; {b\}
    procedure ParseEncounterLocationProperties(obj : TTurtleComplex; result : TFhirEncounterLocation); overload; {b\}
    function ParseEncounter(obj : TTurtleComplex) : TFhirEncounter; overload;
    procedure ParseEncounterProperties(obj : TTurtleComplex; result : TFhirEncounter); overload;
{$ENDIF FHIR_ENCOUNTER}
{$IFDEF FHIR_ENDPOINT}
    function ParseEndpoint(obj : TTurtleComplex) : TFhirEndpoint; overload;
    procedure ParseEndpointProperties(obj : TTurtleComplex; result : TFhirEndpoint); overload;
{$ENDIF FHIR_ENDPOINT}
{$IFDEF FHIR_ENROLLMENTREQUEST}
    function ParseEnrollmentRequest(obj : TTurtleComplex) : TFhirEnrollmentRequest; overload;
    procedure ParseEnrollmentRequestProperties(obj : TTurtleComplex; result : TFhirEnrollmentRequest); overload;
{$ENDIF FHIR_ENROLLMENTREQUEST}
{$IFDEF FHIR_ENROLLMENTRESPONSE}
    function ParseEnrollmentResponse(obj : TTurtleComplex) : TFhirEnrollmentResponse; overload;
    procedure ParseEnrollmentResponseProperties(obj : TTurtleComplex; result : TFhirEnrollmentResponse); overload;
{$ENDIF FHIR_ENROLLMENTRESPONSE}
{$IFDEF FHIR_EPISODEOFCARE}
    function ParseEpisodeOfCareStatusHistory(obj : TTurtleComplex) : TFhirEpisodeOfCareStatusHistory; overload; {b\}
    procedure ParseEpisodeOfCareStatusHistoryProperties(obj : TTurtleComplex; result : TFhirEpisodeOfCareStatusHistory); overload; {b\}
    function ParseEpisodeOfCareDiagnosis(obj : TTurtleComplex) : TFhirEpisodeOfCareDiagnosis; overload; {b\}
    procedure ParseEpisodeOfCareDiagnosisProperties(obj : TTurtleComplex; result : TFhirEpisodeOfCareDiagnosis); overload; {b\}
    function ParseEpisodeOfCare(obj : TTurtleComplex) : TFhirEpisodeOfCare; overload;
    procedure ParseEpisodeOfCareProperties(obj : TTurtleComplex; result : TFhirEpisodeOfCare); overload;
{$ENDIF FHIR_EPISODEOFCARE}
{$IFDEF FHIR_EVENTDEFINITION}
    function ParseEventDefinition(obj : TTurtleComplex) : TFhirEventDefinition; overload;
    procedure ParseEventDefinitionProperties(obj : TTurtleComplex; result : TFhirEventDefinition); overload;
{$ENDIF FHIR_EVENTDEFINITION}
{$IFDEF FHIR_EVIDENCE}
    function ParseEvidence(obj : TTurtleComplex) : TFhirEvidence; overload;
    procedure ParseEvidenceProperties(obj : TTurtleComplex; result : TFhirEvidence); overload;
{$ENDIF FHIR_EVIDENCE}
{$IFDEF FHIR_EVIDENCEVARIABLE}
    function ParseEvidenceVariableCharacteristic(obj : TTurtleComplex) : TFhirEvidenceVariableCharacteristic; overload; {b\}
    procedure ParseEvidenceVariableCharacteristicProperties(obj : TTurtleComplex; result : TFhirEvidenceVariableCharacteristic); overload; {b\}
    function ParseEvidenceVariable(obj : TTurtleComplex) : TFhirEvidenceVariable; overload;
    procedure ParseEvidenceVariableProperties(obj : TTurtleComplex; result : TFhirEvidenceVariable); overload;
{$ENDIF FHIR_EVIDENCEVARIABLE}
{$IFDEF FHIR_EXAMPLESCENARIO}
    function ParseExampleScenarioActor(obj : TTurtleComplex) : TFhirExampleScenarioActor; overload; {b\}
    procedure ParseExampleScenarioActorProperties(obj : TTurtleComplex; result : TFhirExampleScenarioActor); overload; {b\}
    function ParseExampleScenarioInstance(obj : TTurtleComplex) : TFhirExampleScenarioInstance; overload; {b\}
    procedure ParseExampleScenarioInstanceProperties(obj : TTurtleComplex; result : TFhirExampleScenarioInstance); overload; {b\}
    function ParseExampleScenarioInstanceVersion(obj : TTurtleComplex) : TFhirExampleScenarioInstanceVersion; overload; {b\}
    procedure ParseExampleScenarioInstanceVersionProperties(obj : TTurtleComplex; result : TFhirExampleScenarioInstanceVersion); overload; {b\}
    function ParseExampleScenarioInstanceContainedInstance(obj : TTurtleComplex) : TFhirExampleScenarioInstanceContainedInstance; overload; {b\}
    procedure ParseExampleScenarioInstanceContainedInstanceProperties(obj : TTurtleComplex; result : TFhirExampleScenarioInstanceContainedInstance); overload; {b\}
    function ParseExampleScenarioProcess(obj : TTurtleComplex) : TFhirExampleScenarioProcess; overload; {b\}
    procedure ParseExampleScenarioProcessProperties(obj : TTurtleComplex; result : TFhirExampleScenarioProcess); overload; {b\}
    function ParseExampleScenarioProcessStep(obj : TTurtleComplex) : TFhirExampleScenarioProcessStep; overload; {b\}
    procedure ParseExampleScenarioProcessStepProperties(obj : TTurtleComplex; result : TFhirExampleScenarioProcessStep); overload; {b\}
    function ParseExampleScenarioProcessStepOperation(obj : TTurtleComplex) : TFhirExampleScenarioProcessStepOperation; overload; {b\}
    procedure ParseExampleScenarioProcessStepOperationProperties(obj : TTurtleComplex; result : TFhirExampleScenarioProcessStepOperation); overload; {b\}
    function ParseExampleScenarioProcessStepAlternative(obj : TTurtleComplex) : TFhirExampleScenarioProcessStepAlternative; overload; {b\}
    procedure ParseExampleScenarioProcessStepAlternativeProperties(obj : TTurtleComplex; result : TFhirExampleScenarioProcessStepAlternative); overload; {b\}
    function ParseExampleScenario(obj : TTurtleComplex) : TFhirExampleScenario; overload;
    procedure ParseExampleScenarioProperties(obj : TTurtleComplex; result : TFhirExampleScenario); overload;
{$ENDIF FHIR_EXAMPLESCENARIO}
{$IFDEF FHIR_EXPLANATIONOFBENEFIT}
    function ParseExplanationOfBenefitRelated(obj : TTurtleComplex) : TFhirExplanationOfBenefitRelated; overload; {b\}
    procedure ParseExplanationOfBenefitRelatedProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitRelated); overload; {b\}
    function ParseExplanationOfBenefitPayee(obj : TTurtleComplex) : TFhirExplanationOfBenefitPayee; overload; {b\}
    procedure ParseExplanationOfBenefitPayeeProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitPayee); overload; {b\}
    function ParseExplanationOfBenefitCareTeam(obj : TTurtleComplex) : TFhirExplanationOfBenefitCareTeam; overload; {b\}
    procedure ParseExplanationOfBenefitCareTeamProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitCareTeam); overload; {b\}
    function ParseExplanationOfBenefitSupportingInfo(obj : TTurtleComplex) : TFhirExplanationOfBenefitSupportingInfo; overload; {b\}
    procedure ParseExplanationOfBenefitSupportingInfoProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitSupportingInfo); overload; {b\}
    function ParseExplanationOfBenefitDiagnosis(obj : TTurtleComplex) : TFhirExplanationOfBenefitDiagnosis; overload; {b\}
    procedure ParseExplanationOfBenefitDiagnosisProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitDiagnosis); overload; {b\}
    function ParseExplanationOfBenefitProcedure(obj : TTurtleComplex) : TFhirExplanationOfBenefitProcedure; overload; {b\}
    procedure ParseExplanationOfBenefitProcedureProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitProcedure); overload; {b\}
    function ParseExplanationOfBenefitInsurance(obj : TTurtleComplex) : TFhirExplanationOfBenefitInsurance; overload; {b\}
    procedure ParseExplanationOfBenefitInsuranceProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitInsurance); overload; {b\}
    function ParseExplanationOfBenefitAccident(obj : TTurtleComplex) : TFhirExplanationOfBenefitAccident; overload; {b\}
    procedure ParseExplanationOfBenefitAccidentProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitAccident); overload; {b\}
    function ParseExplanationOfBenefitItem(obj : TTurtleComplex) : TFhirExplanationOfBenefitItem; overload; {b\}
    procedure ParseExplanationOfBenefitItemProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitItem); overload; {b\}
    function ParseExplanationOfBenefitItemAdjudication(obj : TTurtleComplex) : TFhirExplanationOfBenefitItemAdjudication; overload; {b\}
    procedure ParseExplanationOfBenefitItemAdjudicationProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitItemAdjudication); overload; {b\}
    function ParseExplanationOfBenefitItemDetail(obj : TTurtleComplex) : TFhirExplanationOfBenefitItemDetail; overload; {b\}
    procedure ParseExplanationOfBenefitItemDetailProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitItemDetail); overload; {b\}
    function ParseExplanationOfBenefitItemDetailSubDetail(obj : TTurtleComplex) : TFhirExplanationOfBenefitItemDetailSubDetail; overload; {b\}
    procedure ParseExplanationOfBenefitItemDetailSubDetailProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitItemDetailSubDetail); overload; {b\}
    function ParseExplanationOfBenefitAddItem(obj : TTurtleComplex) : TFhirExplanationOfBenefitAddItem; overload; {b\}
    procedure ParseExplanationOfBenefitAddItemProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitAddItem); overload; {b\}
    function ParseExplanationOfBenefitAddItemDetail(obj : TTurtleComplex) : TFhirExplanationOfBenefitAddItemDetail; overload; {b\}
    procedure ParseExplanationOfBenefitAddItemDetailProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitAddItemDetail); overload; {b\}
    function ParseExplanationOfBenefitAddItemDetailSubDetail(obj : TTurtleComplex) : TFhirExplanationOfBenefitAddItemDetailSubDetail; overload; {b\}
    procedure ParseExplanationOfBenefitAddItemDetailSubDetailProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitAddItemDetailSubDetail); overload; {b\}
    function ParseExplanationOfBenefitTotal(obj : TTurtleComplex) : TFhirExplanationOfBenefitTotal; overload; {b\}
    procedure ParseExplanationOfBenefitTotalProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitTotal); overload; {b\}
    function ParseExplanationOfBenefitPayment(obj : TTurtleComplex) : TFhirExplanationOfBenefitPayment; overload; {b\}
    procedure ParseExplanationOfBenefitPaymentProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitPayment); overload; {b\}
    function ParseExplanationOfBenefitProcessNote(obj : TTurtleComplex) : TFhirExplanationOfBenefitProcessNote; overload; {b\}
    procedure ParseExplanationOfBenefitProcessNoteProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitProcessNote); overload; {b\}
    function ParseExplanationOfBenefitBenefitBalance(obj : TTurtleComplex) : TFhirExplanationOfBenefitBenefitBalance; overload; {b\}
    procedure ParseExplanationOfBenefitBenefitBalanceProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitBenefitBalance); overload; {b\}
    function ParseExplanationOfBenefitBenefitBalanceFinancial(obj : TTurtleComplex) : TFhirExplanationOfBenefitBenefitBalanceFinancial; overload; {b\}
    procedure ParseExplanationOfBenefitBenefitBalanceFinancialProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitBenefitBalanceFinancial); overload; {b\}
    function ParseExplanationOfBenefit(obj : TTurtleComplex) : TFhirExplanationOfBenefit; overload;
    procedure ParseExplanationOfBenefitProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefit); overload;
{$ENDIF FHIR_EXPLANATIONOFBENEFIT}
{$IFDEF FHIR_FAMILYMEMBERHISTORY}
    function ParseFamilyMemberHistoryCondition(obj : TTurtleComplex) : TFhirFamilyMemberHistoryCondition; overload; {b\}
    procedure ParseFamilyMemberHistoryConditionProperties(obj : TTurtleComplex; result : TFhirFamilyMemberHistoryCondition); overload; {b\}
    function ParseFamilyMemberHistory(obj : TTurtleComplex) : TFhirFamilyMemberHistory; overload;
    procedure ParseFamilyMemberHistoryProperties(obj : TTurtleComplex; result : TFhirFamilyMemberHistory); overload;
{$ENDIF FHIR_FAMILYMEMBERHISTORY}
{$IFDEF FHIR_FLAG}
    function ParseFlag(obj : TTurtleComplex) : TFhirFlag; overload;
    procedure ParseFlagProperties(obj : TTurtleComplex; result : TFhirFlag); overload;
{$ENDIF FHIR_FLAG}
{$IFDEF FHIR_GOAL}
    function ParseGoalTarget(obj : TTurtleComplex) : TFhirGoalTarget; overload; {b\}
    procedure ParseGoalTargetProperties(obj : TTurtleComplex; result : TFhirGoalTarget); overload; {b\}
    function ParseGoal(obj : TTurtleComplex) : TFhirGoal; overload;
    procedure ParseGoalProperties(obj : TTurtleComplex; result : TFhirGoal); overload;
{$ENDIF FHIR_GOAL}
{$IFDEF FHIR_GRAPHDEFINITION}
    function ParseGraphDefinitionLink(obj : TTurtleComplex) : TFhirGraphDefinitionLink; overload; {b\}
    procedure ParseGraphDefinitionLinkProperties(obj : TTurtleComplex; result : TFhirGraphDefinitionLink); overload; {b\}
    function ParseGraphDefinitionLinkTarget(obj : TTurtleComplex) : TFhirGraphDefinitionLinkTarget; overload; {b\}
    procedure ParseGraphDefinitionLinkTargetProperties(obj : TTurtleComplex; result : TFhirGraphDefinitionLinkTarget); overload; {b\}
    function ParseGraphDefinitionLinkTargetCompartment(obj : TTurtleComplex) : TFhirGraphDefinitionLinkTargetCompartment; overload; {b\}
    procedure ParseGraphDefinitionLinkTargetCompartmentProperties(obj : TTurtleComplex; result : TFhirGraphDefinitionLinkTargetCompartment); overload; {b\}
    function ParseGraphDefinition(obj : TTurtleComplex) : TFhirGraphDefinition; overload;
    procedure ParseGraphDefinitionProperties(obj : TTurtleComplex; result : TFhirGraphDefinition); overload;
{$ENDIF FHIR_GRAPHDEFINITION}
{$IFDEF FHIR_GROUP}
    function ParseGroupCharacteristic(obj : TTurtleComplex) : TFhirGroupCharacteristic; overload; {b\}
    procedure ParseGroupCharacteristicProperties(obj : TTurtleComplex; result : TFhirGroupCharacteristic); overload; {b\}
    function ParseGroupMember(obj : TTurtleComplex) : TFhirGroupMember; overload; {b\}
    procedure ParseGroupMemberProperties(obj : TTurtleComplex; result : TFhirGroupMember); overload; {b\}
    function ParseGroup(obj : TTurtleComplex) : TFhirGroup; overload;
    procedure ParseGroupProperties(obj : TTurtleComplex; result : TFhirGroup); overload;
{$ENDIF FHIR_GROUP}
{$IFDEF FHIR_GUIDANCERESPONSE}
    function ParseGuidanceResponse(obj : TTurtleComplex) : TFhirGuidanceResponse; overload;
    procedure ParseGuidanceResponseProperties(obj : TTurtleComplex; result : TFhirGuidanceResponse); overload;
{$ENDIF FHIR_GUIDANCERESPONSE}
{$IFDEF FHIR_HEALTHCARESERVICE}
    function ParseHealthcareServiceEligibility(obj : TTurtleComplex) : TFhirHealthcareServiceEligibility; overload; {b\}
    procedure ParseHealthcareServiceEligibilityProperties(obj : TTurtleComplex; result : TFhirHealthcareServiceEligibility); overload; {b\}
    function ParseHealthcareServiceAvailableTime(obj : TTurtleComplex) : TFhirHealthcareServiceAvailableTime; overload; {b\}
    procedure ParseHealthcareServiceAvailableTimeProperties(obj : TTurtleComplex; result : TFhirHealthcareServiceAvailableTime); overload; {b\}
    function ParseHealthcareServiceNotAvailable(obj : TTurtleComplex) : TFhirHealthcareServiceNotAvailable; overload; {b\}
    procedure ParseHealthcareServiceNotAvailableProperties(obj : TTurtleComplex; result : TFhirHealthcareServiceNotAvailable); overload; {b\}
    function ParseHealthcareService(obj : TTurtleComplex) : TFhirHealthcareService; overload;
    procedure ParseHealthcareServiceProperties(obj : TTurtleComplex; result : TFhirHealthcareService); overload;
{$ENDIF FHIR_HEALTHCARESERVICE}
{$IFDEF FHIR_IMAGINGSTUDY}
    function ParseImagingStudySeries(obj : TTurtleComplex) : TFhirImagingStudySeries; overload; {b\}
    procedure ParseImagingStudySeriesProperties(obj : TTurtleComplex; result : TFhirImagingStudySeries); overload; {b\}
    function ParseImagingStudySeriesPerformer(obj : TTurtleComplex) : TFhirImagingStudySeriesPerformer; overload; {b\}
    procedure ParseImagingStudySeriesPerformerProperties(obj : TTurtleComplex; result : TFhirImagingStudySeriesPerformer); overload; {b\}
    function ParseImagingStudySeriesInstance(obj : TTurtleComplex) : TFhirImagingStudySeriesInstance; overload; {b\}
    procedure ParseImagingStudySeriesInstanceProperties(obj : TTurtleComplex; result : TFhirImagingStudySeriesInstance); overload; {b\}
    function ParseImagingStudy(obj : TTurtleComplex) : TFhirImagingStudy; overload;
    procedure ParseImagingStudyProperties(obj : TTurtleComplex; result : TFhirImagingStudy); overload;
{$ENDIF FHIR_IMAGINGSTUDY}
{$IFDEF FHIR_IMMUNIZATION}
    function ParseImmunizationPerformer(obj : TTurtleComplex) : TFhirImmunizationPerformer; overload; {b\}
    procedure ParseImmunizationPerformerProperties(obj : TTurtleComplex; result : TFhirImmunizationPerformer); overload; {b\}
    function ParseImmunizationEducation(obj : TTurtleComplex) : TFhirImmunizationEducation; overload; {b\}
    procedure ParseImmunizationEducationProperties(obj : TTurtleComplex; result : TFhirImmunizationEducation); overload; {b\}
    function ParseImmunizationReaction(obj : TTurtleComplex) : TFhirImmunizationReaction; overload; {b\}
    procedure ParseImmunizationReactionProperties(obj : TTurtleComplex; result : TFhirImmunizationReaction); overload; {b\}
    function ParseImmunizationProtocolApplied(obj : TTurtleComplex) : TFhirImmunizationProtocolApplied; overload; {b\}
    procedure ParseImmunizationProtocolAppliedProperties(obj : TTurtleComplex; result : TFhirImmunizationProtocolApplied); overload; {b\}
    function ParseImmunization(obj : TTurtleComplex) : TFhirImmunization; overload;
    procedure ParseImmunizationProperties(obj : TTurtleComplex; result : TFhirImmunization); overload;
{$ENDIF FHIR_IMMUNIZATION}
{$IFDEF FHIR_IMMUNIZATIONEVALUATION}
    function ParseImmunizationEvaluation(obj : TTurtleComplex) : TFhirImmunizationEvaluation; overload;
    procedure ParseImmunizationEvaluationProperties(obj : TTurtleComplex; result : TFhirImmunizationEvaluation); overload;
{$ENDIF FHIR_IMMUNIZATIONEVALUATION}
{$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
    function ParseImmunizationRecommendationRecommendation(obj : TTurtleComplex) : TFhirImmunizationRecommendationRecommendation; overload; {b\}
    procedure ParseImmunizationRecommendationRecommendationProperties(obj : TTurtleComplex; result : TFhirImmunizationRecommendationRecommendation); overload; {b\}
    function ParseImmunizationRecommendationRecommendationDateCriterion(obj : TTurtleComplex) : TFhirImmunizationRecommendationRecommendationDateCriterion; overload; {b\}
    procedure ParseImmunizationRecommendationRecommendationDateCriterionProperties(obj : TTurtleComplex; result : TFhirImmunizationRecommendationRecommendationDateCriterion); overload; {b\}
    function ParseImmunizationRecommendation(obj : TTurtleComplex) : TFhirImmunizationRecommendation; overload;
    procedure ParseImmunizationRecommendationProperties(obj : TTurtleComplex; result : TFhirImmunizationRecommendation); overload;
{$ENDIF FHIR_IMMUNIZATIONRECOMMENDATION}
{$IFDEF FHIR_IMPLEMENTATIONGUIDE}
    function ParseImplementationGuideDependsOn(obj : TTurtleComplex) : TFhirImplementationGuideDependsOn; overload; {b\}
    procedure ParseImplementationGuideDependsOnProperties(obj : TTurtleComplex; result : TFhirImplementationGuideDependsOn); overload; {b\}
    function ParseImplementationGuideGlobal(obj : TTurtleComplex) : TFhirImplementationGuideGlobal; overload; {b\}
    procedure ParseImplementationGuideGlobalProperties(obj : TTurtleComplex; result : TFhirImplementationGuideGlobal); overload; {b\}
    function ParseImplementationGuideDefinition(obj : TTurtleComplex) : TFhirImplementationGuideDefinition; overload; {b\}
    procedure ParseImplementationGuideDefinitionProperties(obj : TTurtleComplex; result : TFhirImplementationGuideDefinition); overload; {b\}
    function ParseImplementationGuideDefinitionGrouping(obj : TTurtleComplex) : TFhirImplementationGuideDefinitionGrouping; overload; {b\}
    procedure ParseImplementationGuideDefinitionGroupingProperties(obj : TTurtleComplex; result : TFhirImplementationGuideDefinitionGrouping); overload; {b\}
    function ParseImplementationGuideDefinitionResource(obj : TTurtleComplex) : TFhirImplementationGuideDefinitionResource; overload; {b\}
    procedure ParseImplementationGuideDefinitionResourceProperties(obj : TTurtleComplex; result : TFhirImplementationGuideDefinitionResource); overload; {b\}
    function ParseImplementationGuideDefinitionPage(obj : TTurtleComplex) : TFhirImplementationGuideDefinitionPage; overload; {b\}
    procedure ParseImplementationGuideDefinitionPageProperties(obj : TTurtleComplex; result : TFhirImplementationGuideDefinitionPage); overload; {b\}
    function ParseImplementationGuideDefinitionParameter(obj : TTurtleComplex) : TFhirImplementationGuideDefinitionParameter; overload; {b\}
    procedure ParseImplementationGuideDefinitionParameterProperties(obj : TTurtleComplex; result : TFhirImplementationGuideDefinitionParameter); overload; {b\}
    function ParseImplementationGuideDefinitionTemplate(obj : TTurtleComplex) : TFhirImplementationGuideDefinitionTemplate; overload; {b\}
    procedure ParseImplementationGuideDefinitionTemplateProperties(obj : TTurtleComplex; result : TFhirImplementationGuideDefinitionTemplate); overload; {b\}
    function ParseImplementationGuideManifest(obj : TTurtleComplex) : TFhirImplementationGuideManifest; overload; {b\}
    procedure ParseImplementationGuideManifestProperties(obj : TTurtleComplex; result : TFhirImplementationGuideManifest); overload; {b\}
    function ParseImplementationGuideManifestResource(obj : TTurtleComplex) : TFhirImplementationGuideManifestResource; overload; {b\}
    procedure ParseImplementationGuideManifestResourceProperties(obj : TTurtleComplex; result : TFhirImplementationGuideManifestResource); overload; {b\}
    function ParseImplementationGuideManifestPage(obj : TTurtleComplex) : TFhirImplementationGuideManifestPage; overload; {b\}
    procedure ParseImplementationGuideManifestPageProperties(obj : TTurtleComplex; result : TFhirImplementationGuideManifestPage); overload; {b\}
    function ParseImplementationGuide(obj : TTurtleComplex) : TFhirImplementationGuide; overload;
    procedure ParseImplementationGuideProperties(obj : TTurtleComplex; result : TFhirImplementationGuide); overload;
{$ENDIF FHIR_IMPLEMENTATIONGUIDE}
{$IFDEF FHIR_INSURANCEPLAN}
    function ParseInsurancePlanContact(obj : TTurtleComplex) : TFhirInsurancePlanContact; overload; {b\}
    procedure ParseInsurancePlanContactProperties(obj : TTurtleComplex; result : TFhirInsurancePlanContact); overload; {b\}
    function ParseInsurancePlanCoverage(obj : TTurtleComplex) : TFhirInsurancePlanCoverage; overload; {b\}
    procedure ParseInsurancePlanCoverageProperties(obj : TTurtleComplex; result : TFhirInsurancePlanCoverage); overload; {b\}
    function ParseInsurancePlanCoverageBenefit(obj : TTurtleComplex) : TFhirInsurancePlanCoverageBenefit; overload; {b\}
    procedure ParseInsurancePlanCoverageBenefitProperties(obj : TTurtleComplex; result : TFhirInsurancePlanCoverageBenefit); overload; {b\}
    function ParseInsurancePlanCoverageBenefitLimit(obj : TTurtleComplex) : TFhirInsurancePlanCoverageBenefitLimit; overload; {b\}
    procedure ParseInsurancePlanCoverageBenefitLimitProperties(obj : TTurtleComplex; result : TFhirInsurancePlanCoverageBenefitLimit); overload; {b\}
    function ParseInsurancePlanPlan(obj : TTurtleComplex) : TFhirInsurancePlanPlan; overload; {b\}
    procedure ParseInsurancePlanPlanProperties(obj : TTurtleComplex; result : TFhirInsurancePlanPlan); overload; {b\}
    function ParseInsurancePlanPlanGeneralCost(obj : TTurtleComplex) : TFhirInsurancePlanPlanGeneralCost; overload; {b\}
    procedure ParseInsurancePlanPlanGeneralCostProperties(obj : TTurtleComplex; result : TFhirInsurancePlanPlanGeneralCost); overload; {b\}
    function ParseInsurancePlanPlanSpecificCost(obj : TTurtleComplex) : TFhirInsurancePlanPlanSpecificCost; overload; {b\}
    procedure ParseInsurancePlanPlanSpecificCostProperties(obj : TTurtleComplex; result : TFhirInsurancePlanPlanSpecificCost); overload; {b\}
    function ParseInsurancePlanPlanSpecificCostBenefit(obj : TTurtleComplex) : TFhirInsurancePlanPlanSpecificCostBenefit; overload; {b\}
    procedure ParseInsurancePlanPlanSpecificCostBenefitProperties(obj : TTurtleComplex; result : TFhirInsurancePlanPlanSpecificCostBenefit); overload; {b\}
    function ParseInsurancePlanPlanSpecificCostBenefitCost(obj : TTurtleComplex) : TFhirInsurancePlanPlanSpecificCostBenefitCost; overload; {b\}
    procedure ParseInsurancePlanPlanSpecificCostBenefitCostProperties(obj : TTurtleComplex; result : TFhirInsurancePlanPlanSpecificCostBenefitCost); overload; {b\}
    function ParseInsurancePlan(obj : TTurtleComplex) : TFhirInsurancePlan; overload;
    procedure ParseInsurancePlanProperties(obj : TTurtleComplex; result : TFhirInsurancePlan); overload;
{$ENDIF FHIR_INSURANCEPLAN}
{$IFDEF FHIR_INVOICE}
    function ParseInvoiceParticipant(obj : TTurtleComplex) : TFhirInvoiceParticipant; overload; {b\}
    procedure ParseInvoiceParticipantProperties(obj : TTurtleComplex; result : TFhirInvoiceParticipant); overload; {b\}
    function ParseInvoiceLineItem(obj : TTurtleComplex) : TFhirInvoiceLineItem; overload; {b\}
    procedure ParseInvoiceLineItemProperties(obj : TTurtleComplex; result : TFhirInvoiceLineItem); overload; {b\}
    function ParseInvoiceLineItemPriceComponent(obj : TTurtleComplex) : TFhirInvoiceLineItemPriceComponent; overload; {b\}
    procedure ParseInvoiceLineItemPriceComponentProperties(obj : TTurtleComplex; result : TFhirInvoiceLineItemPriceComponent); overload; {b\}
    function ParseInvoice(obj : TTurtleComplex) : TFhirInvoice; overload;
    procedure ParseInvoiceProperties(obj : TTurtleComplex; result : TFhirInvoice); overload;
{$ENDIF FHIR_INVOICE}
{$IFDEF FHIR_LIBRARY}
    function ParseLibrary(obj : TTurtleComplex) : TFhirLibrary; overload;
    procedure ParseLibraryProperties(obj : TTurtleComplex; result : TFhirLibrary); overload;
{$ENDIF FHIR_LIBRARY}
{$IFDEF FHIR_LINKAGE}
    function ParseLinkageItem(obj : TTurtleComplex) : TFhirLinkageItem; overload; {b\}
    procedure ParseLinkageItemProperties(obj : TTurtleComplex; result : TFhirLinkageItem); overload; {b\}
    function ParseLinkage(obj : TTurtleComplex) : TFhirLinkage; overload;
    procedure ParseLinkageProperties(obj : TTurtleComplex; result : TFhirLinkage); overload;
{$ENDIF FHIR_LINKAGE}
{$IFDEF FHIR_LIST}
    function ParseListEntry(obj : TTurtleComplex) : TFhirListEntry; overload; {b\}
    procedure ParseListEntryProperties(obj : TTurtleComplex; result : TFhirListEntry); overload; {b\}
    function ParseList(obj : TTurtleComplex) : TFhirList; overload;
    procedure ParseListProperties(obj : TTurtleComplex; result : TFhirList); overload;
{$ENDIF FHIR_LIST}
{$IFDEF FHIR_LOCATION}
    function ParseLocationPosition(obj : TTurtleComplex) : TFhirLocationPosition; overload; {b\}
    procedure ParseLocationPositionProperties(obj : TTurtleComplex; result : TFhirLocationPosition); overload; {b\}
    function ParseLocationHoursOfOperation(obj : TTurtleComplex) : TFhirLocationHoursOfOperation; overload; {b\}
    procedure ParseLocationHoursOfOperationProperties(obj : TTurtleComplex; result : TFhirLocationHoursOfOperation); overload; {b\}
    function ParseLocation(obj : TTurtleComplex) : TFhirLocation; overload;
    procedure ParseLocationProperties(obj : TTurtleComplex; result : TFhirLocation); overload;
{$ENDIF FHIR_LOCATION}
{$IFDEF FHIR_MEASURE}
    function ParseMeasureGroup(obj : TTurtleComplex) : TFhirMeasureGroup; overload; {b\}
    procedure ParseMeasureGroupProperties(obj : TTurtleComplex; result : TFhirMeasureGroup); overload; {b\}
    function ParseMeasureGroupPopulation(obj : TTurtleComplex) : TFhirMeasureGroupPopulation; overload; {b\}
    procedure ParseMeasureGroupPopulationProperties(obj : TTurtleComplex; result : TFhirMeasureGroupPopulation); overload; {b\}
    function ParseMeasureGroupStratifier(obj : TTurtleComplex) : TFhirMeasureGroupStratifier; overload; {b\}
    procedure ParseMeasureGroupStratifierProperties(obj : TTurtleComplex; result : TFhirMeasureGroupStratifier); overload; {b\}
    function ParseMeasureGroupStratifierComponent(obj : TTurtleComplex) : TFhirMeasureGroupStratifierComponent; overload; {b\}
    procedure ParseMeasureGroupStratifierComponentProperties(obj : TTurtleComplex; result : TFhirMeasureGroupStratifierComponent); overload; {b\}
    function ParseMeasureSupplementalData(obj : TTurtleComplex) : TFhirMeasureSupplementalData; overload; {b\}
    procedure ParseMeasureSupplementalDataProperties(obj : TTurtleComplex; result : TFhirMeasureSupplementalData); overload; {b\}
    function ParseMeasure(obj : TTurtleComplex) : TFhirMeasure; overload;
    procedure ParseMeasureProperties(obj : TTurtleComplex; result : TFhirMeasure); overload;
{$ENDIF FHIR_MEASURE}
{$IFDEF FHIR_MEASUREREPORT}
    function ParseMeasureReportGroup(obj : TTurtleComplex) : TFhirMeasureReportGroup; overload; {b\}
    procedure ParseMeasureReportGroupProperties(obj : TTurtleComplex; result : TFhirMeasureReportGroup); overload; {b\}
    function ParseMeasureReportGroupPopulation(obj : TTurtleComplex) : TFhirMeasureReportGroupPopulation; overload; {b\}
    procedure ParseMeasureReportGroupPopulationProperties(obj : TTurtleComplex; result : TFhirMeasureReportGroupPopulation); overload; {b\}
    function ParseMeasureReportGroupStratifier(obj : TTurtleComplex) : TFhirMeasureReportGroupStratifier; overload; {b\}
    procedure ParseMeasureReportGroupStratifierProperties(obj : TTurtleComplex; result : TFhirMeasureReportGroupStratifier); overload; {b\}
    function ParseMeasureReportGroupStratifierStratum(obj : TTurtleComplex) : TFhirMeasureReportGroupStratifierStratum; overload; {b\}
    procedure ParseMeasureReportGroupStratifierStratumProperties(obj : TTurtleComplex; result : TFhirMeasureReportGroupStratifierStratum); overload; {b\}
    function ParseMeasureReportGroupStratifierStratumComponent(obj : TTurtleComplex) : TFhirMeasureReportGroupStratifierStratumComponent; overload; {b\}
    procedure ParseMeasureReportGroupStratifierStratumComponentProperties(obj : TTurtleComplex; result : TFhirMeasureReportGroupStratifierStratumComponent); overload; {b\}
    function ParseMeasureReportGroupStratifierStratumPopulation(obj : TTurtleComplex) : TFhirMeasureReportGroupStratifierStratumPopulation; overload; {b\}
    procedure ParseMeasureReportGroupStratifierStratumPopulationProperties(obj : TTurtleComplex; result : TFhirMeasureReportGroupStratifierStratumPopulation); overload; {b\}
    function ParseMeasureReport(obj : TTurtleComplex) : TFhirMeasureReport; overload;
    procedure ParseMeasureReportProperties(obj : TTurtleComplex; result : TFhirMeasureReport); overload;
{$ENDIF FHIR_MEASUREREPORT}
{$IFDEF FHIR_MEDIA}
    function ParseMedia(obj : TTurtleComplex) : TFhirMedia; overload;
    procedure ParseMediaProperties(obj : TTurtleComplex; result : TFhirMedia); overload;
{$ENDIF FHIR_MEDIA}
{$IFDEF FHIR_MEDICATION}
    function ParseMedicationIngredient(obj : TTurtleComplex) : TFhirMedicationIngredient; overload; {b\}
    procedure ParseMedicationIngredientProperties(obj : TTurtleComplex; result : TFhirMedicationIngredient); overload; {b\}
    function ParseMedicationBatch(obj : TTurtleComplex) : TFhirMedicationBatch; overload; {b\}
    procedure ParseMedicationBatchProperties(obj : TTurtleComplex; result : TFhirMedicationBatch); overload; {b\}
    function ParseMedication(obj : TTurtleComplex) : TFhirMedication; overload;
    procedure ParseMedicationProperties(obj : TTurtleComplex; result : TFhirMedication); overload;
{$ENDIF FHIR_MEDICATION}
{$IFDEF FHIR_MEDICATIONADMINISTRATION}
    function ParseMedicationAdministrationPerformer(obj : TTurtleComplex) : TFhirMedicationAdministrationPerformer; overload; {b\}
    procedure ParseMedicationAdministrationPerformerProperties(obj : TTurtleComplex; result : TFhirMedicationAdministrationPerformer); overload; {b\}
    function ParseMedicationAdministrationDosage(obj : TTurtleComplex) : TFhirMedicationAdministrationDosage; overload; {b\}
    procedure ParseMedicationAdministrationDosageProperties(obj : TTurtleComplex; result : TFhirMedicationAdministrationDosage); overload; {b\}
    function ParseMedicationAdministration(obj : TTurtleComplex) : TFhirMedicationAdministration; overload;
    procedure ParseMedicationAdministrationProperties(obj : TTurtleComplex; result : TFhirMedicationAdministration); overload;
{$ENDIF FHIR_MEDICATIONADMINISTRATION}
{$IFDEF FHIR_MEDICATIONDISPENSE}
    function ParseMedicationDispensePerformer(obj : TTurtleComplex) : TFhirMedicationDispensePerformer; overload; {b\}
    procedure ParseMedicationDispensePerformerProperties(obj : TTurtleComplex; result : TFhirMedicationDispensePerformer); overload; {b\}
    function ParseMedicationDispenseSubstitution(obj : TTurtleComplex) : TFhirMedicationDispenseSubstitution; overload; {b\}
    procedure ParseMedicationDispenseSubstitutionProperties(obj : TTurtleComplex; result : TFhirMedicationDispenseSubstitution); overload; {b\}
    function ParseMedicationDispense(obj : TTurtleComplex) : TFhirMedicationDispense; overload;
    procedure ParseMedicationDispenseProperties(obj : TTurtleComplex; result : TFhirMedicationDispense); overload;
{$ENDIF FHIR_MEDICATIONDISPENSE}
{$IFDEF FHIR_MEDICATIONKNOWLEDGE}
    function ParseMedicationKnowledgeRelatedMedicationKnowledge(obj : TTurtleComplex) : TFhirMedicationKnowledgeRelatedMedicationKnowledge; overload; {b\}
    procedure ParseMedicationKnowledgeRelatedMedicationKnowledgeProperties(obj : TTurtleComplex; result : TFhirMedicationKnowledgeRelatedMedicationKnowledge); overload; {b\}
    function ParseMedicationKnowledgeMonograph(obj : TTurtleComplex) : TFhirMedicationKnowledgeMonograph; overload; {b\}
    procedure ParseMedicationKnowledgeMonographProperties(obj : TTurtleComplex; result : TFhirMedicationKnowledgeMonograph); overload; {b\}
    function ParseMedicationKnowledgeIngredient(obj : TTurtleComplex) : TFhirMedicationKnowledgeIngredient; overload; {b\}
    procedure ParseMedicationKnowledgeIngredientProperties(obj : TTurtleComplex; result : TFhirMedicationKnowledgeIngredient); overload; {b\}
    function ParseMedicationKnowledgeCost(obj : TTurtleComplex) : TFhirMedicationKnowledgeCost; overload; {b\}
    procedure ParseMedicationKnowledgeCostProperties(obj : TTurtleComplex; result : TFhirMedicationKnowledgeCost); overload; {b\}
    function ParseMedicationKnowledgeMonitoringProgram(obj : TTurtleComplex) : TFhirMedicationKnowledgeMonitoringProgram; overload; {b\}
    procedure ParseMedicationKnowledgeMonitoringProgramProperties(obj : TTurtleComplex; result : TFhirMedicationKnowledgeMonitoringProgram); overload; {b\}
    function ParseMedicationKnowledgeAdministrationGuidelines(obj : TTurtleComplex) : TFhirMedicationKnowledgeAdministrationGuidelines; overload; {b\}
    procedure ParseMedicationKnowledgeAdministrationGuidelinesProperties(obj : TTurtleComplex; result : TFhirMedicationKnowledgeAdministrationGuidelines); overload; {b\}
    function ParseMedicationKnowledgeAdministrationGuidelinesDosage(obj : TTurtleComplex) : TFhirMedicationKnowledgeAdministrationGuidelinesDosage; overload; {b\}
    procedure ParseMedicationKnowledgeAdministrationGuidelinesDosageProperties(obj : TTurtleComplex; result : TFhirMedicationKnowledgeAdministrationGuidelinesDosage); overload; {b\}
    function ParseMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics(obj : TTurtleComplex) : TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics; overload; {b\}
    procedure ParseMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsProperties(obj : TTurtleComplex; result : TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics); overload; {b\}
    function ParseMedicationKnowledgeMedicineClassification(obj : TTurtleComplex) : TFhirMedicationKnowledgeMedicineClassification; overload; {b\}
    procedure ParseMedicationKnowledgeMedicineClassificationProperties(obj : TTurtleComplex; result : TFhirMedicationKnowledgeMedicineClassification); overload; {b\}
    function ParseMedicationKnowledgePackaging(obj : TTurtleComplex) : TFhirMedicationKnowledgePackaging; overload; {b\}
    procedure ParseMedicationKnowledgePackagingProperties(obj : TTurtleComplex; result : TFhirMedicationKnowledgePackaging); overload; {b\}
    function ParseMedicationKnowledgeDrugCharacteristic(obj : TTurtleComplex) : TFhirMedicationKnowledgeDrugCharacteristic; overload; {b\}
    procedure ParseMedicationKnowledgeDrugCharacteristicProperties(obj : TTurtleComplex; result : TFhirMedicationKnowledgeDrugCharacteristic); overload; {b\}
    function ParseMedicationKnowledgeRegulatory(obj : TTurtleComplex) : TFhirMedicationKnowledgeRegulatory; overload; {b\}
    procedure ParseMedicationKnowledgeRegulatoryProperties(obj : TTurtleComplex; result : TFhirMedicationKnowledgeRegulatory); overload; {b\}
    function ParseMedicationKnowledgeRegulatorySubstitution(obj : TTurtleComplex) : TFhirMedicationKnowledgeRegulatorySubstitution; overload; {b\}
    procedure ParseMedicationKnowledgeRegulatorySubstitutionProperties(obj : TTurtleComplex; result : TFhirMedicationKnowledgeRegulatorySubstitution); overload; {b\}
    function ParseMedicationKnowledgeRegulatorySchedule(obj : TTurtleComplex) : TFhirMedicationKnowledgeRegulatorySchedule; overload; {b\}
    procedure ParseMedicationKnowledgeRegulatoryScheduleProperties(obj : TTurtleComplex; result : TFhirMedicationKnowledgeRegulatorySchedule); overload; {b\}
    function ParseMedicationKnowledgeRegulatoryMaxDispense(obj : TTurtleComplex) : TFhirMedicationKnowledgeRegulatoryMaxDispense; overload; {b\}
    procedure ParseMedicationKnowledgeRegulatoryMaxDispenseProperties(obj : TTurtleComplex; result : TFhirMedicationKnowledgeRegulatoryMaxDispense); overload; {b\}
    function ParseMedicationKnowledgeKinetics(obj : TTurtleComplex) : TFhirMedicationKnowledgeKinetics; overload; {b\}
    procedure ParseMedicationKnowledgeKineticsProperties(obj : TTurtleComplex; result : TFhirMedicationKnowledgeKinetics); overload; {b\}
    function ParseMedicationKnowledge(obj : TTurtleComplex) : TFhirMedicationKnowledge; overload;
    procedure ParseMedicationKnowledgeProperties(obj : TTurtleComplex; result : TFhirMedicationKnowledge); overload;
{$ENDIF FHIR_MEDICATIONKNOWLEDGE}
{$IFDEF FHIR_MEDICATIONREQUEST}
    function ParseMedicationRequestDispenseRequest(obj : TTurtleComplex) : TFhirMedicationRequestDispenseRequest; overload; {b\}
    procedure ParseMedicationRequestDispenseRequestProperties(obj : TTurtleComplex; result : TFhirMedicationRequestDispenseRequest); overload; {b\}
    function ParseMedicationRequestDispenseRequestInitialFill(obj : TTurtleComplex) : TFhirMedicationRequestDispenseRequestInitialFill; overload; {b\}
    procedure ParseMedicationRequestDispenseRequestInitialFillProperties(obj : TTurtleComplex; result : TFhirMedicationRequestDispenseRequestInitialFill); overload; {b\}
    function ParseMedicationRequestSubstitution(obj : TTurtleComplex) : TFhirMedicationRequestSubstitution; overload; {b\}
    procedure ParseMedicationRequestSubstitutionProperties(obj : TTurtleComplex; result : TFhirMedicationRequestSubstitution); overload; {b\}
    function ParseMedicationRequest(obj : TTurtleComplex) : TFhirMedicationRequest; overload;
    procedure ParseMedicationRequestProperties(obj : TTurtleComplex; result : TFhirMedicationRequest); overload;
{$ENDIF FHIR_MEDICATIONREQUEST}
{$IFDEF FHIR_MEDICATIONSTATEMENT}
    function ParseMedicationStatement(obj : TTurtleComplex) : TFhirMedicationStatement; overload;
    procedure ParseMedicationStatementProperties(obj : TTurtleComplex; result : TFhirMedicationStatement); overload;
{$ENDIF FHIR_MEDICATIONSTATEMENT}
{$IFDEF FHIR_MEDICINALPRODUCT}
    function ParseMedicinalProductName(obj : TTurtleComplex) : TFhirMedicinalProductName; overload; {b\}
    procedure ParseMedicinalProductNameProperties(obj : TTurtleComplex; result : TFhirMedicinalProductName); overload; {b\}
    function ParseMedicinalProductNameNamePart(obj : TTurtleComplex) : TFhirMedicinalProductNameNamePart; overload; {b\}
    procedure ParseMedicinalProductNameNamePartProperties(obj : TTurtleComplex; result : TFhirMedicinalProductNameNamePart); overload; {b\}
    function ParseMedicinalProductNameCountryLanguage(obj : TTurtleComplex) : TFhirMedicinalProductNameCountryLanguage; overload; {b\}
    procedure ParseMedicinalProductNameCountryLanguageProperties(obj : TTurtleComplex; result : TFhirMedicinalProductNameCountryLanguage); overload; {b\}
    function ParseMedicinalProductManufacturingBusinessOperation(obj : TTurtleComplex) : TFhirMedicinalProductManufacturingBusinessOperation; overload; {b\}
    procedure ParseMedicinalProductManufacturingBusinessOperationProperties(obj : TTurtleComplex; result : TFhirMedicinalProductManufacturingBusinessOperation); overload; {b\}
    function ParseMedicinalProductSpecialDesignation(obj : TTurtleComplex) : TFhirMedicinalProductSpecialDesignation; overload; {b\}
    procedure ParseMedicinalProductSpecialDesignationProperties(obj : TTurtleComplex; result : TFhirMedicinalProductSpecialDesignation); overload; {b\}
    function ParseMedicinalProduct(obj : TTurtleComplex) : TFhirMedicinalProduct; overload;
    procedure ParseMedicinalProductProperties(obj : TTurtleComplex; result : TFhirMedicinalProduct); overload;
{$ENDIF FHIR_MEDICINALPRODUCT}
{$IFDEF FHIR_MEDICINALPRODUCTAUTHORIZATION}
    function ParseMedicinalProductAuthorizationJurisdictionalAuthorization(obj : TTurtleComplex) : TFhirMedicinalProductAuthorizationJurisdictionalAuthorization; overload; {b\}
    procedure ParseMedicinalProductAuthorizationJurisdictionalAuthorizationProperties(obj : TTurtleComplex; result : TFhirMedicinalProductAuthorizationJurisdictionalAuthorization); overload; {b\}
    function ParseMedicinalProductAuthorizationProcedure(obj : TTurtleComplex) : TFhirMedicinalProductAuthorizationProcedure; overload; {b\}
    procedure ParseMedicinalProductAuthorizationProcedureProperties(obj : TTurtleComplex; result : TFhirMedicinalProductAuthorizationProcedure); overload; {b\}
    function ParseMedicinalProductAuthorization(obj : TTurtleComplex) : TFhirMedicinalProductAuthorization; overload;
    procedure ParseMedicinalProductAuthorizationProperties(obj : TTurtleComplex; result : TFhirMedicinalProductAuthorization); overload;
{$ENDIF FHIR_MEDICINALPRODUCTAUTHORIZATION}
{$IFDEF FHIR_MEDICINALPRODUCTCONTRAINDICATION}
    function ParseMedicinalProductContraindicationOtherTherapy(obj : TTurtleComplex) : TFhirMedicinalProductContraindicationOtherTherapy; overload; {b\}
    procedure ParseMedicinalProductContraindicationOtherTherapyProperties(obj : TTurtleComplex; result : TFhirMedicinalProductContraindicationOtherTherapy); overload; {b\}
    function ParseMedicinalProductContraindication(obj : TTurtleComplex) : TFhirMedicinalProductContraindication; overload;
    procedure ParseMedicinalProductContraindicationProperties(obj : TTurtleComplex; result : TFhirMedicinalProductContraindication); overload;
{$ENDIF FHIR_MEDICINALPRODUCTCONTRAINDICATION}
{$IFDEF FHIR_MEDICINALPRODUCTINDICATION}
    function ParseMedicinalProductIndicationOtherTherapy(obj : TTurtleComplex) : TFhirMedicinalProductIndicationOtherTherapy; overload; {b\}
    procedure ParseMedicinalProductIndicationOtherTherapyProperties(obj : TTurtleComplex; result : TFhirMedicinalProductIndicationOtherTherapy); overload; {b\}
    function ParseMedicinalProductIndication(obj : TTurtleComplex) : TFhirMedicinalProductIndication; overload;
    procedure ParseMedicinalProductIndicationProperties(obj : TTurtleComplex; result : TFhirMedicinalProductIndication); overload;
{$ENDIF FHIR_MEDICINALPRODUCTINDICATION}
{$IFDEF FHIR_MEDICINALPRODUCTINGREDIENT}
    function ParseMedicinalProductIngredientSpecifiedSubstance(obj : TTurtleComplex) : TFhirMedicinalProductIngredientSpecifiedSubstance; overload; {b\}
    procedure ParseMedicinalProductIngredientSpecifiedSubstanceProperties(obj : TTurtleComplex; result : TFhirMedicinalProductIngredientSpecifiedSubstance); overload; {b\}
    function ParseMedicinalProductIngredientSpecifiedSubstanceStrength(obj : TTurtleComplex) : TFhirMedicinalProductIngredientSpecifiedSubstanceStrength; overload; {b\}
    procedure ParseMedicinalProductIngredientSpecifiedSubstanceStrengthProperties(obj : TTurtleComplex; result : TFhirMedicinalProductIngredientSpecifiedSubstanceStrength); overload; {b\}
    function ParseMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength(obj : TTurtleComplex) : TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength; overload; {b\}
    procedure ParseMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrengthProperties(obj : TTurtleComplex; result : TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength); overload; {b\}
    function ParseMedicinalProductIngredientSubstance(obj : TTurtleComplex) : TFhirMedicinalProductIngredientSubstance; overload; {b\}
    procedure ParseMedicinalProductIngredientSubstanceProperties(obj : TTurtleComplex; result : TFhirMedicinalProductIngredientSubstance); overload; {b\}
    function ParseMedicinalProductIngredient(obj : TTurtleComplex) : TFhirMedicinalProductIngredient; overload;
    procedure ParseMedicinalProductIngredientProperties(obj : TTurtleComplex; result : TFhirMedicinalProductIngredient); overload;
{$ENDIF FHIR_MEDICINALPRODUCTINGREDIENT}
{$IFDEF FHIR_MEDICINALPRODUCTINTERACTION}
    function ParseMedicinalProductInteractionInteractant(obj : TTurtleComplex) : TFhirMedicinalProductInteractionInteractant; overload; {b\}
    procedure ParseMedicinalProductInteractionInteractantProperties(obj : TTurtleComplex; result : TFhirMedicinalProductInteractionInteractant); overload; {b\}
    function ParseMedicinalProductInteraction(obj : TTurtleComplex) : TFhirMedicinalProductInteraction; overload;
    procedure ParseMedicinalProductInteractionProperties(obj : TTurtleComplex; result : TFhirMedicinalProductInteraction); overload;
{$ENDIF FHIR_MEDICINALPRODUCTINTERACTION}
{$IFDEF FHIR_MEDICINALPRODUCTMANUFACTURED}
    function ParseMedicinalProductManufactured(obj : TTurtleComplex) : TFhirMedicinalProductManufactured; overload;
    procedure ParseMedicinalProductManufacturedProperties(obj : TTurtleComplex; result : TFhirMedicinalProductManufactured); overload;
{$ENDIF FHIR_MEDICINALPRODUCTMANUFACTURED}
{$IFDEF FHIR_MEDICINALPRODUCTPACKAGED}
    function ParseMedicinalProductPackagedBatchIdentifier(obj : TTurtleComplex) : TFhirMedicinalProductPackagedBatchIdentifier; overload; {b\}
    procedure ParseMedicinalProductPackagedBatchIdentifierProperties(obj : TTurtleComplex; result : TFhirMedicinalProductPackagedBatchIdentifier); overload; {b\}
    function ParseMedicinalProductPackagedPackageItem(obj : TTurtleComplex) : TFhirMedicinalProductPackagedPackageItem; overload; {b\}
    procedure ParseMedicinalProductPackagedPackageItemProperties(obj : TTurtleComplex; result : TFhirMedicinalProductPackagedPackageItem); overload; {b\}
    function ParseMedicinalProductPackaged(obj : TTurtleComplex) : TFhirMedicinalProductPackaged; overload;
    procedure ParseMedicinalProductPackagedProperties(obj : TTurtleComplex; result : TFhirMedicinalProductPackaged); overload;
{$ENDIF FHIR_MEDICINALPRODUCTPACKAGED}
{$IFDEF FHIR_MEDICINALPRODUCTPHARMACEUTICAL}
    function ParseMedicinalProductPharmaceuticalCharacteristics(obj : TTurtleComplex) : TFhirMedicinalProductPharmaceuticalCharacteristics; overload; {b\}
    procedure ParseMedicinalProductPharmaceuticalCharacteristicsProperties(obj : TTurtleComplex; result : TFhirMedicinalProductPharmaceuticalCharacteristics); overload; {b\}
    function ParseMedicinalProductPharmaceuticalRouteOfAdministration(obj : TTurtleComplex) : TFhirMedicinalProductPharmaceuticalRouteOfAdministration; overload; {b\}
    procedure ParseMedicinalProductPharmaceuticalRouteOfAdministrationProperties(obj : TTurtleComplex; result : TFhirMedicinalProductPharmaceuticalRouteOfAdministration); overload; {b\}
    function ParseMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies(obj : TTurtleComplex) : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies; overload; {b\}
    procedure ParseMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesProperties(obj : TTurtleComplex; result : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies); overload; {b\}
    function ParseMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod(obj : TTurtleComplex) : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod; overload; {b\}
    procedure ParseMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriodProperties(obj : TTurtleComplex; result : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod); overload; {b\}
    function ParseMedicinalProductPharmaceutical(obj : TTurtleComplex) : TFhirMedicinalProductPharmaceutical; overload;
    procedure ParseMedicinalProductPharmaceuticalProperties(obj : TTurtleComplex; result : TFhirMedicinalProductPharmaceutical); overload;
{$ENDIF FHIR_MEDICINALPRODUCTPHARMACEUTICAL}
{$IFDEF FHIR_MEDICINALPRODUCTUNDESIRABLEEFFECT}
    function ParseMedicinalProductUndesirableEffect(obj : TTurtleComplex) : TFhirMedicinalProductUndesirableEffect; overload;
    procedure ParseMedicinalProductUndesirableEffectProperties(obj : TTurtleComplex; result : TFhirMedicinalProductUndesirableEffect); overload;
{$ENDIF FHIR_MEDICINALPRODUCTUNDESIRABLEEFFECT}
{$IFDEF FHIR_MESSAGEDEFINITION}
    function ParseMessageDefinitionFocus(obj : TTurtleComplex) : TFhirMessageDefinitionFocus; overload; {b\}
    procedure ParseMessageDefinitionFocusProperties(obj : TTurtleComplex; result : TFhirMessageDefinitionFocus); overload; {b\}
    function ParseMessageDefinitionAllowedResponse(obj : TTurtleComplex) : TFhirMessageDefinitionAllowedResponse; overload; {b\}
    procedure ParseMessageDefinitionAllowedResponseProperties(obj : TTurtleComplex; result : TFhirMessageDefinitionAllowedResponse); overload; {b\}
    function ParseMessageDefinition(obj : TTurtleComplex) : TFhirMessageDefinition; overload;
    procedure ParseMessageDefinitionProperties(obj : TTurtleComplex; result : TFhirMessageDefinition); overload;
{$ENDIF FHIR_MESSAGEDEFINITION}
{$IFDEF FHIR_MESSAGEHEADER}
    function ParseMessageHeaderDestination(obj : TTurtleComplex) : TFhirMessageHeaderDestination; overload; {b\}
    procedure ParseMessageHeaderDestinationProperties(obj : TTurtleComplex; result : TFhirMessageHeaderDestination); overload; {b\}
    function ParseMessageHeaderSource(obj : TTurtleComplex) : TFhirMessageHeaderSource; overload; {b\}
    procedure ParseMessageHeaderSourceProperties(obj : TTurtleComplex; result : TFhirMessageHeaderSource); overload; {b\}
    function ParseMessageHeaderResponse(obj : TTurtleComplex) : TFhirMessageHeaderResponse; overload; {b\}
    procedure ParseMessageHeaderResponseProperties(obj : TTurtleComplex; result : TFhirMessageHeaderResponse); overload; {b\}
    function ParseMessageHeader(obj : TTurtleComplex) : TFhirMessageHeader; overload;
    procedure ParseMessageHeaderProperties(obj : TTurtleComplex; result : TFhirMessageHeader); overload;
{$ENDIF FHIR_MESSAGEHEADER}
{$IFDEF FHIR_MOLECULARSEQUENCE}
    function ParseMolecularSequenceReferenceSeq(obj : TTurtleComplex) : TFhirMolecularSequenceReferenceSeq; overload; {b\}
    procedure ParseMolecularSequenceReferenceSeqProperties(obj : TTurtleComplex; result : TFhirMolecularSequenceReferenceSeq); overload; {b\}
    function ParseMolecularSequenceVariant(obj : TTurtleComplex) : TFhirMolecularSequenceVariant; overload; {b\}
    procedure ParseMolecularSequenceVariantProperties(obj : TTurtleComplex; result : TFhirMolecularSequenceVariant); overload; {b\}
    function ParseMolecularSequenceQuality(obj : TTurtleComplex) : TFhirMolecularSequenceQuality; overload; {b\}
    procedure ParseMolecularSequenceQualityProperties(obj : TTurtleComplex; result : TFhirMolecularSequenceQuality); overload; {b\}
    function ParseMolecularSequenceQualityRoc(obj : TTurtleComplex) : TFhirMolecularSequenceQualityRoc; overload; {b\}
    procedure ParseMolecularSequenceQualityRocProperties(obj : TTurtleComplex; result : TFhirMolecularSequenceQualityRoc); overload; {b\}
    function ParseMolecularSequenceRepository(obj : TTurtleComplex) : TFhirMolecularSequenceRepository; overload; {b\}
    procedure ParseMolecularSequenceRepositoryProperties(obj : TTurtleComplex; result : TFhirMolecularSequenceRepository); overload; {b\}
    function ParseMolecularSequenceStructureVariant(obj : TTurtleComplex) : TFhirMolecularSequenceStructureVariant; overload; {b\}
    procedure ParseMolecularSequenceStructureVariantProperties(obj : TTurtleComplex; result : TFhirMolecularSequenceStructureVariant); overload; {b\}
    function ParseMolecularSequenceStructureVariantOuter(obj : TTurtleComplex) : TFhirMolecularSequenceStructureVariantOuter; overload; {b\}
    procedure ParseMolecularSequenceStructureVariantOuterProperties(obj : TTurtleComplex; result : TFhirMolecularSequenceStructureVariantOuter); overload; {b\}
    function ParseMolecularSequenceStructureVariantInner(obj : TTurtleComplex) : TFhirMolecularSequenceStructureVariantInner; overload; {b\}
    procedure ParseMolecularSequenceStructureVariantInnerProperties(obj : TTurtleComplex; result : TFhirMolecularSequenceStructureVariantInner); overload; {b\}
    function ParseMolecularSequence(obj : TTurtleComplex) : TFhirMolecularSequence; overload;
    procedure ParseMolecularSequenceProperties(obj : TTurtleComplex; result : TFhirMolecularSequence); overload;
{$ENDIF FHIR_MOLECULARSEQUENCE}
{$IFDEF FHIR_NAMINGSYSTEM}
    function ParseNamingSystemUniqueId(obj : TTurtleComplex) : TFhirNamingSystemUniqueId; overload; {b\}
    procedure ParseNamingSystemUniqueIdProperties(obj : TTurtleComplex; result : TFhirNamingSystemUniqueId); overload; {b\}
    function ParseNamingSystem(obj : TTurtleComplex) : TFhirNamingSystem; overload;
    procedure ParseNamingSystemProperties(obj : TTurtleComplex; result : TFhirNamingSystem); overload;
{$ENDIF FHIR_NAMINGSYSTEM}
{$IFDEF FHIR_NUTRITIONORDER}
    function ParseNutritionOrderOralDiet(obj : TTurtleComplex) : TFhirNutritionOrderOralDiet; overload; {b\}
    procedure ParseNutritionOrderOralDietProperties(obj : TTurtleComplex; result : TFhirNutritionOrderOralDiet); overload; {b\}
    function ParseNutritionOrderOralDietNutrient(obj : TTurtleComplex) : TFhirNutritionOrderOralDietNutrient; overload; {b\}
    procedure ParseNutritionOrderOralDietNutrientProperties(obj : TTurtleComplex; result : TFhirNutritionOrderOralDietNutrient); overload; {b\}
    function ParseNutritionOrderOralDietTexture(obj : TTurtleComplex) : TFhirNutritionOrderOralDietTexture; overload; {b\}
    procedure ParseNutritionOrderOralDietTextureProperties(obj : TTurtleComplex; result : TFhirNutritionOrderOralDietTexture); overload; {b\}
    function ParseNutritionOrderSupplement(obj : TTurtleComplex) : TFhirNutritionOrderSupplement; overload; {b\}
    procedure ParseNutritionOrderSupplementProperties(obj : TTurtleComplex; result : TFhirNutritionOrderSupplement); overload; {b\}
    function ParseNutritionOrderEnteralFormula(obj : TTurtleComplex) : TFhirNutritionOrderEnteralFormula; overload; {b\}
    procedure ParseNutritionOrderEnteralFormulaProperties(obj : TTurtleComplex; result : TFhirNutritionOrderEnteralFormula); overload; {b\}
    function ParseNutritionOrderEnteralFormulaAdministration(obj : TTurtleComplex) : TFhirNutritionOrderEnteralFormulaAdministration; overload; {b\}
    procedure ParseNutritionOrderEnteralFormulaAdministrationProperties(obj : TTurtleComplex; result : TFhirNutritionOrderEnteralFormulaAdministration); overload; {b\}
    function ParseNutritionOrder(obj : TTurtleComplex) : TFhirNutritionOrder; overload;
    procedure ParseNutritionOrderProperties(obj : TTurtleComplex; result : TFhirNutritionOrder); overload;
{$ENDIF FHIR_NUTRITIONORDER}
{$IFDEF FHIR_OBSERVATION}
    function ParseObservationReferenceRange(obj : TTurtleComplex) : TFhirObservationReferenceRange; overload; {b\}
    procedure ParseObservationReferenceRangeProperties(obj : TTurtleComplex; result : TFhirObservationReferenceRange); overload; {b\}
    function ParseObservationComponent(obj : TTurtleComplex) : TFhirObservationComponent; overload; {b\}
    procedure ParseObservationComponentProperties(obj : TTurtleComplex; result : TFhirObservationComponent); overload; {b\}
    function ParseObservation(obj : TTurtleComplex) : TFhirObservation; overload;
    procedure ParseObservationProperties(obj : TTurtleComplex; result : TFhirObservation); overload;
{$ENDIF FHIR_OBSERVATION}
{$IFDEF FHIR_OBSERVATIONDEFINITION}
    function ParseObservationDefinitionQuantitativeDetails(obj : TTurtleComplex) : TFhirObservationDefinitionQuantitativeDetails; overload; {b\}
    procedure ParseObservationDefinitionQuantitativeDetailsProperties(obj : TTurtleComplex; result : TFhirObservationDefinitionQuantitativeDetails); overload; {b\}
    function ParseObservationDefinitionQualifiedInterval(obj : TTurtleComplex) : TFhirObservationDefinitionQualifiedInterval; overload; {b\}
    procedure ParseObservationDefinitionQualifiedIntervalProperties(obj : TTurtleComplex; result : TFhirObservationDefinitionQualifiedInterval); overload; {b\}
    function ParseObservationDefinition(obj : TTurtleComplex) : TFhirObservationDefinition; overload;
    procedure ParseObservationDefinitionProperties(obj : TTurtleComplex; result : TFhirObservationDefinition); overload;
{$ENDIF FHIR_OBSERVATIONDEFINITION}
{$IFDEF FHIR_OPERATIONDEFINITION}
    function ParseOperationDefinitionParameter(obj : TTurtleComplex) : TFhirOperationDefinitionParameter; overload; {b\}
    procedure ParseOperationDefinitionParameterProperties(obj : TTurtleComplex; result : TFhirOperationDefinitionParameter); overload; {b\}
    function ParseOperationDefinitionParameterBinding(obj : TTurtleComplex) : TFhirOperationDefinitionParameterBinding; overload; {b\}
    procedure ParseOperationDefinitionParameterBindingProperties(obj : TTurtleComplex; result : TFhirOperationDefinitionParameterBinding); overload; {b\}
    function ParseOperationDefinitionParameterReferencedFrom(obj : TTurtleComplex) : TFhirOperationDefinitionParameterReferencedFrom; overload; {b\}
    procedure ParseOperationDefinitionParameterReferencedFromProperties(obj : TTurtleComplex; result : TFhirOperationDefinitionParameterReferencedFrom); overload; {b\}
    function ParseOperationDefinitionOverload(obj : TTurtleComplex) : TFhirOperationDefinitionOverload; overload; {b\}
    procedure ParseOperationDefinitionOverloadProperties(obj : TTurtleComplex; result : TFhirOperationDefinitionOverload); overload; {b\}
    function ParseOperationDefinition(obj : TTurtleComplex) : TFhirOperationDefinition; overload;
    procedure ParseOperationDefinitionProperties(obj : TTurtleComplex; result : TFhirOperationDefinition); overload;
{$ENDIF FHIR_OPERATIONDEFINITION}
{$IFDEF FHIR_OPERATIONOUTCOME}
    function ParseOperationOutcomeIssue(obj : TTurtleComplex) : TFhirOperationOutcomeIssue; overload; {b\}
    procedure ParseOperationOutcomeIssueProperties(obj : TTurtleComplex; result : TFhirOperationOutcomeIssue); overload; {b\}
    function ParseOperationOutcome(obj : TTurtleComplex) : TFhirOperationOutcome; overload;
    procedure ParseOperationOutcomeProperties(obj : TTurtleComplex; result : TFhirOperationOutcome); overload;
{$ENDIF FHIR_OPERATIONOUTCOME}
{$IFDEF FHIR_ORGANIZATION}
    function ParseOrganizationContact(obj : TTurtleComplex) : TFhirOrganizationContact; overload; {b\}
    procedure ParseOrganizationContactProperties(obj : TTurtleComplex; result : TFhirOrganizationContact); overload; {b\}
    function ParseOrganization(obj : TTurtleComplex) : TFhirOrganization; overload;
    procedure ParseOrganizationProperties(obj : TTurtleComplex; result : TFhirOrganization); overload;
{$ENDIF FHIR_ORGANIZATION}
{$IFDEF FHIR_ORGANIZATIONAFFILIATION}
    function ParseOrganizationAffiliation(obj : TTurtleComplex) : TFhirOrganizationAffiliation; overload;
    procedure ParseOrganizationAffiliationProperties(obj : TTurtleComplex; result : TFhirOrganizationAffiliation); overload;
{$ENDIF FHIR_ORGANIZATIONAFFILIATION}
{$IFDEF FHIR_PATIENT}
    function ParsePatientContact(obj : TTurtleComplex) : TFhirPatientContact; overload; {b\}
    procedure ParsePatientContactProperties(obj : TTurtleComplex; result : TFhirPatientContact); overload; {b\}
    function ParsePatientCommunication(obj : TTurtleComplex) : TFhirPatientCommunication; overload; {b\}
    procedure ParsePatientCommunicationProperties(obj : TTurtleComplex; result : TFhirPatientCommunication); overload; {b\}
    function ParsePatientLink(obj : TTurtleComplex) : TFhirPatientLink; overload; {b\}
    procedure ParsePatientLinkProperties(obj : TTurtleComplex; result : TFhirPatientLink); overload; {b\}
    function ParsePatient(obj : TTurtleComplex) : TFhirPatient; overload;
    procedure ParsePatientProperties(obj : TTurtleComplex; result : TFhirPatient); overload;
{$ENDIF FHIR_PATIENT}
{$IFDEF FHIR_PAYMENTNOTICE}
    function ParsePaymentNotice(obj : TTurtleComplex) : TFhirPaymentNotice; overload;
    procedure ParsePaymentNoticeProperties(obj : TTurtleComplex; result : TFhirPaymentNotice); overload;
{$ENDIF FHIR_PAYMENTNOTICE}
{$IFDEF FHIR_PAYMENTRECONCILIATION}
    function ParsePaymentReconciliationDetail(obj : TTurtleComplex) : TFhirPaymentReconciliationDetail; overload; {b\}
    procedure ParsePaymentReconciliationDetailProperties(obj : TTurtleComplex; result : TFhirPaymentReconciliationDetail); overload; {b\}
    function ParsePaymentReconciliationProcessNote(obj : TTurtleComplex) : TFhirPaymentReconciliationProcessNote; overload; {b\}
    procedure ParsePaymentReconciliationProcessNoteProperties(obj : TTurtleComplex; result : TFhirPaymentReconciliationProcessNote); overload; {b\}
    function ParsePaymentReconciliation(obj : TTurtleComplex) : TFhirPaymentReconciliation; overload;
    procedure ParsePaymentReconciliationProperties(obj : TTurtleComplex; result : TFhirPaymentReconciliation); overload;
{$ENDIF FHIR_PAYMENTRECONCILIATION}
{$IFDEF FHIR_PERSON}
    function ParsePersonLink(obj : TTurtleComplex) : TFhirPersonLink; overload; {b\}
    procedure ParsePersonLinkProperties(obj : TTurtleComplex; result : TFhirPersonLink); overload; {b\}
    function ParsePerson(obj : TTurtleComplex) : TFhirPerson; overload;
    procedure ParsePersonProperties(obj : TTurtleComplex; result : TFhirPerson); overload;
{$ENDIF FHIR_PERSON}
{$IFDEF FHIR_PLANDEFINITION}
    function ParsePlanDefinitionGoal(obj : TTurtleComplex) : TFhirPlanDefinitionGoal; overload; {b\}
    procedure ParsePlanDefinitionGoalProperties(obj : TTurtleComplex; result : TFhirPlanDefinitionGoal); overload; {b\}
    function ParsePlanDefinitionGoalTarget(obj : TTurtleComplex) : TFhirPlanDefinitionGoalTarget; overload; {b\}
    procedure ParsePlanDefinitionGoalTargetProperties(obj : TTurtleComplex; result : TFhirPlanDefinitionGoalTarget); overload; {b\}
    function ParsePlanDefinitionAction(obj : TTurtleComplex) : TFhirPlanDefinitionAction; overload; {b\}
    procedure ParsePlanDefinitionActionProperties(obj : TTurtleComplex; result : TFhirPlanDefinitionAction); overload; {b\}
    function ParsePlanDefinitionActionCondition(obj : TTurtleComplex) : TFhirPlanDefinitionActionCondition; overload; {b\}
    procedure ParsePlanDefinitionActionConditionProperties(obj : TTurtleComplex; result : TFhirPlanDefinitionActionCondition); overload; {b\}
    function ParsePlanDefinitionActionRelatedAction(obj : TTurtleComplex) : TFhirPlanDefinitionActionRelatedAction; overload; {b\}
    procedure ParsePlanDefinitionActionRelatedActionProperties(obj : TTurtleComplex; result : TFhirPlanDefinitionActionRelatedAction); overload; {b\}
    function ParsePlanDefinitionActionParticipant(obj : TTurtleComplex) : TFhirPlanDefinitionActionParticipant; overload; {b\}
    procedure ParsePlanDefinitionActionParticipantProperties(obj : TTurtleComplex; result : TFhirPlanDefinitionActionParticipant); overload; {b\}
    function ParsePlanDefinitionActionDynamicValue(obj : TTurtleComplex) : TFhirPlanDefinitionActionDynamicValue; overload; {b\}
    procedure ParsePlanDefinitionActionDynamicValueProperties(obj : TTurtleComplex; result : TFhirPlanDefinitionActionDynamicValue); overload; {b\}
    function ParsePlanDefinition(obj : TTurtleComplex) : TFhirPlanDefinition; overload;
    procedure ParsePlanDefinitionProperties(obj : TTurtleComplex; result : TFhirPlanDefinition); overload;
{$ENDIF FHIR_PLANDEFINITION}
{$IFDEF FHIR_PRACTITIONER}
    function ParsePractitionerQualification(obj : TTurtleComplex) : TFhirPractitionerQualification; overload; {b\}
    procedure ParsePractitionerQualificationProperties(obj : TTurtleComplex; result : TFhirPractitionerQualification); overload; {b\}
    function ParsePractitioner(obj : TTurtleComplex) : TFhirPractitioner; overload;
    procedure ParsePractitionerProperties(obj : TTurtleComplex; result : TFhirPractitioner); overload;
{$ENDIF FHIR_PRACTITIONER}
{$IFDEF FHIR_PRACTITIONERROLE}
    function ParsePractitionerRoleAvailableTime(obj : TTurtleComplex) : TFhirPractitionerRoleAvailableTime; overload; {b\}
    procedure ParsePractitionerRoleAvailableTimeProperties(obj : TTurtleComplex; result : TFhirPractitionerRoleAvailableTime); overload; {b\}
    function ParsePractitionerRoleNotAvailable(obj : TTurtleComplex) : TFhirPractitionerRoleNotAvailable; overload; {b\}
    procedure ParsePractitionerRoleNotAvailableProperties(obj : TTurtleComplex; result : TFhirPractitionerRoleNotAvailable); overload; {b\}
    function ParsePractitionerRole(obj : TTurtleComplex) : TFhirPractitionerRole; overload;
    procedure ParsePractitionerRoleProperties(obj : TTurtleComplex; result : TFhirPractitionerRole); overload;
{$ENDIF FHIR_PRACTITIONERROLE}
{$IFDEF FHIR_PROCEDURE}
    function ParseProcedurePerformer(obj : TTurtleComplex) : TFhirProcedurePerformer; overload; {b\}
    procedure ParseProcedurePerformerProperties(obj : TTurtleComplex; result : TFhirProcedurePerformer); overload; {b\}
    function ParseProcedureFocalDevice(obj : TTurtleComplex) : TFhirProcedureFocalDevice; overload; {b\}
    procedure ParseProcedureFocalDeviceProperties(obj : TTurtleComplex; result : TFhirProcedureFocalDevice); overload; {b\}
    function ParseProcedure(obj : TTurtleComplex) : TFhirProcedure; overload;
    procedure ParseProcedureProperties(obj : TTurtleComplex; result : TFhirProcedure); overload;
{$ENDIF FHIR_PROCEDURE}
{$IFDEF FHIR_PROVENANCE}
    function ParseProvenanceAgent(obj : TTurtleComplex) : TFhirProvenanceAgent; overload; {b\}
    procedure ParseProvenanceAgentProperties(obj : TTurtleComplex; result : TFhirProvenanceAgent); overload; {b\}
    function ParseProvenanceEntity(obj : TTurtleComplex) : TFhirProvenanceEntity; overload; {b\}
    procedure ParseProvenanceEntityProperties(obj : TTurtleComplex; result : TFhirProvenanceEntity); overload; {b\}
    function ParseProvenance(obj : TTurtleComplex) : TFhirProvenance; overload;
    procedure ParseProvenanceProperties(obj : TTurtleComplex; result : TFhirProvenance); overload;
{$ENDIF FHIR_PROVENANCE}
{$IFDEF FHIR_QUESTIONNAIRE}
    function ParseQuestionnaireItem(obj : TTurtleComplex) : TFhirQuestionnaireItem; overload; {b\}
    procedure ParseQuestionnaireItemProperties(obj : TTurtleComplex; result : TFhirQuestionnaireItem); overload; {b\}
    function ParseQuestionnaireItemEnableWhen(obj : TTurtleComplex) : TFhirQuestionnaireItemEnableWhen; overload; {b\}
    procedure ParseQuestionnaireItemEnableWhenProperties(obj : TTurtleComplex; result : TFhirQuestionnaireItemEnableWhen); overload; {b\}
    function ParseQuestionnaireItemAnswerOption(obj : TTurtleComplex) : TFhirQuestionnaireItemAnswerOption; overload; {b\}
    procedure ParseQuestionnaireItemAnswerOptionProperties(obj : TTurtleComplex; result : TFhirQuestionnaireItemAnswerOption); overload; {b\}
    function ParseQuestionnaireItemInitial(obj : TTurtleComplex) : TFhirQuestionnaireItemInitial; overload; {b\}
    procedure ParseQuestionnaireItemInitialProperties(obj : TTurtleComplex; result : TFhirQuestionnaireItemInitial); overload; {b\}
    function ParseQuestionnaire(obj : TTurtleComplex) : TFhirQuestionnaire; overload;
    procedure ParseQuestionnaireProperties(obj : TTurtleComplex; result : TFhirQuestionnaire); overload;
{$ENDIF FHIR_QUESTIONNAIRE}
{$IFDEF FHIR_QUESTIONNAIRERESPONSE}
    function ParseQuestionnaireResponseItem(obj : TTurtleComplex) : TFhirQuestionnaireResponseItem; overload; {b\}
    procedure ParseQuestionnaireResponseItemProperties(obj : TTurtleComplex; result : TFhirQuestionnaireResponseItem); overload; {b\}
    function ParseQuestionnaireResponseItemAnswer(obj : TTurtleComplex) : TFhirQuestionnaireResponseItemAnswer; overload; {b\}
    procedure ParseQuestionnaireResponseItemAnswerProperties(obj : TTurtleComplex; result : TFhirQuestionnaireResponseItemAnswer); overload; {b\}
    function ParseQuestionnaireResponse(obj : TTurtleComplex) : TFhirQuestionnaireResponse; overload;
    procedure ParseQuestionnaireResponseProperties(obj : TTurtleComplex; result : TFhirQuestionnaireResponse); overload;
{$ENDIF FHIR_QUESTIONNAIRERESPONSE}
{$IFDEF FHIR_RELATEDPERSON}
    function ParseRelatedPersonCommunication(obj : TTurtleComplex) : TFhirRelatedPersonCommunication; overload; {b\}
    procedure ParseRelatedPersonCommunicationProperties(obj : TTurtleComplex; result : TFhirRelatedPersonCommunication); overload; {b\}
    function ParseRelatedPerson(obj : TTurtleComplex) : TFhirRelatedPerson; overload;
    procedure ParseRelatedPersonProperties(obj : TTurtleComplex; result : TFhirRelatedPerson); overload;
{$ENDIF FHIR_RELATEDPERSON}
{$IFDEF FHIR_REQUESTGROUP}
    function ParseRequestGroupAction(obj : TTurtleComplex) : TFhirRequestGroupAction; overload; {b\}
    procedure ParseRequestGroupActionProperties(obj : TTurtleComplex; result : TFhirRequestGroupAction); overload; {b\}
    function ParseRequestGroupActionCondition(obj : TTurtleComplex) : TFhirRequestGroupActionCondition; overload; {b\}
    procedure ParseRequestGroupActionConditionProperties(obj : TTurtleComplex; result : TFhirRequestGroupActionCondition); overload; {b\}
    function ParseRequestGroupActionRelatedAction(obj : TTurtleComplex) : TFhirRequestGroupActionRelatedAction; overload; {b\}
    procedure ParseRequestGroupActionRelatedActionProperties(obj : TTurtleComplex; result : TFhirRequestGroupActionRelatedAction); overload; {b\}
    function ParseRequestGroup(obj : TTurtleComplex) : TFhirRequestGroup; overload;
    procedure ParseRequestGroupProperties(obj : TTurtleComplex; result : TFhirRequestGroup); overload;
{$ENDIF FHIR_REQUESTGROUP}
{$IFDEF FHIR_RESEARCHDEFINITION}
    function ParseResearchDefinition(obj : TTurtleComplex) : TFhirResearchDefinition; overload;
    procedure ParseResearchDefinitionProperties(obj : TTurtleComplex; result : TFhirResearchDefinition); overload;
{$ENDIF FHIR_RESEARCHDEFINITION}
{$IFDEF FHIR_RESEARCHELEMENTDEFINITION}
    function ParseResearchElementDefinitionCharacteristic(obj : TTurtleComplex) : TFhirResearchElementDefinitionCharacteristic; overload; {b\}
    procedure ParseResearchElementDefinitionCharacteristicProperties(obj : TTurtleComplex; result : TFhirResearchElementDefinitionCharacteristic); overload; {b\}
    function ParseResearchElementDefinition(obj : TTurtleComplex) : TFhirResearchElementDefinition; overload;
    procedure ParseResearchElementDefinitionProperties(obj : TTurtleComplex; result : TFhirResearchElementDefinition); overload;
{$ENDIF FHIR_RESEARCHELEMENTDEFINITION}
{$IFDEF FHIR_RESEARCHSTUDY}
    function ParseResearchStudyArm(obj : TTurtleComplex) : TFhirResearchStudyArm; overload; {b\}
    procedure ParseResearchStudyArmProperties(obj : TTurtleComplex; result : TFhirResearchStudyArm); overload; {b\}
    function ParseResearchStudyObjective(obj : TTurtleComplex) : TFhirResearchStudyObjective; overload; {b\}
    procedure ParseResearchStudyObjectiveProperties(obj : TTurtleComplex; result : TFhirResearchStudyObjective); overload; {b\}
    function ParseResearchStudy(obj : TTurtleComplex) : TFhirResearchStudy; overload;
    procedure ParseResearchStudyProperties(obj : TTurtleComplex; result : TFhirResearchStudy); overload;
{$ENDIF FHIR_RESEARCHSTUDY}
{$IFDEF FHIR_RESEARCHSUBJECT}
    function ParseResearchSubject(obj : TTurtleComplex) : TFhirResearchSubject; overload;
    procedure ParseResearchSubjectProperties(obj : TTurtleComplex; result : TFhirResearchSubject); overload;
{$ENDIF FHIR_RESEARCHSUBJECT}
{$IFDEF FHIR_RISKASSESSMENT}
    function ParseRiskAssessmentPrediction(obj : TTurtleComplex) : TFhirRiskAssessmentPrediction; overload; {b\}
    procedure ParseRiskAssessmentPredictionProperties(obj : TTurtleComplex; result : TFhirRiskAssessmentPrediction); overload; {b\}
    function ParseRiskAssessment(obj : TTurtleComplex) : TFhirRiskAssessment; overload;
    procedure ParseRiskAssessmentProperties(obj : TTurtleComplex; result : TFhirRiskAssessment); overload;
{$ENDIF FHIR_RISKASSESSMENT}
{$IFDEF FHIR_RISKEVIDENCESYNTHESIS}
    function ParseRiskEvidenceSynthesisSampleSize(obj : TTurtleComplex) : TFhirRiskEvidenceSynthesisSampleSize; overload; {b\}
    procedure ParseRiskEvidenceSynthesisSampleSizeProperties(obj : TTurtleComplex; result : TFhirRiskEvidenceSynthesisSampleSize); overload; {b\}
    function ParseRiskEvidenceSynthesisRiskEstimate(obj : TTurtleComplex) : TFhirRiskEvidenceSynthesisRiskEstimate; overload; {b\}
    procedure ParseRiskEvidenceSynthesisRiskEstimateProperties(obj : TTurtleComplex; result : TFhirRiskEvidenceSynthesisRiskEstimate); overload; {b\}
    function ParseRiskEvidenceSynthesisRiskEstimatePrecisionEstimate(obj : TTurtleComplex) : TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate; overload; {b\}
    procedure ParseRiskEvidenceSynthesisRiskEstimatePrecisionEstimateProperties(obj : TTurtleComplex; result : TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate); overload; {b\}
    function ParseRiskEvidenceSynthesisCertainty(obj : TTurtleComplex) : TFhirRiskEvidenceSynthesisCertainty; overload; {b\}
    procedure ParseRiskEvidenceSynthesisCertaintyProperties(obj : TTurtleComplex; result : TFhirRiskEvidenceSynthesisCertainty); overload; {b\}
    function ParseRiskEvidenceSynthesisCertaintyCertaintySubcomponent(obj : TTurtleComplex) : TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent; overload; {b\}
    procedure ParseRiskEvidenceSynthesisCertaintyCertaintySubcomponentProperties(obj : TTurtleComplex; result : TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent); overload; {b\}
    function ParseRiskEvidenceSynthesis(obj : TTurtleComplex) : TFhirRiskEvidenceSynthesis; overload;
    procedure ParseRiskEvidenceSynthesisProperties(obj : TTurtleComplex; result : TFhirRiskEvidenceSynthesis); overload;
{$ENDIF FHIR_RISKEVIDENCESYNTHESIS}
{$IFDEF FHIR_SCHEDULE}
    function ParseSchedule(obj : TTurtleComplex) : TFhirSchedule; overload;
    procedure ParseScheduleProperties(obj : TTurtleComplex; result : TFhirSchedule); overload;
{$ENDIF FHIR_SCHEDULE}
{$IFDEF FHIR_SEARCHPARAMETER}
    function ParseSearchParameterComponent(obj : TTurtleComplex) : TFhirSearchParameterComponent; overload; {b\}
    procedure ParseSearchParameterComponentProperties(obj : TTurtleComplex; result : TFhirSearchParameterComponent); overload; {b\}
    function ParseSearchParameter(obj : TTurtleComplex) : TFhirSearchParameter; overload;
    procedure ParseSearchParameterProperties(obj : TTurtleComplex; result : TFhirSearchParameter); overload;
{$ENDIF FHIR_SEARCHPARAMETER}
{$IFDEF FHIR_SERVICEREQUEST}
    function ParseServiceRequest(obj : TTurtleComplex) : TFhirServiceRequest; overload;
    procedure ParseServiceRequestProperties(obj : TTurtleComplex; result : TFhirServiceRequest); overload;
{$ENDIF FHIR_SERVICEREQUEST}
{$IFDEF FHIR_SLOT}
    function ParseSlot(obj : TTurtleComplex) : TFhirSlot; overload;
    procedure ParseSlotProperties(obj : TTurtleComplex; result : TFhirSlot); overload;
{$ENDIF FHIR_SLOT}
{$IFDEF FHIR_SPECIMEN}
    function ParseSpecimenCollection(obj : TTurtleComplex) : TFhirSpecimenCollection; overload; {b\}
    procedure ParseSpecimenCollectionProperties(obj : TTurtleComplex; result : TFhirSpecimenCollection); overload; {b\}
    function ParseSpecimenProcessing(obj : TTurtleComplex) : TFhirSpecimenProcessing; overload; {b\}
    procedure ParseSpecimenProcessingProperties(obj : TTurtleComplex; result : TFhirSpecimenProcessing); overload; {b\}
    function ParseSpecimenContainer(obj : TTurtleComplex) : TFhirSpecimenContainer; overload; {b\}
    procedure ParseSpecimenContainerProperties(obj : TTurtleComplex; result : TFhirSpecimenContainer); overload; {b\}
    function ParseSpecimen(obj : TTurtleComplex) : TFhirSpecimen; overload;
    procedure ParseSpecimenProperties(obj : TTurtleComplex; result : TFhirSpecimen); overload;
{$ENDIF FHIR_SPECIMEN}
{$IFDEF FHIR_SPECIMENDEFINITION}
    function ParseSpecimenDefinitionTypeTested(obj : TTurtleComplex) : TFhirSpecimenDefinitionTypeTested; overload; {b\}
    procedure ParseSpecimenDefinitionTypeTestedProperties(obj : TTurtleComplex; result : TFhirSpecimenDefinitionTypeTested); overload; {b\}
    function ParseSpecimenDefinitionTypeTestedContainer(obj : TTurtleComplex) : TFhirSpecimenDefinitionTypeTestedContainer; overload; {b\}
    procedure ParseSpecimenDefinitionTypeTestedContainerProperties(obj : TTurtleComplex; result : TFhirSpecimenDefinitionTypeTestedContainer); overload; {b\}
    function ParseSpecimenDefinitionTypeTestedContainerAdditive(obj : TTurtleComplex) : TFhirSpecimenDefinitionTypeTestedContainerAdditive; overload; {b\}
    procedure ParseSpecimenDefinitionTypeTestedContainerAdditiveProperties(obj : TTurtleComplex; result : TFhirSpecimenDefinitionTypeTestedContainerAdditive); overload; {b\}
    function ParseSpecimenDefinitionTypeTestedHandling(obj : TTurtleComplex) : TFhirSpecimenDefinitionTypeTestedHandling; overload; {b\}
    procedure ParseSpecimenDefinitionTypeTestedHandlingProperties(obj : TTurtleComplex; result : TFhirSpecimenDefinitionTypeTestedHandling); overload; {b\}
    function ParseSpecimenDefinition(obj : TTurtleComplex) : TFhirSpecimenDefinition; overload;
    procedure ParseSpecimenDefinitionProperties(obj : TTurtleComplex; result : TFhirSpecimenDefinition); overload;
{$ENDIF FHIR_SPECIMENDEFINITION}
{$IFDEF FHIR_STRUCTUREDEFINITION}
    function ParseStructureDefinitionMapping(obj : TTurtleComplex) : TFhirStructureDefinitionMapping; overload; {b\}
    procedure ParseStructureDefinitionMappingProperties(obj : TTurtleComplex; result : TFhirStructureDefinitionMapping); overload; {b\}
    function ParseStructureDefinitionContext(obj : TTurtleComplex) : TFhirStructureDefinitionContext; overload; {b\}
    procedure ParseStructureDefinitionContextProperties(obj : TTurtleComplex; result : TFhirStructureDefinitionContext); overload; {b\}
    function ParseStructureDefinitionSnapshot(obj : TTurtleComplex) : TFhirStructureDefinitionSnapshot; overload; {b\}
    procedure ParseStructureDefinitionSnapshotProperties(obj : TTurtleComplex; result : TFhirStructureDefinitionSnapshot); overload; {b\}
    function ParseStructureDefinitionDifferential(obj : TTurtleComplex) : TFhirStructureDefinitionDifferential; overload; {b\}
    procedure ParseStructureDefinitionDifferentialProperties(obj : TTurtleComplex; result : TFhirStructureDefinitionDifferential); overload; {b\}
    function ParseStructureDefinition(obj : TTurtleComplex) : TFhirStructureDefinition; overload;
    procedure ParseStructureDefinitionProperties(obj : TTurtleComplex; result : TFhirStructureDefinition); overload;
{$ENDIF FHIR_STRUCTUREDEFINITION}
{$IFDEF FHIR_STRUCTUREMAP}
    function ParseStructureMapStructure(obj : TTurtleComplex) : TFhirStructureMapStructure; overload; {b\}
    procedure ParseStructureMapStructureProperties(obj : TTurtleComplex; result : TFhirStructureMapStructure); overload; {b\}
    function ParseStructureMapGroup(obj : TTurtleComplex) : TFhirStructureMapGroup; overload; {b\}
    procedure ParseStructureMapGroupProperties(obj : TTurtleComplex; result : TFhirStructureMapGroup); overload; {b\}
    function ParseStructureMapGroupInput(obj : TTurtleComplex) : TFhirStructureMapGroupInput; overload; {b\}
    procedure ParseStructureMapGroupInputProperties(obj : TTurtleComplex; result : TFhirStructureMapGroupInput); overload; {b\}
    function ParseStructureMapGroupRule(obj : TTurtleComplex) : TFhirStructureMapGroupRule; overload; {b\}
    procedure ParseStructureMapGroupRuleProperties(obj : TTurtleComplex; result : TFhirStructureMapGroupRule); overload; {b\}
    function ParseStructureMapGroupRuleSource(obj : TTurtleComplex) : TFhirStructureMapGroupRuleSource; overload; {b\}
    procedure ParseStructureMapGroupRuleSourceProperties(obj : TTurtleComplex; result : TFhirStructureMapGroupRuleSource); overload; {b\}
    function ParseStructureMapGroupRuleTarget(obj : TTurtleComplex) : TFhirStructureMapGroupRuleTarget; overload; {b\}
    procedure ParseStructureMapGroupRuleTargetProperties(obj : TTurtleComplex; result : TFhirStructureMapGroupRuleTarget); overload; {b\}
    function ParseStructureMapGroupRuleTargetParameter(obj : TTurtleComplex) : TFhirStructureMapGroupRuleTargetParameter; overload; {b\}
    procedure ParseStructureMapGroupRuleTargetParameterProperties(obj : TTurtleComplex; result : TFhirStructureMapGroupRuleTargetParameter); overload; {b\}
    function ParseStructureMapGroupRuleDependent(obj : TTurtleComplex) : TFhirStructureMapGroupRuleDependent; overload; {b\}
    procedure ParseStructureMapGroupRuleDependentProperties(obj : TTurtleComplex; result : TFhirStructureMapGroupRuleDependent); overload; {b\}
    function ParseStructureMap(obj : TTurtleComplex) : TFhirStructureMap; overload;
    procedure ParseStructureMapProperties(obj : TTurtleComplex; result : TFhirStructureMap); overload;
{$ENDIF FHIR_STRUCTUREMAP}
{$IFDEF FHIR_SUBSCRIPTION}
    function ParseSubscriptionChannel(obj : TTurtleComplex) : TFhirSubscriptionChannel; overload; {b\}
    procedure ParseSubscriptionChannelProperties(obj : TTurtleComplex; result : TFhirSubscriptionChannel); overload; {b\}
    function ParseSubscription(obj : TTurtleComplex) : TFhirSubscription; overload;
    procedure ParseSubscriptionProperties(obj : TTurtleComplex; result : TFhirSubscription); overload;
{$ENDIF FHIR_SUBSCRIPTION}
{$IFDEF FHIR_SUBSTANCE}
    function ParseSubstanceInstance(obj : TTurtleComplex) : TFhirSubstanceInstance; overload; {b\}
    procedure ParseSubstanceInstanceProperties(obj : TTurtleComplex; result : TFhirSubstanceInstance); overload; {b\}
    function ParseSubstanceIngredient(obj : TTurtleComplex) : TFhirSubstanceIngredient; overload; {b\}
    procedure ParseSubstanceIngredientProperties(obj : TTurtleComplex; result : TFhirSubstanceIngredient); overload; {b\}
    function ParseSubstance(obj : TTurtleComplex) : TFhirSubstance; overload;
    procedure ParseSubstanceProperties(obj : TTurtleComplex; result : TFhirSubstance); overload;
{$ENDIF FHIR_SUBSTANCE}
{$IFDEF FHIR_SUBSTANCENUCLEICACID}
    function ParseSubstanceNucleicAcidSubunit(obj : TTurtleComplex) : TFhirSubstanceNucleicAcidSubunit; overload; {b\}
    procedure ParseSubstanceNucleicAcidSubunitProperties(obj : TTurtleComplex; result : TFhirSubstanceNucleicAcidSubunit); overload; {b\}
    function ParseSubstanceNucleicAcidSubunitLinkage(obj : TTurtleComplex) : TFhirSubstanceNucleicAcidSubunitLinkage; overload; {b\}
    procedure ParseSubstanceNucleicAcidSubunitLinkageProperties(obj : TTurtleComplex; result : TFhirSubstanceNucleicAcidSubunitLinkage); overload; {b\}
    function ParseSubstanceNucleicAcidSubunitSugar(obj : TTurtleComplex) : TFhirSubstanceNucleicAcidSubunitSugar; overload; {b\}
    procedure ParseSubstanceNucleicAcidSubunitSugarProperties(obj : TTurtleComplex; result : TFhirSubstanceNucleicAcidSubunitSugar); overload; {b\}
    function ParseSubstanceNucleicAcid(obj : TTurtleComplex) : TFhirSubstanceNucleicAcid; overload;
    procedure ParseSubstanceNucleicAcidProperties(obj : TTurtleComplex; result : TFhirSubstanceNucleicAcid); overload;
{$ENDIF FHIR_SUBSTANCENUCLEICACID}
{$IFDEF FHIR_SUBSTANCEPOLYMER}
    function ParseSubstancePolymerMonomerSet(obj : TTurtleComplex) : TFhirSubstancePolymerMonomerSet; overload; {b\}
    procedure ParseSubstancePolymerMonomerSetProperties(obj : TTurtleComplex; result : TFhirSubstancePolymerMonomerSet); overload; {b\}
    function ParseSubstancePolymerMonomerSetStartingMaterial(obj : TTurtleComplex) : TFhirSubstancePolymerMonomerSetStartingMaterial; overload; {b\}
    procedure ParseSubstancePolymerMonomerSetStartingMaterialProperties(obj : TTurtleComplex; result : TFhirSubstancePolymerMonomerSetStartingMaterial); overload; {b\}
    function ParseSubstancePolymerRepeat(obj : TTurtleComplex) : TFhirSubstancePolymerRepeat; overload; {b\}
    procedure ParseSubstancePolymerRepeatProperties(obj : TTurtleComplex; result : TFhirSubstancePolymerRepeat); overload; {b\}
    function ParseSubstancePolymerRepeatRepeatUnit(obj : TTurtleComplex) : TFhirSubstancePolymerRepeatRepeatUnit; overload; {b\}
    procedure ParseSubstancePolymerRepeatRepeatUnitProperties(obj : TTurtleComplex; result : TFhirSubstancePolymerRepeatRepeatUnit); overload; {b\}
    function ParseSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation(obj : TTurtleComplex) : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation; overload; {b\}
    procedure ParseSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationProperties(obj : TTurtleComplex; result : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation); overload; {b\}
    function ParseSubstancePolymerRepeatRepeatUnitStructuralRepresentation(obj : TTurtleComplex) : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation; overload; {b\}
    procedure ParseSubstancePolymerRepeatRepeatUnitStructuralRepresentationProperties(obj : TTurtleComplex; result : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation); overload; {b\}
    function ParseSubstancePolymer(obj : TTurtleComplex) : TFhirSubstancePolymer; overload;
    procedure ParseSubstancePolymerProperties(obj : TTurtleComplex; result : TFhirSubstancePolymer); overload;
{$ENDIF FHIR_SUBSTANCEPOLYMER}
{$IFDEF FHIR_SUBSTANCEPROTEIN}
    function ParseSubstanceProteinSubunit(obj : TTurtleComplex) : TFhirSubstanceProteinSubunit; overload; {b\}
    procedure ParseSubstanceProteinSubunitProperties(obj : TTurtleComplex; result : TFhirSubstanceProteinSubunit); overload; {b\}
    function ParseSubstanceProtein(obj : TTurtleComplex) : TFhirSubstanceProtein; overload;
    procedure ParseSubstanceProteinProperties(obj : TTurtleComplex; result : TFhirSubstanceProtein); overload;
{$ENDIF FHIR_SUBSTANCEPROTEIN}
{$IFDEF FHIR_SUBSTANCEREFERENCEINFORMATION}
    function ParseSubstanceReferenceInformationGene(obj : TTurtleComplex) : TFhirSubstanceReferenceInformationGene; overload; {b\}
    procedure ParseSubstanceReferenceInformationGeneProperties(obj : TTurtleComplex; result : TFhirSubstanceReferenceInformationGene); overload; {b\}
    function ParseSubstanceReferenceInformationGeneElement(obj : TTurtleComplex) : TFhirSubstanceReferenceInformationGeneElement; overload; {b\}
    procedure ParseSubstanceReferenceInformationGeneElementProperties(obj : TTurtleComplex; result : TFhirSubstanceReferenceInformationGeneElement); overload; {b\}
    function ParseSubstanceReferenceInformationClassification(obj : TTurtleComplex) : TFhirSubstanceReferenceInformationClassification; overload; {b\}
    procedure ParseSubstanceReferenceInformationClassificationProperties(obj : TTurtleComplex; result : TFhirSubstanceReferenceInformationClassification); overload; {b\}
    function ParseSubstanceReferenceInformationTarget(obj : TTurtleComplex) : TFhirSubstanceReferenceInformationTarget; overload; {b\}
    procedure ParseSubstanceReferenceInformationTargetProperties(obj : TTurtleComplex; result : TFhirSubstanceReferenceInformationTarget); overload; {b\}
    function ParseSubstanceReferenceInformation(obj : TTurtleComplex) : TFhirSubstanceReferenceInformation; overload;
    procedure ParseSubstanceReferenceInformationProperties(obj : TTurtleComplex; result : TFhirSubstanceReferenceInformation); overload;
{$ENDIF FHIR_SUBSTANCEREFERENCEINFORMATION}
{$IFDEF FHIR_SUBSTANCESOURCEMATERIAL}
    function ParseSubstanceSourceMaterialFractionDescription(obj : TTurtleComplex) : TFhirSubstanceSourceMaterialFractionDescription; overload; {b\}
    procedure ParseSubstanceSourceMaterialFractionDescriptionProperties(obj : TTurtleComplex; result : TFhirSubstanceSourceMaterialFractionDescription); overload; {b\}
    function ParseSubstanceSourceMaterialOrganism(obj : TTurtleComplex) : TFhirSubstanceSourceMaterialOrganism; overload; {b\}
    procedure ParseSubstanceSourceMaterialOrganismProperties(obj : TTurtleComplex; result : TFhirSubstanceSourceMaterialOrganism); overload; {b\}
    function ParseSubstanceSourceMaterialOrganismAuthor(obj : TTurtleComplex) : TFhirSubstanceSourceMaterialOrganismAuthor; overload; {b\}
    procedure ParseSubstanceSourceMaterialOrganismAuthorProperties(obj : TTurtleComplex; result : TFhirSubstanceSourceMaterialOrganismAuthor); overload; {b\}
    function ParseSubstanceSourceMaterialOrganismHybrid(obj : TTurtleComplex) : TFhirSubstanceSourceMaterialOrganismHybrid; overload; {b\}
    procedure ParseSubstanceSourceMaterialOrganismHybridProperties(obj : TTurtleComplex; result : TFhirSubstanceSourceMaterialOrganismHybrid); overload; {b\}
    function ParseSubstanceSourceMaterialOrganismOrganismGeneral(obj : TTurtleComplex) : TFhirSubstanceSourceMaterialOrganismOrganismGeneral; overload; {b\}
    procedure ParseSubstanceSourceMaterialOrganismOrganismGeneralProperties(obj : TTurtleComplex; result : TFhirSubstanceSourceMaterialOrganismOrganismGeneral); overload; {b\}
    function ParseSubstanceSourceMaterialPartDescription(obj : TTurtleComplex) : TFhirSubstanceSourceMaterialPartDescription; overload; {b\}
    procedure ParseSubstanceSourceMaterialPartDescriptionProperties(obj : TTurtleComplex; result : TFhirSubstanceSourceMaterialPartDescription); overload; {b\}
    function ParseSubstanceSourceMaterial(obj : TTurtleComplex) : TFhirSubstanceSourceMaterial; overload;
    procedure ParseSubstanceSourceMaterialProperties(obj : TTurtleComplex; result : TFhirSubstanceSourceMaterial); overload;
{$ENDIF FHIR_SUBSTANCESOURCEMATERIAL}
{$IFDEF FHIR_SUBSTANCESPECIFICATION}
    function ParseSubstanceSpecificationMoiety(obj : TTurtleComplex) : TFhirSubstanceSpecificationMoiety; overload; {b\}
    procedure ParseSubstanceSpecificationMoietyProperties(obj : TTurtleComplex; result : TFhirSubstanceSpecificationMoiety); overload; {b\}
    function ParseSubstanceSpecificationProperty(obj : TTurtleComplex) : TFhirSubstanceSpecificationProperty; overload; {b\}
    procedure ParseSubstanceSpecificationPropertyProperties(obj : TTurtleComplex; result : TFhirSubstanceSpecificationProperty); overload; {b\}
    function ParseSubstanceSpecificationStructure(obj : TTurtleComplex) : TFhirSubstanceSpecificationStructure; overload; {b\}
    procedure ParseSubstanceSpecificationStructureProperties(obj : TTurtleComplex; result : TFhirSubstanceSpecificationStructure); overload; {b\}
    function ParseSubstanceSpecificationStructureIsotope(obj : TTurtleComplex) : TFhirSubstanceSpecificationStructureIsotope; overload; {b\}
    procedure ParseSubstanceSpecificationStructureIsotopeProperties(obj : TTurtleComplex; result : TFhirSubstanceSpecificationStructureIsotope); overload; {b\}
    function ParseSubstanceSpecificationStructureIsotopeMolecularWeight(obj : TTurtleComplex) : TFhirSubstanceSpecificationStructureIsotopeMolecularWeight; overload; {b\}
    procedure ParseSubstanceSpecificationStructureIsotopeMolecularWeightProperties(obj : TTurtleComplex; result : TFhirSubstanceSpecificationStructureIsotopeMolecularWeight); overload; {b\}
    function ParseSubstanceSpecificationStructureRepresentation(obj : TTurtleComplex) : TFhirSubstanceSpecificationStructureRepresentation; overload; {b\}
    procedure ParseSubstanceSpecificationStructureRepresentationProperties(obj : TTurtleComplex; result : TFhirSubstanceSpecificationStructureRepresentation); overload; {b\}
    function ParseSubstanceSpecificationCode(obj : TTurtleComplex) : TFhirSubstanceSpecificationCode; overload; {b\}
    procedure ParseSubstanceSpecificationCodeProperties(obj : TTurtleComplex; result : TFhirSubstanceSpecificationCode); overload; {b\}
    function ParseSubstanceSpecificationName(obj : TTurtleComplex) : TFhirSubstanceSpecificationName; overload; {b\}
    procedure ParseSubstanceSpecificationNameProperties(obj : TTurtleComplex; result : TFhirSubstanceSpecificationName); overload; {b\}
    function ParseSubstanceSpecificationNameOfficial(obj : TTurtleComplex) : TFhirSubstanceSpecificationNameOfficial; overload; {b\}
    procedure ParseSubstanceSpecificationNameOfficialProperties(obj : TTurtleComplex; result : TFhirSubstanceSpecificationNameOfficial); overload; {b\}
    function ParseSubstanceSpecificationRelationship(obj : TTurtleComplex) : TFhirSubstanceSpecificationRelationship; overload; {b\}
    procedure ParseSubstanceSpecificationRelationshipProperties(obj : TTurtleComplex; result : TFhirSubstanceSpecificationRelationship); overload; {b\}
    function ParseSubstanceSpecification(obj : TTurtleComplex) : TFhirSubstanceSpecification; overload;
    procedure ParseSubstanceSpecificationProperties(obj : TTurtleComplex; result : TFhirSubstanceSpecification); overload;
{$ENDIF FHIR_SUBSTANCESPECIFICATION}
{$IFDEF FHIR_SUPPLYDELIVERY}
    function ParseSupplyDeliverySuppliedItem(obj : TTurtleComplex) : TFhirSupplyDeliverySuppliedItem; overload; {b\}
    procedure ParseSupplyDeliverySuppliedItemProperties(obj : TTurtleComplex; result : TFhirSupplyDeliverySuppliedItem); overload; {b\}
    function ParseSupplyDelivery(obj : TTurtleComplex) : TFhirSupplyDelivery; overload;
    procedure ParseSupplyDeliveryProperties(obj : TTurtleComplex; result : TFhirSupplyDelivery); overload;
{$ENDIF FHIR_SUPPLYDELIVERY}
{$IFDEF FHIR_SUPPLYREQUEST}
    function ParseSupplyRequestParameter(obj : TTurtleComplex) : TFhirSupplyRequestParameter; overload; {b\}
    procedure ParseSupplyRequestParameterProperties(obj : TTurtleComplex; result : TFhirSupplyRequestParameter); overload; {b\}
    function ParseSupplyRequest(obj : TTurtleComplex) : TFhirSupplyRequest; overload;
    procedure ParseSupplyRequestProperties(obj : TTurtleComplex; result : TFhirSupplyRequest); overload;
{$ENDIF FHIR_SUPPLYREQUEST}
{$IFDEF FHIR_TASK}
    function ParseTaskRestriction(obj : TTurtleComplex) : TFhirTaskRestriction; overload; {b\}
    procedure ParseTaskRestrictionProperties(obj : TTurtleComplex; result : TFhirTaskRestriction); overload; {b\}
    function ParseTaskInput(obj : TTurtleComplex) : TFhirTaskInput; overload; {b\}
    procedure ParseTaskInputProperties(obj : TTurtleComplex; result : TFhirTaskInput); overload; {b\}
    function ParseTaskOutput(obj : TTurtleComplex) : TFhirTaskOutput; overload; {b\}
    procedure ParseTaskOutputProperties(obj : TTurtleComplex; result : TFhirTaskOutput); overload; {b\}
    function ParseTask(obj : TTurtleComplex) : TFhirTask; overload;
    procedure ParseTaskProperties(obj : TTurtleComplex; result : TFhirTask); overload;
{$ENDIF FHIR_TASK}
{$IFDEF FHIR_TERMINOLOGYCAPABILITIES}
    function ParseTerminologyCapabilitiesSoftware(obj : TTurtleComplex) : TFhirTerminologyCapabilitiesSoftware; overload; {b\}
    procedure ParseTerminologyCapabilitiesSoftwareProperties(obj : TTurtleComplex; result : TFhirTerminologyCapabilitiesSoftware); overload; {b\}
    function ParseTerminologyCapabilitiesImplementation(obj : TTurtleComplex) : TFhirTerminologyCapabilitiesImplementation; overload; {b\}
    procedure ParseTerminologyCapabilitiesImplementationProperties(obj : TTurtleComplex; result : TFhirTerminologyCapabilitiesImplementation); overload; {b\}
    function ParseTerminologyCapabilitiesCodeSystem(obj : TTurtleComplex) : TFhirTerminologyCapabilitiesCodeSystem; overload; {b\}
    procedure ParseTerminologyCapabilitiesCodeSystemProperties(obj : TTurtleComplex; result : TFhirTerminologyCapabilitiesCodeSystem); overload; {b\}
    function ParseTerminologyCapabilitiesCodeSystemVersion(obj : TTurtleComplex) : TFhirTerminologyCapabilitiesCodeSystemVersion; overload; {b\}
    procedure ParseTerminologyCapabilitiesCodeSystemVersionProperties(obj : TTurtleComplex; result : TFhirTerminologyCapabilitiesCodeSystemVersion); overload; {b\}
    function ParseTerminologyCapabilitiesCodeSystemVersionFilter(obj : TTurtleComplex) : TFhirTerminologyCapabilitiesCodeSystemVersionFilter; overload; {b\}
    procedure ParseTerminologyCapabilitiesCodeSystemVersionFilterProperties(obj : TTurtleComplex; result : TFhirTerminologyCapabilitiesCodeSystemVersionFilter); overload; {b\}
    function ParseTerminologyCapabilitiesExpansion(obj : TTurtleComplex) : TFhirTerminologyCapabilitiesExpansion; overload; {b\}
    procedure ParseTerminologyCapabilitiesExpansionProperties(obj : TTurtleComplex; result : TFhirTerminologyCapabilitiesExpansion); overload; {b\}
    function ParseTerminologyCapabilitiesExpansionParameter(obj : TTurtleComplex) : TFhirTerminologyCapabilitiesExpansionParameter; overload; {b\}
    procedure ParseTerminologyCapabilitiesExpansionParameterProperties(obj : TTurtleComplex; result : TFhirTerminologyCapabilitiesExpansionParameter); overload; {b\}
    function ParseTerminologyCapabilitiesValidateCode(obj : TTurtleComplex) : TFhirTerminologyCapabilitiesValidateCode; overload; {b\}
    procedure ParseTerminologyCapabilitiesValidateCodeProperties(obj : TTurtleComplex; result : TFhirTerminologyCapabilitiesValidateCode); overload; {b\}
    function ParseTerminologyCapabilitiesTranslation(obj : TTurtleComplex) : TFhirTerminologyCapabilitiesTranslation; overload; {b\}
    procedure ParseTerminologyCapabilitiesTranslationProperties(obj : TTurtleComplex; result : TFhirTerminologyCapabilitiesTranslation); overload; {b\}
    function ParseTerminologyCapabilitiesClosure(obj : TTurtleComplex) : TFhirTerminologyCapabilitiesClosure; overload; {b\}
    procedure ParseTerminologyCapabilitiesClosureProperties(obj : TTurtleComplex; result : TFhirTerminologyCapabilitiesClosure); overload; {b\}
    function ParseTerminologyCapabilities(obj : TTurtleComplex) : TFhirTerminologyCapabilities; overload;
    procedure ParseTerminologyCapabilitiesProperties(obj : TTurtleComplex; result : TFhirTerminologyCapabilities); overload;
{$ENDIF FHIR_TERMINOLOGYCAPABILITIES}
{$IFDEF FHIR_TESTREPORT}
    function ParseTestReportParticipant(obj : TTurtleComplex) : TFhirTestReportParticipant; overload; {b\}
    procedure ParseTestReportParticipantProperties(obj : TTurtleComplex; result : TFhirTestReportParticipant); overload; {b\}
    function ParseTestReportSetup(obj : TTurtleComplex) : TFhirTestReportSetup; overload; {b\}
    procedure ParseTestReportSetupProperties(obj : TTurtleComplex; result : TFhirTestReportSetup); overload; {b\}
    function ParseTestReportSetupAction(obj : TTurtleComplex) : TFhirTestReportSetupAction; overload; {b\}
    procedure ParseTestReportSetupActionProperties(obj : TTurtleComplex; result : TFhirTestReportSetupAction); overload; {b\}
    function ParseTestReportSetupActionOperation(obj : TTurtleComplex) : TFhirTestReportSetupActionOperation; overload; {b\}
    procedure ParseTestReportSetupActionOperationProperties(obj : TTurtleComplex; result : TFhirTestReportSetupActionOperation); overload; {b\}
    function ParseTestReportSetupActionAssert(obj : TTurtleComplex) : TFhirTestReportSetupActionAssert; overload; {b\}
    procedure ParseTestReportSetupActionAssertProperties(obj : TTurtleComplex; result : TFhirTestReportSetupActionAssert); overload; {b\}
    function ParseTestReportTest(obj : TTurtleComplex) : TFhirTestReportTest; overload; {b\}
    procedure ParseTestReportTestProperties(obj : TTurtleComplex; result : TFhirTestReportTest); overload; {b\}
    function ParseTestReportTestAction(obj : TTurtleComplex) : TFhirTestReportTestAction; overload; {b\}
    procedure ParseTestReportTestActionProperties(obj : TTurtleComplex; result : TFhirTestReportTestAction); overload; {b\}
    function ParseTestReportTeardown(obj : TTurtleComplex) : TFhirTestReportTeardown; overload; {b\}
    procedure ParseTestReportTeardownProperties(obj : TTurtleComplex; result : TFhirTestReportTeardown); overload; {b\}
    function ParseTestReportTeardownAction(obj : TTurtleComplex) : TFhirTestReportTeardownAction; overload; {b\}
    procedure ParseTestReportTeardownActionProperties(obj : TTurtleComplex; result : TFhirTestReportTeardownAction); overload; {b\}
    function ParseTestReport(obj : TTurtleComplex) : TFhirTestReport; overload;
    procedure ParseTestReportProperties(obj : TTurtleComplex; result : TFhirTestReport); overload;
{$ENDIF FHIR_TESTREPORT}
{$IFDEF FHIR_TESTSCRIPT}
    function ParseTestScriptOrigin(obj : TTurtleComplex) : TFhirTestScriptOrigin; overload; {b\}
    procedure ParseTestScriptOriginProperties(obj : TTurtleComplex; result : TFhirTestScriptOrigin); overload; {b\}
    function ParseTestScriptDestination(obj : TTurtleComplex) : TFhirTestScriptDestination; overload; {b\}
    procedure ParseTestScriptDestinationProperties(obj : TTurtleComplex; result : TFhirTestScriptDestination); overload; {b\}
    function ParseTestScriptMetadata(obj : TTurtleComplex) : TFhirTestScriptMetadata; overload; {b\}
    procedure ParseTestScriptMetadataProperties(obj : TTurtleComplex; result : TFhirTestScriptMetadata); overload; {b\}
    function ParseTestScriptMetadataLink(obj : TTurtleComplex) : TFhirTestScriptMetadataLink; overload; {b\}
    procedure ParseTestScriptMetadataLinkProperties(obj : TTurtleComplex; result : TFhirTestScriptMetadataLink); overload; {b\}
    function ParseTestScriptMetadataCapability(obj : TTurtleComplex) : TFhirTestScriptMetadataCapability; overload; {b\}
    procedure ParseTestScriptMetadataCapabilityProperties(obj : TTurtleComplex; result : TFhirTestScriptMetadataCapability); overload; {b\}
    function ParseTestScriptFixture(obj : TTurtleComplex) : TFhirTestScriptFixture; overload; {b\}
    procedure ParseTestScriptFixtureProperties(obj : TTurtleComplex; result : TFhirTestScriptFixture); overload; {b\}
    function ParseTestScriptVariable(obj : TTurtleComplex) : TFhirTestScriptVariable; overload; {b\}
    procedure ParseTestScriptVariableProperties(obj : TTurtleComplex; result : TFhirTestScriptVariable); overload; {b\}
    function ParseTestScriptSetup(obj : TTurtleComplex) : TFhirTestScriptSetup; overload; {b\}
    procedure ParseTestScriptSetupProperties(obj : TTurtleComplex; result : TFhirTestScriptSetup); overload; {b\}
    function ParseTestScriptSetupAction(obj : TTurtleComplex) : TFhirTestScriptSetupAction; overload; {b\}
    procedure ParseTestScriptSetupActionProperties(obj : TTurtleComplex; result : TFhirTestScriptSetupAction); overload; {b\}
    function ParseTestScriptSetupActionOperation(obj : TTurtleComplex) : TFhirTestScriptSetupActionOperation; overload; {b\}
    procedure ParseTestScriptSetupActionOperationProperties(obj : TTurtleComplex; result : TFhirTestScriptSetupActionOperation); overload; {b\}
    function ParseTestScriptSetupActionOperationRequestHeader(obj : TTurtleComplex) : TFhirTestScriptSetupActionOperationRequestHeader; overload; {b\}
    procedure ParseTestScriptSetupActionOperationRequestHeaderProperties(obj : TTurtleComplex; result : TFhirTestScriptSetupActionOperationRequestHeader); overload; {b\}
    function ParseTestScriptSetupActionAssert(obj : TTurtleComplex) : TFhirTestScriptSetupActionAssert; overload; {b\}
    procedure ParseTestScriptSetupActionAssertProperties(obj : TTurtleComplex; result : TFhirTestScriptSetupActionAssert); overload; {b\}
    function ParseTestScriptTest(obj : TTurtleComplex) : TFhirTestScriptTest; overload; {b\}
    procedure ParseTestScriptTestProperties(obj : TTurtleComplex; result : TFhirTestScriptTest); overload; {b\}
    function ParseTestScriptTestAction(obj : TTurtleComplex) : TFhirTestScriptTestAction; overload; {b\}
    procedure ParseTestScriptTestActionProperties(obj : TTurtleComplex; result : TFhirTestScriptTestAction); overload; {b\}
    function ParseTestScriptTeardown(obj : TTurtleComplex) : TFhirTestScriptTeardown; overload; {b\}
    procedure ParseTestScriptTeardownProperties(obj : TTurtleComplex; result : TFhirTestScriptTeardown); overload; {b\}
    function ParseTestScriptTeardownAction(obj : TTurtleComplex) : TFhirTestScriptTeardownAction; overload; {b\}
    procedure ParseTestScriptTeardownActionProperties(obj : TTurtleComplex; result : TFhirTestScriptTeardownAction); overload; {b\}
    function ParseTestScript(obj : TTurtleComplex) : TFhirTestScript; overload;
    procedure ParseTestScriptProperties(obj : TTurtleComplex; result : TFhirTestScript); overload;
{$ENDIF FHIR_TESTSCRIPT}
{$IFDEF FHIR_VALUESET}
    function ParseValueSetCompose(obj : TTurtleComplex) : TFhirValueSetCompose; overload; {b\}
    procedure ParseValueSetComposeProperties(obj : TTurtleComplex; result : TFhirValueSetCompose); overload; {b\}
    function ParseValueSetComposeInclude(obj : TTurtleComplex) : TFhirValueSetComposeInclude; overload; {b\}
    procedure ParseValueSetComposeIncludeProperties(obj : TTurtleComplex; result : TFhirValueSetComposeInclude); overload; {b\}
    function ParseValueSetComposeIncludeConcept(obj : TTurtleComplex) : TFhirValueSetComposeIncludeConcept; overload; {b\}
    procedure ParseValueSetComposeIncludeConceptProperties(obj : TTurtleComplex; result : TFhirValueSetComposeIncludeConcept); overload; {b\}
    function ParseValueSetComposeIncludeConceptDesignation(obj : TTurtleComplex) : TFhirValueSetComposeIncludeConceptDesignation; overload; {b\}
    procedure ParseValueSetComposeIncludeConceptDesignationProperties(obj : TTurtleComplex; result : TFhirValueSetComposeIncludeConceptDesignation); overload; {b\}
    function ParseValueSetComposeIncludeFilter(obj : TTurtleComplex) : TFhirValueSetComposeIncludeFilter; overload; {b\}
    procedure ParseValueSetComposeIncludeFilterProperties(obj : TTurtleComplex; result : TFhirValueSetComposeIncludeFilter); overload; {b\}
    function ParseValueSetExpansion(obj : TTurtleComplex) : TFhirValueSetExpansion; overload; {b\}
    procedure ParseValueSetExpansionProperties(obj : TTurtleComplex; result : TFhirValueSetExpansion); overload; {b\}
    function ParseValueSetExpansionParameter(obj : TTurtleComplex) : TFhirValueSetExpansionParameter; overload; {b\}
    procedure ParseValueSetExpansionParameterProperties(obj : TTurtleComplex; result : TFhirValueSetExpansionParameter); overload; {b\}
    function ParseValueSetExpansionContains(obj : TTurtleComplex) : TFhirValueSetExpansionContains; overload; {b\}
    procedure ParseValueSetExpansionContainsProperties(obj : TTurtleComplex; result : TFhirValueSetExpansionContains); overload; {b\}
    function ParseValueSet(obj : TTurtleComplex) : TFhirValueSet; overload;
    procedure ParseValueSetProperties(obj : TTurtleComplex; result : TFhirValueSet); overload;
{$ENDIF FHIR_VALUESET}
{$IFDEF FHIR_VERIFICATIONRESULT}
    function ParseVerificationResultPrimarySource(obj : TTurtleComplex) : TFhirVerificationResultPrimarySource; overload; {b\}
    procedure ParseVerificationResultPrimarySourceProperties(obj : TTurtleComplex; result : TFhirVerificationResultPrimarySource); overload; {b\}
    function ParseVerificationResultAttestation(obj : TTurtleComplex) : TFhirVerificationResultAttestation; overload; {b\}
    procedure ParseVerificationResultAttestationProperties(obj : TTurtleComplex; result : TFhirVerificationResultAttestation); overload; {b\}
    function ParseVerificationResultValidator(obj : TTurtleComplex) : TFhirVerificationResultValidator; overload; {b\}
    procedure ParseVerificationResultValidatorProperties(obj : TTurtleComplex; result : TFhirVerificationResultValidator); overload; {b\}
    function ParseVerificationResult(obj : TTurtleComplex) : TFhirVerificationResult; overload;
    procedure ParseVerificationResultProperties(obj : TTurtleComplex; result : TFhirVerificationResult); overload;
{$ENDIF FHIR_VERIFICATIONRESULT}
{$IFDEF FHIR_VISIONPRESCRIPTION}
    function ParseVisionPrescriptionLensSpecification(obj : TTurtleComplex) : TFhirVisionPrescriptionLensSpecification; overload; {b\}
    procedure ParseVisionPrescriptionLensSpecificationProperties(obj : TTurtleComplex; result : TFhirVisionPrescriptionLensSpecification); overload; {b\}
    function ParseVisionPrescriptionLensSpecificationPrism(obj : TTurtleComplex) : TFhirVisionPrescriptionLensSpecificationPrism; overload; {b\}
    procedure ParseVisionPrescriptionLensSpecificationPrismProperties(obj : TTurtleComplex; result : TFhirVisionPrescriptionLensSpecificationPrism); overload; {b\}
    function ParseVisionPrescription(obj : TTurtleComplex) : TFhirVisionPrescription; overload;
    procedure ParseVisionPrescriptionProperties(obj : TTurtleComplex; result : TFhirVisionPrescription); overload;
{$ENDIF FHIR_VISIONPRESCRIPTION}
    function ParseResource(obj : TTurtleComplex) : TFhirResource; override;
    function ParseDataType(obj : TTurtleComplex; name : String; type_ : TFHIRTypeClass) : TFHIRType; override;
  public
    function ParseFragment(obj : TTurtleComplex; type_ : String) : TFHIRObject;  overload;
  end;

  TFHIRTurtleComposer = class (TFHIRTurtleComposerBase4)
  protected
    procedure ComposeElement(parent :  TTurtleComplex; parentType, name : String; elem : TFhirElement; useType : boolean; index : integer);


    procedure ComposeBackboneElement(parent :  TTurtleComplex; parentType, name : String; elem : TFhirBackboneElement; useType : boolean; index : integer);
    procedure ComposeBackboneType(parent :  TTurtleComplex; parentType, name : String; elem : TFhirBackboneType; useType : boolean; index : integer);


    Procedure ComposeEnum(parent :  TTurtleComplex; parentType, name : String; value : TFhirEnum; Const aNames, aSystems : Array Of String; useType : boolean; index : integer);
    Procedure ComposeDate(parent :  TTurtleComplex; parentType, name : String; value : TFhirDate; useType : boolean; index : integer);
    Procedure ComposeDateTime(parent :  TTurtleComplex; parentType, name : String; value : TFhirDateTime; useType : boolean; index : integer);
    Procedure ComposeString(parent :  TTurtleComplex; parentType, name : String; value : TFhirString; useType : boolean; index : integer);
    Procedure ComposeInteger(parent :  TTurtleComplex; parentType, name : String; value : TFhirInteger; useType : boolean; index : integer);
    Procedure ComposeUri(parent :  TTurtleComplex; parentType, name : String; value : TFhirUri; useType : boolean; index : integer);
    Procedure ComposeInstant(parent :  TTurtleComplex; parentType, name : String; value : TFhirInstant; useType : boolean; index : integer);
    Procedure ComposeXhtml(parent :  TTurtleComplex; parentType, name : String; value : TFhirXhtml; useType : boolean; index : integer);
    Procedure ComposeBoolean(parent :  TTurtleComplex; parentType, name : String; value : TFhirBoolean; useType : boolean; index : integer);
    Procedure ComposeBase64Binary(parent :  TTurtleComplex; parentType, name : String; value : TFhirBase64Binary; useType : boolean; index : integer);
    Procedure ComposeTime(parent :  TTurtleComplex; parentType, name : String; value : TFhirTime; useType : boolean; index : integer);
    Procedure ComposeDecimal(parent :  TTurtleComplex; parentType, name : String; value : TFhirDecimal; useType : boolean; index : integer);
    Procedure ComposeCode(parent :  TTurtleComplex; parentType, name : String; value : TFhirCode; useType : boolean; index : integer);
    Procedure ComposeCanonical(parent :  TTurtleComplex; parentType, name : String; value : TFhirCanonical; useType : boolean; index : integer);
    Procedure ComposeOid(parent :  TTurtleComplex; parentType, name : String; value : TFhirOid; useType : boolean; index : integer);
    Procedure ComposeUuid(parent :  TTurtleComplex; parentType, name : String; value : TFhirUuid; useType : boolean; index : integer);
    Procedure ComposeUrl(parent :  TTurtleComplex; parentType, name : String; value : TFhirUrl; useType : boolean; index : integer);
    Procedure ComposeMarkdown(parent :  TTurtleComplex; parentType, name : String; value : TFhirMarkdown; useType : boolean; index : integer);
    Procedure ComposeUnsignedInt(parent :  TTurtleComplex; parentType, name : String; value : TFhirUnsignedInt; useType : boolean; index : integer);
    Procedure ComposeId(parent :  TTurtleComplex; parentType, name : String; value : TFhirId; useType : boolean; index : integer);
    Procedure ComposePositiveInt(parent :  TTurtleComplex; parentType, name : String; value : TFhirPositiveInt; useType : boolean; index : integer);


    Procedure ComposeResource(this : TTurtleComplex; parentType, name : String; elem : TFhirResource; useType : boolean; index : integer); overload;
    Procedure ComposeDomainResource(this : TTurtleComplex; parentType, name : String; elem : TFhirDomainResource; useType : boolean; index : integer); overload;
{$IFDEF FHIR_PARAMETERS}
    procedure ComposeParametersParameter(parent :  TTurtleComplex; parentType, name : String; elem : TFhirParametersParameter; useType : boolean; index : integer);
    procedure ComposeParameters(parent :  TTurtleComplex; parentType, name : String; elem : TFhirParameters; useType : boolean; index : integer);
{$ENDIF FHIR_PARAMETERS}


    procedure ComposeExtension(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExtension; useType : boolean; index : integer);
    procedure ComposeNarrative(parent :  TTurtleComplex; parentType, name : String; elem : TFhirNarrative; useType : boolean; index : integer);
    procedure ComposeContributor(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContributor; useType : boolean; index : integer);
    procedure ComposeAttachment(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAttachment; useType : boolean; index : integer);
    procedure ComposeDataRequirementCodeFilter(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDataRequirementCodeFilter; useType : boolean; index : integer);
    procedure ComposeDataRequirementDateFilter(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDataRequirementDateFilter; useType : boolean; index : integer);
    procedure ComposeDataRequirementSort(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDataRequirementSort; useType : boolean; index : integer);
    procedure ComposeDataRequirement(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDataRequirement; useType : boolean; index : integer);
    procedure ComposeDosageDoseAndRate(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDosageDoseAndRate; useType : boolean; index : integer);
    procedure ComposeDosage(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDosage; useType : boolean; index : integer);
    procedure ComposeMoney(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMoney; useType : boolean; index : integer);
    procedure ComposeMarketingStatus(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMarketingStatus; useType : boolean; index : integer);
    procedure ComposeIdentifier(parent :  TTurtleComplex; parentType, name : String; elem : TFhirIdentifier; useType : boolean; index : integer);
    procedure ComposeSubstanceAmountReferenceRange(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstanceAmountReferenceRange; useType : boolean; index : integer);
    procedure ComposeSubstanceAmount(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstanceAmount; useType : boolean; index : integer);
    procedure ComposeCoding(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCoding; useType : boolean; index : integer);
    procedure ComposeSampledData(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSampledData; useType : boolean; index : integer);
    procedure ComposePopulation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPopulation; useType : boolean; index : integer);
    procedure ComposeRatio(parent :  TTurtleComplex; parentType, name : String; elem : TFhirRatio; useType : boolean; index : integer);
    procedure ComposeReference(parent :  TTurtleComplex; parentType, name : String; elem : TFhirReference; useType : boolean; index : integer);
    procedure ComposeTriggerDefinition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTriggerDefinition; useType : boolean; index : integer);
    procedure ComposePeriod(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPeriod; useType : boolean; index : integer);
    procedure ComposeQuantity(parent :  TTurtleComplex; parentType, name : String; elem : TFhirQuantity; useType : boolean; index : integer);
    procedure ComposeRange(parent :  TTurtleComplex; parentType, name : String; elem : TFhirRange; useType : boolean; index : integer);
    procedure ComposeRelatedArtifact(parent :  TTurtleComplex; parentType, name : String; elem : TFhirRelatedArtifact; useType : boolean; index : integer);
    procedure ComposeAnnotation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAnnotation; useType : boolean; index : integer);
    procedure ComposeProductShelfLife(parent :  TTurtleComplex; parentType, name : String; elem : TFhirProductShelfLife; useType : boolean; index : integer);
    procedure ComposeContactDetail(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContactDetail; useType : boolean; index : integer);
    procedure ComposeExpression(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExpression; useType : boolean; index : integer);
    procedure ComposeUsageContext(parent :  TTurtleComplex; parentType, name : String; elem : TFhirUsageContext; useType : boolean; index : integer);
    procedure ComposeSignature(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSignature; useType : boolean; index : integer);
    procedure ComposeProdCharacteristic(parent :  TTurtleComplex; parentType, name : String; elem : TFhirProdCharacteristic; useType : boolean; index : integer);
    procedure ComposeCodeableConcept(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCodeableConcept; useType : boolean; index : integer);
    procedure ComposeParameterDefinition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirParameterDefinition; useType : boolean; index : integer);
    procedure ComposeContactPoint(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContactPoint; useType : boolean; index : integer);
    procedure ComposeHumanName(parent :  TTurtleComplex; parentType, name : String; elem : TFhirHumanName; useType : boolean; index : integer);
    procedure ComposeMeta(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMeta; useType : boolean; index : integer);
    procedure ComposeAddress(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAddress; useType : boolean; index : integer);
    procedure ComposeElementDefinitionSlicing(parent :  TTurtleComplex; parentType, name : String; elem : TFhirElementDefinitionSlicing; useType : boolean; index : integer);
    procedure ComposeElementDefinitionSlicingDiscriminator(parent :  TTurtleComplex; parentType, name : String; elem : TFhirElementDefinitionSlicingDiscriminator; useType : boolean; index : integer);
    procedure ComposeElementDefinitionBase(parent :  TTurtleComplex; parentType, name : String; elem : TFhirElementDefinitionBase; useType : boolean; index : integer);
    procedure ComposeElementDefinitionType(parent :  TTurtleComplex; parentType, name : String; elem : TFhirElementDefinitionType; useType : boolean; index : integer);
    procedure ComposeElementDefinitionExample(parent :  TTurtleComplex; parentType, name : String; elem : TFhirElementDefinitionExample; useType : boolean; index : integer);
    procedure ComposeElementDefinitionConstraint(parent :  TTurtleComplex; parentType, name : String; elem : TFhirElementDefinitionConstraint; useType : boolean; index : integer);
    procedure ComposeElementDefinitionBinding(parent :  TTurtleComplex; parentType, name : String; elem : TFhirElementDefinitionBinding; useType : boolean; index : integer);
    procedure ComposeElementDefinitionMapping(parent :  TTurtleComplex; parentType, name : String; elem : TFhirElementDefinitionMapping; useType : boolean; index : integer);
    procedure ComposeElementDefinition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirElementDefinition; useType : boolean; index : integer);
    procedure ComposeTimingRepeat(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTimingRepeat; useType : boolean; index : integer);
    procedure ComposeTiming(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTiming; useType : boolean; index : integer);
    procedure ComposeCount(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCount; useType : boolean; index : integer);
    procedure ComposeAge(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAge; useType : boolean; index : integer);
    procedure ComposeDistance(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDistance; useType : boolean; index : integer);
    procedure ComposeDuration(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDuration; useType : boolean; index : integer);


{$IFDEF FHIR_ACCOUNT}
    procedure ComposeAccountCoverage(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAccountCoverage; useType : boolean; index : integer);
    procedure ComposeAccountGuarantor(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAccountGuarantor; useType : boolean; index : integer);
    procedure ComposeAccount(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAccount; useType : boolean; index : integer);
{$ENDIF FHIR_ACCOUNT}
{$IFDEF FHIR_ACTIVITYDEFINITION}
    procedure ComposeActivityDefinitionParticipant(parent :  TTurtleComplex; parentType, name : String; elem : TFhirActivityDefinitionParticipant; useType : boolean; index : integer);
    procedure ComposeActivityDefinitionDynamicValue(parent :  TTurtleComplex; parentType, name : String; elem : TFhirActivityDefinitionDynamicValue; useType : boolean; index : integer);
    procedure ComposeActivityDefinition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirActivityDefinition; useType : boolean; index : integer);
{$ENDIF FHIR_ACTIVITYDEFINITION}
{$IFDEF FHIR_ADVERSEEVENT}
    procedure ComposeAdverseEventSuspectEntity(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAdverseEventSuspectEntity; useType : boolean; index : integer);
    procedure ComposeAdverseEventSuspectEntityCausality(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAdverseEventSuspectEntityCausality; useType : boolean; index : integer);
    procedure ComposeAdverseEvent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAdverseEvent; useType : boolean; index : integer);
{$ENDIF FHIR_ADVERSEEVENT}
{$IFDEF FHIR_ALLERGYINTOLERANCE}
    procedure ComposeAllergyIntoleranceReaction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAllergyIntoleranceReaction; useType : boolean; index : integer);
    procedure ComposeAllergyIntolerance(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAllergyIntolerance; useType : boolean; index : integer);
{$ENDIF FHIR_ALLERGYINTOLERANCE}
{$IFDEF FHIR_APPOINTMENT}
    procedure ComposeAppointmentParticipant(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAppointmentParticipant; useType : boolean; index : integer);
    procedure ComposeAppointment(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAppointment; useType : boolean; index : integer);
{$ENDIF FHIR_APPOINTMENT}
{$IFDEF FHIR_APPOINTMENTRESPONSE}
    procedure ComposeAppointmentResponse(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAppointmentResponse; useType : boolean; index : integer);
{$ENDIF FHIR_APPOINTMENTRESPONSE}
{$IFDEF FHIR_AUDITEVENT}
    procedure ComposeAuditEventAgent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAuditEventAgent; useType : boolean; index : integer);
    procedure ComposeAuditEventAgentNetwork(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAuditEventAgentNetwork; useType : boolean; index : integer);
    procedure ComposeAuditEventSource(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAuditEventSource; useType : boolean; index : integer);
    procedure ComposeAuditEventEntity(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAuditEventEntity; useType : boolean; index : integer);
    procedure ComposeAuditEventEntityDetail(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAuditEventEntityDetail; useType : boolean; index : integer);
    procedure ComposeAuditEvent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAuditEvent; useType : boolean; index : integer);
{$ENDIF FHIR_AUDITEVENT}
{$IFDEF FHIR_BASIC}
    procedure ComposeBasic(parent :  TTurtleComplex; parentType, name : String; elem : TFhirBasic; useType : boolean; index : integer);
{$ENDIF FHIR_BASIC}
{$IFDEF FHIR_BINARY}
    procedure ComposeBinary(parent :  TTurtleComplex; parentType, name : String; elem : TFhirBinary; useType : boolean; index : integer);
{$ENDIF FHIR_BINARY}
{$IFDEF FHIR_BIOLOGICALLYDERIVEDPRODUCT}
    procedure ComposeBiologicallyDerivedProductCollection(parent :  TTurtleComplex; parentType, name : String; elem : TFhirBiologicallyDerivedProductCollection; useType : boolean; index : integer);
    procedure ComposeBiologicallyDerivedProductProcessing(parent :  TTurtleComplex; parentType, name : String; elem : TFhirBiologicallyDerivedProductProcessing; useType : boolean; index : integer);
    procedure ComposeBiologicallyDerivedProductManipulation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirBiologicallyDerivedProductManipulation; useType : boolean; index : integer);
    procedure ComposeBiologicallyDerivedProductStorage(parent :  TTurtleComplex; parentType, name : String; elem : TFhirBiologicallyDerivedProductStorage; useType : boolean; index : integer);
    procedure ComposeBiologicallyDerivedProduct(parent :  TTurtleComplex; parentType, name : String; elem : TFhirBiologicallyDerivedProduct; useType : boolean; index : integer);
{$ENDIF FHIR_BIOLOGICALLYDERIVEDPRODUCT}
{$IFDEF FHIR_BODYSTRUCTURE}
    procedure ComposeBodyStructure(parent :  TTurtleComplex; parentType, name : String; elem : TFhirBodyStructure; useType : boolean; index : integer);
{$ENDIF FHIR_BODYSTRUCTURE}
{$IFDEF FHIR_BUNDLE}
    procedure ComposeBundleLink(parent :  TTurtleComplex; parentType, name : String; elem : TFhirBundleLink; useType : boolean; index : integer);
    procedure ComposeBundleEntry(parent :  TTurtleComplex; parentType, name : String; elem : TFhirBundleEntry; useType : boolean; index : integer);
    procedure ComposeBundleEntrySearch(parent :  TTurtleComplex; parentType, name : String; elem : TFhirBundleEntrySearch; useType : boolean; index : integer);
    procedure ComposeBundleEntryRequest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirBundleEntryRequest; useType : boolean; index : integer);
    procedure ComposeBundleEntryResponse(parent :  TTurtleComplex; parentType, name : String; elem : TFhirBundleEntryResponse; useType : boolean; index : integer);
    procedure ComposeBundle(parent :  TTurtleComplex; parentType, name : String; elem : TFhirBundle; useType : boolean; index : integer);
{$ENDIF FHIR_BUNDLE}
{$IFDEF FHIR_CAPABILITYSTATEMENT}
    procedure ComposeCapabilityStatementSoftware(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCapabilityStatementSoftware; useType : boolean; index : integer);
    procedure ComposeCapabilityStatementImplementation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCapabilityStatementImplementation; useType : boolean; index : integer);
    procedure ComposeCapabilityStatementRest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCapabilityStatementRest; useType : boolean; index : integer);
    procedure ComposeCapabilityStatementRestSecurity(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCapabilityStatementRestSecurity; useType : boolean; index : integer);
    procedure ComposeCapabilityStatementRestResource(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCapabilityStatementRestResource; useType : boolean; index : integer);
    procedure ComposeCapabilityStatementRestResourceInteraction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCapabilityStatementRestResourceInteraction; useType : boolean; index : integer);
    procedure ComposeCapabilityStatementRestResourceSearchParam(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCapabilityStatementRestResourceSearchParam; useType : boolean; index : integer);
    procedure ComposeCapabilityStatementRestResourceOperation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCapabilityStatementRestResourceOperation; useType : boolean; index : integer);
    procedure ComposeCapabilityStatementRestInteraction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCapabilityStatementRestInteraction; useType : boolean; index : integer);
    procedure ComposeCapabilityStatementMessaging(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCapabilityStatementMessaging; useType : boolean; index : integer);
    procedure ComposeCapabilityStatementMessagingEndpoint(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCapabilityStatementMessagingEndpoint; useType : boolean; index : integer);
    procedure ComposeCapabilityStatementMessagingSupportedMessage(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCapabilityStatementMessagingSupportedMessage; useType : boolean; index : integer);
    procedure ComposeCapabilityStatementDocument(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCapabilityStatementDocument; useType : boolean; index : integer);
    procedure ComposeCapabilityStatement(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCapabilityStatement; useType : boolean; index : integer);
{$ENDIF FHIR_CAPABILITYSTATEMENT}
{$IFDEF FHIR_CAREPLAN}
    procedure ComposeCarePlanActivity(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCarePlanActivity; useType : boolean; index : integer);
    procedure ComposeCarePlanActivityDetail(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCarePlanActivityDetail; useType : boolean; index : integer);
    procedure ComposeCarePlan(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCarePlan; useType : boolean; index : integer);
{$ENDIF FHIR_CAREPLAN}
{$IFDEF FHIR_CARETEAM}
    procedure ComposeCareTeamParticipant(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCareTeamParticipant; useType : boolean; index : integer);
    procedure ComposeCareTeam(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCareTeam; useType : boolean; index : integer);
{$ENDIF FHIR_CARETEAM}
{$IFDEF FHIR_CATALOGENTRY}
    procedure ComposeCatalogEntryRelatedEntry(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCatalogEntryRelatedEntry; useType : boolean; index : integer);
    procedure ComposeCatalogEntry(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCatalogEntry; useType : boolean; index : integer);
{$ENDIF FHIR_CATALOGENTRY}
{$IFDEF FHIR_CHARGEITEM}
    procedure ComposeChargeItemPerformer(parent :  TTurtleComplex; parentType, name : String; elem : TFhirChargeItemPerformer; useType : boolean; index : integer);
    procedure ComposeChargeItem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirChargeItem; useType : boolean; index : integer);
{$ENDIF FHIR_CHARGEITEM}
{$IFDEF FHIR_CHARGEITEMDEFINITION}
    procedure ComposeChargeItemDefinitionApplicability(parent :  TTurtleComplex; parentType, name : String; elem : TFhirChargeItemDefinitionApplicability; useType : boolean; index : integer);
    procedure ComposeChargeItemDefinitionPropertyGroup(parent :  TTurtleComplex; parentType, name : String; elem : TFhirChargeItemDefinitionPropertyGroup; useType : boolean; index : integer);
    procedure ComposeChargeItemDefinitionPropertyGroupPriceComponent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirChargeItemDefinitionPropertyGroupPriceComponent; useType : boolean; index : integer);
    procedure ComposeChargeItemDefinition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirChargeItemDefinition; useType : boolean; index : integer);
{$ENDIF FHIR_CHARGEITEMDEFINITION}
{$IFDEF FHIR_CLAIM}
    procedure ComposeClaimRelated(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimRelated; useType : boolean; index : integer);
    procedure ComposeClaimPayee(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimPayee; useType : boolean; index : integer);
    procedure ComposeClaimCareTeam(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimCareTeam; useType : boolean; index : integer);
    procedure ComposeClaimSupportingInfo(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimSupportingInfo; useType : boolean; index : integer);
    procedure ComposeClaimDiagnosis(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimDiagnosis; useType : boolean; index : integer);
    procedure ComposeClaimProcedure(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimProcedure; useType : boolean; index : integer);
    procedure ComposeClaimInsurance(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimInsurance; useType : boolean; index : integer);
    procedure ComposeClaimAccident(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimAccident; useType : boolean; index : integer);
    procedure ComposeClaimItem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimItem; useType : boolean; index : integer);
    procedure ComposeClaimItemDetail(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimItemDetail; useType : boolean; index : integer);
    procedure ComposeClaimItemDetailSubDetail(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimItemDetailSubDetail; useType : boolean; index : integer);
    procedure ComposeClaim(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaim; useType : boolean; index : integer);
{$ENDIF FHIR_CLAIM}
{$IFDEF FHIR_CLAIMRESPONSE}
    procedure ComposeClaimResponseItem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponseItem; useType : boolean; index : integer);
    procedure ComposeClaimResponseItemAdjudication(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponseItemAdjudication; useType : boolean; index : integer);
    procedure ComposeClaimResponseItemDetail(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponseItemDetail; useType : boolean; index : integer);
    procedure ComposeClaimResponseItemDetailSubDetail(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponseItemDetailSubDetail; useType : boolean; index : integer);
    procedure ComposeClaimResponseAddItem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponseAddItem; useType : boolean; index : integer);
    procedure ComposeClaimResponseAddItemDetail(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponseAddItemDetail; useType : boolean; index : integer);
    procedure ComposeClaimResponseAddItemDetailSubDetail(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponseAddItemDetailSubDetail; useType : boolean; index : integer);
    procedure ComposeClaimResponseTotal(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponseTotal; useType : boolean; index : integer);
    procedure ComposeClaimResponsePayment(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponsePayment; useType : boolean; index : integer);
    procedure ComposeClaimResponseProcessNote(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponseProcessNote; useType : boolean; index : integer);
    procedure ComposeClaimResponseInsurance(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponseInsurance; useType : boolean; index : integer);
    procedure ComposeClaimResponseError(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponseError; useType : boolean; index : integer);
    procedure ComposeClaimResponse(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponse; useType : boolean; index : integer);
{$ENDIF FHIR_CLAIMRESPONSE}
{$IFDEF FHIR_CLINICALIMPRESSION}
    procedure ComposeClinicalImpressionInvestigation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClinicalImpressionInvestigation; useType : boolean; index : integer);
    procedure ComposeClinicalImpressionFinding(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClinicalImpressionFinding; useType : boolean; index : integer);
    procedure ComposeClinicalImpression(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClinicalImpression; useType : boolean; index : integer);
{$ENDIF FHIR_CLINICALIMPRESSION}
{$IFDEF FHIR_CODESYSTEM}
    procedure ComposeCodeSystemFilter(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCodeSystemFilter; useType : boolean; index : integer);
    procedure ComposeCodeSystemProperty(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCodeSystemProperty; useType : boolean; index : integer);
    procedure ComposeCodeSystemConcept(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCodeSystemConcept; useType : boolean; index : integer);
    procedure ComposeCodeSystemConceptDesignation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCodeSystemConceptDesignation; useType : boolean; index : integer);
    procedure ComposeCodeSystemConceptProperty(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCodeSystemConceptProperty; useType : boolean; index : integer);
    procedure ComposeCodeSystem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCodeSystem; useType : boolean; index : integer);
{$ENDIF FHIR_CODESYSTEM}
{$IFDEF FHIR_COMMUNICATION}
    procedure ComposeCommunicationPayload(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCommunicationPayload; useType : boolean; index : integer);
    procedure ComposeCommunication(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCommunication; useType : boolean; index : integer);
{$ENDIF FHIR_COMMUNICATION}
{$IFDEF FHIR_COMMUNICATIONREQUEST}
    procedure ComposeCommunicationRequestPayload(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCommunicationRequestPayload; useType : boolean; index : integer);
    procedure ComposeCommunicationRequest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCommunicationRequest; useType : boolean; index : integer);
{$ENDIF FHIR_COMMUNICATIONREQUEST}
{$IFDEF FHIR_COMPARTMENTDEFINITION}
    procedure ComposeCompartmentDefinitionResource(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCompartmentDefinitionResource; useType : boolean; index : integer);
    procedure ComposeCompartmentDefinition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCompartmentDefinition; useType : boolean; index : integer);
{$ENDIF FHIR_COMPARTMENTDEFINITION}
{$IFDEF FHIR_COMPOSITION}
    procedure ComposeCompositionAttester(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCompositionAttester; useType : boolean; index : integer);
    procedure ComposeCompositionRelatesTo(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCompositionRelatesTo; useType : boolean; index : integer);
    procedure ComposeCompositionEvent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCompositionEvent; useType : boolean; index : integer);
    procedure ComposeCompositionSection(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCompositionSection; useType : boolean; index : integer);
    procedure ComposeComposition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirComposition; useType : boolean; index : integer);
{$ENDIF FHIR_COMPOSITION}
{$IFDEF FHIR_CONCEPTMAP}
    procedure ComposeConceptMapGroup(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConceptMapGroup; useType : boolean; index : integer);
    procedure ComposeConceptMapGroupElement(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConceptMapGroupElement; useType : boolean; index : integer);
    procedure ComposeConceptMapGroupElementTarget(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConceptMapGroupElementTarget; useType : boolean; index : integer);
    procedure ComposeConceptMapGroupElementTargetDependsOn(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConceptMapGroupElementTargetDependsOn; useType : boolean; index : integer);
    procedure ComposeConceptMapGroupUnmapped(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConceptMapGroupUnmapped; useType : boolean; index : integer);
    procedure ComposeConceptMap(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConceptMap; useType : boolean; index : integer);
{$ENDIF FHIR_CONCEPTMAP}
{$IFDEF FHIR_CONDITION}
    procedure ComposeConditionStage(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConditionStage; useType : boolean; index : integer);
    procedure ComposeConditionEvidence(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConditionEvidence; useType : boolean; index : integer);
    procedure ComposeCondition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCondition; useType : boolean; index : integer);
{$ENDIF FHIR_CONDITION}
{$IFDEF FHIR_CONSENT}
    procedure ComposeConsentPolicy(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConsentPolicy; useType : boolean; index : integer);
    procedure ComposeConsentVerification(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConsentVerification; useType : boolean; index : integer);
    procedure ComposeConsentProvision(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConsentProvision; useType : boolean; index : integer);
    procedure ComposeConsentProvisionActor(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConsentProvisionActor; useType : boolean; index : integer);
    procedure ComposeConsentProvisionData(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConsentProvisionData; useType : boolean; index : integer);
    procedure ComposeConsent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConsent; useType : boolean; index : integer);
{$ENDIF FHIR_CONSENT}
{$IFDEF FHIR_CONTRACT}
    procedure ComposeContractContentDefinition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContractContentDefinition; useType : boolean; index : integer);
    procedure ComposeContractTerm(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContractTerm; useType : boolean; index : integer);
    procedure ComposeContractTermSecurityLabel(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContractTermSecurityLabel; useType : boolean; index : integer);
    procedure ComposeContractTermOffer(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContractTermOffer; useType : boolean; index : integer);
    procedure ComposeContractTermOfferParty(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContractTermOfferParty; useType : boolean; index : integer);
    procedure ComposeContractTermOfferAnswer(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContractTermOfferAnswer; useType : boolean; index : integer);
    procedure ComposeContractTermAsset(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContractTermAsset; useType : boolean; index : integer);
    procedure ComposeContractTermAssetContext(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContractTermAssetContext; useType : boolean; index : integer);
    procedure ComposeContractTermAssetValuedItem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContractTermAssetValuedItem; useType : boolean; index : integer);
    procedure ComposeContractTermAction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContractTermAction; useType : boolean; index : integer);
    procedure ComposeContractTermActionSubject(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContractTermActionSubject; useType : boolean; index : integer);
    procedure ComposeContractSigner(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContractSigner; useType : boolean; index : integer);
    procedure ComposeContractFriendly(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContractFriendly; useType : boolean; index : integer);
    procedure ComposeContractLegal(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContractLegal; useType : boolean; index : integer);
    procedure ComposeContractRule(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContractRule; useType : boolean; index : integer);
    procedure ComposeContract(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContract; useType : boolean; index : integer);
{$ENDIF FHIR_CONTRACT}
{$IFDEF FHIR_COVERAGE}
    procedure ComposeCoverageClass(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCoverageClass; useType : boolean; index : integer);
    procedure ComposeCoverageCostToBeneficiary(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCoverageCostToBeneficiary; useType : boolean; index : integer);
    procedure ComposeCoverageCostToBeneficiaryException(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCoverageCostToBeneficiaryException; useType : boolean; index : integer);
    procedure ComposeCoverage(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCoverage; useType : boolean; index : integer);
{$ENDIF FHIR_COVERAGE}
{$IFDEF FHIR_COVERAGEELIGIBILITYREQUEST}
    procedure ComposeCoverageEligibilityRequestSupportingInfo(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCoverageEligibilityRequestSupportingInfo; useType : boolean; index : integer);
    procedure ComposeCoverageEligibilityRequestInsurance(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCoverageEligibilityRequestInsurance; useType : boolean; index : integer);
    procedure ComposeCoverageEligibilityRequestItem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCoverageEligibilityRequestItem; useType : boolean; index : integer);
    procedure ComposeCoverageEligibilityRequestItemDiagnosis(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCoverageEligibilityRequestItemDiagnosis; useType : boolean; index : integer);
    procedure ComposeCoverageEligibilityRequest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCoverageEligibilityRequest; useType : boolean; index : integer);
{$ENDIF FHIR_COVERAGEELIGIBILITYREQUEST}
{$IFDEF FHIR_COVERAGEELIGIBILITYRESPONSE}
    procedure ComposeCoverageEligibilityResponseInsurance(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCoverageEligibilityResponseInsurance; useType : boolean; index : integer);
    procedure ComposeCoverageEligibilityResponseInsuranceItem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCoverageEligibilityResponseInsuranceItem; useType : boolean; index : integer);
    procedure ComposeCoverageEligibilityResponseInsuranceItemBenefit(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCoverageEligibilityResponseInsuranceItemBenefit; useType : boolean; index : integer);
    procedure ComposeCoverageEligibilityResponseError(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCoverageEligibilityResponseError; useType : boolean; index : integer);
    procedure ComposeCoverageEligibilityResponse(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCoverageEligibilityResponse; useType : boolean; index : integer);
{$ENDIF FHIR_COVERAGEELIGIBILITYRESPONSE}
{$IFDEF FHIR_DETECTEDISSUE}
    procedure ComposeDetectedIssueEvidence(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDetectedIssueEvidence; useType : boolean; index : integer);
    procedure ComposeDetectedIssueMitigation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDetectedIssueMitigation; useType : boolean; index : integer);
    procedure ComposeDetectedIssue(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDetectedIssue; useType : boolean; index : integer);
{$ENDIF FHIR_DETECTEDISSUE}
{$IFDEF FHIR_DEVICE}
    procedure ComposeDeviceUdiCarrier(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDeviceUdiCarrier; useType : boolean; index : integer);
    procedure ComposeDeviceDeviceName(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDeviceDeviceName; useType : boolean; index : integer);
    procedure ComposeDeviceSpecialization(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDeviceSpecialization; useType : boolean; index : integer);
    procedure ComposeDeviceVersion(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDeviceVersion; useType : boolean; index : integer);
    procedure ComposeDeviceProperty(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDeviceProperty; useType : boolean; index : integer);
    procedure ComposeDevice(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDevice; useType : boolean; index : integer);
{$ENDIF FHIR_DEVICE}
{$IFDEF FHIR_DEVICEDEFINITION}
    procedure ComposeDeviceDefinitionUdiDeviceIdentifier(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDeviceDefinitionUdiDeviceIdentifier; useType : boolean; index : integer);
    procedure ComposeDeviceDefinitionDeviceName(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDeviceDefinitionDeviceName; useType : boolean; index : integer);
    procedure ComposeDeviceDefinitionSpecialization(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDeviceDefinitionSpecialization; useType : boolean; index : integer);
    procedure ComposeDeviceDefinitionCapability(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDeviceDefinitionCapability; useType : boolean; index : integer);
    procedure ComposeDeviceDefinitionProperty(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDeviceDefinitionProperty; useType : boolean; index : integer);
    procedure ComposeDeviceDefinitionMaterial(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDeviceDefinitionMaterial; useType : boolean; index : integer);
    procedure ComposeDeviceDefinition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDeviceDefinition; useType : boolean; index : integer);
{$ENDIF FHIR_DEVICEDEFINITION}
{$IFDEF FHIR_DEVICEMETRIC}
    procedure ComposeDeviceMetricCalibration(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDeviceMetricCalibration; useType : boolean; index : integer);
    procedure ComposeDeviceMetric(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDeviceMetric; useType : boolean; index : integer);
{$ENDIF FHIR_DEVICEMETRIC}
{$IFDEF FHIR_DEVICEREQUEST}
    procedure ComposeDeviceRequestParameter(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDeviceRequestParameter; useType : boolean; index : integer);
    procedure ComposeDeviceRequest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDeviceRequest; useType : boolean; index : integer);
{$ENDIF FHIR_DEVICEREQUEST}
{$IFDEF FHIR_DEVICEUSESTATEMENT}
    procedure ComposeDeviceUseStatement(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDeviceUseStatement; useType : boolean; index : integer);
{$ENDIF FHIR_DEVICEUSESTATEMENT}
{$IFDEF FHIR_DIAGNOSTICREPORT}
    procedure ComposeDiagnosticReportMedia(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDiagnosticReportMedia; useType : boolean; index : integer);
    procedure ComposeDiagnosticReport(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDiagnosticReport; useType : boolean; index : integer);
{$ENDIF FHIR_DIAGNOSTICREPORT}
{$IFDEF FHIR_DOCUMENTMANIFEST}
    procedure ComposeDocumentManifestRelated(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDocumentManifestRelated; useType : boolean; index : integer);
    procedure ComposeDocumentManifest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDocumentManifest; useType : boolean; index : integer);
{$ENDIF FHIR_DOCUMENTMANIFEST}
{$IFDEF FHIR_DOCUMENTREFERENCE}
    procedure ComposeDocumentReferenceRelatesTo(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDocumentReferenceRelatesTo; useType : boolean; index : integer);
    procedure ComposeDocumentReferenceContent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDocumentReferenceContent; useType : boolean; index : integer);
    procedure ComposeDocumentReferenceContext(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDocumentReferenceContext; useType : boolean; index : integer);
    procedure ComposeDocumentReference(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDocumentReference; useType : boolean; index : integer);
{$ENDIF FHIR_DOCUMENTREFERENCE}
{$IFDEF FHIR_EFFECTEVIDENCESYNTHESIS}
    procedure ComposeEffectEvidenceSynthesisSampleSize(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEffectEvidenceSynthesisSampleSize; useType : boolean; index : integer);
    procedure ComposeEffectEvidenceSynthesisResultsByExposure(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEffectEvidenceSynthesisResultsByExposure; useType : boolean; index : integer);
    procedure ComposeEffectEvidenceSynthesisEffectEstimate(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEffectEvidenceSynthesisEffectEstimate; useType : boolean; index : integer);
    procedure ComposeEffectEvidenceSynthesisEffectEstimatePrecisionEstimate(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate; useType : boolean; index : integer);
    procedure ComposeEffectEvidenceSynthesisCertainty(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEffectEvidenceSynthesisCertainty; useType : boolean; index : integer);
    procedure ComposeEffectEvidenceSynthesisCertaintyCertaintySubcomponent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent; useType : boolean; index : integer);
    procedure ComposeEffectEvidenceSynthesis(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEffectEvidenceSynthesis; useType : boolean; index : integer);
{$ENDIF FHIR_EFFECTEVIDENCESYNTHESIS}
{$IFDEF FHIR_ENCOUNTER}
    procedure ComposeEncounterStatusHistory(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEncounterStatusHistory; useType : boolean; index : integer);
    procedure ComposeEncounterClassHistory(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEncounterClassHistory; useType : boolean; index : integer);
    procedure ComposeEncounterParticipant(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEncounterParticipant; useType : boolean; index : integer);
    procedure ComposeEncounterDiagnosis(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEncounterDiagnosis; useType : boolean; index : integer);
    procedure ComposeEncounterHospitalization(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEncounterHospitalization; useType : boolean; index : integer);
    procedure ComposeEncounterLocation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEncounterLocation; useType : boolean; index : integer);
    procedure ComposeEncounter(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEncounter; useType : boolean; index : integer);
{$ENDIF FHIR_ENCOUNTER}
{$IFDEF FHIR_ENDPOINT}
    procedure ComposeEndpoint(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEndpoint; useType : boolean; index : integer);
{$ENDIF FHIR_ENDPOINT}
{$IFDEF FHIR_ENROLLMENTREQUEST}
    procedure ComposeEnrollmentRequest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEnrollmentRequest; useType : boolean; index : integer);
{$ENDIF FHIR_ENROLLMENTREQUEST}
{$IFDEF FHIR_ENROLLMENTRESPONSE}
    procedure ComposeEnrollmentResponse(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEnrollmentResponse; useType : boolean; index : integer);
{$ENDIF FHIR_ENROLLMENTRESPONSE}
{$IFDEF FHIR_EPISODEOFCARE}
    procedure ComposeEpisodeOfCareStatusHistory(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEpisodeOfCareStatusHistory; useType : boolean; index : integer);
    procedure ComposeEpisodeOfCareDiagnosis(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEpisodeOfCareDiagnosis; useType : boolean; index : integer);
    procedure ComposeEpisodeOfCare(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEpisodeOfCare; useType : boolean; index : integer);
{$ENDIF FHIR_EPISODEOFCARE}
{$IFDEF FHIR_EVENTDEFINITION}
    procedure ComposeEventDefinition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEventDefinition; useType : boolean; index : integer);
{$ENDIF FHIR_EVENTDEFINITION}
{$IFDEF FHIR_EVIDENCE}
    procedure ComposeEvidence(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEvidence; useType : boolean; index : integer);
{$ENDIF FHIR_EVIDENCE}
{$IFDEF FHIR_EVIDENCEVARIABLE}
    procedure ComposeEvidenceVariableCharacteristic(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEvidenceVariableCharacteristic; useType : boolean; index : integer);
    procedure ComposeEvidenceVariable(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEvidenceVariable; useType : boolean; index : integer);
{$ENDIF FHIR_EVIDENCEVARIABLE}
{$IFDEF FHIR_EXAMPLESCENARIO}
    procedure ComposeExampleScenarioActor(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExampleScenarioActor; useType : boolean; index : integer);
    procedure ComposeExampleScenarioInstance(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExampleScenarioInstance; useType : boolean; index : integer);
    procedure ComposeExampleScenarioInstanceVersion(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExampleScenarioInstanceVersion; useType : boolean; index : integer);
    procedure ComposeExampleScenarioInstanceContainedInstance(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExampleScenarioInstanceContainedInstance; useType : boolean; index : integer);
    procedure ComposeExampleScenarioProcess(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExampleScenarioProcess; useType : boolean; index : integer);
    procedure ComposeExampleScenarioProcessStep(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExampleScenarioProcessStep; useType : boolean; index : integer);
    procedure ComposeExampleScenarioProcessStepOperation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExampleScenarioProcessStepOperation; useType : boolean; index : integer);
    procedure ComposeExampleScenarioProcessStepAlternative(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExampleScenarioProcessStepAlternative; useType : boolean; index : integer);
    procedure ComposeExampleScenario(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExampleScenario; useType : boolean; index : integer);
{$ENDIF FHIR_EXAMPLESCENARIO}
{$IFDEF FHIR_EXPLANATIONOFBENEFIT}
    procedure ComposeExplanationOfBenefitRelated(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitRelated; useType : boolean; index : integer);
    procedure ComposeExplanationOfBenefitPayee(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitPayee; useType : boolean; index : integer);
    procedure ComposeExplanationOfBenefitCareTeam(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitCareTeam; useType : boolean; index : integer);
    procedure ComposeExplanationOfBenefitSupportingInfo(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitSupportingInfo; useType : boolean; index : integer);
    procedure ComposeExplanationOfBenefitDiagnosis(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitDiagnosis; useType : boolean; index : integer);
    procedure ComposeExplanationOfBenefitProcedure(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitProcedure; useType : boolean; index : integer);
    procedure ComposeExplanationOfBenefitInsurance(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitInsurance; useType : boolean; index : integer);
    procedure ComposeExplanationOfBenefitAccident(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitAccident; useType : boolean; index : integer);
    procedure ComposeExplanationOfBenefitItem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitItem; useType : boolean; index : integer);
    procedure ComposeExplanationOfBenefitItemAdjudication(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitItemAdjudication; useType : boolean; index : integer);
    procedure ComposeExplanationOfBenefitItemDetail(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitItemDetail; useType : boolean; index : integer);
    procedure ComposeExplanationOfBenefitItemDetailSubDetail(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitItemDetailSubDetail; useType : boolean; index : integer);
    procedure ComposeExplanationOfBenefitAddItem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitAddItem; useType : boolean; index : integer);
    procedure ComposeExplanationOfBenefitAddItemDetail(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitAddItemDetail; useType : boolean; index : integer);
    procedure ComposeExplanationOfBenefitAddItemDetailSubDetail(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitAddItemDetailSubDetail; useType : boolean; index : integer);
    procedure ComposeExplanationOfBenefitTotal(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitTotal; useType : boolean; index : integer);
    procedure ComposeExplanationOfBenefitPayment(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitPayment; useType : boolean; index : integer);
    procedure ComposeExplanationOfBenefitProcessNote(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitProcessNote; useType : boolean; index : integer);
    procedure ComposeExplanationOfBenefitBenefitBalance(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitBenefitBalance; useType : boolean; index : integer);
    procedure ComposeExplanationOfBenefitBenefitBalanceFinancial(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitBenefitBalanceFinancial; useType : boolean; index : integer);
    procedure ComposeExplanationOfBenefit(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefit; useType : boolean; index : integer);
{$ENDIF FHIR_EXPLANATIONOFBENEFIT}
{$IFDEF FHIR_FAMILYMEMBERHISTORY}
    procedure ComposeFamilyMemberHistoryCondition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirFamilyMemberHistoryCondition; useType : boolean; index : integer);
    procedure ComposeFamilyMemberHistory(parent :  TTurtleComplex; parentType, name : String; elem : TFhirFamilyMemberHistory; useType : boolean; index : integer);
{$ENDIF FHIR_FAMILYMEMBERHISTORY}
{$IFDEF FHIR_FLAG}
    procedure ComposeFlag(parent :  TTurtleComplex; parentType, name : String; elem : TFhirFlag; useType : boolean; index : integer);
{$ENDIF FHIR_FLAG}
{$IFDEF FHIR_GOAL}
    procedure ComposeGoalTarget(parent :  TTurtleComplex; parentType, name : String; elem : TFhirGoalTarget; useType : boolean; index : integer);
    procedure ComposeGoal(parent :  TTurtleComplex; parentType, name : String; elem : TFhirGoal; useType : boolean; index : integer);
{$ENDIF FHIR_GOAL}
{$IFDEF FHIR_GRAPHDEFINITION}
    procedure ComposeGraphDefinitionLink(parent :  TTurtleComplex; parentType, name : String; elem : TFhirGraphDefinitionLink; useType : boolean; index : integer);
    procedure ComposeGraphDefinitionLinkTarget(parent :  TTurtleComplex; parentType, name : String; elem : TFhirGraphDefinitionLinkTarget; useType : boolean; index : integer);
    procedure ComposeGraphDefinitionLinkTargetCompartment(parent :  TTurtleComplex; parentType, name : String; elem : TFhirGraphDefinitionLinkTargetCompartment; useType : boolean; index : integer);
    procedure ComposeGraphDefinition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirGraphDefinition; useType : boolean; index : integer);
{$ENDIF FHIR_GRAPHDEFINITION}
{$IFDEF FHIR_GROUP}
    procedure ComposeGroupCharacteristic(parent :  TTurtleComplex; parentType, name : String; elem : TFhirGroupCharacteristic; useType : boolean; index : integer);
    procedure ComposeGroupMember(parent :  TTurtleComplex; parentType, name : String; elem : TFhirGroupMember; useType : boolean; index : integer);
    procedure ComposeGroup(parent :  TTurtleComplex; parentType, name : String; elem : TFhirGroup; useType : boolean; index : integer);
{$ENDIF FHIR_GROUP}
{$IFDEF FHIR_GUIDANCERESPONSE}
    procedure ComposeGuidanceResponse(parent :  TTurtleComplex; parentType, name : String; elem : TFhirGuidanceResponse; useType : boolean; index : integer);
{$ENDIF FHIR_GUIDANCERESPONSE}
{$IFDEF FHIR_HEALTHCARESERVICE}
    procedure ComposeHealthcareServiceEligibility(parent :  TTurtleComplex; parentType, name : String; elem : TFhirHealthcareServiceEligibility; useType : boolean; index : integer);
    procedure ComposeHealthcareServiceAvailableTime(parent :  TTurtleComplex; parentType, name : String; elem : TFhirHealthcareServiceAvailableTime; useType : boolean; index : integer);
    procedure ComposeHealthcareServiceNotAvailable(parent :  TTurtleComplex; parentType, name : String; elem : TFhirHealthcareServiceNotAvailable; useType : boolean; index : integer);
    procedure ComposeHealthcareService(parent :  TTurtleComplex; parentType, name : String; elem : TFhirHealthcareService; useType : boolean; index : integer);
{$ENDIF FHIR_HEALTHCARESERVICE}
{$IFDEF FHIR_IMAGINGSTUDY}
    procedure ComposeImagingStudySeries(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImagingStudySeries; useType : boolean; index : integer);
    procedure ComposeImagingStudySeriesPerformer(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImagingStudySeriesPerformer; useType : boolean; index : integer);
    procedure ComposeImagingStudySeriesInstance(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImagingStudySeriesInstance; useType : boolean; index : integer);
    procedure ComposeImagingStudy(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImagingStudy; useType : boolean; index : integer);
{$ENDIF FHIR_IMAGINGSTUDY}
{$IFDEF FHIR_IMMUNIZATION}
    procedure ComposeImmunizationPerformer(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImmunizationPerformer; useType : boolean; index : integer);
    procedure ComposeImmunizationEducation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImmunizationEducation; useType : boolean; index : integer);
    procedure ComposeImmunizationReaction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImmunizationReaction; useType : boolean; index : integer);
    procedure ComposeImmunizationProtocolApplied(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImmunizationProtocolApplied; useType : boolean; index : integer);
    procedure ComposeImmunization(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImmunization; useType : boolean; index : integer);
{$ENDIF FHIR_IMMUNIZATION}
{$IFDEF FHIR_IMMUNIZATIONEVALUATION}
    procedure ComposeImmunizationEvaluation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImmunizationEvaluation; useType : boolean; index : integer);
{$ENDIF FHIR_IMMUNIZATIONEVALUATION}
{$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
    procedure ComposeImmunizationRecommendationRecommendation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImmunizationRecommendationRecommendation; useType : boolean; index : integer);
    procedure ComposeImmunizationRecommendationRecommendationDateCriterion(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImmunizationRecommendationRecommendationDateCriterion; useType : boolean; index : integer);
    procedure ComposeImmunizationRecommendation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImmunizationRecommendation; useType : boolean; index : integer);
{$ENDIF FHIR_IMMUNIZATIONRECOMMENDATION}
{$IFDEF FHIR_IMPLEMENTATIONGUIDE}
    procedure ComposeImplementationGuideDependsOn(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImplementationGuideDependsOn; useType : boolean; index : integer);
    procedure ComposeImplementationGuideGlobal(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImplementationGuideGlobal; useType : boolean; index : integer);
    procedure ComposeImplementationGuideDefinition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImplementationGuideDefinition; useType : boolean; index : integer);
    procedure ComposeImplementationGuideDefinitionGrouping(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImplementationGuideDefinitionGrouping; useType : boolean; index : integer);
    procedure ComposeImplementationGuideDefinitionResource(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImplementationGuideDefinitionResource; useType : boolean; index : integer);
    procedure ComposeImplementationGuideDefinitionPage(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImplementationGuideDefinitionPage; useType : boolean; index : integer);
    procedure ComposeImplementationGuideDefinitionParameter(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImplementationGuideDefinitionParameter; useType : boolean; index : integer);
    procedure ComposeImplementationGuideDefinitionTemplate(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImplementationGuideDefinitionTemplate; useType : boolean; index : integer);
    procedure ComposeImplementationGuideManifest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImplementationGuideManifest; useType : boolean; index : integer);
    procedure ComposeImplementationGuideManifestResource(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImplementationGuideManifestResource; useType : boolean; index : integer);
    procedure ComposeImplementationGuideManifestPage(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImplementationGuideManifestPage; useType : boolean; index : integer);
    procedure ComposeImplementationGuide(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImplementationGuide; useType : boolean; index : integer);
{$ENDIF FHIR_IMPLEMENTATIONGUIDE}
{$IFDEF FHIR_INSURANCEPLAN}
    procedure ComposeInsurancePlanContact(parent :  TTurtleComplex; parentType, name : String; elem : TFhirInsurancePlanContact; useType : boolean; index : integer);
    procedure ComposeInsurancePlanCoverage(parent :  TTurtleComplex; parentType, name : String; elem : TFhirInsurancePlanCoverage; useType : boolean; index : integer);
    procedure ComposeInsurancePlanCoverageBenefit(parent :  TTurtleComplex; parentType, name : String; elem : TFhirInsurancePlanCoverageBenefit; useType : boolean; index : integer);
    procedure ComposeInsurancePlanCoverageBenefitLimit(parent :  TTurtleComplex; parentType, name : String; elem : TFhirInsurancePlanCoverageBenefitLimit; useType : boolean; index : integer);
    procedure ComposeInsurancePlanPlan(parent :  TTurtleComplex; parentType, name : String; elem : TFhirInsurancePlanPlan; useType : boolean; index : integer);
    procedure ComposeInsurancePlanPlanGeneralCost(parent :  TTurtleComplex; parentType, name : String; elem : TFhirInsurancePlanPlanGeneralCost; useType : boolean; index : integer);
    procedure ComposeInsurancePlanPlanSpecificCost(parent :  TTurtleComplex; parentType, name : String; elem : TFhirInsurancePlanPlanSpecificCost; useType : boolean; index : integer);
    procedure ComposeInsurancePlanPlanSpecificCostBenefit(parent :  TTurtleComplex; parentType, name : String; elem : TFhirInsurancePlanPlanSpecificCostBenefit; useType : boolean; index : integer);
    procedure ComposeInsurancePlanPlanSpecificCostBenefitCost(parent :  TTurtleComplex; parentType, name : String; elem : TFhirInsurancePlanPlanSpecificCostBenefitCost; useType : boolean; index : integer);
    procedure ComposeInsurancePlan(parent :  TTurtleComplex; parentType, name : String; elem : TFhirInsurancePlan; useType : boolean; index : integer);
{$ENDIF FHIR_INSURANCEPLAN}
{$IFDEF FHIR_INVOICE}
    procedure ComposeInvoiceParticipant(parent :  TTurtleComplex; parentType, name : String; elem : TFhirInvoiceParticipant; useType : boolean; index : integer);
    procedure ComposeInvoiceLineItem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirInvoiceLineItem; useType : boolean; index : integer);
    procedure ComposeInvoiceLineItemPriceComponent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirInvoiceLineItemPriceComponent; useType : boolean; index : integer);
    procedure ComposeInvoice(parent :  TTurtleComplex; parentType, name : String; elem : TFhirInvoice; useType : boolean; index : integer);
{$ENDIF FHIR_INVOICE}
{$IFDEF FHIR_LIBRARY}
    procedure ComposeLibrary(parent :  TTurtleComplex; parentType, name : String; elem : TFhirLibrary; useType : boolean; index : integer);
{$ENDIF FHIR_LIBRARY}
{$IFDEF FHIR_LINKAGE}
    procedure ComposeLinkageItem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirLinkageItem; useType : boolean; index : integer);
    procedure ComposeLinkage(parent :  TTurtleComplex; parentType, name : String; elem : TFhirLinkage; useType : boolean; index : integer);
{$ENDIF FHIR_LINKAGE}
{$IFDEF FHIR_LIST}
    procedure ComposeListEntry(parent :  TTurtleComplex; parentType, name : String; elem : TFhirListEntry; useType : boolean; index : integer);
    procedure ComposeList(parent :  TTurtleComplex; parentType, name : String; elem : TFhirList; useType : boolean; index : integer);
{$ENDIF FHIR_LIST}
{$IFDEF FHIR_LOCATION}
    procedure ComposeLocationPosition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirLocationPosition; useType : boolean; index : integer);
    procedure ComposeLocationHoursOfOperation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirLocationHoursOfOperation; useType : boolean; index : integer);
    procedure ComposeLocation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirLocation; useType : boolean; index : integer);
{$ENDIF FHIR_LOCATION}
{$IFDEF FHIR_MEASURE}
    procedure ComposeMeasureGroup(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMeasureGroup; useType : boolean; index : integer);
    procedure ComposeMeasureGroupPopulation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMeasureGroupPopulation; useType : boolean; index : integer);
    procedure ComposeMeasureGroupStratifier(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMeasureGroupStratifier; useType : boolean; index : integer);
    procedure ComposeMeasureGroupStratifierComponent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMeasureGroupStratifierComponent; useType : boolean; index : integer);
    procedure ComposeMeasureSupplementalData(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMeasureSupplementalData; useType : boolean; index : integer);
    procedure ComposeMeasure(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMeasure; useType : boolean; index : integer);
{$ENDIF FHIR_MEASURE}
{$IFDEF FHIR_MEASUREREPORT}
    procedure ComposeMeasureReportGroup(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMeasureReportGroup; useType : boolean; index : integer);
    procedure ComposeMeasureReportGroupPopulation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMeasureReportGroupPopulation; useType : boolean; index : integer);
    procedure ComposeMeasureReportGroupStratifier(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMeasureReportGroupStratifier; useType : boolean; index : integer);
    procedure ComposeMeasureReportGroupStratifierStratum(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMeasureReportGroupStratifierStratum; useType : boolean; index : integer);
    procedure ComposeMeasureReportGroupStratifierStratumComponent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMeasureReportGroupStratifierStratumComponent; useType : boolean; index : integer);
    procedure ComposeMeasureReportGroupStratifierStratumPopulation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMeasureReportGroupStratifierStratumPopulation; useType : boolean; index : integer);
    procedure ComposeMeasureReport(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMeasureReport; useType : boolean; index : integer);
{$ENDIF FHIR_MEASUREREPORT}
{$IFDEF FHIR_MEDIA}
    procedure ComposeMedia(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedia; useType : boolean; index : integer);
{$ENDIF FHIR_MEDIA}
{$IFDEF FHIR_MEDICATION}
    procedure ComposeMedicationIngredient(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationIngredient; useType : boolean; index : integer);
    procedure ComposeMedicationBatch(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationBatch; useType : boolean; index : integer);
    procedure ComposeMedication(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedication; useType : boolean; index : integer);
{$ENDIF FHIR_MEDICATION}
{$IFDEF FHIR_MEDICATIONADMINISTRATION}
    procedure ComposeMedicationAdministrationPerformer(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationAdministrationPerformer; useType : boolean; index : integer);
    procedure ComposeMedicationAdministrationDosage(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationAdministrationDosage; useType : boolean; index : integer);
    procedure ComposeMedicationAdministration(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationAdministration; useType : boolean; index : integer);
{$ENDIF FHIR_MEDICATIONADMINISTRATION}
{$IFDEF FHIR_MEDICATIONDISPENSE}
    procedure ComposeMedicationDispensePerformer(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationDispensePerformer; useType : boolean; index : integer);
    procedure ComposeMedicationDispenseSubstitution(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationDispenseSubstitution; useType : boolean; index : integer);
    procedure ComposeMedicationDispense(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationDispense; useType : boolean; index : integer);
{$ENDIF FHIR_MEDICATIONDISPENSE}
{$IFDEF FHIR_MEDICATIONKNOWLEDGE}
    procedure ComposeMedicationKnowledgeRelatedMedicationKnowledge(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationKnowledgeRelatedMedicationKnowledge; useType : boolean; index : integer);
    procedure ComposeMedicationKnowledgeMonograph(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationKnowledgeMonograph; useType : boolean; index : integer);
    procedure ComposeMedicationKnowledgeIngredient(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationKnowledgeIngredient; useType : boolean; index : integer);
    procedure ComposeMedicationKnowledgeCost(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationKnowledgeCost; useType : boolean; index : integer);
    procedure ComposeMedicationKnowledgeMonitoringProgram(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationKnowledgeMonitoringProgram; useType : boolean; index : integer);
    procedure ComposeMedicationKnowledgeAdministrationGuidelines(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationKnowledgeAdministrationGuidelines; useType : boolean; index : integer);
    procedure ComposeMedicationKnowledgeAdministrationGuidelinesDosage(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationKnowledgeAdministrationGuidelinesDosage; useType : boolean; index : integer);
    procedure ComposeMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics; useType : boolean; index : integer);
    procedure ComposeMedicationKnowledgeMedicineClassification(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationKnowledgeMedicineClassification; useType : boolean; index : integer);
    procedure ComposeMedicationKnowledgePackaging(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationKnowledgePackaging; useType : boolean; index : integer);
    procedure ComposeMedicationKnowledgeDrugCharacteristic(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationKnowledgeDrugCharacteristic; useType : boolean; index : integer);
    procedure ComposeMedicationKnowledgeRegulatory(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationKnowledgeRegulatory; useType : boolean; index : integer);
    procedure ComposeMedicationKnowledgeRegulatorySubstitution(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationKnowledgeRegulatorySubstitution; useType : boolean; index : integer);
    procedure ComposeMedicationKnowledgeRegulatorySchedule(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationKnowledgeRegulatorySchedule; useType : boolean; index : integer);
    procedure ComposeMedicationKnowledgeRegulatoryMaxDispense(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationKnowledgeRegulatoryMaxDispense; useType : boolean; index : integer);
    procedure ComposeMedicationKnowledgeKinetics(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationKnowledgeKinetics; useType : boolean; index : integer);
    procedure ComposeMedicationKnowledge(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationKnowledge; useType : boolean; index : integer);
{$ENDIF FHIR_MEDICATIONKNOWLEDGE}
{$IFDEF FHIR_MEDICATIONREQUEST}
    procedure ComposeMedicationRequestDispenseRequest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationRequestDispenseRequest; useType : boolean; index : integer);
    procedure ComposeMedicationRequestDispenseRequestInitialFill(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationRequestDispenseRequestInitialFill; useType : boolean; index : integer);
    procedure ComposeMedicationRequestSubstitution(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationRequestSubstitution; useType : boolean; index : integer);
    procedure ComposeMedicationRequest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationRequest; useType : boolean; index : integer);
{$ENDIF FHIR_MEDICATIONREQUEST}
{$IFDEF FHIR_MEDICATIONSTATEMENT}
    procedure ComposeMedicationStatement(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationStatement; useType : boolean; index : integer);
{$ENDIF FHIR_MEDICATIONSTATEMENT}
{$IFDEF FHIR_MEDICINALPRODUCT}
    procedure ComposeMedicinalProductName(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicinalProductName; useType : boolean; index : integer);
    procedure ComposeMedicinalProductNameNamePart(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicinalProductNameNamePart; useType : boolean; index : integer);
    procedure ComposeMedicinalProductNameCountryLanguage(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicinalProductNameCountryLanguage; useType : boolean; index : integer);
    procedure ComposeMedicinalProductManufacturingBusinessOperation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicinalProductManufacturingBusinessOperation; useType : boolean; index : integer);
    procedure ComposeMedicinalProductSpecialDesignation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicinalProductSpecialDesignation; useType : boolean; index : integer);
    procedure ComposeMedicinalProduct(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicinalProduct; useType : boolean; index : integer);
{$ENDIF FHIR_MEDICINALPRODUCT}
{$IFDEF FHIR_MEDICINALPRODUCTAUTHORIZATION}
    procedure ComposeMedicinalProductAuthorizationJurisdictionalAuthorization(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicinalProductAuthorizationJurisdictionalAuthorization; useType : boolean; index : integer);
    procedure ComposeMedicinalProductAuthorizationProcedure(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicinalProductAuthorizationProcedure; useType : boolean; index : integer);
    procedure ComposeMedicinalProductAuthorization(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicinalProductAuthorization; useType : boolean; index : integer);
{$ENDIF FHIR_MEDICINALPRODUCTAUTHORIZATION}
{$IFDEF FHIR_MEDICINALPRODUCTCONTRAINDICATION}
    procedure ComposeMedicinalProductContraindicationOtherTherapy(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicinalProductContraindicationOtherTherapy; useType : boolean; index : integer);
    procedure ComposeMedicinalProductContraindication(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicinalProductContraindication; useType : boolean; index : integer);
{$ENDIF FHIR_MEDICINALPRODUCTCONTRAINDICATION}
{$IFDEF FHIR_MEDICINALPRODUCTINDICATION}
    procedure ComposeMedicinalProductIndicationOtherTherapy(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicinalProductIndicationOtherTherapy; useType : boolean; index : integer);
    procedure ComposeMedicinalProductIndication(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicinalProductIndication; useType : boolean; index : integer);
{$ENDIF FHIR_MEDICINALPRODUCTINDICATION}
{$IFDEF FHIR_MEDICINALPRODUCTINGREDIENT}
    procedure ComposeMedicinalProductIngredientSpecifiedSubstance(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicinalProductIngredientSpecifiedSubstance; useType : boolean; index : integer);
    procedure ComposeMedicinalProductIngredientSpecifiedSubstanceStrength(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicinalProductIngredientSpecifiedSubstanceStrength; useType : boolean; index : integer);
    procedure ComposeMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength; useType : boolean; index : integer);
    procedure ComposeMedicinalProductIngredientSubstance(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicinalProductIngredientSubstance; useType : boolean; index : integer);
    procedure ComposeMedicinalProductIngredient(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicinalProductIngredient; useType : boolean; index : integer);
{$ENDIF FHIR_MEDICINALPRODUCTINGREDIENT}
{$IFDEF FHIR_MEDICINALPRODUCTINTERACTION}
    procedure ComposeMedicinalProductInteractionInteractant(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicinalProductInteractionInteractant; useType : boolean; index : integer);
    procedure ComposeMedicinalProductInteraction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicinalProductInteraction; useType : boolean; index : integer);
{$ENDIF FHIR_MEDICINALPRODUCTINTERACTION}
{$IFDEF FHIR_MEDICINALPRODUCTMANUFACTURED}
    procedure ComposeMedicinalProductManufactured(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicinalProductManufactured; useType : boolean; index : integer);
{$ENDIF FHIR_MEDICINALPRODUCTMANUFACTURED}
{$IFDEF FHIR_MEDICINALPRODUCTPACKAGED}
    procedure ComposeMedicinalProductPackagedBatchIdentifier(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicinalProductPackagedBatchIdentifier; useType : boolean; index : integer);
    procedure ComposeMedicinalProductPackagedPackageItem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicinalProductPackagedPackageItem; useType : boolean; index : integer);
    procedure ComposeMedicinalProductPackaged(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicinalProductPackaged; useType : boolean; index : integer);
{$ENDIF FHIR_MEDICINALPRODUCTPACKAGED}
{$IFDEF FHIR_MEDICINALPRODUCTPHARMACEUTICAL}
    procedure ComposeMedicinalProductPharmaceuticalCharacteristics(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicinalProductPharmaceuticalCharacteristics; useType : boolean; index : integer);
    procedure ComposeMedicinalProductPharmaceuticalRouteOfAdministration(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicinalProductPharmaceuticalRouteOfAdministration; useType : boolean; index : integer);
    procedure ComposeMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies; useType : boolean; index : integer);
    procedure ComposeMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod; useType : boolean; index : integer);
    procedure ComposeMedicinalProductPharmaceutical(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicinalProductPharmaceutical; useType : boolean; index : integer);
{$ENDIF FHIR_MEDICINALPRODUCTPHARMACEUTICAL}
{$IFDEF FHIR_MEDICINALPRODUCTUNDESIRABLEEFFECT}
    procedure ComposeMedicinalProductUndesirableEffect(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicinalProductUndesirableEffect; useType : boolean; index : integer);
{$ENDIF FHIR_MEDICINALPRODUCTUNDESIRABLEEFFECT}
{$IFDEF FHIR_MESSAGEDEFINITION}
    procedure ComposeMessageDefinitionFocus(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMessageDefinitionFocus; useType : boolean; index : integer);
    procedure ComposeMessageDefinitionAllowedResponse(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMessageDefinitionAllowedResponse; useType : boolean; index : integer);
    procedure ComposeMessageDefinition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMessageDefinition; useType : boolean; index : integer);
{$ENDIF FHIR_MESSAGEDEFINITION}
{$IFDEF FHIR_MESSAGEHEADER}
    procedure ComposeMessageHeaderDestination(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMessageHeaderDestination; useType : boolean; index : integer);
    procedure ComposeMessageHeaderSource(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMessageHeaderSource; useType : boolean; index : integer);
    procedure ComposeMessageHeaderResponse(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMessageHeaderResponse; useType : boolean; index : integer);
    procedure ComposeMessageHeader(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMessageHeader; useType : boolean; index : integer);
{$ENDIF FHIR_MESSAGEHEADER}
{$IFDEF FHIR_MOLECULARSEQUENCE}
    procedure ComposeMolecularSequenceReferenceSeq(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMolecularSequenceReferenceSeq; useType : boolean; index : integer);
    procedure ComposeMolecularSequenceVariant(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMolecularSequenceVariant; useType : boolean; index : integer);
    procedure ComposeMolecularSequenceQuality(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMolecularSequenceQuality; useType : boolean; index : integer);
    procedure ComposeMolecularSequenceQualityRoc(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMolecularSequenceQualityRoc; useType : boolean; index : integer);
    procedure ComposeMolecularSequenceRepository(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMolecularSequenceRepository; useType : boolean; index : integer);
    procedure ComposeMolecularSequenceStructureVariant(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMolecularSequenceStructureVariant; useType : boolean; index : integer);
    procedure ComposeMolecularSequenceStructureVariantOuter(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMolecularSequenceStructureVariantOuter; useType : boolean; index : integer);
    procedure ComposeMolecularSequenceStructureVariantInner(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMolecularSequenceStructureVariantInner; useType : boolean; index : integer);
    procedure ComposeMolecularSequence(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMolecularSequence; useType : boolean; index : integer);
{$ENDIF FHIR_MOLECULARSEQUENCE}
{$IFDEF FHIR_NAMINGSYSTEM}
    procedure ComposeNamingSystemUniqueId(parent :  TTurtleComplex; parentType, name : String; elem : TFhirNamingSystemUniqueId; useType : boolean; index : integer);
    procedure ComposeNamingSystem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirNamingSystem; useType : boolean; index : integer);
{$ENDIF FHIR_NAMINGSYSTEM}
{$IFDEF FHIR_NUTRITIONORDER}
    procedure ComposeNutritionOrderOralDiet(parent :  TTurtleComplex; parentType, name : String; elem : TFhirNutritionOrderOralDiet; useType : boolean; index : integer);
    procedure ComposeNutritionOrderOralDietNutrient(parent :  TTurtleComplex; parentType, name : String; elem : TFhirNutritionOrderOralDietNutrient; useType : boolean; index : integer);
    procedure ComposeNutritionOrderOralDietTexture(parent :  TTurtleComplex; parentType, name : String; elem : TFhirNutritionOrderOralDietTexture; useType : boolean; index : integer);
    procedure ComposeNutritionOrderSupplement(parent :  TTurtleComplex; parentType, name : String; elem : TFhirNutritionOrderSupplement; useType : boolean; index : integer);
    procedure ComposeNutritionOrderEnteralFormula(parent :  TTurtleComplex; parentType, name : String; elem : TFhirNutritionOrderEnteralFormula; useType : boolean; index : integer);
    procedure ComposeNutritionOrderEnteralFormulaAdministration(parent :  TTurtleComplex; parentType, name : String; elem : TFhirNutritionOrderEnteralFormulaAdministration; useType : boolean; index : integer);
    procedure ComposeNutritionOrder(parent :  TTurtleComplex; parentType, name : String; elem : TFhirNutritionOrder; useType : boolean; index : integer);
{$ENDIF FHIR_NUTRITIONORDER}
{$IFDEF FHIR_OBSERVATION}
    procedure ComposeObservationReferenceRange(parent :  TTurtleComplex; parentType, name : String; elem : TFhirObservationReferenceRange; useType : boolean; index : integer);
    procedure ComposeObservationComponent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirObservationComponent; useType : boolean; index : integer);
    procedure ComposeObservation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirObservation; useType : boolean; index : integer);
{$ENDIF FHIR_OBSERVATION}
{$IFDEF FHIR_OBSERVATIONDEFINITION}
    procedure ComposeObservationDefinitionQuantitativeDetails(parent :  TTurtleComplex; parentType, name : String; elem : TFhirObservationDefinitionQuantitativeDetails; useType : boolean; index : integer);
    procedure ComposeObservationDefinitionQualifiedInterval(parent :  TTurtleComplex; parentType, name : String; elem : TFhirObservationDefinitionQualifiedInterval; useType : boolean; index : integer);
    procedure ComposeObservationDefinition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirObservationDefinition; useType : boolean; index : integer);
{$ENDIF FHIR_OBSERVATIONDEFINITION}
{$IFDEF FHIR_OPERATIONDEFINITION}
    procedure ComposeOperationDefinitionParameter(parent :  TTurtleComplex; parentType, name : String; elem : TFhirOperationDefinitionParameter; useType : boolean; index : integer);
    procedure ComposeOperationDefinitionParameterBinding(parent :  TTurtleComplex; parentType, name : String; elem : TFhirOperationDefinitionParameterBinding; useType : boolean; index : integer);
    procedure ComposeOperationDefinitionParameterReferencedFrom(parent :  TTurtleComplex; parentType, name : String; elem : TFhirOperationDefinitionParameterReferencedFrom; useType : boolean; index : integer);
    procedure ComposeOperationDefinitionOverload(parent :  TTurtleComplex; parentType, name : String; elem : TFhirOperationDefinitionOverload; useType : boolean; index : integer);
    procedure ComposeOperationDefinition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirOperationDefinition; useType : boolean; index : integer);
{$ENDIF FHIR_OPERATIONDEFINITION}
{$IFDEF FHIR_OPERATIONOUTCOME}
    procedure ComposeOperationOutcomeIssue(parent :  TTurtleComplex; parentType, name : String; elem : TFhirOperationOutcomeIssue; useType : boolean; index : integer);
    procedure ComposeOperationOutcome(parent :  TTurtleComplex; parentType, name : String; elem : TFhirOperationOutcome; useType : boolean; index : integer);
{$ENDIF FHIR_OPERATIONOUTCOME}
{$IFDEF FHIR_ORGANIZATION}
    procedure ComposeOrganizationContact(parent :  TTurtleComplex; parentType, name : String; elem : TFhirOrganizationContact; useType : boolean; index : integer);
    procedure ComposeOrganization(parent :  TTurtleComplex; parentType, name : String; elem : TFhirOrganization; useType : boolean; index : integer);
{$ENDIF FHIR_ORGANIZATION}
{$IFDEF FHIR_ORGANIZATIONAFFILIATION}
    procedure ComposeOrganizationAffiliation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirOrganizationAffiliation; useType : boolean; index : integer);
{$ENDIF FHIR_ORGANIZATIONAFFILIATION}
{$IFDEF FHIR_PATIENT}
    procedure ComposePatientContact(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPatientContact; useType : boolean; index : integer);
    procedure ComposePatientCommunication(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPatientCommunication; useType : boolean; index : integer);
    procedure ComposePatientLink(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPatientLink; useType : boolean; index : integer);
    procedure ComposePatient(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPatient; useType : boolean; index : integer);
{$ENDIF FHIR_PATIENT}
{$IFDEF FHIR_PAYMENTNOTICE}
    procedure ComposePaymentNotice(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPaymentNotice; useType : boolean; index : integer);
{$ENDIF FHIR_PAYMENTNOTICE}
{$IFDEF FHIR_PAYMENTRECONCILIATION}
    procedure ComposePaymentReconciliationDetail(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPaymentReconciliationDetail; useType : boolean; index : integer);
    procedure ComposePaymentReconciliationProcessNote(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPaymentReconciliationProcessNote; useType : boolean; index : integer);
    procedure ComposePaymentReconciliation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPaymentReconciliation; useType : boolean; index : integer);
{$ENDIF FHIR_PAYMENTRECONCILIATION}
{$IFDEF FHIR_PERSON}
    procedure ComposePersonLink(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPersonLink; useType : boolean; index : integer);
    procedure ComposePerson(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPerson; useType : boolean; index : integer);
{$ENDIF FHIR_PERSON}
{$IFDEF FHIR_PLANDEFINITION}
    procedure ComposePlanDefinitionGoal(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPlanDefinitionGoal; useType : boolean; index : integer);
    procedure ComposePlanDefinitionGoalTarget(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPlanDefinitionGoalTarget; useType : boolean; index : integer);
    procedure ComposePlanDefinitionAction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPlanDefinitionAction; useType : boolean; index : integer);
    procedure ComposePlanDefinitionActionCondition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPlanDefinitionActionCondition; useType : boolean; index : integer);
    procedure ComposePlanDefinitionActionRelatedAction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPlanDefinitionActionRelatedAction; useType : boolean; index : integer);
    procedure ComposePlanDefinitionActionParticipant(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPlanDefinitionActionParticipant; useType : boolean; index : integer);
    procedure ComposePlanDefinitionActionDynamicValue(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPlanDefinitionActionDynamicValue; useType : boolean; index : integer);
    procedure ComposePlanDefinition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPlanDefinition; useType : boolean; index : integer);
{$ENDIF FHIR_PLANDEFINITION}
{$IFDEF FHIR_PRACTITIONER}
    procedure ComposePractitionerQualification(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPractitionerQualification; useType : boolean; index : integer);
    procedure ComposePractitioner(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPractitioner; useType : boolean; index : integer);
{$ENDIF FHIR_PRACTITIONER}
{$IFDEF FHIR_PRACTITIONERROLE}
    procedure ComposePractitionerRoleAvailableTime(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPractitionerRoleAvailableTime; useType : boolean; index : integer);
    procedure ComposePractitionerRoleNotAvailable(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPractitionerRoleNotAvailable; useType : boolean; index : integer);
    procedure ComposePractitionerRole(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPractitionerRole; useType : boolean; index : integer);
{$ENDIF FHIR_PRACTITIONERROLE}
{$IFDEF FHIR_PROCEDURE}
    procedure ComposeProcedurePerformer(parent :  TTurtleComplex; parentType, name : String; elem : TFhirProcedurePerformer; useType : boolean; index : integer);
    procedure ComposeProcedureFocalDevice(parent :  TTurtleComplex; parentType, name : String; elem : TFhirProcedureFocalDevice; useType : boolean; index : integer);
    procedure ComposeProcedure(parent :  TTurtleComplex; parentType, name : String; elem : TFhirProcedure; useType : boolean; index : integer);
{$ENDIF FHIR_PROCEDURE}
{$IFDEF FHIR_PROVENANCE}
    procedure ComposeProvenanceAgent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirProvenanceAgent; useType : boolean; index : integer);
    procedure ComposeProvenanceEntity(parent :  TTurtleComplex; parentType, name : String; elem : TFhirProvenanceEntity; useType : boolean; index : integer);
    procedure ComposeProvenance(parent :  TTurtleComplex; parentType, name : String; elem : TFhirProvenance; useType : boolean; index : integer);
{$ENDIF FHIR_PROVENANCE}
{$IFDEF FHIR_QUESTIONNAIRE}
    procedure ComposeQuestionnaireItem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirQuestionnaireItem; useType : boolean; index : integer);
    procedure ComposeQuestionnaireItemEnableWhen(parent :  TTurtleComplex; parentType, name : String; elem : TFhirQuestionnaireItemEnableWhen; useType : boolean; index : integer);
    procedure ComposeQuestionnaireItemAnswerOption(parent :  TTurtleComplex; parentType, name : String; elem : TFhirQuestionnaireItemAnswerOption; useType : boolean; index : integer);
    procedure ComposeQuestionnaireItemInitial(parent :  TTurtleComplex; parentType, name : String; elem : TFhirQuestionnaireItemInitial; useType : boolean; index : integer);
    procedure ComposeQuestionnaire(parent :  TTurtleComplex; parentType, name : String; elem : TFhirQuestionnaire; useType : boolean; index : integer);
{$ENDIF FHIR_QUESTIONNAIRE}
{$IFDEF FHIR_QUESTIONNAIRERESPONSE}
    procedure ComposeQuestionnaireResponseItem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirQuestionnaireResponseItem; useType : boolean; index : integer);
    procedure ComposeQuestionnaireResponseItemAnswer(parent :  TTurtleComplex; parentType, name : String; elem : TFhirQuestionnaireResponseItemAnswer; useType : boolean; index : integer);
    procedure ComposeQuestionnaireResponse(parent :  TTurtleComplex; parentType, name : String; elem : TFhirQuestionnaireResponse; useType : boolean; index : integer);
{$ENDIF FHIR_QUESTIONNAIRERESPONSE}
{$IFDEF FHIR_RELATEDPERSON}
    procedure ComposeRelatedPersonCommunication(parent :  TTurtleComplex; parentType, name : String; elem : TFhirRelatedPersonCommunication; useType : boolean; index : integer);
    procedure ComposeRelatedPerson(parent :  TTurtleComplex; parentType, name : String; elem : TFhirRelatedPerson; useType : boolean; index : integer);
{$ENDIF FHIR_RELATEDPERSON}
{$IFDEF FHIR_REQUESTGROUP}
    procedure ComposeRequestGroupAction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirRequestGroupAction; useType : boolean; index : integer);
    procedure ComposeRequestGroupActionCondition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirRequestGroupActionCondition; useType : boolean; index : integer);
    procedure ComposeRequestGroupActionRelatedAction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirRequestGroupActionRelatedAction; useType : boolean; index : integer);
    procedure ComposeRequestGroup(parent :  TTurtleComplex; parentType, name : String; elem : TFhirRequestGroup; useType : boolean; index : integer);
{$ENDIF FHIR_REQUESTGROUP}
{$IFDEF FHIR_RESEARCHDEFINITION}
    procedure ComposeResearchDefinition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirResearchDefinition; useType : boolean; index : integer);
{$ENDIF FHIR_RESEARCHDEFINITION}
{$IFDEF FHIR_RESEARCHELEMENTDEFINITION}
    procedure ComposeResearchElementDefinitionCharacteristic(parent :  TTurtleComplex; parentType, name : String; elem : TFhirResearchElementDefinitionCharacteristic; useType : boolean; index : integer);
    procedure ComposeResearchElementDefinition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirResearchElementDefinition; useType : boolean; index : integer);
{$ENDIF FHIR_RESEARCHELEMENTDEFINITION}
{$IFDEF FHIR_RESEARCHSTUDY}
    procedure ComposeResearchStudyArm(parent :  TTurtleComplex; parentType, name : String; elem : TFhirResearchStudyArm; useType : boolean; index : integer);
    procedure ComposeResearchStudyObjective(parent :  TTurtleComplex; parentType, name : String; elem : TFhirResearchStudyObjective; useType : boolean; index : integer);
    procedure ComposeResearchStudy(parent :  TTurtleComplex; parentType, name : String; elem : TFhirResearchStudy; useType : boolean; index : integer);
{$ENDIF FHIR_RESEARCHSTUDY}
{$IFDEF FHIR_RESEARCHSUBJECT}
    procedure ComposeResearchSubject(parent :  TTurtleComplex; parentType, name : String; elem : TFhirResearchSubject; useType : boolean; index : integer);
{$ENDIF FHIR_RESEARCHSUBJECT}
{$IFDEF FHIR_RISKASSESSMENT}
    procedure ComposeRiskAssessmentPrediction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirRiskAssessmentPrediction; useType : boolean; index : integer);
    procedure ComposeRiskAssessment(parent :  TTurtleComplex; parentType, name : String; elem : TFhirRiskAssessment; useType : boolean; index : integer);
{$ENDIF FHIR_RISKASSESSMENT}
{$IFDEF FHIR_RISKEVIDENCESYNTHESIS}
    procedure ComposeRiskEvidenceSynthesisSampleSize(parent :  TTurtleComplex; parentType, name : String; elem : TFhirRiskEvidenceSynthesisSampleSize; useType : boolean; index : integer);
    procedure ComposeRiskEvidenceSynthesisRiskEstimate(parent :  TTurtleComplex; parentType, name : String; elem : TFhirRiskEvidenceSynthesisRiskEstimate; useType : boolean; index : integer);
    procedure ComposeRiskEvidenceSynthesisRiskEstimatePrecisionEstimate(parent :  TTurtleComplex; parentType, name : String; elem : TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate; useType : boolean; index : integer);
    procedure ComposeRiskEvidenceSynthesisCertainty(parent :  TTurtleComplex; parentType, name : String; elem : TFhirRiskEvidenceSynthesisCertainty; useType : boolean; index : integer);
    procedure ComposeRiskEvidenceSynthesisCertaintyCertaintySubcomponent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent; useType : boolean; index : integer);
    procedure ComposeRiskEvidenceSynthesis(parent :  TTurtleComplex; parentType, name : String; elem : TFhirRiskEvidenceSynthesis; useType : boolean; index : integer);
{$ENDIF FHIR_RISKEVIDENCESYNTHESIS}
{$IFDEF FHIR_SCHEDULE}
    procedure ComposeSchedule(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSchedule; useType : boolean; index : integer);
{$ENDIF FHIR_SCHEDULE}
{$IFDEF FHIR_SEARCHPARAMETER}
    procedure ComposeSearchParameterComponent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSearchParameterComponent; useType : boolean; index : integer);
    procedure ComposeSearchParameter(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSearchParameter; useType : boolean; index : integer);
{$ENDIF FHIR_SEARCHPARAMETER}
{$IFDEF FHIR_SERVICEREQUEST}
    procedure ComposeServiceRequest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirServiceRequest; useType : boolean; index : integer);
{$ENDIF FHIR_SERVICEREQUEST}
{$IFDEF FHIR_SLOT}
    procedure ComposeSlot(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSlot; useType : boolean; index : integer);
{$ENDIF FHIR_SLOT}
{$IFDEF FHIR_SPECIMEN}
    procedure ComposeSpecimenCollection(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSpecimenCollection; useType : boolean; index : integer);
    procedure ComposeSpecimenProcessing(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSpecimenProcessing; useType : boolean; index : integer);
    procedure ComposeSpecimenContainer(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSpecimenContainer; useType : boolean; index : integer);
    procedure ComposeSpecimen(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSpecimen; useType : boolean; index : integer);
{$ENDIF FHIR_SPECIMEN}
{$IFDEF FHIR_SPECIMENDEFINITION}
    procedure ComposeSpecimenDefinitionTypeTested(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSpecimenDefinitionTypeTested; useType : boolean; index : integer);
    procedure ComposeSpecimenDefinitionTypeTestedContainer(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSpecimenDefinitionTypeTestedContainer; useType : boolean; index : integer);
    procedure ComposeSpecimenDefinitionTypeTestedContainerAdditive(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSpecimenDefinitionTypeTestedContainerAdditive; useType : boolean; index : integer);
    procedure ComposeSpecimenDefinitionTypeTestedHandling(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSpecimenDefinitionTypeTestedHandling; useType : boolean; index : integer);
    procedure ComposeSpecimenDefinition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSpecimenDefinition; useType : boolean; index : integer);
{$ENDIF FHIR_SPECIMENDEFINITION}
{$IFDEF FHIR_STRUCTUREDEFINITION}
    procedure ComposeStructureDefinitionMapping(parent :  TTurtleComplex; parentType, name : String; elem : TFhirStructureDefinitionMapping; useType : boolean; index : integer);
    procedure ComposeStructureDefinitionContext(parent :  TTurtleComplex; parentType, name : String; elem : TFhirStructureDefinitionContext; useType : boolean; index : integer);
    procedure ComposeStructureDefinitionSnapshot(parent :  TTurtleComplex; parentType, name : String; elem : TFhirStructureDefinitionSnapshot; useType : boolean; index : integer);
    procedure ComposeStructureDefinitionDifferential(parent :  TTurtleComplex; parentType, name : String; elem : TFhirStructureDefinitionDifferential; useType : boolean; index : integer);
    procedure ComposeStructureDefinition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirStructureDefinition; useType : boolean; index : integer);
{$ENDIF FHIR_STRUCTUREDEFINITION}
{$IFDEF FHIR_STRUCTUREMAP}
    procedure ComposeStructureMapStructure(parent :  TTurtleComplex; parentType, name : String; elem : TFhirStructureMapStructure; useType : boolean; index : integer);
    procedure ComposeStructureMapGroup(parent :  TTurtleComplex; parentType, name : String; elem : TFhirStructureMapGroup; useType : boolean; index : integer);
    procedure ComposeStructureMapGroupInput(parent :  TTurtleComplex; parentType, name : String; elem : TFhirStructureMapGroupInput; useType : boolean; index : integer);
    procedure ComposeStructureMapGroupRule(parent :  TTurtleComplex; parentType, name : String; elem : TFhirStructureMapGroupRule; useType : boolean; index : integer);
    procedure ComposeStructureMapGroupRuleSource(parent :  TTurtleComplex; parentType, name : String; elem : TFhirStructureMapGroupRuleSource; useType : boolean; index : integer);
    procedure ComposeStructureMapGroupRuleTarget(parent :  TTurtleComplex; parentType, name : String; elem : TFhirStructureMapGroupRuleTarget; useType : boolean; index : integer);
    procedure ComposeStructureMapGroupRuleTargetParameter(parent :  TTurtleComplex; parentType, name : String; elem : TFhirStructureMapGroupRuleTargetParameter; useType : boolean; index : integer);
    procedure ComposeStructureMapGroupRuleDependent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirStructureMapGroupRuleDependent; useType : boolean; index : integer);
    procedure ComposeStructureMap(parent :  TTurtleComplex; parentType, name : String; elem : TFhirStructureMap; useType : boolean; index : integer);
{$ENDIF FHIR_STRUCTUREMAP}
{$IFDEF FHIR_SUBSCRIPTION}
    procedure ComposeSubscriptionChannel(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubscriptionChannel; useType : boolean; index : integer);
    procedure ComposeSubscription(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubscription; useType : boolean; index : integer);
{$ENDIF FHIR_SUBSCRIPTION}
{$IFDEF FHIR_SUBSTANCE}
    procedure ComposeSubstanceInstance(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstanceInstance; useType : boolean; index : integer);
    procedure ComposeSubstanceIngredient(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstanceIngredient; useType : boolean; index : integer);
    procedure ComposeSubstance(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstance; useType : boolean; index : integer);
{$ENDIF FHIR_SUBSTANCE}
{$IFDEF FHIR_SUBSTANCENUCLEICACID}
    procedure ComposeSubstanceNucleicAcidSubunit(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstanceNucleicAcidSubunit; useType : boolean; index : integer);
    procedure ComposeSubstanceNucleicAcidSubunitLinkage(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstanceNucleicAcidSubunitLinkage; useType : boolean; index : integer);
    procedure ComposeSubstanceNucleicAcidSubunitSugar(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstanceNucleicAcidSubunitSugar; useType : boolean; index : integer);
    procedure ComposeSubstanceNucleicAcid(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstanceNucleicAcid; useType : boolean; index : integer);
{$ENDIF FHIR_SUBSTANCENUCLEICACID}
{$IFDEF FHIR_SUBSTANCEPOLYMER}
    procedure ComposeSubstancePolymerMonomerSet(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstancePolymerMonomerSet; useType : boolean; index : integer);
    procedure ComposeSubstancePolymerMonomerSetStartingMaterial(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstancePolymerMonomerSetStartingMaterial; useType : boolean; index : integer);
    procedure ComposeSubstancePolymerRepeat(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstancePolymerRepeat; useType : boolean; index : integer);
    procedure ComposeSubstancePolymerRepeatRepeatUnit(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstancePolymerRepeatRepeatUnit; useType : boolean; index : integer);
    procedure ComposeSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation; useType : boolean; index : integer);
    procedure ComposeSubstancePolymerRepeatRepeatUnitStructuralRepresentation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation; useType : boolean; index : integer);
    procedure ComposeSubstancePolymer(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstancePolymer; useType : boolean; index : integer);
{$ENDIF FHIR_SUBSTANCEPOLYMER}
{$IFDEF FHIR_SUBSTANCEPROTEIN}
    procedure ComposeSubstanceProteinSubunit(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstanceProteinSubunit; useType : boolean; index : integer);
    procedure ComposeSubstanceProtein(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstanceProtein; useType : boolean; index : integer);
{$ENDIF FHIR_SUBSTANCEPROTEIN}
{$IFDEF FHIR_SUBSTANCEREFERENCEINFORMATION}
    procedure ComposeSubstanceReferenceInformationGene(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstanceReferenceInformationGene; useType : boolean; index : integer);
    procedure ComposeSubstanceReferenceInformationGeneElement(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstanceReferenceInformationGeneElement; useType : boolean; index : integer);
    procedure ComposeSubstanceReferenceInformationClassification(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstanceReferenceInformationClassification; useType : boolean; index : integer);
    procedure ComposeSubstanceReferenceInformationTarget(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstanceReferenceInformationTarget; useType : boolean; index : integer);
    procedure ComposeSubstanceReferenceInformation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstanceReferenceInformation; useType : boolean; index : integer);
{$ENDIF FHIR_SUBSTANCEREFERENCEINFORMATION}
{$IFDEF FHIR_SUBSTANCESOURCEMATERIAL}
    procedure ComposeSubstanceSourceMaterialFractionDescription(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstanceSourceMaterialFractionDescription; useType : boolean; index : integer);
    procedure ComposeSubstanceSourceMaterialOrganism(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstanceSourceMaterialOrganism; useType : boolean; index : integer);
    procedure ComposeSubstanceSourceMaterialOrganismAuthor(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstanceSourceMaterialOrganismAuthor; useType : boolean; index : integer);
    procedure ComposeSubstanceSourceMaterialOrganismHybrid(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstanceSourceMaterialOrganismHybrid; useType : boolean; index : integer);
    procedure ComposeSubstanceSourceMaterialOrganismOrganismGeneral(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstanceSourceMaterialOrganismOrganismGeneral; useType : boolean; index : integer);
    procedure ComposeSubstanceSourceMaterialPartDescription(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstanceSourceMaterialPartDescription; useType : boolean; index : integer);
    procedure ComposeSubstanceSourceMaterial(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstanceSourceMaterial; useType : boolean; index : integer);
{$ENDIF FHIR_SUBSTANCESOURCEMATERIAL}
{$IFDEF FHIR_SUBSTANCESPECIFICATION}
    procedure ComposeSubstanceSpecificationMoiety(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstanceSpecificationMoiety; useType : boolean; index : integer);
    procedure ComposeSubstanceSpecificationProperty(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstanceSpecificationProperty; useType : boolean; index : integer);
    procedure ComposeSubstanceSpecificationStructure(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstanceSpecificationStructure; useType : boolean; index : integer);
    procedure ComposeSubstanceSpecificationStructureIsotope(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstanceSpecificationStructureIsotope; useType : boolean; index : integer);
    procedure ComposeSubstanceSpecificationStructureIsotopeMolecularWeight(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstanceSpecificationStructureIsotopeMolecularWeight; useType : boolean; index : integer);
    procedure ComposeSubstanceSpecificationStructureRepresentation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstanceSpecificationStructureRepresentation; useType : boolean; index : integer);
    procedure ComposeSubstanceSpecificationCode(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstanceSpecificationCode; useType : boolean; index : integer);
    procedure ComposeSubstanceSpecificationName(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstanceSpecificationName; useType : boolean; index : integer);
    procedure ComposeSubstanceSpecificationNameOfficial(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstanceSpecificationNameOfficial; useType : boolean; index : integer);
    procedure ComposeSubstanceSpecificationRelationship(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstanceSpecificationRelationship; useType : boolean; index : integer);
    procedure ComposeSubstanceSpecification(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstanceSpecification; useType : boolean; index : integer);
{$ENDIF FHIR_SUBSTANCESPECIFICATION}
{$IFDEF FHIR_SUPPLYDELIVERY}
    procedure ComposeSupplyDeliverySuppliedItem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSupplyDeliverySuppliedItem; useType : boolean; index : integer);
    procedure ComposeSupplyDelivery(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSupplyDelivery; useType : boolean; index : integer);
{$ENDIF FHIR_SUPPLYDELIVERY}
{$IFDEF FHIR_SUPPLYREQUEST}
    procedure ComposeSupplyRequestParameter(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSupplyRequestParameter; useType : boolean; index : integer);
    procedure ComposeSupplyRequest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSupplyRequest; useType : boolean; index : integer);
{$ENDIF FHIR_SUPPLYREQUEST}
{$IFDEF FHIR_TASK}
    procedure ComposeTaskRestriction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTaskRestriction; useType : boolean; index : integer);
    procedure ComposeTaskInput(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTaskInput; useType : boolean; index : integer);
    procedure ComposeTaskOutput(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTaskOutput; useType : boolean; index : integer);
    procedure ComposeTask(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTask; useType : boolean; index : integer);
{$ENDIF FHIR_TASK}
{$IFDEF FHIR_TERMINOLOGYCAPABILITIES}
    procedure ComposeTerminologyCapabilitiesSoftware(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTerminologyCapabilitiesSoftware; useType : boolean; index : integer);
    procedure ComposeTerminologyCapabilitiesImplementation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTerminologyCapabilitiesImplementation; useType : boolean; index : integer);
    procedure ComposeTerminologyCapabilitiesCodeSystem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTerminologyCapabilitiesCodeSystem; useType : boolean; index : integer);
    procedure ComposeTerminologyCapabilitiesCodeSystemVersion(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTerminologyCapabilitiesCodeSystemVersion; useType : boolean; index : integer);
    procedure ComposeTerminologyCapabilitiesCodeSystemVersionFilter(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTerminologyCapabilitiesCodeSystemVersionFilter; useType : boolean; index : integer);
    procedure ComposeTerminologyCapabilitiesExpansion(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTerminologyCapabilitiesExpansion; useType : boolean; index : integer);
    procedure ComposeTerminologyCapabilitiesExpansionParameter(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTerminologyCapabilitiesExpansionParameter; useType : boolean; index : integer);
    procedure ComposeTerminologyCapabilitiesValidateCode(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTerminologyCapabilitiesValidateCode; useType : boolean; index : integer);
    procedure ComposeTerminologyCapabilitiesTranslation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTerminologyCapabilitiesTranslation; useType : boolean; index : integer);
    procedure ComposeTerminologyCapabilitiesClosure(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTerminologyCapabilitiesClosure; useType : boolean; index : integer);
    procedure ComposeTerminologyCapabilities(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTerminologyCapabilities; useType : boolean; index : integer);
{$ENDIF FHIR_TERMINOLOGYCAPABILITIES}
{$IFDEF FHIR_TESTREPORT}
    procedure ComposeTestReportParticipant(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestReportParticipant; useType : boolean; index : integer);
    procedure ComposeTestReportSetup(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestReportSetup; useType : boolean; index : integer);
    procedure ComposeTestReportSetupAction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestReportSetupAction; useType : boolean; index : integer);
    procedure ComposeTestReportSetupActionOperation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestReportSetupActionOperation; useType : boolean; index : integer);
    procedure ComposeTestReportSetupActionAssert(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestReportSetupActionAssert; useType : boolean; index : integer);
    procedure ComposeTestReportTest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestReportTest; useType : boolean; index : integer);
    procedure ComposeTestReportTestAction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestReportTestAction; useType : boolean; index : integer);
    procedure ComposeTestReportTeardown(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestReportTeardown; useType : boolean; index : integer);
    procedure ComposeTestReportTeardownAction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestReportTeardownAction; useType : boolean; index : integer);
    procedure ComposeTestReport(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestReport; useType : boolean; index : integer);
{$ENDIF FHIR_TESTREPORT}
{$IFDEF FHIR_TESTSCRIPT}
    procedure ComposeTestScriptOrigin(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptOrigin; useType : boolean; index : integer);
    procedure ComposeTestScriptDestination(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptDestination; useType : boolean; index : integer);
    procedure ComposeTestScriptMetadata(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptMetadata; useType : boolean; index : integer);
    procedure ComposeTestScriptMetadataLink(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptMetadataLink; useType : boolean; index : integer);
    procedure ComposeTestScriptMetadataCapability(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptMetadataCapability; useType : boolean; index : integer);
    procedure ComposeTestScriptFixture(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptFixture; useType : boolean; index : integer);
    procedure ComposeTestScriptVariable(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptVariable; useType : boolean; index : integer);
    procedure ComposeTestScriptSetup(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptSetup; useType : boolean; index : integer);
    procedure ComposeTestScriptSetupAction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptSetupAction; useType : boolean; index : integer);
    procedure ComposeTestScriptSetupActionOperation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptSetupActionOperation; useType : boolean; index : integer);
    procedure ComposeTestScriptSetupActionOperationRequestHeader(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptSetupActionOperationRequestHeader; useType : boolean; index : integer);
    procedure ComposeTestScriptSetupActionAssert(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptSetupActionAssert; useType : boolean; index : integer);
    procedure ComposeTestScriptTest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptTest; useType : boolean; index : integer);
    procedure ComposeTestScriptTestAction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptTestAction; useType : boolean; index : integer);
    procedure ComposeTestScriptTeardown(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptTeardown; useType : boolean; index : integer);
    procedure ComposeTestScriptTeardownAction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptTeardownAction; useType : boolean; index : integer);
    procedure ComposeTestScript(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScript; useType : boolean; index : integer);
{$ENDIF FHIR_TESTSCRIPT}
{$IFDEF FHIR_VALUESET}
    procedure ComposeValueSetCompose(parent :  TTurtleComplex; parentType, name : String; elem : TFhirValueSetCompose; useType : boolean; index : integer);
    procedure ComposeValueSetComposeInclude(parent :  TTurtleComplex; parentType, name : String; elem : TFhirValueSetComposeInclude; useType : boolean; index : integer);
    procedure ComposeValueSetComposeIncludeConcept(parent :  TTurtleComplex; parentType, name : String; elem : TFhirValueSetComposeIncludeConcept; useType : boolean; index : integer);
    procedure ComposeValueSetComposeIncludeConceptDesignation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirValueSetComposeIncludeConceptDesignation; useType : boolean; index : integer);
    procedure ComposeValueSetComposeIncludeFilter(parent :  TTurtleComplex; parentType, name : String; elem : TFhirValueSetComposeIncludeFilter; useType : boolean; index : integer);
    procedure ComposeValueSetExpansion(parent :  TTurtleComplex; parentType, name : String; elem : TFhirValueSetExpansion; useType : boolean; index : integer);
    procedure ComposeValueSetExpansionParameter(parent :  TTurtleComplex; parentType, name : String; elem : TFhirValueSetExpansionParameter; useType : boolean; index : integer);
    procedure ComposeValueSetExpansionContains(parent :  TTurtleComplex; parentType, name : String; elem : TFhirValueSetExpansionContains; useType : boolean; index : integer);
    procedure ComposeValueSet(parent :  TTurtleComplex; parentType, name : String; elem : TFhirValueSet; useType : boolean; index : integer);
{$ENDIF FHIR_VALUESET}
{$IFDEF FHIR_VERIFICATIONRESULT}
    procedure ComposeVerificationResultPrimarySource(parent :  TTurtleComplex; parentType, name : String; elem : TFhirVerificationResultPrimarySource; useType : boolean; index : integer);
    procedure ComposeVerificationResultAttestation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirVerificationResultAttestation; useType : boolean; index : integer);
    procedure ComposeVerificationResultValidator(parent :  TTurtleComplex; parentType, name : String; elem : TFhirVerificationResultValidator; useType : boolean; index : integer);
    procedure ComposeVerificationResult(parent :  TTurtleComplex; parentType, name : String; elem : TFhirVerificationResult; useType : boolean; index : integer);
{$ENDIF FHIR_VERIFICATIONRESULT}
{$IFDEF FHIR_VISIONPRESCRIPTION}
    procedure ComposeVisionPrescriptionLensSpecification(parent :  TTurtleComplex; parentType, name : String; elem : TFhirVisionPrescriptionLensSpecification; useType : boolean; index : integer);
    procedure ComposeVisionPrescriptionLensSpecificationPrism(parent :  TTurtleComplex; parentType, name : String; elem : TFhirVisionPrescriptionLensSpecificationPrism; useType : boolean; index : integer);
    procedure ComposeVisionPrescription(parent :  TTurtleComplex; parentType, name : String; elem : TFhirVisionPrescription; useType : boolean; index : integer);
{$ENDIF FHIR_VISIONPRESCRIPTION}
  
    procedure ComposeResource(parent :  TTurtleComplex; resource : TFhirResource); overload; override;
  end;


implementation

{ TFHIRTurtleParser }

function TFHIRTurtleParser.ParseElement(obj : TTurtleComplex) : TFhirElement;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirElement.create;
  try
    ParseElementProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleComposer.ComposeElement(parent :  TTurtleComplex; parentType, name : String; elem : TFhirElement; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
    this := parent;
  if (index > -1)  then
    this.addPredicate('fhir:index', inttostr(index), 'int');
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeId(this, 'Element', 'id', elem.idElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.extensionList.Count - 1 do
      ComposeExtension(this, 'Element', 'extension', elem.extensionList[i], false, i);{x.d3}
end;

procedure TFHIRTurtleParser.ParseElementProperties(obj : TTurtleComplex; element : TFhirElement);
var
  item : TTurtleComplex;
begin
  element.LocationStart := obj.Start;
  element.LocationEnd := obj.Stop;
  element.idElement := ParseId(obj.complex('http://hl7.org/fhir/Element.id'));{q1}
  for item in obj.complexes('http://hl7.org/fhir/Element.extension') do
    element.extensionList.Add(parseExtension(item));
end;

procedure TFHIRTurtleParser.ParseBackboneElementProperties(obj : TTurtleComplex; element : TFhirBackboneElement);
var
  item : TTurtleComplex;
begin
  parseElementProperties(obj, element);
  for item in obj.complexes('http://hl7.org/fhir/Element.modifierExtension') do
    element.modifierExtensionList.Add(parseExtension(item));
end;

procedure TFHIRTurtleParser.ParseBackboneElementProperties(obj : TTurtleComplex; element : TFhirBackboneType);
var
  item : TTurtleComplex;
begin
  parseElementProperties(obj, element);
  for item in obj.complexes('http://hl7.org/fhir/Element.modifierExtension') do
    element.modifierExtensionList.Add(parseExtension(item));
end;

function TFHIRTurtleParser.ParseBackboneElement(obj : TTurtleComplex) : TFhirBackboneElement;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirBackboneElement.create;
  try
    ParseBackboneElementProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleComposer.ComposeBackboneElement(parent :  TTurtleComplex; parentType, name : String; elem : TFhirBackboneElement; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:BackboneElement'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.modifierExtensionList.Count - 1 do
      ComposeExtension(this, 'BackboneElement', 'modifierExtension', elem.modifierExtensionList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseBackboneType(obj : TTurtleComplex) : TFhirBackboneType;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirBackboneType.create;
  try
    ParseBackboneTypeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseBackboneTypeProperties(obj : TTurtleComplex; result : TFhirBackboneType);
var
  item : TTurtleComplex;
begin
    ParseElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/BackboneElement.modifierExtension') do
      result.modifierExtensionList.Add(parseExtension(item));
end;

procedure TFHIRTurtleComposer.ComposeBackboneType(parent :  TTurtleComplex; parentType, name : String; elem : TFhirBackboneType; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:BackboneType'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.modifierExtensionList.Count - 1 do
      ComposeExtension(this, 'BackboneElement', 'modifierExtension', elem.modifierExtensionList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseEnum(obj : TTurtleComplex; Const aNames, aSystems : Array Of String) : TFHIREnum;
var
  i : integer;
  value : String;
begin
  if obj = nil then
    exit(nil);

  if (obj.has('http://hl7.org/fhir/value')) then
    value := obj.stringLiteral('http://hl7.org/fhir/value');
  i := StringArrayIndexOfSensitive(aNames, value);
  if (value <> '') and (i < 0) then
    raise ERdfException.create('unknown code: '+value+' from a set of choices of '+StringArrayToCommaString(aNames));
  result := TFHIREnum.create;
  try
    result.value := value;
    result.system := aSystems[i];
    parseElementProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeEnum(parent :  TTurtleComplex; parentType, name : String; value : TFhirEnum; Const aNames, aSystems : Array Of String; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:code');
  this.addPredicate('fhir:value', ttlLiteral(value.value));
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParseDate(obj : TTurtleComplex) : TFHIRDate;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDate.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
      result.value := toTDateTimeEx(obj.stringLiteral('http://hl7.org/fhir/value'));
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeDate(parent :  TTurtleComplex; parentType, name : String; value : TFhirDate; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:date');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)), dateXsdType(value.value));
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParseDateTime(obj : TTurtleComplex) : TFHIRDateTime;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDateTime.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
      result.value := toTDateTimeEx(obj.stringLiteral('http://hl7.org/fhir/value'));
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeDateTime(parent :  TTurtleComplex; parentType, name : String; value : TFhirDateTime; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:dateTime');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)), dateXsdType(value.value));
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParseString(obj : TTurtleComplex) : TFHIRString;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirString.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
      result.value := obj.stringLiteral('http://hl7.org/fhir/value');
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeString(parent :  TTurtleComplex; parentType, name : String; value : TFhirString; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:string');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)), 'xsd:string');
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParseInteger(obj : TTurtleComplex) : TFHIRInteger;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirInteger.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
      result.value := obj.stringLiteral('http://hl7.org/fhir/value');
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeInteger(parent :  TTurtleComplex; parentType, name : String; value : TFhirInteger; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:integer');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)), 'xsd:int');
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParseUri(obj : TTurtleComplex) : TFHIRUri;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirUri.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
      result.value := obj.stringLiteral('http://hl7.org/fhir/value');
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeUri(parent :  TTurtleComplex; parentType, name : String; value : TFhirUri; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:uri');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)), 'xsd:anyURI');
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParseInstant(obj : TTurtleComplex) : TFHIRInstant;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirInstant.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
      result.value := toTDateTimeEx(obj.stringLiteral('http://hl7.org/fhir/value'));
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeInstant(parent :  TTurtleComplex; parentType, name : String; value : TFhirInstant; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:instant');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)), 'xsd:dateTime');
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParseXhtml(obj : TTurtleComplex) : TFHIRXhtml;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirXhtml.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
      result.value := obj.stringLiteral('http://hl7.org/fhir/value');
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeXhtml(parent :  TTurtleComplex; parentType, name : String; value : TFhirXhtml; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:xhtml');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)));
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParseBoolean(obj : TTurtleComplex) : TFHIRBoolean;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirBoolean.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
     result.value := StringToBoolean(obj.stringLiteral('http://hl7.org/fhir/value'));
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeBoolean(parent :  TTurtleComplex; parentType, name : String; value : TFhirBoolean; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:boolean');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)), 'xsd:boolean');
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParseBase64Binary(obj : TTurtleComplex) : TFHIRBase64Binary;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirBase64Binary.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
      result.value := toTBytes(obj.stringLiteral('http://hl7.org/fhir/value'));
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeBase64Binary(parent :  TTurtleComplex; parentType, name : String; value : TFhirBase64Binary; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:base64Binary');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)), 'xsd:base64Binary');
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParseTime(obj : TTurtleComplex) : TFHIRTime;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTime.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
      result.value := obj.stringLiteral('http://hl7.org/fhir/value');
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeTime(parent :  TTurtleComplex; parentType, name : String; value : TFhirTime; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:time');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)), 'xsd:time');
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParseDecimal(obj : TTurtleComplex) : TFHIRDecimal;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDecimal.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
      result.value := obj.stringLiteral('http://hl7.org/fhir/value');
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeDecimal(parent :  TTurtleComplex; parentType, name : String; value : TFhirDecimal; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:decimal');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)), 'xsd:decimal');
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParseCode(obj : TTurtleComplex) : TFHIRCode;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCode.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
      result.value := obj.stringLiteral('http://hl7.org/fhir/value');
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeCode(parent :  TTurtleComplex; parentType, name : String; value : TFhirCode; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:code');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)), 'xsd:token');
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParseCanonical(obj : TTurtleComplex) : TFHIRCanonical;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCanonical.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
      result.value := obj.stringLiteral('http://hl7.org/fhir/value');
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeCanonical(parent :  TTurtleComplex; parentType, name : String; value : TFhirCanonical; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:canonical');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)), 'xsd:anyURI');
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParseOid(obj : TTurtleComplex) : TFHIROid;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirOid.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
      result.value := obj.stringLiteral('http://hl7.org/fhir/value');
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeOid(parent :  TTurtleComplex; parentType, name : String; value : TFhirOid; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:oid');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)), 'xsd:anyURI');
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParseUuid(obj : TTurtleComplex) : TFHIRUuid;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirUuid.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
      result.value := obj.stringLiteral('http://hl7.org/fhir/value');
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeUuid(parent :  TTurtleComplex; parentType, name : String; value : TFhirUuid; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:uuid');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)), 'xsd:anyURI');
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParseUrl(obj : TTurtleComplex) : TFHIRUrl;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirUrl.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
      result.value := obj.stringLiteral('http://hl7.org/fhir/value');
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeUrl(parent :  TTurtleComplex; parentType, name : String; value : TFhirUrl; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:url');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)), 'xsd:anyURI');
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParseMarkdown(obj : TTurtleComplex) : TFHIRMarkdown;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMarkdown.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
      result.value := obj.stringLiteral('http://hl7.org/fhir/value');
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeMarkdown(parent :  TTurtleComplex; parentType, name : String; value : TFhirMarkdown; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:markdown');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)), 'xsd:string');
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParseUnsignedInt(obj : TTurtleComplex) : TFHIRUnsignedInt;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirUnsignedInt.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
      result.value := obj.stringLiteral('http://hl7.org/fhir/value');
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeUnsignedInt(parent :  TTurtleComplex; parentType, name : String; value : TFhirUnsignedInt; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:unsignedInt');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)), 'xsd:nonNegativeInteger');
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParseId(obj : TTurtleComplex) : TFHIRId;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirId.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
      result.value := obj.stringLiteral('http://hl7.org/fhir/value');
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposeId(parent :  TTurtleComplex; parentType, name : String; value : TFhirId; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:id');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)), 'xsd:string');
  composeElement(this, parentType, name, value, false, index);
end;

function TFHIRTurtleParser.ParsePositiveInt(obj : TTurtleComplex) : TFHIRPositiveInt;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPositiveInt.Create;
  try
    if (obj.has('http://hl7.org/fhir/value')) then
      result.value := obj.stringLiteral('http://hl7.org/fhir/value');
    parseElementProperties(obj, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRTurtleComposer.ComposePositiveInt(parent :  TTurtleComplex; parentType, name : String; value : TFhirPositiveInt; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (value = nil) then
    exit;
  this := parent.addPredicate('fhir:'+parentType+'.'+name);
  if (useType) then
    this.addPredicate('a', 'fhir:positiveInt');
  this.addPredicate('fhir:value', ttlLiteral(asString(value.value)), 'xsd:positiveInteger');
  composeElement(this, parentType, name, value, false, index);
end;

procedure TFHIRTurtleParser.ParseResourceProperties(obj : TTurtleComplex; resource : TFhirResource);
begin
  resource.LocationStart := obj.Start;
  resource.LocationEnd := obj.Stop;
  resource.idElement := ParseId(obj.complex('http://hl7.org/fhir/Resource.id'));{q1}
  resource.meta := ParseMeta(obj.complex('http://hl7.org/fhir/Resource.meta'));{q3b}
  resource.implicitRulesElement := ParseUri(obj.complex('http://hl7.org/fhir/Resource.implicitRules'));{q1}
  resource.languageElement := ParseCode(obj.complex('http://hl7.org/fhir/Resource.language'));{q1}
end;

Procedure TFHIRTurtleComposer.ComposeResource(this : TTurtleComplex; parentType, name : String; elem : TFhirResource; useType : boolean; index : integer);
begin
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeId(this, 'Resource', 'id', elem.idElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('meta') then
    ComposeMeta(this, 'Resource', 'meta', elem.metaElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('implicitRules') then
    ComposeUri(this, 'Resource', 'implicitRules', elem.implicitRulesElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('language') then
    ComposeCode(this, 'Resource', 'language', elem.languageElement, false, -1);{x.2ea}
end;

procedure TFHIRTurtleParser.ParseDomainResourceProperties(obj : TTurtleComplex; resource : TFhirDomainResource);
var
  item : TTurtleComplex;
begin
  ParseResourceProperties(obj, resource);
  resource.text := ParseNarrative(obj.complex('http://hl7.org/fhir/DomainResource.text'));{q3b}
  for item in obj.complexes('http://hl7.org/fhir/DomainResource.contained') do
    resource.containedList.Add(parseInnerResource(item));
  for item in obj.complexes('http://hl7.org/fhir/DomainResource.extension') do
    resource.extensionList.Add(parseExtension(item));
  for item in obj.complexes('http://hl7.org/fhir/DomainResource.modifierExtension') do
    resource.modifierExtensionList.Add(parseExtension(item));
end;

Procedure TFHIRTurtleComposer.ComposeDomainResource(this : TTurtleComplex; parentType, name : String; elem : TFhirDomainResource; useType : boolean; index : integer);
var
  i : integer{z.c};
begin
  ComposeResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soText]) and doCompose('text') then
    ComposeNarrative(this, 'DomainResource', 'text', elem.textElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('contained') then
    for i := 0 to elem.containedList.Count - 1 do
      ComposeInnerResource(this, 'DomainResource', 'contained', elem.containedList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('extension') then
    for i := 0 to elem.extensionList.Count - 1 do
      ComposeExtension(this, 'DomainResource', 'extension', elem.extensionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('modifierExtension') then
    for i := 0 to elem.modifierExtensionList.Count - 1 do
      ComposeExtension(this, 'DomainResource', 'modifierExtension', elem.modifierExtensionList[i], false, i);{x.d3}
end;

{$IFDEF FHIR_PARAMETERS}
function TFHIRTurtleParser.ParseParametersParameter(obj : TTurtleComplex) : TFhirParametersParameter;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirParametersParameter.create;
  try
    ParseParametersParameterProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseParametersParameterProperties(obj : TTurtleComplex; result : TFhirParametersParameter);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/Parameters.parameter.name'));{q1}
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueCanonical', item) then
      result.value := parseCanonical(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueCode', item) then
      result.value := parseCode(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueId', item) then
      result.value := parseId(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueMarkdown', item) then
      result.value := parseMarkdown(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueOid', item) then
      result.value := parseOid(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valuePositiveInt', item) then
      result.value := parsePositiveInt(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueUnsignedInt', item) then
      result.value := parseUnsignedInt(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueUrl', item) then
      result.value := parseUrl(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueUuid', item) then
      result.value := parseUuid(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueAddress', item) then
      result.value := parseAddress(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueAge', item) then
      result.value := parseAge(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueAnnotation', item) then
      result.value := parseAnnotation(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueAttachment', item) then
      result.value := parseAttachment(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueCodeableConcept', item) then
      result.value := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueCoding', item) then
      result.value := parseCoding(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueContactPoint', item) then
      result.value := parseContactPoint(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueCount', item) then
      result.value := parseCount(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueDistance', item) then
      result.value := parseDistance(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueDuration', item) then
      result.value := parseDuration(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueHumanName', item) then
      result.value := parseHumanName(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueIdentifier', item) then
      result.value := parseIdentifier(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueMoney', item) then
      result.value := parseMoney(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valuePeriod', item) then
      result.value := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueQuantity', item) then
      result.value := parseQuantity(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueRange', item) then
      result.value := parseRange(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueRatio', item) then
      result.value := parseRatio(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueReference', item) then
      result.value := parseReference(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueSampledData', item) then
      result.value := parseSampledData(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueSignature', item) then
      result.value := parseSignature(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueTiming', item) then
      result.value := parseTiming(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueContactDetail', item) then
      result.value := parseContactDetail(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueContributor', item) then
      result.value := parseContributor(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueDataRequirement', item) then
      result.value := parseDataRequirement(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueExpression', item) then
      result.value := parseExpression(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueParameterDefinition', item) then
      result.value := parseParameterDefinition(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueRelatedArtifact', item) then
      result.value := parseRelatedArtifact(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueTriggerDefinition', item) then
      result.value := parseTriggerDefinition(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueUsageContext', item) then
      result.value := parseUsageContext(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueDosage', item) then
      result.value := parseDosage(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueBase64Binary', item) then
      result.value := parseBase64Binary(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueBoolean', item) then
      result.value := parseBoolean(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueDate', item) then
      result.value := parseDate(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueDateTime', item) then
      result.value := parseDateTime(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueDecimal', item) then
      result.value := parseDecimal(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueInstant', item) then
      result.value := parseInstant(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueInteger', item) then
      result.value := parseInteger(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueString', item) then
      result.value := parseString(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueTime', item) then
      result.value := parseTime(item);
    if obj.has('http://hl7.org/fhir/Parameters.parameter.valueUri', item) then
      result.value := parseUri(item);
    result.resource := ParseInnerResource(obj.predicate('http://hl7.org/fhir/Parameters.parameter.resource'));{q3a}
    for item in obj.complexes('http://hl7.org/fhir/Parameters.parameter.part') do
      result.partList.Add(parseParametersParameter(item));
end;

procedure TFHIRTurtleComposer.ComposeParametersParameter(parent :  TTurtleComplex; parentType, name : String; elem : TFhirParametersParameter; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ParametersParameter'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeString(this, 'Parameters.parameter', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirCanonical) {6} then
    ComposeCanonical(this, 'Parameters.parameter', 'valueCanonical', TFhirCanonical(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirCode) {6} then
    ComposeCode(this, 'Parameters.parameter', 'valueCode', TFhirCode(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirId) {6} then
    ComposeId(this, 'Parameters.parameter', 'valueId', TFhirId(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirMarkdown) {6} then
    ComposeMarkdown(this, 'Parameters.parameter', 'valueMarkdown', TFhirMarkdown(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirOid) {6} then
    ComposeOid(this, 'Parameters.parameter', 'valueOid', TFhirOid(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirPositiveInt) {6} then
    ComposePositiveInt(this, 'Parameters.parameter', 'valuePositiveInt', TFhirPositiveInt(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(this, 'Parameters.parameter', 'valueUnsignedInt', TFhirUnsignedInt(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirUrl) {6} then
    ComposeUrl(this, 'Parameters.parameter', 'valueUrl', TFhirUrl(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirUuid) {6} then
    ComposeUuid(this, 'Parameters.parameter', 'valueUuid', TFhirUuid(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirAddress) {6} then
    ComposeAddress(this, 'Parameters.parameter', 'valueAddress', TFhirAddress(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirAge) {6} then
    ComposeAge(this, 'Parameters.parameter', 'valueAge', TFhirAge(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirAnnotation) {6} then
    ComposeAnnotation(this, 'Parameters.parameter', 'valueAnnotation', TFhirAnnotation(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirAttachment) {6} then
    ComposeAttachment(this, 'Parameters.parameter', 'valueAttachment', TFhirAttachment(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Parameters.parameter', 'valueCodeableConcept', TFhirCodeableConcept(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirCoding) {6} then
    ComposeCoding(this, 'Parameters.parameter', 'valueCoding', TFhirCoding(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirContactPoint) {6} then
    ComposeContactPoint(this, 'Parameters.parameter', 'valueContactPoint', TFhirContactPoint(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirCount) {6} then
    ComposeCount(this, 'Parameters.parameter', 'valueCount', TFhirCount(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDistance) {6} then
    ComposeDistance(this, 'Parameters.parameter', 'valueDistance', TFhirDistance(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDuration) {6} then
    ComposeDuration(this, 'Parameters.parameter', 'valueDuration', TFhirDuration(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirHumanName) {6} then
    ComposeHumanName(this, 'Parameters.parameter', 'valueHumanName', TFhirHumanName(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirIdentifier) {6} then
    ComposeIdentifier(this, 'Parameters.parameter', 'valueIdentifier', TFhirIdentifier(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirMoney) {6} then
    ComposeMoney(this, 'Parameters.parameter', 'valueMoney', TFhirMoney(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirPeriod) {6} then
    ComposePeriod(this, 'Parameters.parameter', 'valuePeriod', TFhirPeriod(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'Parameters.parameter', 'valueQuantity', TFhirQuantity(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirRange) {6} then
    ComposeRange(this, 'Parameters.parameter', 'valueRange', TFhirRange(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirRatio) {6} then
    ComposeRatio(this, 'Parameters.parameter', 'valueRatio', TFhirRatio(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirReference) {6} then
    ComposeReference(this, 'Parameters.parameter', 'valueReference', TFhirReference(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirSampledData) {6} then
    ComposeSampledData(this, 'Parameters.parameter', 'valueSampledData', TFhirSampledData(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirSignature) {6} then
    ComposeSignature(this, 'Parameters.parameter', 'valueSignature', TFhirSignature(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirTiming) {6} then
    ComposeTiming(this, 'Parameters.parameter', 'valueTiming', TFhirTiming(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirContactDetail) {6} then
    ComposeContactDetail(this, 'Parameters.parameter', 'valueContactDetail', TFhirContactDetail(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirContributor) {6} then
    ComposeContributor(this, 'Parameters.parameter', 'valueContributor', TFhirContributor(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDataRequirement) {6} then
    ComposeDataRequirement(this, 'Parameters.parameter', 'valueDataRequirement', TFhirDataRequirement(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirExpression) {6} then
    ComposeExpression(this, 'Parameters.parameter', 'valueExpression', TFhirExpression(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirParameterDefinition) {6} then
    ComposeParameterDefinition(this, 'Parameters.parameter', 'valueParameterDefinition', TFhirParameterDefinition(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirRelatedArtifact) {6} then
    ComposeRelatedArtifact(this, 'Parameters.parameter', 'valueRelatedArtifact', TFhirRelatedArtifact(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirTriggerDefinition) {6} then
    ComposeTriggerDefinition(this, 'Parameters.parameter', 'valueTriggerDefinition', TFhirTriggerDefinition(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirUsageContext) {6} then
    ComposeUsageContext(this, 'Parameters.parameter', 'valueUsageContext', TFhirUsageContext(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDosage) {6} then
    ComposeDosage(this, 'Parameters.parameter', 'valueDosage', TFhirDosage(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirBase64Binary) {6} then
    ComposeBase64Binary(this, 'Parameters.parameter', 'valueBase64Binary', TFhirBase64Binary(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirBoolean) {6} then
    ComposeBoolean(this, 'Parameters.parameter', 'valueBoolean', TFhirBoolean(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDate) {6} then
    ComposeDate(this, 'Parameters.parameter', 'valueDate', TFhirDate(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDateTime) {6} then
    ComposeDateTime(this, 'Parameters.parameter', 'valueDateTime', TFhirDateTime(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDecimal) {6} then
    ComposeDecimal(this, 'Parameters.parameter', 'valueDecimal', TFhirDecimal(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirInstant) {6} then
    ComposeInstant(this, 'Parameters.parameter', 'valueInstant', TFhirInstant(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirInteger) {6} then
    ComposeInteger(this, 'Parameters.parameter', 'valueInteger', TFhirInteger(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirString) {6} then
    ComposeString(this, 'Parameters.parameter', 'valueString', TFhirString(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirTime) {6} then
    ComposeTime(this, 'Parameters.parameter', 'valueTime', TFhirTime(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirUri) {6} then
    ComposeUri(this, 'Parameters.parameter', 'valueUri', TFhirUri(elem.value), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInnerResource(this, 'Parameters.parameter', 'resource', elem.resourceElement, false, -1);{x.2ec}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.partList.Count - 1 do
      ComposeParametersParameter(this, 'Parameters.parameter', 'part', elem.partList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseParameters(obj : TTurtleComplex) : TFhirParameters;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirParameters.create;
  try
    ParseParametersProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseParametersProperties(obj : TTurtleComplex; result : TFhirParameters);
var
  item : TTurtleComplex;
begin
    ParseResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Parameters.parameter') do
      result.parameterList.Add(parseParametersParameter(item));
end;

procedure TFHIRTurtleComposer.ComposeParameters(parent :  TTurtleComplex; parentType, name : String; elem : TFhirParameters; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Parameters'); {z}
  end;
  composeResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and doCompose('parameter') then
    for i := 0 to elem.parameterList.Count - 1 do
      ComposeParametersParameter(this, 'Parameters', 'parameter', elem.parameterList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_PARAMETERS}
function TFHIRTurtleParser.ParseExtension(obj : TTurtleComplex) : TFhirExtension;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExtension.create;
  try
    ParseExtensionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExtensionProperties(obj : TTurtleComplex; result : TFhirExtension);
var
  item : TTurtleComplex;
begin
    ParseElementProperties(obj, result);
    result.urlElement := ParseString(obj.complex('http://hl7.org/fhir/Extension.url'));{q1}
    if obj.has('http://hl7.org/fhir/Extension.valueCanonical', item) then
      result.value := parseCanonical(item);
    if obj.has('http://hl7.org/fhir/Extension.valueCode', item) then
      result.value := parseCode(item);
    if obj.has('http://hl7.org/fhir/Extension.valueId', item) then
      result.value := parseId(item);
    if obj.has('http://hl7.org/fhir/Extension.valueMarkdown', item) then
      result.value := parseMarkdown(item);
    if obj.has('http://hl7.org/fhir/Extension.valueOid', item) then
      result.value := parseOid(item);
    if obj.has('http://hl7.org/fhir/Extension.valuePositiveInt', item) then
      result.value := parsePositiveInt(item);
    if obj.has('http://hl7.org/fhir/Extension.valueUnsignedInt', item) then
      result.value := parseUnsignedInt(item);
    if obj.has('http://hl7.org/fhir/Extension.valueUrl', item) then
      result.value := parseUrl(item);
    if obj.has('http://hl7.org/fhir/Extension.valueUuid', item) then
      result.value := parseUuid(item);
    if obj.has('http://hl7.org/fhir/Extension.valueAddress', item) then
      result.value := parseAddress(item);
    if obj.has('http://hl7.org/fhir/Extension.valueAge', item) then
      result.value := parseAge(item);
    if obj.has('http://hl7.org/fhir/Extension.valueAnnotation', item) then
      result.value := parseAnnotation(item);
    if obj.has('http://hl7.org/fhir/Extension.valueAttachment', item) then
      result.value := parseAttachment(item);
    if obj.has('http://hl7.org/fhir/Extension.valueCodeableConcept', item) then
      result.value := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/Extension.valueCoding', item) then
      result.value := parseCoding(item);
    if obj.has('http://hl7.org/fhir/Extension.valueContactPoint', item) then
      result.value := parseContactPoint(item);
    if obj.has('http://hl7.org/fhir/Extension.valueCount', item) then
      result.value := parseCount(item);
    if obj.has('http://hl7.org/fhir/Extension.valueDistance', item) then
      result.value := parseDistance(item);
    if obj.has('http://hl7.org/fhir/Extension.valueDuration', item) then
      result.value := parseDuration(item);
    if obj.has('http://hl7.org/fhir/Extension.valueHumanName', item) then
      result.value := parseHumanName(item);
    if obj.has('http://hl7.org/fhir/Extension.valueIdentifier', item) then
      result.value := parseIdentifier(item);
    if obj.has('http://hl7.org/fhir/Extension.valueMoney', item) then
      result.value := parseMoney(item);
    if obj.has('http://hl7.org/fhir/Extension.valuePeriod', item) then
      result.value := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/Extension.valueQuantity', item) then
      result.value := parseQuantity(item);
    if obj.has('http://hl7.org/fhir/Extension.valueRange', item) then
      result.value := parseRange(item);
    if obj.has('http://hl7.org/fhir/Extension.valueRatio', item) then
      result.value := parseRatio(item);
    if obj.has('http://hl7.org/fhir/Extension.valueReference', item) then
      result.value := parseReference(item);
    if obj.has('http://hl7.org/fhir/Extension.valueSampledData', item) then
      result.value := parseSampledData(item);
    if obj.has('http://hl7.org/fhir/Extension.valueSignature', item) then
      result.value := parseSignature(item);
    if obj.has('http://hl7.org/fhir/Extension.valueTiming', item) then
      result.value := parseTiming(item);
    if obj.has('http://hl7.org/fhir/Extension.valueContactDetail', item) then
      result.value := parseContactDetail(item);
    if obj.has('http://hl7.org/fhir/Extension.valueContributor', item) then
      result.value := parseContributor(item);
    if obj.has('http://hl7.org/fhir/Extension.valueDataRequirement', item) then
      result.value := parseDataRequirement(item);
    if obj.has('http://hl7.org/fhir/Extension.valueExpression', item) then
      result.value := parseExpression(item);
    if obj.has('http://hl7.org/fhir/Extension.valueParameterDefinition', item) then
      result.value := parseParameterDefinition(item);
    if obj.has('http://hl7.org/fhir/Extension.valueRelatedArtifact', item) then
      result.value := parseRelatedArtifact(item);
    if obj.has('http://hl7.org/fhir/Extension.valueTriggerDefinition', item) then
      result.value := parseTriggerDefinition(item);
    if obj.has('http://hl7.org/fhir/Extension.valueUsageContext', item) then
      result.value := parseUsageContext(item);
    if obj.has('http://hl7.org/fhir/Extension.valueDosage', item) then
      result.value := parseDosage(item);
    if obj.has('http://hl7.org/fhir/Extension.valueBase64Binary', item) then
      result.value := parseBase64Binary(item);
    if obj.has('http://hl7.org/fhir/Extension.valueBoolean', item) then
      result.value := parseBoolean(item);
    if obj.has('http://hl7.org/fhir/Extension.valueDate', item) then
      result.value := parseDate(item);
    if obj.has('http://hl7.org/fhir/Extension.valueDateTime', item) then
      result.value := parseDateTime(item);
    if obj.has('http://hl7.org/fhir/Extension.valueDecimal', item) then
      result.value := parseDecimal(item);
    if obj.has('http://hl7.org/fhir/Extension.valueInstant', item) then
      result.value := parseInstant(item);
    if obj.has('http://hl7.org/fhir/Extension.valueInteger', item) then
      result.value := parseInteger(item);
    if obj.has('http://hl7.org/fhir/Extension.valueString', item) then
      result.value := parseString(item);
    if obj.has('http://hl7.org/fhir/Extension.valueTime', item) then
      result.value := parseTime(item);
    if obj.has('http://hl7.org/fhir/Extension.valueUri', item) then
      result.value := parseUri(item);
end;

procedure TFHIRTurtleComposer.ComposeExtension(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExtension; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Extension'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  ComposeString(this, 'Extension', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirCanonical) {6} then
    ComposeCanonical(this, 'Extension', 'valueCanonical', TFhirCanonical(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirCode) {6} then
    ComposeCode(this, 'Extension', 'valueCode', TFhirCode(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirId) {6} then
    ComposeId(this, 'Extension', 'valueId', TFhirId(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirMarkdown) {6} then
    ComposeMarkdown(this, 'Extension', 'valueMarkdown', TFhirMarkdown(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirOid) {6} then
    ComposeOid(this, 'Extension', 'valueOid', TFhirOid(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirPositiveInt) {6} then
    ComposePositiveInt(this, 'Extension', 'valuePositiveInt', TFhirPositiveInt(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(this, 'Extension', 'valueUnsignedInt', TFhirUnsignedInt(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirUrl) {6} then
    ComposeUrl(this, 'Extension', 'valueUrl', TFhirUrl(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirUuid) {6} then
    ComposeUuid(this, 'Extension', 'valueUuid', TFhirUuid(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirAddress) {6} then
    ComposeAddress(this, 'Extension', 'valueAddress', TFhirAddress(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirAge) {6} then
    ComposeAge(this, 'Extension', 'valueAge', TFhirAge(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirAnnotation) {6} then
    ComposeAnnotation(this, 'Extension', 'valueAnnotation', TFhirAnnotation(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirAttachment) {6} then
    ComposeAttachment(this, 'Extension', 'valueAttachment', TFhirAttachment(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Extension', 'valueCodeableConcept', TFhirCodeableConcept(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirCoding) {6} then
    ComposeCoding(this, 'Extension', 'valueCoding', TFhirCoding(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirContactPoint) {6} then
    ComposeContactPoint(this, 'Extension', 'valueContactPoint', TFhirContactPoint(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirCount) {6} then
    ComposeCount(this, 'Extension', 'valueCount', TFhirCount(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDistance) {6} then
    ComposeDistance(this, 'Extension', 'valueDistance', TFhirDistance(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDuration) {6} then
    ComposeDuration(this, 'Extension', 'valueDuration', TFhirDuration(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirHumanName) {6} then
    ComposeHumanName(this, 'Extension', 'valueHumanName', TFhirHumanName(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirIdentifier) {6} then
    ComposeIdentifier(this, 'Extension', 'valueIdentifier', TFhirIdentifier(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirMoney) {6} then
    ComposeMoney(this, 'Extension', 'valueMoney', TFhirMoney(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirPeriod) {6} then
    ComposePeriod(this, 'Extension', 'valuePeriod', TFhirPeriod(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'Extension', 'valueQuantity', TFhirQuantity(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirRange) {6} then
    ComposeRange(this, 'Extension', 'valueRange', TFhirRange(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirRatio) {6} then
    ComposeRatio(this, 'Extension', 'valueRatio', TFhirRatio(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirReference) {6} then
    ComposeReference(this, 'Extension', 'valueReference', TFhirReference(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirSampledData) {6} then
    ComposeSampledData(this, 'Extension', 'valueSampledData', TFhirSampledData(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirSignature) {6} then
    ComposeSignature(this, 'Extension', 'valueSignature', TFhirSignature(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirTiming) {6} then
    ComposeTiming(this, 'Extension', 'valueTiming', TFhirTiming(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirContactDetail) {6} then
    ComposeContactDetail(this, 'Extension', 'valueContactDetail', TFhirContactDetail(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirContributor) {6} then
    ComposeContributor(this, 'Extension', 'valueContributor', TFhirContributor(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDataRequirement) {6} then
    ComposeDataRequirement(this, 'Extension', 'valueDataRequirement', TFhirDataRequirement(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirExpression) {6} then
    ComposeExpression(this, 'Extension', 'valueExpression', TFhirExpression(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirParameterDefinition) {6} then
    ComposeParameterDefinition(this, 'Extension', 'valueParameterDefinition', TFhirParameterDefinition(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirRelatedArtifact) {6} then
    ComposeRelatedArtifact(this, 'Extension', 'valueRelatedArtifact', TFhirRelatedArtifact(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirTriggerDefinition) {6} then
    ComposeTriggerDefinition(this, 'Extension', 'valueTriggerDefinition', TFhirTriggerDefinition(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirUsageContext) {6} then
    ComposeUsageContext(this, 'Extension', 'valueUsageContext', TFhirUsageContext(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDosage) {6} then
    ComposeDosage(this, 'Extension', 'valueDosage', TFhirDosage(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirBase64Binary) {6} then
    ComposeBase64Binary(this, 'Extension', 'valueBase64Binary', TFhirBase64Binary(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirBoolean) {6} then
    ComposeBoolean(this, 'Extension', 'valueBoolean', TFhirBoolean(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDate) {6} then
    ComposeDate(this, 'Extension', 'valueDate', TFhirDate(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDateTime) {6} then
    ComposeDateTime(this, 'Extension', 'valueDateTime', TFhirDateTime(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDecimal) {6} then
    ComposeDecimal(this, 'Extension', 'valueDecimal', TFhirDecimal(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirInstant) {6} then
    ComposeInstant(this, 'Extension', 'valueInstant', TFhirInstant(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirInteger) {6} then
    ComposeInteger(this, 'Extension', 'valueInteger', TFhirInteger(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirString) {6} then
    ComposeString(this, 'Extension', 'valueString', TFhirString(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirTime) {6} then
    ComposeTime(this, 'Extension', 'valueTime', TFhirTime(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirUri) {6} then
    ComposeUri(this, 'Extension', 'valueUri', TFhirUri(elem.value), false, -1);{x.d9}
end;

function TFHIRTurtleParser.ParseNarrative(obj : TTurtleComplex) : TFhirNarrative;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirNarrative.create;
  try
    ParseNarrativeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseNarrativeProperties(obj : TTurtleComplex; result : TFhirNarrative);
begin
    ParseElementProperties(obj, result);
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Narrative.status'), CODES_TFhirNarrativeStatusEnum, SYSTEMS_TFhirNarrativeStatusEnum);
    result.div_ := ParseXHtmlNode(obj.stringLiteral('http://hl7.org/fhir/Narrative.div'));{q2}
end;

procedure TFHIRTurtleComposer.ComposeNarrative(parent :  TTurtleComplex; parentType, name : String; elem : TFhirNarrative; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Narrative'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'Narrative', 'status', elem.StatusElement, CODES_TFhirNarrativeStatusEnum, SYSTEMS_TFhirNarrativeStatusEnum, false, -1);{x.d4}
  ComposeXHtmlNode(this, 'Narrative', 'div', elem.div_Element, false, -1);{x.2eb}
end;

function TFHIRTurtleParser.ParseContributor(obj : TTurtleComplex) : TFhirContributor;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirContributor.create;
  try
    ParseContributorProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseContributorProperties(obj : TTurtleComplex; result : TFhirContributor);
var
  item : TTurtleComplex;
begin
    ParseElementProperties(obj, result);
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/Contributor.type'), CODES_TFhirContributorTypeEnum, SYSTEMS_TFhirContributorTypeEnum);
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/Contributor.name'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Contributor.contact') do
      result.contactList.Add(parseContactDetail(item));
end;

procedure TFHIRTurtleComposer.ComposeContributor(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContributor; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Contributor'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'Contributor', 'type', elem.Type_Element, CODES_TFhirContributorTypeEnum, SYSTEMS_TFhirContributorTypeEnum, false, -1);{x.d4}
  ComposeString(this, 'Contributor', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(this, 'Contributor', 'contact', elem.contactList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseAttachment(obj : TTurtleComplex) : TFhirAttachment;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAttachment.create;
  try
    ParseAttachmentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAttachmentProperties(obj : TTurtleComplex; result : TFhirAttachment);
begin
    ParseElementProperties(obj, result);
    result.contentTypeElement := ParseCode(obj.complex('http://hl7.org/fhir/Attachment.contentType'));{q1}
    result.languageElement := ParseCode(obj.complex('http://hl7.org/fhir/Attachment.language'));{q1}
    result.dataElement := ParseBase64Binary(obj.complex('http://hl7.org/fhir/Attachment.data'));{q1}
    result.urlElement := ParseUrl(obj.complex('http://hl7.org/fhir/Attachment.url'));{q1}
    result.sizeElement := ParseUnsignedInt(obj.complex('http://hl7.org/fhir/Attachment.size'));{q1}
    result.hashElement := ParseBase64Binary(obj.complex('http://hl7.org/fhir/Attachment.hash'));{q1}
    result.titleElement := ParseString(obj.complex('http://hl7.org/fhir/Attachment.title'));{q1}
    result.creationElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Attachment.creation'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeAttachment(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAttachment; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Attachment'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCode(this, 'Attachment', 'contentType', elem.contentTypeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCode(this, 'Attachment', 'language', elem.languageElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBase64Binary(this, 'Attachment', 'data', elem.dataElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUrl(this, 'Attachment', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUnsignedInt(this, 'Attachment', 'size', elem.sizeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBase64Binary(this, 'Attachment', 'hash', elem.hashElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'Attachment', 'title', elem.titleElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDateTime(this, 'Attachment', 'creation', elem.creationElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseDataRequirementCodeFilter(obj : TTurtleComplex) : TFhirDataRequirementCodeFilter;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDataRequirementCodeFilter.create;
  try
    ParseDataRequirementCodeFilterProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDataRequirementCodeFilterProperties(obj : TTurtleComplex; result : TFhirDataRequirementCodeFilter);
var
  item : TTurtleComplex;
begin
    ParseElementProperties(obj, result);
    result.pathElement := ParseString(obj.complex('http://hl7.org/fhir/DataRequirement.codeFilter.path'));{q1}
    result.searchParamElement := ParseString(obj.complex('http://hl7.org/fhir/DataRequirement.codeFilter.searchParam'));{q1}
    result.valueSetElement := ParseCanonical(obj.complex('http://hl7.org/fhir/DataRequirement.codeFilter.valueSet'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/DataRequirement.codeFilter.code') do
      result.codeList.Add(parseCoding(item));
end;

procedure TFHIRTurtleComposer.ComposeDataRequirementCodeFilter(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDataRequirementCodeFilter; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DataRequirementCodeFilter'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'DataRequirement.codeFilter', 'path', elem.pathElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'DataRequirement.codeFilter', 'searchParam', elem.searchParamElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCanonical(this, 'DataRequirement.codeFilter', 'valueSet', elem.valueSetElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.codeList.Count - 1 do
      ComposeCoding(this, 'DataRequirement.codeFilter', 'code', elem.codeList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseDataRequirementDateFilter(obj : TTurtleComplex) : TFhirDataRequirementDateFilter;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDataRequirementDateFilter.create;
  try
    ParseDataRequirementDateFilterProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDataRequirementDateFilterProperties(obj : TTurtleComplex; result : TFhirDataRequirementDateFilter);
var
  item : TTurtleComplex;
begin
    ParseElementProperties(obj, result);
    result.pathElement := ParseString(obj.complex('http://hl7.org/fhir/DataRequirement.dateFilter.path'));{q1}
    result.searchParamElement := ParseString(obj.complex('http://hl7.org/fhir/DataRequirement.dateFilter.searchParam'));{q1}
    if obj.has('http://hl7.org/fhir/DataRequirement.dateFilter.valuePeriod', item) then
      result.value := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/DataRequirement.dateFilter.valueDuration', item) then
      result.value := parseDuration(item);
    if obj.has('http://hl7.org/fhir/DataRequirement.dateFilter.valueDateTime', item) then
      result.value := parseDateTime(item);
end;

procedure TFHIRTurtleComposer.ComposeDataRequirementDateFilter(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDataRequirementDateFilter; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DataRequirementDateFilter'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'DataRequirement.dateFilter', 'path', elem.pathElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'DataRequirement.dateFilter', 'searchParam', elem.searchParamElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirPeriod) {6} then
    ComposePeriod(this, 'DataRequirement.dateFilter', 'valuePeriod', TFhirPeriod(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirDuration) {6} then
    ComposeDuration(this, 'DataRequirement.dateFilter', 'valueDuration', TFhirDuration(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirDateTime) {6} then
    ComposeDateTime(this, 'DataRequirement.dateFilter', 'valueDateTime', TFhirDateTime(elem.value), false, -1);{x.d9}
end;

function TFHIRTurtleParser.ParseDataRequirementSort(obj : TTurtleComplex) : TFhirDataRequirementSort;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDataRequirementSort.create;
  try
    ParseDataRequirementSortProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDataRequirementSortProperties(obj : TTurtleComplex; result : TFhirDataRequirementSort);
begin
    ParseElementProperties(obj, result);
    result.pathElement := ParseString(obj.complex('http://hl7.org/fhir/DataRequirement.sort.path'));{q1}
    result.directionElement := ParseEnum(obj.complex('http://hl7.org/fhir/DataRequirement.sort.direction'), CODES_TFhirSortDirectionEnum, SYSTEMS_TFhirSortDirectionEnum);
end;

procedure TFHIRTurtleComposer.ComposeDataRequirementSort(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDataRequirementSort; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DataRequirementSort'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  ComposeString(this, 'DataRequirement.sort', 'path', elem.pathElement, false, -1);{x.2ea}
  ComposeEnum(this, 'DataRequirement.sort', 'direction', elem.DirectionElement, CODES_TFhirSortDirectionEnum, SYSTEMS_TFhirSortDirectionEnum, false, -1);{x.d4}
end;

function TFHIRTurtleParser.ParseDataRequirement(obj : TTurtleComplex) : TFhirDataRequirement;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDataRequirement.create;
  try
    ParseDataRequirementProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDataRequirementProperties(obj : TTurtleComplex; result : TFhirDataRequirement);
var
  item : TTurtleComplex;
begin
    ParseElementProperties(obj, result);
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/DataRequirement.type'), CODES_TFhirAllTypesEnum, SYSTEMS_TFhirAllTypesEnum);
    for item in obj.complexes('http://hl7.org/fhir/DataRequirement.profile') do
      result.profileList.Add(parseCanonical(item));
    if obj.has('http://hl7.org/fhir/DataRequirement.subjectCodeableConcept', item) then
      result.subject := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/DataRequirement.subjectReference', item) {a3} then
      result.subject := ParseReference(item);
    for item in obj.complexes('http://hl7.org/fhir/DataRequirement.mustSupport') do
      result.mustSupportList.Add(parseString(item));
    for item in obj.complexes('http://hl7.org/fhir/DataRequirement.codeFilter') do
      result.codeFilterList.Add(parseDataRequirementCodeFilter(item));
    for item in obj.complexes('http://hl7.org/fhir/DataRequirement.dateFilter') do
      result.dateFilterList.Add(parseDataRequirementDateFilter(item));
    result.limitElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/DataRequirement.limit'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/DataRequirement.sort') do
      result.sortList.Add(parseDataRequirementSort(item));
end;

procedure TFHIRTurtleComposer.ComposeDataRequirement(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDataRequirement; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DataRequirement'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'DataRequirement', 'type', elem.Type_Element, CODES_TFhirAllTypesEnum, SYSTEMS_TFhirAllTypesEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.profileList.Count - 1 do
      ComposeCanonical(this, 'DataRequirement', 'profile', elem.profileList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.subject is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'DataRequirement', 'subjectCodeableConcept', TFhirCodeableConcept(elem.subject), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.subject is TFhirReference) {2} then
    ComposeReference(this, 'DataRequirement', 'subjectReference', TFhirReference(elem.subject), false,-1);{x.d8}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.mustSupportList.Count - 1 do
      ComposeString(this, 'DataRequirement', 'mustSupport', elem.mustSupportList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.codeFilterList.Count - 1 do
      ComposeDataRequirementCodeFilter(this, 'DataRequirement', 'codeFilter', elem.codeFilterList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.dateFilterList.Count - 1 do
      ComposeDataRequirementDateFilter(this, 'DataRequirement', 'dateFilter', elem.dateFilterList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposePositiveInt(this, 'DataRequirement', 'limit', elem.limitElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.sortList.Count - 1 do
      ComposeDataRequirementSort(this, 'DataRequirement', 'sort', elem.sortList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseDosageDoseAndRate(obj : TTurtleComplex) : TFhirDosageDoseAndRate;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDosageDoseAndRate.create;
  try
    ParseDosageDoseAndRateProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDosageDoseAndRateProperties(obj : TTurtleComplex; result : TFhirDosageDoseAndRate);
var
  item : TTurtleComplex;
begin
    ParseElementProperties(obj, result);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Dosage.doseAndRate.type'));{q3b}
    if obj.has('http://hl7.org/fhir/Dosage.doseAndRate.doseRange', item) then
      result.dose := parseRange(item);
    if obj.has('http://hl7.org/fhir/Dosage.doseAndRate.doseQuantity', item) then
      result.dose := parseQuantity(item);
    if obj.has('http://hl7.org/fhir/Dosage.doseAndRate.rateRatio', item) then
      result.rate := parseRatio(item);
    if obj.has('http://hl7.org/fhir/Dosage.doseAndRate.rateRange', item) then
      result.rate := parseRange(item);
    if obj.has('http://hl7.org/fhir/Dosage.doseAndRate.rateQuantity', item) then
      result.rate := parseQuantity(item);
end;

procedure TFHIRTurtleComposer.ComposeDosageDoseAndRate(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDosageDoseAndRate; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DosageDoseAndRate'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Dosage.doseAndRate', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.dose is TFhirRange) {6} then
    ComposeRange(this, 'Dosage.doseAndRate', 'doseRange', TFhirRange(elem.dose), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.dose is TFhirQuantity) {6} then
    ComposeQuantity(this, 'Dosage.doseAndRate', 'doseQuantity', TFhirQuantity(elem.dose), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.rate is TFhirRatio) {6} then
    ComposeRatio(this, 'Dosage.doseAndRate', 'rateRatio', TFhirRatio(elem.rate), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.rate is TFhirRange) {6} then
    ComposeRange(this, 'Dosage.doseAndRate', 'rateRange', TFhirRange(elem.rate), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.rate is TFhirQuantity) {6} then
    ComposeQuantity(this, 'Dosage.doseAndRate', 'rateQuantity', TFhirQuantity(elem.rate), false, -1);{x.d9}
end;

function TFHIRTurtleParser.ParseDosage(obj : TTurtleComplex) : TFhirDosage;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDosage.create;
  try
    ParseDosageProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDosageProperties(obj : TTurtleComplex; result : TFhirDosage);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.sequenceElement := ParseInteger(obj.complex('http://hl7.org/fhir/Dosage.sequence'));{q1}
    result.textElement := ParseString(obj.complex('http://hl7.org/fhir/Dosage.text'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Dosage.additionalInstruction') do
      result.additionalInstructionList.Add(parseCodeableConcept(item));
    result.patientInstructionElement := ParseString(obj.complex('http://hl7.org/fhir/Dosage.patientInstruction'));{q1}
    result.timing := ParseTiming(obj.complex('http://hl7.org/fhir/Dosage.timing'));{q3b}
    if obj.has('http://hl7.org/fhir/Dosage.asNeededCodeableConcept', item) then
      result.asNeeded := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/Dosage.asNeededBoolean', item) then
      result.asNeeded := parseBoolean(item);
    result.site := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Dosage.site'));{q3b}
    result.route := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Dosage.route'));{q3b}
    result.method := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Dosage.method'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Dosage.doseAndRate') do
      result.doseAndRateList.Add(parseDosageDoseAndRate(item));
    result.maxDosePerPeriod := ParseRatio(obj.complex('http://hl7.org/fhir/Dosage.maxDosePerPeriod'));{q3b}
    result.maxDosePerAdministration := ParseQuantity(obj.complex('http://hl7.org/fhir/Dosage.maxDosePerAdministration'));{q3b}
    result.maxDosePerLifetime := ParseQuantity(obj.complex('http://hl7.org/fhir/Dosage.maxDosePerLifetime'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeDosage(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDosage; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Dosage'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInteger(this, 'Dosage', 'sequence', elem.sequenceElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'Dosage', 'text', elem.textElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.additionalInstructionList.Count - 1 do
      ComposeCodeableConcept(this, 'Dosage', 'additionalInstruction', elem.additionalInstructionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'Dosage', 'patientInstruction', elem.patientInstructionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeTiming(this, 'Dosage', 'timing', elem.timingElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.asNeeded is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Dosage', 'asNeededCodeableConcept', TFhirCodeableConcept(elem.asNeeded), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.asNeeded is TFhirBoolean) {6} then
    ComposeBoolean(this, 'Dosage', 'asNeededBoolean', TFhirBoolean(elem.asNeeded), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeableConcept(this, 'Dosage', 'site', elem.siteElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeableConcept(this, 'Dosage', 'route', elem.routeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeableConcept(this, 'Dosage', 'method', elem.methodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.doseAndRateList.Count - 1 do
      ComposeDosageDoseAndRate(this, 'Dosage', 'doseAndRate', elem.doseAndRateList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeRatio(this, 'Dosage', 'maxDosePerPeriod', elem.maxDosePerPeriodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeQuantity(this, 'Dosage', 'maxDosePerAdministration', elem.maxDosePerAdministrationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeQuantity(this, 'Dosage', 'maxDosePerLifetime', elem.maxDosePerLifetimeElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseMoney(obj : TTurtleComplex) : TFhirMoney;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMoney.create;
  try
    ParseMoneyProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMoneyProperties(obj : TTurtleComplex; result : TFhirMoney);
begin
    ParseElementProperties(obj, result);
    result.valueElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Money.value'));{q1}
    result.currencyElement := ParseCode(obj.complex('http://hl7.org/fhir/Money.currency'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeMoney(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMoney; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Money'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDecimal(this, 'Money', 'value', elem.valueElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCode(this, 'Money', 'currency', elem.currencyElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseMarketingStatus(obj : TTurtleComplex) : TFhirMarketingStatus;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMarketingStatus.create;
  try
    ParseMarketingStatusProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMarketingStatusProperties(obj : TTurtleComplex; result : TFhirMarketingStatus);
begin
    ParseBackboneElementProperties(obj, result);
    result.country := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MarketingStatus.country'));{q3b}
    result.jurisdiction := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MarketingStatus.jurisdiction'));{q3b}
    result.status := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MarketingStatus.status'));{q3b}
    result.dateRange := ParsePeriod(obj.complex('http://hl7.org/fhir/MarketingStatus.dateRange'));{q3b}
    result.restoreDateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/MarketingStatus.restoreDate'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeMarketingStatus(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMarketingStatus; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MarketingStatus'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'MarketingStatus', 'country', elem.countryElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeableConcept(this, 'MarketingStatus', 'jurisdiction', elem.jurisdictionElement, false, -1);{x.2f}
  ComposeCodeableConcept(this, 'MarketingStatus', 'status', elem.statusElement, false, -1);{x.2f}
  ComposePeriod(this, 'MarketingStatus', 'dateRange', elem.dateRangeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDateTime(this, 'MarketingStatus', 'restoreDate', elem.restoreDateElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseIdentifier(obj : TTurtleComplex) : TFhirIdentifier;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirIdentifier.create;
  try
    ParseIdentifierProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseIdentifierProperties(obj : TTurtleComplex; result : TFhirIdentifier);
begin
    ParseElementProperties(obj, result);
    result.useElement := ParseEnum(obj.complex('http://hl7.org/fhir/Identifier.use'), CODES_TFhirIdentifierUseEnum, SYSTEMS_TFhirIdentifierUseEnum);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Identifier.type'));{q3b}
    result.systemElement := ParseUri(obj.complex('http://hl7.org/fhir/Identifier.system'));{q1}
    result.valueElement := ParseString(obj.complex('http://hl7.org/fhir/Identifier.value'));{q1}
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Identifier.period'));{q3b}
    result.assigner := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/Identifier.assigner'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeIdentifier(parent :  TTurtleComplex; parentType, name : String; elem : TFhirIdentifier; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Identifier'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeEnum(this, 'Identifier', 'use', elem.UseElement, CODES_TFhirIdentifierUseEnum, SYSTEMS_TFhirIdentifierUseEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeableConcept(this, 'Identifier', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUri(this, 'Identifier', 'system', elem.systemElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'Identifier', 'value', elem.valueElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposePeriod(this, 'Identifier', 'period', elem.periodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeReference{TFhirOrganization}(this, 'Identifier', 'assigner', elem.assignerElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseSubstanceAmountReferenceRange(obj : TTurtleComplex) : TFhirSubstanceAmountReferenceRange;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstanceAmountReferenceRange.create;
  try
    ParseSubstanceAmountReferenceRangeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstanceAmountReferenceRangeProperties(obj : TTurtleComplex; result : TFhirSubstanceAmountReferenceRange);
begin
    ParseElementProperties(obj, result);
    result.lowLimit := ParseQuantity(obj.complex('http://hl7.org/fhir/SubstanceAmount.referenceRange.lowLimit'));{q3b}
    result.highLimit := ParseQuantity(obj.complex('http://hl7.org/fhir/SubstanceAmount.referenceRange.highLimit'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeSubstanceAmountReferenceRange(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstanceAmountReferenceRange; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstanceAmountReferenceRange'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'SubstanceAmount.referenceRange', 'lowLimit', elem.lowLimitElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'SubstanceAmount.referenceRange', 'highLimit', elem.highLimitElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseSubstanceAmount(obj : TTurtleComplex) : TFhirSubstanceAmount;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstanceAmount.create;
  try
    ParseSubstanceAmountProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstanceAmountProperties(obj : TTurtleComplex; result : TFhirSubstanceAmount);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    if obj.has('http://hl7.org/fhir/SubstanceAmount.amountQuantity', item) then
      result.amount := parseQuantity(item);
    if obj.has('http://hl7.org/fhir/SubstanceAmount.amountRange', item) then
      result.amount := parseRange(item);
    if obj.has('http://hl7.org/fhir/SubstanceAmount.amountString', item) then
      result.amount := parseString(item);
    result.amountType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceAmount.amountType'));{q3b}
    result.amountTextElement := ParseString(obj.complex('http://hl7.org/fhir/SubstanceAmount.amountText'));{q1}
    result.referenceRange := ParseSubstanceAmountReferenceRange(obj.complex('http://hl7.org/fhir/SubstanceAmount.referenceRange'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeSubstanceAmount(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstanceAmount; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstanceAmount'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.amount is TFhirQuantity) {6} then
    ComposeQuantity(this, 'SubstanceAmount', 'amountQuantity', TFhirQuantity(elem.amount), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.amount is TFhirRange) {6} then
    ComposeRange(this, 'SubstanceAmount', 'amountRange', TFhirRange(elem.amount), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.amount is TFhirString) {6} then
    ComposeString(this, 'SubstanceAmount', 'amountString', TFhirString(elem.amount), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeableConcept(this, 'SubstanceAmount', 'amountType', elem.amountTypeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'SubstanceAmount', 'amountText', elem.amountTextElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeSubstanceAmountReferenceRange(this, 'SubstanceAmount', 'referenceRange', elem.referenceRangeElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseCoding(obj : TTurtleComplex) : TFhirCoding;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCoding.create;
  try
    ParseCodingProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCodingProperties(obj : TTurtleComplex; result : TFhirCoding);
begin
    ParseElementProperties(obj, result);
    result.systemElement := ParseUri(obj.complex('http://hl7.org/fhir/Coding.system'));{q1}
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/Coding.version'));{q1}
    result.codeElement := ParseCode(obj.complex('http://hl7.org/fhir/Coding.code'));{q1}
    result.displayElement := ParseString(obj.complex('http://hl7.org/fhir/Coding.display'));{q1}
    result.userSelectedElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Coding.userSelected'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeCoding(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCoding; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Coding'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUri(this, 'Coding', 'system', elem.systemElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'Coding', 'version', elem.versionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCode(this, 'Coding', 'code', elem.codeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'Coding', 'display', elem.displayElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBoolean(this, 'Coding', 'userSelected', elem.userSelectedElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseSampledData(obj : TTurtleComplex) : TFhirSampledData;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSampledData.create;
  try
    ParseSampledDataProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSampledDataProperties(obj : TTurtleComplex; result : TFhirSampledData);
begin
    ParseElementProperties(obj, result);
    result.origin := ParseQuantity(obj.complex('http://hl7.org/fhir/SampledData.origin'));{q3b}
    result.periodElement := ParseDecimal(obj.complex('http://hl7.org/fhir/SampledData.period'));{q1}
    result.factorElement := ParseDecimal(obj.complex('http://hl7.org/fhir/SampledData.factor'));{q1}
    result.lowerLimitElement := ParseDecimal(obj.complex('http://hl7.org/fhir/SampledData.lowerLimit'));{q1}
    result.upperLimitElement := ParseDecimal(obj.complex('http://hl7.org/fhir/SampledData.upperLimit'));{q1}
    result.dimensionsElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/SampledData.dimensions'));{q1}
    result.dataElement := ParseString(obj.complex('http://hl7.org/fhir/SampledData.data'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeSampledData(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSampledData; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SampledData'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  ComposeQuantity(this, 'SampledData', 'origin', elem.originElement, false, -1);{x.2f}
  ComposeDecimal(this, 'SampledData', 'period', elem.periodElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDecimal(this, 'SampledData', 'factor', elem.factorElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDecimal(this, 'SampledData', 'lowerLimit', elem.lowerLimitElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDecimal(this, 'SampledData', 'upperLimit', elem.upperLimitElement, false, -1);{x.2ea}
  ComposePositiveInt(this, 'SampledData', 'dimensions', elem.dimensionsElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'SampledData', 'data', elem.dataElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParsePopulation(obj : TTurtleComplex) : TFhirPopulation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPopulation.create;
  try
    ParsePopulationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePopulationProperties(obj : TTurtleComplex; result : TFhirPopulation);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    if obj.has('http://hl7.org/fhir/Population.ageRange', item) then
      result.age := parseRange(item);
    if obj.has('http://hl7.org/fhir/Population.ageCodeableConcept', item) then
      result.age := parseCodeableConcept(item);
    result.gender := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Population.gender'));{q3b}
    result.race := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Population.race'));{q3b}
    result.physiologicalCondition := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Population.physiologicalCondition'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposePopulation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPopulation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Population'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.age is TFhirRange) {6} then
    ComposeRange(this, 'Population', 'ageRange', TFhirRange(elem.age), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.age is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Population', 'ageCodeableConcept', TFhirCodeableConcept(elem.age), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeableConcept(this, 'Population', 'gender', elem.genderElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeableConcept(this, 'Population', 'race', elem.raceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeableConcept(this, 'Population', 'physiologicalCondition', elem.physiologicalConditionElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseRatio(obj : TTurtleComplex) : TFhirRatio;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirRatio.create;
  try
    ParseRatioProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseRatioProperties(obj : TTurtleComplex; result : TFhirRatio);
begin
    ParseElementProperties(obj, result);
    result.numerator := ParseQuantity(obj.complex('http://hl7.org/fhir/Ratio.numerator'));{q3b}
    result.denominator := ParseQuantity(obj.complex('http://hl7.org/fhir/Ratio.denominator'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeRatio(parent :  TTurtleComplex; parentType, name : String; elem : TFhirRatio; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Ratio'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeQuantity(this, 'Ratio', 'numerator', elem.numeratorElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeQuantity(this, 'Ratio', 'denominator', elem.denominatorElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseReference(obj : TTurtleComplex) : TFhirReference;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirReference.create;
  try
    ParseReferenceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseReferenceProperties(obj : TTurtleComplex; result : TFhirReference);
begin
    ParseElementProperties(obj, result);
    result.referenceElement := ParseString(obj.complex('http://hl7.org/fhir/Reference.reference'));{q1}
    result.type_Element := ParseUri(obj.complex('http://hl7.org/fhir/Reference.type'));{q1}
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/Reference.identifier'));{q3b}
    result.displayElement := ParseString(obj.complex('http://hl7.org/fhir/Reference.display'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeReference(parent :  TTurtleComplex; parentType, name : String; elem : TFhirReference; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Reference'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'Reference', 'reference', elem.referenceElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUri(this, 'Reference', 'type', elem.type_Element, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeIdentifier(this, 'Reference', 'identifier', elem.identifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'Reference', 'display', elem.displayElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseTriggerDefinition(obj : TTurtleComplex) : TFhirTriggerDefinition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTriggerDefinition.create;
  try
    ParseTriggerDefinitionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTriggerDefinitionProperties(obj : TTurtleComplex; result : TFhirTriggerDefinition);
var
  item : TTurtleComplex;
begin
    ParseElementProperties(obj, result);
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/TriggerDefinition.type'), CODES_TFhirTriggerTypeEnum, SYSTEMS_TFhirTriggerTypeEnum);
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/TriggerDefinition.name'));{q1}
    if obj.has('http://hl7.org/fhir/TriggerDefinition.timingTiming', item) then
      result.timing := parseTiming(item);
    if obj.has('http://hl7.org/fhir/TriggerDefinition.timingReference', item) {a3} then
      result.timing := ParseReference(item);
    if obj.has('http://hl7.org/fhir/TriggerDefinition.timingDate', item) then
      result.timing := parseDate(item);
    if obj.has('http://hl7.org/fhir/TriggerDefinition.timingDateTime', item) then
      result.timing := parseDateTime(item);
    for item in obj.complexes('http://hl7.org/fhir/TriggerDefinition.data') do
      result.dataList.Add(parseDataRequirement(item));
    result.condition := ParseExpression(obj.complex('http://hl7.org/fhir/TriggerDefinition.condition'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeTriggerDefinition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTriggerDefinition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TriggerDefinition'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'TriggerDefinition', 'type', elem.Type_Element, CODES_TFhirTriggerTypeEnum, SYSTEMS_TFhirTriggerTypeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'TriggerDefinition', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.timing is TFhirTiming) {6} then
    ComposeTiming(this, 'TriggerDefinition', 'timingTiming', TFhirTiming(elem.timing), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.timing is TFhirReference) {2} then
    ComposeReference(this, 'TriggerDefinition', 'timingReference', TFhirReference(elem.timing), false,-1){x.d8}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.timing is TFhirDate) {6} then
    ComposeDate(this, 'TriggerDefinition', 'timingDate', TFhirDate(elem.timing), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.timing is TFhirDateTime) {6} then
    ComposeDateTime(this, 'TriggerDefinition', 'timingDateTime', TFhirDateTime(elem.timing), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.dataList.Count - 1 do
      ComposeDataRequirement(this, 'TriggerDefinition', 'data', elem.dataList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeExpression(this, 'TriggerDefinition', 'condition', elem.conditionElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParsePeriod(obj : TTurtleComplex) : TFhirPeriod;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPeriod.create;
  try
    ParsePeriodProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePeriodProperties(obj : TTurtleComplex; result : TFhirPeriod);
begin
    ParseElementProperties(obj, result);
    result.startElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Period.start'));{q1}
    result.end_Element := ParseDateTime(obj.complex('http://hl7.org/fhir/Period.end'));{q1}
end;

procedure TFHIRTurtleComposer.ComposePeriod(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPeriod; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Period'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDateTime(this, 'Period', 'start', elem.startElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDateTime(this, 'Period', 'end', elem.end_Element, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseQuantity(obj : TTurtleComplex) : TFhirQuantity;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirQuantity.create;
  try
    ParseQuantityProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseQuantityProperties(obj : TTurtleComplex; result : TFhirQuantity);
begin
    ParseElementProperties(obj, result);
    result.valueElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Quantity.value'));{q1}
    result.comparatorElement := ParseEnum(obj.complex('http://hl7.org/fhir/Quantity.comparator'), CODES_TFhirQuantityComparatorEnum, SYSTEMS_TFhirQuantityComparatorEnum);
    result.unit_Element := ParseString(obj.complex('http://hl7.org/fhir/Quantity.unit'));{q1}
    result.systemElement := ParseUri(obj.complex('http://hl7.org/fhir/Quantity.system'));{q1}
    result.codeElement := ParseCode(obj.complex('http://hl7.org/fhir/Quantity.code'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeQuantity(parent :  TTurtleComplex; parentType, name : String; elem : TFhirQuantity; useType : boolean; index : integer);
var
  this : TTurtleComplex;
var
  cb, c : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Quantity'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDecimal(this, 'Quantity', 'value', elem.valueElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeEnum(this, 'Quantity', 'comparator', elem.ComparatorElement, CODES_TFhirQuantityComparatorEnum, SYSTEMS_TFhirQuantityComparatorEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'Quantity', 'unit', elem.unit_Element, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUri(this, 'Quantity', 'system', elem.systemElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCode(this, 'Quantity', 'code', elem.codeElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseRange(obj : TTurtleComplex) : TFhirRange;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirRange.create;
  try
    ParseRangeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseRangeProperties(obj : TTurtleComplex; result : TFhirRange);
begin
    ParseElementProperties(obj, result);
    result.low := ParseQuantity(obj.complex('http://hl7.org/fhir/Range.low'));{q3b}
    result.high := ParseQuantity(obj.complex('http://hl7.org/fhir/Range.high'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeRange(parent :  TTurtleComplex; parentType, name : String; elem : TFhirRange; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Range'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeQuantity(this, 'Range', 'low', elem.lowElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeQuantity(this, 'Range', 'high', elem.highElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseRelatedArtifact(obj : TTurtleComplex) : TFhirRelatedArtifact;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirRelatedArtifact.create;
  try
    ParseRelatedArtifactProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseRelatedArtifactProperties(obj : TTurtleComplex; result : TFhirRelatedArtifact);
begin
    ParseElementProperties(obj, result);
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/RelatedArtifact.type'), CODES_TFhirRelatedArtifactTypeEnum, SYSTEMS_TFhirRelatedArtifactTypeEnum);
    result.label_Element := ParseString(obj.complex('http://hl7.org/fhir/RelatedArtifact.label'));{q1}
    result.displayElement := ParseString(obj.complex('http://hl7.org/fhir/RelatedArtifact.display'));{q1}
    result.citationElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/RelatedArtifact.citation'));{q1}
    result.urlElement := ParseUrl(obj.complex('http://hl7.org/fhir/RelatedArtifact.url'));{q1}
    result.document := ParseAttachment(obj.complex('http://hl7.org/fhir/RelatedArtifact.document'));{q3b}
    result.resourceElement := ParseCanonical(obj.complex('http://hl7.org/fhir/RelatedArtifact.resource'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeRelatedArtifact(parent :  TTurtleComplex; parentType, name : String; elem : TFhirRelatedArtifact; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:RelatedArtifact'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'RelatedArtifact', 'type', elem.Type_Element, CODES_TFhirRelatedArtifactTypeEnum, SYSTEMS_TFhirRelatedArtifactTypeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'RelatedArtifact', 'label', elem.label_Element, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'RelatedArtifact', 'display', elem.displayElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeMarkdown(this, 'RelatedArtifact', 'citation', elem.citationElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUrl(this, 'RelatedArtifact', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeAttachment(this, 'RelatedArtifact', 'document', elem.documentElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCanonical(this, 'RelatedArtifact', 'resource', elem.resourceElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseAnnotation(obj : TTurtleComplex) : TFhirAnnotation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAnnotation.create;
  try
    ParseAnnotationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAnnotationProperties(obj : TTurtleComplex; result : TFhirAnnotation);
var
  item : TTurtleComplex;
begin
    ParseElementProperties(obj, result);
    if obj.has('http://hl7.org/fhir/Annotation.authorReference', item) {a3} then
      result.author := ParseReference(item);
    if obj.has('http://hl7.org/fhir/Annotation.authorString', item) then
      result.author := parseString(item);
    result.timeElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Annotation.time'));{q1}
    result.textElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/Annotation.text'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeAnnotation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAnnotation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Annotation'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.author is TFhirReference) {2} then
    ComposeReference(this, 'Annotation', 'authorReference', TFhirReference(elem.author), false,-1){x.d8}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.author is TFhirString) {6} then
    ComposeString(this, 'Annotation', 'authorString', TFhirString(elem.author), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDateTime(this, 'Annotation', 'time', elem.timeElement, false, -1);{x.2ea}
  ComposeMarkdown(this, 'Annotation', 'text', elem.textElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseProductShelfLife(obj : TTurtleComplex) : TFhirProductShelfLife;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirProductShelfLife.create;
  try
    ParseProductShelfLifeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseProductShelfLifeProperties(obj : TTurtleComplex; result : TFhirProductShelfLife);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/ProductShelfLife.identifier'));{q3b}
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ProductShelfLife.type'));{q3b}
    result.period := ParseQuantity(obj.complex('http://hl7.org/fhir/ProductShelfLife.period'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ProductShelfLife.specialPrecautionsForStorage') do
      result.specialPrecautionsForStorageList.Add(parseCodeableConcept(item));
end;

procedure TFHIRTurtleComposer.ComposeProductShelfLife(parent :  TTurtleComplex; parentType, name : String; elem : TFhirProductShelfLife; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ProductShelfLife'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeIdentifier(this, 'ProductShelfLife', 'identifier', elem.identifierElement, false, -1);{x.2f}
  ComposeCodeableConcept(this, 'ProductShelfLife', 'type', elem.type_Element, false, -1);{x.2f}
  ComposeQuantity(this, 'ProductShelfLife', 'period', elem.periodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.specialPrecautionsForStorageList.Count - 1 do
      ComposeCodeableConcept(this, 'ProductShelfLife', 'specialPrecautionsForStorage', elem.specialPrecautionsForStorageList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseContactDetail(obj : TTurtleComplex) : TFhirContactDetail;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirContactDetail.create;
  try
    ParseContactDetailProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseContactDetailProperties(obj : TTurtleComplex; result : TFhirContactDetail);
var
  item : TTurtleComplex;
begin
    ParseElementProperties(obj, result);
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/ContactDetail.name'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ContactDetail.telecom') do
      result.telecomList.Add(parseContactPoint(item));
end;

procedure TFHIRTurtleComposer.ComposeContactDetail(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContactDetail; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ContactDetail'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'ContactDetail', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(this, 'ContactDetail', 'telecom', elem.telecomList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseExpression(obj : TTurtleComplex) : TFhirExpression;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExpression.create;
  try
    ParseExpressionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExpressionProperties(obj : TTurtleComplex; result : TFhirExpression);
begin
    ParseElementProperties(obj, result);
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/Expression.description'));{q1}
    result.nameElement := ParseId(obj.complex('http://hl7.org/fhir/Expression.name'));{q1}
    result.languageElement := ParseCode(obj.complex('http://hl7.org/fhir/Expression.language'));{q1}
    result.expressionElement := ParseString(obj.complex('http://hl7.org/fhir/Expression.expression'));{q1}
    result.referenceElement := ParseUri(obj.complex('http://hl7.org/fhir/Expression.reference'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeExpression(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExpression; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Expression'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'Expression', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeId(this, 'Expression', 'name', elem.nameElement, false, -1);{x.2ea}
  ComposeCode(this, 'Expression', 'language', elem.languageElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'Expression', 'expression', elem.expressionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUri(this, 'Expression', 'reference', elem.referenceElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseUsageContext(obj : TTurtleComplex) : TFhirUsageContext;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirUsageContext.create;
  try
    ParseUsageContextProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseUsageContextProperties(obj : TTurtleComplex; result : TFhirUsageContext);
var
  item : TTurtleComplex;
begin
    ParseElementProperties(obj, result);
    result.code := ParseCoding(obj.complex('http://hl7.org/fhir/UsageContext.code'));{q3b}
    if obj.has('http://hl7.org/fhir/UsageContext.valueCodeableConcept', item) then
      result.value := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/UsageContext.valueQuantity', item) then
      result.value := parseQuantity(item);
    if obj.has('http://hl7.org/fhir/UsageContext.valueRange', item) then
      result.value := parseRange(item);
    if obj.has('http://hl7.org/fhir/UsageContext.valueReference', item) {a3} then
      result.value := ParseReference(item);
end;

procedure TFHIRTurtleComposer.ComposeUsageContext(parent :  TTurtleComplex; parentType, name : String; elem : TFhirUsageContext; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:UsageContext'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  ComposeCoding(this, 'UsageContext', 'code', elem.codeElement, false, -1);{x.2f}
  if (elem.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'UsageContext', 'valueCodeableConcept', TFhirCodeableConcept(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'UsageContext', 'valueQuantity', TFhirQuantity(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirRange) {6} then
    ComposeRange(this, 'UsageContext', 'valueRange', TFhirRange(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirReference) {2} then
    ComposeReference(this, 'UsageContext', 'valueReference', TFhirReference(elem.value), false,-1);{x.d8}
end;

function TFHIRTurtleParser.ParseSignature(obj : TTurtleComplex) : TFhirSignature;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSignature.create;
  try
    ParseSignatureProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSignatureProperties(obj : TTurtleComplex; result : TFhirSignature);
var
  item : TTurtleComplex;
begin
    ParseElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Signature.type') do
      result.type_List.Add(parseCoding(item));
    result.whenElement := ParseInstant(obj.complex('http://hl7.org/fhir/Signature.when'));{q1}
    result.who := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/Signature.who'));{q3b}
    result.onBehalfOf := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/Signature.onBehalfOf'));{q3b}
    result.targetFormatElement := ParseCode(obj.complex('http://hl7.org/fhir/Signature.targetFormat'));{q1}
    result.sigFormatElement := ParseCode(obj.complex('http://hl7.org/fhir/Signature.sigFormat'));{q1}
    result.dataElement := ParseBase64Binary(obj.complex('http://hl7.org/fhir/Signature.data'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeSignature(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSignature; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Signature'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  for i := 0 to elem.type_List.Count - 1 do
      ComposeCoding(this, 'Signature', 'type', elem.type_List[i], false, i);{x.d3}
  ComposeInstant(this, 'Signature', 'when', elem.whenElement, false, -1);{x.2ea}
  ComposeReference{TFhirPractitioner}(this, 'Signature', 'who', elem.whoElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeReference{TFhirPractitioner}(this, 'Signature', 'onBehalfOf', elem.onBehalfOfElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCode(this, 'Signature', 'targetFormat', elem.targetFormatElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCode(this, 'Signature', 'sigFormat', elem.sigFormatElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBase64Binary(this, 'Signature', 'data', elem.dataElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseProdCharacteristic(obj : TTurtleComplex) : TFhirProdCharacteristic;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirProdCharacteristic.create;
  try
    ParseProdCharacteristicProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseProdCharacteristicProperties(obj : TTurtleComplex; result : TFhirProdCharacteristic);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.height := ParseQuantity(obj.complex('http://hl7.org/fhir/ProdCharacteristic.height'));{q3b}
    result.width := ParseQuantity(obj.complex('http://hl7.org/fhir/ProdCharacteristic.width'));{q3b}
    result.depth := ParseQuantity(obj.complex('http://hl7.org/fhir/ProdCharacteristic.depth'));{q3b}
    result.weight := ParseQuantity(obj.complex('http://hl7.org/fhir/ProdCharacteristic.weight'));{q3b}
    result.nominalVolume := ParseQuantity(obj.complex('http://hl7.org/fhir/ProdCharacteristic.nominalVolume'));{q3b}
    result.externalDiameter := ParseQuantity(obj.complex('http://hl7.org/fhir/ProdCharacteristic.externalDiameter'));{q3b}
    result.shapeElement := ParseString(obj.complex('http://hl7.org/fhir/ProdCharacteristic.shape'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ProdCharacteristic.color') do
      result.colorList.Add(parseString(item));
    for item in obj.complexes('http://hl7.org/fhir/ProdCharacteristic.imprint') do
      result.imprintList.Add(parseString(item));
    for item in obj.complexes('http://hl7.org/fhir/ProdCharacteristic.image') do
      result.imageList.Add(parseAttachment(item));
    result.scoring := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ProdCharacteristic.scoring'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeProdCharacteristic(parent :  TTurtleComplex; parentType, name : String; elem : TFhirProdCharacteristic; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ProdCharacteristic'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeQuantity(this, 'ProdCharacteristic', 'height', elem.heightElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeQuantity(this, 'ProdCharacteristic', 'width', elem.widthElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeQuantity(this, 'ProdCharacteristic', 'depth', elem.depthElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeQuantity(this, 'ProdCharacteristic', 'weight', elem.weightElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeQuantity(this, 'ProdCharacteristic', 'nominalVolume', elem.nominalVolumeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeQuantity(this, 'ProdCharacteristic', 'externalDiameter', elem.externalDiameterElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'ProdCharacteristic', 'shape', elem.shapeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.colorList.Count - 1 do
      ComposeString(this, 'ProdCharacteristic', 'color', elem.colorList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.imprintList.Count - 1 do
      ComposeString(this, 'ProdCharacteristic', 'imprint', elem.imprintList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.imageList.Count - 1 do
      ComposeAttachment(this, 'ProdCharacteristic', 'image', elem.imageList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeableConcept(this, 'ProdCharacteristic', 'scoring', elem.scoringElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseCodeableConcept(obj : TTurtleComplex) : TFhirCodeableConcept;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCodeableConcept.create;
  try
    ParseCodeableConceptProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCodeableConceptProperties(obj : TTurtleComplex; result : TFhirCodeableConcept);
var
  item : TTurtleComplex;
begin
    ParseElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/CodeableConcept.coding') do
      result.codingList.Add(parseCoding(item));
    result.textElement := ParseString(obj.complex('http://hl7.org/fhir/CodeableConcept.text'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeCodeableConcept(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCodeableConcept; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CodeableConcept'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.codingList.Count - 1 do
      ComposeCoding(this, 'CodeableConcept', 'coding', elem.codingList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'CodeableConcept', 'text', elem.textElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseParameterDefinition(obj : TTurtleComplex) : TFhirParameterDefinition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirParameterDefinition.create;
  try
    ParseParameterDefinitionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseParameterDefinitionProperties(obj : TTurtleComplex; result : TFhirParameterDefinition);
begin
    ParseElementProperties(obj, result);
    result.nameElement := ParseCode(obj.complex('http://hl7.org/fhir/ParameterDefinition.name'));{q1}
    result.useElement := ParseEnum(obj.complex('http://hl7.org/fhir/ParameterDefinition.use'), CODES_TFhirOperationParameterUseEnum, SYSTEMS_TFhirOperationParameterUseEnum);
    result.minElement := ParseInteger(obj.complex('http://hl7.org/fhir/ParameterDefinition.min'));{q1}
    result.maxElement := ParseString(obj.complex('http://hl7.org/fhir/ParameterDefinition.max'));{q1}
    result.documentationElement := ParseString(obj.complex('http://hl7.org/fhir/ParameterDefinition.documentation'));{q1}
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/ParameterDefinition.type'), CODES_TFhirAllTypesEnum, SYSTEMS_TFhirAllTypesEnum);
    result.profileElement := ParseCanonical(obj.complex('http://hl7.org/fhir/ParameterDefinition.profile'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeParameterDefinition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirParameterDefinition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ParameterDefinition'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCode(this, 'ParameterDefinition', 'name', elem.nameElement, false, -1);{x.2ea}
  ComposeEnum(this, 'ParameterDefinition', 'use', elem.UseElement, CODES_TFhirOperationParameterUseEnum, SYSTEMS_TFhirOperationParameterUseEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInteger(this, 'ParameterDefinition', 'min', elem.minElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'ParameterDefinition', 'max', elem.maxElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'ParameterDefinition', 'documentation', elem.documentationElement, false, -1);{x.2ea}
  ComposeEnum(this, 'ParameterDefinition', 'type', elem.Type_Element, CODES_TFhirAllTypesEnum, SYSTEMS_TFhirAllTypesEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCanonical(this, 'ParameterDefinition', 'profile', elem.profileElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseContactPoint(obj : TTurtleComplex) : TFhirContactPoint;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirContactPoint.create;
  try
    ParseContactPointProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseContactPointProperties(obj : TTurtleComplex; result : TFhirContactPoint);
begin
    ParseElementProperties(obj, result);
    result.systemElement := ParseEnum(obj.complex('http://hl7.org/fhir/ContactPoint.system'), CODES_TFhirContactPointSystemEnum, SYSTEMS_TFhirContactPointSystemEnum);
    result.valueElement := ParseString(obj.complex('http://hl7.org/fhir/ContactPoint.value'));{q1}
    result.useElement := ParseEnum(obj.complex('http://hl7.org/fhir/ContactPoint.use'), CODES_TFhirContactPointUseEnum, SYSTEMS_TFhirContactPointUseEnum);
    result.rankElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/ContactPoint.rank'));{q1}
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/ContactPoint.period'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeContactPoint(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContactPoint; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ContactPoint'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeEnum(this, 'ContactPoint', 'system', elem.SystemElement, CODES_TFhirContactPointSystemEnum, SYSTEMS_TFhirContactPointSystemEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'ContactPoint', 'value', elem.valueElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeEnum(this, 'ContactPoint', 'use', elem.UseElement, CODES_TFhirContactPointUseEnum, SYSTEMS_TFhirContactPointUseEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposePositiveInt(this, 'ContactPoint', 'rank', elem.rankElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposePeriod(this, 'ContactPoint', 'period', elem.periodElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseHumanName(obj : TTurtleComplex) : TFhirHumanName;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirHumanName.create;
  try
    ParseHumanNameProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseHumanNameProperties(obj : TTurtleComplex; result : TFhirHumanName);
var
  item : TTurtleComplex;
begin
    ParseElementProperties(obj, result);
    result.useElement := ParseEnum(obj.complex('http://hl7.org/fhir/HumanName.use'), CODES_TFhirNameUseEnum, SYSTEMS_TFhirNameUseEnum);
    result.textElement := ParseString(obj.complex('http://hl7.org/fhir/HumanName.text'));{q1}
    result.familyElement := ParseString(obj.complex('http://hl7.org/fhir/HumanName.family'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/HumanName.given') do
      result.givenList.Add(parseString(item));
    for item in obj.complexes('http://hl7.org/fhir/HumanName.prefix') do
      result.prefixList.Add(parseString(item));
    for item in obj.complexes('http://hl7.org/fhir/HumanName.suffix') do
      result.suffixList.Add(parseString(item));
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/HumanName.period'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeHumanName(parent :  TTurtleComplex; parentType, name : String; elem : TFhirHumanName; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:HumanName'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeEnum(this, 'HumanName', 'use', elem.UseElement, CODES_TFhirNameUseEnum, SYSTEMS_TFhirNameUseEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'HumanName', 'text', elem.textElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'HumanName', 'family', elem.familyElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.givenList.Count - 1 do
      ComposeString(this, 'HumanName', 'given', elem.givenList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.prefixList.Count - 1 do
      ComposeString(this, 'HumanName', 'prefix', elem.prefixList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.suffixList.Count - 1 do
      ComposeString(this, 'HumanName', 'suffix', elem.suffixList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposePeriod(this, 'HumanName', 'period', elem.periodElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseMeta(obj : TTurtleComplex) : TFhirMeta;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMeta.create;
  try
    ParseMetaProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMetaProperties(obj : TTurtleComplex; result : TFhirMeta);
var
  item : TTurtleComplex;
begin
    ParseElementProperties(obj, result);
    result.versionIdElement := ParseId(obj.complex('http://hl7.org/fhir/Meta.versionId'));{q1}
    result.lastUpdatedElement := ParseInstant(obj.complex('http://hl7.org/fhir/Meta.lastUpdated'));{q1}
    result.sourceElement := ParseUri(obj.complex('http://hl7.org/fhir/Meta.source'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Meta.profile') do
      result.profileList.Add(parseCanonical(item));
    for item in obj.complexes('http://hl7.org/fhir/Meta.security') do
      result.securityList.Add(parseCoding(item));
    for item in obj.complexes('http://hl7.org/fhir/Meta.tag') do
      result.tagList.Add(parseCoding(item));
end;

procedure TFHIRTurtleComposer.ComposeMeta(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMeta; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Meta'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeId(this, 'Meta', 'versionId', elem.versionIdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInstant(this, 'Meta', 'lastUpdated', elem.lastUpdatedElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUri(this, 'Meta', 'source', elem.sourceElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.profileList.Count - 1 do
      ComposeCanonical(this, 'Meta', 'profile', elem.profileList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.securityList.Count - 1 do
      ComposeCoding(this, 'Meta', 'security', elem.securityList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.tagList.Count - 1 do
      ComposeCoding(this, 'Meta', 'tag', elem.tagList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseAddress(obj : TTurtleComplex) : TFhirAddress;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAddress.create;
  try
    ParseAddressProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAddressProperties(obj : TTurtleComplex; result : TFhirAddress);
var
  item : TTurtleComplex;
begin
    ParseElementProperties(obj, result);
    result.useElement := ParseEnum(obj.complex('http://hl7.org/fhir/Address.use'), CODES_TFhirAddressUseEnum, SYSTEMS_TFhirAddressUseEnum);
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/Address.type'), CODES_TFhirAddressTypeEnum, SYSTEMS_TFhirAddressTypeEnum);
    result.textElement := ParseString(obj.complex('http://hl7.org/fhir/Address.text'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Address.line') do
      result.lineList.Add(parseString(item));
    result.cityElement := ParseString(obj.complex('http://hl7.org/fhir/Address.city'));{q1}
    result.districtElement := ParseString(obj.complex('http://hl7.org/fhir/Address.district'));{q1}
    result.stateElement := ParseString(obj.complex('http://hl7.org/fhir/Address.state'));{q1}
    result.postalCodeElement := ParseString(obj.complex('http://hl7.org/fhir/Address.postalCode'));{q1}
    result.countryElement := ParseString(obj.complex('http://hl7.org/fhir/Address.country'));{q1}
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Address.period'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeAddress(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAddress; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Address'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeEnum(this, 'Address', 'use', elem.UseElement, CODES_TFhirAddressUseEnum, SYSTEMS_TFhirAddressUseEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeEnum(this, 'Address', 'type', elem.Type_Element, CODES_TFhirAddressTypeEnum, SYSTEMS_TFhirAddressTypeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'Address', 'text', elem.textElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.lineList.Count - 1 do
      ComposeString(this, 'Address', 'line', elem.lineList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'Address', 'city', elem.cityElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'Address', 'district', elem.districtElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'Address', 'state', elem.stateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'Address', 'postalCode', elem.postalCodeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'Address', 'country', elem.countryElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposePeriod(this, 'Address', 'period', elem.periodElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseElementDefinitionSlicing(obj : TTurtleComplex) : TFhirElementDefinitionSlicing;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirElementDefinitionSlicing.create;
  try
    ParseElementDefinitionSlicingProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseElementDefinitionSlicingProperties(obj : TTurtleComplex; result : TFhirElementDefinitionSlicing);
var
  item : TTurtleComplex;
begin
    ParseElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/ElementDefinition.slicing.discriminator') do
      result.discriminatorList.Add(parseElementDefinitionSlicingDiscriminator(item));
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/ElementDefinition.slicing.description'));{q1}
    result.orderedElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ElementDefinition.slicing.ordered'));{q1}
    result.rulesElement := ParseEnum(obj.complex('http://hl7.org/fhir/ElementDefinition.slicing.rules'), CODES_TFhirResourceSlicingRulesEnum, SYSTEMS_TFhirResourceSlicingRulesEnum);
end;

procedure TFHIRTurtleComposer.ComposeElementDefinitionSlicing(parent :  TTurtleComplex; parentType, name : String; elem : TFhirElementDefinitionSlicing; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ElementDefinitionSlicing'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.discriminatorList.Count - 1 do
      ComposeElementDefinitionSlicingDiscriminator(this, 'ElementDefinition.slicing', 'discriminator', elem.discriminatorList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ElementDefinition.slicing', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'ElementDefinition.slicing', 'ordered', elem.orderedElement, false, -1);{x.2ea}
  ComposeEnum(this, 'ElementDefinition.slicing', 'rules', elem.RulesElement, CODES_TFhirResourceSlicingRulesEnum, SYSTEMS_TFhirResourceSlicingRulesEnum, false, -1);{x.d4}
end;

function TFHIRTurtleParser.ParseElementDefinitionSlicingDiscriminator(obj : TTurtleComplex) : TFhirElementDefinitionSlicingDiscriminator;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirElementDefinitionSlicingDiscriminator.create;
  try
    ParseElementDefinitionSlicingDiscriminatorProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseElementDefinitionSlicingDiscriminatorProperties(obj : TTurtleComplex; result : TFhirElementDefinitionSlicingDiscriminator);
begin
    ParseElementProperties(obj, result);
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/ElementDefinition.slicing.discriminator.type'), CODES_TFhirDiscriminatorTypeEnum, SYSTEMS_TFhirDiscriminatorTypeEnum);
    result.pathElement := ParseString(obj.complex('http://hl7.org/fhir/ElementDefinition.slicing.discriminator.path'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeElementDefinitionSlicingDiscriminator(parent :  TTurtleComplex; parentType, name : String; elem : TFhirElementDefinitionSlicingDiscriminator; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ElementDefinitionSlicingDiscriminator'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'ElementDefinition.slicing.discriminator', 'type', elem.Type_Element, CODES_TFhirDiscriminatorTypeEnum, SYSTEMS_TFhirDiscriminatorTypeEnum, false, -1);{x.d4}
  ComposeString(this, 'ElementDefinition.slicing.discriminator', 'path', elem.pathElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseElementDefinitionBase(obj : TTurtleComplex) : TFhirElementDefinitionBase;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirElementDefinitionBase.create;
  try
    ParseElementDefinitionBaseProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseElementDefinitionBaseProperties(obj : TTurtleComplex; result : TFhirElementDefinitionBase);
begin
    ParseElementProperties(obj, result);
    result.pathElement := ParseString(obj.complex('http://hl7.org/fhir/ElementDefinition.base.path'));{q1}
    result.minElement := ParseUnsignedInt(obj.complex('http://hl7.org/fhir/ElementDefinition.base.min'));{q1}
    result.maxElement := ParseString(obj.complex('http://hl7.org/fhir/ElementDefinition.base.max'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeElementDefinitionBase(parent :  TTurtleComplex; parentType, name : String; elem : TFhirElementDefinitionBase; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ElementDefinitionBase'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  ComposeString(this, 'ElementDefinition.base', 'path', elem.pathElement, false, -1);{x.2ea}
  ComposeUnsignedInt(this, 'ElementDefinition.base', 'min', elem.minElement, false, -1);{x.2ea}
  ComposeString(this, 'ElementDefinition.base', 'max', elem.maxElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseElementDefinitionType(obj : TTurtleComplex) : TFhirElementDefinitionType;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirElementDefinitionType.create;
  try
    ParseElementDefinitionTypeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseElementDefinitionTypeProperties(obj : TTurtleComplex; result : TFhirElementDefinitionType);
var
  item : TTurtleComplex;
begin
    ParseElementProperties(obj, result);
    result.codeElement := ParseUri(obj.complex('http://hl7.org/fhir/ElementDefinition.type.code'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ElementDefinition.type.profile') do
      result.profileList.Add(parseCanonical(item));
    for item in obj.complexes('http://hl7.org/fhir/ElementDefinition.type.targetProfile') do
      result.targetProfileList.Add(parseCanonical(item));
    for item in obj.complexes('http://hl7.org/fhir/ElementDefinition.type.aggregation') do
      result.aggregationList.Add(parseEnum(item, CODES_TFhirResourceAggregationModeEnum, SYSTEMS_TFhirResourceAggregationModeEnum));
    result.versioningElement := ParseEnum(obj.complex('http://hl7.org/fhir/ElementDefinition.type.versioning'), CODES_TFhirReferenceVersionRulesEnum, SYSTEMS_TFhirReferenceVersionRulesEnum);
end;

procedure TFHIRTurtleComposer.ComposeElementDefinitionType(parent :  TTurtleComplex; parentType, name : String; elem : TFhirElementDefinitionType; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ElementDefinitionType'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  ComposeUri(this, 'ElementDefinition.type', 'code', elem.codeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.profileList.Count - 1 do
      ComposeCanonical(this, 'ElementDefinition.type', 'profile', elem.profileList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.targetProfileList.Count - 1 do
      ComposeCanonical(this, 'ElementDefinition.type', 'targetProfile', elem.targetProfileList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.aggregationList.Count - 1 do
      ComposeEnum(this, 'ElementDefinition.type', 'aggregation', elem.aggregationList[i], CODES_TFhirResourceAggregationModeEnum, SYSTEMS_TFhirResourceAggregationModeEnum, false, i); {x.d1}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.aggregationList.Count - 1 do
      ComposeEnum(this, 'ElementDefinition.type', 'aggregation', elem.aggregationList[i], CODES_TFhirResourceAggregationModeEnum, SYSTEMS_TFhirResourceAggregationModeEnum, false, i);{x.d2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'ElementDefinition.type', 'versioning', elem.VersioningElement, CODES_TFhirReferenceVersionRulesEnum, SYSTEMS_TFhirReferenceVersionRulesEnum, false, -1);{x.d4}
end;

function TFHIRTurtleParser.ParseElementDefinitionExample(obj : TTurtleComplex) : TFhirElementDefinitionExample;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirElementDefinitionExample.create;
  try
    ParseElementDefinitionExampleProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseElementDefinitionExampleProperties(obj : TTurtleComplex; result : TFhirElementDefinitionExample);
var
  item : TTurtleComplex;
begin
    ParseElementProperties(obj, result);
    result.label_Element := ParseString(obj.complex('http://hl7.org/fhir/ElementDefinition.example.label'));{q1}
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueCanonical', item) then
      result.value := parseCanonical(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueCode', item) then
      result.value := parseCode(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueId', item) then
      result.value := parseId(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueMarkdown', item) then
      result.value := parseMarkdown(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueOid', item) then
      result.value := parseOid(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valuePositiveInt', item) then
      result.value := parsePositiveInt(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueUnsignedInt', item) then
      result.value := parseUnsignedInt(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueUrl', item) then
      result.value := parseUrl(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueUuid', item) then
      result.value := parseUuid(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueAddress', item) then
      result.value := parseAddress(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueAge', item) then
      result.value := parseAge(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueAnnotation', item) then
      result.value := parseAnnotation(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueAttachment', item) then
      result.value := parseAttachment(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueCodeableConcept', item) then
      result.value := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueCoding', item) then
      result.value := parseCoding(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueContactPoint', item) then
      result.value := parseContactPoint(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueCount', item) then
      result.value := parseCount(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueDistance', item) then
      result.value := parseDistance(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueDuration', item) then
      result.value := parseDuration(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueHumanName', item) then
      result.value := parseHumanName(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueIdentifier', item) then
      result.value := parseIdentifier(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueMoney', item) then
      result.value := parseMoney(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valuePeriod', item) then
      result.value := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueQuantity', item) then
      result.value := parseQuantity(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueRange', item) then
      result.value := parseRange(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueRatio', item) then
      result.value := parseRatio(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueReference', item) then
      result.value := parseReference(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueSampledData', item) then
      result.value := parseSampledData(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueSignature', item) then
      result.value := parseSignature(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueTiming', item) then
      result.value := parseTiming(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueContactDetail', item) then
      result.value := parseContactDetail(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueContributor', item) then
      result.value := parseContributor(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueDataRequirement', item) then
      result.value := parseDataRequirement(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueExpression', item) then
      result.value := parseExpression(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueParameterDefinition', item) then
      result.value := parseParameterDefinition(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueRelatedArtifact', item) then
      result.value := parseRelatedArtifact(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueTriggerDefinition', item) then
      result.value := parseTriggerDefinition(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueUsageContext', item) then
      result.value := parseUsageContext(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueDosage', item) then
      result.value := parseDosage(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueBase64Binary', item) then
      result.value := parseBase64Binary(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueBoolean', item) then
      result.value := parseBoolean(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueDate', item) then
      result.value := parseDate(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueDateTime', item) then
      result.value := parseDateTime(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueDecimal', item) then
      result.value := parseDecimal(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueInstant', item) then
      result.value := parseInstant(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueInteger', item) then
      result.value := parseInteger(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueString', item) then
      result.value := parseString(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueTime', item) then
      result.value := parseTime(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.example.valueUri', item) then
      result.value := parseUri(item);
end;

procedure TFHIRTurtleComposer.ComposeElementDefinitionExample(parent :  TTurtleComplex; parentType, name : String; elem : TFhirElementDefinitionExample; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ElementDefinitionExample'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  ComposeString(this, 'ElementDefinition.example', 'label', elem.label_Element, false, -1);{x.2ea}
  if (elem.value is TFhirCanonical) {6} then
    ComposeCanonical(this, 'ElementDefinition.example', 'valueCanonical', TFhirCanonical(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirCode) {6} then
    ComposeCode(this, 'ElementDefinition.example', 'valueCode', TFhirCode(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirId) {6} then
    ComposeId(this, 'ElementDefinition.example', 'valueId', TFhirId(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirMarkdown) {6} then
    ComposeMarkdown(this, 'ElementDefinition.example', 'valueMarkdown', TFhirMarkdown(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirOid) {6} then
    ComposeOid(this, 'ElementDefinition.example', 'valueOid', TFhirOid(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirPositiveInt) {6} then
    ComposePositiveInt(this, 'ElementDefinition.example', 'valuePositiveInt', TFhirPositiveInt(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(this, 'ElementDefinition.example', 'valueUnsignedInt', TFhirUnsignedInt(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirUrl) {6} then
    ComposeUrl(this, 'ElementDefinition.example', 'valueUrl', TFhirUrl(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirUuid) {6} then
    ComposeUuid(this, 'ElementDefinition.example', 'valueUuid', TFhirUuid(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirAddress) {6} then
    ComposeAddress(this, 'ElementDefinition.example', 'valueAddress', TFhirAddress(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirAge) {6} then
    ComposeAge(this, 'ElementDefinition.example', 'valueAge', TFhirAge(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirAnnotation) {6} then
    ComposeAnnotation(this, 'ElementDefinition.example', 'valueAnnotation', TFhirAnnotation(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirAttachment) {6} then
    ComposeAttachment(this, 'ElementDefinition.example', 'valueAttachment', TFhirAttachment(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'ElementDefinition.example', 'valueCodeableConcept', TFhirCodeableConcept(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirCoding) {6} then
    ComposeCoding(this, 'ElementDefinition.example', 'valueCoding', TFhirCoding(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirContactPoint) {6} then
    ComposeContactPoint(this, 'ElementDefinition.example', 'valueContactPoint', TFhirContactPoint(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirCount) {6} then
    ComposeCount(this, 'ElementDefinition.example', 'valueCount', TFhirCount(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirDistance) {6} then
    ComposeDistance(this, 'ElementDefinition.example', 'valueDistance', TFhirDistance(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirDuration) {6} then
    ComposeDuration(this, 'ElementDefinition.example', 'valueDuration', TFhirDuration(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirHumanName) {6} then
    ComposeHumanName(this, 'ElementDefinition.example', 'valueHumanName', TFhirHumanName(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirIdentifier) {6} then
    ComposeIdentifier(this, 'ElementDefinition.example', 'valueIdentifier', TFhirIdentifier(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirMoney) {6} then
    ComposeMoney(this, 'ElementDefinition.example', 'valueMoney', TFhirMoney(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirPeriod) {6} then
    ComposePeriod(this, 'ElementDefinition.example', 'valuePeriod', TFhirPeriod(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'ElementDefinition.example', 'valueQuantity', TFhirQuantity(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirRange) {6} then
    ComposeRange(this, 'ElementDefinition.example', 'valueRange', TFhirRange(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirRatio) {6} then
    ComposeRatio(this, 'ElementDefinition.example', 'valueRatio', TFhirRatio(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirReference) {6} then
    ComposeReference(this, 'ElementDefinition.example', 'valueReference', TFhirReference(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirSampledData) {6} then
    ComposeSampledData(this, 'ElementDefinition.example', 'valueSampledData', TFhirSampledData(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirSignature) {6} then
    ComposeSignature(this, 'ElementDefinition.example', 'valueSignature', TFhirSignature(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirTiming) {6} then
    ComposeTiming(this, 'ElementDefinition.example', 'valueTiming', TFhirTiming(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirContactDetail) {6} then
    ComposeContactDetail(this, 'ElementDefinition.example', 'valueContactDetail', TFhirContactDetail(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirContributor) {6} then
    ComposeContributor(this, 'ElementDefinition.example', 'valueContributor', TFhirContributor(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirDataRequirement) {6} then
    ComposeDataRequirement(this, 'ElementDefinition.example', 'valueDataRequirement', TFhirDataRequirement(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirExpression) {6} then
    ComposeExpression(this, 'ElementDefinition.example', 'valueExpression', TFhirExpression(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirParameterDefinition) {6} then
    ComposeParameterDefinition(this, 'ElementDefinition.example', 'valueParameterDefinition', TFhirParameterDefinition(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirRelatedArtifact) {6} then
    ComposeRelatedArtifact(this, 'ElementDefinition.example', 'valueRelatedArtifact', TFhirRelatedArtifact(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirTriggerDefinition) {6} then
    ComposeTriggerDefinition(this, 'ElementDefinition.example', 'valueTriggerDefinition', TFhirTriggerDefinition(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirUsageContext) {6} then
    ComposeUsageContext(this, 'ElementDefinition.example', 'valueUsageContext', TFhirUsageContext(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirDosage) {6} then
    ComposeDosage(this, 'ElementDefinition.example', 'valueDosage', TFhirDosage(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirBase64Binary) {6} then
    ComposeBase64Binary(this, 'ElementDefinition.example', 'valueBase64Binary', TFhirBase64Binary(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirBoolean) {6} then
    ComposeBoolean(this, 'ElementDefinition.example', 'valueBoolean', TFhirBoolean(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirDate) {6} then
    ComposeDate(this, 'ElementDefinition.example', 'valueDate', TFhirDate(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirDateTime) {6} then
    ComposeDateTime(this, 'ElementDefinition.example', 'valueDateTime', TFhirDateTime(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirDecimal) {6} then
    ComposeDecimal(this, 'ElementDefinition.example', 'valueDecimal', TFhirDecimal(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirInstant) {6} then
    ComposeInstant(this, 'ElementDefinition.example', 'valueInstant', TFhirInstant(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirInteger) {6} then
    ComposeInteger(this, 'ElementDefinition.example', 'valueInteger', TFhirInteger(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirString) {6} then
    ComposeString(this, 'ElementDefinition.example', 'valueString', TFhirString(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirTime) {6} then
    ComposeTime(this, 'ElementDefinition.example', 'valueTime', TFhirTime(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirUri) {6} then
    ComposeUri(this, 'ElementDefinition.example', 'valueUri', TFhirUri(elem.value), false, -1);{x.d9}
end;

function TFHIRTurtleParser.ParseElementDefinitionConstraint(obj : TTurtleComplex) : TFhirElementDefinitionConstraint;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirElementDefinitionConstraint.create;
  try
    ParseElementDefinitionConstraintProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseElementDefinitionConstraintProperties(obj : TTurtleComplex; result : TFhirElementDefinitionConstraint);
begin
    ParseElementProperties(obj, result);
    result.keyElement := ParseId(obj.complex('http://hl7.org/fhir/ElementDefinition.constraint.key'));{q1}
    result.requirementsElement := ParseString(obj.complex('http://hl7.org/fhir/ElementDefinition.constraint.requirements'));{q1}
    result.severityElement := ParseEnum(obj.complex('http://hl7.org/fhir/ElementDefinition.constraint.severity'), CODES_TFhirConstraintSeverityEnum, SYSTEMS_TFhirConstraintSeverityEnum);
    result.humanElement := ParseString(obj.complex('http://hl7.org/fhir/ElementDefinition.constraint.human'));{q1}
    result.expressionElement := ParseString(obj.complex('http://hl7.org/fhir/ElementDefinition.constraint.expression'));{q1}
    result.xpathElement := ParseString(obj.complex('http://hl7.org/fhir/ElementDefinition.constraint.xpath'));{q1}
    result.sourceElement := ParseCanonical(obj.complex('http://hl7.org/fhir/ElementDefinition.constraint.source'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeElementDefinitionConstraint(parent :  TTurtleComplex; parentType, name : String; elem : TFhirElementDefinitionConstraint; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ElementDefinitionConstraint'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  ComposeId(this, 'ElementDefinition.constraint', 'key', elem.keyElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ElementDefinition.constraint', 'requirements', elem.requirementsElement, false, -1);{x.2ea}
  ComposeEnum(this, 'ElementDefinition.constraint', 'severity', elem.SeverityElement, CODES_TFhirConstraintSeverityEnum, SYSTEMS_TFhirConstraintSeverityEnum, false, -1);{x.d4}
  ComposeString(this, 'ElementDefinition.constraint', 'human', elem.humanElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ElementDefinition.constraint', 'expression', elem.expressionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ElementDefinition.constraint', 'xpath', elem.xpathElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCanonical(this, 'ElementDefinition.constraint', 'source', elem.sourceElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseElementDefinitionBinding(obj : TTurtleComplex) : TFhirElementDefinitionBinding;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirElementDefinitionBinding.create;
  try
    ParseElementDefinitionBindingProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseElementDefinitionBindingProperties(obj : TTurtleComplex; result : TFhirElementDefinitionBinding);
begin
    ParseElementProperties(obj, result);
    result.strengthElement := ParseEnum(obj.complex('http://hl7.org/fhir/ElementDefinition.binding.strength'), CODES_TFhirBindingStrengthEnum, SYSTEMS_TFhirBindingStrengthEnum);
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/ElementDefinition.binding.description'));{q1}
    result.valueSetElement := ParseCanonical(obj.complex('http://hl7.org/fhir/ElementDefinition.binding.valueSet'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeElementDefinitionBinding(parent :  TTurtleComplex; parentType, name : String; elem : TFhirElementDefinitionBinding; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ElementDefinitionBinding'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'ElementDefinition.binding', 'strength', elem.StrengthElement, CODES_TFhirBindingStrengthEnum, SYSTEMS_TFhirBindingStrengthEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ElementDefinition.binding', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCanonical(this, 'ElementDefinition.binding', 'valueSet', elem.valueSetElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseElementDefinitionMapping(obj : TTurtleComplex) : TFhirElementDefinitionMapping;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirElementDefinitionMapping.create;
  try
    ParseElementDefinitionMappingProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseElementDefinitionMappingProperties(obj : TTurtleComplex; result : TFhirElementDefinitionMapping);
begin
    ParseElementProperties(obj, result);
    result.identityElement := ParseId(obj.complex('http://hl7.org/fhir/ElementDefinition.mapping.identity'));{q1}
    result.languageElement := ParseCode(obj.complex('http://hl7.org/fhir/ElementDefinition.mapping.language'));{q1}
    result.mapElement := ParseString(obj.complex('http://hl7.org/fhir/ElementDefinition.mapping.map'));{q1}
    result.commentElement := ParseString(obj.complex('http://hl7.org/fhir/ElementDefinition.mapping.comment'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeElementDefinitionMapping(parent :  TTurtleComplex; parentType, name : String; elem : TFhirElementDefinitionMapping; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ElementDefinitionMapping'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  ComposeId(this, 'ElementDefinition.mapping', 'identity', elem.identityElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCode(this, 'ElementDefinition.mapping', 'language', elem.languageElement, false, -1);{x.2ea}
  ComposeString(this, 'ElementDefinition.mapping', 'map', elem.mapElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ElementDefinition.mapping', 'comment', elem.commentElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseElementDefinition(obj : TTurtleComplex) : TFhirElementDefinition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirElementDefinition.create;
  try
    ParseElementDefinitionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseElementDefinitionProperties(obj : TTurtleComplex; result : TFhirElementDefinition);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.pathElement := ParseString(obj.complex('http://hl7.org/fhir/ElementDefinition.path'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ElementDefinition.representation') do
      result.representationList.Add(parseEnum(item, CODES_TFhirPropertyRepresentationEnum, SYSTEMS_TFhirPropertyRepresentationEnum));
    result.sliceNameElement := ParseString(obj.complex('http://hl7.org/fhir/ElementDefinition.sliceName'));{q1}
    result.sliceIsConstrainingElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ElementDefinition.sliceIsConstraining'));{q1}
    result.label_Element := ParseString(obj.complex('http://hl7.org/fhir/ElementDefinition.label'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ElementDefinition.code') do
      result.codeList.Add(parseCoding(item));
    result.slicing := ParseElementDefinitionSlicing(obj.complex('http://hl7.org/fhir/ElementDefinition.slicing'));{q3b}
    result.shortElement := ParseString(obj.complex('http://hl7.org/fhir/ElementDefinition.short'));{q1}
    result.definitionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ElementDefinition.definition'));{q1}
    result.commentElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ElementDefinition.comment'));{q1}
    result.requirementsElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ElementDefinition.requirements'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ElementDefinition.alias') do
      result.aliasList.Add(parseString(item));
    result.minElement := ParseUnsignedInt(obj.complex('http://hl7.org/fhir/ElementDefinition.min'));{q1}
    result.maxElement := ParseString(obj.complex('http://hl7.org/fhir/ElementDefinition.max'));{q1}
    result.base := ParseElementDefinitionBase(obj.complex('http://hl7.org/fhir/ElementDefinition.base'));{q3b}
    result.contentReferenceElement := ParseUri(obj.complex('http://hl7.org/fhir/ElementDefinition.contentReference'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ElementDefinition.type') do
      result.type_List.Add(parseElementDefinitionType(item));
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueCanonical', item) then
      result.defaultValue := parseCanonical(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueCode', item) then
      result.defaultValue := parseCode(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueId', item) then
      result.defaultValue := parseId(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueMarkdown', item) then
      result.defaultValue := parseMarkdown(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueOid', item) then
      result.defaultValue := parseOid(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValuePositiveInt', item) then
      result.defaultValue := parsePositiveInt(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueUnsignedInt', item) then
      result.defaultValue := parseUnsignedInt(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueUrl', item) then
      result.defaultValue := parseUrl(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueUuid', item) then
      result.defaultValue := parseUuid(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueAddress', item) then
      result.defaultValue := parseAddress(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueAge', item) then
      result.defaultValue := parseAge(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueAnnotation', item) then
      result.defaultValue := parseAnnotation(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueAttachment', item) then
      result.defaultValue := parseAttachment(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueCodeableConcept', item) then
      result.defaultValue := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueCoding', item) then
      result.defaultValue := parseCoding(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueContactPoint', item) then
      result.defaultValue := parseContactPoint(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueCount', item) then
      result.defaultValue := parseCount(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueDistance', item) then
      result.defaultValue := parseDistance(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueDuration', item) then
      result.defaultValue := parseDuration(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueHumanName', item) then
      result.defaultValue := parseHumanName(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueIdentifier', item) then
      result.defaultValue := parseIdentifier(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueMoney', item) then
      result.defaultValue := parseMoney(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValuePeriod', item) then
      result.defaultValue := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueQuantity', item) then
      result.defaultValue := parseQuantity(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueRange', item) then
      result.defaultValue := parseRange(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueRatio', item) then
      result.defaultValue := parseRatio(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueReference', item) then
      result.defaultValue := parseReference(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueSampledData', item) then
      result.defaultValue := parseSampledData(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueSignature', item) then
      result.defaultValue := parseSignature(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueTiming', item) then
      result.defaultValue := parseTiming(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueContactDetail', item) then
      result.defaultValue := parseContactDetail(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueContributor', item) then
      result.defaultValue := parseContributor(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueDataRequirement', item) then
      result.defaultValue := parseDataRequirement(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueExpression', item) then
      result.defaultValue := parseExpression(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueParameterDefinition', item) then
      result.defaultValue := parseParameterDefinition(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueRelatedArtifact', item) then
      result.defaultValue := parseRelatedArtifact(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueTriggerDefinition', item) then
      result.defaultValue := parseTriggerDefinition(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueUsageContext', item) then
      result.defaultValue := parseUsageContext(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueDosage', item) then
      result.defaultValue := parseDosage(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueBase64Binary', item) then
      result.defaultValue := parseBase64Binary(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueBoolean', item) then
      result.defaultValue := parseBoolean(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueDate', item) then
      result.defaultValue := parseDate(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueDateTime', item) then
      result.defaultValue := parseDateTime(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueDecimal', item) then
      result.defaultValue := parseDecimal(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueInstant', item) then
      result.defaultValue := parseInstant(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueInteger', item) then
      result.defaultValue := parseInteger(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueString', item) then
      result.defaultValue := parseString(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueTime', item) then
      result.defaultValue := parseTime(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.defaultValueUri', item) then
      result.defaultValue := parseUri(item);
    result.meaningWhenMissingElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ElementDefinition.meaningWhenMissing'));{q1}
    result.orderMeaningElement := ParseString(obj.complex('http://hl7.org/fhir/ElementDefinition.orderMeaning'));{q1}
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedCanonical', item) then
      result.fixed := parseCanonical(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedCode', item) then
      result.fixed := parseCode(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedId', item) then
      result.fixed := parseId(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedMarkdown', item) then
      result.fixed := parseMarkdown(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedOid', item) then
      result.fixed := parseOid(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedPositiveInt', item) then
      result.fixed := parsePositiveInt(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedUnsignedInt', item) then
      result.fixed := parseUnsignedInt(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedUrl', item) then
      result.fixed := parseUrl(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedUuid', item) then
      result.fixed := parseUuid(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedAddress', item) then
      result.fixed := parseAddress(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedAge', item) then
      result.fixed := parseAge(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedAnnotation', item) then
      result.fixed := parseAnnotation(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedAttachment', item) then
      result.fixed := parseAttachment(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedCodeableConcept', item) then
      result.fixed := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedCoding', item) then
      result.fixed := parseCoding(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedContactPoint', item) then
      result.fixed := parseContactPoint(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedCount', item) then
      result.fixed := parseCount(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedDistance', item) then
      result.fixed := parseDistance(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedDuration', item) then
      result.fixed := parseDuration(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedHumanName', item) then
      result.fixed := parseHumanName(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedIdentifier', item) then
      result.fixed := parseIdentifier(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedMoney', item) then
      result.fixed := parseMoney(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedPeriod', item) then
      result.fixed := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedQuantity', item) then
      result.fixed := parseQuantity(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedRange', item) then
      result.fixed := parseRange(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedRatio', item) then
      result.fixed := parseRatio(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedReference', item) then
      result.fixed := parseReference(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedSampledData', item) then
      result.fixed := parseSampledData(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedSignature', item) then
      result.fixed := parseSignature(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedTiming', item) then
      result.fixed := parseTiming(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedContactDetail', item) then
      result.fixed := parseContactDetail(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedContributor', item) then
      result.fixed := parseContributor(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedDataRequirement', item) then
      result.fixed := parseDataRequirement(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedExpression', item) then
      result.fixed := parseExpression(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedParameterDefinition', item) then
      result.fixed := parseParameterDefinition(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedRelatedArtifact', item) then
      result.fixed := parseRelatedArtifact(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedTriggerDefinition', item) then
      result.fixed := parseTriggerDefinition(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedUsageContext', item) then
      result.fixed := parseUsageContext(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedDosage', item) then
      result.fixed := parseDosage(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedBase64Binary', item) then
      result.fixed := parseBase64Binary(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedBoolean', item) then
      result.fixed := parseBoolean(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedDate', item) then
      result.fixed := parseDate(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedDateTime', item) then
      result.fixed := parseDateTime(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedDecimal', item) then
      result.fixed := parseDecimal(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedInstant', item) then
      result.fixed := parseInstant(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedInteger', item) then
      result.fixed := parseInteger(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedString', item) then
      result.fixed := parseString(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedTime', item) then
      result.fixed := parseTime(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.fixedUri', item) then
      result.fixed := parseUri(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternCanonical', item) then
      result.pattern := parseCanonical(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternCode', item) then
      result.pattern := parseCode(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternId', item) then
      result.pattern := parseId(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternMarkdown', item) then
      result.pattern := parseMarkdown(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternOid', item) then
      result.pattern := parseOid(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternPositiveInt', item) then
      result.pattern := parsePositiveInt(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternUnsignedInt', item) then
      result.pattern := parseUnsignedInt(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternUrl', item) then
      result.pattern := parseUrl(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternUuid', item) then
      result.pattern := parseUuid(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternAddress', item) then
      result.pattern := parseAddress(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternAge', item) then
      result.pattern := parseAge(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternAnnotation', item) then
      result.pattern := parseAnnotation(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternAttachment', item) then
      result.pattern := parseAttachment(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternCodeableConcept', item) then
      result.pattern := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternCoding', item) then
      result.pattern := parseCoding(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternContactPoint', item) then
      result.pattern := parseContactPoint(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternCount', item) then
      result.pattern := parseCount(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternDistance', item) then
      result.pattern := parseDistance(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternDuration', item) then
      result.pattern := parseDuration(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternHumanName', item) then
      result.pattern := parseHumanName(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternIdentifier', item) then
      result.pattern := parseIdentifier(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternMoney', item) then
      result.pattern := parseMoney(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternPeriod', item) then
      result.pattern := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternQuantity', item) then
      result.pattern := parseQuantity(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternRange', item) then
      result.pattern := parseRange(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternRatio', item) then
      result.pattern := parseRatio(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternReference', item) then
      result.pattern := parseReference(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternSampledData', item) then
      result.pattern := parseSampledData(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternSignature', item) then
      result.pattern := parseSignature(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternTiming', item) then
      result.pattern := parseTiming(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternContactDetail', item) then
      result.pattern := parseContactDetail(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternContributor', item) then
      result.pattern := parseContributor(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternDataRequirement', item) then
      result.pattern := parseDataRequirement(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternExpression', item) then
      result.pattern := parseExpression(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternParameterDefinition', item) then
      result.pattern := parseParameterDefinition(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternRelatedArtifact', item) then
      result.pattern := parseRelatedArtifact(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternTriggerDefinition', item) then
      result.pattern := parseTriggerDefinition(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternUsageContext', item) then
      result.pattern := parseUsageContext(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternDosage', item) then
      result.pattern := parseDosage(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternBase64Binary', item) then
      result.pattern := parseBase64Binary(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternBoolean', item) then
      result.pattern := parseBoolean(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternDate', item) then
      result.pattern := parseDate(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternDateTime', item) then
      result.pattern := parseDateTime(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternDecimal', item) then
      result.pattern := parseDecimal(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternInstant', item) then
      result.pattern := parseInstant(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternInteger', item) then
      result.pattern := parseInteger(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternString', item) then
      result.pattern := parseString(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternTime', item) then
      result.pattern := parseTime(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.patternUri', item) then
      result.pattern := parseUri(item);
    for item in obj.complexes('http://hl7.org/fhir/ElementDefinition.example') do
      result.exampleList.Add(parseElementDefinitionExample(item));
    if obj.has('http://hl7.org/fhir/ElementDefinition.minValuePositiveInt', item) then
      result.minValue := parsePositiveInt(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.minValueUnsignedInt', item) then
      result.minValue := parseUnsignedInt(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.minValueQuantity', item) then
      result.minValue := parseQuantity(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.minValueDate', item) then
      result.minValue := parseDate(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.minValueDateTime', item) then
      result.minValue := parseDateTime(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.minValueInstant', item) then
      result.minValue := parseInstant(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.minValueTime', item) then
      result.minValue := parseTime(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.minValueDecimal', item) then
      result.minValue := parseDecimal(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.minValueInteger', item) then
      result.minValue := parseInteger(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.maxValuePositiveInt', item) then
      result.maxValue := parsePositiveInt(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.maxValueUnsignedInt', item) then
      result.maxValue := parseUnsignedInt(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.maxValueQuantity', item) then
      result.maxValue := parseQuantity(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.maxValueDate', item) then
      result.maxValue := parseDate(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.maxValueDateTime', item) then
      result.maxValue := parseDateTime(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.maxValueInstant', item) then
      result.maxValue := parseInstant(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.maxValueTime', item) then
      result.maxValue := parseTime(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.maxValueDecimal', item) then
      result.maxValue := parseDecimal(item);
    if obj.has('http://hl7.org/fhir/ElementDefinition.maxValueInteger', item) then
      result.maxValue := parseInteger(item);
    result.maxLengthElement := ParseInteger(obj.complex('http://hl7.org/fhir/ElementDefinition.maxLength'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ElementDefinition.condition') do
      result.conditionList.Add(parseId(item));
    for item in obj.complexes('http://hl7.org/fhir/ElementDefinition.constraint') do
      result.constraintList.Add(parseElementDefinitionConstraint(item));
    result.mustSupportElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ElementDefinition.mustSupport'));{q1}
    result.isModifierElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ElementDefinition.isModifier'));{q1}
    result.isModifierReasonElement := ParseString(obj.complex('http://hl7.org/fhir/ElementDefinition.isModifierReason'));{q1}
    result.isSummaryElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ElementDefinition.isSummary'));{q1}
    result.binding := ParseElementDefinitionBinding(obj.complex('http://hl7.org/fhir/ElementDefinition.binding'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ElementDefinition.mapping') do
      result.mappingList.Add(parseElementDefinitionMapping(item));
end;

procedure TFHIRTurtleComposer.ComposeElementDefinition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirElementDefinition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ElementDefinition'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  ComposeString(this, 'ElementDefinition', 'path', elem.pathElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.representationList.Count - 1 do
      ComposeEnum(this, 'ElementDefinition', 'representation', elem.representationList[i], CODES_TFhirPropertyRepresentationEnum, SYSTEMS_TFhirPropertyRepresentationEnum, false, i); {x.d1}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.representationList.Count - 1 do
      ComposeEnum(this, 'ElementDefinition', 'representation', elem.representationList[i], CODES_TFhirPropertyRepresentationEnum, SYSTEMS_TFhirPropertyRepresentationEnum, false, i);{x.d2}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'ElementDefinition', 'sliceName', elem.sliceNameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBoolean(this, 'ElementDefinition', 'sliceIsConstraining', elem.sliceIsConstrainingElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'ElementDefinition', 'label', elem.label_Element, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.codeList.Count - 1 do
      ComposeCoding(this, 'ElementDefinition', 'code', elem.codeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeElementDefinitionSlicing(this, 'ElementDefinition', 'slicing', elem.slicingElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'ElementDefinition', 'short', elem.shortElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeMarkdown(this, 'ElementDefinition', 'definition', elem.definitionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeMarkdown(this, 'ElementDefinition', 'comment', elem.commentElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeMarkdown(this, 'ElementDefinition', 'requirements', elem.requirementsElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.aliasList.Count - 1 do
      ComposeString(this, 'ElementDefinition', 'alias', elem.aliasList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUnsignedInt(this, 'ElementDefinition', 'min', elem.minElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'ElementDefinition', 'max', elem.maxElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeElementDefinitionBase(this, 'ElementDefinition', 'base', elem.baseElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUri(this, 'ElementDefinition', 'contentReference', elem.contentReferenceElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeElementDefinitionType(this, 'ElementDefinition', 'type', elem.type_List[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirCanonical) {6} then
    ComposeCanonical(this, 'ElementDefinition', 'defaultValueCanonical', TFhirCanonical(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirCode) {6} then
    ComposeCode(this, 'ElementDefinition', 'defaultValueCode', TFhirCode(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirId) {6} then
    ComposeId(this, 'ElementDefinition', 'defaultValueId', TFhirId(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirMarkdown) {6} then
    ComposeMarkdown(this, 'ElementDefinition', 'defaultValueMarkdown', TFhirMarkdown(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirOid) {6} then
    ComposeOid(this, 'ElementDefinition', 'defaultValueOid', TFhirOid(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirPositiveInt) {6} then
    ComposePositiveInt(this, 'ElementDefinition', 'defaultValuePositiveInt', TFhirPositiveInt(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(this, 'ElementDefinition', 'defaultValueUnsignedInt', TFhirUnsignedInt(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirUrl) {6} then
    ComposeUrl(this, 'ElementDefinition', 'defaultValueUrl', TFhirUrl(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirUuid) {6} then
    ComposeUuid(this, 'ElementDefinition', 'defaultValueUuid', TFhirUuid(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirAddress) {6} then
    ComposeAddress(this, 'ElementDefinition', 'defaultValueAddress', TFhirAddress(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirAge) {6} then
    ComposeAge(this, 'ElementDefinition', 'defaultValueAge', TFhirAge(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirAnnotation) {6} then
    ComposeAnnotation(this, 'ElementDefinition', 'defaultValueAnnotation', TFhirAnnotation(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirAttachment) {6} then
    ComposeAttachment(this, 'ElementDefinition', 'defaultValueAttachment', TFhirAttachment(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'ElementDefinition', 'defaultValueCodeableConcept', TFhirCodeableConcept(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirCoding) {6} then
    ComposeCoding(this, 'ElementDefinition', 'defaultValueCoding', TFhirCoding(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirContactPoint) {6} then
    ComposeContactPoint(this, 'ElementDefinition', 'defaultValueContactPoint', TFhirContactPoint(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirCount) {6} then
    ComposeCount(this, 'ElementDefinition', 'defaultValueCount', TFhirCount(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirDistance) {6} then
    ComposeDistance(this, 'ElementDefinition', 'defaultValueDistance', TFhirDistance(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirDuration) {6} then
    ComposeDuration(this, 'ElementDefinition', 'defaultValueDuration', TFhirDuration(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirHumanName) {6} then
    ComposeHumanName(this, 'ElementDefinition', 'defaultValueHumanName', TFhirHumanName(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirIdentifier) {6} then
    ComposeIdentifier(this, 'ElementDefinition', 'defaultValueIdentifier', TFhirIdentifier(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirMoney) {6} then
    ComposeMoney(this, 'ElementDefinition', 'defaultValueMoney', TFhirMoney(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirPeriod) {6} then
    ComposePeriod(this, 'ElementDefinition', 'defaultValuePeriod', TFhirPeriod(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirQuantity) {6} then
    ComposeQuantity(this, 'ElementDefinition', 'defaultValueQuantity', TFhirQuantity(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirRange) {6} then
    ComposeRange(this, 'ElementDefinition', 'defaultValueRange', TFhirRange(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirRatio) {6} then
    ComposeRatio(this, 'ElementDefinition', 'defaultValueRatio', TFhirRatio(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirReference) {6} then
    ComposeReference(this, 'ElementDefinition', 'defaultValueReference', TFhirReference(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirSampledData) {6} then
    ComposeSampledData(this, 'ElementDefinition', 'defaultValueSampledData', TFhirSampledData(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirSignature) {6} then
    ComposeSignature(this, 'ElementDefinition', 'defaultValueSignature', TFhirSignature(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirTiming) {6} then
    ComposeTiming(this, 'ElementDefinition', 'defaultValueTiming', TFhirTiming(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirContactDetail) {6} then
    ComposeContactDetail(this, 'ElementDefinition', 'defaultValueContactDetail', TFhirContactDetail(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirContributor) {6} then
    ComposeContributor(this, 'ElementDefinition', 'defaultValueContributor', TFhirContributor(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirDataRequirement) {6} then
    ComposeDataRequirement(this, 'ElementDefinition', 'defaultValueDataRequirement', TFhirDataRequirement(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirExpression) {6} then
    ComposeExpression(this, 'ElementDefinition', 'defaultValueExpression', TFhirExpression(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirParameterDefinition) {6} then
    ComposeParameterDefinition(this, 'ElementDefinition', 'defaultValueParameterDefinition', TFhirParameterDefinition(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirRelatedArtifact) {6} then
    ComposeRelatedArtifact(this, 'ElementDefinition', 'defaultValueRelatedArtifact', TFhirRelatedArtifact(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirTriggerDefinition) {6} then
    ComposeTriggerDefinition(this, 'ElementDefinition', 'defaultValueTriggerDefinition', TFhirTriggerDefinition(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirUsageContext) {6} then
    ComposeUsageContext(this, 'ElementDefinition', 'defaultValueUsageContext', TFhirUsageContext(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirDosage) {6} then
    ComposeDosage(this, 'ElementDefinition', 'defaultValueDosage', TFhirDosage(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirBase64Binary) {6} then
    ComposeBase64Binary(this, 'ElementDefinition', 'defaultValueBase64Binary', TFhirBase64Binary(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirBoolean) {6} then
    ComposeBoolean(this, 'ElementDefinition', 'defaultValueBoolean', TFhirBoolean(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirDate) {6} then
    ComposeDate(this, 'ElementDefinition', 'defaultValueDate', TFhirDate(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirDateTime) {6} then
    ComposeDateTime(this, 'ElementDefinition', 'defaultValueDateTime', TFhirDateTime(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirDecimal) {6} then
    ComposeDecimal(this, 'ElementDefinition', 'defaultValueDecimal', TFhirDecimal(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirInstant) {6} then
    ComposeInstant(this, 'ElementDefinition', 'defaultValueInstant', TFhirInstant(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirInteger) {6} then
    ComposeInteger(this, 'ElementDefinition', 'defaultValueInteger', TFhirInteger(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirString) {6} then
    ComposeString(this, 'ElementDefinition', 'defaultValueString', TFhirString(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirTime) {6} then
    ComposeTime(this, 'ElementDefinition', 'defaultValueTime', TFhirTime(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirUri) {6} then
    ComposeUri(this, 'ElementDefinition', 'defaultValueUri', TFhirUri(elem.defaultValue), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeMarkdown(this, 'ElementDefinition', 'meaningWhenMissing', elem.meaningWhenMissingElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'ElementDefinition', 'orderMeaning', elem.orderMeaningElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirCanonical) {6} then
    ComposeCanonical(this, 'ElementDefinition', 'fixedCanonical', TFhirCanonical(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirCode) {6} then
    ComposeCode(this, 'ElementDefinition', 'fixedCode', TFhirCode(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirId) {6} then
    ComposeId(this, 'ElementDefinition', 'fixedId', TFhirId(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirMarkdown) {6} then
    ComposeMarkdown(this, 'ElementDefinition', 'fixedMarkdown', TFhirMarkdown(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirOid) {6} then
    ComposeOid(this, 'ElementDefinition', 'fixedOid', TFhirOid(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirPositiveInt) {6} then
    ComposePositiveInt(this, 'ElementDefinition', 'fixedPositiveInt', TFhirPositiveInt(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(this, 'ElementDefinition', 'fixedUnsignedInt', TFhirUnsignedInt(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirUrl) {6} then
    ComposeUrl(this, 'ElementDefinition', 'fixedUrl', TFhirUrl(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirUuid) {6} then
    ComposeUuid(this, 'ElementDefinition', 'fixedUuid', TFhirUuid(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirAddress) {6} then
    ComposeAddress(this, 'ElementDefinition', 'fixedAddress', TFhirAddress(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirAge) {6} then
    ComposeAge(this, 'ElementDefinition', 'fixedAge', TFhirAge(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirAnnotation) {6} then
    ComposeAnnotation(this, 'ElementDefinition', 'fixedAnnotation', TFhirAnnotation(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirAttachment) {6} then
    ComposeAttachment(this, 'ElementDefinition', 'fixedAttachment', TFhirAttachment(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'ElementDefinition', 'fixedCodeableConcept', TFhirCodeableConcept(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirCoding) {6} then
    ComposeCoding(this, 'ElementDefinition', 'fixedCoding', TFhirCoding(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirContactPoint) {6} then
    ComposeContactPoint(this, 'ElementDefinition', 'fixedContactPoint', TFhirContactPoint(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirCount) {6} then
    ComposeCount(this, 'ElementDefinition', 'fixedCount', TFhirCount(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirDistance) {6} then
    ComposeDistance(this, 'ElementDefinition', 'fixedDistance', TFhirDistance(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirDuration) {6} then
    ComposeDuration(this, 'ElementDefinition', 'fixedDuration', TFhirDuration(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirHumanName) {6} then
    ComposeHumanName(this, 'ElementDefinition', 'fixedHumanName', TFhirHumanName(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirIdentifier) {6} then
    ComposeIdentifier(this, 'ElementDefinition', 'fixedIdentifier', TFhirIdentifier(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirMoney) {6} then
    ComposeMoney(this, 'ElementDefinition', 'fixedMoney', TFhirMoney(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirPeriod) {6} then
    ComposePeriod(this, 'ElementDefinition', 'fixedPeriod', TFhirPeriod(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirQuantity) {6} then
    ComposeQuantity(this, 'ElementDefinition', 'fixedQuantity', TFhirQuantity(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirRange) {6} then
    ComposeRange(this, 'ElementDefinition', 'fixedRange', TFhirRange(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirRatio) {6} then
    ComposeRatio(this, 'ElementDefinition', 'fixedRatio', TFhirRatio(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirReference) {6} then
    ComposeReference(this, 'ElementDefinition', 'fixedReference', TFhirReference(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirSampledData) {6} then
    ComposeSampledData(this, 'ElementDefinition', 'fixedSampledData', TFhirSampledData(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirSignature) {6} then
    ComposeSignature(this, 'ElementDefinition', 'fixedSignature', TFhirSignature(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirTiming) {6} then
    ComposeTiming(this, 'ElementDefinition', 'fixedTiming', TFhirTiming(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirContactDetail) {6} then
    ComposeContactDetail(this, 'ElementDefinition', 'fixedContactDetail', TFhirContactDetail(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirContributor) {6} then
    ComposeContributor(this, 'ElementDefinition', 'fixedContributor', TFhirContributor(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirDataRequirement) {6} then
    ComposeDataRequirement(this, 'ElementDefinition', 'fixedDataRequirement', TFhirDataRequirement(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirExpression) {6} then
    ComposeExpression(this, 'ElementDefinition', 'fixedExpression', TFhirExpression(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirParameterDefinition) {6} then
    ComposeParameterDefinition(this, 'ElementDefinition', 'fixedParameterDefinition', TFhirParameterDefinition(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirRelatedArtifact) {6} then
    ComposeRelatedArtifact(this, 'ElementDefinition', 'fixedRelatedArtifact', TFhirRelatedArtifact(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirTriggerDefinition) {6} then
    ComposeTriggerDefinition(this, 'ElementDefinition', 'fixedTriggerDefinition', TFhirTriggerDefinition(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirUsageContext) {6} then
    ComposeUsageContext(this, 'ElementDefinition', 'fixedUsageContext', TFhirUsageContext(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirDosage) {6} then
    ComposeDosage(this, 'ElementDefinition', 'fixedDosage', TFhirDosage(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirBase64Binary) {6} then
    ComposeBase64Binary(this, 'ElementDefinition', 'fixedBase64Binary', TFhirBase64Binary(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirBoolean) {6} then
    ComposeBoolean(this, 'ElementDefinition', 'fixedBoolean', TFhirBoolean(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirDate) {6} then
    ComposeDate(this, 'ElementDefinition', 'fixedDate', TFhirDate(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirDateTime) {6} then
    ComposeDateTime(this, 'ElementDefinition', 'fixedDateTime', TFhirDateTime(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirDecimal) {6} then
    ComposeDecimal(this, 'ElementDefinition', 'fixedDecimal', TFhirDecimal(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirInstant) {6} then
    ComposeInstant(this, 'ElementDefinition', 'fixedInstant', TFhirInstant(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirInteger) {6} then
    ComposeInteger(this, 'ElementDefinition', 'fixedInteger', TFhirInteger(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirString) {6} then
    ComposeString(this, 'ElementDefinition', 'fixedString', TFhirString(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirTime) {6} then
    ComposeTime(this, 'ElementDefinition', 'fixedTime', TFhirTime(elem.fixed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirUri) {6} then
    ComposeUri(this, 'ElementDefinition', 'fixedUri', TFhirUri(elem.fixed), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirCanonical) {6} then
    ComposeCanonical(this, 'ElementDefinition', 'patternCanonical', TFhirCanonical(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirCode) {6} then
    ComposeCode(this, 'ElementDefinition', 'patternCode', TFhirCode(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirId) {6} then
    ComposeId(this, 'ElementDefinition', 'patternId', TFhirId(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirMarkdown) {6} then
    ComposeMarkdown(this, 'ElementDefinition', 'patternMarkdown', TFhirMarkdown(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirOid) {6} then
    ComposeOid(this, 'ElementDefinition', 'patternOid', TFhirOid(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirPositiveInt) {6} then
    ComposePositiveInt(this, 'ElementDefinition', 'patternPositiveInt', TFhirPositiveInt(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(this, 'ElementDefinition', 'patternUnsignedInt', TFhirUnsignedInt(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirUrl) {6} then
    ComposeUrl(this, 'ElementDefinition', 'patternUrl', TFhirUrl(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirUuid) {6} then
    ComposeUuid(this, 'ElementDefinition', 'patternUuid', TFhirUuid(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirAddress) {6} then
    ComposeAddress(this, 'ElementDefinition', 'patternAddress', TFhirAddress(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirAge) {6} then
    ComposeAge(this, 'ElementDefinition', 'patternAge', TFhirAge(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirAnnotation) {6} then
    ComposeAnnotation(this, 'ElementDefinition', 'patternAnnotation', TFhirAnnotation(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirAttachment) {6} then
    ComposeAttachment(this, 'ElementDefinition', 'patternAttachment', TFhirAttachment(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'ElementDefinition', 'patternCodeableConcept', TFhirCodeableConcept(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirCoding) {6} then
    ComposeCoding(this, 'ElementDefinition', 'patternCoding', TFhirCoding(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirContactPoint) {6} then
    ComposeContactPoint(this, 'ElementDefinition', 'patternContactPoint', TFhirContactPoint(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirCount) {6} then
    ComposeCount(this, 'ElementDefinition', 'patternCount', TFhirCount(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirDistance) {6} then
    ComposeDistance(this, 'ElementDefinition', 'patternDistance', TFhirDistance(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirDuration) {6} then
    ComposeDuration(this, 'ElementDefinition', 'patternDuration', TFhirDuration(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirHumanName) {6} then
    ComposeHumanName(this, 'ElementDefinition', 'patternHumanName', TFhirHumanName(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirIdentifier) {6} then
    ComposeIdentifier(this, 'ElementDefinition', 'patternIdentifier', TFhirIdentifier(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirMoney) {6} then
    ComposeMoney(this, 'ElementDefinition', 'patternMoney', TFhirMoney(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirPeriod) {6} then
    ComposePeriod(this, 'ElementDefinition', 'patternPeriod', TFhirPeriod(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirQuantity) {6} then
    ComposeQuantity(this, 'ElementDefinition', 'patternQuantity', TFhirQuantity(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirRange) {6} then
    ComposeRange(this, 'ElementDefinition', 'patternRange', TFhirRange(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirRatio) {6} then
    ComposeRatio(this, 'ElementDefinition', 'patternRatio', TFhirRatio(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirReference) {6} then
    ComposeReference(this, 'ElementDefinition', 'patternReference', TFhirReference(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirSampledData) {6} then
    ComposeSampledData(this, 'ElementDefinition', 'patternSampledData', TFhirSampledData(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirSignature) {6} then
    ComposeSignature(this, 'ElementDefinition', 'patternSignature', TFhirSignature(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirTiming) {6} then
    ComposeTiming(this, 'ElementDefinition', 'patternTiming', TFhirTiming(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirContactDetail) {6} then
    ComposeContactDetail(this, 'ElementDefinition', 'patternContactDetail', TFhirContactDetail(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirContributor) {6} then
    ComposeContributor(this, 'ElementDefinition', 'patternContributor', TFhirContributor(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirDataRequirement) {6} then
    ComposeDataRequirement(this, 'ElementDefinition', 'patternDataRequirement', TFhirDataRequirement(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirExpression) {6} then
    ComposeExpression(this, 'ElementDefinition', 'patternExpression', TFhirExpression(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirParameterDefinition) {6} then
    ComposeParameterDefinition(this, 'ElementDefinition', 'patternParameterDefinition', TFhirParameterDefinition(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirRelatedArtifact) {6} then
    ComposeRelatedArtifact(this, 'ElementDefinition', 'patternRelatedArtifact', TFhirRelatedArtifact(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirTriggerDefinition) {6} then
    ComposeTriggerDefinition(this, 'ElementDefinition', 'patternTriggerDefinition', TFhirTriggerDefinition(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirUsageContext) {6} then
    ComposeUsageContext(this, 'ElementDefinition', 'patternUsageContext', TFhirUsageContext(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirDosage) {6} then
    ComposeDosage(this, 'ElementDefinition', 'patternDosage', TFhirDosage(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirBase64Binary) {6} then
    ComposeBase64Binary(this, 'ElementDefinition', 'patternBase64Binary', TFhirBase64Binary(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirBoolean) {6} then
    ComposeBoolean(this, 'ElementDefinition', 'patternBoolean', TFhirBoolean(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirDate) {6} then
    ComposeDate(this, 'ElementDefinition', 'patternDate', TFhirDate(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirDateTime) {6} then
    ComposeDateTime(this, 'ElementDefinition', 'patternDateTime', TFhirDateTime(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirDecimal) {6} then
    ComposeDecimal(this, 'ElementDefinition', 'patternDecimal', TFhirDecimal(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirInstant) {6} then
    ComposeInstant(this, 'ElementDefinition', 'patternInstant', TFhirInstant(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirInteger) {6} then
    ComposeInteger(this, 'ElementDefinition', 'patternInteger', TFhirInteger(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirString) {6} then
    ComposeString(this, 'ElementDefinition', 'patternString', TFhirString(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirTime) {6} then
    ComposeTime(this, 'ElementDefinition', 'patternTime', TFhirTime(elem.pattern), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirUri) {6} then
    ComposeUri(this, 'ElementDefinition', 'patternUri', TFhirUri(elem.pattern), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.exampleList.Count - 1 do
      ComposeElementDefinitionExample(this, 'ElementDefinition', 'example', elem.exampleList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirPositiveInt) {6} then
    ComposePositiveInt(this, 'ElementDefinition', 'minValuePositiveInt', TFhirPositiveInt(elem.minValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(this, 'ElementDefinition', 'minValueUnsignedInt', TFhirUnsignedInt(elem.minValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirQuantity) {6} then
    ComposeQuantity(this, 'ElementDefinition', 'minValueQuantity', TFhirQuantity(elem.minValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirDate) {6} then
    ComposeDate(this, 'ElementDefinition', 'minValueDate', TFhirDate(elem.minValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirDateTime) {6} then
    ComposeDateTime(this, 'ElementDefinition', 'minValueDateTime', TFhirDateTime(elem.minValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirInstant) {6} then
    ComposeInstant(this, 'ElementDefinition', 'minValueInstant', TFhirInstant(elem.minValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirTime) {6} then
    ComposeTime(this, 'ElementDefinition', 'minValueTime', TFhirTime(elem.minValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirDecimal) {6} then
    ComposeDecimal(this, 'ElementDefinition', 'minValueDecimal', TFhirDecimal(elem.minValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirInteger) {6} then
    ComposeInteger(this, 'ElementDefinition', 'minValueInteger', TFhirInteger(elem.minValue), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirPositiveInt) {6} then
    ComposePositiveInt(this, 'ElementDefinition', 'maxValuePositiveInt', TFhirPositiveInt(elem.maxValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(this, 'ElementDefinition', 'maxValueUnsignedInt', TFhirUnsignedInt(elem.maxValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirQuantity) {6} then
    ComposeQuantity(this, 'ElementDefinition', 'maxValueQuantity', TFhirQuantity(elem.maxValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirDate) {6} then
    ComposeDate(this, 'ElementDefinition', 'maxValueDate', TFhirDate(elem.maxValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirDateTime) {6} then
    ComposeDateTime(this, 'ElementDefinition', 'maxValueDateTime', TFhirDateTime(elem.maxValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirInstant) {6} then
    ComposeInstant(this, 'ElementDefinition', 'maxValueInstant', TFhirInstant(elem.maxValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirTime) {6} then
    ComposeTime(this, 'ElementDefinition', 'maxValueTime', TFhirTime(elem.maxValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirDecimal) {6} then
    ComposeDecimal(this, 'ElementDefinition', 'maxValueDecimal', TFhirDecimal(elem.maxValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirInteger) {6} then
    ComposeInteger(this, 'ElementDefinition', 'maxValueInteger', TFhirInteger(elem.maxValue), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInteger(this, 'ElementDefinition', 'maxLength', elem.maxLengthElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.conditionList.Count - 1 do
      ComposeId(this, 'ElementDefinition', 'condition', elem.conditionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.constraintList.Count - 1 do
      ComposeElementDefinitionConstraint(this, 'ElementDefinition', 'constraint', elem.constraintList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBoolean(this, 'ElementDefinition', 'mustSupport', elem.mustSupportElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBoolean(this, 'ElementDefinition', 'isModifier', elem.isModifierElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'ElementDefinition', 'isModifierReason', elem.isModifierReasonElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBoolean(this, 'ElementDefinition', 'isSummary', elem.isSummaryElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeElementDefinitionBinding(this, 'ElementDefinition', 'binding', elem.bindingElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.mappingList.Count - 1 do
      ComposeElementDefinitionMapping(this, 'ElementDefinition', 'mapping', elem.mappingList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseTimingRepeat(obj : TTurtleComplex) : TFhirTimingRepeat;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTimingRepeat.create;
  try
    ParseTimingRepeatProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTimingRepeatProperties(obj : TTurtleComplex; result : TFhirTimingRepeat);
var
  item : TTurtleComplex;
begin
    ParseElementProperties(obj, result);
    if obj.has('http://hl7.org/fhir/Timing.repeat.boundsDuration', item) then
      result.bounds := parseDuration(item);
    if obj.has('http://hl7.org/fhir/Timing.repeat.boundsRange', item) then
      result.bounds := parseRange(item);
    if obj.has('http://hl7.org/fhir/Timing.repeat.boundsPeriod', item) then
      result.bounds := parsePeriod(item);
    result.countElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Timing.repeat.count'));{q1}
    result.countMaxElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Timing.repeat.countMax'));{q1}
    result.durationElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Timing.repeat.duration'));{q1}
    result.durationMaxElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Timing.repeat.durationMax'));{q1}
    result.durationUnitElement := ParseEnum(obj.complex('http://hl7.org/fhir/Timing.repeat.durationUnit'), CODES_TFhirUnitsOfTimeEnum, SYSTEMS_TFhirUnitsOfTimeEnum);
    result.frequencyElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Timing.repeat.frequency'));{q1}
    result.frequencyMaxElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Timing.repeat.frequencyMax'));{q1}
    result.periodElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Timing.repeat.period'));{q1}
    result.periodMaxElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Timing.repeat.periodMax'));{q1}
    result.periodUnitElement := ParseEnum(obj.complex('http://hl7.org/fhir/Timing.repeat.periodUnit'), CODES_TFhirUnitsOfTimeEnum, SYSTEMS_TFhirUnitsOfTimeEnum);
    for item in obj.complexes('http://hl7.org/fhir/Timing.repeat.dayOfWeek') do
      result.dayOfWeekList.Add(parseEnum(item, CODES_TFhirDaysOfWeekEnum, SYSTEMS_TFhirDaysOfWeekEnum));
    for item in obj.complexes('http://hl7.org/fhir/Timing.repeat.timeOfDay') do
      result.timeOfDayList.Add(parseTime(item));
    for item in obj.complexes('http://hl7.org/fhir/Timing.repeat.when') do
      result.whenList.Add(parseEnum(item, CODES_TFhirEventTimingEnum, SYSTEMS_TFhirEventTimingEnum));
    result.offsetElement := ParseUnsignedInt(obj.complex('http://hl7.org/fhir/Timing.repeat.offset'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeTimingRepeat(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTimingRepeat; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TimingRepeat'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.bounds is TFhirDuration) {6} then
    ComposeDuration(this, 'Timing.repeat', 'boundsDuration', TFhirDuration(elem.bounds), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.bounds is TFhirRange) {6} then
    ComposeRange(this, 'Timing.repeat', 'boundsRange', TFhirRange(elem.bounds), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.bounds is TFhirPeriod) {6} then
    ComposePeriod(this, 'Timing.repeat', 'boundsPeriod', TFhirPeriod(elem.bounds), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(this, 'Timing.repeat', 'count', elem.countElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(this, 'Timing.repeat', 'countMax', elem.countMaxElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'Timing.repeat', 'duration', elem.durationElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'Timing.repeat', 'durationMax', elem.durationMaxElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'Timing.repeat', 'durationUnit', elem.DurationUnitElement, CODES_TFhirUnitsOfTimeEnum, SYSTEMS_TFhirUnitsOfTimeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(this, 'Timing.repeat', 'frequency', elem.frequencyElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(this, 'Timing.repeat', 'frequencyMax', elem.frequencyMaxElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'Timing.repeat', 'period', elem.periodElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'Timing.repeat', 'periodMax', elem.periodMaxElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'Timing.repeat', 'periodUnit', elem.PeriodUnitElement, CODES_TFhirUnitsOfTimeEnum, SYSTEMS_TFhirUnitsOfTimeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.dayOfWeekList.Count - 1 do
      ComposeEnum(this, 'Timing.repeat', 'dayOfWeek', elem.dayOfWeekList[i], CODES_TFhirDaysOfWeekEnum, SYSTEMS_TFhirDaysOfWeekEnum, false, i); {x.d1}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.dayOfWeekList.Count - 1 do
      ComposeEnum(this, 'Timing.repeat', 'dayOfWeek', elem.dayOfWeekList[i], CODES_TFhirDaysOfWeekEnum, SYSTEMS_TFhirDaysOfWeekEnum, false, i);{x.d2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.timeOfDayList.Count - 1 do
      ComposeTime(this, 'Timing.repeat', 'timeOfDay', elem.timeOfDayList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.whenList.Count - 1 do
      ComposeEnum(this, 'Timing.repeat', 'when', elem.whenList[i], CODES_TFhirEventTimingEnum, SYSTEMS_TFhirEventTimingEnum, false, i); {x.d1}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.whenList.Count - 1 do
      ComposeEnum(this, 'Timing.repeat', 'when', elem.whenList[i], CODES_TFhirEventTimingEnum, SYSTEMS_TFhirEventTimingEnum, false, i);{x.d2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedInt(this, 'Timing.repeat', 'offset', elem.offsetElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseTiming(obj : TTurtleComplex) : TFhirTiming;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTiming.create;
  try
    ParseTimingProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTimingProperties(obj : TTurtleComplex; result : TFhirTiming);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Timing.event') do
      result.eventList.Add(parseDateTime(item));
    result.repeat_ := ParseTimingRepeat(obj.complex('http://hl7.org/fhir/Timing.repeat'));{q3b}
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Timing.code'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeTiming(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTiming; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Timing'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.eventList.Count - 1 do
      ComposeDateTime(this, 'Timing', 'event', elem.eventList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeTimingRepeat(this, 'Timing', 'repeat', elem.repeat_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeableConcept(this, 'Timing', 'code', elem.codeElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseCount(obj : TTurtleComplex) : TFhirCount;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCount.create;
  try
    ParseCountProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCountProperties(obj : TTurtleComplex; result : TFhirCount);
begin
    ParseQuantityProperties(obj, result);
end;

procedure TFHIRTurtleComposer.ComposeCount(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCount; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Count'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
end;

function TFHIRTurtleParser.ParseAge(obj : TTurtleComplex) : TFhirAge;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAge.create;
  try
    ParseAgeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAgeProperties(obj : TTurtleComplex; result : TFhirAge);
begin
    ParseQuantityProperties(obj, result);
end;

procedure TFHIRTurtleComposer.ComposeAge(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAge; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Age'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
end;

function TFHIRTurtleParser.ParseDistance(obj : TTurtleComplex) : TFhirDistance;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDistance.create;
  try
    ParseDistanceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDistanceProperties(obj : TTurtleComplex; result : TFhirDistance);
begin
    ParseQuantityProperties(obj, result);
end;

procedure TFHIRTurtleComposer.ComposeDistance(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDistance; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Distance'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
end;

function TFHIRTurtleParser.ParseDuration(obj : TTurtleComplex) : TFhirDuration;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDuration.create;
  try
    ParseDurationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDurationProperties(obj : TTurtleComplex; result : TFhirDuration);
begin
    ParseQuantityProperties(obj, result);
end;

procedure TFHIRTurtleComposer.ComposeDuration(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDuration; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Duration'); {z}
  end;
  composeElement(this, '', name, elem, false, index);
end;

{$IFDEF FHIR_ACCOUNT}
function TFHIRTurtleParser.ParseAccountCoverage(obj : TTurtleComplex) : TFhirAccountCoverage;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAccountCoverage.create;
  try
    ParseAccountCoverageProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAccountCoverageProperties(obj : TTurtleComplex; result : TFhirAccountCoverage);
begin
    ParseBackboneElementProperties(obj, result);
    result.coverage := ParseReference{TFhirCoverage}(obj.complex('http://hl7.org/fhir/Account.coverage.coverage'));{q3b}
    result.priorityElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Account.coverage.priority'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeAccountCoverage(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAccountCoverage; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:AccountCoverage'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeReference{TFhirCoverage}(this, 'Account.coverage', 'coverage', elem.coverageElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(this, 'Account.coverage', 'priority', elem.priorityElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseAccountGuarantor(obj : TTurtleComplex) : TFhirAccountGuarantor;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAccountGuarantor.create;
  try
    ParseAccountGuarantorProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAccountGuarantorProperties(obj : TTurtleComplex; result : TFhirAccountGuarantor);
begin
    ParseBackboneElementProperties(obj, result);
    result.party := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/Account.guarantor.party'));{q3b}
    result.onHoldElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Account.guarantor.onHold'));{q1}
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Account.guarantor.period'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeAccountGuarantor(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAccountGuarantor; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:AccountGuarantor'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeReference{TFhirPatient}(this, 'Account.guarantor', 'party', elem.partyElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'Account.guarantor', 'onHold', elem.onHoldElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'Account.guarantor', 'period', elem.periodElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseAccount(obj : TTurtleComplex) : TFhirAccount;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAccount.create;
  try
    ParseAccountProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAccountProperties(obj : TTurtleComplex; result : TFhirAccount);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Account.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Account.status'), CODES_TFhirAccountStatusEnum, SYSTEMS_TFhirAccountStatusEnum);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Account.type'));{q3b}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/Account.name'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Account.subject') do
      result.subjectList.Add(parseReference{TFhirPatient}(item));
    result.servicePeriod := ParsePeriod(obj.complex('http://hl7.org/fhir/Account.servicePeriod'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Account.coverage') do
      result.coverageList.Add(parseAccountCoverage(item));
    result.owner := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/Account.owner'));{q3b}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/Account.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Account.guarantor') do
      result.guarantorList.Add(parseAccountGuarantor(item));
    result.partOf := ParseReference{TFhirAccount}(obj.complex('http://hl7.org/fhir/Account.partOf'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeAccount(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAccount; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Account'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Account', 'identifier', elem.identifierList[i], false, i);{x.d3}
  ComposeEnum(this, 'Account', 'status', elem.StatusElement, CODES_TFhirAccountStatusEnum, SYSTEMS_TFhirAccountStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCodeableConcept(this, 'Account', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(this, 'Account', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    for i := 0 to elem.subjectList.Count - 1 do
      ComposeReference{TFhirPatient}(this, 'Account', 'subject', elem.subjectList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('servicePeriod') then
    ComposePeriod(this, 'Account', 'servicePeriod', elem.servicePeriodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('coverage') then
    for i := 0 to elem.coverageList.Count - 1 do
      ComposeAccountCoverage(this, 'Account', 'coverage', elem.coverageList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('owner') then
    ComposeReference{TFhirOrganization}(this, 'Account', 'owner', elem.ownerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeString(this, 'Account', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('guarantor') then
    for i := 0 to elem.guarantorList.Count - 1 do
      ComposeAccountGuarantor(this, 'Account', 'guarantor', elem.guarantorList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('partOf') then
    ComposeReference{TFhirAccount}(this, 'Account', 'partOf', elem.partOfElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_ACCOUNT}
{$IFDEF FHIR_ACTIVITYDEFINITION}
function TFHIRTurtleParser.ParseActivityDefinitionParticipant(obj : TTurtleComplex) : TFhirActivityDefinitionParticipant;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirActivityDefinitionParticipant.create;
  try
    ParseActivityDefinitionParticipantProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseActivityDefinitionParticipantProperties(obj : TTurtleComplex; result : TFhirActivityDefinitionParticipant);
begin
    ParseBackboneElementProperties(obj, result);
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/ActivityDefinition.participant.type'), CODES_TFhirActionParticipantTypeEnum, SYSTEMS_TFhirActionParticipantTypeEnum);
    result.role := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ActivityDefinition.participant.role'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeActivityDefinitionParticipant(parent :  TTurtleComplex; parentType, name : String; elem : TFhirActivityDefinitionParticipant; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ActivityDefinitionParticipant'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'ActivityDefinition.participant', 'type', elem.Type_Element, CODES_TFhirActionParticipantTypeEnum, SYSTEMS_TFhirActionParticipantTypeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ActivityDefinition.participant', 'role', elem.roleElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseActivityDefinitionDynamicValue(obj : TTurtleComplex) : TFhirActivityDefinitionDynamicValue;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirActivityDefinitionDynamicValue.create;
  try
    ParseActivityDefinitionDynamicValueProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseActivityDefinitionDynamicValueProperties(obj : TTurtleComplex; result : TFhirActivityDefinitionDynamicValue);
begin
    ParseBackboneElementProperties(obj, result);
    result.pathElement := ParseString(obj.complex('http://hl7.org/fhir/ActivityDefinition.dynamicValue.path'));{q1}
    result.expression := ParseExpression(obj.complex('http://hl7.org/fhir/ActivityDefinition.dynamicValue.expression'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeActivityDefinitionDynamicValue(parent :  TTurtleComplex; parentType, name : String; elem : TFhirActivityDefinitionDynamicValue; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ActivityDefinitionDynamicValue'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeString(this, 'ActivityDefinition.dynamicValue', 'path', elem.pathElement, false, -1);{x.2ea}
  ComposeExpression(this, 'ActivityDefinition.dynamicValue', 'expression', elem.expressionElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseActivityDefinition(obj : TTurtleComplex) : TFhirActivityDefinition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirActivityDefinition.create;
  try
    ParseActivityDefinitionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseActivityDefinitionProperties(obj : TTurtleComplex; result : TFhirActivityDefinition);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/ActivityDefinition.url'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ActivityDefinition.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/ActivityDefinition.version'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/ActivityDefinition.name'));{q1}
    result.titleElement := ParseString(obj.complex('http://hl7.org/fhir/ActivityDefinition.title'));{q1}
    result.subtitleElement := ParseString(obj.complex('http://hl7.org/fhir/ActivityDefinition.subtitle'));{q1}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/ActivityDefinition.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    result.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ActivityDefinition.experimental'));{q1}
    if obj.has('http://hl7.org/fhir/ActivityDefinition.subjectCodeableConcept', item) then
      result.subject := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/ActivityDefinition.subjectReference', item) {a3} then
      result.subject := ParseReference(item);
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ActivityDefinition.date'));{q1}
    result.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/ActivityDefinition.publisher'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ActivityDefinition.contact') do
      result.contactList.Add(parseContactDetail(item));
    result.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ActivityDefinition.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ActivityDefinition.useContext') do
      result.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/ActivityDefinition.jurisdiction') do
      result.jurisdictionList.Add(parseCodeableConcept(item));
    result.purposeElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ActivityDefinition.purpose'));{q1}
    result.usageElement := ParseString(obj.complex('http://hl7.org/fhir/ActivityDefinition.usage'));{q1}
    result.copyrightElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ActivityDefinition.copyright'));{q1}
    result.approvalDateElement := ParseDate(obj.complex('http://hl7.org/fhir/ActivityDefinition.approvalDate'));{q1}
    result.lastReviewDateElement := ParseDate(obj.complex('http://hl7.org/fhir/ActivityDefinition.lastReviewDate'));{q1}
    result.effectivePeriod := ParsePeriod(obj.complex('http://hl7.org/fhir/ActivityDefinition.effectivePeriod'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ActivityDefinition.topic') do
      result.topicList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/ActivityDefinition.author') do
      result.authorList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/ActivityDefinition.editor') do
      result.editorList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/ActivityDefinition.reviewer') do
      result.reviewerList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/ActivityDefinition.endorser') do
      result.endorserList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/ActivityDefinition.relatedArtifact') do
      result.relatedArtifactList.Add(parseRelatedArtifact(item));
    for item in obj.complexes('http://hl7.org/fhir/ActivityDefinition.library') do
      result.library_List.Add(parseCanonical(item));
    result.kindElement := ParseEnum(obj.complex('http://hl7.org/fhir/ActivityDefinition.kind'), CODES_TFhirRequestResourceTypesEnum, SYSTEMS_TFhirRequestResourceTypesEnum);
    result.profileElement := ParseCanonical(obj.complex('http://hl7.org/fhir/ActivityDefinition.profile'));{q1}
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ActivityDefinition.code'));{q3b}
    result.intentElement := ParseEnum(obj.complex('http://hl7.org/fhir/ActivityDefinition.intent'), CODES_TFhirRequestIntentEnum, SYSTEMS_TFhirRequestIntentEnum);
    result.priorityElement := ParseEnum(obj.complex('http://hl7.org/fhir/ActivityDefinition.priority'), CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum);
    result.doNotPerformElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ActivityDefinition.doNotPerform'));{q1}
    if obj.has('http://hl7.org/fhir/ActivityDefinition.timingTiming', item) then
      result.timing := parseTiming(item);
    if obj.has('http://hl7.org/fhir/ActivityDefinition.timingAge', item) then
      result.timing := parseAge(item);
    if obj.has('http://hl7.org/fhir/ActivityDefinition.timingPeriod', item) then
      result.timing := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/ActivityDefinition.timingRange', item) then
      result.timing := parseRange(item);
    if obj.has('http://hl7.org/fhir/ActivityDefinition.timingDuration', item) then
      result.timing := parseDuration(item);
    if obj.has('http://hl7.org/fhir/ActivityDefinition.timingDateTime', item) then
      result.timing := parseDateTime(item);
    result.location := ParseReference{TFhirLocation}(obj.complex('http://hl7.org/fhir/ActivityDefinition.location'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ActivityDefinition.participant') do
      result.participantList.Add(parseActivityDefinitionParticipant(item));
    if obj.has('http://hl7.org/fhir/ActivityDefinition.productReference', item) {a3} then
      result.product := ParseReference(item);
    if obj.has('http://hl7.org/fhir/ActivityDefinition.productCodeableConcept', item) then
      result.product := parseCodeableConcept(item);
    result.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/ActivityDefinition.quantity'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ActivityDefinition.dosage') do
      result.dosageList.Add(parseDosage(item));
    for item in obj.complexes('http://hl7.org/fhir/ActivityDefinition.bodySite') do
      result.bodySiteList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/ActivityDefinition.specimenRequirement') do
      result.specimenRequirementList.Add(parseReference{TFhirSpecimenDefinition}(item));
    for item in obj.complexes('http://hl7.org/fhir/ActivityDefinition.observationRequirement') do
      result.observationRequirementList.Add(parseReference{TFhirObservationDefinition}(item));
    for item in obj.complexes('http://hl7.org/fhir/ActivityDefinition.observationResultRequirement') do
      result.observationResultRequirementList.Add(parseReference{TFhirObservationDefinition}(item));
    result.transformElement := ParseCanonical(obj.complex('http://hl7.org/fhir/ActivityDefinition.transform'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ActivityDefinition.dynamicValue') do
      result.dynamicValueList.Add(parseActivityDefinitionDynamicValue(item));
end;

procedure TFHIRTurtleComposer.ComposeActivityDefinition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirActivityDefinition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ActivityDefinition'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUri(this, 'ActivityDefinition', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'ActivityDefinition', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(this, 'ActivityDefinition', 'version', elem.versionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(this, 'ActivityDefinition', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeString(this, 'ActivityDefinition', 'title', elem.titleElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('subtitle') then
    ComposeString(this, 'ActivityDefinition', 'subtitle', elem.subtitleElement, false, -1);{x.2ea}
  ComposeEnum(this, 'ActivityDefinition', 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(this, 'ActivityDefinition', 'experimental', elem.experimentalElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and (elem.subject is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'ActivityDefinition', 'subjectCodeableConcept', TFhirCodeableConcept(elem.subject), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.subject is TFhirReference) {2} then
    ComposeReference(this, 'ActivityDefinition', 'subjectReference', TFhirReference(elem.subject), false,-1);{x.d8}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(this, 'ActivityDefinition', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(this, 'ActivityDefinition', 'publisher', elem.publisherElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(this, 'ActivityDefinition', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeMarkdown(this, 'ActivityDefinition', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(this, 'ActivityDefinition', 'useContext', elem.useContextList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'ActivityDefinition', 'jurisdiction', elem.jurisdictionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdown(this, 'ActivityDefinition', 'purpose', elem.purposeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('usage') then
    ComposeString(this, 'ActivityDefinition', 'usage', elem.usageElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdown(this, 'ActivityDefinition', 'copyright', elem.copyrightElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('approvalDate') then
    ComposeDate(this, 'ActivityDefinition', 'approvalDate', elem.approvalDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('lastReviewDate') then
    ComposeDate(this, 'ActivityDefinition', 'lastReviewDate', elem.lastReviewDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('effectivePeriod') then
    ComposePeriod(this, 'ActivityDefinition', 'effectivePeriod', elem.effectivePeriodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('topic') then
    for i := 0 to elem.topicList.Count - 1 do
      ComposeCodeableConcept(this, 'ActivityDefinition', 'topic', elem.topicList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('author') then
    for i := 0 to elem.authorList.Count - 1 do
      ComposeContactDetail(this, 'ActivityDefinition', 'author', elem.authorList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('editor') then
    for i := 0 to elem.editorList.Count - 1 do
      ComposeContactDetail(this, 'ActivityDefinition', 'editor', elem.editorList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('reviewer') then
    for i := 0 to elem.reviewerList.Count - 1 do
      ComposeContactDetail(this, 'ActivityDefinition', 'reviewer', elem.reviewerList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('endorser') then
    for i := 0 to elem.endorserList.Count - 1 do
      ComposeContactDetail(this, 'ActivityDefinition', 'endorser', elem.endorserList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('relatedArtifact') then
    for i := 0 to elem.relatedArtifactList.Count - 1 do
      ComposeRelatedArtifact(this, 'ActivityDefinition', 'relatedArtifact', elem.relatedArtifactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('library_') then
    for i := 0 to elem.library_List.Count - 1 do
      ComposeCanonical(this, 'ActivityDefinition', 'library', elem.library_List[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('kind') then
    ComposeEnum(this, 'ActivityDefinition', 'kind', elem.KindElement, CODES_TFhirRequestResourceTypesEnum, SYSTEMS_TFhirRequestResourceTypesEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('profile') then
    ComposeCanonical(this, 'ActivityDefinition', 'profile', elem.profileElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') then
    ComposeCodeableConcept(this, 'ActivityDefinition', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('intent') then
    ComposeEnum(this, 'ActivityDefinition', 'intent', elem.IntentElement, CODES_TFhirRequestIntentEnum, SYSTEMS_TFhirRequestIntentEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('priority') then
    ComposeEnum(this, 'ActivityDefinition', 'priority', elem.PriorityElement, CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('doNotPerform') then
    ComposeBoolean(this, 'ActivityDefinition', 'doNotPerform', elem.doNotPerformElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirTiming) {6} then
    ComposeTiming(this, 'ActivityDefinition', 'timingTiming', TFhirTiming(elem.timing), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirAge) {6} then
    ComposeAge(this, 'ActivityDefinition', 'timingAge', TFhirAge(elem.timing), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirPeriod) {6} then
    ComposePeriod(this, 'ActivityDefinition', 'timingPeriod', TFhirPeriod(elem.timing), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirRange) {6} then
    ComposeRange(this, 'ActivityDefinition', 'timingRange', TFhirRange(elem.timing), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirDuration) {6} then
    ComposeDuration(this, 'ActivityDefinition', 'timingDuration', TFhirDuration(elem.timing), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirDateTime) {6} then
    ComposeDateTime(this, 'ActivityDefinition', 'timingDateTime', TFhirDateTime(elem.timing), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) and doCompose('location') then
    ComposeReference{TFhirLocation}(this, 'ActivityDefinition', 'location', elem.locationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('participant') then
    for i := 0 to elem.participantList.Count - 1 do
      ComposeActivityDefinitionParticipant(this, 'ActivityDefinition', 'participant', elem.participantList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and (elem.product is TFhirReference) {2} then
    ComposeReference(this, 'ActivityDefinition', 'productReference', TFhirReference(elem.product), false,-1){x.d8}
  else if (SummaryOption in [soFull, soData]) and (elem.product is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'ActivityDefinition', 'productCodeableConcept', TFhirCodeableConcept(elem.product), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) and doCompose('quantity') then
    ComposeQuantity(this, 'ActivityDefinition', 'quantity', elem.quantityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('dosage') then
    for i := 0 to elem.dosageList.Count - 1 do
      ComposeDosage(this, 'ActivityDefinition', 'dosage', elem.dosageList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('bodySite') then
    for i := 0 to elem.bodySiteList.Count - 1 do
      ComposeCodeableConcept(this, 'ActivityDefinition', 'bodySite', elem.bodySiteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('specimenRequirement') then
    for i := 0 to elem.specimenRequirementList.Count - 1 do
      ComposeReference{TFhirSpecimenDefinition}(this, 'ActivityDefinition', 'specimenRequirement', elem.specimenRequirementList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('observationRequirement') then
    for i := 0 to elem.observationRequirementList.Count - 1 do
      ComposeReference{TFhirObservationDefinition}(this, 'ActivityDefinition', 'observationRequirement', elem.observationRequirementList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('observationResultRequirement') then
    for i := 0 to elem.observationResultRequirementList.Count - 1 do
      ComposeReference{TFhirObservationDefinition}(this, 'ActivityDefinition', 'observationResultRequirement', elem.observationResultRequirementList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('transform') then
    ComposeCanonical(this, 'ActivityDefinition', 'transform', elem.transformElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('dynamicValue') then
    for i := 0 to elem.dynamicValueList.Count - 1 do
      ComposeActivityDefinitionDynamicValue(this, 'ActivityDefinition', 'dynamicValue', elem.dynamicValueList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_ACTIVITYDEFINITION}
{$IFDEF FHIR_ADVERSEEVENT}
function TFHIRTurtleParser.ParseAdverseEventSuspectEntity(obj : TTurtleComplex) : TFhirAdverseEventSuspectEntity;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAdverseEventSuspectEntity.create;
  try
    ParseAdverseEventSuspectEntityProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAdverseEventSuspectEntityProperties(obj : TTurtleComplex; result : TFhirAdverseEventSuspectEntity);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.instance := ParseReference{TFhirImmunization}(obj.complex('http://hl7.org/fhir/AdverseEvent.suspectEntity.instance'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/AdverseEvent.suspectEntity.causality') do
      result.causalityList.Add(parseAdverseEventSuspectEntityCausality(item));
end;

procedure TFHIRTurtleComposer.ComposeAdverseEventSuspectEntity(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAdverseEventSuspectEntity; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:AdverseEventSuspectEntity'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeReference{TFhirImmunization}(this, 'AdverseEvent.suspectEntity', 'instance', elem.instanceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.causalityList.Count - 1 do
      ComposeAdverseEventSuspectEntityCausality(this, 'AdverseEvent.suspectEntity', 'causality', elem.causalityList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseAdverseEventSuspectEntityCausality(obj : TTurtleComplex) : TFhirAdverseEventSuspectEntityCausality;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAdverseEventSuspectEntityCausality.create;
  try
    ParseAdverseEventSuspectEntityCausalityProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAdverseEventSuspectEntityCausalityProperties(obj : TTurtleComplex; result : TFhirAdverseEventSuspectEntityCausality);
begin
    ParseBackboneElementProperties(obj, result);
    result.assessment := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/AdverseEvent.suspectEntity.causality.assessment'));{q3b}
    result.productRelatednessElement := ParseString(obj.complex('http://hl7.org/fhir/AdverseEvent.suspectEntity.causality.productRelatedness'));{q1}
    result.author := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/AdverseEvent.suspectEntity.causality.author'));{q3b}
    result.method := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/AdverseEvent.suspectEntity.causality.method'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeAdverseEventSuspectEntityCausality(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAdverseEventSuspectEntityCausality; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:AdverseEventSuspectEntityCausality'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'AdverseEvent.suspectEntity.causality', 'assessment', elem.assessmentElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'AdverseEvent.suspectEntity.causality', 'productRelatedness', elem.productRelatednessElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(this, 'AdverseEvent.suspectEntity.causality', 'author', elem.authorElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'AdverseEvent.suspectEntity.causality', 'method', elem.methodElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseAdverseEvent(obj : TTurtleComplex) : TFhirAdverseEvent;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAdverseEvent.create;
  try
    ParseAdverseEventProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAdverseEventProperties(obj : TTurtleComplex; result : TFhirAdverseEvent);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/AdverseEvent.identifier'));{q3b}
    result.actualityElement := ParseEnum(obj.complex('http://hl7.org/fhir/AdverseEvent.actuality'), CODES_TFhirAdverseEventActualityEnum, SYSTEMS_TFhirAdverseEventActualityEnum);
    for item in obj.complexes('http://hl7.org/fhir/AdverseEvent.category') do
      result.categoryList.Add(parseCodeableConcept(item));
    result.event := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/AdverseEvent.event'));{q3b}
    result.subject := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/AdverseEvent.subject'));{q3b}
    result.encounter := ParseReference{TFhirEncounter}(obj.complex('http://hl7.org/fhir/AdverseEvent.encounter'));{q3b}
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/AdverseEvent.date'));{q1}
    result.detectedElement := ParseDateTime(obj.complex('http://hl7.org/fhir/AdverseEvent.detected'));{q1}
    result.recordedDateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/AdverseEvent.recordedDate'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/AdverseEvent.resultingCondition') do
      result.resultingConditionList.Add(parseReference{TFhirCondition}(item));
    result.location := ParseReference{TFhirLocation}(obj.complex('http://hl7.org/fhir/AdverseEvent.location'));{q3b}
    result.seriousness := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/AdverseEvent.seriousness'));{q3b}
    result.severity := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/AdverseEvent.severity'));{q3b}
    result.outcome := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/AdverseEvent.outcome'));{q3b}
    result.recorder := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/AdverseEvent.recorder'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/AdverseEvent.contributor') do
      result.contributorList.Add(parseReference{TFhirPractitioner}(item));
    for item in obj.complexes('http://hl7.org/fhir/AdverseEvent.suspectEntity') do
      result.suspectEntityList.Add(parseAdverseEventSuspectEntity(item));
    for item in obj.complexes('http://hl7.org/fhir/AdverseEvent.subjectMedicalHistory') do
      result.subjectMedicalHistoryList.Add(parseReference{TFhirCondition}(item));
    for item in obj.complexes('http://hl7.org/fhir/AdverseEvent.referenceDocument') do
      result.referenceDocumentList.Add(parseReference{TFhirDocumentReference}(item));
    for item in obj.complexes('http://hl7.org/fhir/AdverseEvent.study') do
      result.studyList.Add(parseReference{TFhirResearchStudy}(item));
end;

procedure TFHIRTurtleComposer.ComposeAdverseEvent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAdverseEvent; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:AdverseEvent'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(this, 'AdverseEvent', 'identifier', elem.identifierElement, false, -1);{x.2f}
  ComposeEnum(this, 'AdverseEvent', 'actuality', elem.ActualityElement, CODES_TFhirAdverseEventActualityEnum, SYSTEMS_TFhirAdverseEventActualityEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(this, 'AdverseEvent', 'category', elem.categoryList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('event') then
    ComposeCodeableConcept(this, 'AdverseEvent', 'event', elem.eventElement, false, -1);{x.2f}
  ComposeReference{TFhirPatient}(this, 'AdverseEvent', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(this, 'AdverseEvent', 'encounter', elem.encounterElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(this, 'AdverseEvent', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('detected') then
    ComposeDateTime(this, 'AdverseEvent', 'detected', elem.detectedElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('recordedDate') then
    ComposeDateTime(this, 'AdverseEvent', 'recordedDate', elem.recordedDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('resultingCondition') then
    for i := 0 to elem.resultingConditionList.Count - 1 do
      ComposeReference{TFhirCondition}(this, 'AdverseEvent', 'resultingCondition', elem.resultingConditionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('location') then
    ComposeReference{TFhirLocation}(this, 'AdverseEvent', 'location', elem.locationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('seriousness') then
    ComposeCodeableConcept(this, 'AdverseEvent', 'seriousness', elem.seriousnessElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('severity') then
    ComposeCodeableConcept(this, 'AdverseEvent', 'severity', elem.severityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('outcome') then
    ComposeCodeableConcept(this, 'AdverseEvent', 'outcome', elem.outcomeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('recorder') then
    ComposeReference{TFhirPatient}(this, 'AdverseEvent', 'recorder', elem.recorderElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contributor') then
    for i := 0 to elem.contributorList.Count - 1 do
      ComposeReference{TFhirPractitioner}(this, 'AdverseEvent', 'contributor', elem.contributorList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('suspectEntity') then
    for i := 0 to elem.suspectEntityList.Count - 1 do
      ComposeAdverseEventSuspectEntity(this, 'AdverseEvent', 'suspectEntity', elem.suspectEntityList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subjectMedicalHistory') then
    for i := 0 to elem.subjectMedicalHistoryList.Count - 1 do
      ComposeReference{TFhirCondition}(this, 'AdverseEvent', 'subjectMedicalHistory', elem.subjectMedicalHistoryList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('referenceDocument') then
    for i := 0 to elem.referenceDocumentList.Count - 1 do
      ComposeReference{TFhirDocumentReference}(this, 'AdverseEvent', 'referenceDocument', elem.referenceDocumentList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('study') then
    for i := 0 to elem.studyList.Count - 1 do
      ComposeReference{TFhirResearchStudy}(this, 'AdverseEvent', 'study', elem.studyList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_ADVERSEEVENT}
{$IFDEF FHIR_ALLERGYINTOLERANCE}
function TFHIRTurtleParser.ParseAllergyIntoleranceReaction(obj : TTurtleComplex) : TFhirAllergyIntoleranceReaction;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAllergyIntoleranceReaction.create;
  try
    ParseAllergyIntoleranceReactionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAllergyIntoleranceReactionProperties(obj : TTurtleComplex; result : TFhirAllergyIntoleranceReaction);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.substance := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/AllergyIntolerance.reaction.substance'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/AllergyIntolerance.reaction.manifestation') do
      result.manifestationList.Add(parseCodeableConcept(item));
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/AllergyIntolerance.reaction.description'));{q1}
    result.onsetElement := ParseDateTime(obj.complex('http://hl7.org/fhir/AllergyIntolerance.reaction.onset'));{q1}
    result.severityElement := ParseEnum(obj.complex('http://hl7.org/fhir/AllergyIntolerance.reaction.severity'), CODES_TFhirReactionEventSeverityEnum, SYSTEMS_TFhirReactionEventSeverityEnum);
    result.exposureRoute := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/AllergyIntolerance.reaction.exposureRoute'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/AllergyIntolerance.reaction.note') do
      result.noteList.Add(parseAnnotation(item));
end;

procedure TFHIRTurtleComposer.ComposeAllergyIntoleranceReaction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAllergyIntoleranceReaction; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:AllergyIntoleranceReaction'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'AllergyIntolerance.reaction', 'substance', elem.substanceElement, false, -1);{x.2f}
  for i := 0 to elem.manifestationList.Count - 1 do
      ComposeCodeableConcept(this, 'AllergyIntolerance.reaction', 'manifestation', elem.manifestationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'AllergyIntolerance.reaction', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'AllergyIntolerance.reaction', 'onset', elem.onsetElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'AllergyIntolerance.reaction', 'severity', elem.SeverityElement, CODES_TFhirReactionEventSeverityEnum, SYSTEMS_TFhirReactionEventSeverityEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'AllergyIntolerance.reaction', 'exposureRoute', elem.exposureRouteElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'AllergyIntolerance.reaction', 'note', elem.noteList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseAllergyIntolerance(obj : TTurtleComplex) : TFhirAllergyIntolerance;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAllergyIntolerance.create;
  try
    ParseAllergyIntoleranceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAllergyIntoleranceProperties(obj : TTurtleComplex; result : TFhirAllergyIntolerance);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/AllergyIntolerance.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.clinicalStatus := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/AllergyIntolerance.clinicalStatus'));{q3b}
    result.verificationStatus := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/AllergyIntolerance.verificationStatus'));{q3b}
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/AllergyIntolerance.type'), CODES_TFhirAllergyIntoleranceTypeEnum, SYSTEMS_TFhirAllergyIntoleranceTypeEnum);
    for item in obj.complexes('http://hl7.org/fhir/AllergyIntolerance.category') do
      result.categoryList.Add(parseEnum(item, CODES_TFhirAllergyIntoleranceCategoryEnum, SYSTEMS_TFhirAllergyIntoleranceCategoryEnum));
    result.criticalityElement := ParseEnum(obj.complex('http://hl7.org/fhir/AllergyIntolerance.criticality'), CODES_TFhirAllergyIntoleranceCriticalityEnum, SYSTEMS_TFhirAllergyIntoleranceCriticalityEnum);
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/AllergyIntolerance.code'));{q3b}
    result.patient := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/AllergyIntolerance.patient'));{q3b}
    result.encounter := ParseReference{TFhirEncounter}(obj.complex('http://hl7.org/fhir/AllergyIntolerance.encounter'));{q3b}
    if obj.has('http://hl7.org/fhir/AllergyIntolerance.onsetAge', item) then
      result.onset := parseAge(item);
    if obj.has('http://hl7.org/fhir/AllergyIntolerance.onsetPeriod', item) then
      result.onset := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/AllergyIntolerance.onsetRange', item) then
      result.onset := parseRange(item);
    if obj.has('http://hl7.org/fhir/AllergyIntolerance.onsetDateTime', item) then
      result.onset := parseDateTime(item);
    if obj.has('http://hl7.org/fhir/AllergyIntolerance.onsetString', item) then
      result.onset := parseString(item);
    result.recordedDateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/AllergyIntolerance.recordedDate'));{q1}
    result.recorder := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/AllergyIntolerance.recorder'));{q3b}
    result.asserter := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/AllergyIntolerance.asserter'));{q3b}
    result.lastOccurrenceElement := ParseDateTime(obj.complex('http://hl7.org/fhir/AllergyIntolerance.lastOccurrence'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/AllergyIntolerance.note') do
      result.noteList.Add(parseAnnotation(item));
    for item in obj.complexes('http://hl7.org/fhir/AllergyIntolerance.reaction') do
      result.reactionList.Add(parseAllergyIntoleranceReaction(item));
end;

procedure TFHIRTurtleComposer.ComposeAllergyIntolerance(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAllergyIntolerance; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:AllergyIntolerance'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'AllergyIntolerance', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('clinicalStatus') then
    ComposeCodeableConcept(this, 'AllergyIntolerance', 'clinicalStatus', elem.clinicalStatusElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('verificationStatus') then
    ComposeCodeableConcept(this, 'AllergyIntolerance', 'verificationStatus', elem.verificationStatusElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeEnum(this, 'AllergyIntolerance', 'type', elem.Type_Element, CODES_TFhirAllergyIntoleranceTypeEnum, SYSTEMS_TFhirAllergyIntoleranceTypeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeEnum(this, 'AllergyIntolerance', 'category', elem.categoryList[i], CODES_TFhirAllergyIntoleranceCategoryEnum, SYSTEMS_TFhirAllergyIntoleranceCategoryEnum, false, i); {x.d1}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeEnum(this, 'AllergyIntolerance', 'category', elem.categoryList[i], CODES_TFhirAllergyIntoleranceCategoryEnum, SYSTEMS_TFhirAllergyIntoleranceCategoryEnum, false, i);{x.d2}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('criticality') then
    ComposeEnum(this, 'AllergyIntolerance', 'criticality', elem.CriticalityElement, CODES_TFhirAllergyIntoleranceCriticalityEnum, SYSTEMS_TFhirAllergyIntoleranceCriticalityEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') then
    ComposeCodeableConcept(this, 'AllergyIntolerance', 'code', elem.codeElement, false, -1);{x.2f}
  ComposeReference{TFhirPatient}(this, 'AllergyIntolerance', 'patient', elem.patientElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(this, 'AllergyIntolerance', 'encounter', elem.encounterElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and (elem.onset is TFhirAge) {6} then
    ComposeAge(this, 'AllergyIntolerance', 'onsetAge', TFhirAge(elem.onset), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.onset is TFhirPeriod) {6} then
    ComposePeriod(this, 'AllergyIntolerance', 'onsetPeriod', TFhirPeriod(elem.onset), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.onset is TFhirRange) {6} then
    ComposeRange(this, 'AllergyIntolerance', 'onsetRange', TFhirRange(elem.onset), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.onset is TFhirDateTime) {6} then
    ComposeDateTime(this, 'AllergyIntolerance', 'onsetDateTime', TFhirDateTime(elem.onset), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.onset is TFhirString) {6} then
    ComposeString(this, 'AllergyIntolerance', 'onsetString', TFhirString(elem.onset), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) and doCompose('recordedDate') then
    ComposeDateTime(this, 'AllergyIntolerance', 'recordedDate', elem.recordedDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('recorder') then
    ComposeReference{TFhirPractitioner}(this, 'AllergyIntolerance', 'recorder', elem.recorderElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('asserter') then
    ComposeReference{TFhirPatient}(this, 'AllergyIntolerance', 'asserter', elem.asserterElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('lastOccurrence') then
    ComposeDateTime(this, 'AllergyIntolerance', 'lastOccurrence', elem.lastOccurrenceElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'AllergyIntolerance', 'note', elem.noteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('reaction') then
    for i := 0 to elem.reactionList.Count - 1 do
      ComposeAllergyIntoleranceReaction(this, 'AllergyIntolerance', 'reaction', elem.reactionList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_ALLERGYINTOLERANCE}
{$IFDEF FHIR_APPOINTMENT}
function TFHIRTurtleParser.ParseAppointmentParticipant(obj : TTurtleComplex) : TFhirAppointmentParticipant;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAppointmentParticipant.create;
  try
    ParseAppointmentParticipantProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAppointmentParticipantProperties(obj : TTurtleComplex; result : TFhirAppointmentParticipant);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Appointment.participant.type') do
      result.type_List.Add(parseCodeableConcept(item));
    result.actor := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/Appointment.participant.actor'));{q3b}
    result.requiredElement := ParseEnum(obj.complex('http://hl7.org/fhir/Appointment.participant.required'), CODES_TFhirParticipantrequiredEnum, SYSTEMS_TFhirParticipantrequiredEnum);
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Appointment.participant.status'), CODES_TFhirParticipationstatusEnum, SYSTEMS_TFhirParticipationstatusEnum);
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Appointment.participant.period'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeAppointmentParticipant(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAppointmentParticipant; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:AppointmentParticipant'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(this, 'Appointment.participant', 'type', elem.type_List[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(this, 'Appointment.participant', 'actor', elem.actorElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'Appointment.participant', 'required', elem.RequiredElement, CODES_TFhirParticipantrequiredEnum, SYSTEMS_TFhirParticipantrequiredEnum, false, -1);{x.d4}
  ComposeEnum(this, 'Appointment.participant', 'status', elem.StatusElement, CODES_TFhirParticipationstatusEnum, SYSTEMS_TFhirParticipationstatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'Appointment.participant', 'period', elem.periodElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseAppointment(obj : TTurtleComplex) : TFhirAppointment;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAppointment.create;
  try
    ParseAppointmentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAppointmentProperties(obj : TTurtleComplex; result : TFhirAppointment);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Appointment.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Appointment.status'), CODES_TFhirAppointmentstatusEnum, SYSTEMS_TFhirAppointmentstatusEnum);
    result.cancelationReason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Appointment.cancelationReason'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Appointment.serviceCategory') do
      result.serviceCategoryList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Appointment.serviceType') do
      result.serviceTypeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Appointment.specialty') do
      result.specialtyList.Add(parseCodeableConcept(item));
    result.appointmentType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Appointment.appointmentType'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Appointment.reasonCode') do
      result.reasonCodeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Appointment.reasonReference') do
      result.reasonReferenceList.Add(parseReference{TFhirCondition}(item));
    result.priorityElement := ParseUnsignedInt(obj.complex('http://hl7.org/fhir/Appointment.priority'));{q1}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/Appointment.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Appointment.supportingInformation') do
      result.supportingInformationList.Add(parseReference{TFhirReference}(item));
    result.startElement := ParseInstant(obj.complex('http://hl7.org/fhir/Appointment.start'));{q1}
    result.end_Element := ParseInstant(obj.complex('http://hl7.org/fhir/Appointment.end'));{q1}
    result.minutesDurationElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Appointment.minutesDuration'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Appointment.slot') do
      result.slotList.Add(parseReference{TFhirSlot}(item));
    result.createdElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Appointment.created'));{q1}
    result.commentElement := ParseString(obj.complex('http://hl7.org/fhir/Appointment.comment'));{q1}
    result.patientInstructionElement := ParseString(obj.complex('http://hl7.org/fhir/Appointment.patientInstruction'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Appointment.basedOn') do
      result.basedOnList.Add(parseReference{TFhirServiceRequest}(item));
    for item in obj.complexes('http://hl7.org/fhir/Appointment.participant') do
      result.participantList.Add(parseAppointmentParticipant(item));
    for item in obj.complexes('http://hl7.org/fhir/Appointment.requestedPeriod') do
      result.requestedPeriodList.Add(parsePeriod(item));
end;

procedure TFHIRTurtleComposer.ComposeAppointment(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAppointment; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Appointment'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Appointment', 'identifier', elem.identifierList[i], false, i);{x.d3}
  ComposeEnum(this, 'Appointment', 'status', elem.StatusElement, CODES_TFhirAppointmentstatusEnum, SYSTEMS_TFhirAppointmentstatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('cancelationReason') then
    ComposeCodeableConcept(this, 'Appointment', 'cancelationReason', elem.cancelationReasonElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('serviceCategory') then
    for i := 0 to elem.serviceCategoryList.Count - 1 do
      ComposeCodeableConcept(this, 'Appointment', 'serviceCategory', elem.serviceCategoryList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('serviceType') then
    for i := 0 to elem.serviceTypeList.Count - 1 do
      ComposeCodeableConcept(this, 'Appointment', 'serviceType', elem.serviceTypeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('specialty') then
    for i := 0 to elem.specialtyList.Count - 1 do
      ComposeCodeableConcept(this, 'Appointment', 'specialty', elem.specialtyList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('appointmentType') then
    ComposeCodeableConcept(this, 'Appointment', 'appointmentType', elem.appointmentTypeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonCode') then
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'Appointment', 'reasonCode', elem.reasonCodeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('reasonReference') then
    for i := 0 to elem.reasonReferenceList.Count - 1 do
      ComposeReference{TFhirCondition}(this, 'Appointment', 'reasonReference', elem.reasonReferenceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('priority') then
    ComposeUnsignedInt(this, 'Appointment', 'priority', elem.priorityElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeString(this, 'Appointment', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('supportingInformation') then
    for i := 0 to elem.supportingInformationList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'Appointment', 'supportingInformation', elem.supportingInformationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('start') then
    ComposeInstant(this, 'Appointment', 'start', elem.startElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('end_') then
    ComposeInstant(this, 'Appointment', 'end', elem.end_Element, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('minutesDuration') then
    ComposePositiveInt(this, 'Appointment', 'minutesDuration', elem.minutesDurationElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('slot') then
    for i := 0 to elem.slotList.Count - 1 do
      ComposeReference{TFhirSlot}(this, 'Appointment', 'slot', elem.slotList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('created') then
    ComposeDateTime(this, 'Appointment', 'created', elem.createdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('comment') then
    ComposeString(this, 'Appointment', 'comment', elem.commentElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('patientInstruction') then
    ComposeString(this, 'Appointment', 'patientInstruction', elem.patientInstructionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('basedOn') then
    for i := 0 to elem.basedOnList.Count - 1 do
      ComposeReference{TFhirServiceRequest}(this, 'Appointment', 'basedOn', elem.basedOnList[i], false, i);{x.d3}
  for i := 0 to elem.participantList.Count - 1 do
      ComposeAppointmentParticipant(this, 'Appointment', 'participant', elem.participantList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('requestedPeriod') then
    for i := 0 to elem.requestedPeriodList.Count - 1 do
      ComposePeriod(this, 'Appointment', 'requestedPeriod', elem.requestedPeriodList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_APPOINTMENT}
{$IFDEF FHIR_APPOINTMENTRESPONSE}
function TFHIRTurtleParser.ParseAppointmentResponse(obj : TTurtleComplex) : TFhirAppointmentResponse;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAppointmentResponse.create;
  try
    ParseAppointmentResponseProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAppointmentResponseProperties(obj : TTurtleComplex; result : TFhirAppointmentResponse);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/AppointmentResponse.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.appointment := ParseReference{TFhirAppointment}(obj.complex('http://hl7.org/fhir/AppointmentResponse.appointment'));{q3b}
    result.startElement := ParseInstant(obj.complex('http://hl7.org/fhir/AppointmentResponse.start'));{q1}
    result.end_Element := ParseInstant(obj.complex('http://hl7.org/fhir/AppointmentResponse.end'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/AppointmentResponse.participantType') do
      result.participantTypeList.Add(parseCodeableConcept(item));
    result.actor := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/AppointmentResponse.actor'));{q3b}
    result.participantStatusElement := ParseEnum(obj.complex('http://hl7.org/fhir/AppointmentResponse.participantStatus'), CODES_TFhirParticipationstatusEnum, SYSTEMS_TFhirParticipationstatusEnum);
    result.commentElement := ParseString(obj.complex('http://hl7.org/fhir/AppointmentResponse.comment'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeAppointmentResponse(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAppointmentResponse; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:AppointmentResponse'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'AppointmentResponse', 'identifier', elem.identifierList[i], false, i);{x.d3}
  ComposeReference{TFhirAppointment}(this, 'AppointmentResponse', 'appointment', elem.appointmentElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('start') then
    ComposeInstant(this, 'AppointmentResponse', 'start', elem.startElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('end_') then
    ComposeInstant(this, 'AppointmentResponse', 'end', elem.end_Element, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('participantType') then
    for i := 0 to elem.participantTypeList.Count - 1 do
      ComposeCodeableConcept(this, 'AppointmentResponse', 'participantType', elem.participantTypeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('actor') then
    ComposeReference{TFhirPatient}(this, 'AppointmentResponse', 'actor', elem.actorElement, false, -1);{x.2f}
  ComposeEnum(this, 'AppointmentResponse', 'participantStatus', elem.ParticipantStatusElement, CODES_TFhirParticipationstatusEnum, SYSTEMS_TFhirParticipationstatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('comment') then
    ComposeString(this, 'AppointmentResponse', 'comment', elem.commentElement, false, -1);{x.2ea}
end;

{$ENDIF FHIR_APPOINTMENTRESPONSE}
{$IFDEF FHIR_AUDITEVENT}
function TFHIRTurtleParser.ParseAuditEventAgent(obj : TTurtleComplex) : TFhirAuditEventAgent;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAuditEventAgent.create;
  try
    ParseAuditEventAgentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAuditEventAgentProperties(obj : TTurtleComplex; result : TFhirAuditEventAgent);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/AuditEvent.agent.type'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/AuditEvent.agent.role') do
      result.roleList.Add(parseCodeableConcept(item));
    result.who := ParseReference{TFhirPractitionerRole}(obj.complex('http://hl7.org/fhir/AuditEvent.agent.who'));{q3b}
    result.altIdElement := ParseString(obj.complex('http://hl7.org/fhir/AuditEvent.agent.altId'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/AuditEvent.agent.name'));{q1}
    result.requestorElement := ParseBoolean(obj.complex('http://hl7.org/fhir/AuditEvent.agent.requestor'));{q1}
    result.location := ParseReference{TFhirLocation}(obj.complex('http://hl7.org/fhir/AuditEvent.agent.location'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/AuditEvent.agent.policy') do
      result.policyList.Add(parseUri(item));
    result.media := ParseCoding(obj.complex('http://hl7.org/fhir/AuditEvent.agent.media'));{q3b}
    result.network := ParseAuditEventAgentNetwork(obj.complex('http://hl7.org/fhir/AuditEvent.agent.network'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/AuditEvent.agent.purposeOfUse') do
      result.purposeOfUseList.Add(parseCodeableConcept(item));
end;

procedure TFHIRTurtleComposer.ComposeAuditEventAgent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAuditEventAgent; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:AuditEventAgent'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'AuditEvent.agent', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.roleList.Count - 1 do
      ComposeCodeableConcept(this, 'AuditEvent.agent', 'role', elem.roleList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitionerRole}(this, 'AuditEvent.agent', 'who', elem.whoElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'AuditEvent.agent', 'altId', elem.altIdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'AuditEvent.agent', 'name', elem.nameElement, false, -1);{x.2ea}
  ComposeBoolean(this, 'AuditEvent.agent', 'requestor', elem.requestorElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirLocation}(this, 'AuditEvent.agent', 'location', elem.locationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.policyList.Count - 1 do
      ComposeUri(this, 'AuditEvent.agent', 'policy', elem.policyList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(this, 'AuditEvent.agent', 'media', elem.mediaElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeAuditEventAgentNetwork(this, 'AuditEvent.agent', 'network', elem.networkElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.purposeOfUseList.Count - 1 do
      ComposeCodeableConcept(this, 'AuditEvent.agent', 'purposeOfUse', elem.purposeOfUseList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseAuditEventAgentNetwork(obj : TTurtleComplex) : TFhirAuditEventAgentNetwork;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAuditEventAgentNetwork.create;
  try
    ParseAuditEventAgentNetworkProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAuditEventAgentNetworkProperties(obj : TTurtleComplex; result : TFhirAuditEventAgentNetwork);
begin
    ParseBackboneElementProperties(obj, result);
    result.addressElement := ParseString(obj.complex('http://hl7.org/fhir/AuditEvent.agent.network.address'));{q1}
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/AuditEvent.agent.network.type'), CODES_TFhirNetworkTypeEnum, SYSTEMS_TFhirNetworkTypeEnum);
end;

procedure TFHIRTurtleComposer.ComposeAuditEventAgentNetwork(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAuditEventAgentNetwork; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:AuditEventAgentNetwork'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'AuditEvent.agent.network', 'address', elem.addressElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'AuditEvent.agent.network', 'type', elem.Type_Element, CODES_TFhirNetworkTypeEnum, SYSTEMS_TFhirNetworkTypeEnum, false, -1);{x.d4}
end;

function TFHIRTurtleParser.ParseAuditEventSource(obj : TTurtleComplex) : TFhirAuditEventSource;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAuditEventSource.create;
  try
    ParseAuditEventSourceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAuditEventSourceProperties(obj : TTurtleComplex; result : TFhirAuditEventSource);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.siteElement := ParseString(obj.complex('http://hl7.org/fhir/AuditEvent.source.site'));{q1}
    result.observer := ParseReference{TFhirPractitionerRole}(obj.complex('http://hl7.org/fhir/AuditEvent.source.observer'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/AuditEvent.source.type') do
      result.type_List.Add(parseCoding(item));
end;

procedure TFHIRTurtleComposer.ComposeAuditEventSource(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAuditEventSource; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:AuditEventSource'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'AuditEvent.source', 'site', elem.siteElement, false, -1);{x.2ea}
  ComposeReference{TFhirPractitionerRole}(this, 'AuditEvent.source', 'observer', elem.observerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCoding(this, 'AuditEvent.source', 'type', elem.type_List[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseAuditEventEntity(obj : TTurtleComplex) : TFhirAuditEventEntity;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAuditEventEntity.create;
  try
    ParseAuditEventEntityProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAuditEventEntityProperties(obj : TTurtleComplex; result : TFhirAuditEventEntity);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.what := ParseReference{TFhirReference}(obj.complex('http://hl7.org/fhir/AuditEvent.entity.what'));{q3b}
    result.type_ := ParseCoding(obj.complex('http://hl7.org/fhir/AuditEvent.entity.type'));{q3b}
    result.role := ParseCoding(obj.complex('http://hl7.org/fhir/AuditEvent.entity.role'));{q3b}
    result.lifecycle := ParseCoding(obj.complex('http://hl7.org/fhir/AuditEvent.entity.lifecycle'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/AuditEvent.entity.securityLabel') do
      result.securityLabelList.Add(parseCoding(item));
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/AuditEvent.entity.name'));{q1}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/AuditEvent.entity.description'));{q1}
    result.queryElement := ParseBase64Binary(obj.complex('http://hl7.org/fhir/AuditEvent.entity.query'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/AuditEvent.entity.detail') do
      result.detailList.Add(parseAuditEventEntityDetail(item));
end;

procedure TFHIRTurtleComposer.ComposeAuditEventEntity(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAuditEventEntity; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:AuditEventEntity'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirReference}(this, 'AuditEvent.entity', 'what', elem.whatElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(this, 'AuditEvent.entity', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(this, 'AuditEvent.entity', 'role', elem.roleElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(this, 'AuditEvent.entity', 'lifecycle', elem.lifecycleElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.securityLabelList.Count - 1 do
      ComposeCoding(this, 'AuditEvent.entity', 'securityLabel', elem.securityLabelList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'AuditEvent.entity', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'AuditEvent.entity', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBase64Binary(this, 'AuditEvent.entity', 'query', elem.queryElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.detailList.Count - 1 do
      ComposeAuditEventEntityDetail(this, 'AuditEvent.entity', 'detail', elem.detailList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseAuditEventEntityDetail(obj : TTurtleComplex) : TFhirAuditEventEntityDetail;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAuditEventEntityDetail.create;
  try
    ParseAuditEventEntityDetailProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAuditEventEntityDetailProperties(obj : TTurtleComplex; result : TFhirAuditEventEntityDetail);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.type_Element := ParseString(obj.complex('http://hl7.org/fhir/AuditEvent.entity.detail.type'));{q1}
    if obj.has('http://hl7.org/fhir/AuditEvent.entity.detail.valueString', item) then
      result.value := parseString(item);
    if obj.has('http://hl7.org/fhir/AuditEvent.entity.detail.valueBase64Binary', item) then
      result.value := parseBase64Binary(item);
end;

procedure TFHIRTurtleComposer.ComposeAuditEventEntityDetail(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAuditEventEntityDetail; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:AuditEventEntityDetail'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeString(this, 'AuditEvent.entity.detail', 'type', elem.type_Element, false, -1);{x.2ea}
  if (elem.value is TFhirString) {6} then
    ComposeString(this, 'AuditEvent.entity.detail', 'valueString', TFhirString(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirBase64Binary) {6} then
    ComposeBase64Binary(this, 'AuditEvent.entity.detail', 'valueBase64Binary', TFhirBase64Binary(elem.value), false, -1);{x.d9}
end;

function TFHIRTurtleParser.ParseAuditEvent(obj : TTurtleComplex) : TFhirAuditEvent;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirAuditEvent.create;
  try
    ParseAuditEventProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseAuditEventProperties(obj : TTurtleComplex; result : TFhirAuditEvent);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.type_ := ParseCoding(obj.complex('http://hl7.org/fhir/AuditEvent.type'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/AuditEvent.subtype') do
      result.subtypeList.Add(parseCoding(item));
    result.actionElement := ParseEnum(obj.complex('http://hl7.org/fhir/AuditEvent.action'), CODES_TFhirAuditEventActionEnum, SYSTEMS_TFhirAuditEventActionEnum);
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/AuditEvent.period'));{q3b}
    result.recordedElement := ParseInstant(obj.complex('http://hl7.org/fhir/AuditEvent.recorded'));{q1}
    result.outcomeElement := ParseEnum(obj.complex('http://hl7.org/fhir/AuditEvent.outcome'), CODES_TFhirAuditEventOutcomeEnum, SYSTEMS_TFhirAuditEventOutcomeEnum);
    result.outcomeDescElement := ParseString(obj.complex('http://hl7.org/fhir/AuditEvent.outcomeDesc'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/AuditEvent.purposeOfEvent') do
      result.purposeOfEventList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/AuditEvent.agent') do
      result.agentList.Add(parseAuditEventAgent(item));
    result.source := ParseAuditEventSource(obj.complex('http://hl7.org/fhir/AuditEvent.source'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/AuditEvent.entity') do
      result.entityList.Add(parseAuditEventEntity(item));
end;

procedure TFHIRTurtleComposer.ComposeAuditEvent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirAuditEvent; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:AuditEvent'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  ComposeCoding(this, 'AuditEvent', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subtype') then
    for i := 0 to elem.subtypeList.Count - 1 do
      ComposeCoding(this, 'AuditEvent', 'subtype', elem.subtypeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('action') then
    ComposeEnum(this, 'AuditEvent', 'action', elem.ActionElement, CODES_TFhirAuditEventActionEnum, SYSTEMS_TFhirAuditEventActionEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('period') then
    ComposePeriod(this, 'AuditEvent', 'period', elem.periodElement, false, -1);{x.2f}
  ComposeInstant(this, 'AuditEvent', 'recorded', elem.recordedElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('outcome') then
    ComposeEnum(this, 'AuditEvent', 'outcome', elem.OutcomeElement, CODES_TFhirAuditEventOutcomeEnum, SYSTEMS_TFhirAuditEventOutcomeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('outcomeDesc') then
    ComposeString(this, 'AuditEvent', 'outcomeDesc', elem.outcomeDescElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('purposeOfEvent') then
    for i := 0 to elem.purposeOfEventList.Count - 1 do
      ComposeCodeableConcept(this, 'AuditEvent', 'purposeOfEvent', elem.purposeOfEventList[i], false, i);{x.d3}
  for i := 0 to elem.agentList.Count - 1 do
      ComposeAuditEventAgent(this, 'AuditEvent', 'agent', elem.agentList[i], false, i);{x.d3}
  ComposeAuditEventSource(this, 'AuditEvent', 'source', elem.sourceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('entity') then
    for i := 0 to elem.entityList.Count - 1 do
      ComposeAuditEventEntity(this, 'AuditEvent', 'entity', elem.entityList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_AUDITEVENT}
{$IFDEF FHIR_BASIC}
function TFHIRTurtleParser.ParseBasic(obj : TTurtleComplex) : TFhirBasic;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirBasic.create;
  try
    ParseBasicProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseBasicProperties(obj : TTurtleComplex; result : TFhirBasic);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Basic.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Basic.code'));{q3b}
    result.subject := ParseReference{TFhirReference}(obj.complex('http://hl7.org/fhir/Basic.subject'));{q3b}
    result.createdElement := ParseDate(obj.complex('http://hl7.org/fhir/Basic.created'));{q1}
    result.author := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/Basic.author'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeBasic(parent :  TTurtleComplex; parentType, name : String; elem : TFhirBasic; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Basic'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Basic', 'identifier', elem.identifierList[i], false, i);{x.d3}
  ComposeCodeableConcept(this, 'Basic', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{TFhirReference}(this, 'Basic', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('created') then
    ComposeDate(this, 'Basic', 'created', elem.createdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('author') then
    ComposeReference{TFhirPractitioner}(this, 'Basic', 'author', elem.authorElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_BASIC}
{$IFDEF FHIR_BINARY}
function TFHIRTurtleParser.ParseBinary(obj : TTurtleComplex) : TFhirBinary;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirBinary.create;
  try
    ParseBinaryProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseBinaryProperties(obj : TTurtleComplex; result : TFhirBinary);
begin
    ParseResourceProperties(obj, result);
    result.contentTypeElement := ParseCode(obj.complex('http://hl7.org/fhir/Binary.contentType'));{q1}
    result.securityContext := ParseReference{TFhirReference}(obj.complex('http://hl7.org/fhir/Binary.securityContext'));{q3b}
    result.dataElement := ParseBase64Binary(obj.complex('http://hl7.org/fhir/Binary.data'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeBinary(parent :  TTurtleComplex; parentType, name : String; elem : TFhirBinary; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Binary'); {z}
  end;
  composeResource(this, '', name, elem, false, index);
  ComposeCode(this, 'Binary', 'contentType', elem.contentTypeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('securityContext') then
    ComposeReference{TFhirReference}(this, 'Binary', 'securityContext', elem.securityContextElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('data') then
    ComposeBase64Binary(this, 'Binary', 'data', elem.dataElement, false, -1);{x.2ea}
end;

{$ENDIF FHIR_BINARY}
{$IFDEF FHIR_BIOLOGICALLYDERIVEDPRODUCT}
function TFHIRTurtleParser.ParseBiologicallyDerivedProductCollection(obj : TTurtleComplex) : TFhirBiologicallyDerivedProductCollection;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirBiologicallyDerivedProductCollection.create;
  try
    ParseBiologicallyDerivedProductCollectionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseBiologicallyDerivedProductCollectionProperties(obj : TTurtleComplex; result : TFhirBiologicallyDerivedProductCollection);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.collector := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/BiologicallyDerivedProduct.collection.collector'));{q3b}
    result.source := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/BiologicallyDerivedProduct.collection.source'));{q3b}
    if obj.has('http://hl7.org/fhir/BiologicallyDerivedProduct.collection.collectedPeriod', item) then
      result.collected := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/BiologicallyDerivedProduct.collection.collectedDateTime', item) then
      result.collected := parseDateTime(item);
end;

procedure TFHIRTurtleComposer.ComposeBiologicallyDerivedProductCollection(parent :  TTurtleComplex; parentType, name : String; elem : TFhirBiologicallyDerivedProductCollection; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:BiologicallyDerivedProductCollection'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirPractitioner}(this, 'BiologicallyDerivedProduct.collection', 'collector', elem.collectorElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirPatient}(this, 'BiologicallyDerivedProduct.collection', 'source', elem.sourceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and (elem.collected is TFhirPeriod) {6} then
    ComposePeriod(this, 'BiologicallyDerivedProduct.collection', 'collectedPeriod', TFhirPeriod(elem.collected), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.collected is TFhirDateTime) {6} then
    ComposeDateTime(this, 'BiologicallyDerivedProduct.collection', 'collectedDateTime', TFhirDateTime(elem.collected), false, -1);{x.d9}
end;

function TFHIRTurtleParser.ParseBiologicallyDerivedProductProcessing(obj : TTurtleComplex) : TFhirBiologicallyDerivedProductProcessing;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirBiologicallyDerivedProductProcessing.create;
  try
    ParseBiologicallyDerivedProductProcessingProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseBiologicallyDerivedProductProcessingProperties(obj : TTurtleComplex; result : TFhirBiologicallyDerivedProductProcessing);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/BiologicallyDerivedProduct.processing.description'));{q1}
    result.procedure_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/BiologicallyDerivedProduct.processing.procedure'));{q3b}
    result.additive := ParseReference{TFhirSubstance}(obj.complex('http://hl7.org/fhir/BiologicallyDerivedProduct.processing.additive'));{q3b}
    if obj.has('http://hl7.org/fhir/BiologicallyDerivedProduct.processing.timePeriod', item) then
      result.time := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/BiologicallyDerivedProduct.processing.timeDateTime', item) then
      result.time := parseDateTime(item);
end;

procedure TFHIRTurtleComposer.ComposeBiologicallyDerivedProductProcessing(parent :  TTurtleComplex; parentType, name : String; elem : TFhirBiologicallyDerivedProductProcessing; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:BiologicallyDerivedProductProcessing'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'BiologicallyDerivedProduct.processing', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'BiologicallyDerivedProduct.processing', 'procedure', elem.procedure_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirSubstance}(this, 'BiologicallyDerivedProduct.processing', 'additive', elem.additiveElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and (elem.time is TFhirPeriod) {6} then
    ComposePeriod(this, 'BiologicallyDerivedProduct.processing', 'timePeriod', TFhirPeriod(elem.time), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.time is TFhirDateTime) {6} then
    ComposeDateTime(this, 'BiologicallyDerivedProduct.processing', 'timeDateTime', TFhirDateTime(elem.time), false, -1);{x.d9}
end;

function TFHIRTurtleParser.ParseBiologicallyDerivedProductManipulation(obj : TTurtleComplex) : TFhirBiologicallyDerivedProductManipulation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirBiologicallyDerivedProductManipulation.create;
  try
    ParseBiologicallyDerivedProductManipulationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseBiologicallyDerivedProductManipulationProperties(obj : TTurtleComplex; result : TFhirBiologicallyDerivedProductManipulation);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/BiologicallyDerivedProduct.manipulation.description'));{q1}
    if obj.has('http://hl7.org/fhir/BiologicallyDerivedProduct.manipulation.timePeriod', item) then
      result.time := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/BiologicallyDerivedProduct.manipulation.timeDateTime', item) then
      result.time := parseDateTime(item);
end;

procedure TFHIRTurtleComposer.ComposeBiologicallyDerivedProductManipulation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirBiologicallyDerivedProductManipulation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:BiologicallyDerivedProductManipulation'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'BiologicallyDerivedProduct.manipulation', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and (elem.time is TFhirPeriod) {6} then
    ComposePeriod(this, 'BiologicallyDerivedProduct.manipulation', 'timePeriod', TFhirPeriod(elem.time), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.time is TFhirDateTime) {6} then
    ComposeDateTime(this, 'BiologicallyDerivedProduct.manipulation', 'timeDateTime', TFhirDateTime(elem.time), false, -1);{x.d9}
end;

function TFHIRTurtleParser.ParseBiologicallyDerivedProductStorage(obj : TTurtleComplex) : TFhirBiologicallyDerivedProductStorage;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirBiologicallyDerivedProductStorage.create;
  try
    ParseBiologicallyDerivedProductStorageProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseBiologicallyDerivedProductStorageProperties(obj : TTurtleComplex; result : TFhirBiologicallyDerivedProductStorage);
begin
    ParseBackboneElementProperties(obj, result);
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/BiologicallyDerivedProduct.storage.description'));{q1}
    result.temperatureElement := ParseDecimal(obj.complex('http://hl7.org/fhir/BiologicallyDerivedProduct.storage.temperature'));{q1}
    result.scaleElement := ParseEnum(obj.complex('http://hl7.org/fhir/BiologicallyDerivedProduct.storage.scale'), CODES_TFhirProductStorageScaleEnum, SYSTEMS_TFhirProductStorageScaleEnum);
    result.duration := ParsePeriod(obj.complex('http://hl7.org/fhir/BiologicallyDerivedProduct.storage.duration'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeBiologicallyDerivedProductStorage(parent :  TTurtleComplex; parentType, name : String; elem : TFhirBiologicallyDerivedProductStorage; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:BiologicallyDerivedProductStorage'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'BiologicallyDerivedProduct.storage', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'BiologicallyDerivedProduct.storage', 'temperature', elem.temperatureElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'BiologicallyDerivedProduct.storage', 'scale', elem.ScaleElement, CODES_TFhirProductStorageScaleEnum, SYSTEMS_TFhirProductStorageScaleEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'BiologicallyDerivedProduct.storage', 'duration', elem.durationElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseBiologicallyDerivedProduct(obj : TTurtleComplex) : TFhirBiologicallyDerivedProduct;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirBiologicallyDerivedProduct.create;
  try
    ParseBiologicallyDerivedProductProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseBiologicallyDerivedProductProperties(obj : TTurtleComplex; result : TFhirBiologicallyDerivedProduct);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/BiologicallyDerivedProduct.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.productCategoryElement := ParseEnum(obj.complex('http://hl7.org/fhir/BiologicallyDerivedProduct.productCategory'), CODES_TFhirProductCategoryEnum, SYSTEMS_TFhirProductCategoryEnum);
    result.productCode := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/BiologicallyDerivedProduct.productCode'));{q3b}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/BiologicallyDerivedProduct.status'), CODES_TFhirProductStatusEnum, SYSTEMS_TFhirProductStatusEnum);
    for item in obj.complexes('http://hl7.org/fhir/BiologicallyDerivedProduct.request') do
      result.requestList.Add(parseReference{TFhirServiceRequest}(item));
    result.quantityElement := ParseInteger(obj.complex('http://hl7.org/fhir/BiologicallyDerivedProduct.quantity'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/BiologicallyDerivedProduct.parent') do
      result.parentList.Add(parseReference{TFhirBiologicallyDerivedProduct}(item));
    result.collection := ParseBiologicallyDerivedProductCollection(obj.complex('http://hl7.org/fhir/BiologicallyDerivedProduct.collection'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/BiologicallyDerivedProduct.processing') do
      result.processingList.Add(parseBiologicallyDerivedProductProcessing(item));
    result.manipulation := ParseBiologicallyDerivedProductManipulation(obj.complex('http://hl7.org/fhir/BiologicallyDerivedProduct.manipulation'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/BiologicallyDerivedProduct.storage') do
      result.storageList.Add(parseBiologicallyDerivedProductStorage(item));
end;

procedure TFHIRTurtleComposer.ComposeBiologicallyDerivedProduct(parent :  TTurtleComplex; parentType, name : String; elem : TFhirBiologicallyDerivedProduct; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:BiologicallyDerivedProduct'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'BiologicallyDerivedProduct', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('productCategory') then
    ComposeEnum(this, 'BiologicallyDerivedProduct', 'productCategory', elem.ProductCategoryElement, CODES_TFhirProductCategoryEnum, SYSTEMS_TFhirProductCategoryEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('productCode') then
    ComposeCodeableConcept(this, 'BiologicallyDerivedProduct', 'productCode', elem.productCodeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('status') then
    ComposeEnum(this, 'BiologicallyDerivedProduct', 'status', elem.StatusElement, CODES_TFhirProductStatusEnum, SYSTEMS_TFhirProductStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('request') then
    for i := 0 to elem.requestList.Count - 1 do
      ComposeReference{TFhirServiceRequest}(this, 'BiologicallyDerivedProduct', 'request', elem.requestList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('quantity') then
    ComposeInteger(this, 'BiologicallyDerivedProduct', 'quantity', elem.quantityElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('parent') then
    for i := 0 to elem.parentList.Count - 1 do
      ComposeReference{TFhirBiologicallyDerivedProduct}(this, 'BiologicallyDerivedProduct', 'parent', elem.parentList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('collection') then
    ComposeBiologicallyDerivedProductCollection(this, 'BiologicallyDerivedProduct', 'collection', elem.collectionElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('processing') then
    for i := 0 to elem.processingList.Count - 1 do
      ComposeBiologicallyDerivedProductProcessing(this, 'BiologicallyDerivedProduct', 'processing', elem.processingList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('manipulation') then
    ComposeBiologicallyDerivedProductManipulation(this, 'BiologicallyDerivedProduct', 'manipulation', elem.manipulationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('storage') then
    for i := 0 to elem.storageList.Count - 1 do
      ComposeBiologicallyDerivedProductStorage(this, 'BiologicallyDerivedProduct', 'storage', elem.storageList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_BIOLOGICALLYDERIVEDPRODUCT}
{$IFDEF FHIR_BODYSTRUCTURE}
function TFHIRTurtleParser.ParseBodyStructure(obj : TTurtleComplex) : TFhirBodyStructure;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirBodyStructure.create;
  try
    ParseBodyStructureProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseBodyStructureProperties(obj : TTurtleComplex; result : TFhirBodyStructure);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/BodyStructure.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.activeElement := ParseBoolean(obj.complex('http://hl7.org/fhir/BodyStructure.active'));{q1}
    result.morphology := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/BodyStructure.morphology'));{q3b}
    result.location := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/BodyStructure.location'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/BodyStructure.locationQualifier') do
      result.locationQualifierList.Add(parseCodeableConcept(item));
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/BodyStructure.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/BodyStructure.image') do
      result.imageList.Add(parseAttachment(item));
    result.patient := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/BodyStructure.patient'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeBodyStructure(parent :  TTurtleComplex; parentType, name : String; elem : TFhirBodyStructure; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:BodyStructure'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'BodyStructure', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('active') then
    ComposeBoolean(this, 'BodyStructure', 'active', elem.activeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('morphology') then
    ComposeCodeableConcept(this, 'BodyStructure', 'morphology', elem.morphologyElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('location') then
    ComposeCodeableConcept(this, 'BodyStructure', 'location', elem.locationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('locationQualifier') then
    for i := 0 to elem.locationQualifierList.Count - 1 do
      ComposeCodeableConcept(this, 'BodyStructure', 'locationQualifier', elem.locationQualifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeString(this, 'BodyStructure', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('image') then
    for i := 0 to elem.imageList.Count - 1 do
      ComposeAttachment(this, 'BodyStructure', 'image', elem.imageList[i], false, i);{x.d3}
  ComposeReference{TFhirPatient}(this, 'BodyStructure', 'patient', elem.patientElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_BODYSTRUCTURE}
{$IFDEF FHIR_BUNDLE}
function TFHIRTurtleParser.ParseBundleLink(obj : TTurtleComplex) : TFhirBundleLink;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirBundleLink.create;
  try
    ParseBundleLinkProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseBundleLinkProperties(obj : TTurtleComplex; result : TFhirBundleLink);
begin
    ParseBackboneElementProperties(obj, result);
    result.relationElement := ParseString(obj.complex('http://hl7.org/fhir/Bundle.link.relation'));{q1}
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/Bundle.link.url'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeBundleLink(parent :  TTurtleComplex; parentType, name : String; elem : TFhirBundleLink; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:BundleLink'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeString(this, 'Bundle.link', 'relation', elem.relationElement, false, -1);{x.2ea}
  ComposeUri(this, 'Bundle.link', 'url', elem.urlElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseBundleEntry(obj : TTurtleComplex) : TFhirBundleEntry;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirBundleEntry.create;
  try
    ParseBundleEntryProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseBundleEntryProperties(obj : TTurtleComplex; result : TFhirBundleEntry);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Bundle.entry.link') do
      result.link_List.Add(parseBundleLink(item));
    result.fullUrlElement := ParseUri(obj.complex('http://hl7.org/fhir/Bundle.entry.fullUrl'));{q1}
    result.resource := ParseInnerResource(obj.predicate('http://hl7.org/fhir/Bundle.entry.resource'));{q3a}
    result.search := ParseBundleEntrySearch(obj.complex('http://hl7.org/fhir/Bundle.entry.search'));{q3b}
    result.request := ParseBundleEntryRequest(obj.complex('http://hl7.org/fhir/Bundle.entry.request'));{q3b}
    result.response := ParseBundleEntryResponse(obj.complex('http://hl7.org/fhir/Bundle.entry.response'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeBundleEntry(parent :  TTurtleComplex; parentType, name : String; elem : TFhirBundleEntry; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:BundleEntry'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.link_List.Count - 1 do
      ComposeBundleLink(this, 'Bundle.entry', 'link', elem.link_List[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUri(this, 'Bundle.entry', 'fullUrl', elem.fullUrlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInnerResource(this, 'Bundle.entry', 'resource', elem.resourceElement, false, -1);{x.2ec}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBundleEntrySearch(this, 'Bundle.entry', 'search', elem.searchElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBundleEntryRequest(this, 'Bundle.entry', 'request', elem.requestElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBundleEntryResponse(this, 'Bundle.entry', 'response', elem.responseElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseBundleEntrySearch(obj : TTurtleComplex) : TFhirBundleEntrySearch;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirBundleEntrySearch.create;
  try
    ParseBundleEntrySearchProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseBundleEntrySearchProperties(obj : TTurtleComplex; result : TFhirBundleEntrySearch);
begin
    ParseBackboneElementProperties(obj, result);
    result.modeElement := ParseEnum(obj.complex('http://hl7.org/fhir/Bundle.entry.search.mode'), CODES_TFhirSearchEntryModeEnum, SYSTEMS_TFhirSearchEntryModeEnum);
    result.scoreElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Bundle.entry.search.score'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeBundleEntrySearch(parent :  TTurtleComplex; parentType, name : String; elem : TFhirBundleEntrySearch; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:BundleEntrySearch'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeEnum(this, 'Bundle.entry.search', 'mode', elem.ModeElement, CODES_TFhirSearchEntryModeEnum, SYSTEMS_TFhirSearchEntryModeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDecimal(this, 'Bundle.entry.search', 'score', elem.scoreElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseBundleEntryRequest(obj : TTurtleComplex) : TFhirBundleEntryRequest;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirBundleEntryRequest.create;
  try
    ParseBundleEntryRequestProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseBundleEntryRequestProperties(obj : TTurtleComplex; result : TFhirBundleEntryRequest);
begin
    ParseBackboneElementProperties(obj, result);
    result.methodElement := ParseEnum(obj.complex('http://hl7.org/fhir/Bundle.entry.request.method'), CODES_TFhirHttpVerbEnum, SYSTEMS_TFhirHttpVerbEnum);
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/Bundle.entry.request.url'));{q1}
    result.ifNoneMatchElement := ParseString(obj.complex('http://hl7.org/fhir/Bundle.entry.request.ifNoneMatch'));{q1}
    result.ifModifiedSinceElement := ParseInstant(obj.complex('http://hl7.org/fhir/Bundle.entry.request.ifModifiedSince'));{q1}
    result.ifMatchElement := ParseString(obj.complex('http://hl7.org/fhir/Bundle.entry.request.ifMatch'));{q1}
    result.ifNoneExistElement := ParseString(obj.complex('http://hl7.org/fhir/Bundle.entry.request.ifNoneExist'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeBundleEntryRequest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirBundleEntryRequest; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:BundleEntryRequest'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'Bundle.entry.request', 'method', elem.MethodElement, CODES_TFhirHttpVerbEnum, SYSTEMS_TFhirHttpVerbEnum, false, -1);{x.d4}
  ComposeUri(this, 'Bundle.entry.request', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'Bundle.entry.request', 'ifNoneMatch', elem.ifNoneMatchElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInstant(this, 'Bundle.entry.request', 'ifModifiedSince', elem.ifModifiedSinceElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'Bundle.entry.request', 'ifMatch', elem.ifMatchElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'Bundle.entry.request', 'ifNoneExist', elem.ifNoneExistElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseBundleEntryResponse(obj : TTurtleComplex) : TFhirBundleEntryResponse;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirBundleEntryResponse.create;
  try
    ParseBundleEntryResponseProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseBundleEntryResponseProperties(obj : TTurtleComplex; result : TFhirBundleEntryResponse);
begin
    ParseBackboneElementProperties(obj, result);
    result.statusElement := ParseString(obj.complex('http://hl7.org/fhir/Bundle.entry.response.status'));{q1}
    result.locationElement := ParseUri(obj.complex('http://hl7.org/fhir/Bundle.entry.response.location'));{q1}
    result.etagElement := ParseString(obj.complex('http://hl7.org/fhir/Bundle.entry.response.etag'));{q1}
    result.lastModifiedElement := ParseInstant(obj.complex('http://hl7.org/fhir/Bundle.entry.response.lastModified'));{q1}
    result.outcome := ParseInnerResource(obj.predicate('http://hl7.org/fhir/Bundle.entry.response.outcome'));{q3a}
end;

procedure TFHIRTurtleComposer.ComposeBundleEntryResponse(parent :  TTurtleComplex; parentType, name : String; elem : TFhirBundleEntryResponse; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:BundleEntryResponse'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeString(this, 'Bundle.entry.response', 'status', elem.statusElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUri(this, 'Bundle.entry.response', 'location', elem.locationElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(this, 'Bundle.entry.response', 'etag', elem.etagElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInstant(this, 'Bundle.entry.response', 'lastModified', elem.lastModifiedElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInnerResource(this, 'Bundle.entry.response', 'outcome', elem.outcomeElement, false, -1);{x.2ec}
end;

function TFHIRTurtleParser.ParseBundle(obj : TTurtleComplex) : TFhirBundle;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirBundle.create;
  try
    ParseBundleProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseBundleProperties(obj : TTurtleComplex; result : TFhirBundle);
var
  item : TTurtleComplex;
begin
    ParseResourceProperties(obj, result);
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/Bundle.identifier'));{q3b}
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/Bundle.type'), CODES_TFhirBundleTypeEnum, SYSTEMS_TFhirBundleTypeEnum);
    result.timestampElement := ParseInstant(obj.complex('http://hl7.org/fhir/Bundle.timestamp'));{q1}
    result.totalElement := ParseUnsignedInt(obj.complex('http://hl7.org/fhir/Bundle.total'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Bundle.link') do
      result.link_List.Add(parseBundleLink(item));
    for item in obj.complexes('http://hl7.org/fhir/Bundle.entry') do
      result.entryList.Add(parseBundleEntry(item));
    result.signature := ParseSignature(obj.complex('http://hl7.org/fhir/Bundle.signature'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeBundle(parent :  TTurtleComplex; parentType, name : String; elem : TFhirBundle; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Bundle'); {z}
  end;
  composeResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeIdentifier(this, 'Bundle', 'identifier', elem.identifierElement, false, -1);{x.2f}
  ComposeEnum(this, 'Bundle', 'type', elem.Type_Element, CODES_TFhirBundleTypeEnum, SYSTEMS_TFhirBundleTypeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInstant(this, 'Bundle', 'timestamp', elem.timestampElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData, soCount]) then
    ComposeUnsignedInt(this, 'Bundle', 'total', elem.totalElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.link_List.Count - 1 do
      ComposeBundleLink(this, 'Bundle', 'link', elem.link_List[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.entryList.Count - 1 do
      ComposeBundleEntry(this, 'Bundle', 'entry', elem.entryList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeSignature(this, 'Bundle', 'signature', elem.signatureElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_BUNDLE}
{$IFDEF FHIR_CAPABILITYSTATEMENT}
function TFHIRTurtleParser.ParseCapabilityStatementSoftware(obj : TTurtleComplex) : TFhirCapabilityStatementSoftware;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCapabilityStatementSoftware.create;
  try
    ParseCapabilityStatementSoftwareProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCapabilityStatementSoftwareProperties(obj : TTurtleComplex; result : TFhirCapabilityStatementSoftware);
begin
    ParseBackboneElementProperties(obj, result);
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/CapabilityStatement.software.name'));{q1}
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/CapabilityStatement.software.version'));{q1}
    result.releaseDateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/CapabilityStatement.software.releaseDate'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeCapabilityStatementSoftware(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCapabilityStatementSoftware; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CapabilityStatementSoftware'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeString(this, 'CapabilityStatement.software', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'CapabilityStatement.software', 'version', elem.versionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'CapabilityStatement.software', 'releaseDate', elem.releaseDateElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseCapabilityStatementImplementation(obj : TTurtleComplex) : TFhirCapabilityStatementImplementation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCapabilityStatementImplementation.create;
  try
    ParseCapabilityStatementImplementationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCapabilityStatementImplementationProperties(obj : TTurtleComplex; result : TFhirCapabilityStatementImplementation);
begin
    ParseBackboneElementProperties(obj, result);
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/CapabilityStatement.implementation.description'));{q1}
    result.urlElement := ParseUrl(obj.complex('http://hl7.org/fhir/CapabilityStatement.implementation.url'));{q1}
    result.custodian := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/CapabilityStatement.implementation.custodian'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeCapabilityStatementImplementation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCapabilityStatementImplementation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CapabilityStatementImplementation'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeString(this, 'CapabilityStatement.implementation', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUrl(this, 'CapabilityStatement.implementation', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(this, 'CapabilityStatement.implementation', 'custodian', elem.custodianElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseCapabilityStatementRest(obj : TTurtleComplex) : TFhirCapabilityStatementRest;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCapabilityStatementRest.create;
  try
    ParseCapabilityStatementRestProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCapabilityStatementRestProperties(obj : TTurtleComplex; result : TFhirCapabilityStatementRest);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.modeElement := ParseEnum(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.mode'), CODES_TFhirRestfulCapabilityModeEnum, SYSTEMS_TFhirRestfulCapabilityModeEnum);
    result.documentationElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.documentation'));{q1}
    result.security := ParseCapabilityStatementRestSecurity(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.security'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.rest.resource') do
      result.resourceList.Add(parseCapabilityStatementRestResource(item));
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.rest.interaction') do
      result.interactionList.Add(parseCapabilityStatementRestInteraction(item));
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.rest.searchParam') do
      result.searchParamList.Add(parseCapabilityStatementRestResourceSearchParam(item));
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.rest.operation') do
      result.operationList.Add(parseCapabilityStatementRestResourceOperation(item));
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.rest.compartment') do
      result.compartmentList.Add(parseCanonical(item));
end;

procedure TFHIRTurtleComposer.ComposeCapabilityStatementRest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCapabilityStatementRest; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CapabilityStatementRest'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'CapabilityStatement.rest', 'mode', elem.ModeElement, CODES_TFhirRestfulCapabilityModeEnum, SYSTEMS_TFhirRestfulCapabilityModeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'CapabilityStatement.rest', 'documentation', elem.documentationElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCapabilityStatementRestSecurity(this, 'CapabilityStatement.rest', 'security', elem.securityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.resourceList.Count - 1 do
      ComposeCapabilityStatementRestResource(this, 'CapabilityStatement.rest', 'resource', elem.resourceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.interactionList.Count - 1 do
      ComposeCapabilityStatementRestInteraction(this, 'CapabilityStatement.rest', 'interaction', elem.interactionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.searchParamList.Count - 1 do
      ComposeCapabilityStatementRestResourceSearchParam(this, 'CapabilityStatement.rest', 'searchParam', elem.searchParamList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.operationList.Count - 1 do
      ComposeCapabilityStatementRestResourceOperation(this, 'CapabilityStatement.rest', 'operation', elem.operationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.compartmentList.Count - 1 do
      ComposeCanonical(this, 'CapabilityStatement.rest', 'compartment', elem.compartmentList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseCapabilityStatementRestSecurity(obj : TTurtleComplex) : TFhirCapabilityStatementRestSecurity;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCapabilityStatementRestSecurity.create;
  try
    ParseCapabilityStatementRestSecurityProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCapabilityStatementRestSecurityProperties(obj : TTurtleComplex; result : TFhirCapabilityStatementRestSecurity);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.corsElement := ParseBoolean(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.security.cors'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.rest.security.service') do
      result.serviceList.Add(parseCodeableConcept(item));
    result.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.security.description'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeCapabilityStatementRestSecurity(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCapabilityStatementRestSecurity; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CapabilityStatementRestSecurity'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'CapabilityStatement.rest.security', 'cors', elem.corsElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.serviceList.Count - 1 do
      ComposeCodeableConcept(this, 'CapabilityStatement.rest.security', 'service', elem.serviceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'CapabilityStatement.rest.security', 'description', elem.descriptionElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseCapabilityStatementRestResource(obj : TTurtleComplex) : TFhirCapabilityStatementRestResource;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCapabilityStatementRestResource.create;
  try
    ParseCapabilityStatementRestResourceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCapabilityStatementRestResourceProperties(obj : TTurtleComplex; result : TFhirCapabilityStatementRestResource);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.resource.type'), CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum);
    result.profileElement := ParseCanonical(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.resource.profile'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.rest.resource.supportedProfile') do
      result.supportedProfileList.Add(parseCanonical(item));
    result.documentationElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.resource.documentation'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.rest.resource.interaction') do
      result.interactionList.Add(parseCapabilityStatementRestResourceInteraction(item));
    result.versioningElement := ParseEnum(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.resource.versioning'), CODES_TFhirVersioningPolicyEnum, SYSTEMS_TFhirVersioningPolicyEnum);
    result.readHistoryElement := ParseBoolean(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.resource.readHistory'));{q1}
    result.updateCreateElement := ParseBoolean(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.resource.updateCreate'));{q1}
    result.conditionalCreateElement := ParseBoolean(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.resource.conditionalCreate'));{q1}
    result.conditionalReadElement := ParseEnum(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.resource.conditionalRead'), CODES_TFhirConditionalReadStatusEnum, SYSTEMS_TFhirConditionalReadStatusEnum);
    result.conditionalUpdateElement := ParseBoolean(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.resource.conditionalUpdate'));{q1}
    result.conditionalDeleteElement := ParseEnum(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.resource.conditionalDelete'), CODES_TFhirConditionalDeleteStatusEnum, SYSTEMS_TFhirConditionalDeleteStatusEnum);
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.rest.resource.referencePolicy') do
      result.referencePolicyList.Add(parseEnum(item, CODES_TFhirReferenceHandlingPolicyEnum, SYSTEMS_TFhirReferenceHandlingPolicyEnum));
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.rest.resource.searchInclude') do
      result.searchIncludeList.Add(parseString(item));
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.rest.resource.searchRevInclude') do
      result.searchRevIncludeList.Add(parseString(item));
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.rest.resource.searchParam') do
      result.searchParamList.Add(parseCapabilityStatementRestResourceSearchParam(item));
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.rest.resource.operation') do
      result.operationList.Add(parseCapabilityStatementRestResourceOperation(item));
end;

procedure TFHIRTurtleComposer.ComposeCapabilityStatementRestResource(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCapabilityStatementRestResource; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CapabilityStatementRestResource'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'CapabilityStatement.rest.resource', 'type', elem.Type_Element, CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCanonical(this, 'CapabilityStatement.rest.resource', 'profile', elem.profileElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.supportedProfileList.Count - 1 do
      ComposeCanonical(this, 'CapabilityStatement.rest.resource', 'supportedProfile', elem.supportedProfileList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'CapabilityStatement.rest.resource', 'documentation', elem.documentationElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.interactionList.Count - 1 do
      ComposeCapabilityStatementRestResourceInteraction(this, 'CapabilityStatement.rest.resource', 'interaction', elem.interactionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'CapabilityStatement.rest.resource', 'versioning', elem.VersioningElement, CODES_TFhirVersioningPolicyEnum, SYSTEMS_TFhirVersioningPolicyEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'CapabilityStatement.rest.resource', 'readHistory', elem.readHistoryElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'CapabilityStatement.rest.resource', 'updateCreate', elem.updateCreateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'CapabilityStatement.rest.resource', 'conditionalCreate', elem.conditionalCreateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'CapabilityStatement.rest.resource', 'conditionalRead', elem.ConditionalReadElement, CODES_TFhirConditionalReadStatusEnum, SYSTEMS_TFhirConditionalReadStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'CapabilityStatement.rest.resource', 'conditionalUpdate', elem.conditionalUpdateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'CapabilityStatement.rest.resource', 'conditionalDelete', elem.ConditionalDeleteElement, CODES_TFhirConditionalDeleteStatusEnum, SYSTEMS_TFhirConditionalDeleteStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.referencePolicyList.Count - 1 do
      ComposeEnum(this, 'CapabilityStatement.rest.resource', 'referencePolicy', elem.referencePolicyList[i], CODES_TFhirReferenceHandlingPolicyEnum, SYSTEMS_TFhirReferenceHandlingPolicyEnum, false, i); {x.d1}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.referencePolicyList.Count - 1 do
      ComposeEnum(this, 'CapabilityStatement.rest.resource', 'referencePolicy', elem.referencePolicyList[i], CODES_TFhirReferenceHandlingPolicyEnum, SYSTEMS_TFhirReferenceHandlingPolicyEnum, false, i);{x.d2}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.searchIncludeList.Count - 1 do
      ComposeString(this, 'CapabilityStatement.rest.resource', 'searchInclude', elem.searchIncludeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.searchRevIncludeList.Count - 1 do
      ComposeString(this, 'CapabilityStatement.rest.resource', 'searchRevInclude', elem.searchRevIncludeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.searchParamList.Count - 1 do
      ComposeCapabilityStatementRestResourceSearchParam(this, 'CapabilityStatement.rest.resource', 'searchParam', elem.searchParamList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.operationList.Count - 1 do
      ComposeCapabilityStatementRestResourceOperation(this, 'CapabilityStatement.rest.resource', 'operation', elem.operationList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseCapabilityStatementRestResourceInteraction(obj : TTurtleComplex) : TFhirCapabilityStatementRestResourceInteraction;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCapabilityStatementRestResourceInteraction.create;
  try
    ParseCapabilityStatementRestResourceInteractionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCapabilityStatementRestResourceInteractionProperties(obj : TTurtleComplex; result : TFhirCapabilityStatementRestResourceInteraction);
begin
    ParseBackboneElementProperties(obj, result);
    result.codeElement := ParseEnum(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.resource.interaction.code'), CODES_TFhirTypeRestfulInteractionEnum, SYSTEMS_TFhirTypeRestfulInteractionEnum);
    result.documentationElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.resource.interaction.documentation'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeCapabilityStatementRestResourceInteraction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCapabilityStatementRestResourceInteraction; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CapabilityStatementRestResourceInteraction'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'CapabilityStatement.rest.resource.interaction', 'code', elem.CodeElement, CODES_TFhirTypeRestfulInteractionEnum, SYSTEMS_TFhirTypeRestfulInteractionEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'CapabilityStatement.rest.resource.interaction', 'documentation', elem.documentationElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseCapabilityStatementRestResourceSearchParam(obj : TTurtleComplex) : TFhirCapabilityStatementRestResourceSearchParam;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCapabilityStatementRestResourceSearchParam.create;
  try
    ParseCapabilityStatementRestResourceSearchParamProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCapabilityStatementRestResourceSearchParamProperties(obj : TTurtleComplex; result : TFhirCapabilityStatementRestResourceSearchParam);
begin
    ParseBackboneElementProperties(obj, result);
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.resource.searchParam.name'));{q1}
    result.definitionElement := ParseCanonical(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.resource.searchParam.definition'));{q1}
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.resource.searchParam.type'), CODES_TFhirSearchParamTypeEnum, SYSTEMS_TFhirSearchParamTypeEnum);
    result.documentationElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.resource.searchParam.documentation'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeCapabilityStatementRestResourceSearchParam(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCapabilityStatementRestResourceSearchParam; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CapabilityStatementRestResourceSearchParam'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeString(this, 'CapabilityStatement.rest.resource.searchParam', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(this, 'CapabilityStatement.rest.resource.searchParam', 'definition', elem.definitionElement, false, -1);{x.2ea}
  ComposeEnum(this, 'CapabilityStatement.rest.resource.searchParam', 'type', elem.Type_Element, CODES_TFhirSearchParamTypeEnum, SYSTEMS_TFhirSearchParamTypeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'CapabilityStatement.rest.resource.searchParam', 'documentation', elem.documentationElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseCapabilityStatementRestResourceOperation(obj : TTurtleComplex) : TFhirCapabilityStatementRestResourceOperation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCapabilityStatementRestResourceOperation.create;
  try
    ParseCapabilityStatementRestResourceOperationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCapabilityStatementRestResourceOperationProperties(obj : TTurtleComplex; result : TFhirCapabilityStatementRestResourceOperation);
begin
    ParseBackboneElementProperties(obj, result);
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.resource.operation.name'));{q1}
    result.definitionElement := ParseCanonical(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.resource.operation.definition'));{q1}
    result.documentationElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.resource.operation.documentation'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeCapabilityStatementRestResourceOperation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCapabilityStatementRestResourceOperation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CapabilityStatementRestResourceOperation'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeString(this, 'CapabilityStatement.rest.resource.operation', 'name', elem.nameElement, false, -1);{x.2ea}
  ComposeCanonical(this, 'CapabilityStatement.rest.resource.operation', 'definition', elem.definitionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'CapabilityStatement.rest.resource.operation', 'documentation', elem.documentationElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseCapabilityStatementRestInteraction(obj : TTurtleComplex) : TFhirCapabilityStatementRestInteraction;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCapabilityStatementRestInteraction.create;
  try
    ParseCapabilityStatementRestInteractionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCapabilityStatementRestInteractionProperties(obj : TTurtleComplex; result : TFhirCapabilityStatementRestInteraction);
begin
    ParseBackboneElementProperties(obj, result);
    result.codeElement := ParseEnum(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.interaction.code'), CODES_TFhirSystemRestfulInteractionEnum, SYSTEMS_TFhirSystemRestfulInteractionEnum);
    result.documentationElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/CapabilityStatement.rest.interaction.documentation'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeCapabilityStatementRestInteraction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCapabilityStatementRestInteraction; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CapabilityStatementRestInteraction'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'CapabilityStatement.rest.interaction', 'code', elem.CodeElement, CODES_TFhirSystemRestfulInteractionEnum, SYSTEMS_TFhirSystemRestfulInteractionEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'CapabilityStatement.rest.interaction', 'documentation', elem.documentationElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseCapabilityStatementMessaging(obj : TTurtleComplex) : TFhirCapabilityStatementMessaging;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCapabilityStatementMessaging.create;
  try
    ParseCapabilityStatementMessagingProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCapabilityStatementMessagingProperties(obj : TTurtleComplex; result : TFhirCapabilityStatementMessaging);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.messaging.endpoint') do
      result.endpointList.Add(parseCapabilityStatementMessagingEndpoint(item));
    result.reliableCacheElement := ParseUnsignedInt(obj.complex('http://hl7.org/fhir/CapabilityStatement.messaging.reliableCache'));{q1}
    result.documentationElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/CapabilityStatement.messaging.documentation'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.messaging.supportedMessage') do
      result.supportedMessageList.Add(parseCapabilityStatementMessagingSupportedMessage(item));
end;

procedure TFHIRTurtleComposer.ComposeCapabilityStatementMessaging(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCapabilityStatementMessaging; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CapabilityStatementMessaging'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.endpointList.Count - 1 do
      ComposeCapabilityStatementMessagingEndpoint(this, 'CapabilityStatement.messaging', 'endpoint', elem.endpointList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeUnsignedInt(this, 'CapabilityStatement.messaging', 'reliableCache', elem.reliableCacheElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'CapabilityStatement.messaging', 'documentation', elem.documentationElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.supportedMessageList.Count - 1 do
      ComposeCapabilityStatementMessagingSupportedMessage(this, 'CapabilityStatement.messaging', 'supportedMessage', elem.supportedMessageList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseCapabilityStatementMessagingEndpoint(obj : TTurtleComplex) : TFhirCapabilityStatementMessagingEndpoint;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCapabilityStatementMessagingEndpoint.create;
  try
    ParseCapabilityStatementMessagingEndpointProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCapabilityStatementMessagingEndpointProperties(obj : TTurtleComplex; result : TFhirCapabilityStatementMessagingEndpoint);
begin
    ParseBackboneElementProperties(obj, result);
    result.protocol := ParseCoding(obj.complex('http://hl7.org/fhir/CapabilityStatement.messaging.endpoint.protocol'));{q3b}
    result.addressElement := ParseUrl(obj.complex('http://hl7.org/fhir/CapabilityStatement.messaging.endpoint.address'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeCapabilityStatementMessagingEndpoint(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCapabilityStatementMessagingEndpoint; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CapabilityStatementMessagingEndpoint'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCoding(this, 'CapabilityStatement.messaging.endpoint', 'protocol', elem.protocolElement, false, -1);{x.2f}
  ComposeUrl(this, 'CapabilityStatement.messaging.endpoint', 'address', elem.addressElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseCapabilityStatementMessagingSupportedMessage(obj : TTurtleComplex) : TFhirCapabilityStatementMessagingSupportedMessage;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCapabilityStatementMessagingSupportedMessage.create;
  try
    ParseCapabilityStatementMessagingSupportedMessageProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCapabilityStatementMessagingSupportedMessageProperties(obj : TTurtleComplex; result : TFhirCapabilityStatementMessagingSupportedMessage);
begin
    ParseBackboneElementProperties(obj, result);
    result.modeElement := ParseEnum(obj.complex('http://hl7.org/fhir/CapabilityStatement.messaging.supportedMessage.mode'), CODES_TFhirEventCapabilityModeEnum, SYSTEMS_TFhirEventCapabilityModeEnum);
    result.definitionElement := ParseCanonical(obj.complex('http://hl7.org/fhir/CapabilityStatement.messaging.supportedMessage.definition'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeCapabilityStatementMessagingSupportedMessage(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCapabilityStatementMessagingSupportedMessage; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CapabilityStatementMessagingSupportedMessage'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'CapabilityStatement.messaging.supportedMessage', 'mode', elem.ModeElement, CODES_TFhirEventCapabilityModeEnum, SYSTEMS_TFhirEventCapabilityModeEnum, false, -1);{x.d4}
  ComposeCanonical(this, 'CapabilityStatement.messaging.supportedMessage', 'definition', elem.definitionElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseCapabilityStatementDocument(obj : TTurtleComplex) : TFhirCapabilityStatementDocument;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCapabilityStatementDocument.create;
  try
    ParseCapabilityStatementDocumentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCapabilityStatementDocumentProperties(obj : TTurtleComplex; result : TFhirCapabilityStatementDocument);
begin
    ParseBackboneElementProperties(obj, result);
    result.modeElement := ParseEnum(obj.complex('http://hl7.org/fhir/CapabilityStatement.document.mode'), CODES_TFhirDocumentModeEnum, SYSTEMS_TFhirDocumentModeEnum);
    result.documentationElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/CapabilityStatement.document.documentation'));{q1}
    result.profileElement := ParseCanonical(obj.complex('http://hl7.org/fhir/CapabilityStatement.document.profile'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeCapabilityStatementDocument(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCapabilityStatementDocument; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CapabilityStatementDocument'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'CapabilityStatement.document', 'mode', elem.ModeElement, CODES_TFhirDocumentModeEnum, SYSTEMS_TFhirDocumentModeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'CapabilityStatement.document', 'documentation', elem.documentationElement, false, -1);{x.2ea}
  ComposeCanonical(this, 'CapabilityStatement.document', 'profile', elem.profileElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseCapabilityStatement(obj : TTurtleComplex) : TFhirCapabilityStatement;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCapabilityStatement.create;
  try
    ParseCapabilityStatementProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCapabilityStatementProperties(obj : TTurtleComplex; result : TFhirCapabilityStatement);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/CapabilityStatement.url'));{q1}
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/CapabilityStatement.version'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/CapabilityStatement.name'));{q1}
    result.titleElement := ParseString(obj.complex('http://hl7.org/fhir/CapabilityStatement.title'));{q1}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/CapabilityStatement.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    result.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/CapabilityStatement.experimental'));{q1}
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/CapabilityStatement.date'));{q1}
    result.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/CapabilityStatement.publisher'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.contact') do
      result.contactList.Add(parseContactDetail(item));
    result.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/CapabilityStatement.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.useContext') do
      result.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.jurisdiction') do
      result.jurisdictionList.Add(parseCodeableConcept(item));
    result.purposeElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/CapabilityStatement.purpose'));{q1}
    result.copyrightElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/CapabilityStatement.copyright'));{q1}
    result.kindElement := ParseEnum(obj.complex('http://hl7.org/fhir/CapabilityStatement.kind'), CODES_TFhirCapabilityStatementKindEnum, SYSTEMS_TFhirCapabilityStatementKindEnum);
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.instantiates') do
      result.instantiatesList.Add(parseCanonical(item));
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.imports') do
      result.importsList.Add(parseCanonical(item));
    result.software := ParseCapabilityStatementSoftware(obj.complex('http://hl7.org/fhir/CapabilityStatement.software'));{q3b}
    result.implementation_ := ParseCapabilityStatementImplementation(obj.complex('http://hl7.org/fhir/CapabilityStatement.implementation'));{q3b}
    result.fhirVersionElement := ParseEnum(obj.complex('http://hl7.org/fhir/CapabilityStatement.fhirVersion'), CODES_TFhirFHIRVersionEnum, SYSTEMS_TFhirFHIRVersionEnum);
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.format') do
      result.formatList.Add(parseCode(item));
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.patchFormat') do
      result.patchFormatList.Add(parseCode(item));
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.implementationGuide') do
      result.implementationGuideList.Add(parseCanonical(item));
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.rest') do
      result.restList.Add(parseCapabilityStatementRest(item));
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.messaging') do
      result.messagingList.Add(parseCapabilityStatementMessaging(item));
    for item in obj.complexes('http://hl7.org/fhir/CapabilityStatement.document') do
      result.documentList.Add(parseCapabilityStatementDocument(item));
end;

procedure TFHIRTurtleComposer.ComposeCapabilityStatement(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCapabilityStatement; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CapabilityStatement'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUri(this, 'CapabilityStatement', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(this, 'CapabilityStatement', 'version', elem.versionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(this, 'CapabilityStatement', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeString(this, 'CapabilityStatement', 'title', elem.titleElement, false, -1);{x.2ea}
  ComposeEnum(this, 'CapabilityStatement', 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(this, 'CapabilityStatement', 'experimental', elem.experimentalElement, false, -1);{x.2ea}
  ComposeDateTime(this, 'CapabilityStatement', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(this, 'CapabilityStatement', 'publisher', elem.publisherElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(this, 'CapabilityStatement', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdown(this, 'CapabilityStatement', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(this, 'CapabilityStatement', 'useContext', elem.useContextList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'CapabilityStatement', 'jurisdiction', elem.jurisdictionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdown(this, 'CapabilityStatement', 'purpose', elem.purposeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdown(this, 'CapabilityStatement', 'copyright', elem.copyrightElement, false, -1);{x.2ea}
  ComposeEnum(this, 'CapabilityStatement', 'kind', elem.KindElement, CODES_TFhirCapabilityStatementKindEnum, SYSTEMS_TFhirCapabilityStatementKindEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('instantiates') then
    for i := 0 to elem.instantiatesList.Count - 1 do
      ComposeCanonical(this, 'CapabilityStatement', 'instantiates', elem.instantiatesList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('imports') then
    for i := 0 to elem.importsList.Count - 1 do
      ComposeCanonical(this, 'CapabilityStatement', 'imports', elem.importsList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('software') then
    ComposeCapabilityStatementSoftware(this, 'CapabilityStatement', 'software', elem.softwareElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('implementation_') then
    ComposeCapabilityStatementImplementation(this, 'CapabilityStatement', 'implementation', elem.implementation_Element, false, -1);{x.2f}
  ComposeEnum(this, 'CapabilityStatement', 'fhirVersion', elem.FhirVersionElement, CODES_TFhirFHIRVersionEnum, SYSTEMS_TFhirFHIRVersionEnum, false, -1);{x.d4}
  for i := 0 to elem.formatList.Count - 1 do
      ComposeCode(this, 'CapabilityStatement', 'format', elem.formatList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('patchFormat') then
    for i := 0 to elem.patchFormatList.Count - 1 do
      ComposeCode(this, 'CapabilityStatement', 'patchFormat', elem.patchFormatList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('implementationGuide') then
    for i := 0 to elem.implementationGuideList.Count - 1 do
      ComposeCanonical(this, 'CapabilityStatement', 'implementationGuide', elem.implementationGuideList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('rest') then
    for i := 0 to elem.restList.Count - 1 do
      ComposeCapabilityStatementRest(this, 'CapabilityStatement', 'rest', elem.restList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('messaging') then
    for i := 0 to elem.messagingList.Count - 1 do
      ComposeCapabilityStatementMessaging(this, 'CapabilityStatement', 'messaging', elem.messagingList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('document') then
    for i := 0 to elem.documentList.Count - 1 do
      ComposeCapabilityStatementDocument(this, 'CapabilityStatement', 'document', elem.documentList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_CAPABILITYSTATEMENT}
{$IFDEF FHIR_CAREPLAN}
function TFHIRTurtleParser.ParseCarePlanActivity(obj : TTurtleComplex) : TFhirCarePlanActivity;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCarePlanActivity.create;
  try
    ParseCarePlanActivityProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCarePlanActivityProperties(obj : TTurtleComplex; result : TFhirCarePlanActivity);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.activity.outcomeCodeableConcept') do
      result.outcomeCodeableConceptList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.activity.outcomeReference') do
      result.outcomeReferenceList.Add(parseReference{TFhirReference}(item));
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.activity.progress') do
      result.progressList.Add(parseAnnotation(item));
    result.reference := ParseReference{TFhirAppointment}(obj.complex('http://hl7.org/fhir/CarePlan.activity.reference'));{q3b}
    result.detail := ParseCarePlanActivityDetail(obj.complex('http://hl7.org/fhir/CarePlan.activity.detail'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeCarePlanActivity(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCarePlanActivity; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CarePlanActivity'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.outcomeCodeableConceptList.Count - 1 do
      ComposeCodeableConcept(this, 'CarePlan.activity', 'outcomeCodeableConcept', elem.outcomeCodeableConceptList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.outcomeReferenceList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'CarePlan.activity', 'outcomeReference', elem.outcomeReferenceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.progressList.Count - 1 do
      ComposeAnnotation(this, 'CarePlan.activity', 'progress', elem.progressList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirAppointment}(this, 'CarePlan.activity', 'reference', elem.referenceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCarePlanActivityDetail(this, 'CarePlan.activity', 'detail', elem.detailElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseCarePlanActivityDetail(obj : TTurtleComplex) : TFhirCarePlanActivityDetail;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCarePlanActivityDetail.create;
  try
    ParseCarePlanActivityDetailProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCarePlanActivityDetailProperties(obj : TTurtleComplex; result : TFhirCarePlanActivityDetail);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.kindElement := ParseEnum(obj.complex('http://hl7.org/fhir/CarePlan.activity.detail.kind'), CODES_TFhirCarePlanActivityKindEnum, SYSTEMS_TFhirCarePlanActivityKindEnum);
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.activity.detail.instantiatesCanonical') do
      result.instantiatesCanonicalList.Add(parseCanonical(item));
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.activity.detail.instantiatesUri') do
      result.instantiatesUriList.Add(parseUri(item));
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/CarePlan.activity.detail.code'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.activity.detail.reasonCode') do
      result.reasonCodeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.activity.detail.reasonReference') do
      result.reasonReferenceList.Add(parseReference{TFhirCondition}(item));
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.activity.detail.goal') do
      result.goalList.Add(parseReference{TFhirGoal}(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/CarePlan.activity.detail.status'), CODES_TFhirCarePlanActivityStatusEnum, SYSTEMS_TFhirCarePlanActivityStatusEnum);
    result.statusReason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/CarePlan.activity.detail.statusReason'));{q3b}
    result.doNotPerformElement := ParseBoolean(obj.complex('http://hl7.org/fhir/CarePlan.activity.detail.doNotPerform'));{q1}
    if obj.has('http://hl7.org/fhir/CarePlan.activity.detail.scheduledTiming', item) then
      result.scheduled := parseTiming(item);
    if obj.has('http://hl7.org/fhir/CarePlan.activity.detail.scheduledPeriod', item) then
      result.scheduled := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/CarePlan.activity.detail.scheduledString', item) then
      result.scheduled := parseString(item);
    result.location := ParseReference{TFhirLocation}(obj.complex('http://hl7.org/fhir/CarePlan.activity.detail.location'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.activity.detail.performer') do
      result.performerList.Add(parseReference{TFhirPractitioner}(item));
    if obj.has('http://hl7.org/fhir/CarePlan.activity.detail.productCodeableConcept', item) then
      result.product := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/CarePlan.activity.detail.productReference', item) {a3} then
      result.product := ParseReference(item);
    result.dailyAmount := ParseQuantity(obj.complex('http://hl7.org/fhir/CarePlan.activity.detail.dailyAmount'));{q3b}
    result.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/CarePlan.activity.detail.quantity'));{q3b}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/CarePlan.activity.detail.description'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeCarePlanActivityDetail(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCarePlanActivityDetail; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CarePlanActivityDetail'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'CarePlan.activity.detail', 'kind', elem.KindElement, CODES_TFhirCarePlanActivityKindEnum, SYSTEMS_TFhirCarePlanActivityKindEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.instantiatesCanonicalList.Count - 1 do
      ComposeCanonical(this, 'CarePlan.activity.detail', 'instantiatesCanonical', elem.instantiatesCanonicalList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.instantiatesUriList.Count - 1 do
      ComposeUri(this, 'CarePlan.activity.detail', 'instantiatesUri', elem.instantiatesUriList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'CarePlan.activity.detail', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'CarePlan.activity.detail', 'reasonCode', elem.reasonCodeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.reasonReferenceList.Count - 1 do
      ComposeReference{TFhirCondition}(this, 'CarePlan.activity.detail', 'reasonReference', elem.reasonReferenceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.goalList.Count - 1 do
      ComposeReference{TFhirGoal}(this, 'CarePlan.activity.detail', 'goal', elem.goalList[i], false, i);{x.d3}
  ComposeEnum(this, 'CarePlan.activity.detail', 'status', elem.StatusElement, CODES_TFhirCarePlanActivityStatusEnum, SYSTEMS_TFhirCarePlanActivityStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'CarePlan.activity.detail', 'statusReason', elem.statusReasonElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'CarePlan.activity.detail', 'doNotPerform', elem.doNotPerformElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and (elem.scheduled is TFhirTiming) {6} then
    ComposeTiming(this, 'CarePlan.activity.detail', 'scheduledTiming', TFhirTiming(elem.scheduled), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.scheduled is TFhirPeriod) {6} then
    ComposePeriod(this, 'CarePlan.activity.detail', 'scheduledPeriod', TFhirPeriod(elem.scheduled), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.scheduled is TFhirString) {6} then
    ComposeString(this, 'CarePlan.activity.detail', 'scheduledString', TFhirString(elem.scheduled), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirLocation}(this, 'CarePlan.activity.detail', 'location', elem.locationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.performerList.Count - 1 do
      ComposeReference{TFhirPractitioner}(this, 'CarePlan.activity.detail', 'performer', elem.performerList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and (elem.product is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'CarePlan.activity.detail', 'productCodeableConcept', TFhirCodeableConcept(elem.product), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.product is TFhirReference) {2} then
    ComposeReference(this, 'CarePlan.activity.detail', 'productReference', TFhirReference(elem.product), false,-1);{x.d8}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'CarePlan.activity.detail', 'dailyAmount', elem.dailyAmountElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'CarePlan.activity.detail', 'quantity', elem.quantityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'CarePlan.activity.detail', 'description', elem.descriptionElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseCarePlan(obj : TTurtleComplex) : TFhirCarePlan;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCarePlan.create;
  try
    ParseCarePlanProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCarePlanProperties(obj : TTurtleComplex; result : TFhirCarePlan);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.instantiatesCanonical') do
      result.instantiatesCanonicalList.Add(parseCanonical(item));
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.instantiatesUri') do
      result.instantiatesUriList.Add(parseUri(item));
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.basedOn') do
      result.basedOnList.Add(parseReference{TFhirCarePlan}(item));
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.replaces') do
      result.replacesList.Add(parseReference{TFhirCarePlan}(item));
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.partOf') do
      result.partOfList.Add(parseReference{TFhirCarePlan}(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/CarePlan.status'), CODES_TFhirRequestStatusEnum, SYSTEMS_TFhirRequestStatusEnum);
    result.intentElement := ParseEnum(obj.complex('http://hl7.org/fhir/CarePlan.intent'), CODES_TFhirCarePlanIntentEnum, SYSTEMS_TFhirCarePlanIntentEnum);
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.category') do
      result.categoryList.Add(parseCodeableConcept(item));
    result.titleElement := ParseString(obj.complex('http://hl7.org/fhir/CarePlan.title'));{q1}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/CarePlan.description'));{q1}
    result.subject := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/CarePlan.subject'));{q3b}
    result.encounter := ParseReference{TFhirEncounter}(obj.complex('http://hl7.org/fhir/CarePlan.encounter'));{q3b}
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/CarePlan.period'));{q3b}
    result.createdElement := ParseDateTime(obj.complex('http://hl7.org/fhir/CarePlan.created'));{q1}
    result.author := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/CarePlan.author'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.contributor') do
      result.contributorList.Add(parseReference{TFhirPatient}(item));
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.careTeam') do
      result.careTeamList.Add(parseReference{TFhirCareTeam}(item));
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.addresses') do
      result.addressesList.Add(parseReference{TFhirCondition}(item));
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.supportingInfo') do
      result.supportingInfoList.Add(parseReference{TFhirReference}(item));
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.goal') do
      result.goalList.Add(parseReference{TFhirGoal}(item));
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.activity') do
      result.activityList.Add(parseCarePlanActivity(item));
    for item in obj.complexes('http://hl7.org/fhir/CarePlan.note') do
      result.noteList.Add(parseAnnotation(item));
end;

procedure TFHIRTurtleComposer.ComposeCarePlan(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCarePlan; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CarePlan'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'CarePlan', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('instantiatesCanonical') then
    for i := 0 to elem.instantiatesCanonicalList.Count - 1 do
      ComposeCanonical(this, 'CarePlan', 'instantiatesCanonical', elem.instantiatesCanonicalList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('instantiatesUri') then
    for i := 0 to elem.instantiatesUriList.Count - 1 do
      ComposeUri(this, 'CarePlan', 'instantiatesUri', elem.instantiatesUriList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('basedOn') then
    for i := 0 to elem.basedOnList.Count - 1 do
      ComposeReference{TFhirCarePlan}(this, 'CarePlan', 'basedOn', elem.basedOnList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('replaces') then
    for i := 0 to elem.replacesList.Count - 1 do
      ComposeReference{TFhirCarePlan}(this, 'CarePlan', 'replaces', elem.replacesList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('partOf') then
    for i := 0 to elem.partOfList.Count - 1 do
      ComposeReference{TFhirCarePlan}(this, 'CarePlan', 'partOf', elem.partOfList[i], false, i);{x.d3}
  ComposeEnum(this, 'CarePlan', 'status', elem.StatusElement, CODES_TFhirRequestStatusEnum, SYSTEMS_TFhirRequestStatusEnum, false, -1);{x.d4}
  ComposeEnum(this, 'CarePlan', 'intent', elem.IntentElement, CODES_TFhirCarePlanIntentEnum, SYSTEMS_TFhirCarePlanIntentEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(this, 'CarePlan', 'category', elem.categoryList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeString(this, 'CarePlan', 'title', elem.titleElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeString(this, 'CarePlan', 'description', elem.descriptionElement, false, -1);{x.2ea}
  ComposeReference{TFhirPatient}(this, 'CarePlan', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(this, 'CarePlan', 'encounter', elem.encounterElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('period') then
    ComposePeriod(this, 'CarePlan', 'period', elem.periodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('created') then
    ComposeDateTime(this, 'CarePlan', 'created', elem.createdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('author') then
    ComposeReference{TFhirPatient}(this, 'CarePlan', 'author', elem.authorElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('contributor') then
    for i := 0 to elem.contributorList.Count - 1 do
      ComposeReference{TFhirPatient}(this, 'CarePlan', 'contributor', elem.contributorList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('careTeam') then
    for i := 0 to elem.careTeamList.Count - 1 do
      ComposeReference{TFhirCareTeam}(this, 'CarePlan', 'careTeam', elem.careTeamList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('addresses') then
    for i := 0 to elem.addressesList.Count - 1 do
      ComposeReference{TFhirCondition}(this, 'CarePlan', 'addresses', elem.addressesList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('supportingInfo') then
    for i := 0 to elem.supportingInfoList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'CarePlan', 'supportingInfo', elem.supportingInfoList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('goal') then
    for i := 0 to elem.goalList.Count - 1 do
      ComposeReference{TFhirGoal}(this, 'CarePlan', 'goal', elem.goalList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('activity') then
    for i := 0 to elem.activityList.Count - 1 do
      ComposeCarePlanActivity(this, 'CarePlan', 'activity', elem.activityList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'CarePlan', 'note', elem.noteList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_CAREPLAN}
{$IFDEF FHIR_CARETEAM}
function TFHIRTurtleParser.ParseCareTeamParticipant(obj : TTurtleComplex) : TFhirCareTeamParticipant;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCareTeamParticipant.create;
  try
    ParseCareTeamParticipantProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCareTeamParticipantProperties(obj : TTurtleComplex; result : TFhirCareTeamParticipant);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/CareTeam.participant.role') do
      result.roleList.Add(parseCodeableConcept(item));
    result.member := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/CareTeam.participant.member'));{q3b}
    result.onBehalfOf := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/CareTeam.participant.onBehalfOf'));{q3b}
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/CareTeam.participant.period'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeCareTeamParticipant(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCareTeamParticipant; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CareTeamParticipant'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.roleList.Count - 1 do
      ComposeCodeableConcept(this, 'CareTeam.participant', 'role', elem.roleList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(this, 'CareTeam.participant', 'member', elem.memberElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(this, 'CareTeam.participant', 'onBehalfOf', elem.onBehalfOfElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'CareTeam.participant', 'period', elem.periodElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseCareTeam(obj : TTurtleComplex) : TFhirCareTeam;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCareTeam.create;
  try
    ParseCareTeamProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCareTeamProperties(obj : TTurtleComplex; result : TFhirCareTeam);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/CareTeam.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/CareTeam.status'), CODES_TFhirCareTeamStatusEnum, SYSTEMS_TFhirCareTeamStatusEnum);
    for item in obj.complexes('http://hl7.org/fhir/CareTeam.category') do
      result.categoryList.Add(parseCodeableConcept(item));
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/CareTeam.name'));{q1}
    result.subject := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/CareTeam.subject'));{q3b}
    result.encounter := ParseReference{TFhirEncounter}(obj.complex('http://hl7.org/fhir/CareTeam.encounter'));{q3b}
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/CareTeam.period'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/CareTeam.participant') do
      result.participantList.Add(parseCareTeamParticipant(item));
    for item in obj.complexes('http://hl7.org/fhir/CareTeam.reasonCode') do
      result.reasonCodeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/CareTeam.reasonReference') do
      result.reasonReferenceList.Add(parseReference{TFhirCondition}(item));
    for item in obj.complexes('http://hl7.org/fhir/CareTeam.managingOrganization') do
      result.managingOrganizationList.Add(parseReference{TFhirOrganization}(item));
    for item in obj.complexes('http://hl7.org/fhir/CareTeam.telecom') do
      result.telecomList.Add(parseContactPoint(item));
    for item in obj.complexes('http://hl7.org/fhir/CareTeam.note') do
      result.noteList.Add(parseAnnotation(item));
end;

procedure TFHIRTurtleComposer.ComposeCareTeam(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCareTeam; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CareTeam'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'CareTeam', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(this, 'CareTeam', 'status', elem.StatusElement, CODES_TFhirCareTeamStatusEnum, SYSTEMS_TFhirCareTeamStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(this, 'CareTeam', 'category', elem.categoryList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(this, 'CareTeam', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{TFhirPatient}(this, 'CareTeam', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(this, 'CareTeam', 'encounter', elem.encounterElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('period') then
    ComposePeriod(this, 'CareTeam', 'period', elem.periodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('participant') then
    for i := 0 to elem.participantList.Count - 1 do
      ComposeCareTeamParticipant(this, 'CareTeam', 'participant', elem.participantList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('reasonCode') then
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'CareTeam', 'reasonCode', elem.reasonCodeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('reasonReference') then
    for i := 0 to elem.reasonReferenceList.Count - 1 do
      ComposeReference{TFhirCondition}(this, 'CareTeam', 'reasonReference', elem.reasonReferenceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('managingOrganization') then
    for i := 0 to elem.managingOrganizationList.Count - 1 do
      ComposeReference{TFhirOrganization}(this, 'CareTeam', 'managingOrganization', elem.managingOrganizationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('telecom') then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(this, 'CareTeam', 'telecom', elem.telecomList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'CareTeam', 'note', elem.noteList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_CARETEAM}
{$IFDEF FHIR_CATALOGENTRY}
function TFHIRTurtleParser.ParseCatalogEntryRelatedEntry(obj : TTurtleComplex) : TFhirCatalogEntryRelatedEntry;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCatalogEntryRelatedEntry.create;
  try
    ParseCatalogEntryRelatedEntryProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCatalogEntryRelatedEntryProperties(obj : TTurtleComplex; result : TFhirCatalogEntryRelatedEntry);
begin
    ParseBackboneElementProperties(obj, result);
    result.relationtypeElement := ParseEnum(obj.complex('http://hl7.org/fhir/CatalogEntry.relatedEntry.relationtype'), CODES_TFhirRelationTypeEnum, SYSTEMS_TFhirRelationTypeEnum);
    result.item := ParseReference{TFhirCatalogEntry}(obj.complex('http://hl7.org/fhir/CatalogEntry.relatedEntry.item'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeCatalogEntryRelatedEntry(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCatalogEntryRelatedEntry; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CatalogEntryRelatedEntry'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'CatalogEntry.relatedEntry', 'relationtype', elem.RelationtypeElement, CODES_TFhirRelationTypeEnum, SYSTEMS_TFhirRelationTypeEnum, false, -1);{x.d4}
  ComposeReference{TFhirCatalogEntry}(this, 'CatalogEntry.relatedEntry', 'item', elem.itemElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseCatalogEntry(obj : TTurtleComplex) : TFhirCatalogEntry;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCatalogEntry.create;
  try
    ParseCatalogEntryProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCatalogEntryProperties(obj : TTurtleComplex; result : TFhirCatalogEntry);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/CatalogEntry.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/CatalogEntry.type'));{q3b}
    result.orderableElement := ParseBoolean(obj.complex('http://hl7.org/fhir/CatalogEntry.orderable'));{q1}
    result.referencedItem := ParseReference{TFhirMedication}(obj.complex('http://hl7.org/fhir/CatalogEntry.referencedItem'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/CatalogEntry.additionalIdentifier') do
      result.additionalIdentifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/CatalogEntry.classification') do
      result.classificationList.Add(parseCodeableConcept(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/CatalogEntry.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    result.validityPeriod := ParsePeriod(obj.complex('http://hl7.org/fhir/CatalogEntry.validityPeriod'));{q3b}
    result.validToElement := ParseDateTime(obj.complex('http://hl7.org/fhir/CatalogEntry.validTo'));{q1}
    result.lastUpdatedElement := ParseDateTime(obj.complex('http://hl7.org/fhir/CatalogEntry.lastUpdated'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/CatalogEntry.additionalCharacteristic') do
      result.additionalCharacteristicList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/CatalogEntry.additionalClassification') do
      result.additionalClassificationList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/CatalogEntry.relatedEntry') do
      result.relatedEntryList.Add(parseCatalogEntryRelatedEntry(item));
end;

procedure TFHIRTurtleComposer.ComposeCatalogEntry(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCatalogEntry; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CatalogEntry'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'CatalogEntry', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('type_') then
    ComposeCodeableConcept(this, 'CatalogEntry', 'type', elem.type_Element, false, -1);{x.2f}
  ComposeBoolean(this, 'CatalogEntry', 'orderable', elem.orderableElement, false, -1);{x.2ea}
  ComposeReference{TFhirMedication}(this, 'CatalogEntry', 'referencedItem', elem.referencedItemElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('additionalIdentifier') then
    for i := 0 to elem.additionalIdentifierList.Count - 1 do
      ComposeIdentifier(this, 'CatalogEntry', 'additionalIdentifier', elem.additionalIdentifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('classification') then
    for i := 0 to elem.classificationList.Count - 1 do
      ComposeCodeableConcept(this, 'CatalogEntry', 'classification', elem.classificationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('status') then
    ComposeEnum(this, 'CatalogEntry', 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('validityPeriod') then
    ComposePeriod(this, 'CatalogEntry', 'validityPeriod', elem.validityPeriodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('validTo') then
    ComposeDateTime(this, 'CatalogEntry', 'validTo', elem.validToElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('lastUpdated') then
    ComposeDateTime(this, 'CatalogEntry', 'lastUpdated', elem.lastUpdatedElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('additionalCharacteristic') then
    for i := 0 to elem.additionalCharacteristicList.Count - 1 do
      ComposeCodeableConcept(this, 'CatalogEntry', 'additionalCharacteristic', elem.additionalCharacteristicList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('additionalClassification') then
    for i := 0 to elem.additionalClassificationList.Count - 1 do
      ComposeCodeableConcept(this, 'CatalogEntry', 'additionalClassification', elem.additionalClassificationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('relatedEntry') then
    for i := 0 to elem.relatedEntryList.Count - 1 do
      ComposeCatalogEntryRelatedEntry(this, 'CatalogEntry', 'relatedEntry', elem.relatedEntryList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_CATALOGENTRY}
{$IFDEF FHIR_CHARGEITEM}
function TFHIRTurtleParser.ParseChargeItemPerformer(obj : TTurtleComplex) : TFhirChargeItemPerformer;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirChargeItemPerformer.create;
  try
    ParseChargeItemPerformerProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseChargeItemPerformerProperties(obj : TTurtleComplex; result : TFhirChargeItemPerformer);
begin
    ParseBackboneElementProperties(obj, result);
    result.function_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ChargeItem.performer.function'));{q3b}
    result.actor := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/ChargeItem.performer.actor'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeChargeItemPerformer(parent :  TTurtleComplex; parentType, name : String; elem : TFhirChargeItemPerformer; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ChargeItemPerformer'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ChargeItem.performer', 'function', elem.function_Element, false, -1);{x.2f}
  ComposeReference{TFhirPractitioner}(this, 'ChargeItem.performer', 'actor', elem.actorElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseChargeItem(obj : TTurtleComplex) : TFhirChargeItem;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirChargeItem.create;
  try
    ParseChargeItemProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseChargeItemProperties(obj : TTurtleComplex; result : TFhirChargeItem);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/ChargeItem.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/ChargeItem.definitionUri') do
      result.definitionUriList.Add(parseUri(item));
    for item in obj.complexes('http://hl7.org/fhir/ChargeItem.definitionCanonical') do
      result.definitionCanonicalList.Add(parseCanonical(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/ChargeItem.status'), CODES_TFhirChargeitemStatusEnum, SYSTEMS_TFhirChargeitemStatusEnum);
    for item in obj.complexes('http://hl7.org/fhir/ChargeItem.partOf') do
      result.partOfList.Add(parseReference{TFhirChargeItem}(item));
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ChargeItem.code'));{q3b}
    result.subject := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/ChargeItem.subject'));{q3b}
    result.context := ParseReference{TFhirEncounter}(obj.complex('http://hl7.org/fhir/ChargeItem.context'));{q3b}
    if obj.has('http://hl7.org/fhir/ChargeItem.occurrencePeriod', item) then
      result.occurrence := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/ChargeItem.occurrenceTiming', item) then
      result.occurrence := parseTiming(item);
    if obj.has('http://hl7.org/fhir/ChargeItem.occurrenceDateTime', item) then
      result.occurrence := parseDateTime(item);
    for item in obj.complexes('http://hl7.org/fhir/ChargeItem.performer') do
      result.performerList.Add(parseChargeItemPerformer(item));
    result.performingOrganization := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/ChargeItem.performingOrganization'));{q3b}
    result.requestingOrganization := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/ChargeItem.requestingOrganization'));{q3b}
    result.costCenter := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/ChargeItem.costCenter'));{q3b}
    result.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/ChargeItem.quantity'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ChargeItem.bodysite') do
      result.bodysiteList.Add(parseCodeableConcept(item));
    result.factorOverrideElement := ParseDecimal(obj.complex('http://hl7.org/fhir/ChargeItem.factorOverride'));{q1}
    result.priceOverride := ParseMoney(obj.complex('http://hl7.org/fhir/ChargeItem.priceOverride'));{q3b}
    result.overrideReasonElement := ParseString(obj.complex('http://hl7.org/fhir/ChargeItem.overrideReason'));{q1}
    result.enterer := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/ChargeItem.enterer'));{q3b}
    result.enteredDateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ChargeItem.enteredDate'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ChargeItem.reason') do
      result.reasonList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/ChargeItem.service') do
      result.serviceList.Add(parseReference{TFhirDiagnosticReport}(item));
    if obj.has('http://hl7.org/fhir/ChargeItem.productReference', item) {a3} then
      result.product := ParseReference(item);
    if obj.has('http://hl7.org/fhir/ChargeItem.productCodeableConcept', item) then
      result.product := parseCodeableConcept(item);
    for item in obj.complexes('http://hl7.org/fhir/ChargeItem.account') do
      result.accountList.Add(parseReference{TFhirAccount}(item));
    for item in obj.complexes('http://hl7.org/fhir/ChargeItem.note') do
      result.noteList.Add(parseAnnotation(item));
    for item in obj.complexes('http://hl7.org/fhir/ChargeItem.supportingInformation') do
      result.supportingInformationList.Add(parseReference{TFhirReference}(item));
end;

procedure TFHIRTurtleComposer.ComposeChargeItem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirChargeItem; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ChargeItem'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'ChargeItem', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('definitionUri') then
    for i := 0 to elem.definitionUriList.Count - 1 do
      ComposeUri(this, 'ChargeItem', 'definitionUri', elem.definitionUriList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('definitionCanonical') then
    for i := 0 to elem.definitionCanonicalList.Count - 1 do
      ComposeCanonical(this, 'ChargeItem', 'definitionCanonical', elem.definitionCanonicalList[i], false, i);{x.d3}
  ComposeEnum(this, 'ChargeItem', 'status', elem.StatusElement, CODES_TFhirChargeitemStatusEnum, SYSTEMS_TFhirChargeitemStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('partOf') then
    for i := 0 to elem.partOfList.Count - 1 do
      ComposeReference{TFhirChargeItem}(this, 'ChargeItem', 'partOf', elem.partOfList[i], false, i);{x.d3}
  ComposeCodeableConcept(this, 'ChargeItem', 'code', elem.codeElement, false, -1);{x.2f}
  ComposeReference{TFhirPatient}(this, 'ChargeItem', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('context') then
    ComposeReference{TFhirEncounter}(this, 'ChargeItem', 'context', elem.contextElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirPeriod) {6} then
    ComposePeriod(this, 'ChargeItem', 'occurrencePeriod', TFhirPeriod(elem.occurrence), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirTiming) {6} then
    ComposeTiming(this, 'ChargeItem', 'occurrenceTiming', TFhirTiming(elem.occurrence), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirDateTime) {6} then
    ComposeDateTime(this, 'ChargeItem', 'occurrenceDateTime', TFhirDateTime(elem.occurrence), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) and doCompose('performer') then
    for i := 0 to elem.performerList.Count - 1 do
      ComposeChargeItemPerformer(this, 'ChargeItem', 'performer', elem.performerList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('performingOrganization') then
    ComposeReference{TFhirOrganization}(this, 'ChargeItem', 'performingOrganization', elem.performingOrganizationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('requestingOrganization') then
    ComposeReference{TFhirOrganization}(this, 'ChargeItem', 'requestingOrganization', elem.requestingOrganizationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('costCenter') then
    ComposeReference{TFhirOrganization}(this, 'ChargeItem', 'costCenter', elem.costCenterElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('quantity') then
    ComposeQuantity(this, 'ChargeItem', 'quantity', elem.quantityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('bodysite') then
    for i := 0 to elem.bodysiteList.Count - 1 do
      ComposeCodeableConcept(this, 'ChargeItem', 'bodysite', elem.bodysiteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('factorOverride') then
    ComposeDecimal(this, 'ChargeItem', 'factorOverride', elem.factorOverrideElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('priceOverride') then
    ComposeMoney(this, 'ChargeItem', 'priceOverride', elem.priceOverrideElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('overrideReason') then
    ComposeString(this, 'ChargeItem', 'overrideReason', elem.overrideReasonElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('enterer') then
    ComposeReference{TFhirPractitioner}(this, 'ChargeItem', 'enterer', elem.entererElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('enteredDate') then
    ComposeDateTime(this, 'ChargeItem', 'enteredDate', elem.enteredDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('reason') then
    for i := 0 to elem.reasonList.Count - 1 do
      ComposeCodeableConcept(this, 'ChargeItem', 'reason', elem.reasonList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('service') then
    for i := 0 to elem.serviceList.Count - 1 do
      ComposeReference{TFhirDiagnosticReport}(this, 'ChargeItem', 'service', elem.serviceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and (elem.product is TFhirReference) {2} then
    ComposeReference(this, 'ChargeItem', 'productReference', TFhirReference(elem.product), false,-1){x.d8}
  else if (SummaryOption in [soFull, soData]) and (elem.product is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'ChargeItem', 'productCodeableConcept', TFhirCodeableConcept(elem.product), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('account') then
    for i := 0 to elem.accountList.Count - 1 do
      ComposeReference{TFhirAccount}(this, 'ChargeItem', 'account', elem.accountList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'ChargeItem', 'note', elem.noteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('supportingInformation') then
    for i := 0 to elem.supportingInformationList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'ChargeItem', 'supportingInformation', elem.supportingInformationList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_CHARGEITEM}
{$IFDEF FHIR_CHARGEITEMDEFINITION}
function TFHIRTurtleParser.ParseChargeItemDefinitionApplicability(obj : TTurtleComplex) : TFhirChargeItemDefinitionApplicability;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirChargeItemDefinitionApplicability.create;
  try
    ParseChargeItemDefinitionApplicabilityProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseChargeItemDefinitionApplicabilityProperties(obj : TTurtleComplex; result : TFhirChargeItemDefinitionApplicability);
begin
    ParseBackboneElementProperties(obj, result);
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/ChargeItemDefinition.applicability.description'));{q1}
    result.languageElement := ParseString(obj.complex('http://hl7.org/fhir/ChargeItemDefinition.applicability.language'));{q1}
    result.expressionElement := ParseString(obj.complex('http://hl7.org/fhir/ChargeItemDefinition.applicability.expression'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeChargeItemDefinitionApplicability(parent :  TTurtleComplex; parentType, name : String; elem : TFhirChargeItemDefinitionApplicability; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ChargeItemDefinitionApplicability'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ChargeItemDefinition.applicability', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ChargeItemDefinition.applicability', 'language', elem.languageElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ChargeItemDefinition.applicability', 'expression', elem.expressionElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseChargeItemDefinitionPropertyGroup(obj : TTurtleComplex) : TFhirChargeItemDefinitionPropertyGroup;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirChargeItemDefinitionPropertyGroup.create;
  try
    ParseChargeItemDefinitionPropertyGroupProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseChargeItemDefinitionPropertyGroupProperties(obj : TTurtleComplex; result : TFhirChargeItemDefinitionPropertyGroup);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/ChargeItemDefinition.propertyGroup.applicability') do
      result.applicabilityList.Add(parseChargeItemDefinitionApplicability(item));
    for item in obj.complexes('http://hl7.org/fhir/ChargeItemDefinition.propertyGroup.priceComponent') do
      result.priceComponentList.Add(parseChargeItemDefinitionPropertyGroupPriceComponent(item));
end;

procedure TFHIRTurtleComposer.ComposeChargeItemDefinitionPropertyGroup(parent :  TTurtleComplex; parentType, name : String; elem : TFhirChargeItemDefinitionPropertyGroup; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ChargeItemDefinitionPropertyGroup'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.applicabilityList.Count - 1 do
      ComposeChargeItemDefinitionApplicability(this, 'ChargeItemDefinition.propertyGroup', 'applicability', elem.applicabilityList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.priceComponentList.Count - 1 do
      ComposeChargeItemDefinitionPropertyGroupPriceComponent(this, 'ChargeItemDefinition.propertyGroup', 'priceComponent', elem.priceComponentList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseChargeItemDefinitionPropertyGroupPriceComponent(obj : TTurtleComplex) : TFhirChargeItemDefinitionPropertyGroupPriceComponent;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirChargeItemDefinitionPropertyGroupPriceComponent.create;
  try
    ParseChargeItemDefinitionPropertyGroupPriceComponentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseChargeItemDefinitionPropertyGroupPriceComponentProperties(obj : TTurtleComplex; result : TFhirChargeItemDefinitionPropertyGroupPriceComponent);
begin
    ParseBackboneElementProperties(obj, result);
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/ChargeItemDefinition.propertyGroup.priceComponent.type'), CODES_TFhirInvoicePriceComponentTypeEnum, SYSTEMS_TFhirInvoicePriceComponentTypeEnum);
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ChargeItemDefinition.propertyGroup.priceComponent.code'));{q3b}
    result.factorElement := ParseDecimal(obj.complex('http://hl7.org/fhir/ChargeItemDefinition.propertyGroup.priceComponent.factor'));{q1}
    result.amount := ParseMoney(obj.complex('http://hl7.org/fhir/ChargeItemDefinition.propertyGroup.priceComponent.amount'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeChargeItemDefinitionPropertyGroupPriceComponent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirChargeItemDefinitionPropertyGroupPriceComponent; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ChargeItemDefinitionPropertyGroupPriceComponent'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'ChargeItemDefinition.propertyGroup.priceComponent', 'type', elem.Type_Element, CODES_TFhirInvoicePriceComponentTypeEnum, SYSTEMS_TFhirInvoicePriceComponentTypeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ChargeItemDefinition.propertyGroup.priceComponent', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'ChargeItemDefinition.propertyGroup.priceComponent', 'factor', elem.factorElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ChargeItemDefinition.propertyGroup.priceComponent', 'amount', elem.amountElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseChargeItemDefinition(obj : TTurtleComplex) : TFhirChargeItemDefinition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirChargeItemDefinition.create;
  try
    ParseChargeItemDefinitionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseChargeItemDefinitionProperties(obj : TTurtleComplex; result : TFhirChargeItemDefinition);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/ChargeItemDefinition.url'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ChargeItemDefinition.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/ChargeItemDefinition.version'));{q1}
    result.titleElement := ParseString(obj.complex('http://hl7.org/fhir/ChargeItemDefinition.title'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ChargeItemDefinition.derivedFromUri') do
      result.derivedFromUriList.Add(parseUri(item));
    for item in obj.complexes('http://hl7.org/fhir/ChargeItemDefinition.partOf') do
      result.partOfList.Add(parseCanonical(item));
    for item in obj.complexes('http://hl7.org/fhir/ChargeItemDefinition.replaces') do
      result.replacesList.Add(parseCanonical(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/ChargeItemDefinition.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    result.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ChargeItemDefinition.experimental'));{q1}
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ChargeItemDefinition.date'));{q1}
    result.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/ChargeItemDefinition.publisher'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ChargeItemDefinition.contact') do
      result.contactList.Add(parseContactDetail(item));
    result.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ChargeItemDefinition.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ChargeItemDefinition.useContext') do
      result.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/ChargeItemDefinition.jurisdiction') do
      result.jurisdictionList.Add(parseCodeableConcept(item));
    result.copyrightElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ChargeItemDefinition.copyright'));{q1}
    result.approvalDateElement := ParseDate(obj.complex('http://hl7.org/fhir/ChargeItemDefinition.approvalDate'));{q1}
    result.lastReviewDateElement := ParseDate(obj.complex('http://hl7.org/fhir/ChargeItemDefinition.lastReviewDate'));{q1}
    result.effectivePeriod := ParsePeriod(obj.complex('http://hl7.org/fhir/ChargeItemDefinition.effectivePeriod'));{q3b}
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ChargeItemDefinition.code'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ChargeItemDefinition.instance') do
      result.instanceList.Add(parseReference{TFhirMedication}(item));
    for item in obj.complexes('http://hl7.org/fhir/ChargeItemDefinition.applicability') do
      result.applicabilityList.Add(parseChargeItemDefinitionApplicability(item));
    for item in obj.complexes('http://hl7.org/fhir/ChargeItemDefinition.propertyGroup') do
      result.propertyGroupList.Add(parseChargeItemDefinitionPropertyGroup(item));
end;

procedure TFHIRTurtleComposer.ComposeChargeItemDefinition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirChargeItemDefinition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ChargeItemDefinition'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  ComposeUri(this, 'ChargeItemDefinition', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'ChargeItemDefinition', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(this, 'ChargeItemDefinition', 'version', elem.versionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeString(this, 'ChargeItemDefinition', 'title', elem.titleElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('derivedFromUri') then
    for i := 0 to elem.derivedFromUriList.Count - 1 do
      ComposeUri(this, 'ChargeItemDefinition', 'derivedFromUri', elem.derivedFromUriList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('partOf') then
    for i := 0 to elem.partOfList.Count - 1 do
      ComposeCanonical(this, 'ChargeItemDefinition', 'partOf', elem.partOfList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('replaces') then
    for i := 0 to elem.replacesList.Count - 1 do
      ComposeCanonical(this, 'ChargeItemDefinition', 'replaces', elem.replacesList[i], false, i);{x.d3}
  ComposeEnum(this, 'ChargeItemDefinition', 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(this, 'ChargeItemDefinition', 'experimental', elem.experimentalElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(this, 'ChargeItemDefinition', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(this, 'ChargeItemDefinition', 'publisher', elem.publisherElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(this, 'ChargeItemDefinition', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeMarkdown(this, 'ChargeItemDefinition', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(this, 'ChargeItemDefinition', 'useContext', elem.useContextList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'ChargeItemDefinition', 'jurisdiction', elem.jurisdictionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdown(this, 'ChargeItemDefinition', 'copyright', elem.copyrightElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('approvalDate') then
    ComposeDate(this, 'ChargeItemDefinition', 'approvalDate', elem.approvalDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('lastReviewDate') then
    ComposeDate(this, 'ChargeItemDefinition', 'lastReviewDate', elem.lastReviewDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('effectivePeriod') then
    ComposePeriod(this, 'ChargeItemDefinition', 'effectivePeriod', elem.effectivePeriodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') then
    ComposeCodeableConcept(this, 'ChargeItemDefinition', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('instance') then
    for i := 0 to elem.instanceList.Count - 1 do
      ComposeReference{TFhirMedication}(this, 'ChargeItemDefinition', 'instance', elem.instanceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('applicability') then
    for i := 0 to elem.applicabilityList.Count - 1 do
      ComposeChargeItemDefinitionApplicability(this, 'ChargeItemDefinition', 'applicability', elem.applicabilityList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('propertyGroup') then
    for i := 0 to elem.propertyGroupList.Count - 1 do
      ComposeChargeItemDefinitionPropertyGroup(this, 'ChargeItemDefinition', 'propertyGroup', elem.propertyGroupList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_CHARGEITEMDEFINITION}
{$IFDEF FHIR_CLAIM}
function TFHIRTurtleParser.ParseClaimRelated(obj : TTurtleComplex) : TFhirClaimRelated;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimRelated.create;
  try
    ParseClaimRelatedProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimRelatedProperties(obj : TTurtleComplex; result : TFhirClaimRelated);
begin
    ParseBackboneElementProperties(obj, result);
    result.claim := ParseReference{TFhirClaim}(obj.complex('http://hl7.org/fhir/Claim.related.claim'));{q3b}
    result.relationship := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Claim.related.relationship'));{q3b}
    result.reference := ParseIdentifier(obj.complex('http://hl7.org/fhir/Claim.related.reference'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeClaimRelated(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimRelated; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimRelated'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirClaim}(this, 'Claim.related', 'claim', elem.claimElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Claim.related', 'relationship', elem.relationshipElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(this, 'Claim.related', 'reference', elem.referenceElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseClaimPayee(obj : TTurtleComplex) : TFhirClaimPayee;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimPayee.create;
  try
    ParseClaimPayeeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimPayeeProperties(obj : TTurtleComplex; result : TFhirClaimPayee);
begin
    ParseBackboneElementProperties(obj, result);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Claim.payee.type'));{q3b}
    result.party := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/Claim.payee.party'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeClaimPayee(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimPayee; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimPayee'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'Claim.payee', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirPractitioner}(this, 'Claim.payee', 'party', elem.partyElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseClaimCareTeam(obj : TTurtleComplex) : TFhirClaimCareTeam;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimCareTeam.create;
  try
    ParseClaimCareTeamProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimCareTeamProperties(obj : TTurtleComplex; result : TFhirClaimCareTeam);
begin
    ParseBackboneElementProperties(obj, result);
    result.sequenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Claim.careTeam.sequence'));{q1}
    result.provider := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/Claim.careTeam.provider'));{q3b}
    result.responsibleElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Claim.careTeam.responsible'));{q1}
    result.role := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Claim.careTeam.role'));{q3b}
    result.qualification := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Claim.careTeam.qualification'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeClaimCareTeam(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimCareTeam; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimCareTeam'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposePositiveInt(this, 'Claim.careTeam', 'sequence', elem.sequenceElement, false, -1);{x.2ea}
  ComposeReference{TFhirPractitioner}(this, 'Claim.careTeam', 'provider', elem.providerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'Claim.careTeam', 'responsible', elem.responsibleElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Claim.careTeam', 'role', elem.roleElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Claim.careTeam', 'qualification', elem.qualificationElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseClaimSupportingInfo(obj : TTurtleComplex) : TFhirClaimSupportingInfo;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimSupportingInfo.create;
  try
    ParseClaimSupportingInfoProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimSupportingInfoProperties(obj : TTurtleComplex; result : TFhirClaimSupportingInfo);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.sequenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Claim.supportingInfo.sequence'));{q1}
    result.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Claim.supportingInfo.category'));{q3b}
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Claim.supportingInfo.code'));{q3b}
    if obj.has('http://hl7.org/fhir/Claim.supportingInfo.timingPeriod', item) then
      result.timing := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/Claim.supportingInfo.timingDate', item) then
      result.timing := parseDate(item);
    if obj.has('http://hl7.org/fhir/Claim.supportingInfo.valueQuantity', item) then
      result.value := parseQuantity(item);
    if obj.has('http://hl7.org/fhir/Claim.supportingInfo.valueAttachment', item) then
      result.value := parseAttachment(item);
    if obj.has('http://hl7.org/fhir/Claim.supportingInfo.valueReference', item) {a3} then
      result.value := ParseReference(item);
    if obj.has('http://hl7.org/fhir/Claim.supportingInfo.valueBoolean', item) then
      result.value := parseBoolean(item);
    if obj.has('http://hl7.org/fhir/Claim.supportingInfo.valueString', item) then
      result.value := parseString(item);
    result.reason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Claim.supportingInfo.reason'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeClaimSupportingInfo(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimSupportingInfo; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimSupportingInfo'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposePositiveInt(this, 'Claim.supportingInfo', 'sequence', elem.sequenceElement, false, -1);{x.2ea}
  ComposeCodeableConcept(this, 'Claim.supportingInfo', 'category', elem.categoryElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Claim.supportingInfo', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirPeriod) {6} then
    ComposePeriod(this, 'Claim.supportingInfo', 'timingPeriod', TFhirPeriod(elem.timing), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirDate) {6} then
    ComposeDate(this, 'Claim.supportingInfo', 'timingDate', TFhirDate(elem.timing), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) and (elem.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'Claim.supportingInfo', 'valueQuantity', TFhirQuantity(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirAttachment) {6} then
    ComposeAttachment(this, 'Claim.supportingInfo', 'valueAttachment', TFhirAttachment(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirReference) {2} then
    ComposeReference(this, 'Claim.supportingInfo', 'valueReference', TFhirReference(elem.value), false,-1){x.d8}
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirBoolean) {6} then
    ComposeBoolean(this, 'Claim.supportingInfo', 'valueBoolean', TFhirBoolean(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirString) {6} then
    ComposeString(this, 'Claim.supportingInfo', 'valueString', TFhirString(elem.value), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Claim.supportingInfo', 'reason', elem.reasonElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseClaimDiagnosis(obj : TTurtleComplex) : TFhirClaimDiagnosis;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimDiagnosis.create;
  try
    ParseClaimDiagnosisProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimDiagnosisProperties(obj : TTurtleComplex; result : TFhirClaimDiagnosis);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.sequenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Claim.diagnosis.sequence'));{q1}
    if obj.has('http://hl7.org/fhir/Claim.diagnosis.diagnosisCodeableConcept', item) then
      result.diagnosis := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/Claim.diagnosis.diagnosisReference', item) {a3} then
      result.diagnosis := ParseReference(item);
    for item in obj.complexes('http://hl7.org/fhir/Claim.diagnosis.type') do
      result.type_List.Add(parseCodeableConcept(item));
    result.onAdmission := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Claim.diagnosis.onAdmission'));{q3b}
    result.packageCode := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Claim.diagnosis.packageCode'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeClaimDiagnosis(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimDiagnosis; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimDiagnosis'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposePositiveInt(this, 'Claim.diagnosis', 'sequence', elem.sequenceElement, false, -1);{x.2ea}
  if (elem.diagnosis is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Claim.diagnosis', 'diagnosisCodeableConcept', TFhirCodeableConcept(elem.diagnosis), false, -1){x.d9}
  else if (elem.diagnosis is TFhirReference) {2} then
    ComposeReference(this, 'Claim.diagnosis', 'diagnosisReference', TFhirReference(elem.diagnosis), false,-1);{x.d8}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(this, 'Claim.diagnosis', 'type', elem.type_List[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Claim.diagnosis', 'onAdmission', elem.onAdmissionElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Claim.diagnosis', 'packageCode', elem.packageCodeElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseClaimProcedure(obj : TTurtleComplex) : TFhirClaimProcedure;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimProcedure.create;
  try
    ParseClaimProcedureProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimProcedureProperties(obj : TTurtleComplex; result : TFhirClaimProcedure);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.sequenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Claim.procedure.sequence'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Claim.procedure.type') do
      result.type_List.Add(parseCodeableConcept(item));
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Claim.procedure.date'));{q1}
    if obj.has('http://hl7.org/fhir/Claim.procedure.procedureCodeableConcept', item) then
      result.procedure_ := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/Claim.procedure.procedureReference', item) {a3} then
      result.procedure_ := ParseReference(item);
    for item in obj.complexes('http://hl7.org/fhir/Claim.procedure.udi') do
      result.udiList.Add(parseReference{TFhirDevice}(item));
end;

procedure TFHIRTurtleComposer.ComposeClaimProcedure(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimProcedure; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimProcedure'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposePositiveInt(this, 'Claim.procedure', 'sequence', elem.sequenceElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(this, 'Claim.procedure', 'type', elem.type_List[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'Claim.procedure', 'date', elem.dateElement, false, -1);{x.2ea}
  if (elem.procedure_ is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Claim.procedure', 'procedureCodeableConcept', TFhirCodeableConcept(elem.procedure_), false, -1){x.d9}
  else if (elem.procedure_ is TFhirReference) {2} then
    ComposeReference(this, 'Claim.procedure', 'procedureReference', TFhirReference(elem.procedure_), false,-1);{x.d8}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.udiList.Count - 1 do
      ComposeReference{TFhirDevice}(this, 'Claim.procedure', 'udi', elem.udiList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseClaimInsurance(obj : TTurtleComplex) : TFhirClaimInsurance;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimInsurance.create;
  try
    ParseClaimInsuranceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimInsuranceProperties(obj : TTurtleComplex; result : TFhirClaimInsurance);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.sequenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Claim.insurance.sequence'));{q1}
    result.focalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Claim.insurance.focal'));{q1}
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/Claim.insurance.identifier'));{q3b}
    result.coverage := ParseReference{TFhirCoverage}(obj.complex('http://hl7.org/fhir/Claim.insurance.coverage'));{q3b}
    result.businessArrangementElement := ParseString(obj.complex('http://hl7.org/fhir/Claim.insurance.businessArrangement'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Claim.insurance.preAuthRef') do
      result.preAuthRefList.Add(parseString(item));
    result.claimResponse := ParseReference{TFhirClaimResponse}(obj.complex('http://hl7.org/fhir/Claim.insurance.claimResponse'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeClaimInsurance(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimInsurance; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimInsurance'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposePositiveInt(this, 'Claim.insurance', 'sequence', elem.sequenceElement, false, -1);{x.2ea}
  ComposeBoolean(this, 'Claim.insurance', 'focal', elem.focalElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(this, 'Claim.insurance', 'identifier', elem.identifierElement, false, -1);{x.2f}
  ComposeReference{TFhirCoverage}(this, 'Claim.insurance', 'coverage', elem.coverageElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Claim.insurance', 'businessArrangement', elem.businessArrangementElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.preAuthRefList.Count - 1 do
      ComposeString(this, 'Claim.insurance', 'preAuthRef', elem.preAuthRefList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirClaimResponse}(this, 'Claim.insurance', 'claimResponse', elem.claimResponseElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseClaimAccident(obj : TTurtleComplex) : TFhirClaimAccident;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimAccident.create;
  try
    ParseClaimAccidentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimAccidentProperties(obj : TTurtleComplex; result : TFhirClaimAccident);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.dateElement := ParseDate(obj.complex('http://hl7.org/fhir/Claim.accident.date'));{q1}
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Claim.accident.type'));{q3b}
    if obj.has('http://hl7.org/fhir/Claim.accident.locationAddress', item) then
      result.location := parseAddress(item);
    if obj.has('http://hl7.org/fhir/Claim.accident.locationReference', item) {a3} then
      result.location := ParseReference(item);
end;

procedure TFHIRTurtleComposer.ComposeClaimAccident(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimAccident; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimAccident'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeDate(this, 'Claim.accident', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Claim.accident', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and (elem.location is TFhirAddress) {6} then
    ComposeAddress(this, 'Claim.accident', 'locationAddress', TFhirAddress(elem.location), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.location is TFhirReference) {2} then
    ComposeReference(this, 'Claim.accident', 'locationReference', TFhirReference(elem.location), false,-1);{x.d8}
end;

function TFHIRTurtleParser.ParseClaimItem(obj : TTurtleComplex) : TFhirClaimItem;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimItem.create;
  try
    ParseClaimItemProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimItemProperties(obj : TTurtleComplex; result : TFhirClaimItem);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.sequenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Claim.item.sequence'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Claim.item.careTeamSequence') do
      result.careTeamSequenceList.Add(parsePositiveInt(item));
    for item in obj.complexes('http://hl7.org/fhir/Claim.item.diagnosisSequence') do
      result.diagnosisSequenceList.Add(parsePositiveInt(item));
    for item in obj.complexes('http://hl7.org/fhir/Claim.item.procedureSequence') do
      result.procedureSequenceList.Add(parsePositiveInt(item));
    for item in obj.complexes('http://hl7.org/fhir/Claim.item.informationSequence') do
      result.informationSequenceList.Add(parsePositiveInt(item));
    result.revenue := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Claim.item.revenue'));{q3b}
    result.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Claim.item.category'));{q3b}
    result.productOrService := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Claim.item.productOrService'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Claim.item.modifier') do
      result.modifierList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Claim.item.programCode') do
      result.programCodeList.Add(parseCodeableConcept(item));
    if obj.has('http://hl7.org/fhir/Claim.item.servicedPeriod', item) then
      result.serviced := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/Claim.item.servicedDate', item) then
      result.serviced := parseDate(item);
    if obj.has('http://hl7.org/fhir/Claim.item.locationCodeableConcept', item) then
      result.location := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/Claim.item.locationAddress', item) then
      result.location := parseAddress(item);
    if obj.has('http://hl7.org/fhir/Claim.item.locationReference', item) {a3} then
      result.location := ParseReference(item);
    result.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/Claim.item.quantity'));{q3b}
    result.unitPrice := ParseMoney(obj.complex('http://hl7.org/fhir/Claim.item.unitPrice'));{q3b}
    result.factorElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Claim.item.factor'));{q1}
    result.net := ParseMoney(obj.complex('http://hl7.org/fhir/Claim.item.net'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Claim.item.udi') do
      result.udiList.Add(parseReference{TFhirDevice}(item));
    result.bodySite := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Claim.item.bodySite'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Claim.item.subSite') do
      result.subSiteList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Claim.item.encounter') do
      result.encounterList.Add(parseReference{TFhirEncounter}(item));
    for item in obj.complexes('http://hl7.org/fhir/Claim.item.detail') do
      result.detailList.Add(parseClaimItemDetail(item));
end;

procedure TFHIRTurtleComposer.ComposeClaimItem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimItem; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimItem'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposePositiveInt(this, 'Claim.item', 'sequence', elem.sequenceElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.careTeamSequenceList.Count - 1 do
      ComposePositiveInt(this, 'Claim.item', 'careTeamSequence', elem.careTeamSequenceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.diagnosisSequenceList.Count - 1 do
      ComposePositiveInt(this, 'Claim.item', 'diagnosisSequence', elem.diagnosisSequenceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.procedureSequenceList.Count - 1 do
      ComposePositiveInt(this, 'Claim.item', 'procedureSequence', elem.procedureSequenceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.informationSequenceList.Count - 1 do
      ComposePositiveInt(this, 'Claim.item', 'informationSequence', elem.informationSequenceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Claim.item', 'revenue', elem.revenueElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Claim.item', 'category', elem.categoryElement, false, -1);{x.2f}
  ComposeCodeableConcept(this, 'Claim.item', 'productOrService', elem.productOrServiceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.modifierList.Count - 1 do
      ComposeCodeableConcept(this, 'Claim.item', 'modifier', elem.modifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.programCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'Claim.item', 'programCode', elem.programCodeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and (elem.serviced is TFhirPeriod) {6} then
    ComposePeriod(this, 'Claim.item', 'servicedPeriod', TFhirPeriod(elem.serviced), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.serviced is TFhirDate) {6} then
    ComposeDate(this, 'Claim.item', 'servicedDate', TFhirDate(elem.serviced), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) and (elem.location is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Claim.item', 'locationCodeableConcept', TFhirCodeableConcept(elem.location), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.location is TFhirAddress) {6} then
    ComposeAddress(this, 'Claim.item', 'locationAddress', TFhirAddress(elem.location), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.location is TFhirReference) {2} then
    ComposeReference(this, 'Claim.item', 'locationReference', TFhirReference(elem.location), false,-1);{x.d8}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'Claim.item', 'quantity', elem.quantityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'Claim.item', 'unitPrice', elem.unitPriceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'Claim.item', 'factor', elem.factorElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'Claim.item', 'net', elem.netElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.udiList.Count - 1 do
      ComposeReference{TFhirDevice}(this, 'Claim.item', 'udi', elem.udiList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Claim.item', 'bodySite', elem.bodySiteElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.subSiteList.Count - 1 do
      ComposeCodeableConcept(this, 'Claim.item', 'subSite', elem.subSiteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.encounterList.Count - 1 do
      ComposeReference{TFhirEncounter}(this, 'Claim.item', 'encounter', elem.encounterList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.detailList.Count - 1 do
      ComposeClaimItemDetail(this, 'Claim.item', 'detail', elem.detailList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseClaimItemDetail(obj : TTurtleComplex) : TFhirClaimItemDetail;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimItemDetail.create;
  try
    ParseClaimItemDetailProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimItemDetailProperties(obj : TTurtleComplex; result : TFhirClaimItemDetail);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.sequenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Claim.item.detail.sequence'));{q1}
    result.revenue := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Claim.item.detail.revenue'));{q3b}
    result.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Claim.item.detail.category'));{q3b}
    result.productOrService := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Claim.item.detail.productOrService'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Claim.item.detail.modifier') do
      result.modifierList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Claim.item.detail.programCode') do
      result.programCodeList.Add(parseCodeableConcept(item));
    result.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/Claim.item.detail.quantity'));{q3b}
    result.unitPrice := ParseMoney(obj.complex('http://hl7.org/fhir/Claim.item.detail.unitPrice'));{q3b}
    result.factorElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Claim.item.detail.factor'));{q1}
    result.net := ParseMoney(obj.complex('http://hl7.org/fhir/Claim.item.detail.net'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Claim.item.detail.udi') do
      result.udiList.Add(parseReference{TFhirDevice}(item));
    for item in obj.complexes('http://hl7.org/fhir/Claim.item.detail.subDetail') do
      result.subDetailList.Add(parseClaimItemDetailSubDetail(item));
end;

procedure TFHIRTurtleComposer.ComposeClaimItemDetail(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimItemDetail; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimItemDetail'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposePositiveInt(this, 'Claim.item.detail', 'sequence', elem.sequenceElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Claim.item.detail', 'revenue', elem.revenueElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Claim.item.detail', 'category', elem.categoryElement, false, -1);{x.2f}
  ComposeCodeableConcept(this, 'Claim.item.detail', 'productOrService', elem.productOrServiceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.modifierList.Count - 1 do
      ComposeCodeableConcept(this, 'Claim.item.detail', 'modifier', elem.modifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.programCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'Claim.item.detail', 'programCode', elem.programCodeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'Claim.item.detail', 'quantity', elem.quantityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'Claim.item.detail', 'unitPrice', elem.unitPriceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'Claim.item.detail', 'factor', elem.factorElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'Claim.item.detail', 'net', elem.netElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.udiList.Count - 1 do
      ComposeReference{TFhirDevice}(this, 'Claim.item.detail', 'udi', elem.udiList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.subDetailList.Count - 1 do
      ComposeClaimItemDetailSubDetail(this, 'Claim.item.detail', 'subDetail', elem.subDetailList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseClaimItemDetailSubDetail(obj : TTurtleComplex) : TFhirClaimItemDetailSubDetail;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimItemDetailSubDetail.create;
  try
    ParseClaimItemDetailSubDetailProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimItemDetailSubDetailProperties(obj : TTurtleComplex; result : TFhirClaimItemDetailSubDetail);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.sequenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Claim.item.detail.subDetail.sequence'));{q1}
    result.revenue := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Claim.item.detail.subDetail.revenue'));{q3b}
    result.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Claim.item.detail.subDetail.category'));{q3b}
    result.productOrService := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Claim.item.detail.subDetail.productOrService'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Claim.item.detail.subDetail.modifier') do
      result.modifierList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Claim.item.detail.subDetail.programCode') do
      result.programCodeList.Add(parseCodeableConcept(item));
    result.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/Claim.item.detail.subDetail.quantity'));{q3b}
    result.unitPrice := ParseMoney(obj.complex('http://hl7.org/fhir/Claim.item.detail.subDetail.unitPrice'));{q3b}
    result.factorElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Claim.item.detail.subDetail.factor'));{q1}
    result.net := ParseMoney(obj.complex('http://hl7.org/fhir/Claim.item.detail.subDetail.net'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Claim.item.detail.subDetail.udi') do
      result.udiList.Add(parseReference{TFhirDevice}(item));
end;

procedure TFHIRTurtleComposer.ComposeClaimItemDetailSubDetail(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimItemDetailSubDetail; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimItemDetailSubDetail'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposePositiveInt(this, 'Claim.item.detail.subDetail', 'sequence', elem.sequenceElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Claim.item.detail.subDetail', 'revenue', elem.revenueElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Claim.item.detail.subDetail', 'category', elem.categoryElement, false, -1);{x.2f}
  ComposeCodeableConcept(this, 'Claim.item.detail.subDetail', 'productOrService', elem.productOrServiceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.modifierList.Count - 1 do
      ComposeCodeableConcept(this, 'Claim.item.detail.subDetail', 'modifier', elem.modifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.programCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'Claim.item.detail.subDetail', 'programCode', elem.programCodeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'Claim.item.detail.subDetail', 'quantity', elem.quantityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'Claim.item.detail.subDetail', 'unitPrice', elem.unitPriceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'Claim.item.detail.subDetail', 'factor', elem.factorElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'Claim.item.detail.subDetail', 'net', elem.netElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.udiList.Count - 1 do
      ComposeReference{TFhirDevice}(this, 'Claim.item.detail.subDetail', 'udi', elem.udiList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseClaim(obj : TTurtleComplex) : TFhirClaim;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaim.create;
  try
    ParseClaimProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimProperties(obj : TTurtleComplex; result : TFhirClaim);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Claim.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Claim.status'), CODES_TFhirFmStatusEnum, SYSTEMS_TFhirFmStatusEnum);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Claim.type'));{q3b}
    result.subType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Claim.subType'));{q3b}
    result.useElement := ParseEnum(obj.complex('http://hl7.org/fhir/Claim.use'), CODES_TFhirClaimUseEnum, SYSTEMS_TFhirClaimUseEnum);
    result.patient := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/Claim.patient'));{q3b}
    result.billablePeriod := ParsePeriod(obj.complex('http://hl7.org/fhir/Claim.billablePeriod'));{q3b}
    result.createdElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Claim.created'));{q1}
    result.enterer := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/Claim.enterer'));{q3b}
    result.insurer := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/Claim.insurer'));{q3b}
    result.provider := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/Claim.provider'));{q3b}
    result.priority := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Claim.priority'));{q3b}
    result.fundsReserve := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Claim.fundsReserve'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Claim.related') do
      result.relatedList.Add(parseClaimRelated(item));
    result.prescription := ParseReference{TFhirDeviceRequest}(obj.complex('http://hl7.org/fhir/Claim.prescription'));{q3b}
    result.originalPrescription := ParseReference{TFhirDeviceRequest}(obj.complex('http://hl7.org/fhir/Claim.originalPrescription'));{q3b}
    result.payee := ParseClaimPayee(obj.complex('http://hl7.org/fhir/Claim.payee'));{q3b}
    result.referral := ParseReference{TFhirServiceRequest}(obj.complex('http://hl7.org/fhir/Claim.referral'));{q3b}
    result.facility := ParseReference{TFhirLocation}(obj.complex('http://hl7.org/fhir/Claim.facility'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Claim.careTeam') do
      result.careTeamList.Add(parseClaimCareTeam(item));
    for item in obj.complexes('http://hl7.org/fhir/Claim.supportingInfo') do
      result.supportingInfoList.Add(parseClaimSupportingInfo(item));
    for item in obj.complexes('http://hl7.org/fhir/Claim.diagnosis') do
      result.diagnosisList.Add(parseClaimDiagnosis(item));
    for item in obj.complexes('http://hl7.org/fhir/Claim.procedure') do
      result.procedure_List.Add(parseClaimProcedure(item));
    for item in obj.complexes('http://hl7.org/fhir/Claim.insurance') do
      result.insuranceList.Add(parseClaimInsurance(item));
    result.accident := ParseClaimAccident(obj.complex('http://hl7.org/fhir/Claim.accident'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Claim.item') do
      result.itemList.Add(parseClaimItem(item));
    result.total := ParseMoney(obj.complex('http://hl7.org/fhir/Claim.total'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeClaim(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaim; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Claim'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Claim', 'identifier', elem.identifierList[i], false, i);{x.d3}
  ComposeEnum(this, 'Claim', 'status', elem.StatusElement, CODES_TFhirFmStatusEnum, SYSTEMS_TFhirFmStatusEnum, false, -1);{x.d4}
  ComposeCodeableConcept(this, 'Claim', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('subType') then
    ComposeCodeableConcept(this, 'Claim', 'subType', elem.subTypeElement, false, -1);{x.2f}
  ComposeEnum(this, 'Claim', 'use', elem.UseElement, CODES_TFhirClaimUseEnum, SYSTEMS_TFhirClaimUseEnum, false, -1);{x.d4}
  ComposeReference{TFhirPatient}(this, 'Claim', 'patient', elem.patientElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('billablePeriod') then
    ComposePeriod(this, 'Claim', 'billablePeriod', elem.billablePeriodElement, false, -1);{x.2f}
  ComposeDateTime(this, 'Claim', 'created', elem.createdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('enterer') then
    ComposeReference{TFhirPractitioner}(this, 'Claim', 'enterer', elem.entererElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('insurer') then
    ComposeReference{TFhirOrganization}(this, 'Claim', 'insurer', elem.insurerElement, false, -1);{x.2f}
  ComposeReference{TFhirPractitioner}(this, 'Claim', 'provider', elem.providerElement, false, -1);{x.2f}
  ComposeCodeableConcept(this, 'Claim', 'priority', elem.priorityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('fundsReserve') then
    ComposeCodeableConcept(this, 'Claim', 'fundsReserve', elem.fundsReserveElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('related') then
    for i := 0 to elem.relatedList.Count - 1 do
      ComposeClaimRelated(this, 'Claim', 'related', elem.relatedList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('prescription') then
    ComposeReference{TFhirDeviceRequest}(this, 'Claim', 'prescription', elem.prescriptionElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('originalPrescription') then
    ComposeReference{TFhirDeviceRequest}(this, 'Claim', 'originalPrescription', elem.originalPrescriptionElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('payee') then
    ComposeClaimPayee(this, 'Claim', 'payee', elem.payeeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('referral') then
    ComposeReference{TFhirServiceRequest}(this, 'Claim', 'referral', elem.referralElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('facility') then
    ComposeReference{TFhirLocation}(this, 'Claim', 'facility', elem.facilityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('careTeam') then
    for i := 0 to elem.careTeamList.Count - 1 do
      ComposeClaimCareTeam(this, 'Claim', 'careTeam', elem.careTeamList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('supportingInfo') then
    for i := 0 to elem.supportingInfoList.Count - 1 do
      ComposeClaimSupportingInfo(this, 'Claim', 'supportingInfo', elem.supportingInfoList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('diagnosis') then
    for i := 0 to elem.diagnosisList.Count - 1 do
      ComposeClaimDiagnosis(this, 'Claim', 'diagnosis', elem.diagnosisList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('procedure_') then
    for i := 0 to elem.procedure_List.Count - 1 do
      ComposeClaimProcedure(this, 'Claim', 'procedure', elem.procedure_List[i], false, i);{x.d3}
  for i := 0 to elem.insuranceList.Count - 1 do
      ComposeClaimInsurance(this, 'Claim', 'insurance', elem.insuranceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('accident') then
    ComposeClaimAccident(this, 'Claim', 'accident', elem.accidentElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('item') then
    for i := 0 to elem.itemList.Count - 1 do
      ComposeClaimItem(this, 'Claim', 'item', elem.itemList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('total') then
    ComposeMoney(this, 'Claim', 'total', elem.totalElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_CLAIM}
{$IFDEF FHIR_CLAIMRESPONSE}
function TFHIRTurtleParser.ParseClaimResponseItem(obj : TTurtleComplex) : TFhirClaimResponseItem;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimResponseItem.create;
  try
    ParseClaimResponseItemProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimResponseItemProperties(obj : TTurtleComplex; result : TFhirClaimResponseItem);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.itemSequenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/ClaimResponse.item.itemSequence'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.item.noteNumber') do
      result.noteNumberList.Add(parsePositiveInt(item));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.item.adjudication') do
      result.adjudicationList.Add(parseClaimResponseItemAdjudication(item));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.item.detail') do
      result.detailList.Add(parseClaimResponseItemDetail(item));
end;

procedure TFHIRTurtleComposer.ComposeClaimResponseItem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponseItem; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimResponseItem'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposePositiveInt(this, 'ClaimResponse.item', 'itemSequence', elem.itemSequenceElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.noteNumberList.Count - 1 do
      ComposePositiveInt(this, 'ClaimResponse.item', 'noteNumber', elem.noteNumberList[i], false, i);{x.d3}
  for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeClaimResponseItemAdjudication(this, 'ClaimResponse.item', 'adjudication', elem.adjudicationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.detailList.Count - 1 do
      ComposeClaimResponseItemDetail(this, 'ClaimResponse.item', 'detail', elem.detailList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseClaimResponseItemAdjudication(obj : TTurtleComplex) : TFhirClaimResponseItemAdjudication;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimResponseItemAdjudication.create;
  try
    ParseClaimResponseItemAdjudicationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimResponseItemAdjudicationProperties(obj : TTurtleComplex; result : TFhirClaimResponseItemAdjudication);
begin
    ParseBackboneElementProperties(obj, result);
    result.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClaimResponse.item.adjudication.category'));{q3b}
    result.reason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClaimResponse.item.adjudication.reason'));{q3b}
    result.amount := ParseMoney(obj.complex('http://hl7.org/fhir/ClaimResponse.item.adjudication.amount'));{q3b}
    result.valueElement := ParseDecimal(obj.complex('http://hl7.org/fhir/ClaimResponse.item.adjudication.value'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeClaimResponseItemAdjudication(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponseItemAdjudication; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimResponseItemAdjudication'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'ClaimResponse.item.adjudication', 'category', elem.categoryElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ClaimResponse.item.adjudication', 'reason', elem.reasonElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ClaimResponse.item.adjudication', 'amount', elem.amountElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'ClaimResponse.item.adjudication', 'value', elem.valueElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseClaimResponseItemDetail(obj : TTurtleComplex) : TFhirClaimResponseItemDetail;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimResponseItemDetail.create;
  try
    ParseClaimResponseItemDetailProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimResponseItemDetailProperties(obj : TTurtleComplex; result : TFhirClaimResponseItemDetail);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.detailSequenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/ClaimResponse.item.detail.detailSequence'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.item.detail.noteNumber') do
      result.noteNumberList.Add(parsePositiveInt(item));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.item.detail.adjudication') do
      result.adjudicationList.Add(parseClaimResponseItemAdjudication(item));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.item.detail.subDetail') do
      result.subDetailList.Add(parseClaimResponseItemDetailSubDetail(item));
end;

procedure TFHIRTurtleComposer.ComposeClaimResponseItemDetail(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponseItemDetail; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimResponseItemDetail'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposePositiveInt(this, 'ClaimResponse.item.detail', 'detailSequence', elem.detailSequenceElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.noteNumberList.Count - 1 do
      ComposePositiveInt(this, 'ClaimResponse.item.detail', 'noteNumber', elem.noteNumberList[i], false, i);{x.d3}
  for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeClaimResponseItemAdjudication(this, 'ClaimResponse.item.detail', 'adjudication', elem.adjudicationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.subDetailList.Count - 1 do
      ComposeClaimResponseItemDetailSubDetail(this, 'ClaimResponse.item.detail', 'subDetail', elem.subDetailList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseClaimResponseItemDetailSubDetail(obj : TTurtleComplex) : TFhirClaimResponseItemDetailSubDetail;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimResponseItemDetailSubDetail.create;
  try
    ParseClaimResponseItemDetailSubDetailProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimResponseItemDetailSubDetailProperties(obj : TTurtleComplex; result : TFhirClaimResponseItemDetailSubDetail);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.subDetailSequenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/ClaimResponse.item.detail.subDetail.subDetailSequence'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.item.detail.subDetail.noteNumber') do
      result.noteNumberList.Add(parsePositiveInt(item));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.item.detail.subDetail.adjudication') do
      result.adjudicationList.Add(parseClaimResponseItemAdjudication(item));
end;

procedure TFHIRTurtleComposer.ComposeClaimResponseItemDetailSubDetail(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponseItemDetailSubDetail; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimResponseItemDetailSubDetail'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposePositiveInt(this, 'ClaimResponse.item.detail.subDetail', 'subDetailSequence', elem.subDetailSequenceElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.noteNumberList.Count - 1 do
      ComposePositiveInt(this, 'ClaimResponse.item.detail.subDetail', 'noteNumber', elem.noteNumberList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeClaimResponseItemAdjudication(this, 'ClaimResponse.item.detail.subDetail', 'adjudication', elem.adjudicationList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseClaimResponseAddItem(obj : TTurtleComplex) : TFhirClaimResponseAddItem;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimResponseAddItem.create;
  try
    ParseClaimResponseAddItemProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimResponseAddItemProperties(obj : TTurtleComplex; result : TFhirClaimResponseAddItem);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.addItem.itemSequence') do
      result.itemSequenceList.Add(parsePositiveInt(item));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.addItem.detailSequence') do
      result.detailSequenceList.Add(parsePositiveInt(item));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.addItem.subdetailSequence') do
      result.subdetailSequenceList.Add(parsePositiveInt(item));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.addItem.provider') do
      result.providerList.Add(parseReference{TFhirPractitioner}(item));
    result.productOrService := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClaimResponse.addItem.productOrService'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.addItem.modifier') do
      result.modifierList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.addItem.programCode') do
      result.programCodeList.Add(parseCodeableConcept(item));
    if obj.has('http://hl7.org/fhir/ClaimResponse.addItem.servicedPeriod', item) then
      result.serviced := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/ClaimResponse.addItem.servicedDate', item) then
      result.serviced := parseDate(item);
    if obj.has('http://hl7.org/fhir/ClaimResponse.addItem.locationCodeableConcept', item) then
      result.location := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/ClaimResponse.addItem.locationAddress', item) then
      result.location := parseAddress(item);
    if obj.has('http://hl7.org/fhir/ClaimResponse.addItem.locationReference', item) {a3} then
      result.location := ParseReference(item);
    result.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/ClaimResponse.addItem.quantity'));{q3b}
    result.unitPrice := ParseMoney(obj.complex('http://hl7.org/fhir/ClaimResponse.addItem.unitPrice'));{q3b}
    result.factorElement := ParseDecimal(obj.complex('http://hl7.org/fhir/ClaimResponse.addItem.factor'));{q1}
    result.net := ParseMoney(obj.complex('http://hl7.org/fhir/ClaimResponse.addItem.net'));{q3b}
    result.bodySite := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClaimResponse.addItem.bodySite'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.addItem.subSite') do
      result.subSiteList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.addItem.noteNumber') do
      result.noteNumberList.Add(parsePositiveInt(item));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.addItem.adjudication') do
      result.adjudicationList.Add(parseClaimResponseItemAdjudication(item));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.addItem.detail') do
      result.detailList.Add(parseClaimResponseAddItemDetail(item));
end;

procedure TFHIRTurtleComposer.ComposeClaimResponseAddItem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponseAddItem; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimResponseAddItem'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.itemSequenceList.Count - 1 do
      ComposePositiveInt(this, 'ClaimResponse.addItem', 'itemSequence', elem.itemSequenceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.detailSequenceList.Count - 1 do
      ComposePositiveInt(this, 'ClaimResponse.addItem', 'detailSequence', elem.detailSequenceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.subdetailSequenceList.Count - 1 do
      ComposePositiveInt(this, 'ClaimResponse.addItem', 'subdetailSequence', elem.subdetailSequenceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.providerList.Count - 1 do
      ComposeReference{TFhirPractitioner}(this, 'ClaimResponse.addItem', 'provider', elem.providerList[i], false, i);{x.d3}
  ComposeCodeableConcept(this, 'ClaimResponse.addItem', 'productOrService', elem.productOrServiceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.modifierList.Count - 1 do
      ComposeCodeableConcept(this, 'ClaimResponse.addItem', 'modifier', elem.modifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.programCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'ClaimResponse.addItem', 'programCode', elem.programCodeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and (elem.serviced is TFhirPeriod) {6} then
    ComposePeriod(this, 'ClaimResponse.addItem', 'servicedPeriod', TFhirPeriod(elem.serviced), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.serviced is TFhirDate) {6} then
    ComposeDate(this, 'ClaimResponse.addItem', 'servicedDate', TFhirDate(elem.serviced), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) and (elem.location is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'ClaimResponse.addItem', 'locationCodeableConcept', TFhirCodeableConcept(elem.location), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.location is TFhirAddress) {6} then
    ComposeAddress(this, 'ClaimResponse.addItem', 'locationAddress', TFhirAddress(elem.location), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.location is TFhirReference) {2} then
    ComposeReference(this, 'ClaimResponse.addItem', 'locationReference', TFhirReference(elem.location), false,-1);{x.d8}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'ClaimResponse.addItem', 'quantity', elem.quantityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ClaimResponse.addItem', 'unitPrice', elem.unitPriceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'ClaimResponse.addItem', 'factor', elem.factorElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ClaimResponse.addItem', 'net', elem.netElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ClaimResponse.addItem', 'bodySite', elem.bodySiteElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.subSiteList.Count - 1 do
      ComposeCodeableConcept(this, 'ClaimResponse.addItem', 'subSite', elem.subSiteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.noteNumberList.Count - 1 do
      ComposePositiveInt(this, 'ClaimResponse.addItem', 'noteNumber', elem.noteNumberList[i], false, i);{x.d3}
  for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeClaimResponseItemAdjudication(this, 'ClaimResponse.addItem', 'adjudication', elem.adjudicationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.detailList.Count - 1 do
      ComposeClaimResponseAddItemDetail(this, 'ClaimResponse.addItem', 'detail', elem.detailList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseClaimResponseAddItemDetail(obj : TTurtleComplex) : TFhirClaimResponseAddItemDetail;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimResponseAddItemDetail.create;
  try
    ParseClaimResponseAddItemDetailProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimResponseAddItemDetailProperties(obj : TTurtleComplex; result : TFhirClaimResponseAddItemDetail);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.productOrService := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClaimResponse.addItem.detail.productOrService'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.addItem.detail.modifier') do
      result.modifierList.Add(parseCodeableConcept(item));
    result.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/ClaimResponse.addItem.detail.quantity'));{q3b}
    result.unitPrice := ParseMoney(obj.complex('http://hl7.org/fhir/ClaimResponse.addItem.detail.unitPrice'));{q3b}
    result.factorElement := ParseDecimal(obj.complex('http://hl7.org/fhir/ClaimResponse.addItem.detail.factor'));{q1}
    result.net := ParseMoney(obj.complex('http://hl7.org/fhir/ClaimResponse.addItem.detail.net'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.addItem.detail.noteNumber') do
      result.noteNumberList.Add(parsePositiveInt(item));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.addItem.detail.adjudication') do
      result.adjudicationList.Add(parseClaimResponseItemAdjudication(item));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.addItem.detail.subDetail') do
      result.subDetailList.Add(parseClaimResponseAddItemDetailSubDetail(item));
end;

procedure TFHIRTurtleComposer.ComposeClaimResponseAddItemDetail(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponseAddItemDetail; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimResponseAddItemDetail'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'ClaimResponse.addItem.detail', 'productOrService', elem.productOrServiceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.modifierList.Count - 1 do
      ComposeCodeableConcept(this, 'ClaimResponse.addItem.detail', 'modifier', elem.modifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'ClaimResponse.addItem.detail', 'quantity', elem.quantityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ClaimResponse.addItem.detail', 'unitPrice', elem.unitPriceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'ClaimResponse.addItem.detail', 'factor', elem.factorElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ClaimResponse.addItem.detail', 'net', elem.netElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.noteNumberList.Count - 1 do
      ComposePositiveInt(this, 'ClaimResponse.addItem.detail', 'noteNumber', elem.noteNumberList[i], false, i);{x.d3}
  for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeClaimResponseItemAdjudication(this, 'ClaimResponse.addItem.detail', 'adjudication', elem.adjudicationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.subDetailList.Count - 1 do
      ComposeClaimResponseAddItemDetailSubDetail(this, 'ClaimResponse.addItem.detail', 'subDetail', elem.subDetailList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseClaimResponseAddItemDetailSubDetail(obj : TTurtleComplex) : TFhirClaimResponseAddItemDetailSubDetail;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimResponseAddItemDetailSubDetail.create;
  try
    ParseClaimResponseAddItemDetailSubDetailProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimResponseAddItemDetailSubDetailProperties(obj : TTurtleComplex; result : TFhirClaimResponseAddItemDetailSubDetail);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.productOrService := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClaimResponse.addItem.detail.subDetail.productOrService'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.addItem.detail.subDetail.modifier') do
      result.modifierList.Add(parseCodeableConcept(item));
    result.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/ClaimResponse.addItem.detail.subDetail.quantity'));{q3b}
    result.unitPrice := ParseMoney(obj.complex('http://hl7.org/fhir/ClaimResponse.addItem.detail.subDetail.unitPrice'));{q3b}
    result.factorElement := ParseDecimal(obj.complex('http://hl7.org/fhir/ClaimResponse.addItem.detail.subDetail.factor'));{q1}
    result.net := ParseMoney(obj.complex('http://hl7.org/fhir/ClaimResponse.addItem.detail.subDetail.net'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.addItem.detail.subDetail.noteNumber') do
      result.noteNumberList.Add(parsePositiveInt(item));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.addItem.detail.subDetail.adjudication') do
      result.adjudicationList.Add(parseClaimResponseItemAdjudication(item));
end;

procedure TFHIRTurtleComposer.ComposeClaimResponseAddItemDetailSubDetail(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponseAddItemDetailSubDetail; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimResponseAddItemDetailSubDetail'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'ClaimResponse.addItem.detail.subDetail', 'productOrService', elem.productOrServiceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.modifierList.Count - 1 do
      ComposeCodeableConcept(this, 'ClaimResponse.addItem.detail.subDetail', 'modifier', elem.modifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'ClaimResponse.addItem.detail.subDetail', 'quantity', elem.quantityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ClaimResponse.addItem.detail.subDetail', 'unitPrice', elem.unitPriceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'ClaimResponse.addItem.detail.subDetail', 'factor', elem.factorElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ClaimResponse.addItem.detail.subDetail', 'net', elem.netElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.noteNumberList.Count - 1 do
      ComposePositiveInt(this, 'ClaimResponse.addItem.detail.subDetail', 'noteNumber', elem.noteNumberList[i], false, i);{x.d3}
  for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeClaimResponseItemAdjudication(this, 'ClaimResponse.addItem.detail.subDetail', 'adjudication', elem.adjudicationList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseClaimResponseTotal(obj : TTurtleComplex) : TFhirClaimResponseTotal;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimResponseTotal.create;
  try
    ParseClaimResponseTotalProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimResponseTotalProperties(obj : TTurtleComplex; result : TFhirClaimResponseTotal);
begin
    ParseBackboneElementProperties(obj, result);
    result.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClaimResponse.total.category'));{q3b}
    result.amount := ParseMoney(obj.complex('http://hl7.org/fhir/ClaimResponse.total.amount'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeClaimResponseTotal(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponseTotal; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimResponseTotal'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'ClaimResponse.total', 'category', elem.categoryElement, false, -1);{x.2f}
  ComposeMoney(this, 'ClaimResponse.total', 'amount', elem.amountElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseClaimResponsePayment(obj : TTurtleComplex) : TFhirClaimResponsePayment;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimResponsePayment.create;
  try
    ParseClaimResponsePaymentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimResponsePaymentProperties(obj : TTurtleComplex; result : TFhirClaimResponsePayment);
begin
    ParseBackboneElementProperties(obj, result);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClaimResponse.payment.type'));{q3b}
    result.adjustment := ParseMoney(obj.complex('http://hl7.org/fhir/ClaimResponse.payment.adjustment'));{q3b}
    result.adjustmentReason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClaimResponse.payment.adjustmentReason'));{q3b}
    result.dateElement := ParseDate(obj.complex('http://hl7.org/fhir/ClaimResponse.payment.date'));{q1}
    result.amount := ParseMoney(obj.complex('http://hl7.org/fhir/ClaimResponse.payment.amount'));{q3b}
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/ClaimResponse.payment.identifier'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeClaimResponsePayment(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponsePayment; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimResponsePayment'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'ClaimResponse.payment', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ClaimResponse.payment', 'adjustment', elem.adjustmentElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ClaimResponse.payment', 'adjustmentReason', elem.adjustmentReasonElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(this, 'ClaimResponse.payment', 'date', elem.dateElement, false, -1);{x.2ea}
  ComposeMoney(this, 'ClaimResponse.payment', 'amount', elem.amountElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(this, 'ClaimResponse.payment', 'identifier', elem.identifierElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseClaimResponseProcessNote(obj : TTurtleComplex) : TFhirClaimResponseProcessNote;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimResponseProcessNote.create;
  try
    ParseClaimResponseProcessNoteProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimResponseProcessNoteProperties(obj : TTurtleComplex; result : TFhirClaimResponseProcessNote);
begin
    ParseBackboneElementProperties(obj, result);
    result.numberElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/ClaimResponse.processNote.number'));{q1}
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/ClaimResponse.processNote.type'), CODES_TFhirNoteTypeEnum, SYSTEMS_TFhirNoteTypeEnum);
    result.textElement := ParseString(obj.complex('http://hl7.org/fhir/ClaimResponse.processNote.text'));{q1}
    result.language := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClaimResponse.processNote.language'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeClaimResponseProcessNote(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponseProcessNote; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimResponseProcessNote'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(this, 'ClaimResponse.processNote', 'number', elem.numberElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'ClaimResponse.processNote', 'type', elem.Type_Element, CODES_TFhirNoteTypeEnum, SYSTEMS_TFhirNoteTypeEnum, false, -1);{x.d4}
  ComposeString(this, 'ClaimResponse.processNote', 'text', elem.textElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ClaimResponse.processNote', 'language', elem.languageElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseClaimResponseInsurance(obj : TTurtleComplex) : TFhirClaimResponseInsurance;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimResponseInsurance.create;
  try
    ParseClaimResponseInsuranceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimResponseInsuranceProperties(obj : TTurtleComplex; result : TFhirClaimResponseInsurance);
begin
    ParseBackboneElementProperties(obj, result);
    result.sequenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/ClaimResponse.insurance.sequence'));{q1}
    result.focalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ClaimResponse.insurance.focal'));{q1}
    result.coverage := ParseReference{TFhirCoverage}(obj.complex('http://hl7.org/fhir/ClaimResponse.insurance.coverage'));{q3b}
    result.businessArrangementElement := ParseString(obj.complex('http://hl7.org/fhir/ClaimResponse.insurance.businessArrangement'));{q1}
    result.claimResponse := ParseReference{TFhirClaimResponse}(obj.complex('http://hl7.org/fhir/ClaimResponse.insurance.claimResponse'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeClaimResponseInsurance(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponseInsurance; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimResponseInsurance'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposePositiveInt(this, 'ClaimResponse.insurance', 'sequence', elem.sequenceElement, false, -1);{x.2ea}
  ComposeBoolean(this, 'ClaimResponse.insurance', 'focal', elem.focalElement, false, -1);{x.2ea}
  ComposeReference{TFhirCoverage}(this, 'ClaimResponse.insurance', 'coverage', elem.coverageElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ClaimResponse.insurance', 'businessArrangement', elem.businessArrangementElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirClaimResponse}(this, 'ClaimResponse.insurance', 'claimResponse', elem.claimResponseElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseClaimResponseError(obj : TTurtleComplex) : TFhirClaimResponseError;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimResponseError.create;
  try
    ParseClaimResponseErrorProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimResponseErrorProperties(obj : TTurtleComplex; result : TFhirClaimResponseError);
begin
    ParseBackboneElementProperties(obj, result);
    result.itemSequenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/ClaimResponse.error.itemSequence'));{q1}
    result.detailSequenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/ClaimResponse.error.detailSequence'));{q1}
    result.subDetailSequenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/ClaimResponse.error.subDetailSequence'));{q1}
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClaimResponse.error.code'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeClaimResponseError(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponseError; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimResponseError'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(this, 'ClaimResponse.error', 'itemSequence', elem.itemSequenceElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(this, 'ClaimResponse.error', 'detailSequence', elem.detailSequenceElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(this, 'ClaimResponse.error', 'subDetailSequence', elem.subDetailSequenceElement, false, -1);{x.2ea}
  ComposeCodeableConcept(this, 'ClaimResponse.error', 'code', elem.codeElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseClaimResponse(obj : TTurtleComplex) : TFhirClaimResponse;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClaimResponse.create;
  try
    ParseClaimResponseProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClaimResponseProperties(obj : TTurtleComplex; result : TFhirClaimResponse);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/ClaimResponse.status'), CODES_TFhirFmStatusEnum, SYSTEMS_TFhirFmStatusEnum);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClaimResponse.type'));{q3b}
    result.subType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClaimResponse.subType'));{q3b}
    result.useElement := ParseEnum(obj.complex('http://hl7.org/fhir/ClaimResponse.use'), CODES_TFhirClaimUseEnum, SYSTEMS_TFhirClaimUseEnum);
    result.patient := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/ClaimResponse.patient'));{q3b}
    result.createdElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ClaimResponse.created'));{q1}
    result.insurer := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/ClaimResponse.insurer'));{q3b}
    result.requestor := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/ClaimResponse.requestor'));{q3b}
    result.request := ParseReference{TFhirClaim}(obj.complex('http://hl7.org/fhir/ClaimResponse.request'));{q3b}
    result.outcomeElement := ParseEnum(obj.complex('http://hl7.org/fhir/ClaimResponse.outcome'), CODES_TFhirRemittanceOutcomeEnum, SYSTEMS_TFhirRemittanceOutcomeEnum);
    result.dispositionElement := ParseString(obj.complex('http://hl7.org/fhir/ClaimResponse.disposition'));{q1}
    result.preAuthRefElement := ParseString(obj.complex('http://hl7.org/fhir/ClaimResponse.preAuthRef'));{q1}
    result.preAuthPeriod := ParsePeriod(obj.complex('http://hl7.org/fhir/ClaimResponse.preAuthPeriod'));{q3b}
    result.payeeType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClaimResponse.payeeType'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.item') do
      result.itemList.Add(parseClaimResponseItem(item));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.addItem') do
      result.addItemList.Add(parseClaimResponseAddItem(item));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.adjudication') do
      result.adjudicationList.Add(parseClaimResponseItemAdjudication(item));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.total') do
      result.totalList.Add(parseClaimResponseTotal(item));
    result.payment := ParseClaimResponsePayment(obj.complex('http://hl7.org/fhir/ClaimResponse.payment'));{q3b}
    result.fundsReserve := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClaimResponse.fundsReserve'));{q3b}
    result.formCode := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClaimResponse.formCode'));{q3b}
    result.form := ParseAttachment(obj.complex('http://hl7.org/fhir/ClaimResponse.form'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.processNote') do
      result.processNoteList.Add(parseClaimResponseProcessNote(item));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.communicationRequest') do
      result.communicationRequestList.Add(parseReference{TFhirCommunicationRequest}(item));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.insurance') do
      result.insuranceList.Add(parseClaimResponseInsurance(item));
    for item in obj.complexes('http://hl7.org/fhir/ClaimResponse.error') do
      result.errorList.Add(parseClaimResponseError(item));
end;

procedure TFHIRTurtleComposer.ComposeClaimResponse(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClaimResponse; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClaimResponse'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'ClaimResponse', 'identifier', elem.identifierList[i], false, i);{x.d3}
  ComposeEnum(this, 'ClaimResponse', 'status', elem.StatusElement, CODES_TFhirFmStatusEnum, SYSTEMS_TFhirFmStatusEnum, false, -1);{x.d4}
  ComposeCodeableConcept(this, 'ClaimResponse', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('subType') then
    ComposeCodeableConcept(this, 'ClaimResponse', 'subType', elem.subTypeElement, false, -1);{x.2f}
  ComposeEnum(this, 'ClaimResponse', 'use', elem.UseElement, CODES_TFhirClaimUseEnum, SYSTEMS_TFhirClaimUseEnum, false, -1);{x.d4}
  ComposeReference{TFhirPatient}(this, 'ClaimResponse', 'patient', elem.patientElement, false, -1);{x.2f}
  ComposeDateTime(this, 'ClaimResponse', 'created', elem.createdElement, false, -1);{x.2ea}
  ComposeReference{TFhirOrganization}(this, 'ClaimResponse', 'insurer', elem.insurerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('requestor') then
    ComposeReference{TFhirPractitioner}(this, 'ClaimResponse', 'requestor', elem.requestorElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('request') then
    ComposeReference{TFhirClaim}(this, 'ClaimResponse', 'request', elem.requestElement, false, -1);{x.2f}
  ComposeEnum(this, 'ClaimResponse', 'outcome', elem.OutcomeElement, CODES_TFhirRemittanceOutcomeEnum, SYSTEMS_TFhirRemittanceOutcomeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('disposition') then
    ComposeString(this, 'ClaimResponse', 'disposition', elem.dispositionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('preAuthRef') then
    ComposeString(this, 'ClaimResponse', 'preAuthRef', elem.preAuthRefElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('preAuthPeriod') then
    ComposePeriod(this, 'ClaimResponse', 'preAuthPeriod', elem.preAuthPeriodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('payeeType') then
    ComposeCodeableConcept(this, 'ClaimResponse', 'payeeType', elem.payeeTypeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('item') then
    for i := 0 to elem.itemList.Count - 1 do
      ComposeClaimResponseItem(this, 'ClaimResponse', 'item', elem.itemList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('addItem') then
    for i := 0 to elem.addItemList.Count - 1 do
      ComposeClaimResponseAddItem(this, 'ClaimResponse', 'addItem', elem.addItemList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('adjudication') then
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeClaimResponseItemAdjudication(this, 'ClaimResponse', 'adjudication', elem.adjudicationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('total') then
    for i := 0 to elem.totalList.Count - 1 do
      ComposeClaimResponseTotal(this, 'ClaimResponse', 'total', elem.totalList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('payment') then
    ComposeClaimResponsePayment(this, 'ClaimResponse', 'payment', elem.paymentElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('fundsReserve') then
    ComposeCodeableConcept(this, 'ClaimResponse', 'fundsReserve', elem.fundsReserveElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('formCode') then
    ComposeCodeableConcept(this, 'ClaimResponse', 'formCode', elem.formCodeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('form') then
    ComposeAttachment(this, 'ClaimResponse', 'form', elem.formElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('processNote') then
    for i := 0 to elem.processNoteList.Count - 1 do
      ComposeClaimResponseProcessNote(this, 'ClaimResponse', 'processNote', elem.processNoteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('communicationRequest') then
    for i := 0 to elem.communicationRequestList.Count - 1 do
      ComposeReference{TFhirCommunicationRequest}(this, 'ClaimResponse', 'communicationRequest', elem.communicationRequestList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('insurance') then
    for i := 0 to elem.insuranceList.Count - 1 do
      ComposeClaimResponseInsurance(this, 'ClaimResponse', 'insurance', elem.insuranceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('error') then
    for i := 0 to elem.errorList.Count - 1 do
      ComposeClaimResponseError(this, 'ClaimResponse', 'error', elem.errorList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_CLAIMRESPONSE}
{$IFDEF FHIR_CLINICALIMPRESSION}
function TFHIRTurtleParser.ParseClinicalImpressionInvestigation(obj : TTurtleComplex) : TFhirClinicalImpressionInvestigation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClinicalImpressionInvestigation.create;
  try
    ParseClinicalImpressionInvestigationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClinicalImpressionInvestigationProperties(obj : TTurtleComplex; result : TFhirClinicalImpressionInvestigation);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClinicalImpression.investigation.code'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ClinicalImpression.investigation.item') do
      result.itemList.Add(parseReference{TFhirObservation}(item));
end;

procedure TFHIRTurtleComposer.ComposeClinicalImpressionInvestigation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClinicalImpressionInvestigation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClinicalImpressionInvestigation'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'ClinicalImpression.investigation', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.itemList.Count - 1 do
      ComposeReference{TFhirObservation}(this, 'ClinicalImpression.investigation', 'item', elem.itemList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseClinicalImpressionFinding(obj : TTurtleComplex) : TFhirClinicalImpressionFinding;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClinicalImpressionFinding.create;
  try
    ParseClinicalImpressionFindingProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClinicalImpressionFindingProperties(obj : TTurtleComplex; result : TFhirClinicalImpressionFinding);
begin
    ParseBackboneElementProperties(obj, result);
    result.itemCodeableConcept := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClinicalImpression.finding.itemCodeableConcept'));{q3b}
    result.itemReference := ParseReference{TFhirCondition}(obj.complex('http://hl7.org/fhir/ClinicalImpression.finding.itemReference'));{q3b}
    result.basisElement := ParseString(obj.complex('http://hl7.org/fhir/ClinicalImpression.finding.basis'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeClinicalImpressionFinding(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClinicalImpressionFinding; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClinicalImpressionFinding'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ClinicalImpression.finding', 'itemCodeableConcept', elem.itemCodeableConceptElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirCondition}(this, 'ClinicalImpression.finding', 'itemReference', elem.itemReferenceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ClinicalImpression.finding', 'basis', elem.basisElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseClinicalImpression(obj : TTurtleComplex) : TFhirClinicalImpression;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirClinicalImpression.create;
  try
    ParseClinicalImpressionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseClinicalImpressionProperties(obj : TTurtleComplex; result : TFhirClinicalImpression);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/ClinicalImpression.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/ClinicalImpression.status'), CODES_TFhirClinicalimpressionStatusEnum, SYSTEMS_TFhirClinicalimpressionStatusEnum);
    result.statusReason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClinicalImpression.statusReason'));{q3b}
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ClinicalImpression.code'));{q3b}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/ClinicalImpression.description'));{q1}
    result.subject := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/ClinicalImpression.subject'));{q3b}
    result.encounter := ParseReference{TFhirEncounter}(obj.complex('http://hl7.org/fhir/ClinicalImpression.encounter'));{q3b}
    if obj.has('http://hl7.org/fhir/ClinicalImpression.effectivePeriod', item) then
      result.effective := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/ClinicalImpression.effectiveDateTime', item) then
      result.effective := parseDateTime(item);
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ClinicalImpression.date'));{q1}
    result.assessor := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/ClinicalImpression.assessor'));{q3b}
    result.previous := ParseReference{TFhirClinicalImpression}(obj.complex('http://hl7.org/fhir/ClinicalImpression.previous'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ClinicalImpression.problem') do
      result.problemList.Add(parseReference{TFhirCondition}(item));
    for item in obj.complexes('http://hl7.org/fhir/ClinicalImpression.investigation') do
      result.investigationList.Add(parseClinicalImpressionInvestigation(item));
    for item in obj.complexes('http://hl7.org/fhir/ClinicalImpression.protocol') do
      result.protocolList.Add(parseUri(item));
    result.summaryElement := ParseString(obj.complex('http://hl7.org/fhir/ClinicalImpression.summary'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ClinicalImpression.finding') do
      result.findingList.Add(parseClinicalImpressionFinding(item));
    for item in obj.complexes('http://hl7.org/fhir/ClinicalImpression.prognosisCodeableConcept') do
      result.prognosisCodeableConceptList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/ClinicalImpression.prognosisReference') do
      result.prognosisReferenceList.Add(parseReference{TFhirRiskAssessment}(item));
    for item in obj.complexes('http://hl7.org/fhir/ClinicalImpression.supportingInfo') do
      result.supportingInfoList.Add(parseReference{TFhirReference}(item));
    for item in obj.complexes('http://hl7.org/fhir/ClinicalImpression.note') do
      result.noteList.Add(parseAnnotation(item));
end;

procedure TFHIRTurtleComposer.ComposeClinicalImpression(parent :  TTurtleComplex; parentType, name : String; elem : TFhirClinicalImpression; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ClinicalImpression'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'ClinicalImpression', 'identifier', elem.identifierList[i], false, i);{x.d3}
  ComposeEnum(this, 'ClinicalImpression', 'status', elem.StatusElement, CODES_TFhirClinicalimpressionStatusEnum, SYSTEMS_TFhirClinicalimpressionStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('statusReason') then
    ComposeCodeableConcept(this, 'ClinicalImpression', 'statusReason', elem.statusReasonElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') then
    ComposeCodeableConcept(this, 'ClinicalImpression', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeString(this, 'ClinicalImpression', 'description', elem.descriptionElement, false, -1);{x.2ea}
  ComposeReference{TFhirPatient}(this, 'ClinicalImpression', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(this, 'ClinicalImpression', 'encounter', elem.encounterElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.effective is TFhirPeriod) {6} then
    ComposePeriod(this, 'ClinicalImpression', 'effectivePeriod', TFhirPeriod(elem.effective), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.effective is TFhirDateTime) {6} then
    ComposeDateTime(this, 'ClinicalImpression', 'effectiveDateTime', TFhirDateTime(elem.effective), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(this, 'ClinicalImpression', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('assessor') then
    ComposeReference{TFhirPractitioner}(this, 'ClinicalImpression', 'assessor', elem.assessorElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('previous') then
    ComposeReference{TFhirClinicalImpression}(this, 'ClinicalImpression', 'previous', elem.previousElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('problem') then
    for i := 0 to elem.problemList.Count - 1 do
      ComposeReference{TFhirCondition}(this, 'ClinicalImpression', 'problem', elem.problemList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('investigation') then
    for i := 0 to elem.investigationList.Count - 1 do
      ComposeClinicalImpressionInvestigation(this, 'ClinicalImpression', 'investigation', elem.investigationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('protocol') then
    for i := 0 to elem.protocolList.Count - 1 do
      ComposeUri(this, 'ClinicalImpression', 'protocol', elem.protocolList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('summary') then
    ComposeString(this, 'ClinicalImpression', 'summary', elem.summaryElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('finding') then
    for i := 0 to elem.findingList.Count - 1 do
      ComposeClinicalImpressionFinding(this, 'ClinicalImpression', 'finding', elem.findingList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('prognosisCodeableConcept') then
    for i := 0 to elem.prognosisCodeableConceptList.Count - 1 do
      ComposeCodeableConcept(this, 'ClinicalImpression', 'prognosisCodeableConcept', elem.prognosisCodeableConceptList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('prognosisReference') then
    for i := 0 to elem.prognosisReferenceList.Count - 1 do
      ComposeReference{TFhirRiskAssessment}(this, 'ClinicalImpression', 'prognosisReference', elem.prognosisReferenceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('supportingInfo') then
    for i := 0 to elem.supportingInfoList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'ClinicalImpression', 'supportingInfo', elem.supportingInfoList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'ClinicalImpression', 'note', elem.noteList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_CLINICALIMPRESSION}
{$IFDEF FHIR_CODESYSTEM}
function TFHIRTurtleParser.ParseCodeSystemFilter(obj : TTurtleComplex) : TFhirCodeSystemFilter;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCodeSystemFilter.create;
  try
    ParseCodeSystemFilterProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCodeSystemFilterProperties(obj : TTurtleComplex; result : TFhirCodeSystemFilter);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.codeElement := ParseCode(obj.complex('http://hl7.org/fhir/CodeSystem.filter.code'));{q1}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/CodeSystem.filter.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/CodeSystem.filter.operator') do
      result.operatorList.Add(parseEnum(item, CODES_TFhirFilterOperatorEnum, SYSTEMS_TFhirFilterOperatorEnum));
    result.valueElement := ParseString(obj.complex('http://hl7.org/fhir/CodeSystem.filter.value'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeCodeSystemFilter(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCodeSystemFilter; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CodeSystemFilter'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCode(this, 'CodeSystem.filter', 'code', elem.codeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'CodeSystem.filter', 'description', elem.descriptionElement, false, -1);{x.2ea}
  for i := 0 to elem.operatorList.Count - 1 do
      ComposeEnum(this, 'CodeSystem.filter', 'operator', elem.operatorList[i], CODES_TFhirFilterOperatorEnum, SYSTEMS_TFhirFilterOperatorEnum, false, i); {x.d1}
  for i := 0 to elem.operatorList.Count - 1 do
      ComposeEnum(this, 'CodeSystem.filter', 'operator', elem.operatorList[i], CODES_TFhirFilterOperatorEnum, SYSTEMS_TFhirFilterOperatorEnum, false, i);{x.d2}
  ComposeString(this, 'CodeSystem.filter', 'value', elem.valueElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseCodeSystemProperty(obj : TTurtleComplex) : TFhirCodeSystemProperty;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCodeSystemProperty.create;
  try
    ParseCodeSystemPropertyProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCodeSystemPropertyProperties(obj : TTurtleComplex; result : TFhirCodeSystemProperty);
begin
    ParseBackboneElementProperties(obj, result);
    result.codeElement := ParseCode(obj.complex('http://hl7.org/fhir/CodeSystem.property.code'));{q1}
    result.uriElement := ParseUri(obj.complex('http://hl7.org/fhir/CodeSystem.property.uri'));{q1}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/CodeSystem.property.description'));{q1}
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/CodeSystem.property.type'), CODES_TFhirConceptPropertyTypeEnum, SYSTEMS_TFhirConceptPropertyTypeEnum);
end;

procedure TFHIRTurtleComposer.ComposeCodeSystemProperty(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCodeSystemProperty; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CodeSystemProperty'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCode(this, 'CodeSystem.property', 'code', elem.codeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'CodeSystem.property', 'uri', elem.uriElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'CodeSystem.property', 'description', elem.descriptionElement, false, -1);{x.2ea}
  ComposeEnum(this, 'CodeSystem.property', 'type', elem.Type_Element, CODES_TFhirConceptPropertyTypeEnum, SYSTEMS_TFhirConceptPropertyTypeEnum, false, -1);{x.d4}
end;

function TFHIRTurtleParser.ParseCodeSystemConcept(obj : TTurtleComplex) : TFhirCodeSystemConcept;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCodeSystemConcept.create;
  try
    ParseCodeSystemConceptProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCodeSystemConceptProperties(obj : TTurtleComplex; result : TFhirCodeSystemConcept);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.codeElement := ParseCode(obj.complex('http://hl7.org/fhir/CodeSystem.concept.code'));{q1}
    result.displayElement := ParseString(obj.complex('http://hl7.org/fhir/CodeSystem.concept.display'));{q1}
    result.definitionElement := ParseString(obj.complex('http://hl7.org/fhir/CodeSystem.concept.definition'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/CodeSystem.concept.designation') do
      result.designationList.Add(parseCodeSystemConceptDesignation(item));
    for item in obj.complexes('http://hl7.org/fhir/CodeSystem.concept.property') do
      result.property_List.Add(parseCodeSystemConceptProperty(item));
    for item in obj.complexes('http://hl7.org/fhir/CodeSystem.concept.concept') do
      result.conceptList.Add(parseCodeSystemConcept(item));
end;

procedure TFHIRTurtleComposer.ComposeCodeSystemConcept(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCodeSystemConcept; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CodeSystemConcept'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCode(this, 'CodeSystem.concept', 'code', elem.codeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'CodeSystem.concept', 'display', elem.displayElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'CodeSystem.concept', 'definition', elem.definitionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.designationList.Count - 1 do
      ComposeCodeSystemConceptDesignation(this, 'CodeSystem.concept', 'designation', elem.designationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.property_List.Count - 1 do
      ComposeCodeSystemConceptProperty(this, 'CodeSystem.concept', 'property', elem.property_List[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.conceptList.Count - 1 do
      ComposeCodeSystemConcept(this, 'CodeSystem.concept', 'concept', elem.conceptList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseCodeSystemConceptDesignation(obj : TTurtleComplex) : TFhirCodeSystemConceptDesignation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCodeSystemConceptDesignation.create;
  try
    ParseCodeSystemConceptDesignationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCodeSystemConceptDesignationProperties(obj : TTurtleComplex; result : TFhirCodeSystemConceptDesignation);
begin
    ParseBackboneElementProperties(obj, result);
    result.languageElement := ParseCode(obj.complex('http://hl7.org/fhir/CodeSystem.concept.designation.language'));{q1}
    result.use := ParseCoding(obj.complex('http://hl7.org/fhir/CodeSystem.concept.designation.use'));{q3b}
    result.valueElement := ParseString(obj.complex('http://hl7.org/fhir/CodeSystem.concept.designation.value'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeCodeSystemConceptDesignation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCodeSystemConceptDesignation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CodeSystemConceptDesignation'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(this, 'CodeSystem.concept.designation', 'language', elem.languageElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(this, 'CodeSystem.concept.designation', 'use', elem.useElement, false, -1);{x.2f}
  ComposeString(this, 'CodeSystem.concept.designation', 'value', elem.valueElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseCodeSystemConceptProperty(obj : TTurtleComplex) : TFhirCodeSystemConceptProperty;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCodeSystemConceptProperty.create;
  try
    ParseCodeSystemConceptPropertyProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCodeSystemConceptPropertyProperties(obj : TTurtleComplex; result : TFhirCodeSystemConceptProperty);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.codeElement := ParseCode(obj.complex('http://hl7.org/fhir/CodeSystem.concept.property.code'));{q1}
    if obj.has('http://hl7.org/fhir/CodeSystem.concept.property.valueCode', item) then
      result.value := parseCode(item);
    if obj.has('http://hl7.org/fhir/CodeSystem.concept.property.valueCoding', item) then
      result.value := parseCoding(item);
    if obj.has('http://hl7.org/fhir/CodeSystem.concept.property.valueString', item) then
      result.value := parseString(item);
    if obj.has('http://hl7.org/fhir/CodeSystem.concept.property.valueInteger', item) then
      result.value := parseInteger(item);
    if obj.has('http://hl7.org/fhir/CodeSystem.concept.property.valueBoolean', item) then
      result.value := parseBoolean(item);
    if obj.has('http://hl7.org/fhir/CodeSystem.concept.property.valueDateTime', item) then
      result.value := parseDateTime(item);
    if obj.has('http://hl7.org/fhir/CodeSystem.concept.property.valueDecimal', item) then
      result.value := parseDecimal(item);
end;

procedure TFHIRTurtleComposer.ComposeCodeSystemConceptProperty(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCodeSystemConceptProperty; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CodeSystemConceptProperty'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCode(this, 'CodeSystem.concept.property', 'code', elem.codeElement, false, -1);{x.2ea}
  if (elem.value is TFhirCode) {6} then
    ComposeCode(this, 'CodeSystem.concept.property', 'valueCode', TFhirCode(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirCoding) {6} then
    ComposeCoding(this, 'CodeSystem.concept.property', 'valueCoding', TFhirCoding(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirString) {6} then
    ComposeString(this, 'CodeSystem.concept.property', 'valueString', TFhirString(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirInteger) {6} then
    ComposeInteger(this, 'CodeSystem.concept.property', 'valueInteger', TFhirInteger(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirBoolean) {6} then
    ComposeBoolean(this, 'CodeSystem.concept.property', 'valueBoolean', TFhirBoolean(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirDateTime) {6} then
    ComposeDateTime(this, 'CodeSystem.concept.property', 'valueDateTime', TFhirDateTime(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirDecimal) {6} then
    ComposeDecimal(this, 'CodeSystem.concept.property', 'valueDecimal', TFhirDecimal(elem.value), false, -1);{x.d9}
end;

function TFHIRTurtleParser.ParseCodeSystem(obj : TTurtleComplex) : TFhirCodeSystem;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCodeSystem.create;
  try
    ParseCodeSystemProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCodeSystemProperties(obj : TTurtleComplex; result : TFhirCodeSystem);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/CodeSystem.url'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/CodeSystem.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/CodeSystem.version'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/CodeSystem.name'));{q1}
    result.titleElement := ParseString(obj.complex('http://hl7.org/fhir/CodeSystem.title'));{q1}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/CodeSystem.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    result.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/CodeSystem.experimental'));{q1}
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/CodeSystem.date'));{q1}
    result.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/CodeSystem.publisher'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/CodeSystem.contact') do
      result.contactList.Add(parseContactDetail(item));
    result.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/CodeSystem.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/CodeSystem.useContext') do
      result.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/CodeSystem.jurisdiction') do
      result.jurisdictionList.Add(parseCodeableConcept(item));
    result.purposeElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/CodeSystem.purpose'));{q1}
    result.copyrightElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/CodeSystem.copyright'));{q1}
    result.caseSensitiveElement := ParseBoolean(obj.complex('http://hl7.org/fhir/CodeSystem.caseSensitive'));{q1}
    result.valueSetElement := ParseCanonical(obj.complex('http://hl7.org/fhir/CodeSystem.valueSet'));{q1}
    result.hierarchyMeaningElement := ParseEnum(obj.complex('http://hl7.org/fhir/CodeSystem.hierarchyMeaning'), CODES_TFhirCodesystemHierarchyMeaningEnum, SYSTEMS_TFhirCodesystemHierarchyMeaningEnum);
    result.compositionalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/CodeSystem.compositional'));{q1}
    result.versionNeededElement := ParseBoolean(obj.complex('http://hl7.org/fhir/CodeSystem.versionNeeded'));{q1}
    result.contentElement := ParseEnum(obj.complex('http://hl7.org/fhir/CodeSystem.content'), CODES_TFhirCodesystemContentModeEnum, SYSTEMS_TFhirCodesystemContentModeEnum);
    result.supplementsElement := ParseCanonical(obj.complex('http://hl7.org/fhir/CodeSystem.supplements'));{q1}
    result.countElement := ParseUnsignedInt(obj.complex('http://hl7.org/fhir/CodeSystem.count'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/CodeSystem.filter') do
      result.filterList.Add(parseCodeSystemFilter(item));
    for item in obj.complexes('http://hl7.org/fhir/CodeSystem.property') do
      result.property_List.Add(parseCodeSystemProperty(item));
    for item in obj.complexes('http://hl7.org/fhir/CodeSystem.concept') do
      result.conceptList.Add(parseCodeSystemConcept(item));
end;

procedure TFHIRTurtleComposer.ComposeCodeSystem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCodeSystem; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CodeSystem'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUri(this, 'CodeSystem', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'CodeSystem', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(this, 'CodeSystem', 'version', elem.versionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(this, 'CodeSystem', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeString(this, 'CodeSystem', 'title', elem.titleElement, false, -1);{x.2ea}
  ComposeEnum(this, 'CodeSystem', 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(this, 'CodeSystem', 'experimental', elem.experimentalElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(this, 'CodeSystem', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(this, 'CodeSystem', 'publisher', elem.publisherElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(this, 'CodeSystem', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdown(this, 'CodeSystem', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(this, 'CodeSystem', 'useContext', elem.useContextList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'CodeSystem', 'jurisdiction', elem.jurisdictionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdown(this, 'CodeSystem', 'purpose', elem.purposeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdown(this, 'CodeSystem', 'copyright', elem.copyrightElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('caseSensitive') then
    ComposeBoolean(this, 'CodeSystem', 'caseSensitive', elem.caseSensitiveElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('valueSet') then
    ComposeCanonical(this, 'CodeSystem', 'valueSet', elem.valueSetElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('hierarchyMeaning') then
    ComposeEnum(this, 'CodeSystem', 'hierarchyMeaning', elem.HierarchyMeaningElement, CODES_TFhirCodesystemHierarchyMeaningEnum, SYSTEMS_TFhirCodesystemHierarchyMeaningEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('compositional') then
    ComposeBoolean(this, 'CodeSystem', 'compositional', elem.compositionalElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('versionNeeded') then
    ComposeBoolean(this, 'CodeSystem', 'versionNeeded', elem.versionNeededElement, false, -1);{x.2ea}
  ComposeEnum(this, 'CodeSystem', 'content', elem.ContentElement, CODES_TFhirCodesystemContentModeEnum, SYSTEMS_TFhirCodesystemContentModeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('supplements') then
    ComposeCanonical(this, 'CodeSystem', 'supplements', elem.supplementsElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('count') then
    ComposeUnsignedInt(this, 'CodeSystem', 'count', elem.countElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('filter') then
    for i := 0 to elem.filterList.Count - 1 do
      ComposeCodeSystemFilter(this, 'CodeSystem', 'filter', elem.filterList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('property_') then
    for i := 0 to elem.property_List.Count - 1 do
      ComposeCodeSystemProperty(this, 'CodeSystem', 'property', elem.property_List[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('concept') then
    for i := 0 to elem.conceptList.Count - 1 do
      ComposeCodeSystemConcept(this, 'CodeSystem', 'concept', elem.conceptList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_CODESYSTEM}
{$IFDEF FHIR_COMMUNICATION}
function TFHIRTurtleParser.ParseCommunicationPayload(obj : TTurtleComplex) : TFhirCommunicationPayload;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCommunicationPayload.create;
  try
    ParseCommunicationPayloadProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCommunicationPayloadProperties(obj : TTurtleComplex; result : TFhirCommunicationPayload);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    if obj.has('http://hl7.org/fhir/Communication.payload.contentAttachment', item) then
      result.content := parseAttachment(item);
    if obj.has('http://hl7.org/fhir/Communication.payload.contentReference', item) {a3} then
      result.content := ParseReference(item);
    if obj.has('http://hl7.org/fhir/Communication.payload.contentString', item) then
      result.content := parseString(item);
end;

procedure TFHIRTurtleComposer.ComposeCommunicationPayload(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCommunicationPayload; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CommunicationPayload'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (elem.content is TFhirAttachment) {6} then
    ComposeAttachment(this, 'Communication.payload', 'contentAttachment', TFhirAttachment(elem.content), false, -1){x.d9}
  else if (elem.content is TFhirReference) {2} then
    ComposeReference(this, 'Communication.payload', 'contentReference', TFhirReference(elem.content), false,-1){x.d8}
  else if (elem.content is TFhirString) {6} then
    ComposeString(this, 'Communication.payload', 'contentString', TFhirString(elem.content), false, -1);{x.d9}
end;

function TFHIRTurtleParser.ParseCommunication(obj : TTurtleComplex) : TFhirCommunication;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCommunication.create;
  try
    ParseCommunicationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCommunicationProperties(obj : TTurtleComplex; result : TFhirCommunication);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Communication.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/Communication.instantiatesCanonical') do
      result.instantiatesCanonicalList.Add(parseCanonical(item));
    for item in obj.complexes('http://hl7.org/fhir/Communication.instantiatesUri') do
      result.instantiatesUriList.Add(parseUri(item));
    for item in obj.complexes('http://hl7.org/fhir/Communication.basedOn') do
      result.basedOnList.Add(parseReference{TFhirReference}(item));
    for item in obj.complexes('http://hl7.org/fhir/Communication.partOf') do
      result.partOfList.Add(parseReference{TFhirReference}(item));
    for item in obj.complexes('http://hl7.org/fhir/Communication.inResponseTo') do
      result.inResponseToList.Add(parseReference{TFhirCommunication}(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Communication.status'), CODES_TFhirEventStatusEnum, SYSTEMS_TFhirEventStatusEnum);
    result.statusReason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Communication.statusReason'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Communication.category') do
      result.categoryList.Add(parseCodeableConcept(item));
    result.priorityElement := ParseEnum(obj.complex('http://hl7.org/fhir/Communication.priority'), CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum);
    for item in obj.complexes('http://hl7.org/fhir/Communication.medium') do
      result.mediumList.Add(parseCodeableConcept(item));
    result.subject := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/Communication.subject'));{q3b}
    result.topic := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Communication.topic'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Communication.about') do
      result.aboutList.Add(parseReference{TFhirReference}(item));
    result.encounter := ParseReference{TFhirEncounter}(obj.complex('http://hl7.org/fhir/Communication.encounter'));{q3b}
    result.sentElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Communication.sent'));{q1}
    result.receivedElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Communication.received'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Communication.recipient') do
      result.recipientList.Add(parseReference{TFhirDevice}(item));
    result.sender := ParseReference{TFhirDevice}(obj.complex('http://hl7.org/fhir/Communication.sender'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Communication.reasonCode') do
      result.reasonCodeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Communication.reasonReference') do
      result.reasonReferenceList.Add(parseReference{TFhirCondition}(item));
    for item in obj.complexes('http://hl7.org/fhir/Communication.payload') do
      result.payloadList.Add(parseCommunicationPayload(item));
    for item in obj.complexes('http://hl7.org/fhir/Communication.note') do
      result.noteList.Add(parseAnnotation(item));
end;

procedure TFHIRTurtleComposer.ComposeCommunication(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCommunication; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Communication'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Communication', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('instantiatesCanonical') then
    for i := 0 to elem.instantiatesCanonicalList.Count - 1 do
      ComposeCanonical(this, 'Communication', 'instantiatesCanonical', elem.instantiatesCanonicalList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('instantiatesUri') then
    for i := 0 to elem.instantiatesUriList.Count - 1 do
      ComposeUri(this, 'Communication', 'instantiatesUri', elem.instantiatesUriList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('basedOn') then
    for i := 0 to elem.basedOnList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'Communication', 'basedOn', elem.basedOnList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('partOf') then
    for i := 0 to elem.partOfList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'Communication', 'partOf', elem.partOfList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('inResponseTo') then
    for i := 0 to elem.inResponseToList.Count - 1 do
      ComposeReference{TFhirCommunication}(this, 'Communication', 'inResponseTo', elem.inResponseToList[i], false, i);{x.d3}
  ComposeEnum(this, 'Communication', 'status', elem.StatusElement, CODES_TFhirEventStatusEnum, SYSTEMS_TFhirEventStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('statusReason') then
    ComposeCodeableConcept(this, 'Communication', 'statusReason', elem.statusReasonElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('category') then
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(this, 'Communication', 'category', elem.categoryList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('priority') then
    ComposeEnum(this, 'Communication', 'priority', elem.PriorityElement, CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('medium') then
    for i := 0 to elem.mediumList.Count - 1 do
      ComposeCodeableConcept(this, 'Communication', 'medium', elem.mediumList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{TFhirPatient}(this, 'Communication', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('topic') then
    ComposeCodeableConcept(this, 'Communication', 'topic', elem.topicElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('about') then
    for i := 0 to elem.aboutList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'Communication', 'about', elem.aboutList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(this, 'Communication', 'encounter', elem.encounterElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('sent') then
    ComposeDateTime(this, 'Communication', 'sent', elem.sentElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('received') then
    ComposeDateTime(this, 'Communication', 'received', elem.receivedElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('recipient') then
    for i := 0 to elem.recipientList.Count - 1 do
      ComposeReference{TFhirDevice}(this, 'Communication', 'recipient', elem.recipientList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('sender') then
    ComposeReference{TFhirDevice}(this, 'Communication', 'sender', elem.senderElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonCode') then
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'Communication', 'reasonCode', elem.reasonCodeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonReference') then
    for i := 0 to elem.reasonReferenceList.Count - 1 do
      ComposeReference{TFhirCondition}(this, 'Communication', 'reasonReference', elem.reasonReferenceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('payload') then
    for i := 0 to elem.payloadList.Count - 1 do
      ComposeCommunicationPayload(this, 'Communication', 'payload', elem.payloadList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'Communication', 'note', elem.noteList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_COMMUNICATION}
{$IFDEF FHIR_COMMUNICATIONREQUEST}
function TFHIRTurtleParser.ParseCommunicationRequestPayload(obj : TTurtleComplex) : TFhirCommunicationRequestPayload;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCommunicationRequestPayload.create;
  try
    ParseCommunicationRequestPayloadProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCommunicationRequestPayloadProperties(obj : TTurtleComplex; result : TFhirCommunicationRequestPayload);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    if obj.has('http://hl7.org/fhir/CommunicationRequest.payload.contentAttachment', item) then
      result.content := parseAttachment(item);
    if obj.has('http://hl7.org/fhir/CommunicationRequest.payload.contentReference', item) {a3} then
      result.content := ParseReference(item);
    if obj.has('http://hl7.org/fhir/CommunicationRequest.payload.contentString', item) then
      result.content := parseString(item);
end;

procedure TFHIRTurtleComposer.ComposeCommunicationRequestPayload(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCommunicationRequestPayload; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CommunicationRequestPayload'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (elem.content is TFhirAttachment) {6} then
    ComposeAttachment(this, 'CommunicationRequest.payload', 'contentAttachment', TFhirAttachment(elem.content), false, -1){x.d9}
  else if (elem.content is TFhirReference) {2} then
    ComposeReference(this, 'CommunicationRequest.payload', 'contentReference', TFhirReference(elem.content), false,-1){x.d8}
  else if (elem.content is TFhirString) {6} then
    ComposeString(this, 'CommunicationRequest.payload', 'contentString', TFhirString(elem.content), false, -1);{x.d9}
end;

function TFHIRTurtleParser.ParseCommunicationRequest(obj : TTurtleComplex) : TFhirCommunicationRequest;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCommunicationRequest.create;
  try
    ParseCommunicationRequestProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCommunicationRequestProperties(obj : TTurtleComplex; result : TFhirCommunicationRequest);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/CommunicationRequest.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/CommunicationRequest.basedOn') do
      result.basedOnList.Add(parseReference{TFhirReference}(item));
    for item in obj.complexes('http://hl7.org/fhir/CommunicationRequest.replaces') do
      result.replacesList.Add(parseReference{TFhirCommunicationRequest}(item));
    result.groupIdentifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/CommunicationRequest.groupIdentifier'));{q3b}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/CommunicationRequest.status'), CODES_TFhirRequestStatusEnum, SYSTEMS_TFhirRequestStatusEnum);
    result.statusReason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/CommunicationRequest.statusReason'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/CommunicationRequest.category') do
      result.categoryList.Add(parseCodeableConcept(item));
    result.priorityElement := ParseEnum(obj.complex('http://hl7.org/fhir/CommunicationRequest.priority'), CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum);
    result.doNotPerformElement := ParseBoolean(obj.complex('http://hl7.org/fhir/CommunicationRequest.doNotPerform'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/CommunicationRequest.medium') do
      result.mediumList.Add(parseCodeableConcept(item));
    result.subject := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/CommunicationRequest.subject'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/CommunicationRequest.about') do
      result.aboutList.Add(parseReference{TFhirReference}(item));
    result.encounter := ParseReference{TFhirEncounter}(obj.complex('http://hl7.org/fhir/CommunicationRequest.encounter'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/CommunicationRequest.payload') do
      result.payloadList.Add(parseCommunicationRequestPayload(item));
    if obj.has('http://hl7.org/fhir/CommunicationRequest.occurrencePeriod', item) then
      result.occurrence := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/CommunicationRequest.occurrenceDateTime', item) then
      result.occurrence := parseDateTime(item);
    result.authoredOnElement := ParseDateTime(obj.complex('http://hl7.org/fhir/CommunicationRequest.authoredOn'));{q1}
    result.requester := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/CommunicationRequest.requester'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/CommunicationRequest.recipient') do
      result.recipientList.Add(parseReference{TFhirDevice}(item));
    result.sender := ParseReference{TFhirDevice}(obj.complex('http://hl7.org/fhir/CommunicationRequest.sender'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/CommunicationRequest.reasonCode') do
      result.reasonCodeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/CommunicationRequest.reasonReference') do
      result.reasonReferenceList.Add(parseReference{TFhirCondition}(item));
    for item in obj.complexes('http://hl7.org/fhir/CommunicationRequest.note') do
      result.noteList.Add(parseAnnotation(item));
end;

procedure TFHIRTurtleComposer.ComposeCommunicationRequest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCommunicationRequest; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CommunicationRequest'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'CommunicationRequest', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('basedOn') then
    for i := 0 to elem.basedOnList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'CommunicationRequest', 'basedOn', elem.basedOnList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('replaces') then
    for i := 0 to elem.replacesList.Count - 1 do
      ComposeReference{TFhirCommunicationRequest}(this, 'CommunicationRequest', 'replaces', elem.replacesList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('groupIdentifier') then
    ComposeIdentifier(this, 'CommunicationRequest', 'groupIdentifier', elem.groupIdentifierElement, false, -1);{x.2f}
  ComposeEnum(this, 'CommunicationRequest', 'status', elem.StatusElement, CODES_TFhirRequestStatusEnum, SYSTEMS_TFhirRequestStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('statusReason') then
    ComposeCodeableConcept(this, 'CommunicationRequest', 'statusReason', elem.statusReasonElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('category') then
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(this, 'CommunicationRequest', 'category', elem.categoryList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('priority') then
    ComposeEnum(this, 'CommunicationRequest', 'priority', elem.PriorityElement, CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('doNotPerform') then
    ComposeBoolean(this, 'CommunicationRequest', 'doNotPerform', elem.doNotPerformElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('medium') then
    for i := 0 to elem.mediumList.Count - 1 do
      ComposeCodeableConcept(this, 'CommunicationRequest', 'medium', elem.mediumList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('subject') then
    ComposeReference{TFhirPatient}(this, 'CommunicationRequest', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('about') then
    for i := 0 to elem.aboutList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'CommunicationRequest', 'about', elem.aboutList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(this, 'CommunicationRequest', 'encounter', elem.encounterElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('payload') then
    for i := 0 to elem.payloadList.Count - 1 do
      ComposeCommunicationRequestPayload(this, 'CommunicationRequest', 'payload', elem.payloadList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirPeriod) {6} then
    ComposePeriod(this, 'CommunicationRequest', 'occurrencePeriod', TFhirPeriod(elem.occurrence), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirDateTime) {6} then
    ComposeDateTime(this, 'CommunicationRequest', 'occurrenceDateTime', TFhirDateTime(elem.occurrence), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('authoredOn') then
    ComposeDateTime(this, 'CommunicationRequest', 'authoredOn', elem.authoredOnElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requester') then
    ComposeReference{TFhirPractitioner}(this, 'CommunicationRequest', 'requester', elem.requesterElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('recipient') then
    for i := 0 to elem.recipientList.Count - 1 do
      ComposeReference{TFhirDevice}(this, 'CommunicationRequest', 'recipient', elem.recipientList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('sender') then
    ComposeReference{TFhirDevice}(this, 'CommunicationRequest', 'sender', elem.senderElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonCode') then
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'CommunicationRequest', 'reasonCode', elem.reasonCodeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonReference') then
    for i := 0 to elem.reasonReferenceList.Count - 1 do
      ComposeReference{TFhirCondition}(this, 'CommunicationRequest', 'reasonReference', elem.reasonReferenceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'CommunicationRequest', 'note', elem.noteList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_COMMUNICATIONREQUEST}
{$IFDEF FHIR_COMPARTMENTDEFINITION}
function TFHIRTurtleParser.ParseCompartmentDefinitionResource(obj : TTurtleComplex) : TFhirCompartmentDefinitionResource;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCompartmentDefinitionResource.create;
  try
    ParseCompartmentDefinitionResourceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCompartmentDefinitionResourceProperties(obj : TTurtleComplex; result : TFhirCompartmentDefinitionResource);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.codeElement := ParseEnum(obj.complex('http://hl7.org/fhir/CompartmentDefinition.resource.code'), CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum);
    for item in obj.complexes('http://hl7.org/fhir/CompartmentDefinition.resource.param') do
      result.paramList.Add(parseString(item));
    result.documentationElement := ParseString(obj.complex('http://hl7.org/fhir/CompartmentDefinition.resource.documentation'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeCompartmentDefinitionResource(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCompartmentDefinitionResource; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CompartmentDefinitionResource'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'CompartmentDefinition.resource', 'code', elem.CodeElement, CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.paramList.Count - 1 do
      ComposeString(this, 'CompartmentDefinition.resource', 'param', elem.paramList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'CompartmentDefinition.resource', 'documentation', elem.documentationElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseCompartmentDefinition(obj : TTurtleComplex) : TFhirCompartmentDefinition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCompartmentDefinition.create;
  try
    ParseCompartmentDefinitionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCompartmentDefinitionProperties(obj : TTurtleComplex; result : TFhirCompartmentDefinition);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/CompartmentDefinition.url'));{q1}
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/CompartmentDefinition.version'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/CompartmentDefinition.name'));{q1}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/CompartmentDefinition.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    result.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/CompartmentDefinition.experimental'));{q1}
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/CompartmentDefinition.date'));{q1}
    result.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/CompartmentDefinition.publisher'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/CompartmentDefinition.contact') do
      result.contactList.Add(parseContactDetail(item));
    result.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/CompartmentDefinition.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/CompartmentDefinition.useContext') do
      result.useContextList.Add(parseUsageContext(item));
    result.purposeElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/CompartmentDefinition.purpose'));{q1}
    result.codeElement := ParseEnum(obj.complex('http://hl7.org/fhir/CompartmentDefinition.code'), CODES_TFhirCompartmentTypeEnum, SYSTEMS_TFhirCompartmentTypeEnum);
    result.searchElement := ParseBoolean(obj.complex('http://hl7.org/fhir/CompartmentDefinition.search'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/CompartmentDefinition.resource') do
      result.resourceList.Add(parseCompartmentDefinitionResource(item));
end;

procedure TFHIRTurtleComposer.ComposeCompartmentDefinition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCompartmentDefinition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CompartmentDefinition'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  ComposeUri(this, 'CompartmentDefinition', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(this, 'CompartmentDefinition', 'version', elem.versionElement, false, -1);{x.2ea}
  ComposeString(this, 'CompartmentDefinition', 'name', elem.nameElement, false, -1);{x.2ea}
  ComposeEnum(this, 'CompartmentDefinition', 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(this, 'CompartmentDefinition', 'experimental', elem.experimentalElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(this, 'CompartmentDefinition', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(this, 'CompartmentDefinition', 'publisher', elem.publisherElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(this, 'CompartmentDefinition', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdown(this, 'CompartmentDefinition', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(this, 'CompartmentDefinition', 'useContext', elem.useContextList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdown(this, 'CompartmentDefinition', 'purpose', elem.purposeElement, false, -1);{x.2ea}
  ComposeEnum(this, 'CompartmentDefinition', 'code', elem.CodeElement, CODES_TFhirCompartmentTypeEnum, SYSTEMS_TFhirCompartmentTypeEnum, false, -1);{x.d4}
  ComposeBoolean(this, 'CompartmentDefinition', 'search', elem.searchElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('resource') then
    for i := 0 to elem.resourceList.Count - 1 do
      ComposeCompartmentDefinitionResource(this, 'CompartmentDefinition', 'resource', elem.resourceList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_COMPARTMENTDEFINITION}
{$IFDEF FHIR_COMPOSITION}
function TFHIRTurtleParser.ParseCompositionAttester(obj : TTurtleComplex) : TFhirCompositionAttester;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCompositionAttester.create;
  try
    ParseCompositionAttesterProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCompositionAttesterProperties(obj : TTurtleComplex; result : TFhirCompositionAttester);
begin
    ParseBackboneElementProperties(obj, result);
    result.modeElement := ParseEnum(obj.complex('http://hl7.org/fhir/Composition.attester.mode'), CODES_TFhirCompositionAttestationModeEnum, SYSTEMS_TFhirCompositionAttestationModeEnum);
    result.timeElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Composition.attester.time'));{q1}
    result.party := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/Composition.attester.party'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeCompositionAttester(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCompositionAttester; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CompositionAttester'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'Composition.attester', 'mode', elem.ModeElement, CODES_TFhirCompositionAttestationModeEnum, SYSTEMS_TFhirCompositionAttestationModeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'Composition.attester', 'time', elem.timeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirPatient}(this, 'Composition.attester', 'party', elem.partyElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseCompositionRelatesTo(obj : TTurtleComplex) : TFhirCompositionRelatesTo;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCompositionRelatesTo.create;
  try
    ParseCompositionRelatesToProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCompositionRelatesToProperties(obj : TTurtleComplex; result : TFhirCompositionRelatesTo);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.codeElement := ParseEnum(obj.complex('http://hl7.org/fhir/Composition.relatesTo.code'), CODES_TFhirDocumentRelationshipTypeEnum, SYSTEMS_TFhirDocumentRelationshipTypeEnum);
    if obj.has('http://hl7.org/fhir/Composition.relatesTo.targetIdentifier', item) then
      result.target := parseIdentifier(item);
    if obj.has('http://hl7.org/fhir/Composition.relatesTo.targetReference', item) {a3} then
      result.target := ParseReference(item);
end;

procedure TFHIRTurtleComposer.ComposeCompositionRelatesTo(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCompositionRelatesTo; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CompositionRelatesTo'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'Composition.relatesTo', 'code', elem.CodeElement, CODES_TFhirDocumentRelationshipTypeEnum, SYSTEMS_TFhirDocumentRelationshipTypeEnum, false, -1);{x.d4}
  if (elem.target is TFhirIdentifier) {6} then
    ComposeIdentifier(this, 'Composition.relatesTo', 'targetIdentifier', TFhirIdentifier(elem.target), false, -1){x.d9}
  else if (elem.target is TFhirReference) {2} then
    ComposeReference(this, 'Composition.relatesTo', 'targetReference', TFhirReference(elem.target), false,-1);{x.d8}
end;

function TFHIRTurtleParser.ParseCompositionEvent(obj : TTurtleComplex) : TFhirCompositionEvent;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCompositionEvent.create;
  try
    ParseCompositionEventProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCompositionEventProperties(obj : TTurtleComplex; result : TFhirCompositionEvent);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Composition.event.code') do
      result.codeList.Add(parseCodeableConcept(item));
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Composition.event.period'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Composition.event.detail') do
      result.detailList.Add(parseReference{TFhirReference}(item));
end;

procedure TFHIRTurtleComposer.ComposeCompositionEvent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCompositionEvent; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CompositionEvent'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.codeList.Count - 1 do
      ComposeCodeableConcept(this, 'Composition.event', 'code', elem.codeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'Composition.event', 'period', elem.periodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.detailList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'Composition.event', 'detail', elem.detailList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseCompositionSection(obj : TTurtleComplex) : TFhirCompositionSection;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCompositionSection.create;
  try
    ParseCompositionSectionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCompositionSectionProperties(obj : TTurtleComplex; result : TFhirCompositionSection);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.titleElement := ParseString(obj.complex('http://hl7.org/fhir/Composition.section.title'));{q1}
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Composition.section.code'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Composition.section.author') do
      result.authorList.Add(parseReference{TFhirPractitioner}(item));
    result.focus := ParseReference{TFhirReference}(obj.complex('http://hl7.org/fhir/Composition.section.focus'));{q3b}
    result.text := ParseNarrative(obj.complex('http://hl7.org/fhir/Composition.section.text'));{q3b}
    result.modeElement := ParseEnum(obj.complex('http://hl7.org/fhir/Composition.section.mode'), CODES_TFhirListModeEnum, SYSTEMS_TFhirListModeEnum);
    result.orderedBy := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Composition.section.orderedBy'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Composition.section.entry') do
      result.entryList.Add(parseReference{TFhirReference}(item));
    result.emptyReason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Composition.section.emptyReason'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Composition.section.section') do
      result.sectionList.Add(parseCompositionSection(item));
end;

procedure TFHIRTurtleComposer.ComposeCompositionSection(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCompositionSection; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CompositionSection'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Composition.section', 'title', elem.titleElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Composition.section', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.authorList.Count - 1 do
      ComposeReference{TFhirPractitioner}(this, 'Composition.section', 'author', elem.authorList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirReference}(this, 'Composition.section', 'focus', elem.focusElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeNarrative(this, 'Composition.section', 'text', elem.textElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'Composition.section', 'mode', elem.ModeElement, CODES_TFhirListModeEnum, SYSTEMS_TFhirListModeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Composition.section', 'orderedBy', elem.orderedByElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.entryList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'Composition.section', 'entry', elem.entryList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Composition.section', 'emptyReason', elem.emptyReasonElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.sectionList.Count - 1 do
      ComposeCompositionSection(this, 'Composition.section', 'section', elem.sectionList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseComposition(obj : TTurtleComplex) : TFhirComposition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirComposition.create;
  try
    ParseCompositionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCompositionProperties(obj : TTurtleComplex; result : TFhirComposition);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/Composition.identifier'));{q3b}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Composition.status'), CODES_TFhirCompositionStatusEnum, SYSTEMS_TFhirCompositionStatusEnum);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Composition.type'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Composition.category') do
      result.categoryList.Add(parseCodeableConcept(item));
    result.subject := ParseReference{TFhirReference}(obj.complex('http://hl7.org/fhir/Composition.subject'));{q3b}
    result.encounter := ParseReference{TFhirEncounter}(obj.complex('http://hl7.org/fhir/Composition.encounter'));{q3b}
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Composition.date'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Composition.author') do
      result.authorList.Add(parseReference{TFhirPractitioner}(item));
    result.titleElement := ParseString(obj.complex('http://hl7.org/fhir/Composition.title'));{q1}
    result.confidentialityElement := ParseEnum(obj.complex('http://hl7.org/fhir/Composition.confidentiality'), CODES_TFhirV3ConfidentialityClassificationEnum, SYSTEMS_TFhirV3ConfidentialityClassificationEnum);
    for item in obj.complexes('http://hl7.org/fhir/Composition.attester') do
      result.attesterList.Add(parseCompositionAttester(item));
    result.custodian := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/Composition.custodian'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Composition.relatesTo') do
      result.relatesToList.Add(parseCompositionRelatesTo(item));
    for item in obj.complexes('http://hl7.org/fhir/Composition.event') do
      result.eventList.Add(parseCompositionEvent(item));
    for item in obj.complexes('http://hl7.org/fhir/Composition.section') do
      result.sectionList.Add(parseCompositionSection(item));
end;

procedure TFHIRTurtleComposer.ComposeComposition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirComposition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Composition'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(this, 'Composition', 'identifier', elem.identifierElement, false, -1);{x.2f}
  ComposeEnum(this, 'Composition', 'status', elem.StatusElement, CODES_TFhirCompositionStatusEnum, SYSTEMS_TFhirCompositionStatusEnum, false, -1);{x.d4}
  ComposeCodeableConcept(this, 'Composition', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(this, 'Composition', 'category', elem.categoryList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{TFhirReference}(this, 'Composition', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(this, 'Composition', 'encounter', elem.encounterElement, false, -1);{x.2f}
  ComposeDateTime(this, 'Composition', 'date', elem.dateElement, false, -1);{x.2ea}
  for i := 0 to elem.authorList.Count - 1 do
      ComposeReference{TFhirPractitioner}(this, 'Composition', 'author', elem.authorList[i], false, i);{x.d3}
  ComposeString(this, 'Composition', 'title', elem.titleElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('confidentiality') then
    ComposeEnum(this, 'Composition', 'confidentiality', elem.ConfidentialityElement, CODES_TFhirV3ConfidentialityClassificationEnum, SYSTEMS_TFhirV3ConfidentialityClassificationEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('attester') then
    for i := 0 to elem.attesterList.Count - 1 do
      ComposeCompositionAttester(this, 'Composition', 'attester', elem.attesterList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('custodian') then
    ComposeReference{TFhirOrganization}(this, 'Composition', 'custodian', elem.custodianElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('relatesTo') then
    for i := 0 to elem.relatesToList.Count - 1 do
      ComposeCompositionRelatesTo(this, 'Composition', 'relatesTo', elem.relatesToList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('event') then
    for i := 0 to elem.eventList.Count - 1 do
      ComposeCompositionEvent(this, 'Composition', 'event', elem.eventList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('section') then
    for i := 0 to elem.sectionList.Count - 1 do
      ComposeCompositionSection(this, 'Composition', 'section', elem.sectionList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_COMPOSITION}
{$IFDEF FHIR_CONCEPTMAP}
function TFHIRTurtleParser.ParseConceptMapGroup(obj : TTurtleComplex) : TFhirConceptMapGroup;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirConceptMapGroup.create;
  try
    ParseConceptMapGroupProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConceptMapGroupProperties(obj : TTurtleComplex; result : TFhirConceptMapGroup);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.sourceElement := ParseUri(obj.complex('http://hl7.org/fhir/ConceptMap.group.source'));{q1}
    result.sourceVersionElement := ParseString(obj.complex('http://hl7.org/fhir/ConceptMap.group.sourceVersion'));{q1}
    result.targetElement := ParseUri(obj.complex('http://hl7.org/fhir/ConceptMap.group.target'));{q1}
    result.targetVersionElement := ParseString(obj.complex('http://hl7.org/fhir/ConceptMap.group.targetVersion'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ConceptMap.group.element') do
      result.elementList.Add(parseConceptMapGroupElement(item));
    result.unmapped := ParseConceptMapGroupUnmapped(obj.complex('http://hl7.org/fhir/ConceptMap.group.unmapped'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeConceptMapGroup(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConceptMapGroup; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ConceptMapGroup'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'ConceptMap.group', 'source', elem.sourceElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ConceptMap.group', 'sourceVersion', elem.sourceVersionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'ConceptMap.group', 'target', elem.targetElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ConceptMap.group', 'targetVersion', elem.targetVersionElement, false, -1);{x.2ea}
  for i := 0 to elem.elementList.Count - 1 do
      ComposeConceptMapGroupElement(this, 'ConceptMap.group', 'element', elem.elementList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeConceptMapGroupUnmapped(this, 'ConceptMap.group', 'unmapped', elem.unmappedElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseConceptMapGroupElement(obj : TTurtleComplex) : TFhirConceptMapGroupElement;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirConceptMapGroupElement.create;
  try
    ParseConceptMapGroupElementProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConceptMapGroupElementProperties(obj : TTurtleComplex; result : TFhirConceptMapGroupElement);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.codeElement := ParseCode(obj.complex('http://hl7.org/fhir/ConceptMap.group.element.code'));{q1}
    result.displayElement := ParseString(obj.complex('http://hl7.org/fhir/ConceptMap.group.element.display'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ConceptMap.group.element.target') do
      result.targetList.Add(parseConceptMapGroupElementTarget(item));
end;

procedure TFHIRTurtleComposer.ComposeConceptMapGroupElement(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConceptMapGroupElement; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ConceptMapGroupElement'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(this, 'ConceptMap.group.element', 'code', elem.codeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ConceptMap.group.element', 'display', elem.displayElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.targetList.Count - 1 do
      ComposeConceptMapGroupElementTarget(this, 'ConceptMap.group.element', 'target', elem.targetList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseConceptMapGroupElementTarget(obj : TTurtleComplex) : TFhirConceptMapGroupElementTarget;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirConceptMapGroupElementTarget.create;
  try
    ParseConceptMapGroupElementTargetProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConceptMapGroupElementTargetProperties(obj : TTurtleComplex; result : TFhirConceptMapGroupElementTarget);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.codeElement := ParseCode(obj.complex('http://hl7.org/fhir/ConceptMap.group.element.target.code'));{q1}
    result.displayElement := ParseString(obj.complex('http://hl7.org/fhir/ConceptMap.group.element.target.display'));{q1}
    result.equivalenceElement := ParseEnum(obj.complex('http://hl7.org/fhir/ConceptMap.group.element.target.equivalence'), CODES_TFhirConceptMapEquivalenceEnum, SYSTEMS_TFhirConceptMapEquivalenceEnum);
    result.commentElement := ParseString(obj.complex('http://hl7.org/fhir/ConceptMap.group.element.target.comment'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ConceptMap.group.element.target.dependsOn') do
      result.dependsOnList.Add(parseConceptMapGroupElementTargetDependsOn(item));
    for item in obj.complexes('http://hl7.org/fhir/ConceptMap.group.element.target.product') do
      result.productList.Add(parseConceptMapGroupElementTargetDependsOn(item));
end;

procedure TFHIRTurtleComposer.ComposeConceptMapGroupElementTarget(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConceptMapGroupElementTarget; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ConceptMapGroupElementTarget'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(this, 'ConceptMap.group.element.target', 'code', elem.codeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ConceptMap.group.element.target', 'display', elem.displayElement, false, -1);{x.2ea}
  ComposeEnum(this, 'ConceptMap.group.element.target', 'equivalence', elem.EquivalenceElement, CODES_TFhirConceptMapEquivalenceEnum, SYSTEMS_TFhirConceptMapEquivalenceEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ConceptMap.group.element.target', 'comment', elem.commentElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.dependsOnList.Count - 1 do
      ComposeConceptMapGroupElementTargetDependsOn(this, 'ConceptMap.group.element.target', 'dependsOn', elem.dependsOnList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.productList.Count - 1 do
      ComposeConceptMapGroupElementTargetDependsOn(this, 'ConceptMap.group.element.target', 'product', elem.productList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseConceptMapGroupElementTargetDependsOn(obj : TTurtleComplex) : TFhirConceptMapGroupElementTargetDependsOn;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirConceptMapGroupElementTargetDependsOn.create;
  try
    ParseConceptMapGroupElementTargetDependsOnProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConceptMapGroupElementTargetDependsOnProperties(obj : TTurtleComplex; result : TFhirConceptMapGroupElementTargetDependsOn);
begin
    ParseBackboneElementProperties(obj, result);
    result.property_Element := ParseUri(obj.complex('http://hl7.org/fhir/ConceptMap.group.element.target.dependsOn.property'));{q1}
    result.systemElement := ParseCanonical(obj.complex('http://hl7.org/fhir/ConceptMap.group.element.target.dependsOn.system'));{q1}
    result.valueElement := ParseString(obj.complex('http://hl7.org/fhir/ConceptMap.group.element.target.dependsOn.value'));{q1}
    result.displayElement := ParseString(obj.complex('http://hl7.org/fhir/ConceptMap.group.element.target.dependsOn.display'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeConceptMapGroupElementTargetDependsOn(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConceptMapGroupElementTargetDependsOn; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ConceptMapGroupElementTargetDependsOn'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeUri(this, 'ConceptMap.group.element.target.dependsOn', 'property', elem.property_Element, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(this, 'ConceptMap.group.element.target.dependsOn', 'system', elem.systemElement, false, -1);{x.2ea}
  ComposeString(this, 'ConceptMap.group.element.target.dependsOn', 'value', elem.valueElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ConceptMap.group.element.target.dependsOn', 'display', elem.displayElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseConceptMapGroupUnmapped(obj : TTurtleComplex) : TFhirConceptMapGroupUnmapped;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirConceptMapGroupUnmapped.create;
  try
    ParseConceptMapGroupUnmappedProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConceptMapGroupUnmappedProperties(obj : TTurtleComplex; result : TFhirConceptMapGroupUnmapped);
begin
    ParseBackboneElementProperties(obj, result);
    result.modeElement := ParseEnum(obj.complex('http://hl7.org/fhir/ConceptMap.group.unmapped.mode'), CODES_TFhirConceptmapUnmappedModeEnum, SYSTEMS_TFhirConceptmapUnmappedModeEnum);
    result.codeElement := ParseCode(obj.complex('http://hl7.org/fhir/ConceptMap.group.unmapped.code'));{q1}
    result.displayElement := ParseString(obj.complex('http://hl7.org/fhir/ConceptMap.group.unmapped.display'));{q1}
    result.urlElement := ParseCanonical(obj.complex('http://hl7.org/fhir/ConceptMap.group.unmapped.url'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeConceptMapGroupUnmapped(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConceptMapGroupUnmapped; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ConceptMapGroupUnmapped'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'ConceptMap.group.unmapped', 'mode', elem.ModeElement, CODES_TFhirConceptmapUnmappedModeEnum, SYSTEMS_TFhirConceptmapUnmappedModeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(this, 'ConceptMap.group.unmapped', 'code', elem.codeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ConceptMap.group.unmapped', 'display', elem.displayElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(this, 'ConceptMap.group.unmapped', 'url', elem.urlElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseConceptMap(obj : TTurtleComplex) : TFhirConceptMap;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirConceptMap.create;
  try
    ParseConceptMapProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConceptMapProperties(obj : TTurtleComplex; result : TFhirConceptMap);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/ConceptMap.url'));{q1}
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/ConceptMap.identifier'));{q3b}
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/ConceptMap.version'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/ConceptMap.name'));{q1}
    result.titleElement := ParseString(obj.complex('http://hl7.org/fhir/ConceptMap.title'));{q1}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/ConceptMap.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    result.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ConceptMap.experimental'));{q1}
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ConceptMap.date'));{q1}
    result.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/ConceptMap.publisher'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ConceptMap.contact') do
      result.contactList.Add(parseContactDetail(item));
    result.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ConceptMap.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ConceptMap.useContext') do
      result.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/ConceptMap.jurisdiction') do
      result.jurisdictionList.Add(parseCodeableConcept(item));
    result.purposeElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ConceptMap.purpose'));{q1}
    result.copyrightElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ConceptMap.copyright'));{q1}
    if obj.has('http://hl7.org/fhir/ConceptMap.sourceCanonical', item) then
      result.source := parseCanonical(item);
    if obj.has('http://hl7.org/fhir/ConceptMap.sourceUri', item) then
      result.source := parseUri(item);
    if obj.has('http://hl7.org/fhir/ConceptMap.targetCanonical', item) then
      result.target := parseCanonical(item);
    if obj.has('http://hl7.org/fhir/ConceptMap.targetUri', item) then
      result.target := parseUri(item);
    for item in obj.complexes('http://hl7.org/fhir/ConceptMap.group') do
      result.groupList.Add(parseConceptMapGroup(item));
end;

procedure TFHIRTurtleComposer.ComposeConceptMap(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConceptMap; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ConceptMap'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUri(this, 'ConceptMap', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(this, 'ConceptMap', 'identifier', elem.identifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(this, 'ConceptMap', 'version', elem.versionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(this, 'ConceptMap', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeString(this, 'ConceptMap', 'title', elem.titleElement, false, -1);{x.2ea}
  ComposeEnum(this, 'ConceptMap', 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(this, 'ConceptMap', 'experimental', elem.experimentalElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(this, 'ConceptMap', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(this, 'ConceptMap', 'publisher', elem.publisherElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(this, 'ConceptMap', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdown(this, 'ConceptMap', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(this, 'ConceptMap', 'useContext', elem.useContextList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'ConceptMap', 'jurisdiction', elem.jurisdictionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdown(this, 'ConceptMap', 'purpose', elem.purposeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdown(this, 'ConceptMap', 'copyright', elem.copyrightElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.source is TFhirCanonical) {6} then
    ComposeCanonical(this, 'ConceptMap', 'sourceCanonical', TFhirCanonical(elem.source), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.source is TFhirUri) {6} then
    ComposeUri(this, 'ConceptMap', 'sourceUri', TFhirUri(elem.source), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.target is TFhirCanonical) {6} then
    ComposeCanonical(this, 'ConceptMap', 'targetCanonical', TFhirCanonical(elem.target), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.target is TFhirUri) {6} then
    ComposeUri(this, 'ConceptMap', 'targetUri', TFhirUri(elem.target), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) and doCompose('group') then
    for i := 0 to elem.groupList.Count - 1 do
      ComposeConceptMapGroup(this, 'ConceptMap', 'group', elem.groupList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_CONCEPTMAP}
{$IFDEF FHIR_CONDITION}
function TFHIRTurtleParser.ParseConditionStage(obj : TTurtleComplex) : TFhirConditionStage;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirConditionStage.create;
  try
    ParseConditionStageProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConditionStageProperties(obj : TTurtleComplex; result : TFhirConditionStage);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.summary := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Condition.stage.summary'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Condition.stage.assessment') do
      result.assessmentList.Add(parseReference{TFhirClinicalImpression}(item));
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Condition.stage.type'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeConditionStage(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConditionStage; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ConditionStage'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Condition.stage', 'summary', elem.summaryElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.assessmentList.Count - 1 do
      ComposeReference{TFhirClinicalImpression}(this, 'Condition.stage', 'assessment', elem.assessmentList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Condition.stage', 'type', elem.type_Element, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseConditionEvidence(obj : TTurtleComplex) : TFhirConditionEvidence;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirConditionEvidence.create;
  try
    ParseConditionEvidenceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConditionEvidenceProperties(obj : TTurtleComplex; result : TFhirConditionEvidence);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Condition.evidence.code') do
      result.codeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Condition.evidence.detail') do
      result.detailList.Add(parseReference{TFhirReference}(item));
end;

procedure TFHIRTurtleComposer.ComposeConditionEvidence(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConditionEvidence; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ConditionEvidence'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.codeList.Count - 1 do
      ComposeCodeableConcept(this, 'Condition.evidence', 'code', elem.codeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.detailList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'Condition.evidence', 'detail', elem.detailList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseCondition(obj : TTurtleComplex) : TFhirCondition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCondition.create;
  try
    ParseConditionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConditionProperties(obj : TTurtleComplex; result : TFhirCondition);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Condition.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.clinicalStatus := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Condition.clinicalStatus'));{q3b}
    result.verificationStatus := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Condition.verificationStatus'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Condition.category') do
      result.categoryList.Add(parseCodeableConcept(item));
    result.severity := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Condition.severity'));{q3b}
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Condition.code'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Condition.bodySite') do
      result.bodySiteList.Add(parseCodeableConcept(item));
    result.subject := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/Condition.subject'));{q3b}
    result.encounter := ParseReference{TFhirEncounter}(obj.complex('http://hl7.org/fhir/Condition.encounter'));{q3b}
    if obj.has('http://hl7.org/fhir/Condition.onsetAge', item) then
      result.onset := parseAge(item);
    if obj.has('http://hl7.org/fhir/Condition.onsetPeriod', item) then
      result.onset := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/Condition.onsetRange', item) then
      result.onset := parseRange(item);
    if obj.has('http://hl7.org/fhir/Condition.onsetDateTime', item) then
      result.onset := parseDateTime(item);
    if obj.has('http://hl7.org/fhir/Condition.onsetString', item) then
      result.onset := parseString(item);
    if obj.has('http://hl7.org/fhir/Condition.abatementAge', item) then
      result.abatement := parseAge(item);
    if obj.has('http://hl7.org/fhir/Condition.abatementPeriod', item) then
      result.abatement := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/Condition.abatementRange', item) then
      result.abatement := parseRange(item);
    if obj.has('http://hl7.org/fhir/Condition.abatementDateTime', item) then
      result.abatement := parseDateTime(item);
    if obj.has('http://hl7.org/fhir/Condition.abatementString', item) then
      result.abatement := parseString(item);
    result.recordedDateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Condition.recordedDate'));{q1}
    result.recorder := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/Condition.recorder'));{q3b}
    result.asserter := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/Condition.asserter'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Condition.stage') do
      result.stageList.Add(parseConditionStage(item));
    for item in obj.complexes('http://hl7.org/fhir/Condition.evidence') do
      result.evidenceList.Add(parseConditionEvidence(item));
    for item in obj.complexes('http://hl7.org/fhir/Condition.note') do
      result.noteList.Add(parseAnnotation(item));
end;

procedure TFHIRTurtleComposer.ComposeCondition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCondition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Condition'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Condition', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('clinicalStatus') then
    ComposeCodeableConcept(this, 'Condition', 'clinicalStatus', elem.clinicalStatusElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('verificationStatus') then
    ComposeCodeableConcept(this, 'Condition', 'verificationStatus', elem.verificationStatusElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('category') then
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(this, 'Condition', 'category', elem.categoryList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('severity') then
    ComposeCodeableConcept(this, 'Condition', 'severity', elem.severityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') then
    ComposeCodeableConcept(this, 'Condition', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('bodySite') then
    for i := 0 to elem.bodySiteList.Count - 1 do
      ComposeCodeableConcept(this, 'Condition', 'bodySite', elem.bodySiteList[i], false, i);{x.d3}
  ComposeReference{TFhirPatient}(this, 'Condition', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(this, 'Condition', 'encounter', elem.encounterElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.onset is TFhirAge) {6} then
    ComposeAge(this, 'Condition', 'onsetAge', TFhirAge(elem.onset), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.onset is TFhirPeriod) {6} then
    ComposePeriod(this, 'Condition', 'onsetPeriod', TFhirPeriod(elem.onset), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.onset is TFhirRange) {6} then
    ComposeRange(this, 'Condition', 'onsetRange', TFhirRange(elem.onset), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.onset is TFhirDateTime) {6} then
    ComposeDateTime(this, 'Condition', 'onsetDateTime', TFhirDateTime(elem.onset), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.onset is TFhirString) {6} then
    ComposeString(this, 'Condition', 'onsetString', TFhirString(elem.onset), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) and (elem.abatement is TFhirAge) {6} then
    ComposeAge(this, 'Condition', 'abatementAge', TFhirAge(elem.abatement), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.abatement is TFhirPeriod) {6} then
    ComposePeriod(this, 'Condition', 'abatementPeriod', TFhirPeriod(elem.abatement), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.abatement is TFhirRange) {6} then
    ComposeRange(this, 'Condition', 'abatementRange', TFhirRange(elem.abatement), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.abatement is TFhirDateTime) {6} then
    ComposeDateTime(this, 'Condition', 'abatementDateTime', TFhirDateTime(elem.abatement), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.abatement is TFhirString) {6} then
    ComposeString(this, 'Condition', 'abatementString', TFhirString(elem.abatement), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('recordedDate') then
    ComposeDateTime(this, 'Condition', 'recordedDate', elem.recordedDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('recorder') then
    ComposeReference{TFhirPractitioner}(this, 'Condition', 'recorder', elem.recorderElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('asserter') then
    ComposeReference{TFhirPractitioner}(this, 'Condition', 'asserter', elem.asserterElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('stage') then
    for i := 0 to elem.stageList.Count - 1 do
      ComposeConditionStage(this, 'Condition', 'stage', elem.stageList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('evidence') then
    for i := 0 to elem.evidenceList.Count - 1 do
      ComposeConditionEvidence(this, 'Condition', 'evidence', elem.evidenceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'Condition', 'note', elem.noteList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_CONDITION}
{$IFDEF FHIR_CONSENT}
function TFHIRTurtleParser.ParseConsentPolicy(obj : TTurtleComplex) : TFhirConsentPolicy;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirConsentPolicy.create;
  try
    ParseConsentPolicyProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConsentPolicyProperties(obj : TTurtleComplex; result : TFhirConsentPolicy);
begin
    ParseBackboneElementProperties(obj, result);
    result.authorityElement := ParseUri(obj.complex('http://hl7.org/fhir/Consent.policy.authority'));{q1}
    result.uriElement := ParseUri(obj.complex('http://hl7.org/fhir/Consent.policy.uri'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeConsentPolicy(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConsentPolicy; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ConsentPolicy'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'Consent.policy', 'authority', elem.authorityElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'Consent.policy', 'uri', elem.uriElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseConsentVerification(obj : TTurtleComplex) : TFhirConsentVerification;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirConsentVerification.create;
  try
    ParseConsentVerificationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConsentVerificationProperties(obj : TTurtleComplex; result : TFhirConsentVerification);
begin
    ParseBackboneElementProperties(obj, result);
    result.verifiedElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Consent.verification.verified'));{q1}
    result.verifiedWith := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/Consent.verification.verifiedWith'));{q3b}
    result.verificationDateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Consent.verification.verificationDate'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeConsentVerification(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConsentVerification; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ConsentVerification'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeBoolean(this, 'Consent.verification', 'verified', elem.verifiedElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirPatient}(this, 'Consent.verification', 'verifiedWith', elem.verifiedWithElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'Consent.verification', 'verificationDate', elem.verificationDateElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseConsentProvision(obj : TTurtleComplex) : TFhirConsentProvision;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirConsentProvision.create;
  try
    ParseConsentProvisionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConsentProvisionProperties(obj : TTurtleComplex; result : TFhirConsentProvision);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/Consent.provision.type'), CODES_TFhirConsentProvisionTypeEnum, SYSTEMS_TFhirConsentProvisionTypeEnum);
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Consent.provision.period'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Consent.provision.actor') do
      result.actorList.Add(parseConsentProvisionActor(item));
    for item in obj.complexes('http://hl7.org/fhir/Consent.provision.action') do
      result.actionList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Consent.provision.securityLabel') do
      result.securityLabelList.Add(parseCoding(item));
    for item in obj.complexes('http://hl7.org/fhir/Consent.provision.purpose') do
      result.purposeList.Add(parseCoding(item));
    for item in obj.complexes('http://hl7.org/fhir/Consent.provision.class') do
      result.class_List.Add(parseCoding(item));
    for item in obj.complexes('http://hl7.org/fhir/Consent.provision.code') do
      result.codeList.Add(parseCodeableConcept(item));
    result.dataPeriod := ParsePeriod(obj.complex('http://hl7.org/fhir/Consent.provision.dataPeriod'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Consent.provision.data') do
      result.dataList.Add(parseConsentProvisionData(item));
    for item in obj.complexes('http://hl7.org/fhir/Consent.provision.provision') do
      result.provisionList.Add(parseConsentProvision(item));
end;

procedure TFHIRTurtleComposer.ComposeConsentProvision(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConsentProvision; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ConsentProvision'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'Consent.provision', 'type', elem.Type_Element, CODES_TFhirConsentProvisionTypeEnum, SYSTEMS_TFhirConsentProvisionTypeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'Consent.provision', 'period', elem.periodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.actorList.Count - 1 do
      ComposeConsentProvisionActor(this, 'Consent.provision', 'actor', elem.actorList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.actionList.Count - 1 do
      ComposeCodeableConcept(this, 'Consent.provision', 'action', elem.actionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.securityLabelList.Count - 1 do
      ComposeCoding(this, 'Consent.provision', 'securityLabel', elem.securityLabelList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.purposeList.Count - 1 do
      ComposeCoding(this, 'Consent.provision', 'purpose', elem.purposeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.class_List.Count - 1 do
      ComposeCoding(this, 'Consent.provision', 'class', elem.class_List[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.codeList.Count - 1 do
      ComposeCodeableConcept(this, 'Consent.provision', 'code', elem.codeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'Consent.provision', 'dataPeriod', elem.dataPeriodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.dataList.Count - 1 do
      ComposeConsentProvisionData(this, 'Consent.provision', 'data', elem.dataList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.provisionList.Count - 1 do
      ComposeConsentProvision(this, 'Consent.provision', 'provision', elem.provisionList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseConsentProvisionActor(obj : TTurtleComplex) : TFhirConsentProvisionActor;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirConsentProvisionActor.create;
  try
    ParseConsentProvisionActorProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConsentProvisionActorProperties(obj : TTurtleComplex; result : TFhirConsentProvisionActor);
begin
    ParseBackboneElementProperties(obj, result);
    result.role := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Consent.provision.actor.role'));{q3b}
    result.reference := ParseReference{TFhirDevice}(obj.complex('http://hl7.org/fhir/Consent.provision.actor.reference'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeConsentProvisionActor(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConsentProvisionActor; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ConsentProvisionActor'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'Consent.provision.actor', 'role', elem.roleElement, false, -1);{x.2f}
  ComposeReference{TFhirDevice}(this, 'Consent.provision.actor', 'reference', elem.referenceElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseConsentProvisionData(obj : TTurtleComplex) : TFhirConsentProvisionData;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirConsentProvisionData.create;
  try
    ParseConsentProvisionDataProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConsentProvisionDataProperties(obj : TTurtleComplex; result : TFhirConsentProvisionData);
begin
    ParseBackboneElementProperties(obj, result);
    result.meaningElement := ParseEnum(obj.complex('http://hl7.org/fhir/Consent.provision.data.meaning'), CODES_TFhirConsentDataMeaningEnum, SYSTEMS_TFhirConsentDataMeaningEnum);
    result.reference := ParseReference{TFhirReference}(obj.complex('http://hl7.org/fhir/Consent.provision.data.reference'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeConsentProvisionData(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConsentProvisionData; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ConsentProvisionData'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'Consent.provision.data', 'meaning', elem.MeaningElement, CODES_TFhirConsentDataMeaningEnum, SYSTEMS_TFhirConsentDataMeaningEnum, false, -1);{x.d4}
  ComposeReference{TFhirReference}(this, 'Consent.provision.data', 'reference', elem.referenceElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseConsent(obj : TTurtleComplex) : TFhirConsent;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirConsent.create;
  try
    ParseConsentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseConsentProperties(obj : TTurtleComplex; result : TFhirConsent);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Consent.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Consent.status'), CODES_TFhirConsentStateCodesEnum, SYSTEMS_TFhirConsentStateCodesEnum);
    result.scope := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Consent.scope'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Consent.category') do
      result.categoryList.Add(parseCodeableConcept(item));
    result.patient := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/Consent.patient'));{q3b}
    result.dateTimeElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Consent.dateTime'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Consent.performer') do
      result.performerList.Add(parseReference{TFhirOrganization}(item));
    for item in obj.complexes('http://hl7.org/fhir/Consent.organization') do
      result.organizationList.Add(parseReference{TFhirOrganization}(item));
    if obj.has('http://hl7.org/fhir/Consent.sourceAttachment', item) then
      result.source := parseAttachment(item);
    if obj.has('http://hl7.org/fhir/Consent.sourceReference', item) {a3} then
      result.source := ParseReference(item);
    for item in obj.complexes('http://hl7.org/fhir/Consent.policy') do
      result.policyList.Add(parseConsentPolicy(item));
    result.policyRule := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Consent.policyRule'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Consent.verification') do
      result.verificationList.Add(parseConsentVerification(item));
    result.provision := ParseConsentProvision(obj.complex('http://hl7.org/fhir/Consent.provision'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeConsent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirConsent; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Consent'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Consent', 'identifier', elem.identifierList[i], false, i);{x.d3}
  ComposeEnum(this, 'Consent', 'status', elem.StatusElement, CODES_TFhirConsentStateCodesEnum, SYSTEMS_TFhirConsentStateCodesEnum, false, -1);{x.d4}
  ComposeCodeableConcept(this, 'Consent', 'scope', elem.scopeElement, false, -1);{x.2f}
  for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(this, 'Consent', 'category', elem.categoryList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('patient') then
    ComposeReference{TFhirPatient}(this, 'Consent', 'patient', elem.patientElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dateTime') then
    ComposeDateTime(this, 'Consent', 'dateTime', elem.dateTimeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('performer') then
    for i := 0 to elem.performerList.Count - 1 do
      ComposeReference{TFhirOrganization}(this, 'Consent', 'performer', elem.performerList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('organization') then
    for i := 0 to elem.organizationList.Count - 1 do
      ComposeReference{TFhirOrganization}(this, 'Consent', 'organization', elem.organizationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.source is TFhirAttachment) {6} then
    ComposeAttachment(this, 'Consent', 'sourceAttachment', TFhirAttachment(elem.source), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.source is TFhirReference) {2} then
    ComposeReference(this, 'Consent', 'sourceReference', TFhirReference(elem.source), false,-1);{x.d8}
  if (SummaryOption in [soFull, soData]) and doCompose('policy') then
    for i := 0 to elem.policyList.Count - 1 do
      ComposeConsentPolicy(this, 'Consent', 'policy', elem.policyList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('policyRule') then
    ComposeCodeableConcept(this, 'Consent', 'policyRule', elem.policyRuleElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('verification') then
    for i := 0 to elem.verificationList.Count - 1 do
      ComposeConsentVerification(this, 'Consent', 'verification', elem.verificationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('provision') then
    ComposeConsentProvision(this, 'Consent', 'provision', elem.provisionElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_CONSENT}
{$IFDEF FHIR_CONTRACT}
function TFHIRTurtleParser.ParseContractContentDefinition(obj : TTurtleComplex) : TFhirContractContentDefinition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirContractContentDefinition.create;
  try
    ParseContractContentDefinitionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseContractContentDefinitionProperties(obj : TTurtleComplex; result : TFhirContractContentDefinition);
begin
    ParseBackboneElementProperties(obj, result);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Contract.contentDefinition.type'));{q3b}
    result.subType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Contract.contentDefinition.subType'));{q3b}
    result.publisher := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/Contract.contentDefinition.publisher'));{q3b}
    result.publicationDateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Contract.contentDefinition.publicationDate'));{q1}
    result.publicationStatusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Contract.contentDefinition.publicationStatus'), CODES_TFhirContractPublicationstatusEnum, SYSTEMS_TFhirContractPublicationstatusEnum);
    result.copyrightElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/Contract.contentDefinition.copyright'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeContractContentDefinition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContractContentDefinition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ContractContentDefinition'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'Contract.contentDefinition', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Contract.contentDefinition', 'subType', elem.subTypeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirPractitioner}(this, 'Contract.contentDefinition', 'publisher', elem.publisherElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'Contract.contentDefinition', 'publicationDate', elem.publicationDateElement, false, -1);{x.2ea}
  ComposeEnum(this, 'Contract.contentDefinition', 'publicationStatus', elem.PublicationStatusElement, CODES_TFhirContractPublicationstatusEnum, SYSTEMS_TFhirContractPublicationstatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'Contract.contentDefinition', 'copyright', elem.copyrightElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseContractTerm(obj : TTurtleComplex) : TFhirContractTerm;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirContractTerm.create;
  try
    ParseContractTermProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseContractTermProperties(obj : TTurtleComplex; result : TFhirContractTerm);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/Contract.term.identifier'));{q3b}
    result.issuedElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Contract.term.issued'));{q1}
    result.applies := ParsePeriod(obj.complex('http://hl7.org/fhir/Contract.term.applies'));{q3b}
    if obj.has('http://hl7.org/fhir/Contract.term.topicCodeableConcept', item) then
      result.topic := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/Contract.term.topicReference', item) {a3} then
      result.topic := ParseReference(item);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Contract.term.type'));{q3b}
    result.subType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Contract.term.subType'));{q3b}
    result.textElement := ParseString(obj.complex('http://hl7.org/fhir/Contract.term.text'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.securityLabel') do
      result.securityLabelList.Add(parseContractTermSecurityLabel(item));
    result.offer := ParseContractTermOffer(obj.complex('http://hl7.org/fhir/Contract.term.offer'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.asset') do
      result.assetList.Add(parseContractTermAsset(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.action') do
      result.actionList.Add(parseContractTermAction(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.group') do
      result.groupList.Add(parseContractTerm(item));
end;

procedure TFHIRTurtleComposer.ComposeContractTerm(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContractTerm; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ContractTerm'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'Contract.term', 'identifier', elem.identifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'Contract.term', 'issued', elem.issuedElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'Contract.term', 'applies', elem.appliesElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and (elem.topic is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Contract.term', 'topicCodeableConcept', TFhirCodeableConcept(elem.topic), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.topic is TFhirReference) {2} then
    ComposeReference(this, 'Contract.term', 'topicReference', TFhirReference(elem.topic), false,-1);{x.d8}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Contract.term', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Contract.term', 'subType', elem.subTypeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Contract.term', 'text', elem.textElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.securityLabelList.Count - 1 do
      ComposeContractTermSecurityLabel(this, 'Contract.term', 'securityLabel', elem.securityLabelList[i], false, i);{x.d3}
  ComposeContractTermOffer(this, 'Contract.term', 'offer', elem.offerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.assetList.Count - 1 do
      ComposeContractTermAsset(this, 'Contract.term', 'asset', elem.assetList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.actionList.Count - 1 do
      ComposeContractTermAction(this, 'Contract.term', 'action', elem.actionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.groupList.Count - 1 do
      ComposeContractTerm(this, 'Contract.term', 'group', elem.groupList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseContractTermSecurityLabel(obj : TTurtleComplex) : TFhirContractTermSecurityLabel;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirContractTermSecurityLabel.create;
  try
    ParseContractTermSecurityLabelProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseContractTermSecurityLabelProperties(obj : TTurtleComplex; result : TFhirContractTermSecurityLabel);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.securityLabel.number') do
      result.numberList.Add(parseUnsignedInt(item));
    result.classification := ParseCoding(obj.complex('http://hl7.org/fhir/Contract.term.securityLabel.classification'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.securityLabel.category') do
      result.categoryList.Add(parseCoding(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.securityLabel.control') do
      result.controlList.Add(parseCoding(item));
end;

procedure TFHIRTurtleComposer.ComposeContractTermSecurityLabel(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContractTermSecurityLabel; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ContractTermSecurityLabel'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.numberList.Count - 1 do
      ComposeUnsignedInt(this, 'Contract.term.securityLabel', 'number', elem.numberList[i], false, i);{x.d3}
  ComposeCoding(this, 'Contract.term.securityLabel', 'classification', elem.classificationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCoding(this, 'Contract.term.securityLabel', 'category', elem.categoryList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.controlList.Count - 1 do
      ComposeCoding(this, 'Contract.term.securityLabel', 'control', elem.controlList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseContractTermOffer(obj : TTurtleComplex) : TFhirContractTermOffer;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirContractTermOffer.create;
  try
    ParseContractTermOfferProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseContractTermOfferProperties(obj : TTurtleComplex; result : TFhirContractTermOffer);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.offer.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.offer.party') do
      result.partyList.Add(parseContractTermOfferParty(item));
    result.topic := ParseReference{TFhirReference}(obj.complex('http://hl7.org/fhir/Contract.term.offer.topic'));{q3b}
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Contract.term.offer.type'));{q3b}
    result.decision := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Contract.term.offer.decision'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.offer.decisionMode') do
      result.decisionModeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.offer.answer') do
      result.answerList.Add(parseContractTermOfferAnswer(item));
    result.textElement := ParseString(obj.complex('http://hl7.org/fhir/Contract.term.offer.text'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.offer.linkId') do
      result.linkIdList.Add(parseString(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.offer.securityLabelNumber') do
      result.securityLabelNumberList.Add(parseUnsignedInt(item));
end;

procedure TFHIRTurtleComposer.ComposeContractTermOffer(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContractTermOffer; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ContractTermOffer'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Contract.term.offer', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.partyList.Count - 1 do
      ComposeContractTermOfferParty(this, 'Contract.term.offer', 'party', elem.partyList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirReference}(this, 'Contract.term.offer', 'topic', elem.topicElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Contract.term.offer', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Contract.term.offer', 'decision', elem.decisionElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.decisionModeList.Count - 1 do
      ComposeCodeableConcept(this, 'Contract.term.offer', 'decisionMode', elem.decisionModeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.answerList.Count - 1 do
      ComposeContractTermOfferAnswer(this, 'Contract.term.offer', 'answer', elem.answerList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Contract.term.offer', 'text', elem.textElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.linkIdList.Count - 1 do
      ComposeString(this, 'Contract.term.offer', 'linkId', elem.linkIdList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.securityLabelNumberList.Count - 1 do
      ComposeUnsignedInt(this, 'Contract.term.offer', 'securityLabelNumber', elem.securityLabelNumberList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseContractTermOfferParty(obj : TTurtleComplex) : TFhirContractTermOfferParty;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirContractTermOfferParty.create;
  try
    ParseContractTermOfferPartyProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseContractTermOfferPartyProperties(obj : TTurtleComplex; result : TFhirContractTermOfferParty);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.offer.party.reference') do
      result.referenceList.Add(parseReference{TFhirPatient}(item));
    result.role := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Contract.term.offer.party.role'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeContractTermOfferParty(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContractTermOfferParty; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ContractTermOfferParty'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  for i := 0 to elem.referenceList.Count - 1 do
      ComposeReference{TFhirPatient}(this, 'Contract.term.offer.party', 'reference', elem.referenceList[i], false, i);{x.d3}
  ComposeCodeableConcept(this, 'Contract.term.offer.party', 'role', elem.roleElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseContractTermOfferAnswer(obj : TTurtleComplex) : TFhirContractTermOfferAnswer;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirContractTermOfferAnswer.create;
  try
    ParseContractTermOfferAnswerProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseContractTermOfferAnswerProperties(obj : TTurtleComplex; result : TFhirContractTermOfferAnswer);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    if obj.has('http://hl7.org/fhir/Contract.term.offer.answer.valueAttachment', item) then
      result.value := parseAttachment(item);
    if obj.has('http://hl7.org/fhir/Contract.term.offer.answer.valueCoding', item) then
      result.value := parseCoding(item);
    if obj.has('http://hl7.org/fhir/Contract.term.offer.answer.valueQuantity', item) then
      result.value := parseQuantity(item);
    if obj.has('http://hl7.org/fhir/Contract.term.offer.answer.valueReference', item) {a3} then
      result.value := ParseReference(item);
    if obj.has('http://hl7.org/fhir/Contract.term.offer.answer.valueBoolean', item) then
      result.value := parseBoolean(item);
    if obj.has('http://hl7.org/fhir/Contract.term.offer.answer.valueDecimal', item) then
      result.value := parseDecimal(item);
    if obj.has('http://hl7.org/fhir/Contract.term.offer.answer.valueInteger', item) then
      result.value := parseInteger(item);
    if obj.has('http://hl7.org/fhir/Contract.term.offer.answer.valueDate', item) then
      result.value := parseDate(item);
    if obj.has('http://hl7.org/fhir/Contract.term.offer.answer.valueDateTime', item) then
      result.value := parseDateTime(item);
    if obj.has('http://hl7.org/fhir/Contract.term.offer.answer.valueTime', item) then
      result.value := parseTime(item);
    if obj.has('http://hl7.org/fhir/Contract.term.offer.answer.valueString', item) then
      result.value := parseString(item);
    if obj.has('http://hl7.org/fhir/Contract.term.offer.answer.valueUri', item) then
      result.value := parseUri(item);
end;

procedure TFHIRTurtleComposer.ComposeContractTermOfferAnswer(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContractTermOfferAnswer; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ContractTermOfferAnswer'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (elem.value is TFhirAttachment) {6} then
    ComposeAttachment(this, 'Contract.term.offer.answer', 'valueAttachment', TFhirAttachment(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirCoding) {6} then
    ComposeCoding(this, 'Contract.term.offer.answer', 'valueCoding', TFhirCoding(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'Contract.term.offer.answer', 'valueQuantity', TFhirQuantity(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirReference) {2} then
    ComposeReference(this, 'Contract.term.offer.answer', 'valueReference', TFhirReference(elem.value), false,-1){x.d8}
  else if (elem.value is TFhirBoolean) {6} then
    ComposeBoolean(this, 'Contract.term.offer.answer', 'valueBoolean', TFhirBoolean(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirDecimal) {6} then
    ComposeDecimal(this, 'Contract.term.offer.answer', 'valueDecimal', TFhirDecimal(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirInteger) {6} then
    ComposeInteger(this, 'Contract.term.offer.answer', 'valueInteger', TFhirInteger(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirDate) {6} then
    ComposeDate(this, 'Contract.term.offer.answer', 'valueDate', TFhirDate(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirDateTime) {6} then
    ComposeDateTime(this, 'Contract.term.offer.answer', 'valueDateTime', TFhirDateTime(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirTime) {6} then
    ComposeTime(this, 'Contract.term.offer.answer', 'valueTime', TFhirTime(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirString) {6} then
    ComposeString(this, 'Contract.term.offer.answer', 'valueString', TFhirString(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirUri) {6} then
    ComposeUri(this, 'Contract.term.offer.answer', 'valueUri', TFhirUri(elem.value), false, -1);{x.d9}
end;

function TFHIRTurtleParser.ParseContractTermAsset(obj : TTurtleComplex) : TFhirContractTermAsset;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirContractTermAsset.create;
  try
    ParseContractTermAssetProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseContractTermAssetProperties(obj : TTurtleComplex; result : TFhirContractTermAsset);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.scope := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Contract.term.asset.scope'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.asset.type') do
      result.type_List.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.asset.typeReference') do
      result.typeReferenceList.Add(parseReference{TFhirReference}(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.asset.subtype') do
      result.subtypeList.Add(parseCodeableConcept(item));
    result.relationship := ParseCoding(obj.complex('http://hl7.org/fhir/Contract.term.asset.relationship'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.asset.context') do
      result.contextList.Add(parseContractTermAssetContext(item));
    result.conditionElement := ParseString(obj.complex('http://hl7.org/fhir/Contract.term.asset.condition'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.asset.periodType') do
      result.periodTypeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.asset.period') do
      result.periodList.Add(parsePeriod(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.asset.usePeriod') do
      result.usePeriodList.Add(parsePeriod(item));
    result.textElement := ParseString(obj.complex('http://hl7.org/fhir/Contract.term.asset.text'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.asset.linkId') do
      result.linkIdList.Add(parseString(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.asset.answer') do
      result.answerList.Add(parseContractTermOfferAnswer(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.asset.securityLabelNumber') do
      result.securityLabelNumberList.Add(parseUnsignedInt(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.asset.valuedItem') do
      result.valuedItemList.Add(parseContractTermAssetValuedItem(item));
end;

procedure TFHIRTurtleComposer.ComposeContractTermAsset(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContractTermAsset; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ContractTermAsset'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Contract.term.asset', 'scope', elem.scopeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(this, 'Contract.term.asset', 'type', elem.type_List[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.typeReferenceList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'Contract.term.asset', 'typeReference', elem.typeReferenceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.subtypeList.Count - 1 do
      ComposeCodeableConcept(this, 'Contract.term.asset', 'subtype', elem.subtypeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(this, 'Contract.term.asset', 'relationship', elem.relationshipElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.contextList.Count - 1 do
      ComposeContractTermAssetContext(this, 'Contract.term.asset', 'context', elem.contextList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Contract.term.asset', 'condition', elem.conditionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.periodTypeList.Count - 1 do
      ComposeCodeableConcept(this, 'Contract.term.asset', 'periodType', elem.periodTypeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.periodList.Count - 1 do
      ComposePeriod(this, 'Contract.term.asset', 'period', elem.periodList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.usePeriodList.Count - 1 do
      ComposePeriod(this, 'Contract.term.asset', 'usePeriod', elem.usePeriodList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Contract.term.asset', 'text', elem.textElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.linkIdList.Count - 1 do
      ComposeString(this, 'Contract.term.asset', 'linkId', elem.linkIdList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.answerList.Count - 1 do
      ComposeContractTermOfferAnswer(this, 'Contract.term.asset', 'answer', elem.answerList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.securityLabelNumberList.Count - 1 do
      ComposeUnsignedInt(this, 'Contract.term.asset', 'securityLabelNumber', elem.securityLabelNumberList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.valuedItemList.Count - 1 do
      ComposeContractTermAssetValuedItem(this, 'Contract.term.asset', 'valuedItem', elem.valuedItemList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseContractTermAssetContext(obj : TTurtleComplex) : TFhirContractTermAssetContext;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirContractTermAssetContext.create;
  try
    ParseContractTermAssetContextProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseContractTermAssetContextProperties(obj : TTurtleComplex; result : TFhirContractTermAssetContext);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.reference := ParseReference{TFhirReference}(obj.complex('http://hl7.org/fhir/Contract.term.asset.context.reference'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.asset.context.code') do
      result.codeList.Add(parseCodeableConcept(item));
    result.textElement := ParseString(obj.complex('http://hl7.org/fhir/Contract.term.asset.context.text'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeContractTermAssetContext(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContractTermAssetContext; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ContractTermAssetContext'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirReference}(this, 'Contract.term.asset.context', 'reference', elem.referenceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.codeList.Count - 1 do
      ComposeCodeableConcept(this, 'Contract.term.asset.context', 'code', elem.codeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Contract.term.asset.context', 'text', elem.textElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseContractTermAssetValuedItem(obj : TTurtleComplex) : TFhirContractTermAssetValuedItem;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirContractTermAssetValuedItem.create;
  try
    ParseContractTermAssetValuedItemProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseContractTermAssetValuedItemProperties(obj : TTurtleComplex; result : TFhirContractTermAssetValuedItem);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    if obj.has('http://hl7.org/fhir/Contract.term.asset.valuedItem.entityCodeableConcept', item) then
      result.entity := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/Contract.term.asset.valuedItem.entityReference', item) {a3} then
      result.entity := ParseReference(item);
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/Contract.term.asset.valuedItem.identifier'));{q3b}
    result.effectiveTimeElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Contract.term.asset.valuedItem.effectiveTime'));{q1}
    result.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/Contract.term.asset.valuedItem.quantity'));{q3b}
    result.unitPrice := ParseMoney(obj.complex('http://hl7.org/fhir/Contract.term.asset.valuedItem.unitPrice'));{q3b}
    result.factorElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Contract.term.asset.valuedItem.factor'));{q1}
    result.pointsElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Contract.term.asset.valuedItem.points'));{q1}
    result.net := ParseMoney(obj.complex('http://hl7.org/fhir/Contract.term.asset.valuedItem.net'));{q3b}
    result.paymentElement := ParseString(obj.complex('http://hl7.org/fhir/Contract.term.asset.valuedItem.payment'));{q1}
    result.paymentDateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Contract.term.asset.valuedItem.paymentDate'));{q1}
    result.responsible := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/Contract.term.asset.valuedItem.responsible'));{q3b}
    result.recipient := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/Contract.term.asset.valuedItem.recipient'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.asset.valuedItem.linkId') do
      result.linkIdList.Add(parseString(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.asset.valuedItem.securityLabelNumber') do
      result.securityLabelNumberList.Add(parseUnsignedInt(item));
end;

procedure TFHIRTurtleComposer.ComposeContractTermAssetValuedItem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContractTermAssetValuedItem; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ContractTermAssetValuedItem'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) and (elem.entity is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Contract.term.asset.valuedItem', 'entityCodeableConcept', TFhirCodeableConcept(elem.entity), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.entity is TFhirReference) {2} then
    ComposeReference(this, 'Contract.term.asset.valuedItem', 'entityReference', TFhirReference(elem.entity), false,-1);{x.d8}
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(this, 'Contract.term.asset.valuedItem', 'identifier', elem.identifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'Contract.term.asset.valuedItem', 'effectiveTime', elem.effectiveTimeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'Contract.term.asset.valuedItem', 'quantity', elem.quantityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'Contract.term.asset.valuedItem', 'unitPrice', elem.unitPriceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'Contract.term.asset.valuedItem', 'factor', elem.factorElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'Contract.term.asset.valuedItem', 'points', elem.pointsElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'Contract.term.asset.valuedItem', 'net', elem.netElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Contract.term.asset.valuedItem', 'payment', elem.paymentElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'Contract.term.asset.valuedItem', 'paymentDate', elem.paymentDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(this, 'Contract.term.asset.valuedItem', 'responsible', elem.responsibleElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(this, 'Contract.term.asset.valuedItem', 'recipient', elem.recipientElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.linkIdList.Count - 1 do
      ComposeString(this, 'Contract.term.asset.valuedItem', 'linkId', elem.linkIdList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.securityLabelNumberList.Count - 1 do
      ComposeUnsignedInt(this, 'Contract.term.asset.valuedItem', 'securityLabelNumber', elem.securityLabelNumberList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseContractTermAction(obj : TTurtleComplex) : TFhirContractTermAction;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirContractTermAction.create;
  try
    ParseContractTermActionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseContractTermActionProperties(obj : TTurtleComplex; result : TFhirContractTermAction);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.doNotPerformElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Contract.term.action.doNotPerform'));{q1}
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Contract.term.action.type'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.action.subject') do
      result.subjectList.Add(parseContractTermActionSubject(item));
    result.intent := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Contract.term.action.intent'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.action.linkId') do
      result.linkIdList.Add(parseString(item));
    result.status := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Contract.term.action.status'));{q3b}
    result.context := ParseReference{TFhirEncounter}(obj.complex('http://hl7.org/fhir/Contract.term.action.context'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.action.contextLinkId') do
      result.contextLinkIdList.Add(parseString(item));
    if obj.has('http://hl7.org/fhir/Contract.term.action.occurrencePeriod', item) then
      result.occurrence := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/Contract.term.action.occurrenceTiming', item) then
      result.occurrence := parseTiming(item);
    if obj.has('http://hl7.org/fhir/Contract.term.action.occurrenceDateTime', item) then
      result.occurrence := parseDateTime(item);
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.action.requester') do
      result.requesterList.Add(parseReference{TFhirPatient}(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.action.requesterLinkId') do
      result.requesterLinkIdList.Add(parseString(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.action.performerType') do
      result.performerTypeList.Add(parseCodeableConcept(item));
    result.performerRole := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Contract.term.action.performerRole'));{q3b}
    result.performer := ParseReference{TFhirRelatedPerson}(obj.complex('http://hl7.org/fhir/Contract.term.action.performer'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.action.performerLinkId') do
      result.performerLinkIdList.Add(parseString(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.action.reasonCode') do
      result.reasonCodeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.action.reasonReference') do
      result.reasonReferenceList.Add(parseReference{TFhirCondition}(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.action.reason') do
      result.reasonList.Add(parseString(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.action.reasonLinkId') do
      result.reasonLinkIdList.Add(parseString(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.action.note') do
      result.noteList.Add(parseAnnotation(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.action.securityLabelNumber') do
      result.securityLabelNumberList.Add(parseUnsignedInt(item));
end;

procedure TFHIRTurtleComposer.ComposeContractTermAction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContractTermAction; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ContractTermAction'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'Contract.term.action', 'doNotPerform', elem.doNotPerformElement, false, -1);{x.2ea}
  ComposeCodeableConcept(this, 'Contract.term.action', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.subjectList.Count - 1 do
      ComposeContractTermActionSubject(this, 'Contract.term.action', 'subject', elem.subjectList[i], false, i);{x.d3}
  ComposeCodeableConcept(this, 'Contract.term.action', 'intent', elem.intentElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.linkIdList.Count - 1 do
      ComposeString(this, 'Contract.term.action', 'linkId', elem.linkIdList[i], false, i);{x.d3}
  ComposeCodeableConcept(this, 'Contract.term.action', 'status', elem.statusElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirEncounter}(this, 'Contract.term.action', 'context', elem.contextElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.contextLinkIdList.Count - 1 do
      ComposeString(this, 'Contract.term.action', 'contextLinkId', elem.contextLinkIdList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and (elem.occurrence is TFhirPeriod) {6} then
    ComposePeriod(this, 'Contract.term.action', 'occurrencePeriod', TFhirPeriod(elem.occurrence), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.occurrence is TFhirTiming) {6} then
    ComposeTiming(this, 'Contract.term.action', 'occurrenceTiming', TFhirTiming(elem.occurrence), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.occurrence is TFhirDateTime) {6} then
    ComposeDateTime(this, 'Contract.term.action', 'occurrenceDateTime', TFhirDateTime(elem.occurrence), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.requesterList.Count - 1 do
      ComposeReference{TFhirPatient}(this, 'Contract.term.action', 'requester', elem.requesterList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.requesterLinkIdList.Count - 1 do
      ComposeString(this, 'Contract.term.action', 'requesterLinkId', elem.requesterLinkIdList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.performerTypeList.Count - 1 do
      ComposeCodeableConcept(this, 'Contract.term.action', 'performerType', elem.performerTypeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Contract.term.action', 'performerRole', elem.performerRoleElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirRelatedPerson}(this, 'Contract.term.action', 'performer', elem.performerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.performerLinkIdList.Count - 1 do
      ComposeString(this, 'Contract.term.action', 'performerLinkId', elem.performerLinkIdList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'Contract.term.action', 'reasonCode', elem.reasonCodeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.reasonReferenceList.Count - 1 do
      ComposeReference{TFhirCondition}(this, 'Contract.term.action', 'reasonReference', elem.reasonReferenceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.reasonList.Count - 1 do
      ComposeString(this, 'Contract.term.action', 'reason', elem.reasonList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.reasonLinkIdList.Count - 1 do
      ComposeString(this, 'Contract.term.action', 'reasonLinkId', elem.reasonLinkIdList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'Contract.term.action', 'note', elem.noteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.securityLabelNumberList.Count - 1 do
      ComposeUnsignedInt(this, 'Contract.term.action', 'securityLabelNumber', elem.securityLabelNumberList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseContractTermActionSubject(obj : TTurtleComplex) : TFhirContractTermActionSubject;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirContractTermActionSubject.create;
  try
    ParseContractTermActionSubjectProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseContractTermActionSubjectProperties(obj : TTurtleComplex; result : TFhirContractTermActionSubject);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Contract.term.action.subject.reference') do
      result.referenceList.Add(parseReference{TFhirPatient}(item));
    result.role := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Contract.term.action.subject.role'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeContractTermActionSubject(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContractTermActionSubject; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ContractTermActionSubject'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  for i := 0 to elem.referenceList.Count - 1 do
      ComposeReference{TFhirPatient}(this, 'Contract.term.action.subject', 'reference', elem.referenceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Contract.term.action.subject', 'role', elem.roleElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseContractSigner(obj : TTurtleComplex) : TFhirContractSigner;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirContractSigner.create;
  try
    ParseContractSignerProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseContractSignerProperties(obj : TTurtleComplex; result : TFhirContractSigner);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.type_ := ParseCoding(obj.complex('http://hl7.org/fhir/Contract.signer.type'));{q3b}
    result.party := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/Contract.signer.party'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Contract.signer.signature') do
      result.signatureList.Add(parseSignature(item));
end;

procedure TFHIRTurtleComposer.ComposeContractSigner(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContractSigner; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ContractSigner'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCoding(this, 'Contract.signer', 'type', elem.type_Element, false, -1);{x.2f}
  ComposeReference{TFhirOrganization}(this, 'Contract.signer', 'party', elem.partyElement, false, -1);{x.2f}
  for i := 0 to elem.signatureList.Count - 1 do
      ComposeSignature(this, 'Contract.signer', 'signature', elem.signatureList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseContractFriendly(obj : TTurtleComplex) : TFhirContractFriendly;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirContractFriendly.create;
  try
    ParseContractFriendlyProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseContractFriendlyProperties(obj : TTurtleComplex; result : TFhirContractFriendly);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    if obj.has('http://hl7.org/fhir/Contract.friendly.contentAttachment', item) then
      result.content := parseAttachment(item);
    if obj.has('http://hl7.org/fhir/Contract.friendly.contentReference', item) {a3} then
      result.content := ParseReference(item);
end;

procedure TFHIRTurtleComposer.ComposeContractFriendly(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContractFriendly; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ContractFriendly'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (elem.content is TFhirAttachment) {6} then
    ComposeAttachment(this, 'Contract.friendly', 'contentAttachment', TFhirAttachment(elem.content), false, -1){x.d9}
  else if (elem.content is TFhirReference) {2} then
    ComposeReference(this, 'Contract.friendly', 'contentReference', TFhirReference(elem.content), false,-1);{x.d8}
end;

function TFHIRTurtleParser.ParseContractLegal(obj : TTurtleComplex) : TFhirContractLegal;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirContractLegal.create;
  try
    ParseContractLegalProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseContractLegalProperties(obj : TTurtleComplex; result : TFhirContractLegal);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    if obj.has('http://hl7.org/fhir/Contract.legal.contentAttachment', item) then
      result.content := parseAttachment(item);
    if obj.has('http://hl7.org/fhir/Contract.legal.contentReference', item) {a3} then
      result.content := ParseReference(item);
end;

procedure TFHIRTurtleComposer.ComposeContractLegal(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContractLegal; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ContractLegal'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (elem.content is TFhirAttachment) {6} then
    ComposeAttachment(this, 'Contract.legal', 'contentAttachment', TFhirAttachment(elem.content), false, -1){x.d9}
  else if (elem.content is TFhirReference) {2} then
    ComposeReference(this, 'Contract.legal', 'contentReference', TFhirReference(elem.content), false,-1);{x.d8}
end;

function TFHIRTurtleParser.ParseContractRule(obj : TTurtleComplex) : TFhirContractRule;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirContractRule.create;
  try
    ParseContractRuleProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseContractRuleProperties(obj : TTurtleComplex; result : TFhirContractRule);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    if obj.has('http://hl7.org/fhir/Contract.rule.contentAttachment', item) then
      result.content := parseAttachment(item);
    if obj.has('http://hl7.org/fhir/Contract.rule.contentReference', item) {a3} then
      result.content := ParseReference(item);
end;

procedure TFHIRTurtleComposer.ComposeContractRule(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContractRule; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ContractRule'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (elem.content is TFhirAttachment) {6} then
    ComposeAttachment(this, 'Contract.rule', 'contentAttachment', TFhirAttachment(elem.content), false, -1){x.d9}
  else if (elem.content is TFhirReference) {2} then
    ComposeReference(this, 'Contract.rule', 'contentReference', TFhirReference(elem.content), false,-1);{x.d8}
end;

function TFHIRTurtleParser.ParseContract(obj : TTurtleComplex) : TFhirContract;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirContract.create;
  try
    ParseContractProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseContractProperties(obj : TTurtleComplex; result : TFhirContract);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Contract.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/Contract.url'));{q1}
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/Contract.version'));{q1}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Contract.status'), CODES_TFhirContractStatusEnum, SYSTEMS_TFhirContractStatusEnum);
    result.legalState := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Contract.legalState'));{q3b}
    result.instantiatesCanonical := ParseReference{TFhirContract}(obj.complex('http://hl7.org/fhir/Contract.instantiatesCanonical'));{q3b}
    result.instantiatesUriElement := ParseUri(obj.complex('http://hl7.org/fhir/Contract.instantiatesUri'));{q1}
    result.contentDerivative := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Contract.contentDerivative'));{q3b}
    result.issuedElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Contract.issued'));{q1}
    result.applies := ParsePeriod(obj.complex('http://hl7.org/fhir/Contract.applies'));{q3b}
    result.expirationType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Contract.expirationType'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Contract.subject') do
      result.subjectList.Add(parseReference{TFhirReference}(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.authority') do
      result.authorityList.Add(parseReference{TFhirOrganization}(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.domain') do
      result.domainList.Add(parseReference{TFhirLocation}(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.site') do
      result.siteList.Add(parseReference{TFhirLocation}(item));
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/Contract.name'));{q1}
    result.titleElement := ParseString(obj.complex('http://hl7.org/fhir/Contract.title'));{q1}
    result.subtitleElement := ParseString(obj.complex('http://hl7.org/fhir/Contract.subtitle'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Contract.alias') do
      result.aliasList.Add(parseString(item));
    result.author := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/Contract.author'));{q3b}
    result.scope := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Contract.scope'));{q3b}
    if obj.has('http://hl7.org/fhir/Contract.topicCodeableConcept', item) then
      result.topic := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/Contract.topicReference', item) {a3} then
      result.topic := ParseReference(item);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Contract.type'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Contract.subType') do
      result.subTypeList.Add(parseCodeableConcept(item));
    result.contentDefinition := ParseContractContentDefinition(obj.complex('http://hl7.org/fhir/Contract.contentDefinition'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Contract.term') do
      result.termList.Add(parseContractTerm(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.supportingInfo') do
      result.supportingInfoList.Add(parseReference{TFhirReference}(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.relevantHistory') do
      result.relevantHistoryList.Add(parseReference{TFhirProvenance}(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.signer') do
      result.signerList.Add(parseContractSigner(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.friendly') do
      result.friendlyList.Add(parseContractFriendly(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.legal') do
      result.legalList.Add(parseContractLegal(item));
    for item in obj.complexes('http://hl7.org/fhir/Contract.rule') do
      result.ruleList.Add(parseContractRule(item));
    if obj.has('http://hl7.org/fhir/Contract.legallyBindingAttachment', item) then
      result.legallyBinding := parseAttachment(item);
    if obj.has('http://hl7.org/fhir/Contract.legallyBindingReference', item) {a3} then
      result.legallyBinding := ParseReference(item);
end;

procedure TFHIRTurtleComposer.ComposeContract(parent :  TTurtleComplex; parentType, name : String; elem : TFhirContract; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Contract'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Contract', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('url') then
    ComposeUri(this, 'Contract', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(this, 'Contract', 'version', elem.versionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(this, 'Contract', 'status', elem.StatusElement, CODES_TFhirContractStatusEnum, SYSTEMS_TFhirContractStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('legalState') then
    ComposeCodeableConcept(this, 'Contract', 'legalState', elem.legalStateElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('instantiatesCanonical') then
    ComposeReference{TFhirContract}(this, 'Contract', 'instantiatesCanonical', elem.instantiatesCanonicalElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('instantiatesUri') then
    ComposeUri(this, 'Contract', 'instantiatesUri', elem.instantiatesUriElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('contentDerivative') then
    ComposeCodeableConcept(this, 'Contract', 'contentDerivative', elem.contentDerivativeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('issued') then
    ComposeDateTime(this, 'Contract', 'issued', elem.issuedElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('applies') then
    ComposePeriod(this, 'Contract', 'applies', elem.appliesElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('expirationType') then
    ComposeCodeableConcept(this, 'Contract', 'expirationType', elem.expirationTypeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    for i := 0 to elem.subjectList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'Contract', 'subject', elem.subjectList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('authority') then
    for i := 0 to elem.authorityList.Count - 1 do
      ComposeReference{TFhirOrganization}(this, 'Contract', 'authority', elem.authorityList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('domain') then
    for i := 0 to elem.domainList.Count - 1 do
      ComposeReference{TFhirLocation}(this, 'Contract', 'domain', elem.domainList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('site') then
    for i := 0 to elem.siteList.Count - 1 do
      ComposeReference{TFhirLocation}(this, 'Contract', 'site', elem.siteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(this, 'Contract', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeString(this, 'Contract', 'title', elem.titleElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('subtitle') then
    ComposeString(this, 'Contract', 'subtitle', elem.subtitleElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('alias') then
    for i := 0 to elem.aliasList.Count - 1 do
      ComposeString(this, 'Contract', 'alias', elem.aliasList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('author') then
    ComposeReference{TFhirPatient}(this, 'Contract', 'author', elem.authorElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('scope') then
    ComposeCodeableConcept(this, 'Contract', 'scope', elem.scopeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and (elem.topic is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Contract', 'topicCodeableConcept', TFhirCodeableConcept(elem.topic), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.topic is TFhirReference) {2} then
    ComposeReference(this, 'Contract', 'topicReference', TFhirReference(elem.topic), false,-1);{x.d8}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCodeableConcept(this, 'Contract', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subType') then
    for i := 0 to elem.subTypeList.Count - 1 do
      ComposeCodeableConcept(this, 'Contract', 'subType', elem.subTypeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('contentDefinition') then
    ComposeContractContentDefinition(this, 'Contract', 'contentDefinition', elem.contentDefinitionElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('term') then
    for i := 0 to elem.termList.Count - 1 do
      ComposeContractTerm(this, 'Contract', 'term', elem.termList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('supportingInfo') then
    for i := 0 to elem.supportingInfoList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'Contract', 'supportingInfo', elem.supportingInfoList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('relevantHistory') then
    for i := 0 to elem.relevantHistoryList.Count - 1 do
      ComposeReference{TFhirProvenance}(this, 'Contract', 'relevantHistory', elem.relevantHistoryList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('signer') then
    for i := 0 to elem.signerList.Count - 1 do
      ComposeContractSigner(this, 'Contract', 'signer', elem.signerList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('friendly') then
    for i := 0 to elem.friendlyList.Count - 1 do
      ComposeContractFriendly(this, 'Contract', 'friendly', elem.friendlyList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('legal') then
    for i := 0 to elem.legalList.Count - 1 do
      ComposeContractLegal(this, 'Contract', 'legal', elem.legalList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('rule') then
    for i := 0 to elem.ruleList.Count - 1 do
      ComposeContractRule(this, 'Contract', 'rule', elem.ruleList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and (elem.legallyBinding is TFhirAttachment) {6} then
    ComposeAttachment(this, 'Contract', 'legallyBindingAttachment', TFhirAttachment(elem.legallyBinding), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.legallyBinding is TFhirReference) {2} then
    ComposeReference(this, 'Contract', 'legallyBindingReference', TFhirReference(elem.legallyBinding), false,-1);{x.d8}
end;

{$ENDIF FHIR_CONTRACT}
{$IFDEF FHIR_COVERAGE}
function TFHIRTurtleParser.ParseCoverageClass(obj : TTurtleComplex) : TFhirCoverageClass;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCoverageClass.create;
  try
    ParseCoverageClassProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCoverageClassProperties(obj : TTurtleComplex; result : TFhirCoverageClass);
begin
    ParseBackboneElementProperties(obj, result);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Coverage.class.type'));{q3b}
    result.valueElement := ParseString(obj.complex('http://hl7.org/fhir/Coverage.class.value'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/Coverage.class.name'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeCoverageClass(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCoverageClass; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CoverageClass'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'Coverage.class', 'type', elem.type_Element, false, -1);{x.2f}
  ComposeString(this, 'Coverage.class', 'value', elem.valueElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Coverage.class', 'name', elem.nameElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseCoverageCostToBeneficiary(obj : TTurtleComplex) : TFhirCoverageCostToBeneficiary;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCoverageCostToBeneficiary.create;
  try
    ParseCoverageCostToBeneficiaryProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCoverageCostToBeneficiaryProperties(obj : TTurtleComplex; result : TFhirCoverageCostToBeneficiary);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Coverage.costToBeneficiary.type'));{q3b}
    if obj.has('http://hl7.org/fhir/Coverage.costToBeneficiary.valueQuantity', item) then
      result.value := parseQuantity(item);
    if obj.has('http://hl7.org/fhir/Coverage.costToBeneficiary.valueMoney', item) then
      result.value := parseMoney(item);
    for item in obj.complexes('http://hl7.org/fhir/Coverage.costToBeneficiary.exception') do
      result.exceptionList.Add(parseCoverageCostToBeneficiaryException(item));
end;

procedure TFHIRTurtleComposer.ComposeCoverageCostToBeneficiary(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCoverageCostToBeneficiary; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CoverageCostToBeneficiary'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Coverage.costToBeneficiary', 'type', elem.type_Element, false, -1);{x.2f}
  if (elem.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'Coverage.costToBeneficiary', 'valueQuantity', TFhirQuantity(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirMoney) {6} then
    ComposeMoney(this, 'Coverage.costToBeneficiary', 'valueMoney', TFhirMoney(elem.value), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.exceptionList.Count - 1 do
      ComposeCoverageCostToBeneficiaryException(this, 'Coverage.costToBeneficiary', 'exception', elem.exceptionList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseCoverageCostToBeneficiaryException(obj : TTurtleComplex) : TFhirCoverageCostToBeneficiaryException;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCoverageCostToBeneficiaryException.create;
  try
    ParseCoverageCostToBeneficiaryExceptionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCoverageCostToBeneficiaryExceptionProperties(obj : TTurtleComplex; result : TFhirCoverageCostToBeneficiaryException);
begin
    ParseBackboneElementProperties(obj, result);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Coverage.costToBeneficiary.exception.type'));{q3b}
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Coverage.costToBeneficiary.exception.period'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeCoverageCostToBeneficiaryException(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCoverageCostToBeneficiaryException; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CoverageCostToBeneficiaryException'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'Coverage.costToBeneficiary.exception', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'Coverage.costToBeneficiary.exception', 'period', elem.periodElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseCoverage(obj : TTurtleComplex) : TFhirCoverage;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCoverage.create;
  try
    ParseCoverageProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCoverageProperties(obj : TTurtleComplex; result : TFhirCoverage);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Coverage.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Coverage.status'), CODES_TFhirFmStatusEnum, SYSTEMS_TFhirFmStatusEnum);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Coverage.type'));{q3b}
    result.policyHolder := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/Coverage.policyHolder'));{q3b}
    result.subscriber := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/Coverage.subscriber'));{q3b}
    result.subscriberIdElement := ParseString(obj.complex('http://hl7.org/fhir/Coverage.subscriberId'));{q1}
    result.beneficiary := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/Coverage.beneficiary'));{q3b}
    result.dependentElement := ParseString(obj.complex('http://hl7.org/fhir/Coverage.dependent'));{q1}
    result.relationship := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Coverage.relationship'));{q3b}
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Coverage.period'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Coverage.payor') do
      result.payorList.Add(parseReference{TFhirOrganization}(item));
    for item in obj.complexes('http://hl7.org/fhir/Coverage.class') do
      result.class_List.Add(parseCoverageClass(item));
    result.orderElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Coverage.order'));{q1}
    result.networkElement := ParseString(obj.complex('http://hl7.org/fhir/Coverage.network'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Coverage.costToBeneficiary') do
      result.costToBeneficiaryList.Add(parseCoverageCostToBeneficiary(item));
    result.subrogationElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Coverage.subrogation'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Coverage.contract') do
      result.contractList.Add(parseReference{TFhirContract}(item));
end;

procedure TFHIRTurtleComposer.ComposeCoverage(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCoverage; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Coverage'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Coverage', 'identifier', elem.identifierList[i], false, i);{x.d3}
  ComposeEnum(this, 'Coverage', 'status', elem.StatusElement, CODES_TFhirFmStatusEnum, SYSTEMS_TFhirFmStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCodeableConcept(this, 'Coverage', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('policyHolder') then
    ComposeReference{TFhirPatient}(this, 'Coverage', 'policyHolder', elem.policyHolderElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subscriber') then
    ComposeReference{TFhirPatient}(this, 'Coverage', 'subscriber', elem.subscriberElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subscriberId') then
    ComposeString(this, 'Coverage', 'subscriberId', elem.subscriberIdElement, false, -1);{x.2ea}
  ComposeReference{TFhirPatient}(this, 'Coverage', 'beneficiary', elem.beneficiaryElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dependent') then
    ComposeString(this, 'Coverage', 'dependent', elem.dependentElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('relationship') then
    ComposeCodeableConcept(this, 'Coverage', 'relationship', elem.relationshipElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('period') then
    ComposePeriod(this, 'Coverage', 'period', elem.periodElement, false, -1);{x.2f}
  for i := 0 to elem.payorList.Count - 1 do
      ComposeReference{TFhirOrganization}(this, 'Coverage', 'payor', elem.payorList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('class_') then
    for i := 0 to elem.class_List.Count - 1 do
      ComposeCoverageClass(this, 'Coverage', 'class', elem.class_List[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('order') then
    ComposePositiveInt(this, 'Coverage', 'order', elem.orderElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('network') then
    ComposeString(this, 'Coverage', 'network', elem.networkElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('costToBeneficiary') then
    for i := 0 to elem.costToBeneficiaryList.Count - 1 do
      ComposeCoverageCostToBeneficiary(this, 'Coverage', 'costToBeneficiary', elem.costToBeneficiaryList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('subrogation') then
    ComposeBoolean(this, 'Coverage', 'subrogation', elem.subrogationElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('contract') then
    for i := 0 to elem.contractList.Count - 1 do
      ComposeReference{TFhirContract}(this, 'Coverage', 'contract', elem.contractList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_COVERAGE}
{$IFDEF FHIR_COVERAGEELIGIBILITYREQUEST}
function TFHIRTurtleParser.ParseCoverageEligibilityRequestSupportingInfo(obj : TTurtleComplex) : TFhirCoverageEligibilityRequestSupportingInfo;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCoverageEligibilityRequestSupportingInfo.create;
  try
    ParseCoverageEligibilityRequestSupportingInfoProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCoverageEligibilityRequestSupportingInfoProperties(obj : TTurtleComplex; result : TFhirCoverageEligibilityRequestSupportingInfo);
begin
    ParseBackboneElementProperties(obj, result);
    result.sequenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/CoverageEligibilityRequest.supportingInfo.sequence'));{q1}
    result.information := ParseReference{TFhirReference}(obj.complex('http://hl7.org/fhir/CoverageEligibilityRequest.supportingInfo.information'));{q3b}
    result.appliesToAllElement := ParseBoolean(obj.complex('http://hl7.org/fhir/CoverageEligibilityRequest.supportingInfo.appliesToAll'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeCoverageEligibilityRequestSupportingInfo(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCoverageEligibilityRequestSupportingInfo; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CoverageEligibilityRequestSupportingInfo'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposePositiveInt(this, 'CoverageEligibilityRequest.supportingInfo', 'sequence', elem.sequenceElement, false, -1);{x.2ea}
  ComposeReference{TFhirReference}(this, 'CoverageEligibilityRequest.supportingInfo', 'information', elem.informationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'CoverageEligibilityRequest.supportingInfo', 'appliesToAll', elem.appliesToAllElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseCoverageEligibilityRequestInsurance(obj : TTurtleComplex) : TFhirCoverageEligibilityRequestInsurance;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCoverageEligibilityRequestInsurance.create;
  try
    ParseCoverageEligibilityRequestInsuranceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCoverageEligibilityRequestInsuranceProperties(obj : TTurtleComplex; result : TFhirCoverageEligibilityRequestInsurance);
begin
    ParseBackboneElementProperties(obj, result);
    result.focalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/CoverageEligibilityRequest.insurance.focal'));{q1}
    result.coverage := ParseReference{TFhirCoverage}(obj.complex('http://hl7.org/fhir/CoverageEligibilityRequest.insurance.coverage'));{q3b}
    result.businessArrangementElement := ParseString(obj.complex('http://hl7.org/fhir/CoverageEligibilityRequest.insurance.businessArrangement'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeCoverageEligibilityRequestInsurance(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCoverageEligibilityRequestInsurance; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CoverageEligibilityRequestInsurance'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'CoverageEligibilityRequest.insurance', 'focal', elem.focalElement, false, -1);{x.2ea}
  ComposeReference{TFhirCoverage}(this, 'CoverageEligibilityRequest.insurance', 'coverage', elem.coverageElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'CoverageEligibilityRequest.insurance', 'businessArrangement', elem.businessArrangementElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseCoverageEligibilityRequestItem(obj : TTurtleComplex) : TFhirCoverageEligibilityRequestItem;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCoverageEligibilityRequestItem.create;
  try
    ParseCoverageEligibilityRequestItemProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCoverageEligibilityRequestItemProperties(obj : TTurtleComplex; result : TFhirCoverageEligibilityRequestItem);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/CoverageEligibilityRequest.item.supportingInfoSequence') do
      result.supportingInfoSequenceList.Add(parsePositiveInt(item));
    result.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/CoverageEligibilityRequest.item.category'));{q3b}
    result.productOrService := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/CoverageEligibilityRequest.item.productOrService'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/CoverageEligibilityRequest.item.modifier') do
      result.modifierList.Add(parseCodeableConcept(item));
    result.provider := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/CoverageEligibilityRequest.item.provider'));{q3b}
    result.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/CoverageEligibilityRequest.item.quantity'));{q3b}
    result.unitPrice := ParseMoney(obj.complex('http://hl7.org/fhir/CoverageEligibilityRequest.item.unitPrice'));{q3b}
    result.facility := ParseReference{TFhirLocation}(obj.complex('http://hl7.org/fhir/CoverageEligibilityRequest.item.facility'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/CoverageEligibilityRequest.item.diagnosis') do
      result.diagnosisList.Add(parseCoverageEligibilityRequestItemDiagnosis(item));
    for item in obj.complexes('http://hl7.org/fhir/CoverageEligibilityRequest.item.detail') do
      result.detailList.Add(parseReference{TFhirReference}(item));
end;

procedure TFHIRTurtleComposer.ComposeCoverageEligibilityRequestItem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCoverageEligibilityRequestItem; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CoverageEligibilityRequestItem'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.supportingInfoSequenceList.Count - 1 do
      ComposePositiveInt(this, 'CoverageEligibilityRequest.item', 'supportingInfoSequence', elem.supportingInfoSequenceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'CoverageEligibilityRequest.item', 'category', elem.categoryElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'CoverageEligibilityRequest.item', 'productOrService', elem.productOrServiceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.modifierList.Count - 1 do
      ComposeCodeableConcept(this, 'CoverageEligibilityRequest.item', 'modifier', elem.modifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirPractitioner}(this, 'CoverageEligibilityRequest.item', 'provider', elem.providerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'CoverageEligibilityRequest.item', 'quantity', elem.quantityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'CoverageEligibilityRequest.item', 'unitPrice', elem.unitPriceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirLocation}(this, 'CoverageEligibilityRequest.item', 'facility', elem.facilityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.diagnosisList.Count - 1 do
      ComposeCoverageEligibilityRequestItemDiagnosis(this, 'CoverageEligibilityRequest.item', 'diagnosis', elem.diagnosisList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.detailList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'CoverageEligibilityRequest.item', 'detail', elem.detailList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseCoverageEligibilityRequestItemDiagnosis(obj : TTurtleComplex) : TFhirCoverageEligibilityRequestItemDiagnosis;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCoverageEligibilityRequestItemDiagnosis.create;
  try
    ParseCoverageEligibilityRequestItemDiagnosisProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCoverageEligibilityRequestItemDiagnosisProperties(obj : TTurtleComplex; result : TFhirCoverageEligibilityRequestItemDiagnosis);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    if obj.has('http://hl7.org/fhir/CoverageEligibilityRequest.item.diagnosis.diagnosisCodeableConcept', item) then
      result.diagnosis := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/CoverageEligibilityRequest.item.diagnosis.diagnosisReference', item) {a3} then
      result.diagnosis := ParseReference(item);
end;

procedure TFHIRTurtleComposer.ComposeCoverageEligibilityRequestItemDiagnosis(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCoverageEligibilityRequestItemDiagnosis; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CoverageEligibilityRequestItemDiagnosis'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) and (elem.diagnosis is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'CoverageEligibilityRequest.item.diagnosis', 'diagnosisCodeableConcept', TFhirCodeableConcept(elem.diagnosis), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.diagnosis is TFhirReference) {2} then
    ComposeReference(this, 'CoverageEligibilityRequest.item.diagnosis', 'diagnosisReference', TFhirReference(elem.diagnosis), false,-1);{x.d8}
end;

function TFHIRTurtleParser.ParseCoverageEligibilityRequest(obj : TTurtleComplex) : TFhirCoverageEligibilityRequest;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCoverageEligibilityRequest.create;
  try
    ParseCoverageEligibilityRequestProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCoverageEligibilityRequestProperties(obj : TTurtleComplex; result : TFhirCoverageEligibilityRequest);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/CoverageEligibilityRequest.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/CoverageEligibilityRequest.status'), CODES_TFhirFmStatusEnum, SYSTEMS_TFhirFmStatusEnum);
    result.priority := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/CoverageEligibilityRequest.priority'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/CoverageEligibilityRequest.purpose') do
      result.purposeList.Add(parseEnum(item, CODES_TFhirEligibilityrequestPurposeEnum, SYSTEMS_TFhirEligibilityrequestPurposeEnum));
    result.patient := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/CoverageEligibilityRequest.patient'));{q3b}
    if obj.has('http://hl7.org/fhir/CoverageEligibilityRequest.servicedPeriod', item) then
      result.serviced := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/CoverageEligibilityRequest.servicedDate', item) then
      result.serviced := parseDate(item);
    result.createdElement := ParseDateTime(obj.complex('http://hl7.org/fhir/CoverageEligibilityRequest.created'));{q1}
    result.enterer := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/CoverageEligibilityRequest.enterer'));{q3b}
    result.provider := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/CoverageEligibilityRequest.provider'));{q3b}
    result.insurer := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/CoverageEligibilityRequest.insurer'));{q3b}
    result.facility := ParseReference{TFhirLocation}(obj.complex('http://hl7.org/fhir/CoverageEligibilityRequest.facility'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/CoverageEligibilityRequest.supportingInfo') do
      result.supportingInfoList.Add(parseCoverageEligibilityRequestSupportingInfo(item));
    for item in obj.complexes('http://hl7.org/fhir/CoverageEligibilityRequest.insurance') do
      result.insuranceList.Add(parseCoverageEligibilityRequestInsurance(item));
    for item in obj.complexes('http://hl7.org/fhir/CoverageEligibilityRequest.item') do
      result.itemList.Add(parseCoverageEligibilityRequestItem(item));
end;

procedure TFHIRTurtleComposer.ComposeCoverageEligibilityRequest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCoverageEligibilityRequest; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CoverageEligibilityRequest'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'CoverageEligibilityRequest', 'identifier', elem.identifierList[i], false, i);{x.d3}
  ComposeEnum(this, 'CoverageEligibilityRequest', 'status', elem.StatusElement, CODES_TFhirFmStatusEnum, SYSTEMS_TFhirFmStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('priority') then
    ComposeCodeableConcept(this, 'CoverageEligibilityRequest', 'priority', elem.priorityElement, false, -1);{x.2f}
  for i := 0 to elem.purposeList.Count - 1 do
      ComposeEnum(this, 'CoverageEligibilityRequest', 'purpose', elem.purposeList[i], CODES_TFhirEligibilityrequestPurposeEnum, SYSTEMS_TFhirEligibilityrequestPurposeEnum, false, i); {x.d1}
  for i := 0 to elem.purposeList.Count - 1 do
      ComposeEnum(this, 'CoverageEligibilityRequest', 'purpose', elem.purposeList[i], CODES_TFhirEligibilityrequestPurposeEnum, SYSTEMS_TFhirEligibilityrequestPurposeEnum, false, i);{x.d2}
  ComposeReference{TFhirPatient}(this, 'CoverageEligibilityRequest', 'patient', elem.patientElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and (elem.serviced is TFhirPeriod) {6} then
    ComposePeriod(this, 'CoverageEligibilityRequest', 'servicedPeriod', TFhirPeriod(elem.serviced), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.serviced is TFhirDate) {6} then
    ComposeDate(this, 'CoverageEligibilityRequest', 'servicedDate', TFhirDate(elem.serviced), false, -1);{x.d9}
  ComposeDateTime(this, 'CoverageEligibilityRequest', 'created', elem.createdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('enterer') then
    ComposeReference{TFhirPractitioner}(this, 'CoverageEligibilityRequest', 'enterer', elem.entererElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('provider') then
    ComposeReference{TFhirPractitioner}(this, 'CoverageEligibilityRequest', 'provider', elem.providerElement, false, -1);{x.2f}
  ComposeReference{TFhirOrganization}(this, 'CoverageEligibilityRequest', 'insurer', elem.insurerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('facility') then
    ComposeReference{TFhirLocation}(this, 'CoverageEligibilityRequest', 'facility', elem.facilityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('supportingInfo') then
    for i := 0 to elem.supportingInfoList.Count - 1 do
      ComposeCoverageEligibilityRequestSupportingInfo(this, 'CoverageEligibilityRequest', 'supportingInfo', elem.supportingInfoList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('insurance') then
    for i := 0 to elem.insuranceList.Count - 1 do
      ComposeCoverageEligibilityRequestInsurance(this, 'CoverageEligibilityRequest', 'insurance', elem.insuranceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('item') then
    for i := 0 to elem.itemList.Count - 1 do
      ComposeCoverageEligibilityRequestItem(this, 'CoverageEligibilityRequest', 'item', elem.itemList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_COVERAGEELIGIBILITYREQUEST}
{$IFDEF FHIR_COVERAGEELIGIBILITYRESPONSE}
function TFHIRTurtleParser.ParseCoverageEligibilityResponseInsurance(obj : TTurtleComplex) : TFhirCoverageEligibilityResponseInsurance;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCoverageEligibilityResponseInsurance.create;
  try
    ParseCoverageEligibilityResponseInsuranceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCoverageEligibilityResponseInsuranceProperties(obj : TTurtleComplex; result : TFhirCoverageEligibilityResponseInsurance);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.coverage := ParseReference{TFhirCoverage}(obj.complex('http://hl7.org/fhir/CoverageEligibilityResponse.insurance.coverage'));{q3b}
    result.inforceElement := ParseBoolean(obj.complex('http://hl7.org/fhir/CoverageEligibilityResponse.insurance.inforce'));{q1}
    result.benefitPeriod := ParsePeriod(obj.complex('http://hl7.org/fhir/CoverageEligibilityResponse.insurance.benefitPeriod'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/CoverageEligibilityResponse.insurance.item') do
      result.itemList.Add(parseCoverageEligibilityResponseInsuranceItem(item));
end;

procedure TFHIRTurtleComposer.ComposeCoverageEligibilityResponseInsurance(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCoverageEligibilityResponseInsurance; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CoverageEligibilityResponseInsurance'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeReference{TFhirCoverage}(this, 'CoverageEligibilityResponse.insurance', 'coverage', elem.coverageElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'CoverageEligibilityResponse.insurance', 'inforce', elem.inforceElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'CoverageEligibilityResponse.insurance', 'benefitPeriod', elem.benefitPeriodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.itemList.Count - 1 do
      ComposeCoverageEligibilityResponseInsuranceItem(this, 'CoverageEligibilityResponse.insurance', 'item', elem.itemList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseCoverageEligibilityResponseInsuranceItem(obj : TTurtleComplex) : TFhirCoverageEligibilityResponseInsuranceItem;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCoverageEligibilityResponseInsuranceItem.create;
  try
    ParseCoverageEligibilityResponseInsuranceItemProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCoverageEligibilityResponseInsuranceItemProperties(obj : TTurtleComplex; result : TFhirCoverageEligibilityResponseInsuranceItem);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/CoverageEligibilityResponse.insurance.item.category'));{q3b}
    result.productOrService := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/CoverageEligibilityResponse.insurance.item.productOrService'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/CoverageEligibilityResponse.insurance.item.modifier') do
      result.modifierList.Add(parseCodeableConcept(item));
    result.provider := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/CoverageEligibilityResponse.insurance.item.provider'));{q3b}
    result.excludedElement := ParseBoolean(obj.complex('http://hl7.org/fhir/CoverageEligibilityResponse.insurance.item.excluded'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/CoverageEligibilityResponse.insurance.item.name'));{q1}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/CoverageEligibilityResponse.insurance.item.description'));{q1}
    result.network := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/CoverageEligibilityResponse.insurance.item.network'));{q3b}
    result.unit_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/CoverageEligibilityResponse.insurance.item.unit'));{q3b}
    result.term := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/CoverageEligibilityResponse.insurance.item.term'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/CoverageEligibilityResponse.insurance.item.benefit') do
      result.benefitList.Add(parseCoverageEligibilityResponseInsuranceItemBenefit(item));
    result.authorizationRequiredElement := ParseBoolean(obj.complex('http://hl7.org/fhir/CoverageEligibilityResponse.insurance.item.authorizationRequired'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/CoverageEligibilityResponse.insurance.item.authorizationSupporting') do
      result.authorizationSupportingList.Add(parseCodeableConcept(item));
    result.authorizationUrlElement := ParseUri(obj.complex('http://hl7.org/fhir/CoverageEligibilityResponse.insurance.item.authorizationUrl'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeCoverageEligibilityResponseInsuranceItem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCoverageEligibilityResponseInsuranceItem; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CoverageEligibilityResponseInsuranceItem'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'CoverageEligibilityResponse.insurance.item', 'category', elem.categoryElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'CoverageEligibilityResponse.insurance.item', 'productOrService', elem.productOrServiceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.modifierList.Count - 1 do
      ComposeCodeableConcept(this, 'CoverageEligibilityResponse.insurance.item', 'modifier', elem.modifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirPractitioner}(this, 'CoverageEligibilityResponse.insurance.item', 'provider', elem.providerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'CoverageEligibilityResponse.insurance.item', 'excluded', elem.excludedElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'CoverageEligibilityResponse.insurance.item', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'CoverageEligibilityResponse.insurance.item', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'CoverageEligibilityResponse.insurance.item', 'network', elem.networkElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'CoverageEligibilityResponse.insurance.item', 'unit', elem.unit_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'CoverageEligibilityResponse.insurance.item', 'term', elem.termElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.benefitList.Count - 1 do
      ComposeCoverageEligibilityResponseInsuranceItemBenefit(this, 'CoverageEligibilityResponse.insurance.item', 'benefit', elem.benefitList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'CoverageEligibilityResponse.insurance.item', 'authorizationRequired', elem.authorizationRequiredElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.authorizationSupportingList.Count - 1 do
      ComposeCodeableConcept(this, 'CoverageEligibilityResponse.insurance.item', 'authorizationSupporting', elem.authorizationSupportingList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'CoverageEligibilityResponse.insurance.item', 'authorizationUrl', elem.authorizationUrlElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseCoverageEligibilityResponseInsuranceItemBenefit(obj : TTurtleComplex) : TFhirCoverageEligibilityResponseInsuranceItemBenefit;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCoverageEligibilityResponseInsuranceItemBenefit.create;
  try
    ParseCoverageEligibilityResponseInsuranceItemBenefitProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCoverageEligibilityResponseInsuranceItemBenefitProperties(obj : TTurtleComplex; result : TFhirCoverageEligibilityResponseInsuranceItemBenefit);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/CoverageEligibilityResponse.insurance.item.benefit.type'));{q3b}
    if obj.has('http://hl7.org/fhir/CoverageEligibilityResponse.insurance.item.benefit.allowedUnsignedInt', item) then
      result.allowed := parseUnsignedInt(item);
    if obj.has('http://hl7.org/fhir/CoverageEligibilityResponse.insurance.item.benefit.allowedMoney', item) then
      result.allowed := parseMoney(item);
    if obj.has('http://hl7.org/fhir/CoverageEligibilityResponse.insurance.item.benefit.allowedString', item) then
      result.allowed := parseString(item);
    if obj.has('http://hl7.org/fhir/CoverageEligibilityResponse.insurance.item.benefit.usedUnsignedInt', item) then
      result.used := parseUnsignedInt(item);
    if obj.has('http://hl7.org/fhir/CoverageEligibilityResponse.insurance.item.benefit.usedMoney', item) then
      result.used := parseMoney(item);
    if obj.has('http://hl7.org/fhir/CoverageEligibilityResponse.insurance.item.benefit.usedString', item) then
      result.used := parseString(item);
end;

procedure TFHIRTurtleComposer.ComposeCoverageEligibilityResponseInsuranceItemBenefit(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCoverageEligibilityResponseInsuranceItemBenefit; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CoverageEligibilityResponseInsuranceItemBenefit'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'CoverageEligibilityResponse.insurance.item.benefit', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and (elem.allowed is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(this, 'CoverageEligibilityResponse.insurance.item.benefit', 'allowedUnsignedInt', TFhirUnsignedInt(elem.allowed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.allowed is TFhirMoney) {6} then
    ComposeMoney(this, 'CoverageEligibilityResponse.insurance.item.benefit', 'allowedMoney', TFhirMoney(elem.allowed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.allowed is TFhirString) {6} then
    ComposeString(this, 'CoverageEligibilityResponse.insurance.item.benefit', 'allowedString', TFhirString(elem.allowed), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) and (elem.used is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(this, 'CoverageEligibilityResponse.insurance.item.benefit', 'usedUnsignedInt', TFhirUnsignedInt(elem.used), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.used is TFhirMoney) {6} then
    ComposeMoney(this, 'CoverageEligibilityResponse.insurance.item.benefit', 'usedMoney', TFhirMoney(elem.used), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.used is TFhirString) {6} then
    ComposeString(this, 'CoverageEligibilityResponse.insurance.item.benefit', 'usedString', TFhirString(elem.used), false, -1);{x.d9}
end;

function TFHIRTurtleParser.ParseCoverageEligibilityResponseError(obj : TTurtleComplex) : TFhirCoverageEligibilityResponseError;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCoverageEligibilityResponseError.create;
  try
    ParseCoverageEligibilityResponseErrorProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCoverageEligibilityResponseErrorProperties(obj : TTurtleComplex; result : TFhirCoverageEligibilityResponseError);
begin
    ParseBackboneElementProperties(obj, result);
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/CoverageEligibilityResponse.error.code'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeCoverageEligibilityResponseError(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCoverageEligibilityResponseError; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CoverageEligibilityResponseError'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'CoverageEligibilityResponse.error', 'code', elem.codeElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseCoverageEligibilityResponse(obj : TTurtleComplex) : TFhirCoverageEligibilityResponse;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirCoverageEligibilityResponse.create;
  try
    ParseCoverageEligibilityResponseProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseCoverageEligibilityResponseProperties(obj : TTurtleComplex; result : TFhirCoverageEligibilityResponse);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/CoverageEligibilityResponse.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/CoverageEligibilityResponse.status'), CODES_TFhirFmStatusEnum, SYSTEMS_TFhirFmStatusEnum);
    for item in obj.complexes('http://hl7.org/fhir/CoverageEligibilityResponse.purpose') do
      result.purposeList.Add(parseEnum(item, CODES_TFhirEligibilityresponsePurposeEnum, SYSTEMS_TFhirEligibilityresponsePurposeEnum));
    result.patient := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/CoverageEligibilityResponse.patient'));{q3b}
    if obj.has('http://hl7.org/fhir/CoverageEligibilityResponse.servicedPeriod', item) then
      result.serviced := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/CoverageEligibilityResponse.servicedDate', item) then
      result.serviced := parseDate(item);
    result.createdElement := ParseDateTime(obj.complex('http://hl7.org/fhir/CoverageEligibilityResponse.created'));{q1}
    result.requestor := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/CoverageEligibilityResponse.requestor'));{q3b}
    result.request := ParseReference{TFhirCoverageEligibilityRequest}(obj.complex('http://hl7.org/fhir/CoverageEligibilityResponse.request'));{q3b}
    result.outcomeElement := ParseEnum(obj.complex('http://hl7.org/fhir/CoverageEligibilityResponse.outcome'), CODES_TFhirRemittanceOutcomeEnum, SYSTEMS_TFhirRemittanceOutcomeEnum);
    result.dispositionElement := ParseString(obj.complex('http://hl7.org/fhir/CoverageEligibilityResponse.disposition'));{q1}
    result.insurer := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/CoverageEligibilityResponse.insurer'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/CoverageEligibilityResponse.insurance') do
      result.insuranceList.Add(parseCoverageEligibilityResponseInsurance(item));
    result.preAuthRefElement := ParseString(obj.complex('http://hl7.org/fhir/CoverageEligibilityResponse.preAuthRef'));{q1}
    result.form := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/CoverageEligibilityResponse.form'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/CoverageEligibilityResponse.error') do
      result.errorList.Add(parseCoverageEligibilityResponseError(item));
end;

procedure TFHIRTurtleComposer.ComposeCoverageEligibilityResponse(parent :  TTurtleComplex; parentType, name : String; elem : TFhirCoverageEligibilityResponse; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:CoverageEligibilityResponse'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'CoverageEligibilityResponse', 'identifier', elem.identifierList[i], false, i);{x.d3}
  ComposeEnum(this, 'CoverageEligibilityResponse', 'status', elem.StatusElement, CODES_TFhirFmStatusEnum, SYSTEMS_TFhirFmStatusEnum, false, -1);{x.d4}
  for i := 0 to elem.purposeList.Count - 1 do
      ComposeEnum(this, 'CoverageEligibilityResponse', 'purpose', elem.purposeList[i], CODES_TFhirEligibilityresponsePurposeEnum, SYSTEMS_TFhirEligibilityresponsePurposeEnum, false, i); {x.d1}
  for i := 0 to elem.purposeList.Count - 1 do
      ComposeEnum(this, 'CoverageEligibilityResponse', 'purpose', elem.purposeList[i], CODES_TFhirEligibilityresponsePurposeEnum, SYSTEMS_TFhirEligibilityresponsePurposeEnum, false, i);{x.d2}
  ComposeReference{TFhirPatient}(this, 'CoverageEligibilityResponse', 'patient', elem.patientElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and (elem.serviced is TFhirPeriod) {6} then
    ComposePeriod(this, 'CoverageEligibilityResponse', 'servicedPeriod', TFhirPeriod(elem.serviced), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.serviced is TFhirDate) {6} then
    ComposeDate(this, 'CoverageEligibilityResponse', 'servicedDate', TFhirDate(elem.serviced), false, -1);{x.d9}
  ComposeDateTime(this, 'CoverageEligibilityResponse', 'created', elem.createdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('requestor') then
    ComposeReference{TFhirPractitioner}(this, 'CoverageEligibilityResponse', 'requestor', elem.requestorElement, false, -1);{x.2f}
  ComposeReference{TFhirCoverageEligibilityRequest}(this, 'CoverageEligibilityResponse', 'request', elem.requestElement, false, -1);{x.2f}
  ComposeEnum(this, 'CoverageEligibilityResponse', 'outcome', elem.OutcomeElement, CODES_TFhirRemittanceOutcomeEnum, SYSTEMS_TFhirRemittanceOutcomeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('disposition') then
    ComposeString(this, 'CoverageEligibilityResponse', 'disposition', elem.dispositionElement, false, -1);{x.2ea}
  ComposeReference{TFhirOrganization}(this, 'CoverageEligibilityResponse', 'insurer', elem.insurerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('insurance') then
    for i := 0 to elem.insuranceList.Count - 1 do
      ComposeCoverageEligibilityResponseInsurance(this, 'CoverageEligibilityResponse', 'insurance', elem.insuranceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('preAuthRef') then
    ComposeString(this, 'CoverageEligibilityResponse', 'preAuthRef', elem.preAuthRefElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('form') then
    ComposeCodeableConcept(this, 'CoverageEligibilityResponse', 'form', elem.formElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('error') then
    for i := 0 to elem.errorList.Count - 1 do
      ComposeCoverageEligibilityResponseError(this, 'CoverageEligibilityResponse', 'error', elem.errorList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_COVERAGEELIGIBILITYRESPONSE}
{$IFDEF FHIR_DETECTEDISSUE}
function TFHIRTurtleParser.ParseDetectedIssueEvidence(obj : TTurtleComplex) : TFhirDetectedIssueEvidence;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDetectedIssueEvidence.create;
  try
    ParseDetectedIssueEvidenceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDetectedIssueEvidenceProperties(obj : TTurtleComplex; result : TFhirDetectedIssueEvidence);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/DetectedIssue.evidence.code') do
      result.codeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/DetectedIssue.evidence.detail') do
      result.detailList.Add(parseReference{TFhirReference}(item));
end;

procedure TFHIRTurtleComposer.ComposeDetectedIssueEvidence(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDetectedIssueEvidence; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DetectedIssueEvidence'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.codeList.Count - 1 do
      ComposeCodeableConcept(this, 'DetectedIssue.evidence', 'code', elem.codeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.detailList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'DetectedIssue.evidence', 'detail', elem.detailList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseDetectedIssueMitigation(obj : TTurtleComplex) : TFhirDetectedIssueMitigation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDetectedIssueMitigation.create;
  try
    ParseDetectedIssueMitigationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDetectedIssueMitigationProperties(obj : TTurtleComplex; result : TFhirDetectedIssueMitigation);
begin
    ParseBackboneElementProperties(obj, result);
    result.action := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DetectedIssue.mitigation.action'));{q3b}
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/DetectedIssue.mitigation.date'));{q1}
    result.author := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/DetectedIssue.mitigation.author'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeDetectedIssueMitigation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDetectedIssueMitigation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DetectedIssueMitigation'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'DetectedIssue.mitigation', 'action', elem.actionElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'DetectedIssue.mitigation', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirPractitioner}(this, 'DetectedIssue.mitigation', 'author', elem.authorElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseDetectedIssue(obj : TTurtleComplex) : TFhirDetectedIssue;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDetectedIssue.create;
  try
    ParseDetectedIssueProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDetectedIssueProperties(obj : TTurtleComplex; result : TFhirDetectedIssue);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/DetectedIssue.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/DetectedIssue.status'), CODES_TFhirObservationStatusEnum, SYSTEMS_TFhirObservationStatusEnum);
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DetectedIssue.code'));{q3b}
    result.severityElement := ParseEnum(obj.complex('http://hl7.org/fhir/DetectedIssue.severity'), CODES_TFhirDetectedissueSeverityEnum, SYSTEMS_TFhirDetectedissueSeverityEnum);
    result.patient := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/DetectedIssue.patient'));{q3b}
    if obj.has('http://hl7.org/fhir/DetectedIssue.identifiedPeriod', item) then
      result.identified := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/DetectedIssue.identifiedDateTime', item) then
      result.identified := parseDateTime(item);
    result.author := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/DetectedIssue.author'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/DetectedIssue.implicated') do
      result.implicatedList.Add(parseReference{TFhirReference}(item));
    for item in obj.complexes('http://hl7.org/fhir/DetectedIssue.evidence') do
      result.evidenceList.Add(parseDetectedIssueEvidence(item));
    result.detailElement := ParseString(obj.complex('http://hl7.org/fhir/DetectedIssue.detail'));{q1}
    result.referenceElement := ParseUri(obj.complex('http://hl7.org/fhir/DetectedIssue.reference'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/DetectedIssue.mitigation') do
      result.mitigationList.Add(parseDetectedIssueMitigation(item));
end;

procedure TFHIRTurtleComposer.ComposeDetectedIssue(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDetectedIssue; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DetectedIssue'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'DetectedIssue', 'identifier', elem.identifierList[i], false, i);{x.d3}
  ComposeEnum(this, 'DetectedIssue', 'status', elem.StatusElement, CODES_TFhirObservationStatusEnum, SYSTEMS_TFhirObservationStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') then
    ComposeCodeableConcept(this, 'DetectedIssue', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('severity') then
    ComposeEnum(this, 'DetectedIssue', 'severity', elem.SeverityElement, CODES_TFhirDetectedissueSeverityEnum, SYSTEMS_TFhirDetectedissueSeverityEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('patient') then
    ComposeReference{TFhirPatient}(this, 'DetectedIssue', 'patient', elem.patientElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.identified is TFhirPeriod) {6} then
    ComposePeriod(this, 'DetectedIssue', 'identifiedPeriod', TFhirPeriod(elem.identified), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.identified is TFhirDateTime) {6} then
    ComposeDateTime(this, 'DetectedIssue', 'identifiedDateTime', TFhirDateTime(elem.identified), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('author') then
    ComposeReference{TFhirPractitioner}(this, 'DetectedIssue', 'author', elem.authorElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('implicated') then
    for i := 0 to elem.implicatedList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'DetectedIssue', 'implicated', elem.implicatedList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('evidence') then
    for i := 0 to elem.evidenceList.Count - 1 do
      ComposeDetectedIssueEvidence(this, 'DetectedIssue', 'evidence', elem.evidenceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('detail') then
    ComposeString(this, 'DetectedIssue', 'detail', elem.detailElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('reference') then
    ComposeUri(this, 'DetectedIssue', 'reference', elem.referenceElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('mitigation') then
    for i := 0 to elem.mitigationList.Count - 1 do
      ComposeDetectedIssueMitigation(this, 'DetectedIssue', 'mitigation', elem.mitigationList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_DETECTEDISSUE}
{$IFDEF FHIR_DEVICE}
function TFHIRTurtleParser.ParseDeviceUdiCarrier(obj : TTurtleComplex) : TFhirDeviceUdiCarrier;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDeviceUdiCarrier.create;
  try
    ParseDeviceUdiCarrierProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDeviceUdiCarrierProperties(obj : TTurtleComplex; result : TFhirDeviceUdiCarrier);
begin
    ParseBackboneElementProperties(obj, result);
    result.deviceIdentifierElement := ParseString(obj.complex('http://hl7.org/fhir/Device.udiCarrier.deviceIdentifier'));{q1}
    result.issuerElement := ParseUri(obj.complex('http://hl7.org/fhir/Device.udiCarrier.issuer'));{q1}
    result.jurisdictionElement := ParseUri(obj.complex('http://hl7.org/fhir/Device.udiCarrier.jurisdiction'));{q1}
    result.carrierAIDCElement := ParseBase64Binary(obj.complex('http://hl7.org/fhir/Device.udiCarrier.carrierAIDC'));{q1}
    result.carrierHRFElement := ParseString(obj.complex('http://hl7.org/fhir/Device.udiCarrier.carrierHRF'));{q1}
    result.entryTypeElement := ParseEnum(obj.complex('http://hl7.org/fhir/Device.udiCarrier.entryType'), CODES_TFhirUdiEntryTypeEnum, SYSTEMS_TFhirUdiEntryTypeEnum);
end;

procedure TFHIRTurtleComposer.ComposeDeviceUdiCarrier(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDeviceUdiCarrier; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DeviceUdiCarrier'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Device.udiCarrier', 'deviceIdentifier', elem.deviceIdentifierElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'Device.udiCarrier', 'issuer', elem.issuerElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'Device.udiCarrier', 'jurisdiction', elem.jurisdictionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBase64Binary(this, 'Device.udiCarrier', 'carrierAIDC', elem.carrierAIDCElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'Device.udiCarrier', 'carrierHRF', elem.carrierHRFElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'Device.udiCarrier', 'entryType', elem.EntryTypeElement, CODES_TFhirUdiEntryTypeEnum, SYSTEMS_TFhirUdiEntryTypeEnum, false, -1);{x.d4}
end;

function TFHIRTurtleParser.ParseDeviceDeviceName(obj : TTurtleComplex) : TFhirDeviceDeviceName;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDeviceDeviceName.create;
  try
    ParseDeviceDeviceNameProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDeviceDeviceNameProperties(obj : TTurtleComplex; result : TFhirDeviceDeviceName);
begin
    ParseBackboneElementProperties(obj, result);
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/Device.deviceName.name'));{q1}
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/Device.deviceName.type'), CODES_TFhirDeviceNametypeEnum, SYSTEMS_TFhirDeviceNametypeEnum);
end;

procedure TFHIRTurtleComposer.ComposeDeviceDeviceName(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDeviceDeviceName; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DeviceDeviceName'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeString(this, 'Device.deviceName', 'name', elem.nameElement, false, -1);{x.2ea}
  ComposeEnum(this, 'Device.deviceName', 'type', elem.Type_Element, CODES_TFhirDeviceNametypeEnum, SYSTEMS_TFhirDeviceNametypeEnum, false, -1);{x.d4}
end;

function TFHIRTurtleParser.ParseDeviceSpecialization(obj : TTurtleComplex) : TFhirDeviceSpecialization;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDeviceSpecialization.create;
  try
    ParseDeviceSpecializationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDeviceSpecializationProperties(obj : TTurtleComplex; result : TFhirDeviceSpecialization);
begin
    ParseBackboneElementProperties(obj, result);
    result.systemType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Device.specialization.systemType'));{q3b}
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/Device.specialization.version'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeDeviceSpecialization(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDeviceSpecialization; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DeviceSpecialization'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'Device.specialization', 'systemType', elem.systemTypeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Device.specialization', 'version', elem.versionElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseDeviceVersion(obj : TTurtleComplex) : TFhirDeviceVersion;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDeviceVersion.create;
  try
    ParseDeviceVersionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDeviceVersionProperties(obj : TTurtleComplex; result : TFhirDeviceVersion);
begin
    ParseBackboneElementProperties(obj, result);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Device.version.type'));{q3b}
    result.component := ParseIdentifier(obj.complex('http://hl7.org/fhir/Device.version.component'));{q3b}
    result.valueElement := ParseString(obj.complex('http://hl7.org/fhir/Device.version.value'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeDeviceVersion(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDeviceVersion; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DeviceVersion'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Device.version', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(this, 'Device.version', 'component', elem.componentElement, false, -1);{x.2f}
  ComposeString(this, 'Device.version', 'value', elem.valueElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseDeviceProperty(obj : TTurtleComplex) : TFhirDeviceProperty;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDeviceProperty.create;
  try
    ParseDevicePropertyProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDevicePropertyProperties(obj : TTurtleComplex; result : TFhirDeviceProperty);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Device.property.type'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Device.property.valueQuantity') do
      result.valueQuantityList.Add(parseQuantity(item));
    for item in obj.complexes('http://hl7.org/fhir/Device.property.valueCode') do
      result.valueCodeList.Add(parseCodeableConcept(item));
end;

procedure TFHIRTurtleComposer.ComposeDeviceProperty(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDeviceProperty; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DeviceProperty'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'Device.property', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.valueQuantityList.Count - 1 do
      ComposeQuantity(this, 'Device.property', 'valueQuantity', elem.valueQuantityList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.valueCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'Device.property', 'valueCode', elem.valueCodeList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseDevice(obj : TTurtleComplex) : TFhirDevice;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDevice.create;
  try
    ParseDeviceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDeviceProperties(obj : TTurtleComplex; result : TFhirDevice);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Device.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.definition := ParseReference{TFhirDeviceDefinition}(obj.complex('http://hl7.org/fhir/Device.definition'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Device.udiCarrier') do
      result.udiCarrierList.Add(parseDeviceUdiCarrier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Device.status'), CODES_TFhirDeviceStatusEnum, SYSTEMS_TFhirDeviceStatusEnum);
    for item in obj.complexes('http://hl7.org/fhir/Device.statusReason') do
      result.statusReasonList.Add(parseCodeableConcept(item));
    result.distinctIdentifierElement := ParseString(obj.complex('http://hl7.org/fhir/Device.distinctIdentifier'));{q1}
    result.manufacturerElement := ParseString(obj.complex('http://hl7.org/fhir/Device.manufacturer'));{q1}
    result.manufactureDateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Device.manufactureDate'));{q1}
    result.expirationDateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Device.expirationDate'));{q1}
    result.lotNumberElement := ParseString(obj.complex('http://hl7.org/fhir/Device.lotNumber'));{q1}
    result.serialNumberElement := ParseString(obj.complex('http://hl7.org/fhir/Device.serialNumber'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Device.deviceName') do
      result.deviceNameList.Add(parseDeviceDeviceName(item));
    result.modelNumberElement := ParseString(obj.complex('http://hl7.org/fhir/Device.modelNumber'));{q1}
    result.partNumberElement := ParseString(obj.complex('http://hl7.org/fhir/Device.partNumber'));{q1}
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Device.type'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Device.specialization') do
      result.specializationList.Add(parseDeviceSpecialization(item));
    for item in obj.complexes('http://hl7.org/fhir/Device.version') do
      result.versionList.Add(parseDeviceVersion(item));
    for item in obj.complexes('http://hl7.org/fhir/Device.property') do
      result.property_List.Add(parseDeviceProperty(item));
    result.patient := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/Device.patient'));{q3b}
    result.owner := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/Device.owner'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Device.contact') do
      result.contactList.Add(parseContactPoint(item));
    result.location := ParseReference{TFhirLocation}(obj.complex('http://hl7.org/fhir/Device.location'));{q3b}
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/Device.url'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Device.note') do
      result.noteList.Add(parseAnnotation(item));
    for item in obj.complexes('http://hl7.org/fhir/Device.safety') do
      result.safetyList.Add(parseCodeableConcept(item));
    result.parent := ParseReference{TFhirDevice}(obj.complex('http://hl7.org/fhir/Device.parent'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeDevice(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDevice; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Device'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Device', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('definition') then
    ComposeReference{TFhirDeviceDefinition}(this, 'Device', 'definition', elem.definitionElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('udiCarrier') then
    for i := 0 to elem.udiCarrierList.Count - 1 do
      ComposeDeviceUdiCarrier(this, 'Device', 'udiCarrier', elem.udiCarrierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(this, 'Device', 'status', elem.StatusElement, CODES_TFhirDeviceStatusEnum, SYSTEMS_TFhirDeviceStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('statusReason') then
    for i := 0 to elem.statusReasonList.Count - 1 do
      ComposeCodeableConcept(this, 'Device', 'statusReason', elem.statusReasonList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('distinctIdentifier') then
    ComposeString(this, 'Device', 'distinctIdentifier', elem.distinctIdentifierElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('manufacturer') then
    ComposeString(this, 'Device', 'manufacturer', elem.manufacturerElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('manufactureDate') then
    ComposeDateTime(this, 'Device', 'manufactureDate', elem.manufactureDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('expirationDate') then
    ComposeDateTime(this, 'Device', 'expirationDate', elem.expirationDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('lotNumber') then
    ComposeString(this, 'Device', 'lotNumber', elem.lotNumberElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('serialNumber') then
    ComposeString(this, 'Device', 'serialNumber', elem.serialNumberElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('deviceName') then
    for i := 0 to elem.deviceNameList.Count - 1 do
      ComposeDeviceDeviceName(this, 'Device', 'deviceName', elem.deviceNameList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('modelNumber') then
    ComposeString(this, 'Device', 'modelNumber', elem.modelNumberElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('partNumber') then
    ComposeString(this, 'Device', 'partNumber', elem.partNumberElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('type_') then
    ComposeCodeableConcept(this, 'Device', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('specialization') then
    for i := 0 to elem.specializationList.Count - 1 do
      ComposeDeviceSpecialization(this, 'Device', 'specialization', elem.specializationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('version') then
    for i := 0 to elem.versionList.Count - 1 do
      ComposeDeviceVersion(this, 'Device', 'version', elem.versionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('property_') then
    for i := 0 to elem.property_List.Count - 1 do
      ComposeDeviceProperty(this, 'Device', 'property', elem.property_List[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('patient') then
    ComposeReference{TFhirPatient}(this, 'Device', 'patient', elem.patientElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('owner') then
    ComposeReference{TFhirOrganization}(this, 'Device', 'owner', elem.ownerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactPoint(this, 'Device', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('location') then
    ComposeReference{TFhirLocation}(this, 'Device', 'location', elem.locationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('url') then
    ComposeUri(this, 'Device', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'Device', 'note', elem.noteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('safety') then
    for i := 0 to elem.safetyList.Count - 1 do
      ComposeCodeableConcept(this, 'Device', 'safety', elem.safetyList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('parent') then
    ComposeReference{TFhirDevice}(this, 'Device', 'parent', elem.parentElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_DEVICE}
{$IFDEF FHIR_DEVICEDEFINITION}
function TFHIRTurtleParser.ParseDeviceDefinitionUdiDeviceIdentifier(obj : TTurtleComplex) : TFhirDeviceDefinitionUdiDeviceIdentifier;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDeviceDefinitionUdiDeviceIdentifier.create;
  try
    ParseDeviceDefinitionUdiDeviceIdentifierProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDeviceDefinitionUdiDeviceIdentifierProperties(obj : TTurtleComplex; result : TFhirDeviceDefinitionUdiDeviceIdentifier);
begin
    ParseBackboneElementProperties(obj, result);
    result.deviceIdentifierElement := ParseString(obj.complex('http://hl7.org/fhir/DeviceDefinition.udiDeviceIdentifier.deviceIdentifier'));{q1}
    result.issuerElement := ParseUri(obj.complex('http://hl7.org/fhir/DeviceDefinition.udiDeviceIdentifier.issuer'));{q1}
    result.jurisdictionElement := ParseUri(obj.complex('http://hl7.org/fhir/DeviceDefinition.udiDeviceIdentifier.jurisdiction'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeDeviceDefinitionUdiDeviceIdentifier(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDeviceDefinitionUdiDeviceIdentifier; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DeviceDefinitionUdiDeviceIdentifier'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeString(this, 'DeviceDefinition.udiDeviceIdentifier', 'deviceIdentifier', elem.deviceIdentifierElement, false, -1);{x.2ea}
  ComposeUri(this, 'DeviceDefinition.udiDeviceIdentifier', 'issuer', elem.issuerElement, false, -1);{x.2ea}
  ComposeUri(this, 'DeviceDefinition.udiDeviceIdentifier', 'jurisdiction', elem.jurisdictionElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseDeviceDefinitionDeviceName(obj : TTurtleComplex) : TFhirDeviceDefinitionDeviceName;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDeviceDefinitionDeviceName.create;
  try
    ParseDeviceDefinitionDeviceNameProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDeviceDefinitionDeviceNameProperties(obj : TTurtleComplex; result : TFhirDeviceDefinitionDeviceName);
begin
    ParseBackboneElementProperties(obj, result);
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/DeviceDefinition.deviceName.name'));{q1}
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/DeviceDefinition.deviceName.type'), CODES_TFhirDeviceNametypeEnum, SYSTEMS_TFhirDeviceNametypeEnum);
end;

procedure TFHIRTurtleComposer.ComposeDeviceDefinitionDeviceName(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDeviceDefinitionDeviceName; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DeviceDefinitionDeviceName'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeString(this, 'DeviceDefinition.deviceName', 'name', elem.nameElement, false, -1);{x.2ea}
  ComposeEnum(this, 'DeviceDefinition.deviceName', 'type', elem.Type_Element, CODES_TFhirDeviceNametypeEnum, SYSTEMS_TFhirDeviceNametypeEnum, false, -1);{x.d4}
end;

function TFHIRTurtleParser.ParseDeviceDefinitionSpecialization(obj : TTurtleComplex) : TFhirDeviceDefinitionSpecialization;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDeviceDefinitionSpecialization.create;
  try
    ParseDeviceDefinitionSpecializationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDeviceDefinitionSpecializationProperties(obj : TTurtleComplex; result : TFhirDeviceDefinitionSpecialization);
begin
    ParseBackboneElementProperties(obj, result);
    result.systemTypeElement := ParseString(obj.complex('http://hl7.org/fhir/DeviceDefinition.specialization.systemType'));{q1}
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/DeviceDefinition.specialization.version'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeDeviceDefinitionSpecialization(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDeviceDefinitionSpecialization; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DeviceDefinitionSpecialization'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeString(this, 'DeviceDefinition.specialization', 'systemType', elem.systemTypeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'DeviceDefinition.specialization', 'version', elem.versionElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseDeviceDefinitionCapability(obj : TTurtleComplex) : TFhirDeviceDefinitionCapability;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDeviceDefinitionCapability.create;
  try
    ParseDeviceDefinitionCapabilityProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDeviceDefinitionCapabilityProperties(obj : TTurtleComplex; result : TFhirDeviceDefinitionCapability);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DeviceDefinition.capability.type'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/DeviceDefinition.capability.description') do
      result.descriptionList.Add(parseCodeableConcept(item));
end;

procedure TFHIRTurtleComposer.ComposeDeviceDefinitionCapability(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDeviceDefinitionCapability; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DeviceDefinitionCapability'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'DeviceDefinition.capability', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.descriptionList.Count - 1 do
      ComposeCodeableConcept(this, 'DeviceDefinition.capability', 'description', elem.descriptionList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseDeviceDefinitionProperty(obj : TTurtleComplex) : TFhirDeviceDefinitionProperty;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDeviceDefinitionProperty.create;
  try
    ParseDeviceDefinitionPropertyProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDeviceDefinitionPropertyProperties(obj : TTurtleComplex; result : TFhirDeviceDefinitionProperty);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DeviceDefinition.property.type'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/DeviceDefinition.property.valueQuantity') do
      result.valueQuantityList.Add(parseQuantity(item));
    for item in obj.complexes('http://hl7.org/fhir/DeviceDefinition.property.valueCode') do
      result.valueCodeList.Add(parseCodeableConcept(item));
end;

procedure TFHIRTurtleComposer.ComposeDeviceDefinitionProperty(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDeviceDefinitionProperty; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DeviceDefinitionProperty'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'DeviceDefinition.property', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.valueQuantityList.Count - 1 do
      ComposeQuantity(this, 'DeviceDefinition.property', 'valueQuantity', elem.valueQuantityList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.valueCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'DeviceDefinition.property', 'valueCode', elem.valueCodeList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseDeviceDefinitionMaterial(obj : TTurtleComplex) : TFhirDeviceDefinitionMaterial;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDeviceDefinitionMaterial.create;
  try
    ParseDeviceDefinitionMaterialProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDeviceDefinitionMaterialProperties(obj : TTurtleComplex; result : TFhirDeviceDefinitionMaterial);
begin
    ParseBackboneElementProperties(obj, result);
    result.substance := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DeviceDefinition.material.substance'));{q3b}
    result.alternateElement := ParseBoolean(obj.complex('http://hl7.org/fhir/DeviceDefinition.material.alternate'));{q1}
    result.allergenicIndicatorElement := ParseBoolean(obj.complex('http://hl7.org/fhir/DeviceDefinition.material.allergenicIndicator'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeDeviceDefinitionMaterial(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDeviceDefinitionMaterial; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DeviceDefinitionMaterial'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'DeviceDefinition.material', 'substance', elem.substanceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'DeviceDefinition.material', 'alternate', elem.alternateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'DeviceDefinition.material', 'allergenicIndicator', elem.allergenicIndicatorElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseDeviceDefinition(obj : TTurtleComplex) : TFhirDeviceDefinition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDeviceDefinition.create;
  try
    ParseDeviceDefinitionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDeviceDefinitionProperties(obj : TTurtleComplex; result : TFhirDeviceDefinition);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/DeviceDefinition.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/DeviceDefinition.udiDeviceIdentifier') do
      result.udiDeviceIdentifierList.Add(parseDeviceDefinitionUdiDeviceIdentifier(item));
    if obj.has('http://hl7.org/fhir/DeviceDefinition.manufacturerReference', item) {a3} then
      result.manufacturer := ParseReference(item);
    if obj.has('http://hl7.org/fhir/DeviceDefinition.manufacturerString', item) then
      result.manufacturer := parseString(item);
    for item in obj.complexes('http://hl7.org/fhir/DeviceDefinition.deviceName') do
      result.deviceNameList.Add(parseDeviceDefinitionDeviceName(item));
    result.modelNumberElement := ParseString(obj.complex('http://hl7.org/fhir/DeviceDefinition.modelNumber'));{q1}
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DeviceDefinition.type'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/DeviceDefinition.specialization') do
      result.specializationList.Add(parseDeviceDefinitionSpecialization(item));
    for item in obj.complexes('http://hl7.org/fhir/DeviceDefinition.version') do
      result.versionList.Add(parseString(item));
    for item in obj.complexes('http://hl7.org/fhir/DeviceDefinition.safety') do
      result.safetyList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/DeviceDefinition.shelfLifeStorage') do
      result.shelfLifeStorageList.Add(parseProductShelfLife(item));
    result.physicalCharacteristics := ParseProdCharacteristic(obj.complex('http://hl7.org/fhir/DeviceDefinition.physicalCharacteristics'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/DeviceDefinition.languageCode') do
      result.languageCodeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/DeviceDefinition.capability') do
      result.capabilityList.Add(parseDeviceDefinitionCapability(item));
    for item in obj.complexes('http://hl7.org/fhir/DeviceDefinition.property') do
      result.property_List.Add(parseDeviceDefinitionProperty(item));
    result.owner := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/DeviceDefinition.owner'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/DeviceDefinition.contact') do
      result.contactList.Add(parseContactPoint(item));
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/DeviceDefinition.url'));{q1}
    result.onlineInformationElement := ParseUri(obj.complex('http://hl7.org/fhir/DeviceDefinition.onlineInformation'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/DeviceDefinition.note') do
      result.noteList.Add(parseAnnotation(item));
    result.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/DeviceDefinition.quantity'));{q3b}
    result.parentDevice := ParseReference{TFhirDeviceDefinition}(obj.complex('http://hl7.org/fhir/DeviceDefinition.parentDevice'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/DeviceDefinition.material') do
      result.materialList.Add(parseDeviceDefinitionMaterial(item));
end;

procedure TFHIRTurtleComposer.ComposeDeviceDefinition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDeviceDefinition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DeviceDefinition'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'DeviceDefinition', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('udiDeviceIdentifier') then
    for i := 0 to elem.udiDeviceIdentifierList.Count - 1 do
      ComposeDeviceDefinitionUdiDeviceIdentifier(this, 'DeviceDefinition', 'udiDeviceIdentifier', elem.udiDeviceIdentifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and (elem.manufacturer is TFhirReference) {2} then
    ComposeReference(this, 'DeviceDefinition', 'manufacturerReference', TFhirReference(elem.manufacturer), false,-1){x.d8}
  else if (SummaryOption in [soFull, soData]) and (elem.manufacturer is TFhirString) {6} then
    ComposeString(this, 'DeviceDefinition', 'manufacturerString', TFhirString(elem.manufacturer), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) and doCompose('deviceName') then
    for i := 0 to elem.deviceNameList.Count - 1 do
      ComposeDeviceDefinitionDeviceName(this, 'DeviceDefinition', 'deviceName', elem.deviceNameList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('modelNumber') then
    ComposeString(this, 'DeviceDefinition', 'modelNumber', elem.modelNumberElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('type_') then
    ComposeCodeableConcept(this, 'DeviceDefinition', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('specialization') then
    for i := 0 to elem.specializationList.Count - 1 do
      ComposeDeviceDefinitionSpecialization(this, 'DeviceDefinition', 'specialization', elem.specializationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('version') then
    for i := 0 to elem.versionList.Count - 1 do
      ComposeString(this, 'DeviceDefinition', 'version', elem.versionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('safety') then
    for i := 0 to elem.safetyList.Count - 1 do
      ComposeCodeableConcept(this, 'DeviceDefinition', 'safety', elem.safetyList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('shelfLifeStorage') then
    for i := 0 to elem.shelfLifeStorageList.Count - 1 do
      ComposeProductShelfLife(this, 'DeviceDefinition', 'shelfLifeStorage', elem.shelfLifeStorageList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('physicalCharacteristics') then
    ComposeProdCharacteristic(this, 'DeviceDefinition', 'physicalCharacteristics', elem.physicalCharacteristicsElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('languageCode') then
    for i := 0 to elem.languageCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'DeviceDefinition', 'languageCode', elem.languageCodeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('capability') then
    for i := 0 to elem.capabilityList.Count - 1 do
      ComposeDeviceDefinitionCapability(this, 'DeviceDefinition', 'capability', elem.capabilityList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('property_') then
    for i := 0 to elem.property_List.Count - 1 do
      ComposeDeviceDefinitionProperty(this, 'DeviceDefinition', 'property', elem.property_List[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('owner') then
    ComposeReference{TFhirOrganization}(this, 'DeviceDefinition', 'owner', elem.ownerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactPoint(this, 'DeviceDefinition', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('url') then
    ComposeUri(this, 'DeviceDefinition', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('onlineInformation') then
    ComposeUri(this, 'DeviceDefinition', 'onlineInformation', elem.onlineInformationElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'DeviceDefinition', 'note', elem.noteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('quantity') then
    ComposeQuantity(this, 'DeviceDefinition', 'quantity', elem.quantityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('parentDevice') then
    ComposeReference{TFhirDeviceDefinition}(this, 'DeviceDefinition', 'parentDevice', elem.parentDeviceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('material') then
    for i := 0 to elem.materialList.Count - 1 do
      ComposeDeviceDefinitionMaterial(this, 'DeviceDefinition', 'material', elem.materialList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_DEVICEDEFINITION}
{$IFDEF FHIR_DEVICEMETRIC}
function TFHIRTurtleParser.ParseDeviceMetricCalibration(obj : TTurtleComplex) : TFhirDeviceMetricCalibration;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDeviceMetricCalibration.create;
  try
    ParseDeviceMetricCalibrationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDeviceMetricCalibrationProperties(obj : TTurtleComplex; result : TFhirDeviceMetricCalibration);
begin
    ParseBackboneElementProperties(obj, result);
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/DeviceMetric.calibration.type'), CODES_TFhirMetricCalibrationTypeEnum, SYSTEMS_TFhirMetricCalibrationTypeEnum);
    result.stateElement := ParseEnum(obj.complex('http://hl7.org/fhir/DeviceMetric.calibration.state'), CODES_TFhirMetricCalibrationStateEnum, SYSTEMS_TFhirMetricCalibrationStateEnum);
    result.timeElement := ParseInstant(obj.complex('http://hl7.org/fhir/DeviceMetric.calibration.time'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeDeviceMetricCalibration(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDeviceMetricCalibration; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DeviceMetricCalibration'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'DeviceMetric.calibration', 'type', elem.Type_Element, CODES_TFhirMetricCalibrationTypeEnum, SYSTEMS_TFhirMetricCalibrationTypeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'DeviceMetric.calibration', 'state', elem.StateElement, CODES_TFhirMetricCalibrationStateEnum, SYSTEMS_TFhirMetricCalibrationStateEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstant(this, 'DeviceMetric.calibration', 'time', elem.timeElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseDeviceMetric(obj : TTurtleComplex) : TFhirDeviceMetric;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDeviceMetric.create;
  try
    ParseDeviceMetricProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDeviceMetricProperties(obj : TTurtleComplex; result : TFhirDeviceMetric);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/DeviceMetric.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DeviceMetric.type'));{q3b}
    result.unit_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DeviceMetric.unit'));{q3b}
    result.source := ParseReference{TFhirDevice}(obj.complex('http://hl7.org/fhir/DeviceMetric.source'));{q3b}
    result.parent := ParseReference{TFhirDevice}(obj.complex('http://hl7.org/fhir/DeviceMetric.parent'));{q3b}
    result.operationalStatusElement := ParseEnum(obj.complex('http://hl7.org/fhir/DeviceMetric.operationalStatus'), CODES_TFhirMetricOperationalStatusEnum, SYSTEMS_TFhirMetricOperationalStatusEnum);
    result.colorElement := ParseEnum(obj.complex('http://hl7.org/fhir/DeviceMetric.color'), CODES_TFhirMetricColorEnum, SYSTEMS_TFhirMetricColorEnum);
    result.categoryElement := ParseEnum(obj.complex('http://hl7.org/fhir/DeviceMetric.category'), CODES_TFhirMetricCategoryEnum, SYSTEMS_TFhirMetricCategoryEnum);
    result.measurementPeriod := ParseTiming(obj.complex('http://hl7.org/fhir/DeviceMetric.measurementPeriod'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/DeviceMetric.calibration') do
      result.calibrationList.Add(parseDeviceMetricCalibration(item));
end;

procedure TFHIRTurtleComposer.ComposeDeviceMetric(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDeviceMetric; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DeviceMetric'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'DeviceMetric', 'identifier', elem.identifierList[i], false, i);{x.d3}
  ComposeCodeableConcept(this, 'DeviceMetric', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('unit_') then
    ComposeCodeableConcept(this, 'DeviceMetric', 'unit', elem.unit_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('source') then
    ComposeReference{TFhirDevice}(this, 'DeviceMetric', 'source', elem.sourceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('parent') then
    ComposeReference{TFhirDevice}(this, 'DeviceMetric', 'parent', elem.parentElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('operationalStatus') then
    ComposeEnum(this, 'DeviceMetric', 'operationalStatus', elem.OperationalStatusElement, CODES_TFhirMetricOperationalStatusEnum, SYSTEMS_TFhirMetricOperationalStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('color') then
    ComposeEnum(this, 'DeviceMetric', 'color', elem.ColorElement, CODES_TFhirMetricColorEnum, SYSTEMS_TFhirMetricColorEnum, false, -1);{x.d4}
  ComposeEnum(this, 'DeviceMetric', 'category', elem.CategoryElement, CODES_TFhirMetricCategoryEnum, SYSTEMS_TFhirMetricCategoryEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('measurementPeriod') then
    ComposeTiming(this, 'DeviceMetric', 'measurementPeriod', elem.measurementPeriodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('calibration') then
    for i := 0 to elem.calibrationList.Count - 1 do
      ComposeDeviceMetricCalibration(this, 'DeviceMetric', 'calibration', elem.calibrationList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_DEVICEMETRIC}
{$IFDEF FHIR_DEVICEREQUEST}
function TFHIRTurtleParser.ParseDeviceRequestParameter(obj : TTurtleComplex) : TFhirDeviceRequestParameter;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDeviceRequestParameter.create;
  try
    ParseDeviceRequestParameterProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDeviceRequestParameterProperties(obj : TTurtleComplex; result : TFhirDeviceRequestParameter);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DeviceRequest.parameter.code'));{q3b}
    if obj.has('http://hl7.org/fhir/DeviceRequest.parameter.valueCodeableConcept', item) then
      result.value := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/DeviceRequest.parameter.valueQuantity', item) then
      result.value := parseQuantity(item);
    if obj.has('http://hl7.org/fhir/DeviceRequest.parameter.valueRange', item) then
      result.value := parseRange(item);
    if obj.has('http://hl7.org/fhir/DeviceRequest.parameter.valueBoolean', item) then
      result.value := parseBoolean(item);
end;

procedure TFHIRTurtleComposer.ComposeDeviceRequestParameter(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDeviceRequestParameter; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DeviceRequestParameter'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'DeviceRequest.parameter', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and (elem.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'DeviceRequest.parameter', 'valueCodeableConcept', TFhirCodeableConcept(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'DeviceRequest.parameter', 'valueQuantity', TFhirQuantity(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirRange) {6} then
    ComposeRange(this, 'DeviceRequest.parameter', 'valueRange', TFhirRange(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirBoolean) {6} then
    ComposeBoolean(this, 'DeviceRequest.parameter', 'valueBoolean', TFhirBoolean(elem.value), false, -1);{x.d9}
end;

function TFHIRTurtleParser.ParseDeviceRequest(obj : TTurtleComplex) : TFhirDeviceRequest;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDeviceRequest.create;
  try
    ParseDeviceRequestProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDeviceRequestProperties(obj : TTurtleComplex; result : TFhirDeviceRequest);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/DeviceRequest.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/DeviceRequest.instantiatesCanonical') do
      result.instantiatesCanonicalList.Add(parseCanonical(item));
    for item in obj.complexes('http://hl7.org/fhir/DeviceRequest.instantiatesUri') do
      result.instantiatesUriList.Add(parseUri(item));
    for item in obj.complexes('http://hl7.org/fhir/DeviceRequest.basedOn') do
      result.basedOnList.Add(parseReference{TFhirReference}(item));
    for item in obj.complexes('http://hl7.org/fhir/DeviceRequest.priorRequest') do
      result.priorRequestList.Add(parseReference{TFhirReference}(item));
    result.groupIdentifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/DeviceRequest.groupIdentifier'));{q3b}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/DeviceRequest.status'), CODES_TFhirRequestStatusEnum, SYSTEMS_TFhirRequestStatusEnum);
    result.intentElement := ParseEnum(obj.complex('http://hl7.org/fhir/DeviceRequest.intent'), CODES_TFhirRequestIntentEnum, SYSTEMS_TFhirRequestIntentEnum);
    result.priorityElement := ParseEnum(obj.complex('http://hl7.org/fhir/DeviceRequest.priority'), CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum);
    if obj.has('http://hl7.org/fhir/DeviceRequest.codeReference', item) {a3} then
      result.code := ParseReference(item);
    if obj.has('http://hl7.org/fhir/DeviceRequest.codeCodeableConcept', item) then
      result.code := parseCodeableConcept(item);
    for item in obj.complexes('http://hl7.org/fhir/DeviceRequest.parameter') do
      result.parameterList.Add(parseDeviceRequestParameter(item));
    result.subject := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/DeviceRequest.subject'));{q3b}
    result.encounter := ParseReference{TFhirEncounter}(obj.complex('http://hl7.org/fhir/DeviceRequest.encounter'));{q3b}
    if obj.has('http://hl7.org/fhir/DeviceRequest.occurrencePeriod', item) then
      result.occurrence := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/DeviceRequest.occurrenceTiming', item) then
      result.occurrence := parseTiming(item);
    if obj.has('http://hl7.org/fhir/DeviceRequest.occurrenceDateTime', item) then
      result.occurrence := parseDateTime(item);
    result.authoredOnElement := ParseDateTime(obj.complex('http://hl7.org/fhir/DeviceRequest.authoredOn'));{q1}
    result.requester := ParseReference{TFhirDevice}(obj.complex('http://hl7.org/fhir/DeviceRequest.requester'));{q3b}
    result.performerType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DeviceRequest.performerType'));{q3b}
    result.performer := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/DeviceRequest.performer'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/DeviceRequest.reasonCode') do
      result.reasonCodeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/DeviceRequest.reasonReference') do
      result.reasonReferenceList.Add(parseReference{TFhirCondition}(item));
    for item in obj.complexes('http://hl7.org/fhir/DeviceRequest.insurance') do
      result.insuranceList.Add(parseReference{TFhirCoverage}(item));
    for item in obj.complexes('http://hl7.org/fhir/DeviceRequest.supportingInfo') do
      result.supportingInfoList.Add(parseReference{TFhirReference}(item));
    for item in obj.complexes('http://hl7.org/fhir/DeviceRequest.note') do
      result.noteList.Add(parseAnnotation(item));
    for item in obj.complexes('http://hl7.org/fhir/DeviceRequest.relevantHistory') do
      result.relevantHistoryList.Add(parseReference{TFhirProvenance}(item));
end;

procedure TFHIRTurtleComposer.ComposeDeviceRequest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDeviceRequest; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DeviceRequest'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'DeviceRequest', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('instantiatesCanonical') then
    for i := 0 to elem.instantiatesCanonicalList.Count - 1 do
      ComposeCanonical(this, 'DeviceRequest', 'instantiatesCanonical', elem.instantiatesCanonicalList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('instantiatesUri') then
    for i := 0 to elem.instantiatesUriList.Count - 1 do
      ComposeUri(this, 'DeviceRequest', 'instantiatesUri', elem.instantiatesUriList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('basedOn') then
    for i := 0 to elem.basedOnList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'DeviceRequest', 'basedOn', elem.basedOnList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('priorRequest') then
    for i := 0 to elem.priorRequestList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'DeviceRequest', 'priorRequest', elem.priorRequestList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('groupIdentifier') then
    ComposeIdentifier(this, 'DeviceRequest', 'groupIdentifier', elem.groupIdentifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(this, 'DeviceRequest', 'status', elem.StatusElement, CODES_TFhirRequestStatusEnum, SYSTEMS_TFhirRequestStatusEnum, false, -1);{x.d4}
  ComposeEnum(this, 'DeviceRequest', 'intent', elem.IntentElement, CODES_TFhirRequestIntentEnum, SYSTEMS_TFhirRequestIntentEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('priority') then
    ComposeEnum(this, 'DeviceRequest', 'priority', elem.PriorityElement, CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum, false, -1);{x.d4}
  if (elem.code is TFhirReference) {2} then
    ComposeReference(this, 'DeviceRequest', 'codeReference', TFhirReference(elem.code), false,-1){x.d8}
  else if (elem.code is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'DeviceRequest', 'codeCodeableConcept', TFhirCodeableConcept(elem.code), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) and doCompose('parameter') then
    for i := 0 to elem.parameterList.Count - 1 do
      ComposeDeviceRequestParameter(this, 'DeviceRequest', 'parameter', elem.parameterList[i], false, i);{x.d3}
  ComposeReference{TFhirPatient}(this, 'DeviceRequest', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(this, 'DeviceRequest', 'encounter', elem.encounterElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirPeriod) {6} then
    ComposePeriod(this, 'DeviceRequest', 'occurrencePeriod', TFhirPeriod(elem.occurrence), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirTiming) {6} then
    ComposeTiming(this, 'DeviceRequest', 'occurrenceTiming', TFhirTiming(elem.occurrence), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirDateTime) {6} then
    ComposeDateTime(this, 'DeviceRequest', 'occurrenceDateTime', TFhirDateTime(elem.occurrence), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('authoredOn') then
    ComposeDateTime(this, 'DeviceRequest', 'authoredOn', elem.authoredOnElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requester') then
    ComposeReference{TFhirDevice}(this, 'DeviceRequest', 'requester', elem.requesterElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('performerType') then
    ComposeCodeableConcept(this, 'DeviceRequest', 'performerType', elem.performerTypeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('performer') then
    ComposeReference{TFhirPractitioner}(this, 'DeviceRequest', 'performer', elem.performerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonCode') then
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'DeviceRequest', 'reasonCode', elem.reasonCodeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonReference') then
    for i := 0 to elem.reasonReferenceList.Count - 1 do
      ComposeReference{TFhirCondition}(this, 'DeviceRequest', 'reasonReference', elem.reasonReferenceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('insurance') then
    for i := 0 to elem.insuranceList.Count - 1 do
      ComposeReference{TFhirCoverage}(this, 'DeviceRequest', 'insurance', elem.insuranceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('supportingInfo') then
    for i := 0 to elem.supportingInfoList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'DeviceRequest', 'supportingInfo', elem.supportingInfoList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'DeviceRequest', 'note', elem.noteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('relevantHistory') then
    for i := 0 to elem.relevantHistoryList.Count - 1 do
      ComposeReference{TFhirProvenance}(this, 'DeviceRequest', 'relevantHistory', elem.relevantHistoryList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_DEVICEREQUEST}
{$IFDEF FHIR_DEVICEUSESTATEMENT}
function TFHIRTurtleParser.ParseDeviceUseStatement(obj : TTurtleComplex) : TFhirDeviceUseStatement;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDeviceUseStatement.create;
  try
    ParseDeviceUseStatementProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDeviceUseStatementProperties(obj : TTurtleComplex; result : TFhirDeviceUseStatement);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/DeviceUseStatement.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/DeviceUseStatement.basedOn') do
      result.basedOnList.Add(parseReference{TFhirServiceRequest}(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/DeviceUseStatement.status'), CODES_TFhirDeviceStatementStatusEnum, SYSTEMS_TFhirDeviceStatementStatusEnum);
    result.subject := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/DeviceUseStatement.subject'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/DeviceUseStatement.derivedFrom') do
      result.derivedFromList.Add(parseReference{TFhirServiceRequest}(item));
    if obj.has('http://hl7.org/fhir/DeviceUseStatement.timingTiming', item) then
      result.timing := parseTiming(item);
    if obj.has('http://hl7.org/fhir/DeviceUseStatement.timingPeriod', item) then
      result.timing := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/DeviceUseStatement.timingDateTime', item) then
      result.timing := parseDateTime(item);
    result.recordedOnElement := ParseDateTime(obj.complex('http://hl7.org/fhir/DeviceUseStatement.recordedOn'));{q1}
    result.source := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/DeviceUseStatement.source'));{q3b}
    result.device := ParseReference{TFhirDevice}(obj.complex('http://hl7.org/fhir/DeviceUseStatement.device'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/DeviceUseStatement.reasonCode') do
      result.reasonCodeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/DeviceUseStatement.reasonReference') do
      result.reasonReferenceList.Add(parseReference{TFhirCondition}(item));
    result.bodySite := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DeviceUseStatement.bodySite'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/DeviceUseStatement.note') do
      result.noteList.Add(parseAnnotation(item));
end;

procedure TFHIRTurtleComposer.ComposeDeviceUseStatement(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDeviceUseStatement; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DeviceUseStatement'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'DeviceUseStatement', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('basedOn') then
    for i := 0 to elem.basedOnList.Count - 1 do
      ComposeReference{TFhirServiceRequest}(this, 'DeviceUseStatement', 'basedOn', elem.basedOnList[i], false, i);{x.d3}
  ComposeEnum(this, 'DeviceUseStatement', 'status', elem.StatusElement, CODES_TFhirDeviceStatementStatusEnum, SYSTEMS_TFhirDeviceStatementStatusEnum, false, -1);{x.d4}
  ComposeReference{TFhirPatient}(this, 'DeviceUseStatement', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('derivedFrom') then
    for i := 0 to elem.derivedFromList.Count - 1 do
      ComposeReference{TFhirServiceRequest}(this, 'DeviceUseStatement', 'derivedFrom', elem.derivedFromList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.timing is TFhirTiming) {6} then
    ComposeTiming(this, 'DeviceUseStatement', 'timingTiming', TFhirTiming(elem.timing), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.timing is TFhirPeriod) {6} then
    ComposePeriod(this, 'DeviceUseStatement', 'timingPeriod', TFhirPeriod(elem.timing), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.timing is TFhirDateTime) {6} then
    ComposeDateTime(this, 'DeviceUseStatement', 'timingDateTime', TFhirDateTime(elem.timing), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('recordedOn') then
    ComposeDateTime(this, 'DeviceUseStatement', 'recordedOn', elem.recordedOnElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('source') then
    ComposeReference{TFhirPatient}(this, 'DeviceUseStatement', 'source', elem.sourceElement, false, -1);{x.2f}
  ComposeReference{TFhirDevice}(this, 'DeviceUseStatement', 'device', elem.deviceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonCode') then
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'DeviceUseStatement', 'reasonCode', elem.reasonCodeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonReference') then
    for i := 0 to elem.reasonReferenceList.Count - 1 do
      ComposeReference{TFhirCondition}(this, 'DeviceUseStatement', 'reasonReference', elem.reasonReferenceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('bodySite') then
    ComposeCodeableConcept(this, 'DeviceUseStatement', 'bodySite', elem.bodySiteElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'DeviceUseStatement', 'note', elem.noteList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_DEVICEUSESTATEMENT}
{$IFDEF FHIR_DIAGNOSTICREPORT}
function TFHIRTurtleParser.ParseDiagnosticReportMedia(obj : TTurtleComplex) : TFhirDiagnosticReportMedia;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDiagnosticReportMedia.create;
  try
    ParseDiagnosticReportMediaProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDiagnosticReportMediaProperties(obj : TTurtleComplex; result : TFhirDiagnosticReportMedia);
begin
    ParseBackboneElementProperties(obj, result);
    result.commentElement := ParseString(obj.complex('http://hl7.org/fhir/DiagnosticReport.media.comment'));{q1}
    result.link_ := ParseReference{TFhirMedia}(obj.complex('http://hl7.org/fhir/DiagnosticReport.media.link'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeDiagnosticReportMedia(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDiagnosticReportMedia; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DiagnosticReportMedia'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'DiagnosticReport.media', 'comment', elem.commentElement, false, -1);{x.2ea}
  ComposeReference{TFhirMedia}(this, 'DiagnosticReport.media', 'link', elem.link_Element, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseDiagnosticReport(obj : TTurtleComplex) : TFhirDiagnosticReport;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDiagnosticReport.create;
  try
    ParseDiagnosticReportProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDiagnosticReportProperties(obj : TTurtleComplex; result : TFhirDiagnosticReport);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/DiagnosticReport.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/DiagnosticReport.basedOn') do
      result.basedOnList.Add(parseReference{TFhirCarePlan}(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/DiagnosticReport.status'), CODES_TFhirDiagnosticReportStatusEnum, SYSTEMS_TFhirDiagnosticReportStatusEnum);
    for item in obj.complexes('http://hl7.org/fhir/DiagnosticReport.category') do
      result.categoryList.Add(parseCodeableConcept(item));
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DiagnosticReport.code'));{q3b}
    result.subject := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/DiagnosticReport.subject'));{q3b}
    result.encounter := ParseReference{TFhirEncounter}(obj.complex('http://hl7.org/fhir/DiagnosticReport.encounter'));{q3b}
    if obj.has('http://hl7.org/fhir/DiagnosticReport.effectivePeriod', item) then
      result.effective := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/DiagnosticReport.effectiveDateTime', item) then
      result.effective := parseDateTime(item);
    result.issuedElement := ParseInstant(obj.complex('http://hl7.org/fhir/DiagnosticReport.issued'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/DiagnosticReport.performer') do
      result.performerList.Add(parseReference{TFhirPractitioner}(item));
    for item in obj.complexes('http://hl7.org/fhir/DiagnosticReport.resultsInterpreter') do
      result.resultsInterpreterList.Add(parseReference{TFhirPractitioner}(item));
    for item in obj.complexes('http://hl7.org/fhir/DiagnosticReport.specimen') do
      result.specimenList.Add(parseReference{TFhirSpecimen}(item));
    for item in obj.complexes('http://hl7.org/fhir/DiagnosticReport.result') do
      result.resultList.Add(parseReference{TFhirObservation}(item));
    for item in obj.complexes('http://hl7.org/fhir/DiagnosticReport.imagingStudy') do
      result.imagingStudyList.Add(parseReference{TFhirImagingStudy}(item));
    for item in obj.complexes('http://hl7.org/fhir/DiagnosticReport.media') do
      result.mediaList.Add(parseDiagnosticReportMedia(item));
    result.conclusionElement := ParseString(obj.complex('http://hl7.org/fhir/DiagnosticReport.conclusion'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/DiagnosticReport.conclusionCode') do
      result.conclusionCodeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/DiagnosticReport.presentedForm') do
      result.presentedFormList.Add(parseAttachment(item));
end;

procedure TFHIRTurtleComposer.ComposeDiagnosticReport(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDiagnosticReport; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DiagnosticReport'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'DiagnosticReport', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('basedOn') then
    for i := 0 to elem.basedOnList.Count - 1 do
      ComposeReference{TFhirCarePlan}(this, 'DiagnosticReport', 'basedOn', elem.basedOnList[i], false, i);{x.d3}
  ComposeEnum(this, 'DiagnosticReport', 'status', elem.StatusElement, CODES_TFhirDiagnosticReportStatusEnum, SYSTEMS_TFhirDiagnosticReportStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(this, 'DiagnosticReport', 'category', elem.categoryList[i], false, i);{x.d3}
  ComposeCodeableConcept(this, 'DiagnosticReport', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{TFhirPatient}(this, 'DiagnosticReport', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(this, 'DiagnosticReport', 'encounter', elem.encounterElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.effective is TFhirPeriod) {6} then
    ComposePeriod(this, 'DiagnosticReport', 'effectivePeriod', TFhirPeriod(elem.effective), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.effective is TFhirDateTime) {6} then
    ComposeDateTime(this, 'DiagnosticReport', 'effectiveDateTime', TFhirDateTime(elem.effective), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('issued') then
    ComposeInstant(this, 'DiagnosticReport', 'issued', elem.issuedElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('performer') then
    for i := 0 to elem.performerList.Count - 1 do
      ComposeReference{TFhirPractitioner}(this, 'DiagnosticReport', 'performer', elem.performerList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('resultsInterpreter') then
    for i := 0 to elem.resultsInterpreterList.Count - 1 do
      ComposeReference{TFhirPractitioner}(this, 'DiagnosticReport', 'resultsInterpreter', elem.resultsInterpreterList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('specimen') then
    for i := 0 to elem.specimenList.Count - 1 do
      ComposeReference{TFhirSpecimen}(this, 'DiagnosticReport', 'specimen', elem.specimenList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('result') then
    for i := 0 to elem.resultList.Count - 1 do
      ComposeReference{TFhirObservation}(this, 'DiagnosticReport', 'result', elem.resultList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('imagingStudy') then
    for i := 0 to elem.imagingStudyList.Count - 1 do
      ComposeReference{TFhirImagingStudy}(this, 'DiagnosticReport', 'imagingStudy', elem.imagingStudyList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('media') then
    for i := 0 to elem.mediaList.Count - 1 do
      ComposeDiagnosticReportMedia(this, 'DiagnosticReport', 'media', elem.mediaList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('conclusion') then
    ComposeString(this, 'DiagnosticReport', 'conclusion', elem.conclusionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('conclusionCode') then
    for i := 0 to elem.conclusionCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'DiagnosticReport', 'conclusionCode', elem.conclusionCodeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('presentedForm') then
    for i := 0 to elem.presentedFormList.Count - 1 do
      ComposeAttachment(this, 'DiagnosticReport', 'presentedForm', elem.presentedFormList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_DIAGNOSTICREPORT}
{$IFDEF FHIR_DOCUMENTMANIFEST}
function TFHIRTurtleParser.ParseDocumentManifestRelated(obj : TTurtleComplex) : TFhirDocumentManifestRelated;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDocumentManifestRelated.create;
  try
    ParseDocumentManifestRelatedProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDocumentManifestRelatedProperties(obj : TTurtleComplex; result : TFhirDocumentManifestRelated);
begin
    ParseBackboneElementProperties(obj, result);
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/DocumentManifest.related.identifier'));{q3b}
    result.ref := ParseReference{TFhirReference}(obj.complex('http://hl7.org/fhir/DocumentManifest.related.ref'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeDocumentManifestRelated(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDocumentManifestRelated; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DocumentManifestRelated'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(this, 'DocumentManifest.related', 'identifier', elem.identifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirReference}(this, 'DocumentManifest.related', 'ref', elem.refElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseDocumentManifest(obj : TTurtleComplex) : TFhirDocumentManifest;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDocumentManifest.create;
  try
    ParseDocumentManifestProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDocumentManifestProperties(obj : TTurtleComplex; result : TFhirDocumentManifest);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.masterIdentifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/DocumentManifest.masterIdentifier'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/DocumentManifest.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/DocumentManifest.status'), CODES_TFhirDocumentReferenceStatusEnum, SYSTEMS_TFhirDocumentReferenceStatusEnum);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DocumentManifest.type'));{q3b}
    result.subject := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/DocumentManifest.subject'));{q3b}
    result.createdElement := ParseDateTime(obj.complex('http://hl7.org/fhir/DocumentManifest.created'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/DocumentManifest.author') do
      result.authorList.Add(parseReference{TFhirPractitioner}(item));
    for item in obj.complexes('http://hl7.org/fhir/DocumentManifest.recipient') do
      result.recipientList.Add(parseReference{TFhirPatient}(item));
    result.sourceElement := ParseUri(obj.complex('http://hl7.org/fhir/DocumentManifest.source'));{q1}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/DocumentManifest.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/DocumentManifest.content') do
      result.contentList.Add(parseReference{TFhirReference}(item));
    for item in obj.complexes('http://hl7.org/fhir/DocumentManifest.related') do
      result.relatedList.Add(parseDocumentManifestRelated(item));
end;

procedure TFHIRTurtleComposer.ComposeDocumentManifest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDocumentManifest; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DocumentManifest'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('masterIdentifier') then
    ComposeIdentifier(this, 'DocumentManifest', 'masterIdentifier', elem.masterIdentifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'DocumentManifest', 'identifier', elem.identifierList[i], false, i);{x.d3}
  ComposeEnum(this, 'DocumentManifest', 'status', elem.StatusElement, CODES_TFhirDocumentReferenceStatusEnum, SYSTEMS_TFhirDocumentReferenceStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCodeableConcept(this, 'DocumentManifest', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{TFhirPatient}(this, 'DocumentManifest', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('created') then
    ComposeDateTime(this, 'DocumentManifest', 'created', elem.createdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('author') then
    for i := 0 to elem.authorList.Count - 1 do
      ComposeReference{TFhirPractitioner}(this, 'DocumentManifest', 'author', elem.authorList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('recipient') then
    for i := 0 to elem.recipientList.Count - 1 do
      ComposeReference{TFhirPatient}(this, 'DocumentManifest', 'recipient', elem.recipientList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('source') then
    ComposeUri(this, 'DocumentManifest', 'source', elem.sourceElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeString(this, 'DocumentManifest', 'description', elem.descriptionElement, false, -1);{x.2ea}
  for i := 0 to elem.contentList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'DocumentManifest', 'content', elem.contentList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('related') then
    for i := 0 to elem.relatedList.Count - 1 do
      ComposeDocumentManifestRelated(this, 'DocumentManifest', 'related', elem.relatedList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_DOCUMENTMANIFEST}
{$IFDEF FHIR_DOCUMENTREFERENCE}
function TFHIRTurtleParser.ParseDocumentReferenceRelatesTo(obj : TTurtleComplex) : TFhirDocumentReferenceRelatesTo;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDocumentReferenceRelatesTo.create;
  try
    ParseDocumentReferenceRelatesToProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDocumentReferenceRelatesToProperties(obj : TTurtleComplex; result : TFhirDocumentReferenceRelatesTo);
begin
    ParseBackboneElementProperties(obj, result);
    result.codeElement := ParseEnum(obj.complex('http://hl7.org/fhir/DocumentReference.relatesTo.code'), CODES_TFhirDocumentRelationshipTypeEnum, SYSTEMS_TFhirDocumentRelationshipTypeEnum);
    result.target := ParseReference{TFhirDocumentReference}(obj.complex('http://hl7.org/fhir/DocumentReference.relatesTo.target'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeDocumentReferenceRelatesTo(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDocumentReferenceRelatesTo; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DocumentReferenceRelatesTo'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'DocumentReference.relatesTo', 'code', elem.CodeElement, CODES_TFhirDocumentRelationshipTypeEnum, SYSTEMS_TFhirDocumentRelationshipTypeEnum, false, -1);{x.d4}
  ComposeReference{TFhirDocumentReference}(this, 'DocumentReference.relatesTo', 'target', elem.targetElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseDocumentReferenceContent(obj : TTurtleComplex) : TFhirDocumentReferenceContent;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDocumentReferenceContent.create;
  try
    ParseDocumentReferenceContentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDocumentReferenceContentProperties(obj : TTurtleComplex; result : TFhirDocumentReferenceContent);
begin
    ParseBackboneElementProperties(obj, result);
    result.attachment := ParseAttachment(obj.complex('http://hl7.org/fhir/DocumentReference.content.attachment'));{q3b}
    result.format := ParseCoding(obj.complex('http://hl7.org/fhir/DocumentReference.content.format'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeDocumentReferenceContent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDocumentReferenceContent; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DocumentReferenceContent'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeAttachment(this, 'DocumentReference.content', 'attachment', elem.attachmentElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(this, 'DocumentReference.content', 'format', elem.formatElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseDocumentReferenceContext(obj : TTurtleComplex) : TFhirDocumentReferenceContext;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDocumentReferenceContext.create;
  try
    ParseDocumentReferenceContextProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDocumentReferenceContextProperties(obj : TTurtleComplex; result : TFhirDocumentReferenceContext);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/DocumentReference.context.encounter') do
      result.encounterList.Add(parseReference{TFhirEncounter}(item));
    for item in obj.complexes('http://hl7.org/fhir/DocumentReference.context.event') do
      result.eventList.Add(parseCodeableConcept(item));
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/DocumentReference.context.period'));{q3b}
    result.facilityType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DocumentReference.context.facilityType'));{q3b}
    result.practiceSetting := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DocumentReference.context.practiceSetting'));{q3b}
    result.sourcePatientInfo := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/DocumentReference.context.sourcePatientInfo'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/DocumentReference.context.related') do
      result.relatedList.Add(parseReference{TFhirReference}(item));
end;

procedure TFHIRTurtleComposer.ComposeDocumentReferenceContext(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDocumentReferenceContext; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DocumentReferenceContext'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.encounterList.Count - 1 do
      ComposeReference{TFhirEncounter}(this, 'DocumentReference.context', 'encounter', elem.encounterList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.eventList.Count - 1 do
      ComposeCodeableConcept(this, 'DocumentReference.context', 'event', elem.eventList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'DocumentReference.context', 'period', elem.periodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'DocumentReference.context', 'facilityType', elem.facilityTypeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'DocumentReference.context', 'practiceSetting', elem.practiceSettingElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirPatient}(this, 'DocumentReference.context', 'sourcePatientInfo', elem.sourcePatientInfoElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.relatedList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'DocumentReference.context', 'related', elem.relatedList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseDocumentReference(obj : TTurtleComplex) : TFhirDocumentReference;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirDocumentReference.create;
  try
    ParseDocumentReferenceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseDocumentReferenceProperties(obj : TTurtleComplex; result : TFhirDocumentReference);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.masterIdentifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/DocumentReference.masterIdentifier'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/DocumentReference.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/DocumentReference.status'), CODES_TFhirDocumentReferenceStatusEnum, SYSTEMS_TFhirDocumentReferenceStatusEnum);
    result.docStatusElement := ParseEnum(obj.complex('http://hl7.org/fhir/DocumentReference.docStatus'), CODES_TFhirCompositionStatusEnum, SYSTEMS_TFhirCompositionStatusEnum);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/DocumentReference.type'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/DocumentReference.category') do
      result.categoryList.Add(parseCodeableConcept(item));
    result.subject := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/DocumentReference.subject'));{q3b}
    result.dateElement := ParseInstant(obj.complex('http://hl7.org/fhir/DocumentReference.date'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/DocumentReference.author') do
      result.authorList.Add(parseReference{TFhirPractitioner}(item));
    result.authenticator := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/DocumentReference.authenticator'));{q3b}
    result.custodian := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/DocumentReference.custodian'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/DocumentReference.relatesTo') do
      result.relatesToList.Add(parseDocumentReferenceRelatesTo(item));
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/DocumentReference.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/DocumentReference.securityLabel') do
      result.securityLabelList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/DocumentReference.content') do
      result.contentList.Add(parseDocumentReferenceContent(item));
    result.context := ParseDocumentReferenceContext(obj.complex('http://hl7.org/fhir/DocumentReference.context'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeDocumentReference(parent :  TTurtleComplex; parentType, name : String; elem : TFhirDocumentReference; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:DocumentReference'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('masterIdentifier') then
    ComposeIdentifier(this, 'DocumentReference', 'masterIdentifier', elem.masterIdentifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'DocumentReference', 'identifier', elem.identifierList[i], false, i);{x.d3}
  ComposeEnum(this, 'DocumentReference', 'status', elem.StatusElement, CODES_TFhirDocumentReferenceStatusEnum, SYSTEMS_TFhirDocumentReferenceStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('docStatus') then
    ComposeEnum(this, 'DocumentReference', 'docStatus', elem.DocStatusElement, CODES_TFhirCompositionStatusEnum, SYSTEMS_TFhirCompositionStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCodeableConcept(this, 'DocumentReference', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(this, 'DocumentReference', 'category', elem.categoryList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{TFhirPatient}(this, 'DocumentReference', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeInstant(this, 'DocumentReference', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('author') then
    for i := 0 to elem.authorList.Count - 1 do
      ComposeReference{TFhirPractitioner}(this, 'DocumentReference', 'author', elem.authorList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('authenticator') then
    ComposeReference{TFhirPractitioner}(this, 'DocumentReference', 'authenticator', elem.authenticatorElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('custodian') then
    ComposeReference{TFhirOrganization}(this, 'DocumentReference', 'custodian', elem.custodianElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('relatesTo') then
    for i := 0 to elem.relatesToList.Count - 1 do
      ComposeDocumentReferenceRelatesTo(this, 'DocumentReference', 'relatesTo', elem.relatesToList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeString(this, 'DocumentReference', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('securityLabel') then
    for i := 0 to elem.securityLabelList.Count - 1 do
      ComposeCodeableConcept(this, 'DocumentReference', 'securityLabel', elem.securityLabelList[i], false, i);{x.d3}
  for i := 0 to elem.contentList.Count - 1 do
      ComposeDocumentReferenceContent(this, 'DocumentReference', 'content', elem.contentList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('context') then
    ComposeDocumentReferenceContext(this, 'DocumentReference', 'context', elem.contextElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_DOCUMENTREFERENCE}
{$IFDEF FHIR_EFFECTEVIDENCESYNTHESIS}
function TFHIRTurtleParser.ParseEffectEvidenceSynthesisSampleSize(obj : TTurtleComplex) : TFhirEffectEvidenceSynthesisSampleSize;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEffectEvidenceSynthesisSampleSize.create;
  try
    ParseEffectEvidenceSynthesisSampleSizeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEffectEvidenceSynthesisSampleSizeProperties(obj : TTurtleComplex; result : TFhirEffectEvidenceSynthesisSampleSize);
begin
    ParseBackboneElementProperties(obj, result);
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/EffectEvidenceSynthesis.sampleSize.description'));{q1}
    result.numberOfStudiesElement := ParseInteger(obj.complex('http://hl7.org/fhir/EffectEvidenceSynthesis.sampleSize.numberOfStudies'));{q1}
    result.numberOfParticipantsElement := ParseInteger(obj.complex('http://hl7.org/fhir/EffectEvidenceSynthesis.sampleSize.numberOfParticipants'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeEffectEvidenceSynthesisSampleSize(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEffectEvidenceSynthesisSampleSize; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EffectEvidenceSynthesisSampleSize'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'EffectEvidenceSynthesis.sampleSize', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(this, 'EffectEvidenceSynthesis.sampleSize', 'numberOfStudies', elem.numberOfStudiesElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(this, 'EffectEvidenceSynthesis.sampleSize', 'numberOfParticipants', elem.numberOfParticipantsElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseEffectEvidenceSynthesisResultsByExposure(obj : TTurtleComplex) : TFhirEffectEvidenceSynthesisResultsByExposure;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEffectEvidenceSynthesisResultsByExposure.create;
  try
    ParseEffectEvidenceSynthesisResultsByExposureProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEffectEvidenceSynthesisResultsByExposureProperties(obj : TTurtleComplex; result : TFhirEffectEvidenceSynthesisResultsByExposure);
begin
    ParseBackboneElementProperties(obj, result);
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/EffectEvidenceSynthesis.resultsByExposure.description'));{q1}
    result.exposureStateElement := ParseEnum(obj.complex('http://hl7.org/fhir/EffectEvidenceSynthesis.resultsByExposure.exposureState'), CODES_TFhirExposureStateEnum, SYSTEMS_TFhirExposureStateEnum);
    result.variantState := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/EffectEvidenceSynthesis.resultsByExposure.variantState'));{q3b}
    result.riskEvidenceSynthesis := ParseReference{TFhirRiskEvidenceSynthesis}(obj.complex('http://hl7.org/fhir/EffectEvidenceSynthesis.resultsByExposure.riskEvidenceSynthesis'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeEffectEvidenceSynthesisResultsByExposure(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEffectEvidenceSynthesisResultsByExposure; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EffectEvidenceSynthesisResultsByExposure'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'EffectEvidenceSynthesis.resultsByExposure', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'EffectEvidenceSynthesis.resultsByExposure', 'exposureState', elem.ExposureStateElement, CODES_TFhirExposureStateEnum, SYSTEMS_TFhirExposureStateEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'EffectEvidenceSynthesis.resultsByExposure', 'variantState', elem.variantStateElement, false, -1);{x.2f}
  ComposeReference{TFhirRiskEvidenceSynthesis}(this, 'EffectEvidenceSynthesis.resultsByExposure', 'riskEvidenceSynthesis', elem.riskEvidenceSynthesisElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseEffectEvidenceSynthesisEffectEstimate(obj : TTurtleComplex) : TFhirEffectEvidenceSynthesisEffectEstimate;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEffectEvidenceSynthesisEffectEstimate.create;
  try
    ParseEffectEvidenceSynthesisEffectEstimateProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEffectEvidenceSynthesisEffectEstimateProperties(obj : TTurtleComplex; result : TFhirEffectEvidenceSynthesisEffectEstimate);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/EffectEvidenceSynthesis.effectEstimate.description'));{q1}
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/EffectEvidenceSynthesis.effectEstimate.type'));{q3b}
    result.variantState := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/EffectEvidenceSynthesis.effectEstimate.variantState'));{q3b}
    result.valueElement := ParseDecimal(obj.complex('http://hl7.org/fhir/EffectEvidenceSynthesis.effectEstimate.value'));{q1}
    result.unitOfMeasure := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/EffectEvidenceSynthesis.effectEstimate.unitOfMeasure'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/EffectEvidenceSynthesis.effectEstimate.precisionEstimate') do
      result.precisionEstimateList.Add(parseEffectEvidenceSynthesisEffectEstimatePrecisionEstimate(item));
end;

procedure TFHIRTurtleComposer.ComposeEffectEvidenceSynthesisEffectEstimate(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEffectEvidenceSynthesisEffectEstimate; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EffectEvidenceSynthesisEffectEstimate'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'EffectEvidenceSynthesis.effectEstimate', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'EffectEvidenceSynthesis.effectEstimate', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'EffectEvidenceSynthesis.effectEstimate', 'variantState', elem.variantStateElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'EffectEvidenceSynthesis.effectEstimate', 'value', elem.valueElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'EffectEvidenceSynthesis.effectEstimate', 'unitOfMeasure', elem.unitOfMeasureElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.precisionEstimateList.Count - 1 do
      ComposeEffectEvidenceSynthesisEffectEstimatePrecisionEstimate(this, 'EffectEvidenceSynthesis.effectEstimate', 'precisionEstimate', elem.precisionEstimateList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseEffectEvidenceSynthesisEffectEstimatePrecisionEstimate(obj : TTurtleComplex) : TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate.create;
  try
    ParseEffectEvidenceSynthesisEffectEstimatePrecisionEstimateProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEffectEvidenceSynthesisEffectEstimatePrecisionEstimateProperties(obj : TTurtleComplex; result : TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate);
begin
    ParseBackboneElementProperties(obj, result);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/EffectEvidenceSynthesis.effectEstimate.precisionEstimate.type'));{q3b}
    result.levelElement := ParseDecimal(obj.complex('http://hl7.org/fhir/EffectEvidenceSynthesis.effectEstimate.precisionEstimate.level'));{q1}
    result.fromElement := ParseDecimal(obj.complex('http://hl7.org/fhir/EffectEvidenceSynthesis.effectEstimate.precisionEstimate.from'));{q1}
    result.to_Element := ParseDecimal(obj.complex('http://hl7.org/fhir/EffectEvidenceSynthesis.effectEstimate.precisionEstimate.to'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeEffectEvidenceSynthesisEffectEstimatePrecisionEstimate(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EffectEvidenceSynthesisEffectEstimatePrecisionEstimate'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'EffectEvidenceSynthesis.effectEstimate.precisionEstimate', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'EffectEvidenceSynthesis.effectEstimate.precisionEstimate', 'level', elem.levelElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'EffectEvidenceSynthesis.effectEstimate.precisionEstimate', 'from', elem.fromElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'EffectEvidenceSynthesis.effectEstimate.precisionEstimate', 'to', elem.to_Element, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseEffectEvidenceSynthesisCertainty(obj : TTurtleComplex) : TFhirEffectEvidenceSynthesisCertainty;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEffectEvidenceSynthesisCertainty.create;
  try
    ParseEffectEvidenceSynthesisCertaintyProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEffectEvidenceSynthesisCertaintyProperties(obj : TTurtleComplex; result : TFhirEffectEvidenceSynthesisCertainty);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/EffectEvidenceSynthesis.certainty.rating') do
      result.ratingList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/EffectEvidenceSynthesis.certainty.note') do
      result.noteList.Add(parseAnnotation(item));
    for item in obj.complexes('http://hl7.org/fhir/EffectEvidenceSynthesis.certainty.certaintySubcomponent') do
      result.certaintySubcomponentList.Add(parseEffectEvidenceSynthesisCertaintyCertaintySubcomponent(item));
end;

procedure TFHIRTurtleComposer.ComposeEffectEvidenceSynthesisCertainty(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEffectEvidenceSynthesisCertainty; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EffectEvidenceSynthesisCertainty'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.ratingList.Count - 1 do
      ComposeCodeableConcept(this, 'EffectEvidenceSynthesis.certainty', 'rating', elem.ratingList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'EffectEvidenceSynthesis.certainty', 'note', elem.noteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.certaintySubcomponentList.Count - 1 do
      ComposeEffectEvidenceSynthesisCertaintyCertaintySubcomponent(this, 'EffectEvidenceSynthesis.certainty', 'certaintySubcomponent', elem.certaintySubcomponentList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseEffectEvidenceSynthesisCertaintyCertaintySubcomponent(obj : TTurtleComplex) : TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent.create;
  try
    ParseEffectEvidenceSynthesisCertaintyCertaintySubcomponentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEffectEvidenceSynthesisCertaintyCertaintySubcomponentProperties(obj : TTurtleComplex; result : TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/EffectEvidenceSynthesis.certainty.certaintySubcomponent.type'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/EffectEvidenceSynthesis.certainty.certaintySubcomponent.rating') do
      result.ratingList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/EffectEvidenceSynthesis.certainty.certaintySubcomponent.note') do
      result.noteList.Add(parseAnnotation(item));
end;

procedure TFHIRTurtleComposer.ComposeEffectEvidenceSynthesisCertaintyCertaintySubcomponent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EffectEvidenceSynthesisCertaintyCertaintySubcomponent'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'EffectEvidenceSynthesis.certainty.certaintySubcomponent', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.ratingList.Count - 1 do
      ComposeCodeableConcept(this, 'EffectEvidenceSynthesis.certainty.certaintySubcomponent', 'rating', elem.ratingList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'EffectEvidenceSynthesis.certainty.certaintySubcomponent', 'note', elem.noteList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseEffectEvidenceSynthesis(obj : TTurtleComplex) : TFhirEffectEvidenceSynthesis;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEffectEvidenceSynthesis.create;
  try
    ParseEffectEvidenceSynthesisProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEffectEvidenceSynthesisProperties(obj : TTurtleComplex; result : TFhirEffectEvidenceSynthesis);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/EffectEvidenceSynthesis.url'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/EffectEvidenceSynthesis.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/EffectEvidenceSynthesis.version'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/EffectEvidenceSynthesis.name'));{q1}
    result.titleElement := ParseString(obj.complex('http://hl7.org/fhir/EffectEvidenceSynthesis.title'));{q1}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/EffectEvidenceSynthesis.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/EffectEvidenceSynthesis.date'));{q1}
    result.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/EffectEvidenceSynthesis.publisher'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/EffectEvidenceSynthesis.contact') do
      result.contactList.Add(parseContactDetail(item));
    result.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/EffectEvidenceSynthesis.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/EffectEvidenceSynthesis.note') do
      result.noteList.Add(parseAnnotation(item));
    for item in obj.complexes('http://hl7.org/fhir/EffectEvidenceSynthesis.useContext') do
      result.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/EffectEvidenceSynthesis.jurisdiction') do
      result.jurisdictionList.Add(parseCodeableConcept(item));
    result.copyrightElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/EffectEvidenceSynthesis.copyright'));{q1}
    result.approvalDateElement := ParseDate(obj.complex('http://hl7.org/fhir/EffectEvidenceSynthesis.approvalDate'));{q1}
    result.lastReviewDateElement := ParseDate(obj.complex('http://hl7.org/fhir/EffectEvidenceSynthesis.lastReviewDate'));{q1}
    result.effectivePeriod := ParsePeriod(obj.complex('http://hl7.org/fhir/EffectEvidenceSynthesis.effectivePeriod'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/EffectEvidenceSynthesis.topic') do
      result.topicList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/EffectEvidenceSynthesis.author') do
      result.authorList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/EffectEvidenceSynthesis.editor') do
      result.editorList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/EffectEvidenceSynthesis.reviewer') do
      result.reviewerList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/EffectEvidenceSynthesis.endorser') do
      result.endorserList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/EffectEvidenceSynthesis.relatedArtifact') do
      result.relatedArtifactList.Add(parseRelatedArtifact(item));
    result.synthesisType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/EffectEvidenceSynthesis.synthesisType'));{q3b}
    result.studyType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/EffectEvidenceSynthesis.studyType'));{q3b}
    result.population := ParseReference{TFhirEvidenceVariable}(obj.complex('http://hl7.org/fhir/EffectEvidenceSynthesis.population'));{q3b}
    result.exposure := ParseReference{TFhirEvidenceVariable}(obj.complex('http://hl7.org/fhir/EffectEvidenceSynthesis.exposure'));{q3b}
    result.exposureAlternative := ParseReference{TFhirEvidenceVariable}(obj.complex('http://hl7.org/fhir/EffectEvidenceSynthesis.exposureAlternative'));{q3b}
    result.outcome := ParseReference{TFhirEvidenceVariable}(obj.complex('http://hl7.org/fhir/EffectEvidenceSynthesis.outcome'));{q3b}
    result.sampleSize := ParseEffectEvidenceSynthesisSampleSize(obj.complex('http://hl7.org/fhir/EffectEvidenceSynthesis.sampleSize'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/EffectEvidenceSynthesis.resultsByExposure') do
      result.resultsByExposureList.Add(parseEffectEvidenceSynthesisResultsByExposure(item));
    for item in obj.complexes('http://hl7.org/fhir/EffectEvidenceSynthesis.effectEstimate') do
      result.effectEstimateList.Add(parseEffectEvidenceSynthesisEffectEstimate(item));
    for item in obj.complexes('http://hl7.org/fhir/EffectEvidenceSynthesis.certainty') do
      result.certaintyList.Add(parseEffectEvidenceSynthesisCertainty(item));
end;

procedure TFHIRTurtleComposer.ComposeEffectEvidenceSynthesis(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEffectEvidenceSynthesis; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EffectEvidenceSynthesis'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUri(this, 'EffectEvidenceSynthesis', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'EffectEvidenceSynthesis', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(this, 'EffectEvidenceSynthesis', 'version', elem.versionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(this, 'EffectEvidenceSynthesis', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeString(this, 'EffectEvidenceSynthesis', 'title', elem.titleElement, false, -1);{x.2ea}
  ComposeEnum(this, 'EffectEvidenceSynthesis', 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(this, 'EffectEvidenceSynthesis', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(this, 'EffectEvidenceSynthesis', 'publisher', elem.publisherElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(this, 'EffectEvidenceSynthesis', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeMarkdown(this, 'EffectEvidenceSynthesis', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'EffectEvidenceSynthesis', 'note', elem.noteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(this, 'EffectEvidenceSynthesis', 'useContext', elem.useContextList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'EffectEvidenceSynthesis', 'jurisdiction', elem.jurisdictionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdown(this, 'EffectEvidenceSynthesis', 'copyright', elem.copyrightElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('approvalDate') then
    ComposeDate(this, 'EffectEvidenceSynthesis', 'approvalDate', elem.approvalDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('lastReviewDate') then
    ComposeDate(this, 'EffectEvidenceSynthesis', 'lastReviewDate', elem.lastReviewDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('effectivePeriod') then
    ComposePeriod(this, 'EffectEvidenceSynthesis', 'effectivePeriod', elem.effectivePeriodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('topic') then
    for i := 0 to elem.topicList.Count - 1 do
      ComposeCodeableConcept(this, 'EffectEvidenceSynthesis', 'topic', elem.topicList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('author') then
    for i := 0 to elem.authorList.Count - 1 do
      ComposeContactDetail(this, 'EffectEvidenceSynthesis', 'author', elem.authorList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('editor') then
    for i := 0 to elem.editorList.Count - 1 do
      ComposeContactDetail(this, 'EffectEvidenceSynthesis', 'editor', elem.editorList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('reviewer') then
    for i := 0 to elem.reviewerList.Count - 1 do
      ComposeContactDetail(this, 'EffectEvidenceSynthesis', 'reviewer', elem.reviewerList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('endorser') then
    for i := 0 to elem.endorserList.Count - 1 do
      ComposeContactDetail(this, 'EffectEvidenceSynthesis', 'endorser', elem.endorserList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('relatedArtifact') then
    for i := 0 to elem.relatedArtifactList.Count - 1 do
      ComposeRelatedArtifact(this, 'EffectEvidenceSynthesis', 'relatedArtifact', elem.relatedArtifactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('synthesisType') then
    ComposeCodeableConcept(this, 'EffectEvidenceSynthesis', 'synthesisType', elem.synthesisTypeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('studyType') then
    ComposeCodeableConcept(this, 'EffectEvidenceSynthesis', 'studyType', elem.studyTypeElement, false, -1);{x.2f}
  ComposeReference{TFhirEvidenceVariable}(this, 'EffectEvidenceSynthesis', 'population', elem.populationElement, false, -1);{x.2f}
  ComposeReference{TFhirEvidenceVariable}(this, 'EffectEvidenceSynthesis', 'exposure', elem.exposureElement, false, -1);{x.2f}
  ComposeReference{TFhirEvidenceVariable}(this, 'EffectEvidenceSynthesis', 'exposureAlternative', elem.exposureAlternativeElement, false, -1);{x.2f}
  ComposeReference{TFhirEvidenceVariable}(this, 'EffectEvidenceSynthesis', 'outcome', elem.outcomeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('sampleSize') then
    ComposeEffectEvidenceSynthesisSampleSize(this, 'EffectEvidenceSynthesis', 'sampleSize', elem.sampleSizeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('resultsByExposure') then
    for i := 0 to elem.resultsByExposureList.Count - 1 do
      ComposeEffectEvidenceSynthesisResultsByExposure(this, 'EffectEvidenceSynthesis', 'resultsByExposure', elem.resultsByExposureList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('effectEstimate') then
    for i := 0 to elem.effectEstimateList.Count - 1 do
      ComposeEffectEvidenceSynthesisEffectEstimate(this, 'EffectEvidenceSynthesis', 'effectEstimate', elem.effectEstimateList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('certainty') then
    for i := 0 to elem.certaintyList.Count - 1 do
      ComposeEffectEvidenceSynthesisCertainty(this, 'EffectEvidenceSynthesis', 'certainty', elem.certaintyList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_EFFECTEVIDENCESYNTHESIS}
{$IFDEF FHIR_ENCOUNTER}
function TFHIRTurtleParser.ParseEncounterStatusHistory(obj : TTurtleComplex) : TFhirEncounterStatusHistory;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEncounterStatusHistory.create;
  try
    ParseEncounterStatusHistoryProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEncounterStatusHistoryProperties(obj : TTurtleComplex; result : TFhirEncounterStatusHistory);
begin
    ParseBackboneElementProperties(obj, result);
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Encounter.statusHistory.status'), CODES_TFhirEncounterStatusEnum, SYSTEMS_TFhirEncounterStatusEnum);
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Encounter.statusHistory.period'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeEncounterStatusHistory(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEncounterStatusHistory; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EncounterStatusHistory'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'Encounter.statusHistory', 'status', elem.StatusElement, CODES_TFhirEncounterStatusEnum, SYSTEMS_TFhirEncounterStatusEnum, false, -1);{x.d4}
  ComposePeriod(this, 'Encounter.statusHistory', 'period', elem.periodElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseEncounterClassHistory(obj : TTurtleComplex) : TFhirEncounterClassHistory;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEncounterClassHistory.create;
  try
    ParseEncounterClassHistoryProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEncounterClassHistoryProperties(obj : TTurtleComplex; result : TFhirEncounterClassHistory);
begin
    ParseBackboneElementProperties(obj, result);
    result.class_ := ParseCoding(obj.complex('http://hl7.org/fhir/Encounter.classHistory.class'));{q3b}
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Encounter.classHistory.period'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeEncounterClassHistory(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEncounterClassHistory; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EncounterClassHistory'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCoding(this, 'Encounter.classHistory', 'class', elem.class_Element, false, -1);{x.2f}
  ComposePeriod(this, 'Encounter.classHistory', 'period', elem.periodElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseEncounterParticipant(obj : TTurtleComplex) : TFhirEncounterParticipant;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEncounterParticipant.create;
  try
    ParseEncounterParticipantProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEncounterParticipantProperties(obj : TTurtleComplex; result : TFhirEncounterParticipant);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Encounter.participant.type') do
      result.type_List.Add(parseCodeableConcept(item));
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Encounter.participant.period'));{q3b}
    result.individual := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/Encounter.participant.individual'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeEncounterParticipant(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEncounterParticipant; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EncounterParticipant'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(this, 'Encounter.participant', 'type', elem.type_List[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'Encounter.participant', 'period', elem.periodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(this, 'Encounter.participant', 'individual', elem.individualElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseEncounterDiagnosis(obj : TTurtleComplex) : TFhirEncounterDiagnosis;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEncounterDiagnosis.create;
  try
    ParseEncounterDiagnosisProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEncounterDiagnosisProperties(obj : TTurtleComplex; result : TFhirEncounterDiagnosis);
begin
    ParseBackboneElementProperties(obj, result);
    result.condition := ParseReference{TFhirCondition}(obj.complex('http://hl7.org/fhir/Encounter.diagnosis.condition'));{q3b}
    result.use := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Encounter.diagnosis.use'));{q3b}
    result.rankElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Encounter.diagnosis.rank'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeEncounterDiagnosis(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEncounterDiagnosis; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EncounterDiagnosis'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeReference{TFhirCondition}(this, 'Encounter.diagnosis', 'condition', elem.conditionElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Encounter.diagnosis', 'use', elem.useElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(this, 'Encounter.diagnosis', 'rank', elem.rankElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseEncounterHospitalization(obj : TTurtleComplex) : TFhirEncounterHospitalization;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEncounterHospitalization.create;
  try
    ParseEncounterHospitalizationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEncounterHospitalizationProperties(obj : TTurtleComplex; result : TFhirEncounterHospitalization);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.preAdmissionIdentifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/Encounter.hospitalization.preAdmissionIdentifier'));{q3b}
    result.origin := ParseReference{TFhirLocation}(obj.complex('http://hl7.org/fhir/Encounter.hospitalization.origin'));{q3b}
    result.admitSource := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Encounter.hospitalization.admitSource'));{q3b}
    result.reAdmission := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Encounter.hospitalization.reAdmission'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Encounter.hospitalization.dietPreference') do
      result.dietPreferenceList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Encounter.hospitalization.specialCourtesy') do
      result.specialCourtesyList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Encounter.hospitalization.specialArrangement') do
      result.specialArrangementList.Add(parseCodeableConcept(item));
    result.destination := ParseReference{TFhirLocation}(obj.complex('http://hl7.org/fhir/Encounter.hospitalization.destination'));{q3b}
    result.dischargeDisposition := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Encounter.hospitalization.dischargeDisposition'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeEncounterHospitalization(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEncounterHospitalization; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EncounterHospitalization'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(this, 'Encounter.hospitalization', 'preAdmissionIdentifier', elem.preAdmissionIdentifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirLocation}(this, 'Encounter.hospitalization', 'origin', elem.originElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Encounter.hospitalization', 'admitSource', elem.admitSourceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Encounter.hospitalization', 'reAdmission', elem.reAdmissionElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.dietPreferenceList.Count - 1 do
      ComposeCodeableConcept(this, 'Encounter.hospitalization', 'dietPreference', elem.dietPreferenceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.specialCourtesyList.Count - 1 do
      ComposeCodeableConcept(this, 'Encounter.hospitalization', 'specialCourtesy', elem.specialCourtesyList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.specialArrangementList.Count - 1 do
      ComposeCodeableConcept(this, 'Encounter.hospitalization', 'specialArrangement', elem.specialArrangementList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirLocation}(this, 'Encounter.hospitalization', 'destination', elem.destinationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Encounter.hospitalization', 'dischargeDisposition', elem.dischargeDispositionElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseEncounterLocation(obj : TTurtleComplex) : TFhirEncounterLocation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEncounterLocation.create;
  try
    ParseEncounterLocationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEncounterLocationProperties(obj : TTurtleComplex; result : TFhirEncounterLocation);
begin
    ParseBackboneElementProperties(obj, result);
    result.location := ParseReference{TFhirLocation}(obj.complex('http://hl7.org/fhir/Encounter.location.location'));{q3b}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Encounter.location.status'), CODES_TFhirEncounterLocationStatusEnum, SYSTEMS_TFhirEncounterLocationStatusEnum);
    result.physicalType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Encounter.location.physicalType'));{q3b}
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Encounter.location.period'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeEncounterLocation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEncounterLocation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EncounterLocation'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeReference{TFhirLocation}(this, 'Encounter.location', 'location', elem.locationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'Encounter.location', 'status', elem.StatusElement, CODES_TFhirEncounterLocationStatusEnum, SYSTEMS_TFhirEncounterLocationStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Encounter.location', 'physicalType', elem.physicalTypeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'Encounter.location', 'period', elem.periodElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseEncounter(obj : TTurtleComplex) : TFhirEncounter;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEncounter.create;
  try
    ParseEncounterProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEncounterProperties(obj : TTurtleComplex; result : TFhirEncounter);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Encounter.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Encounter.status'), CODES_TFhirEncounterStatusEnum, SYSTEMS_TFhirEncounterStatusEnum);
    for item in obj.complexes('http://hl7.org/fhir/Encounter.statusHistory') do
      result.statusHistoryList.Add(parseEncounterStatusHistory(item));
    result.class_ := ParseCoding(obj.complex('http://hl7.org/fhir/Encounter.class'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Encounter.classHistory') do
      result.classHistoryList.Add(parseEncounterClassHistory(item));
    for item in obj.complexes('http://hl7.org/fhir/Encounter.type') do
      result.type_List.Add(parseCodeableConcept(item));
    result.serviceType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Encounter.serviceType'));{q3b}
    result.priority := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Encounter.priority'));{q3b}
    result.subject := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/Encounter.subject'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Encounter.episodeOfCare') do
      result.episodeOfCareList.Add(parseReference{TFhirEpisodeOfCare}(item));
    for item in obj.complexes('http://hl7.org/fhir/Encounter.basedOn') do
      result.basedOnList.Add(parseReference{TFhirServiceRequest}(item));
    for item in obj.complexes('http://hl7.org/fhir/Encounter.participant') do
      result.participantList.Add(parseEncounterParticipant(item));
    for item in obj.complexes('http://hl7.org/fhir/Encounter.appointment') do
      result.appointmentList.Add(parseReference{TFhirAppointment}(item));
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Encounter.period'));{q3b}
    result.length := ParseDuration(obj.complex('http://hl7.org/fhir/Encounter.length'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Encounter.reasonCode') do
      result.reasonCodeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Encounter.reasonReference') do
      result.reasonReferenceList.Add(parseReference{TFhirCondition}(item));
    for item in obj.complexes('http://hl7.org/fhir/Encounter.diagnosis') do
      result.diagnosisList.Add(parseEncounterDiagnosis(item));
    for item in obj.complexes('http://hl7.org/fhir/Encounter.account') do
      result.accountList.Add(parseReference{TFhirAccount}(item));
    result.hospitalization := ParseEncounterHospitalization(obj.complex('http://hl7.org/fhir/Encounter.hospitalization'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Encounter.location') do
      result.locationList.Add(parseEncounterLocation(item));
    result.serviceProvider := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/Encounter.serviceProvider'));{q3b}
    result.partOf := ParseReference{TFhirEncounter}(obj.complex('http://hl7.org/fhir/Encounter.partOf'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeEncounter(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEncounter; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Encounter'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Encounter', 'identifier', elem.identifierList[i], false, i);{x.d3}
  ComposeEnum(this, 'Encounter', 'status', elem.StatusElement, CODES_TFhirEncounterStatusEnum, SYSTEMS_TFhirEncounterStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('statusHistory') then
    for i := 0 to elem.statusHistoryList.Count - 1 do
      ComposeEncounterStatusHistory(this, 'Encounter', 'statusHistory', elem.statusHistoryList[i], false, i);{x.d3}
  ComposeCoding(this, 'Encounter', 'class', elem.class_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('classHistory') then
    for i := 0 to elem.classHistoryList.Count - 1 do
      ComposeEncounterClassHistory(this, 'Encounter', 'classHistory', elem.classHistoryList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(this, 'Encounter', 'type', elem.type_List[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('serviceType') then
    ComposeCodeableConcept(this, 'Encounter', 'serviceType', elem.serviceTypeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('priority') then
    ComposeCodeableConcept(this, 'Encounter', 'priority', elem.priorityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{TFhirPatient}(this, 'Encounter', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('episodeOfCare') then
    for i := 0 to elem.episodeOfCareList.Count - 1 do
      ComposeReference{TFhirEpisodeOfCare}(this, 'Encounter', 'episodeOfCare', elem.episodeOfCareList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('basedOn') then
    for i := 0 to elem.basedOnList.Count - 1 do
      ComposeReference{TFhirServiceRequest}(this, 'Encounter', 'basedOn', elem.basedOnList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('participant') then
    for i := 0 to elem.participantList.Count - 1 do
      ComposeEncounterParticipant(this, 'Encounter', 'participant', elem.participantList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('appointment') then
    for i := 0 to elem.appointmentList.Count - 1 do
      ComposeReference{TFhirAppointment}(this, 'Encounter', 'appointment', elem.appointmentList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('period') then
    ComposePeriod(this, 'Encounter', 'period', elem.periodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('length') then
    ComposeDuration(this, 'Encounter', 'length', elem.lengthElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonCode') then
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'Encounter', 'reasonCode', elem.reasonCodeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonReference') then
    for i := 0 to elem.reasonReferenceList.Count - 1 do
      ComposeReference{TFhirCondition}(this, 'Encounter', 'reasonReference', elem.reasonReferenceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('diagnosis') then
    for i := 0 to elem.diagnosisList.Count - 1 do
      ComposeEncounterDiagnosis(this, 'Encounter', 'diagnosis', elem.diagnosisList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('account') then
    for i := 0 to elem.accountList.Count - 1 do
      ComposeReference{TFhirAccount}(this, 'Encounter', 'account', elem.accountList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('hospitalization') then
    ComposeEncounterHospitalization(this, 'Encounter', 'hospitalization', elem.hospitalizationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('location') then
    for i := 0 to elem.locationList.Count - 1 do
      ComposeEncounterLocation(this, 'Encounter', 'location', elem.locationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('serviceProvider') then
    ComposeReference{TFhirOrganization}(this, 'Encounter', 'serviceProvider', elem.serviceProviderElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('partOf') then
    ComposeReference{TFhirEncounter}(this, 'Encounter', 'partOf', elem.partOfElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_ENCOUNTER}
{$IFDEF FHIR_ENDPOINT}
function TFHIRTurtleParser.ParseEndpoint(obj : TTurtleComplex) : TFhirEndpoint;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEndpoint.create;
  try
    ParseEndpointProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEndpointProperties(obj : TTurtleComplex; result : TFhirEndpoint);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Endpoint.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Endpoint.status'), CODES_TFhirEndpointStatusEnum, SYSTEMS_TFhirEndpointStatusEnum);
    result.connectionType := ParseCoding(obj.complex('http://hl7.org/fhir/Endpoint.connectionType'));{q3b}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/Endpoint.name'));{q1}
    result.managingOrganization := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/Endpoint.managingOrganization'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Endpoint.contact') do
      result.contactList.Add(parseContactPoint(item));
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Endpoint.period'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Endpoint.payloadType') do
      result.payloadTypeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Endpoint.payloadMimeType') do
      result.payloadMimeTypeList.Add(parseCode(item));
    result.addressElement := ParseUrl(obj.complex('http://hl7.org/fhir/Endpoint.address'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Endpoint.header') do
      result.headerList.Add(parseString(item));
end;

procedure TFHIRTurtleComposer.ComposeEndpoint(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEndpoint; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Endpoint'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Endpoint', 'identifier', elem.identifierList[i], false, i);{x.d3}
  ComposeEnum(this, 'Endpoint', 'status', elem.StatusElement, CODES_TFhirEndpointStatusEnum, SYSTEMS_TFhirEndpointStatusEnum, false, -1);{x.d4}
  ComposeCoding(this, 'Endpoint', 'connectionType', elem.connectionTypeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(this, 'Endpoint', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('managingOrganization') then
    ComposeReference{TFhirOrganization}(this, 'Endpoint', 'managingOrganization', elem.managingOrganizationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactPoint(this, 'Endpoint', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('period') then
    ComposePeriod(this, 'Endpoint', 'period', elem.periodElement, false, -1);{x.2f}
  for i := 0 to elem.payloadTypeList.Count - 1 do
      ComposeCodeableConcept(this, 'Endpoint', 'payloadType', elem.payloadTypeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('payloadMimeType') then
    for i := 0 to elem.payloadMimeTypeList.Count - 1 do
      ComposeCode(this, 'Endpoint', 'payloadMimeType', elem.payloadMimeTypeList[i], false, i);{x.d3}
  ComposeUrl(this, 'Endpoint', 'address', elem.addressElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('header') then
    for i := 0 to elem.headerList.Count - 1 do
      ComposeString(this, 'Endpoint', 'header', elem.headerList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_ENDPOINT}
{$IFDEF FHIR_ENROLLMENTREQUEST}
function TFHIRTurtleParser.ParseEnrollmentRequest(obj : TTurtleComplex) : TFhirEnrollmentRequest;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEnrollmentRequest.create;
  try
    ParseEnrollmentRequestProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEnrollmentRequestProperties(obj : TTurtleComplex; result : TFhirEnrollmentRequest);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/EnrollmentRequest.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/EnrollmentRequest.status'), CODES_TFhirFmStatusEnum, SYSTEMS_TFhirFmStatusEnum);
    result.createdElement := ParseDateTime(obj.complex('http://hl7.org/fhir/EnrollmentRequest.created'));{q1}
    result.insurer := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/EnrollmentRequest.insurer'));{q3b}
    result.provider := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/EnrollmentRequest.provider'));{q3b}
    result.candidate := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/EnrollmentRequest.candidate'));{q3b}
    result.coverage := ParseReference{TFhirCoverage}(obj.complex('http://hl7.org/fhir/EnrollmentRequest.coverage'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeEnrollmentRequest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEnrollmentRequest; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EnrollmentRequest'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'EnrollmentRequest', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(this, 'EnrollmentRequest', 'status', elem.StatusElement, CODES_TFhirFmStatusEnum, SYSTEMS_TFhirFmStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('created') then
    ComposeDateTime(this, 'EnrollmentRequest', 'created', elem.createdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('insurer') then
    ComposeReference{TFhirOrganization}(this, 'EnrollmentRequest', 'insurer', elem.insurerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('provider') then
    ComposeReference{TFhirPractitioner}(this, 'EnrollmentRequest', 'provider', elem.providerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('candidate') then
    ComposeReference{TFhirPatient}(this, 'EnrollmentRequest', 'candidate', elem.candidateElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('coverage') then
    ComposeReference{TFhirCoverage}(this, 'EnrollmentRequest', 'coverage', elem.coverageElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_ENROLLMENTREQUEST}
{$IFDEF FHIR_ENROLLMENTRESPONSE}
function TFHIRTurtleParser.ParseEnrollmentResponse(obj : TTurtleComplex) : TFhirEnrollmentResponse;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEnrollmentResponse.create;
  try
    ParseEnrollmentResponseProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEnrollmentResponseProperties(obj : TTurtleComplex; result : TFhirEnrollmentResponse);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/EnrollmentResponse.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/EnrollmentResponse.status'), CODES_TFhirFmStatusEnum, SYSTEMS_TFhirFmStatusEnum);
    result.request := ParseReference{TFhirEnrollmentRequest}(obj.complex('http://hl7.org/fhir/EnrollmentResponse.request'));{q3b}
    result.outcomeElement := ParseEnum(obj.complex('http://hl7.org/fhir/EnrollmentResponse.outcome'), CODES_TFhirRemittanceOutcomeEnum, SYSTEMS_TFhirRemittanceOutcomeEnum);
    result.dispositionElement := ParseString(obj.complex('http://hl7.org/fhir/EnrollmentResponse.disposition'));{q1}
    result.createdElement := ParseDateTime(obj.complex('http://hl7.org/fhir/EnrollmentResponse.created'));{q1}
    result.organization := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/EnrollmentResponse.organization'));{q3b}
    result.requestProvider := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/EnrollmentResponse.requestProvider'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeEnrollmentResponse(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEnrollmentResponse; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EnrollmentResponse'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'EnrollmentResponse', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(this, 'EnrollmentResponse', 'status', elem.StatusElement, CODES_TFhirFmStatusEnum, SYSTEMS_TFhirFmStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('request') then
    ComposeReference{TFhirEnrollmentRequest}(this, 'EnrollmentResponse', 'request', elem.requestElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('outcome') then
    ComposeEnum(this, 'EnrollmentResponse', 'outcome', elem.OutcomeElement, CODES_TFhirRemittanceOutcomeEnum, SYSTEMS_TFhirRemittanceOutcomeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('disposition') then
    ComposeString(this, 'EnrollmentResponse', 'disposition', elem.dispositionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('created') then
    ComposeDateTime(this, 'EnrollmentResponse', 'created', elem.createdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('organization') then
    ComposeReference{TFhirOrganization}(this, 'EnrollmentResponse', 'organization', elem.organizationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('requestProvider') then
    ComposeReference{TFhirPractitioner}(this, 'EnrollmentResponse', 'requestProvider', elem.requestProviderElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_ENROLLMENTRESPONSE}
{$IFDEF FHIR_EPISODEOFCARE}
function TFHIRTurtleParser.ParseEpisodeOfCareStatusHistory(obj : TTurtleComplex) : TFhirEpisodeOfCareStatusHistory;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEpisodeOfCareStatusHistory.create;
  try
    ParseEpisodeOfCareStatusHistoryProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEpisodeOfCareStatusHistoryProperties(obj : TTurtleComplex; result : TFhirEpisodeOfCareStatusHistory);
begin
    ParseBackboneElementProperties(obj, result);
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/EpisodeOfCare.statusHistory.status'), CODES_TFhirEpisodeOfCareStatusEnum, SYSTEMS_TFhirEpisodeOfCareStatusEnum);
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/EpisodeOfCare.statusHistory.period'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeEpisodeOfCareStatusHistory(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEpisodeOfCareStatusHistory; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EpisodeOfCareStatusHistory'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'EpisodeOfCare.statusHistory', 'status', elem.StatusElement, CODES_TFhirEpisodeOfCareStatusEnum, SYSTEMS_TFhirEpisodeOfCareStatusEnum, false, -1);{x.d4}
  ComposePeriod(this, 'EpisodeOfCare.statusHistory', 'period', elem.periodElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseEpisodeOfCareDiagnosis(obj : TTurtleComplex) : TFhirEpisodeOfCareDiagnosis;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEpisodeOfCareDiagnosis.create;
  try
    ParseEpisodeOfCareDiagnosisProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEpisodeOfCareDiagnosisProperties(obj : TTurtleComplex; result : TFhirEpisodeOfCareDiagnosis);
begin
    ParseBackboneElementProperties(obj, result);
    result.condition := ParseReference{TFhirCondition}(obj.complex('http://hl7.org/fhir/EpisodeOfCare.diagnosis.condition'));{q3b}
    result.role := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/EpisodeOfCare.diagnosis.role'));{q3b}
    result.rankElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/EpisodeOfCare.diagnosis.rank'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeEpisodeOfCareDiagnosis(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEpisodeOfCareDiagnosis; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EpisodeOfCareDiagnosis'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeReference{TFhirCondition}(this, 'EpisodeOfCare.diagnosis', 'condition', elem.conditionElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'EpisodeOfCare.diagnosis', 'role', elem.roleElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(this, 'EpisodeOfCare.diagnosis', 'rank', elem.rankElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseEpisodeOfCare(obj : TTurtleComplex) : TFhirEpisodeOfCare;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEpisodeOfCare.create;
  try
    ParseEpisodeOfCareProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEpisodeOfCareProperties(obj : TTurtleComplex; result : TFhirEpisodeOfCare);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/EpisodeOfCare.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/EpisodeOfCare.status'), CODES_TFhirEpisodeOfCareStatusEnum, SYSTEMS_TFhirEpisodeOfCareStatusEnum);
    for item in obj.complexes('http://hl7.org/fhir/EpisodeOfCare.statusHistory') do
      result.statusHistoryList.Add(parseEpisodeOfCareStatusHistory(item));
    for item in obj.complexes('http://hl7.org/fhir/EpisodeOfCare.type') do
      result.type_List.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/EpisodeOfCare.diagnosis') do
      result.diagnosisList.Add(parseEpisodeOfCareDiagnosis(item));
    result.patient := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/EpisodeOfCare.patient'));{q3b}
    result.managingOrganization := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/EpisodeOfCare.managingOrganization'));{q3b}
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/EpisodeOfCare.period'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/EpisodeOfCare.referralRequest') do
      result.referralRequestList.Add(parseReference{TFhirServiceRequest}(item));
    result.careManager := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/EpisodeOfCare.careManager'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/EpisodeOfCare.team') do
      result.teamList.Add(parseReference{TFhirCareTeam}(item));
    for item in obj.complexes('http://hl7.org/fhir/EpisodeOfCare.account') do
      result.accountList.Add(parseReference{TFhirAccount}(item));
end;

procedure TFHIRTurtleComposer.ComposeEpisodeOfCare(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEpisodeOfCare; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EpisodeOfCare'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'EpisodeOfCare', 'identifier', elem.identifierList[i], false, i);{x.d3}
  ComposeEnum(this, 'EpisodeOfCare', 'status', elem.StatusElement, CODES_TFhirEpisodeOfCareStatusEnum, SYSTEMS_TFhirEpisodeOfCareStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('statusHistory') then
    for i := 0 to elem.statusHistoryList.Count - 1 do
      ComposeEpisodeOfCareStatusHistory(this, 'EpisodeOfCare', 'statusHistory', elem.statusHistoryList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(this, 'EpisodeOfCare', 'type', elem.type_List[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('diagnosis') then
    for i := 0 to elem.diagnosisList.Count - 1 do
      ComposeEpisodeOfCareDiagnosis(this, 'EpisodeOfCare', 'diagnosis', elem.diagnosisList[i], false, i);{x.d3}
  ComposeReference{TFhirPatient}(this, 'EpisodeOfCare', 'patient', elem.patientElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('managingOrganization') then
    ComposeReference{TFhirOrganization}(this, 'EpisodeOfCare', 'managingOrganization', elem.managingOrganizationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('period') then
    ComposePeriod(this, 'EpisodeOfCare', 'period', elem.periodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('referralRequest') then
    for i := 0 to elem.referralRequestList.Count - 1 do
      ComposeReference{TFhirServiceRequest}(this, 'EpisodeOfCare', 'referralRequest', elem.referralRequestList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('careManager') then
    ComposeReference{TFhirPractitioner}(this, 'EpisodeOfCare', 'careManager', elem.careManagerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('team') then
    for i := 0 to elem.teamList.Count - 1 do
      ComposeReference{TFhirCareTeam}(this, 'EpisodeOfCare', 'team', elem.teamList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('account') then
    for i := 0 to elem.accountList.Count - 1 do
      ComposeReference{TFhirAccount}(this, 'EpisodeOfCare', 'account', elem.accountList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_EPISODEOFCARE}
{$IFDEF FHIR_EVENTDEFINITION}
function TFHIRTurtleParser.ParseEventDefinition(obj : TTurtleComplex) : TFhirEventDefinition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEventDefinition.create;
  try
    ParseEventDefinitionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEventDefinitionProperties(obj : TTurtleComplex; result : TFhirEventDefinition);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/EventDefinition.url'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/EventDefinition.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/EventDefinition.version'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/EventDefinition.name'));{q1}
    result.titleElement := ParseString(obj.complex('http://hl7.org/fhir/EventDefinition.title'));{q1}
    result.subtitleElement := ParseString(obj.complex('http://hl7.org/fhir/EventDefinition.subtitle'));{q1}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/EventDefinition.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    result.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/EventDefinition.experimental'));{q1}
    if obj.has('http://hl7.org/fhir/EventDefinition.subjectCodeableConcept', item) then
      result.subject := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/EventDefinition.subjectReference', item) {a3} then
      result.subject := ParseReference(item);
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/EventDefinition.date'));{q1}
    result.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/EventDefinition.publisher'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/EventDefinition.contact') do
      result.contactList.Add(parseContactDetail(item));
    result.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/EventDefinition.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/EventDefinition.useContext') do
      result.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/EventDefinition.jurisdiction') do
      result.jurisdictionList.Add(parseCodeableConcept(item));
    result.purposeElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/EventDefinition.purpose'));{q1}
    result.usageElement := ParseString(obj.complex('http://hl7.org/fhir/EventDefinition.usage'));{q1}
    result.copyrightElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/EventDefinition.copyright'));{q1}
    result.approvalDateElement := ParseDate(obj.complex('http://hl7.org/fhir/EventDefinition.approvalDate'));{q1}
    result.lastReviewDateElement := ParseDate(obj.complex('http://hl7.org/fhir/EventDefinition.lastReviewDate'));{q1}
    result.effectivePeriod := ParsePeriod(obj.complex('http://hl7.org/fhir/EventDefinition.effectivePeriod'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/EventDefinition.topic') do
      result.topicList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/EventDefinition.author') do
      result.authorList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/EventDefinition.editor') do
      result.editorList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/EventDefinition.reviewer') do
      result.reviewerList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/EventDefinition.endorser') do
      result.endorserList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/EventDefinition.relatedArtifact') do
      result.relatedArtifactList.Add(parseRelatedArtifact(item));
    for item in obj.complexes('http://hl7.org/fhir/EventDefinition.trigger') do
      result.triggerList.Add(parseTriggerDefinition(item));
end;

procedure TFHIRTurtleComposer.ComposeEventDefinition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEventDefinition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EventDefinition'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUri(this, 'EventDefinition', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'EventDefinition', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(this, 'EventDefinition', 'version', elem.versionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(this, 'EventDefinition', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeString(this, 'EventDefinition', 'title', elem.titleElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('subtitle') then
    ComposeString(this, 'EventDefinition', 'subtitle', elem.subtitleElement, false, -1);{x.2ea}
  ComposeEnum(this, 'EventDefinition', 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(this, 'EventDefinition', 'experimental', elem.experimentalElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and (elem.subject is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'EventDefinition', 'subjectCodeableConcept', TFhirCodeableConcept(elem.subject), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.subject is TFhirReference) {2} then
    ComposeReference(this, 'EventDefinition', 'subjectReference', TFhirReference(elem.subject), false,-1);{x.d8}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(this, 'EventDefinition', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(this, 'EventDefinition', 'publisher', elem.publisherElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(this, 'EventDefinition', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdown(this, 'EventDefinition', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(this, 'EventDefinition', 'useContext', elem.useContextList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'EventDefinition', 'jurisdiction', elem.jurisdictionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdown(this, 'EventDefinition', 'purpose', elem.purposeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('usage') then
    ComposeString(this, 'EventDefinition', 'usage', elem.usageElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdown(this, 'EventDefinition', 'copyright', elem.copyrightElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('approvalDate') then
    ComposeDate(this, 'EventDefinition', 'approvalDate', elem.approvalDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('lastReviewDate') then
    ComposeDate(this, 'EventDefinition', 'lastReviewDate', elem.lastReviewDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('effectivePeriod') then
    ComposePeriod(this, 'EventDefinition', 'effectivePeriod', elem.effectivePeriodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('topic') then
    for i := 0 to elem.topicList.Count - 1 do
      ComposeCodeableConcept(this, 'EventDefinition', 'topic', elem.topicList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('author') then
    for i := 0 to elem.authorList.Count - 1 do
      ComposeContactDetail(this, 'EventDefinition', 'author', elem.authorList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('editor') then
    for i := 0 to elem.editorList.Count - 1 do
      ComposeContactDetail(this, 'EventDefinition', 'editor', elem.editorList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('reviewer') then
    for i := 0 to elem.reviewerList.Count - 1 do
      ComposeContactDetail(this, 'EventDefinition', 'reviewer', elem.reviewerList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('endorser') then
    for i := 0 to elem.endorserList.Count - 1 do
      ComposeContactDetail(this, 'EventDefinition', 'endorser', elem.endorserList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('relatedArtifact') then
    for i := 0 to elem.relatedArtifactList.Count - 1 do
      ComposeRelatedArtifact(this, 'EventDefinition', 'relatedArtifact', elem.relatedArtifactList[i], false, i);{x.d3}
  for i := 0 to elem.triggerList.Count - 1 do
      ComposeTriggerDefinition(this, 'EventDefinition', 'trigger', elem.triggerList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_EVENTDEFINITION}
{$IFDEF FHIR_EVIDENCE}
function TFHIRTurtleParser.ParseEvidence(obj : TTurtleComplex) : TFhirEvidence;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEvidence.create;
  try
    ParseEvidenceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEvidenceProperties(obj : TTurtleComplex; result : TFhirEvidence);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/Evidence.url'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Evidence.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/Evidence.version'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/Evidence.name'));{q1}
    result.titleElement := ParseString(obj.complex('http://hl7.org/fhir/Evidence.title'));{q1}
    result.shortTitleElement := ParseString(obj.complex('http://hl7.org/fhir/Evidence.shortTitle'));{q1}
    result.subtitleElement := ParseString(obj.complex('http://hl7.org/fhir/Evidence.subtitle'));{q1}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Evidence.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Evidence.date'));{q1}
    result.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/Evidence.publisher'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Evidence.contact') do
      result.contactList.Add(parseContactDetail(item));
    result.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/Evidence.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Evidence.note') do
      result.noteList.Add(parseAnnotation(item));
    for item in obj.complexes('http://hl7.org/fhir/Evidence.useContext') do
      result.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/Evidence.jurisdiction') do
      result.jurisdictionList.Add(parseCodeableConcept(item));
    result.copyrightElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/Evidence.copyright'));{q1}
    result.approvalDateElement := ParseDate(obj.complex('http://hl7.org/fhir/Evidence.approvalDate'));{q1}
    result.lastReviewDateElement := ParseDate(obj.complex('http://hl7.org/fhir/Evidence.lastReviewDate'));{q1}
    result.effectivePeriod := ParsePeriod(obj.complex('http://hl7.org/fhir/Evidence.effectivePeriod'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Evidence.topic') do
      result.topicList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Evidence.author') do
      result.authorList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/Evidence.editor') do
      result.editorList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/Evidence.reviewer') do
      result.reviewerList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/Evidence.endorser') do
      result.endorserList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/Evidence.relatedArtifact') do
      result.relatedArtifactList.Add(parseRelatedArtifact(item));
    result.exposureBackground := ParseReference{TFhirEvidenceVariable}(obj.complex('http://hl7.org/fhir/Evidence.exposureBackground'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Evidence.exposureVariant') do
      result.exposureVariantList.Add(parseReference{TFhirEvidenceVariable}(item));
    for item in obj.complexes('http://hl7.org/fhir/Evidence.outcome') do
      result.outcomeList.Add(parseReference{TFhirEvidenceVariable}(item));
end;

procedure TFHIRTurtleComposer.ComposeEvidence(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEvidence; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Evidence'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUri(this, 'Evidence', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Evidence', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(this, 'Evidence', 'version', elem.versionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(this, 'Evidence', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeString(this, 'Evidence', 'title', elem.titleElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('shortTitle') then
    ComposeString(this, 'Evidence', 'shortTitle', elem.shortTitleElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('subtitle') then
    ComposeString(this, 'Evidence', 'subtitle', elem.subtitleElement, false, -1);{x.2ea}
  ComposeEnum(this, 'Evidence', 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(this, 'Evidence', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(this, 'Evidence', 'publisher', elem.publisherElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(this, 'Evidence', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeMarkdown(this, 'Evidence', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'Evidence', 'note', elem.noteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(this, 'Evidence', 'useContext', elem.useContextList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'Evidence', 'jurisdiction', elem.jurisdictionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdown(this, 'Evidence', 'copyright', elem.copyrightElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('approvalDate') then
    ComposeDate(this, 'Evidence', 'approvalDate', elem.approvalDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('lastReviewDate') then
    ComposeDate(this, 'Evidence', 'lastReviewDate', elem.lastReviewDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('effectivePeriod') then
    ComposePeriod(this, 'Evidence', 'effectivePeriod', elem.effectivePeriodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('topic') then
    for i := 0 to elem.topicList.Count - 1 do
      ComposeCodeableConcept(this, 'Evidence', 'topic', elem.topicList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('author') then
    for i := 0 to elem.authorList.Count - 1 do
      ComposeContactDetail(this, 'Evidence', 'author', elem.authorList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('editor') then
    for i := 0 to elem.editorList.Count - 1 do
      ComposeContactDetail(this, 'Evidence', 'editor', elem.editorList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('reviewer') then
    for i := 0 to elem.reviewerList.Count - 1 do
      ComposeContactDetail(this, 'Evidence', 'reviewer', elem.reviewerList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('endorser') then
    for i := 0 to elem.endorserList.Count - 1 do
      ComposeContactDetail(this, 'Evidence', 'endorser', elem.endorserList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('relatedArtifact') then
    for i := 0 to elem.relatedArtifactList.Count - 1 do
      ComposeRelatedArtifact(this, 'Evidence', 'relatedArtifact', elem.relatedArtifactList[i], false, i);{x.d3}
  ComposeReference{TFhirEvidenceVariable}(this, 'Evidence', 'exposureBackground', elem.exposureBackgroundElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('exposureVariant') then
    for i := 0 to elem.exposureVariantList.Count - 1 do
      ComposeReference{TFhirEvidenceVariable}(this, 'Evidence', 'exposureVariant', elem.exposureVariantList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('outcome') then
    for i := 0 to elem.outcomeList.Count - 1 do
      ComposeReference{TFhirEvidenceVariable}(this, 'Evidence', 'outcome', elem.outcomeList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_EVIDENCE}
{$IFDEF FHIR_EVIDENCEVARIABLE}
function TFHIRTurtleParser.ParseEvidenceVariableCharacteristic(obj : TTurtleComplex) : TFhirEvidenceVariableCharacteristic;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEvidenceVariableCharacteristic.create;
  try
    ParseEvidenceVariableCharacteristicProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEvidenceVariableCharacteristicProperties(obj : TTurtleComplex; result : TFhirEvidenceVariableCharacteristic);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/EvidenceVariable.characteristic.description'));{q1}
    if obj.has('http://hl7.org/fhir/EvidenceVariable.characteristic.definitionReference', item) {a3} then
      result.definition := ParseReference(item);
    if obj.has('http://hl7.org/fhir/EvidenceVariable.characteristic.definitionCanonical', item) then
      result.definition := parseCanonical(item);
    if obj.has('http://hl7.org/fhir/EvidenceVariable.characteristic.definitionCodeableConcept', item) then
      result.definition := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/EvidenceVariable.characteristic.definitionExpression', item) then
      result.definition := parseExpression(item);
    if obj.has('http://hl7.org/fhir/EvidenceVariable.characteristic.definitionDataRequirement', item) then
      result.definition := parseDataRequirement(item);
    if obj.has('http://hl7.org/fhir/EvidenceVariable.characteristic.definitionTriggerDefinition', item) then
      result.definition := parseTriggerDefinition(item);
    for item in obj.complexes('http://hl7.org/fhir/EvidenceVariable.characteristic.usageContext') do
      result.usageContextList.Add(parseUsageContext(item));
    result.excludeElement := ParseBoolean(obj.complex('http://hl7.org/fhir/EvidenceVariable.characteristic.exclude'));{q1}
    if obj.has('http://hl7.org/fhir/EvidenceVariable.characteristic.participantEffectivePeriod', item) then
      result.participantEffective := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/EvidenceVariable.characteristic.participantEffectiveDuration', item) then
      result.participantEffective := parseDuration(item);
    if obj.has('http://hl7.org/fhir/EvidenceVariable.characteristic.participantEffectiveTiming', item) then
      result.participantEffective := parseTiming(item);
    if obj.has('http://hl7.org/fhir/EvidenceVariable.characteristic.participantEffectiveDateTime', item) then
      result.participantEffective := parseDateTime(item);
    result.timeFromStart := ParseDuration(obj.complex('http://hl7.org/fhir/EvidenceVariable.characteristic.timeFromStart'));{q3b}
    result.groupMeasureElement := ParseEnum(obj.complex('http://hl7.org/fhir/EvidenceVariable.characteristic.groupMeasure'), CODES_TFhirGroupMeasureEnum, SYSTEMS_TFhirGroupMeasureEnum);
end;

procedure TFHIRTurtleComposer.ComposeEvidenceVariableCharacteristic(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEvidenceVariableCharacteristic; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EvidenceVariableCharacteristic'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'EvidenceVariable.characteristic', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (elem.definition is TFhirReference) {2} then
    ComposeReference(this, 'EvidenceVariable.characteristic', 'definitionReference', TFhirReference(elem.definition), false,-1){x.d8}
  else if (elem.definition is TFhirCanonical) {6} then
    ComposeCanonical(this, 'EvidenceVariable.characteristic', 'definitionCanonical', TFhirCanonical(elem.definition), false, -1){x.d9}
  else if (elem.definition is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'EvidenceVariable.characteristic', 'definitionCodeableConcept', TFhirCodeableConcept(elem.definition), false, -1){x.d9}
  else if (elem.definition is TFhirExpression) {6} then
    ComposeExpression(this, 'EvidenceVariable.characteristic', 'definitionExpression', TFhirExpression(elem.definition), false, -1){x.d9}
  else if (elem.definition is TFhirDataRequirement) {6} then
    ComposeDataRequirement(this, 'EvidenceVariable.characteristic', 'definitionDataRequirement', TFhirDataRequirement(elem.definition), false, -1){x.d9}
  else if (elem.definition is TFhirTriggerDefinition) {6} then
    ComposeTriggerDefinition(this, 'EvidenceVariable.characteristic', 'definitionTriggerDefinition', TFhirTriggerDefinition(elem.definition), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.usageContextList.Count - 1 do
      ComposeUsageContext(this, 'EvidenceVariable.characteristic', 'usageContext', elem.usageContextList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'EvidenceVariable.characteristic', 'exclude', elem.excludeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and (elem.participantEffective is TFhirPeriod) {6} then
    ComposePeriod(this, 'EvidenceVariable.characteristic', 'participantEffectivePeriod', TFhirPeriod(elem.participantEffective), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.participantEffective is TFhirDuration) {6} then
    ComposeDuration(this, 'EvidenceVariable.characteristic', 'participantEffectiveDuration', TFhirDuration(elem.participantEffective), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.participantEffective is TFhirTiming) {6} then
    ComposeTiming(this, 'EvidenceVariable.characteristic', 'participantEffectiveTiming', TFhirTiming(elem.participantEffective), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.participantEffective is TFhirDateTime) {6} then
    ComposeDateTime(this, 'EvidenceVariable.characteristic', 'participantEffectiveDateTime', TFhirDateTime(elem.participantEffective), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) then
    ComposeDuration(this, 'EvidenceVariable.characteristic', 'timeFromStart', elem.timeFromStartElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'EvidenceVariable.characteristic', 'groupMeasure', elem.GroupMeasureElement, CODES_TFhirGroupMeasureEnum, SYSTEMS_TFhirGroupMeasureEnum, false, -1);{x.d4}
end;

function TFHIRTurtleParser.ParseEvidenceVariable(obj : TTurtleComplex) : TFhirEvidenceVariable;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirEvidenceVariable.create;
  try
    ParseEvidenceVariableProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseEvidenceVariableProperties(obj : TTurtleComplex; result : TFhirEvidenceVariable);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/EvidenceVariable.url'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/EvidenceVariable.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/EvidenceVariable.version'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/EvidenceVariable.name'));{q1}
    result.titleElement := ParseString(obj.complex('http://hl7.org/fhir/EvidenceVariable.title'));{q1}
    result.shortTitleElement := ParseString(obj.complex('http://hl7.org/fhir/EvidenceVariable.shortTitle'));{q1}
    result.subtitleElement := ParseString(obj.complex('http://hl7.org/fhir/EvidenceVariable.subtitle'));{q1}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/EvidenceVariable.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/EvidenceVariable.date'));{q1}
    result.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/EvidenceVariable.publisher'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/EvidenceVariable.contact') do
      result.contactList.Add(parseContactDetail(item));
    result.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/EvidenceVariable.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/EvidenceVariable.note') do
      result.noteList.Add(parseAnnotation(item));
    for item in obj.complexes('http://hl7.org/fhir/EvidenceVariable.useContext') do
      result.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/EvidenceVariable.jurisdiction') do
      result.jurisdictionList.Add(parseCodeableConcept(item));
    result.copyrightElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/EvidenceVariable.copyright'));{q1}
    result.approvalDateElement := ParseDate(obj.complex('http://hl7.org/fhir/EvidenceVariable.approvalDate'));{q1}
    result.lastReviewDateElement := ParseDate(obj.complex('http://hl7.org/fhir/EvidenceVariable.lastReviewDate'));{q1}
    result.effectivePeriod := ParsePeriod(obj.complex('http://hl7.org/fhir/EvidenceVariable.effectivePeriod'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/EvidenceVariable.topic') do
      result.topicList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/EvidenceVariable.author') do
      result.authorList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/EvidenceVariable.editor') do
      result.editorList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/EvidenceVariable.reviewer') do
      result.reviewerList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/EvidenceVariable.endorser') do
      result.endorserList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/EvidenceVariable.relatedArtifact') do
      result.relatedArtifactList.Add(parseRelatedArtifact(item));
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/EvidenceVariable.type'), CODES_TFhirVariableTypeEnum, SYSTEMS_TFhirVariableTypeEnum);
    for item in obj.complexes('http://hl7.org/fhir/EvidenceVariable.characteristic') do
      result.characteristicList.Add(parseEvidenceVariableCharacteristic(item));
end;

procedure TFHIRTurtleComposer.ComposeEvidenceVariable(parent :  TTurtleComplex; parentType, name : String; elem : TFhirEvidenceVariable; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:EvidenceVariable'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUri(this, 'EvidenceVariable', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'EvidenceVariable', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(this, 'EvidenceVariable', 'version', elem.versionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(this, 'EvidenceVariable', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeString(this, 'EvidenceVariable', 'title', elem.titleElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('shortTitle') then
    ComposeString(this, 'EvidenceVariable', 'shortTitle', elem.shortTitleElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('subtitle') then
    ComposeString(this, 'EvidenceVariable', 'subtitle', elem.subtitleElement, false, -1);{x.2ea}
  ComposeEnum(this, 'EvidenceVariable', 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(this, 'EvidenceVariable', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(this, 'EvidenceVariable', 'publisher', elem.publisherElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(this, 'EvidenceVariable', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeMarkdown(this, 'EvidenceVariable', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'EvidenceVariable', 'note', elem.noteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(this, 'EvidenceVariable', 'useContext', elem.useContextList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'EvidenceVariable', 'jurisdiction', elem.jurisdictionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdown(this, 'EvidenceVariable', 'copyright', elem.copyrightElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('approvalDate') then
    ComposeDate(this, 'EvidenceVariable', 'approvalDate', elem.approvalDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('lastReviewDate') then
    ComposeDate(this, 'EvidenceVariable', 'lastReviewDate', elem.lastReviewDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('effectivePeriod') then
    ComposePeriod(this, 'EvidenceVariable', 'effectivePeriod', elem.effectivePeriodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('topic') then
    for i := 0 to elem.topicList.Count - 1 do
      ComposeCodeableConcept(this, 'EvidenceVariable', 'topic', elem.topicList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('author') then
    for i := 0 to elem.authorList.Count - 1 do
      ComposeContactDetail(this, 'EvidenceVariable', 'author', elem.authorList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('editor') then
    for i := 0 to elem.editorList.Count - 1 do
      ComposeContactDetail(this, 'EvidenceVariable', 'editor', elem.editorList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('reviewer') then
    for i := 0 to elem.reviewerList.Count - 1 do
      ComposeContactDetail(this, 'EvidenceVariable', 'reviewer', elem.reviewerList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('endorser') then
    for i := 0 to elem.endorserList.Count - 1 do
      ComposeContactDetail(this, 'EvidenceVariable', 'endorser', elem.endorserList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('relatedArtifact') then
    for i := 0 to elem.relatedArtifactList.Count - 1 do
      ComposeRelatedArtifact(this, 'EvidenceVariable', 'relatedArtifact', elem.relatedArtifactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeEnum(this, 'EvidenceVariable', 'type', elem.Type_Element, CODES_TFhirVariableTypeEnum, SYSTEMS_TFhirVariableTypeEnum, false, -1);{x.d4}
  for i := 0 to elem.characteristicList.Count - 1 do
      ComposeEvidenceVariableCharacteristic(this, 'EvidenceVariable', 'characteristic', elem.characteristicList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_EVIDENCEVARIABLE}
{$IFDEF FHIR_EXAMPLESCENARIO}
function TFHIRTurtleParser.ParseExampleScenarioActor(obj : TTurtleComplex) : TFhirExampleScenarioActor;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExampleScenarioActor.create;
  try
    ParseExampleScenarioActorProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExampleScenarioActorProperties(obj : TTurtleComplex; result : TFhirExampleScenarioActor);
begin
    ParseBackboneElementProperties(obj, result);
    result.actorIdElement := ParseString(obj.complex('http://hl7.org/fhir/ExampleScenario.actor.actorId'));{q1}
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/ExampleScenario.actor.type'), CODES_TFhirExamplescenarioActorTypeEnum, SYSTEMS_TFhirExamplescenarioActorTypeEnum);
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/ExampleScenario.actor.name'));{q1}
    result.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ExampleScenario.actor.description'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeExampleScenarioActor(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExampleScenarioActor; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExampleScenarioActor'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeString(this, 'ExampleScenario.actor', 'actorId', elem.actorIdElement, false, -1);{x.2ea}
  ComposeEnum(this, 'ExampleScenario.actor', 'type', elem.Type_Element, CODES_TFhirExamplescenarioActorTypeEnum, SYSTEMS_TFhirExamplescenarioActorTypeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ExampleScenario.actor', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'ExampleScenario.actor', 'description', elem.descriptionElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseExampleScenarioInstance(obj : TTurtleComplex) : TFhirExampleScenarioInstance;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExampleScenarioInstance.create;
  try
    ParseExampleScenarioInstanceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExampleScenarioInstanceProperties(obj : TTurtleComplex; result : TFhirExampleScenarioInstance);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.resourceIdElement := ParseString(obj.complex('http://hl7.org/fhir/ExampleScenario.instance.resourceId'));{q1}
    result.resourceTypeElement := ParseEnum(obj.complex('http://hl7.org/fhir/ExampleScenario.instance.resourceType'), CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum);
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/ExampleScenario.instance.name'));{q1}
    result.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ExampleScenario.instance.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ExampleScenario.instance.version') do
      result.versionList.Add(parseExampleScenarioInstanceVersion(item));
    for item in obj.complexes('http://hl7.org/fhir/ExampleScenario.instance.containedInstance') do
      result.containedInstanceList.Add(parseExampleScenarioInstanceContainedInstance(item));
end;

procedure TFHIRTurtleComposer.ComposeExampleScenarioInstance(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExampleScenarioInstance; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExampleScenarioInstance'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeString(this, 'ExampleScenario.instance', 'resourceId', elem.resourceIdElement, false, -1);{x.2ea}
  ComposeEnum(this, 'ExampleScenario.instance', 'resourceType', elem.ResourceTypeElement, CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ExampleScenario.instance', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'ExampleScenario.instance', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.versionList.Count - 1 do
      ComposeExampleScenarioInstanceVersion(this, 'ExampleScenario.instance', 'version', elem.versionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.containedInstanceList.Count - 1 do
      ComposeExampleScenarioInstanceContainedInstance(this, 'ExampleScenario.instance', 'containedInstance', elem.containedInstanceList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseExampleScenarioInstanceVersion(obj : TTurtleComplex) : TFhirExampleScenarioInstanceVersion;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExampleScenarioInstanceVersion.create;
  try
    ParseExampleScenarioInstanceVersionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExampleScenarioInstanceVersionProperties(obj : TTurtleComplex; result : TFhirExampleScenarioInstanceVersion);
begin
    ParseBackboneElementProperties(obj, result);
    result.versionIdElement := ParseString(obj.complex('http://hl7.org/fhir/ExampleScenario.instance.version.versionId'));{q1}
    result.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ExampleScenario.instance.version.description'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeExampleScenarioInstanceVersion(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExampleScenarioInstanceVersion; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExampleScenarioInstanceVersion'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeString(this, 'ExampleScenario.instance.version', 'versionId', elem.versionIdElement, false, -1);{x.2ea}
  ComposeMarkdown(this, 'ExampleScenario.instance.version', 'description', elem.descriptionElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseExampleScenarioInstanceContainedInstance(obj : TTurtleComplex) : TFhirExampleScenarioInstanceContainedInstance;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExampleScenarioInstanceContainedInstance.create;
  try
    ParseExampleScenarioInstanceContainedInstanceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExampleScenarioInstanceContainedInstanceProperties(obj : TTurtleComplex; result : TFhirExampleScenarioInstanceContainedInstance);
begin
    ParseBackboneElementProperties(obj, result);
    result.resourceIdElement := ParseString(obj.complex('http://hl7.org/fhir/ExampleScenario.instance.containedInstance.resourceId'));{q1}
    result.versionIdElement := ParseString(obj.complex('http://hl7.org/fhir/ExampleScenario.instance.containedInstance.versionId'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeExampleScenarioInstanceContainedInstance(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExampleScenarioInstanceContainedInstance; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExampleScenarioInstanceContainedInstance'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeString(this, 'ExampleScenario.instance.containedInstance', 'resourceId', elem.resourceIdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ExampleScenario.instance.containedInstance', 'versionId', elem.versionIdElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseExampleScenarioProcess(obj : TTurtleComplex) : TFhirExampleScenarioProcess;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExampleScenarioProcess.create;
  try
    ParseExampleScenarioProcessProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExampleScenarioProcessProperties(obj : TTurtleComplex; result : TFhirExampleScenarioProcess);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.titleElement := ParseString(obj.complex('http://hl7.org/fhir/ExampleScenario.process.title'));{q1}
    result.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ExampleScenario.process.description'));{q1}
    result.preConditionsElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ExampleScenario.process.preConditions'));{q1}
    result.postConditionsElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ExampleScenario.process.postConditions'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ExampleScenario.process.step') do
      result.stepList.Add(parseExampleScenarioProcessStep(item));
end;

procedure TFHIRTurtleComposer.ComposeExampleScenarioProcess(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExampleScenarioProcess; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExampleScenarioProcess'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeString(this, 'ExampleScenario.process', 'title', elem.titleElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'ExampleScenario.process', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'ExampleScenario.process', 'preConditions', elem.preConditionsElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'ExampleScenario.process', 'postConditions', elem.postConditionsElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.stepList.Count - 1 do
      ComposeExampleScenarioProcessStep(this, 'ExampleScenario.process', 'step', elem.stepList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseExampleScenarioProcessStep(obj : TTurtleComplex) : TFhirExampleScenarioProcessStep;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExampleScenarioProcessStep.create;
  try
    ParseExampleScenarioProcessStepProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExampleScenarioProcessStepProperties(obj : TTurtleComplex; result : TFhirExampleScenarioProcessStep);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/ExampleScenario.process.step.process') do
      result.processList.Add(parseExampleScenarioProcess(item));
    result.pauseElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ExampleScenario.process.step.pause'));{q1}
    result.operation := ParseExampleScenarioProcessStepOperation(obj.complex('http://hl7.org/fhir/ExampleScenario.process.step.operation'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ExampleScenario.process.step.alternative') do
      result.alternativeList.Add(parseExampleScenarioProcessStepAlternative(item));
end;

procedure TFHIRTurtleComposer.ComposeExampleScenarioProcessStep(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExampleScenarioProcessStep; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExampleScenarioProcessStep'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.processList.Count - 1 do
      ComposeExampleScenarioProcess(this, 'ExampleScenario.process.step', 'process', elem.processList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'ExampleScenario.process.step', 'pause', elem.pauseElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeExampleScenarioProcessStepOperation(this, 'ExampleScenario.process.step', 'operation', elem.operationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.alternativeList.Count - 1 do
      ComposeExampleScenarioProcessStepAlternative(this, 'ExampleScenario.process.step', 'alternative', elem.alternativeList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseExampleScenarioProcessStepOperation(obj : TTurtleComplex) : TFhirExampleScenarioProcessStepOperation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExampleScenarioProcessStepOperation.create;
  try
    ParseExampleScenarioProcessStepOperationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExampleScenarioProcessStepOperationProperties(obj : TTurtleComplex; result : TFhirExampleScenarioProcessStepOperation);
begin
    ParseBackboneElementProperties(obj, result);
    result.numberElement := ParseString(obj.complex('http://hl7.org/fhir/ExampleScenario.process.step.operation.number'));{q1}
    result.type_Element := ParseString(obj.complex('http://hl7.org/fhir/ExampleScenario.process.step.operation.type'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/ExampleScenario.process.step.operation.name'));{q1}
    result.initiatorElement := ParseString(obj.complex('http://hl7.org/fhir/ExampleScenario.process.step.operation.initiator'));{q1}
    result.receiverElement := ParseString(obj.complex('http://hl7.org/fhir/ExampleScenario.process.step.operation.receiver'));{q1}
    result.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ExampleScenario.process.step.operation.description'));{q1}
    result.initiatorActiveElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ExampleScenario.process.step.operation.initiatorActive'));{q1}
    result.receiverActiveElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ExampleScenario.process.step.operation.receiverActive'));{q1}
    result.request := ParseExampleScenarioInstanceContainedInstance(obj.complex('http://hl7.org/fhir/ExampleScenario.process.step.operation.request'));{q3b}
    result.response := ParseExampleScenarioInstanceContainedInstance(obj.complex('http://hl7.org/fhir/ExampleScenario.process.step.operation.response'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeExampleScenarioProcessStepOperation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExampleScenarioProcessStepOperation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExampleScenarioProcessStepOperation'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeString(this, 'ExampleScenario.process.step.operation', 'number', elem.numberElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ExampleScenario.process.step.operation', 'type', elem.type_Element, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ExampleScenario.process.step.operation', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ExampleScenario.process.step.operation', 'initiator', elem.initiatorElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ExampleScenario.process.step.operation', 'receiver', elem.receiverElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'ExampleScenario.process.step.operation', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'ExampleScenario.process.step.operation', 'initiatorActive', elem.initiatorActiveElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'ExampleScenario.process.step.operation', 'receiverActive', elem.receiverActiveElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeExampleScenarioInstanceContainedInstance(this, 'ExampleScenario.process.step.operation', 'request', elem.requestElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeExampleScenarioInstanceContainedInstance(this, 'ExampleScenario.process.step.operation', 'response', elem.responseElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseExampleScenarioProcessStepAlternative(obj : TTurtleComplex) : TFhirExampleScenarioProcessStepAlternative;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExampleScenarioProcessStepAlternative.create;
  try
    ParseExampleScenarioProcessStepAlternativeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExampleScenarioProcessStepAlternativeProperties(obj : TTurtleComplex; result : TFhirExampleScenarioProcessStepAlternative);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.titleElement := ParseString(obj.complex('http://hl7.org/fhir/ExampleScenario.process.step.alternative.title'));{q1}
    result.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ExampleScenario.process.step.alternative.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ExampleScenario.process.step.alternative.step') do
      result.stepList.Add(parseExampleScenarioProcessStep(item));
end;

procedure TFHIRTurtleComposer.ComposeExampleScenarioProcessStepAlternative(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExampleScenarioProcessStepAlternative; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExampleScenarioProcessStepAlternative'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeString(this, 'ExampleScenario.process.step.alternative', 'title', elem.titleElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'ExampleScenario.process.step.alternative', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.stepList.Count - 1 do
      ComposeExampleScenarioProcessStep(this, 'ExampleScenario.process.step.alternative', 'step', elem.stepList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseExampleScenario(obj : TTurtleComplex) : TFhirExampleScenario;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExampleScenario.create;
  try
    ParseExampleScenarioProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExampleScenarioProperties(obj : TTurtleComplex; result : TFhirExampleScenario);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/ExampleScenario.url'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ExampleScenario.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/ExampleScenario.version'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/ExampleScenario.name'));{q1}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/ExampleScenario.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    result.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ExampleScenario.experimental'));{q1}
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ExampleScenario.date'));{q1}
    result.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/ExampleScenario.publisher'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ExampleScenario.contact') do
      result.contactList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/ExampleScenario.useContext') do
      result.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/ExampleScenario.jurisdiction') do
      result.jurisdictionList.Add(parseCodeableConcept(item));
    result.copyrightElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ExampleScenario.copyright'));{q1}
    result.purposeElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ExampleScenario.purpose'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ExampleScenario.actor') do
      result.actorList.Add(parseExampleScenarioActor(item));
    for item in obj.complexes('http://hl7.org/fhir/ExampleScenario.instance') do
      result.instanceList.Add(parseExampleScenarioInstance(item));
    for item in obj.complexes('http://hl7.org/fhir/ExampleScenario.process') do
      result.processList.Add(parseExampleScenarioProcess(item));
    for item in obj.complexes('http://hl7.org/fhir/ExampleScenario.workflow') do
      result.workflowList.Add(parseCanonical(item));
end;

procedure TFHIRTurtleComposer.ComposeExampleScenario(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExampleScenario; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExampleScenario'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUri(this, 'ExampleScenario', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'ExampleScenario', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(this, 'ExampleScenario', 'version', elem.versionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(this, 'ExampleScenario', 'name', elem.nameElement, false, -1);{x.2ea}
  ComposeEnum(this, 'ExampleScenario', 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(this, 'ExampleScenario', 'experimental', elem.experimentalElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(this, 'ExampleScenario', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(this, 'ExampleScenario', 'publisher', elem.publisherElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(this, 'ExampleScenario', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(this, 'ExampleScenario', 'useContext', elem.useContextList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'ExampleScenario', 'jurisdiction', elem.jurisdictionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdown(this, 'ExampleScenario', 'copyright', elem.copyrightElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdown(this, 'ExampleScenario', 'purpose', elem.purposeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('actor') then
    for i := 0 to elem.actorList.Count - 1 do
      ComposeExampleScenarioActor(this, 'ExampleScenario', 'actor', elem.actorList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('instance') then
    for i := 0 to elem.instanceList.Count - 1 do
      ComposeExampleScenarioInstance(this, 'ExampleScenario', 'instance', elem.instanceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('process') then
    for i := 0 to elem.processList.Count - 1 do
      ComposeExampleScenarioProcess(this, 'ExampleScenario', 'process', elem.processList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('workflow') then
    for i := 0 to elem.workflowList.Count - 1 do
      ComposeCanonical(this, 'ExampleScenario', 'workflow', elem.workflowList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_EXAMPLESCENARIO}
{$IFDEF FHIR_EXPLANATIONOFBENEFIT}
function TFHIRTurtleParser.ParseExplanationOfBenefitRelated(obj : TTurtleComplex) : TFhirExplanationOfBenefitRelated;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExplanationOfBenefitRelated.create;
  try
    ParseExplanationOfBenefitRelatedProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExplanationOfBenefitRelatedProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitRelated);
begin
    ParseBackboneElementProperties(obj, result);
    result.claim := ParseReference{TFhirClaim}(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.related.claim'));{q3b}
    result.relationship := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.related.relationship'));{q3b}
    result.reference := ParseIdentifier(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.related.reference'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeExplanationOfBenefitRelated(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitRelated; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExplanationOfBenefitRelated'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirClaim}(this, 'ExplanationOfBenefit.related', 'claim', elem.claimElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.related', 'relationship', elem.relationshipElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(this, 'ExplanationOfBenefit.related', 'reference', elem.referenceElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseExplanationOfBenefitPayee(obj : TTurtleComplex) : TFhirExplanationOfBenefitPayee;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExplanationOfBenefitPayee.create;
  try
    ParseExplanationOfBenefitPayeeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExplanationOfBenefitPayeeProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitPayee);
begin
    ParseBackboneElementProperties(obj, result);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.payee.type'));{q3b}
    result.party := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.payee.party'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeExplanationOfBenefitPayee(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitPayee; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExplanationOfBenefitPayee'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.payee', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirPractitioner}(this, 'ExplanationOfBenefit.payee', 'party', elem.partyElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseExplanationOfBenefitCareTeam(obj : TTurtleComplex) : TFhirExplanationOfBenefitCareTeam;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExplanationOfBenefitCareTeam.create;
  try
    ParseExplanationOfBenefitCareTeamProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExplanationOfBenefitCareTeamProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitCareTeam);
begin
    ParseBackboneElementProperties(obj, result);
    result.sequenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.careTeam.sequence'));{q1}
    result.provider := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.careTeam.provider'));{q3b}
    result.responsibleElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.careTeam.responsible'));{q1}
    result.role := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.careTeam.role'));{q3b}
    result.qualification := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.careTeam.qualification'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeExplanationOfBenefitCareTeam(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitCareTeam; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExplanationOfBenefitCareTeam'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposePositiveInt(this, 'ExplanationOfBenefit.careTeam', 'sequence', elem.sequenceElement, false, -1);{x.2ea}
  ComposeReference{TFhirPractitioner}(this, 'ExplanationOfBenefit.careTeam', 'provider', elem.providerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'ExplanationOfBenefit.careTeam', 'responsible', elem.responsibleElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.careTeam', 'role', elem.roleElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.careTeam', 'qualification', elem.qualificationElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseExplanationOfBenefitSupportingInfo(obj : TTurtleComplex) : TFhirExplanationOfBenefitSupportingInfo;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExplanationOfBenefitSupportingInfo.create;
  try
    ParseExplanationOfBenefitSupportingInfoProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExplanationOfBenefitSupportingInfoProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitSupportingInfo);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.sequenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.supportingInfo.sequence'));{q1}
    result.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.supportingInfo.category'));{q3b}
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.supportingInfo.code'));{q3b}
    if obj.has('http://hl7.org/fhir/ExplanationOfBenefit.supportingInfo.timingPeriod', item) then
      result.timing := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/ExplanationOfBenefit.supportingInfo.timingDate', item) then
      result.timing := parseDate(item);
    if obj.has('http://hl7.org/fhir/ExplanationOfBenefit.supportingInfo.valueQuantity', item) then
      result.value := parseQuantity(item);
    if obj.has('http://hl7.org/fhir/ExplanationOfBenefit.supportingInfo.valueAttachment', item) then
      result.value := parseAttachment(item);
    if obj.has('http://hl7.org/fhir/ExplanationOfBenefit.supportingInfo.valueReference', item) {a3} then
      result.value := ParseReference(item);
    if obj.has('http://hl7.org/fhir/ExplanationOfBenefit.supportingInfo.valueBoolean', item) then
      result.value := parseBoolean(item);
    if obj.has('http://hl7.org/fhir/ExplanationOfBenefit.supportingInfo.valueString', item) then
      result.value := parseString(item);
    result.reason := ParseCoding(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.supportingInfo.reason'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeExplanationOfBenefitSupportingInfo(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitSupportingInfo; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExplanationOfBenefitSupportingInfo'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposePositiveInt(this, 'ExplanationOfBenefit.supportingInfo', 'sequence', elem.sequenceElement, false, -1);{x.2ea}
  ComposeCodeableConcept(this, 'ExplanationOfBenefit.supportingInfo', 'category', elem.categoryElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.supportingInfo', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirPeriod) {6} then
    ComposePeriod(this, 'ExplanationOfBenefit.supportingInfo', 'timingPeriod', TFhirPeriod(elem.timing), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirDate) {6} then
    ComposeDate(this, 'ExplanationOfBenefit.supportingInfo', 'timingDate', TFhirDate(elem.timing), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) and (elem.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'ExplanationOfBenefit.supportingInfo', 'valueQuantity', TFhirQuantity(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirAttachment) {6} then
    ComposeAttachment(this, 'ExplanationOfBenefit.supportingInfo', 'valueAttachment', TFhirAttachment(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirReference) {2} then
    ComposeReference(this, 'ExplanationOfBenefit.supportingInfo', 'valueReference', TFhirReference(elem.value), false,-1){x.d8}
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirBoolean) {6} then
    ComposeBoolean(this, 'ExplanationOfBenefit.supportingInfo', 'valueBoolean', TFhirBoolean(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirString) {6} then
    ComposeString(this, 'ExplanationOfBenefit.supportingInfo', 'valueString', TFhirString(elem.value), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(this, 'ExplanationOfBenefit.supportingInfo', 'reason', elem.reasonElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseExplanationOfBenefitDiagnosis(obj : TTurtleComplex) : TFhirExplanationOfBenefitDiagnosis;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExplanationOfBenefitDiagnosis.create;
  try
    ParseExplanationOfBenefitDiagnosisProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExplanationOfBenefitDiagnosisProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitDiagnosis);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.sequenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.diagnosis.sequence'));{q1}
    if obj.has('http://hl7.org/fhir/ExplanationOfBenefit.diagnosis.diagnosisCodeableConcept', item) then
      result.diagnosis := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/ExplanationOfBenefit.diagnosis.diagnosisReference', item) {a3} then
      result.diagnosis := ParseReference(item);
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.diagnosis.type') do
      result.type_List.Add(parseCodeableConcept(item));
    result.onAdmission := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.diagnosis.onAdmission'));{q3b}
    result.packageCode := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.diagnosis.packageCode'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeExplanationOfBenefitDiagnosis(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitDiagnosis; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExplanationOfBenefitDiagnosis'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposePositiveInt(this, 'ExplanationOfBenefit.diagnosis', 'sequence', elem.sequenceElement, false, -1);{x.2ea}
  if (elem.diagnosis is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.diagnosis', 'diagnosisCodeableConcept', TFhirCodeableConcept(elem.diagnosis), false, -1){x.d9}
  else if (elem.diagnosis is TFhirReference) {2} then
    ComposeReference(this, 'ExplanationOfBenefit.diagnosis', 'diagnosisReference', TFhirReference(elem.diagnosis), false,-1);{x.d8}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(this, 'ExplanationOfBenefit.diagnosis', 'type', elem.type_List[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.diagnosis', 'onAdmission', elem.onAdmissionElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.diagnosis', 'packageCode', elem.packageCodeElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseExplanationOfBenefitProcedure(obj : TTurtleComplex) : TFhirExplanationOfBenefitProcedure;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExplanationOfBenefitProcedure.create;
  try
    ParseExplanationOfBenefitProcedureProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExplanationOfBenefitProcedureProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitProcedure);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.sequenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.procedure.sequence'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.procedure.type') do
      result.type_List.Add(parseCodeableConcept(item));
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.procedure.date'));{q1}
    if obj.has('http://hl7.org/fhir/ExplanationOfBenefit.procedure.procedureCodeableConcept', item) then
      result.procedure_ := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/ExplanationOfBenefit.procedure.procedureReference', item) {a3} then
      result.procedure_ := ParseReference(item);
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.procedure.udi') do
      result.udiList.Add(parseReference{TFhirDevice}(item));
end;

procedure TFHIRTurtleComposer.ComposeExplanationOfBenefitProcedure(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitProcedure; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExplanationOfBenefitProcedure'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposePositiveInt(this, 'ExplanationOfBenefit.procedure', 'sequence', elem.sequenceElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(this, 'ExplanationOfBenefit.procedure', 'type', elem.type_List[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'ExplanationOfBenefit.procedure', 'date', elem.dateElement, false, -1);{x.2ea}
  if (elem.procedure_ is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.procedure', 'procedureCodeableConcept', TFhirCodeableConcept(elem.procedure_), false, -1){x.d9}
  else if (elem.procedure_ is TFhirReference) {2} then
    ComposeReference(this, 'ExplanationOfBenefit.procedure', 'procedureReference', TFhirReference(elem.procedure_), false,-1);{x.d8}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.udiList.Count - 1 do
      ComposeReference{TFhirDevice}(this, 'ExplanationOfBenefit.procedure', 'udi', elem.udiList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseExplanationOfBenefitInsurance(obj : TTurtleComplex) : TFhirExplanationOfBenefitInsurance;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExplanationOfBenefitInsurance.create;
  try
    ParseExplanationOfBenefitInsuranceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExplanationOfBenefitInsuranceProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitInsurance);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.focalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.insurance.focal'));{q1}
    result.coverage := ParseReference{TFhirCoverage}(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.insurance.coverage'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.insurance.preAuthRef') do
      result.preAuthRefList.Add(parseString(item));
end;

procedure TFHIRTurtleComposer.ComposeExplanationOfBenefitInsurance(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitInsurance; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExplanationOfBenefitInsurance'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeBoolean(this, 'ExplanationOfBenefit.insurance', 'focal', elem.focalElement, false, -1);{x.2ea}
  ComposeReference{TFhirCoverage}(this, 'ExplanationOfBenefit.insurance', 'coverage', elem.coverageElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.preAuthRefList.Count - 1 do
      ComposeString(this, 'ExplanationOfBenefit.insurance', 'preAuthRef', elem.preAuthRefList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseExplanationOfBenefitAccident(obj : TTurtleComplex) : TFhirExplanationOfBenefitAccident;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExplanationOfBenefitAccident.create;
  try
    ParseExplanationOfBenefitAccidentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExplanationOfBenefitAccidentProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitAccident);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.dateElement := ParseDate(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.accident.date'));{q1}
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.accident.type'));{q3b}
    if obj.has('http://hl7.org/fhir/ExplanationOfBenefit.accident.locationAddress', item) then
      result.location := parseAddress(item);
    if obj.has('http://hl7.org/fhir/ExplanationOfBenefit.accident.locationReference', item) {a3} then
      result.location := ParseReference(item);
end;

procedure TFHIRTurtleComposer.ComposeExplanationOfBenefitAccident(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitAccident; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExplanationOfBenefitAccident'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(this, 'ExplanationOfBenefit.accident', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.accident', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and (elem.location is TFhirAddress) {6} then
    ComposeAddress(this, 'ExplanationOfBenefit.accident', 'locationAddress', TFhirAddress(elem.location), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.location is TFhirReference) {2} then
    ComposeReference(this, 'ExplanationOfBenefit.accident', 'locationReference', TFhirReference(elem.location), false,-1);{x.d8}
end;

function TFHIRTurtleParser.ParseExplanationOfBenefitItem(obj : TTurtleComplex) : TFhirExplanationOfBenefitItem;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExplanationOfBenefitItem.create;
  try
    ParseExplanationOfBenefitItemProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExplanationOfBenefitItemProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitItem);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.sequenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.sequence'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.item.careTeamSequence') do
      result.careTeamSequenceList.Add(parsePositiveInt(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.item.diagnosisSequence') do
      result.diagnosisSequenceList.Add(parsePositiveInt(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.item.procedureSequence') do
      result.procedureSequenceList.Add(parsePositiveInt(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.item.informationSequence') do
      result.informationSequenceList.Add(parsePositiveInt(item));
    result.revenue := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.revenue'));{q3b}
    result.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.category'));{q3b}
    result.productOrService := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.productOrService'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.item.modifier') do
      result.modifierList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.item.programCode') do
      result.programCodeList.Add(parseCodeableConcept(item));
    if obj.has('http://hl7.org/fhir/ExplanationOfBenefit.item.servicedPeriod', item) then
      result.serviced := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/ExplanationOfBenefit.item.servicedDate', item) then
      result.serviced := parseDate(item);
    if obj.has('http://hl7.org/fhir/ExplanationOfBenefit.item.locationCodeableConcept', item) then
      result.location := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/ExplanationOfBenefit.item.locationAddress', item) then
      result.location := parseAddress(item);
    if obj.has('http://hl7.org/fhir/ExplanationOfBenefit.item.locationReference', item) {a3} then
      result.location := ParseReference(item);
    result.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.quantity'));{q3b}
    result.unitPrice := ParseMoney(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.unitPrice'));{q3b}
    result.factorElement := ParseDecimal(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.factor'));{q1}
    result.net := ParseMoney(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.net'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.item.udi') do
      result.udiList.Add(parseReference{TFhirDevice}(item));
    result.bodySite := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.bodySite'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.item.subSite') do
      result.subSiteList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.item.encounter') do
      result.encounterList.Add(parseReference{TFhirEncounter}(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.item.noteNumber') do
      result.noteNumberList.Add(parsePositiveInt(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.item.adjudication') do
      result.adjudicationList.Add(parseExplanationOfBenefitItemAdjudication(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.item.detail') do
      result.detailList.Add(parseExplanationOfBenefitItemDetail(item));
end;

procedure TFHIRTurtleComposer.ComposeExplanationOfBenefitItem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitItem; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExplanationOfBenefitItem'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposePositiveInt(this, 'ExplanationOfBenefit.item', 'sequence', elem.sequenceElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.careTeamSequenceList.Count - 1 do
      ComposePositiveInt(this, 'ExplanationOfBenefit.item', 'careTeamSequence', elem.careTeamSequenceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.diagnosisSequenceList.Count - 1 do
      ComposePositiveInt(this, 'ExplanationOfBenefit.item', 'diagnosisSequence', elem.diagnosisSequenceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.procedureSequenceList.Count - 1 do
      ComposePositiveInt(this, 'ExplanationOfBenefit.item', 'procedureSequence', elem.procedureSequenceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.informationSequenceList.Count - 1 do
      ComposePositiveInt(this, 'ExplanationOfBenefit.item', 'informationSequence', elem.informationSequenceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.item', 'revenue', elem.revenueElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.item', 'category', elem.categoryElement, false, -1);{x.2f}
  ComposeCodeableConcept(this, 'ExplanationOfBenefit.item', 'productOrService', elem.productOrServiceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.modifierList.Count - 1 do
      ComposeCodeableConcept(this, 'ExplanationOfBenefit.item', 'modifier', elem.modifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.programCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'ExplanationOfBenefit.item', 'programCode', elem.programCodeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and (elem.serviced is TFhirPeriod) {6} then
    ComposePeriod(this, 'ExplanationOfBenefit.item', 'servicedPeriod', TFhirPeriod(elem.serviced), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.serviced is TFhirDate) {6} then
    ComposeDate(this, 'ExplanationOfBenefit.item', 'servicedDate', TFhirDate(elem.serviced), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) and (elem.location is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.item', 'locationCodeableConcept', TFhirCodeableConcept(elem.location), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.location is TFhirAddress) {6} then
    ComposeAddress(this, 'ExplanationOfBenefit.item', 'locationAddress', TFhirAddress(elem.location), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.location is TFhirReference) {2} then
    ComposeReference(this, 'ExplanationOfBenefit.item', 'locationReference', TFhirReference(elem.location), false,-1);{x.d8}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'ExplanationOfBenefit.item', 'quantity', elem.quantityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ExplanationOfBenefit.item', 'unitPrice', elem.unitPriceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'ExplanationOfBenefit.item', 'factor', elem.factorElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ExplanationOfBenefit.item', 'net', elem.netElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.udiList.Count - 1 do
      ComposeReference{TFhirDevice}(this, 'ExplanationOfBenefit.item', 'udi', elem.udiList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.item', 'bodySite', elem.bodySiteElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.subSiteList.Count - 1 do
      ComposeCodeableConcept(this, 'ExplanationOfBenefit.item', 'subSite', elem.subSiteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.encounterList.Count - 1 do
      ComposeReference{TFhirEncounter}(this, 'ExplanationOfBenefit.item', 'encounter', elem.encounterList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.noteNumberList.Count - 1 do
      ComposePositiveInt(this, 'ExplanationOfBenefit.item', 'noteNumber', elem.noteNumberList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeExplanationOfBenefitItemAdjudication(this, 'ExplanationOfBenefit.item', 'adjudication', elem.adjudicationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.detailList.Count - 1 do
      ComposeExplanationOfBenefitItemDetail(this, 'ExplanationOfBenefit.item', 'detail', elem.detailList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseExplanationOfBenefitItemAdjudication(obj : TTurtleComplex) : TFhirExplanationOfBenefitItemAdjudication;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExplanationOfBenefitItemAdjudication.create;
  try
    ParseExplanationOfBenefitItemAdjudicationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExplanationOfBenefitItemAdjudicationProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitItemAdjudication);
begin
    ParseBackboneElementProperties(obj, result);
    result.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.adjudication.category'));{q3b}
    result.reason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.adjudication.reason'));{q3b}
    result.amount := ParseMoney(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.adjudication.amount'));{q3b}
    result.valueElement := ParseDecimal(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.adjudication.value'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeExplanationOfBenefitItemAdjudication(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitItemAdjudication; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExplanationOfBenefitItemAdjudication'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'ExplanationOfBenefit.item.adjudication', 'category', elem.categoryElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.item.adjudication', 'reason', elem.reasonElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ExplanationOfBenefit.item.adjudication', 'amount', elem.amountElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'ExplanationOfBenefit.item.adjudication', 'value', elem.valueElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseExplanationOfBenefitItemDetail(obj : TTurtleComplex) : TFhirExplanationOfBenefitItemDetail;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExplanationOfBenefitItemDetail.create;
  try
    ParseExplanationOfBenefitItemDetailProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExplanationOfBenefitItemDetailProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitItemDetail);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.sequenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.sequence'));{q1}
    result.revenue := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.revenue'));{q3b}
    result.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.category'));{q3b}
    result.productOrService := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.productOrService'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.modifier') do
      result.modifierList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.programCode') do
      result.programCodeList.Add(parseCodeableConcept(item));
    result.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.quantity'));{q3b}
    result.unitPrice := ParseMoney(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.unitPrice'));{q3b}
    result.factorElement := ParseDecimal(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.factor'));{q1}
    result.net := ParseMoney(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.net'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.udi') do
      result.udiList.Add(parseReference{TFhirDevice}(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.noteNumber') do
      result.noteNumberList.Add(parsePositiveInt(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.adjudication') do
      result.adjudicationList.Add(parseExplanationOfBenefitItemAdjudication(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.subDetail') do
      result.subDetailList.Add(parseExplanationOfBenefitItemDetailSubDetail(item));
end;

procedure TFHIRTurtleComposer.ComposeExplanationOfBenefitItemDetail(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitItemDetail; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExplanationOfBenefitItemDetail'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposePositiveInt(this, 'ExplanationOfBenefit.item.detail', 'sequence', elem.sequenceElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.item.detail', 'revenue', elem.revenueElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.item.detail', 'category', elem.categoryElement, false, -1);{x.2f}
  ComposeCodeableConcept(this, 'ExplanationOfBenefit.item.detail', 'productOrService', elem.productOrServiceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.modifierList.Count - 1 do
      ComposeCodeableConcept(this, 'ExplanationOfBenefit.item.detail', 'modifier', elem.modifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.programCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'ExplanationOfBenefit.item.detail', 'programCode', elem.programCodeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'ExplanationOfBenefit.item.detail', 'quantity', elem.quantityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ExplanationOfBenefit.item.detail', 'unitPrice', elem.unitPriceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'ExplanationOfBenefit.item.detail', 'factor', elem.factorElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ExplanationOfBenefit.item.detail', 'net', elem.netElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.udiList.Count - 1 do
      ComposeReference{TFhirDevice}(this, 'ExplanationOfBenefit.item.detail', 'udi', elem.udiList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.noteNumberList.Count - 1 do
      ComposePositiveInt(this, 'ExplanationOfBenefit.item.detail', 'noteNumber', elem.noteNumberList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeExplanationOfBenefitItemAdjudication(this, 'ExplanationOfBenefit.item.detail', 'adjudication', elem.adjudicationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.subDetailList.Count - 1 do
      ComposeExplanationOfBenefitItemDetailSubDetail(this, 'ExplanationOfBenefit.item.detail', 'subDetail', elem.subDetailList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseExplanationOfBenefitItemDetailSubDetail(obj : TTurtleComplex) : TFhirExplanationOfBenefitItemDetailSubDetail;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExplanationOfBenefitItemDetailSubDetail.create;
  try
    ParseExplanationOfBenefitItemDetailSubDetailProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExplanationOfBenefitItemDetailSubDetailProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitItemDetailSubDetail);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.sequenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.subDetail.sequence'));{q1}
    result.revenue := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.subDetail.revenue'));{q3b}
    result.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.subDetail.category'));{q3b}
    result.productOrService := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.subDetail.productOrService'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.subDetail.modifier') do
      result.modifierList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.subDetail.programCode') do
      result.programCodeList.Add(parseCodeableConcept(item));
    result.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.subDetail.quantity'));{q3b}
    result.unitPrice := ParseMoney(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.subDetail.unitPrice'));{q3b}
    result.factorElement := ParseDecimal(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.subDetail.factor'));{q1}
    result.net := ParseMoney(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.subDetail.net'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.subDetail.udi') do
      result.udiList.Add(parseReference{TFhirDevice}(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.subDetail.noteNumber') do
      result.noteNumberList.Add(parsePositiveInt(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.item.detail.subDetail.adjudication') do
      result.adjudicationList.Add(parseExplanationOfBenefitItemAdjudication(item));
end;

procedure TFHIRTurtleComposer.ComposeExplanationOfBenefitItemDetailSubDetail(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitItemDetailSubDetail; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExplanationOfBenefitItemDetailSubDetail'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposePositiveInt(this, 'ExplanationOfBenefit.item.detail.subDetail', 'sequence', elem.sequenceElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.item.detail.subDetail', 'revenue', elem.revenueElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.item.detail.subDetail', 'category', elem.categoryElement, false, -1);{x.2f}
  ComposeCodeableConcept(this, 'ExplanationOfBenefit.item.detail.subDetail', 'productOrService', elem.productOrServiceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.modifierList.Count - 1 do
      ComposeCodeableConcept(this, 'ExplanationOfBenefit.item.detail.subDetail', 'modifier', elem.modifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.programCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'ExplanationOfBenefit.item.detail.subDetail', 'programCode', elem.programCodeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'ExplanationOfBenefit.item.detail.subDetail', 'quantity', elem.quantityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ExplanationOfBenefit.item.detail.subDetail', 'unitPrice', elem.unitPriceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'ExplanationOfBenefit.item.detail.subDetail', 'factor', elem.factorElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ExplanationOfBenefit.item.detail.subDetail', 'net', elem.netElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.udiList.Count - 1 do
      ComposeReference{TFhirDevice}(this, 'ExplanationOfBenefit.item.detail.subDetail', 'udi', elem.udiList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.noteNumberList.Count - 1 do
      ComposePositiveInt(this, 'ExplanationOfBenefit.item.detail.subDetail', 'noteNumber', elem.noteNumberList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeExplanationOfBenefitItemAdjudication(this, 'ExplanationOfBenefit.item.detail.subDetail', 'adjudication', elem.adjudicationList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseExplanationOfBenefitAddItem(obj : TTurtleComplex) : TFhirExplanationOfBenefitAddItem;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExplanationOfBenefitAddItem.create;
  try
    ParseExplanationOfBenefitAddItemProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExplanationOfBenefitAddItemProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitAddItem);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.addItem.itemSequence') do
      result.itemSequenceList.Add(parsePositiveInt(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.addItem.detailSequence') do
      result.detailSequenceList.Add(parsePositiveInt(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.addItem.subDetailSequence') do
      result.subDetailSequenceList.Add(parsePositiveInt(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.addItem.provider') do
      result.providerList.Add(parseReference{TFhirPractitioner}(item));
    result.productOrService := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.addItem.productOrService'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.addItem.modifier') do
      result.modifierList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.addItem.programCode') do
      result.programCodeList.Add(parseCodeableConcept(item));
    if obj.has('http://hl7.org/fhir/ExplanationOfBenefit.addItem.servicedPeriod', item) then
      result.serviced := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/ExplanationOfBenefit.addItem.servicedDate', item) then
      result.serviced := parseDate(item);
    if obj.has('http://hl7.org/fhir/ExplanationOfBenefit.addItem.locationCodeableConcept', item) then
      result.location := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/ExplanationOfBenefit.addItem.locationAddress', item) then
      result.location := parseAddress(item);
    if obj.has('http://hl7.org/fhir/ExplanationOfBenefit.addItem.locationReference', item) {a3} then
      result.location := ParseReference(item);
    result.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.addItem.quantity'));{q3b}
    result.unitPrice := ParseMoney(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.addItem.unitPrice'));{q3b}
    result.factorElement := ParseDecimal(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.addItem.factor'));{q1}
    result.net := ParseMoney(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.addItem.net'));{q3b}
    result.bodySite := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.addItem.bodySite'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.addItem.subSite') do
      result.subSiteList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.addItem.noteNumber') do
      result.noteNumberList.Add(parsePositiveInt(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.addItem.adjudication') do
      result.adjudicationList.Add(parseExplanationOfBenefitItemAdjudication(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.addItem.detail') do
      result.detailList.Add(parseExplanationOfBenefitAddItemDetail(item));
end;

procedure TFHIRTurtleComposer.ComposeExplanationOfBenefitAddItem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitAddItem; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExplanationOfBenefitAddItem'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.itemSequenceList.Count - 1 do
      ComposePositiveInt(this, 'ExplanationOfBenefit.addItem', 'itemSequence', elem.itemSequenceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.detailSequenceList.Count - 1 do
      ComposePositiveInt(this, 'ExplanationOfBenefit.addItem', 'detailSequence', elem.detailSequenceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.subDetailSequenceList.Count - 1 do
      ComposePositiveInt(this, 'ExplanationOfBenefit.addItem', 'subDetailSequence', elem.subDetailSequenceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.providerList.Count - 1 do
      ComposeReference{TFhirPractitioner}(this, 'ExplanationOfBenefit.addItem', 'provider', elem.providerList[i], false, i);{x.d3}
  ComposeCodeableConcept(this, 'ExplanationOfBenefit.addItem', 'productOrService', elem.productOrServiceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.modifierList.Count - 1 do
      ComposeCodeableConcept(this, 'ExplanationOfBenefit.addItem', 'modifier', elem.modifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.programCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'ExplanationOfBenefit.addItem', 'programCode', elem.programCodeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and (elem.serviced is TFhirPeriod) {6} then
    ComposePeriod(this, 'ExplanationOfBenefit.addItem', 'servicedPeriod', TFhirPeriod(elem.serviced), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.serviced is TFhirDate) {6} then
    ComposeDate(this, 'ExplanationOfBenefit.addItem', 'servicedDate', TFhirDate(elem.serviced), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) and (elem.location is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.addItem', 'locationCodeableConcept', TFhirCodeableConcept(elem.location), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.location is TFhirAddress) {6} then
    ComposeAddress(this, 'ExplanationOfBenefit.addItem', 'locationAddress', TFhirAddress(elem.location), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.location is TFhirReference) {2} then
    ComposeReference(this, 'ExplanationOfBenefit.addItem', 'locationReference', TFhirReference(elem.location), false,-1);{x.d8}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'ExplanationOfBenefit.addItem', 'quantity', elem.quantityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ExplanationOfBenefit.addItem', 'unitPrice', elem.unitPriceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'ExplanationOfBenefit.addItem', 'factor', elem.factorElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ExplanationOfBenefit.addItem', 'net', elem.netElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.addItem', 'bodySite', elem.bodySiteElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.subSiteList.Count - 1 do
      ComposeCodeableConcept(this, 'ExplanationOfBenefit.addItem', 'subSite', elem.subSiteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.noteNumberList.Count - 1 do
      ComposePositiveInt(this, 'ExplanationOfBenefit.addItem', 'noteNumber', elem.noteNumberList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeExplanationOfBenefitItemAdjudication(this, 'ExplanationOfBenefit.addItem', 'adjudication', elem.adjudicationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.detailList.Count - 1 do
      ComposeExplanationOfBenefitAddItemDetail(this, 'ExplanationOfBenefit.addItem', 'detail', elem.detailList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseExplanationOfBenefitAddItemDetail(obj : TTurtleComplex) : TFhirExplanationOfBenefitAddItemDetail;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExplanationOfBenefitAddItemDetail.create;
  try
    ParseExplanationOfBenefitAddItemDetailProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExplanationOfBenefitAddItemDetailProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitAddItemDetail);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.productOrService := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.addItem.detail.productOrService'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.addItem.detail.modifier') do
      result.modifierList.Add(parseCodeableConcept(item));
    result.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.addItem.detail.quantity'));{q3b}
    result.unitPrice := ParseMoney(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.addItem.detail.unitPrice'));{q3b}
    result.factorElement := ParseDecimal(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.addItem.detail.factor'));{q1}
    result.net := ParseMoney(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.addItem.detail.net'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.addItem.detail.noteNumber') do
      result.noteNumberList.Add(parsePositiveInt(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.addItem.detail.adjudication') do
      result.adjudicationList.Add(parseExplanationOfBenefitItemAdjudication(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.addItem.detail.subDetail') do
      result.subDetailList.Add(parseExplanationOfBenefitAddItemDetailSubDetail(item));
end;

procedure TFHIRTurtleComposer.ComposeExplanationOfBenefitAddItemDetail(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitAddItemDetail; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExplanationOfBenefitAddItemDetail'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'ExplanationOfBenefit.addItem.detail', 'productOrService', elem.productOrServiceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.modifierList.Count - 1 do
      ComposeCodeableConcept(this, 'ExplanationOfBenefit.addItem.detail', 'modifier', elem.modifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'ExplanationOfBenefit.addItem.detail', 'quantity', elem.quantityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ExplanationOfBenefit.addItem.detail', 'unitPrice', elem.unitPriceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'ExplanationOfBenefit.addItem.detail', 'factor', elem.factorElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ExplanationOfBenefit.addItem.detail', 'net', elem.netElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.noteNumberList.Count - 1 do
      ComposePositiveInt(this, 'ExplanationOfBenefit.addItem.detail', 'noteNumber', elem.noteNumberList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeExplanationOfBenefitItemAdjudication(this, 'ExplanationOfBenefit.addItem.detail', 'adjudication', elem.adjudicationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.subDetailList.Count - 1 do
      ComposeExplanationOfBenefitAddItemDetailSubDetail(this, 'ExplanationOfBenefit.addItem.detail', 'subDetail', elem.subDetailList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseExplanationOfBenefitAddItemDetailSubDetail(obj : TTurtleComplex) : TFhirExplanationOfBenefitAddItemDetailSubDetail;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExplanationOfBenefitAddItemDetailSubDetail.create;
  try
    ParseExplanationOfBenefitAddItemDetailSubDetailProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExplanationOfBenefitAddItemDetailSubDetailProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitAddItemDetailSubDetail);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.productOrService := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.addItem.detail.subDetail.productOrService'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.addItem.detail.subDetail.modifier') do
      result.modifierList.Add(parseCodeableConcept(item));
    result.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.addItem.detail.subDetail.quantity'));{q3b}
    result.unitPrice := ParseMoney(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.addItem.detail.subDetail.unitPrice'));{q3b}
    result.factorElement := ParseDecimal(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.addItem.detail.subDetail.factor'));{q1}
    result.net := ParseMoney(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.addItem.detail.subDetail.net'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.addItem.detail.subDetail.noteNumber') do
      result.noteNumberList.Add(parsePositiveInt(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.addItem.detail.subDetail.adjudication') do
      result.adjudicationList.Add(parseExplanationOfBenefitItemAdjudication(item));
end;

procedure TFHIRTurtleComposer.ComposeExplanationOfBenefitAddItemDetailSubDetail(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitAddItemDetailSubDetail; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExplanationOfBenefitAddItemDetailSubDetail'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'ExplanationOfBenefit.addItem.detail.subDetail', 'productOrService', elem.productOrServiceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.modifierList.Count - 1 do
      ComposeCodeableConcept(this, 'ExplanationOfBenefit.addItem.detail.subDetail', 'modifier', elem.modifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'ExplanationOfBenefit.addItem.detail.subDetail', 'quantity', elem.quantityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ExplanationOfBenefit.addItem.detail.subDetail', 'unitPrice', elem.unitPriceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'ExplanationOfBenefit.addItem.detail.subDetail', 'factor', elem.factorElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ExplanationOfBenefit.addItem.detail.subDetail', 'net', elem.netElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.noteNumberList.Count - 1 do
      ComposePositiveInt(this, 'ExplanationOfBenefit.addItem.detail.subDetail', 'noteNumber', elem.noteNumberList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeExplanationOfBenefitItemAdjudication(this, 'ExplanationOfBenefit.addItem.detail.subDetail', 'adjudication', elem.adjudicationList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseExplanationOfBenefitTotal(obj : TTurtleComplex) : TFhirExplanationOfBenefitTotal;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExplanationOfBenefitTotal.create;
  try
    ParseExplanationOfBenefitTotalProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExplanationOfBenefitTotalProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitTotal);
begin
    ParseBackboneElementProperties(obj, result);
    result.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.total.category'));{q3b}
    result.amount := ParseMoney(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.total.amount'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeExplanationOfBenefitTotal(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitTotal; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExplanationOfBenefitTotal'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'ExplanationOfBenefit.total', 'category', elem.categoryElement, false, -1);{x.2f}
  ComposeMoney(this, 'ExplanationOfBenefit.total', 'amount', elem.amountElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseExplanationOfBenefitPayment(obj : TTurtleComplex) : TFhirExplanationOfBenefitPayment;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExplanationOfBenefitPayment.create;
  try
    ParseExplanationOfBenefitPaymentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExplanationOfBenefitPaymentProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitPayment);
begin
    ParseBackboneElementProperties(obj, result);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.payment.type'));{q3b}
    result.adjustment := ParseMoney(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.payment.adjustment'));{q3b}
    result.adjustmentReason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.payment.adjustmentReason'));{q3b}
    result.dateElement := ParseDate(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.payment.date'));{q1}
    result.amount := ParseMoney(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.payment.amount'));{q3b}
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.payment.identifier'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeExplanationOfBenefitPayment(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitPayment; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExplanationOfBenefitPayment'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.payment', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ExplanationOfBenefit.payment', 'adjustment', elem.adjustmentElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.payment', 'adjustmentReason', elem.adjustmentReasonElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(this, 'ExplanationOfBenefit.payment', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'ExplanationOfBenefit.payment', 'amount', elem.amountElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(this, 'ExplanationOfBenefit.payment', 'identifier', elem.identifierElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseExplanationOfBenefitProcessNote(obj : TTurtleComplex) : TFhirExplanationOfBenefitProcessNote;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExplanationOfBenefitProcessNote.create;
  try
    ParseExplanationOfBenefitProcessNoteProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExplanationOfBenefitProcessNoteProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitProcessNote);
begin
    ParseBackboneElementProperties(obj, result);
    result.numberElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.processNote.number'));{q1}
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.processNote.type'), CODES_TFhirNoteTypeEnum, SYSTEMS_TFhirNoteTypeEnum);
    result.textElement := ParseString(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.processNote.text'));{q1}
    result.language := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.processNote.language'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeExplanationOfBenefitProcessNote(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitProcessNote; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExplanationOfBenefitProcessNote'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(this, 'ExplanationOfBenefit.processNote', 'number', elem.numberElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'ExplanationOfBenefit.processNote', 'type', elem.Type_Element, CODES_TFhirNoteTypeEnum, SYSTEMS_TFhirNoteTypeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ExplanationOfBenefit.processNote', 'text', elem.textElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.processNote', 'language', elem.languageElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseExplanationOfBenefitBenefitBalance(obj : TTurtleComplex) : TFhirExplanationOfBenefitBenefitBalance;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExplanationOfBenefitBenefitBalance.create;
  try
    ParseExplanationOfBenefitBenefitBalanceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExplanationOfBenefitBenefitBalanceProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitBenefitBalance);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.benefitBalance.category'));{q3b}
    result.excludedElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.benefitBalance.excluded'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.benefitBalance.name'));{q1}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.benefitBalance.description'));{q1}
    result.network := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.benefitBalance.network'));{q3b}
    result.unit_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.benefitBalance.unit'));{q3b}
    result.term := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.benefitBalance.term'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.benefitBalance.financial') do
      result.financialList.Add(parseExplanationOfBenefitBenefitBalanceFinancial(item));
end;

procedure TFHIRTurtleComposer.ComposeExplanationOfBenefitBenefitBalance(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitBenefitBalance; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExplanationOfBenefitBenefitBalance'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'ExplanationOfBenefit.benefitBalance', 'category', elem.categoryElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'ExplanationOfBenefit.benefitBalance', 'excluded', elem.excludedElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ExplanationOfBenefit.benefitBalance', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ExplanationOfBenefit.benefitBalance', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.benefitBalance', 'network', elem.networkElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.benefitBalance', 'unit', elem.unit_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit.benefitBalance', 'term', elem.termElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.financialList.Count - 1 do
      ComposeExplanationOfBenefitBenefitBalanceFinancial(this, 'ExplanationOfBenefit.benefitBalance', 'financial', elem.financialList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseExplanationOfBenefitBenefitBalanceFinancial(obj : TTurtleComplex) : TFhirExplanationOfBenefitBenefitBalanceFinancial;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExplanationOfBenefitBenefitBalanceFinancial.create;
  try
    ParseExplanationOfBenefitBenefitBalanceFinancialProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExplanationOfBenefitBenefitBalanceFinancialProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefitBenefitBalanceFinancial);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.benefitBalance.financial.type'));{q3b}
    if obj.has('http://hl7.org/fhir/ExplanationOfBenefit.benefitBalance.financial.allowedUnsignedInt', item) then
      result.allowed := parseUnsignedInt(item);
    if obj.has('http://hl7.org/fhir/ExplanationOfBenefit.benefitBalance.financial.allowedMoney', item) then
      result.allowed := parseMoney(item);
    if obj.has('http://hl7.org/fhir/ExplanationOfBenefit.benefitBalance.financial.allowedString', item) then
      result.allowed := parseString(item);
    if obj.has('http://hl7.org/fhir/ExplanationOfBenefit.benefitBalance.financial.usedUnsignedInt', item) then
      result.used := parseUnsignedInt(item);
    if obj.has('http://hl7.org/fhir/ExplanationOfBenefit.benefitBalance.financial.usedMoney', item) then
      result.used := parseMoney(item);
end;

procedure TFHIRTurtleComposer.ComposeExplanationOfBenefitBenefitBalanceFinancial(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefitBenefitBalanceFinancial; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExplanationOfBenefitBenefitBalanceFinancial'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'ExplanationOfBenefit.benefitBalance.financial', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and (elem.allowed is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(this, 'ExplanationOfBenefit.benefitBalance.financial', 'allowedUnsignedInt', TFhirUnsignedInt(elem.allowed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.allowed is TFhirMoney) {6} then
    ComposeMoney(this, 'ExplanationOfBenefit.benefitBalance.financial', 'allowedMoney', TFhirMoney(elem.allowed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.allowed is TFhirString) {6} then
    ComposeString(this, 'ExplanationOfBenefit.benefitBalance.financial', 'allowedString', TFhirString(elem.allowed), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) and (elem.used is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(this, 'ExplanationOfBenefit.benefitBalance.financial', 'usedUnsignedInt', TFhirUnsignedInt(elem.used), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.used is TFhirMoney) {6} then
    ComposeMoney(this, 'ExplanationOfBenefit.benefitBalance.financial', 'usedMoney', TFhirMoney(elem.used), false, -1);{x.d9}
end;

function TFHIRTurtleParser.ParseExplanationOfBenefit(obj : TTurtleComplex) : TFhirExplanationOfBenefit;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirExplanationOfBenefit.create;
  try
    ParseExplanationOfBenefitProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseExplanationOfBenefitProperties(obj : TTurtleComplex; result : TFhirExplanationOfBenefit);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.status'), CODES_TFhirExplanationofbenefitStatusEnum, SYSTEMS_TFhirExplanationofbenefitStatusEnum);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.type'));{q3b}
    result.subType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.subType'));{q3b}
    result.useElement := ParseEnum(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.use'), CODES_TFhirClaimUseEnum, SYSTEMS_TFhirClaimUseEnum);
    result.patient := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.patient'));{q3b}
    result.billablePeriod := ParsePeriod(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.billablePeriod'));{q3b}
    result.createdElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.created'));{q1}
    result.enterer := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.enterer'));{q3b}
    result.insurer := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.insurer'));{q3b}
    result.provider := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.provider'));{q3b}
    result.priority := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.priority'));{q3b}
    result.fundsReserveRequested := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.fundsReserveRequested'));{q3b}
    result.fundsReserve := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.fundsReserve'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.related') do
      result.relatedList.Add(parseExplanationOfBenefitRelated(item));
    result.prescription := ParseReference{TFhirMedicationRequest}(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.prescription'));{q3b}
    result.originalPrescription := ParseReference{TFhirMedicationRequest}(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.originalPrescription'));{q3b}
    result.payee := ParseExplanationOfBenefitPayee(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.payee'));{q3b}
    result.referral := ParseReference{TFhirServiceRequest}(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.referral'));{q3b}
    result.facility := ParseReference{TFhirLocation}(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.facility'));{q3b}
    result.claim := ParseReference{TFhirClaim}(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.claim'));{q3b}
    result.claimResponse := ParseReference{TFhirClaimResponse}(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.claimResponse'));{q3b}
    result.outcomeElement := ParseEnum(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.outcome'), CODES_TFhirRemittanceOutcomeEnum, SYSTEMS_TFhirRemittanceOutcomeEnum);
    result.dispositionElement := ParseString(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.disposition'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.preAuthRef') do
      result.preAuthRefList.Add(parseString(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.preAuthRefPeriod') do
      result.preAuthRefPeriodList.Add(parsePeriod(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.careTeam') do
      result.careTeamList.Add(parseExplanationOfBenefitCareTeam(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.supportingInfo') do
      result.supportingInfoList.Add(parseExplanationOfBenefitSupportingInfo(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.diagnosis') do
      result.diagnosisList.Add(parseExplanationOfBenefitDiagnosis(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.procedure') do
      result.procedure_List.Add(parseExplanationOfBenefitProcedure(item));
    result.precedenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.precedence'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.insurance') do
      result.insuranceList.Add(parseExplanationOfBenefitInsurance(item));
    result.accident := ParseExplanationOfBenefitAccident(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.accident'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.item') do
      result.itemList.Add(parseExplanationOfBenefitItem(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.addItem') do
      result.addItemList.Add(parseExplanationOfBenefitAddItem(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.adjudication') do
      result.adjudicationList.Add(parseExplanationOfBenefitItemAdjudication(item));
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.total') do
      result.totalList.Add(parseExplanationOfBenefitTotal(item));
    result.payment := ParseExplanationOfBenefitPayment(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.payment'));{q3b}
    result.formCode := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.formCode'));{q3b}
    result.form := ParseAttachment(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.form'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.processNote') do
      result.processNoteList.Add(parseExplanationOfBenefitProcessNote(item));
    result.benefitPeriod := ParsePeriod(obj.complex('http://hl7.org/fhir/ExplanationOfBenefit.benefitPeriod'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ExplanationOfBenefit.benefitBalance') do
      result.benefitBalanceList.Add(parseExplanationOfBenefitBenefitBalance(item));
end;

procedure TFHIRTurtleComposer.ComposeExplanationOfBenefit(parent :  TTurtleComplex; parentType, name : String; elem : TFhirExplanationOfBenefit; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ExplanationOfBenefit'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'ExplanationOfBenefit', 'identifier', elem.identifierList[i], false, i);{x.d3}
  ComposeEnum(this, 'ExplanationOfBenefit', 'status', elem.StatusElement, CODES_TFhirExplanationofbenefitStatusEnum, SYSTEMS_TFhirExplanationofbenefitStatusEnum, false, -1);{x.d4}
  ComposeCodeableConcept(this, 'ExplanationOfBenefit', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('subType') then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit', 'subType', elem.subTypeElement, false, -1);{x.2f}
  ComposeEnum(this, 'ExplanationOfBenefit', 'use', elem.UseElement, CODES_TFhirClaimUseEnum, SYSTEMS_TFhirClaimUseEnum, false, -1);{x.d4}
  ComposeReference{TFhirPatient}(this, 'ExplanationOfBenefit', 'patient', elem.patientElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('billablePeriod') then
    ComposePeriod(this, 'ExplanationOfBenefit', 'billablePeriod', elem.billablePeriodElement, false, -1);{x.2f}
  ComposeDateTime(this, 'ExplanationOfBenefit', 'created', elem.createdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('enterer') then
    ComposeReference{TFhirPractitioner}(this, 'ExplanationOfBenefit', 'enterer', elem.entererElement, false, -1);{x.2f}
  ComposeReference{TFhirOrganization}(this, 'ExplanationOfBenefit', 'insurer', elem.insurerElement, false, -1);{x.2f}
  ComposeReference{TFhirPractitioner}(this, 'ExplanationOfBenefit', 'provider', elem.providerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('priority') then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit', 'priority', elem.priorityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('fundsReserveRequested') then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit', 'fundsReserveRequested', elem.fundsReserveRequestedElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('fundsReserve') then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit', 'fundsReserve', elem.fundsReserveElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('related') then
    for i := 0 to elem.relatedList.Count - 1 do
      ComposeExplanationOfBenefitRelated(this, 'ExplanationOfBenefit', 'related', elem.relatedList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('prescription') then
    ComposeReference{TFhirMedicationRequest}(this, 'ExplanationOfBenefit', 'prescription', elem.prescriptionElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('originalPrescription') then
    ComposeReference{TFhirMedicationRequest}(this, 'ExplanationOfBenefit', 'originalPrescription', elem.originalPrescriptionElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('payee') then
    ComposeExplanationOfBenefitPayee(this, 'ExplanationOfBenefit', 'payee', elem.payeeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('referral') then
    ComposeReference{TFhirServiceRequest}(this, 'ExplanationOfBenefit', 'referral', elem.referralElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('facility') then
    ComposeReference{TFhirLocation}(this, 'ExplanationOfBenefit', 'facility', elem.facilityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('claim') then
    ComposeReference{TFhirClaim}(this, 'ExplanationOfBenefit', 'claim', elem.claimElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('claimResponse') then
    ComposeReference{TFhirClaimResponse}(this, 'ExplanationOfBenefit', 'claimResponse', elem.claimResponseElement, false, -1);{x.2f}
  ComposeEnum(this, 'ExplanationOfBenefit', 'outcome', elem.OutcomeElement, CODES_TFhirRemittanceOutcomeEnum, SYSTEMS_TFhirRemittanceOutcomeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('disposition') then
    ComposeString(this, 'ExplanationOfBenefit', 'disposition', elem.dispositionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('preAuthRef') then
    for i := 0 to elem.preAuthRefList.Count - 1 do
      ComposeString(this, 'ExplanationOfBenefit', 'preAuthRef', elem.preAuthRefList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('preAuthRefPeriod') then
    for i := 0 to elem.preAuthRefPeriodList.Count - 1 do
      ComposePeriod(this, 'ExplanationOfBenefit', 'preAuthRefPeriod', elem.preAuthRefPeriodList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('careTeam') then
    for i := 0 to elem.careTeamList.Count - 1 do
      ComposeExplanationOfBenefitCareTeam(this, 'ExplanationOfBenefit', 'careTeam', elem.careTeamList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('supportingInfo') then
    for i := 0 to elem.supportingInfoList.Count - 1 do
      ComposeExplanationOfBenefitSupportingInfo(this, 'ExplanationOfBenefit', 'supportingInfo', elem.supportingInfoList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('diagnosis') then
    for i := 0 to elem.diagnosisList.Count - 1 do
      ComposeExplanationOfBenefitDiagnosis(this, 'ExplanationOfBenefit', 'diagnosis', elem.diagnosisList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('procedure_') then
    for i := 0 to elem.procedure_List.Count - 1 do
      ComposeExplanationOfBenefitProcedure(this, 'ExplanationOfBenefit', 'procedure', elem.procedure_List[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('precedence') then
    ComposePositiveInt(this, 'ExplanationOfBenefit', 'precedence', elem.precedenceElement, false, -1);{x.2ea}
  for i := 0 to elem.insuranceList.Count - 1 do
      ComposeExplanationOfBenefitInsurance(this, 'ExplanationOfBenefit', 'insurance', elem.insuranceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('accident') then
    ComposeExplanationOfBenefitAccident(this, 'ExplanationOfBenefit', 'accident', elem.accidentElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('item') then
    for i := 0 to elem.itemList.Count - 1 do
      ComposeExplanationOfBenefitItem(this, 'ExplanationOfBenefit', 'item', elem.itemList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('addItem') then
    for i := 0 to elem.addItemList.Count - 1 do
      ComposeExplanationOfBenefitAddItem(this, 'ExplanationOfBenefit', 'addItem', elem.addItemList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('adjudication') then
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeExplanationOfBenefitItemAdjudication(this, 'ExplanationOfBenefit', 'adjudication', elem.adjudicationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('total') then
    for i := 0 to elem.totalList.Count - 1 do
      ComposeExplanationOfBenefitTotal(this, 'ExplanationOfBenefit', 'total', elem.totalList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('payment') then
    ComposeExplanationOfBenefitPayment(this, 'ExplanationOfBenefit', 'payment', elem.paymentElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('formCode') then
    ComposeCodeableConcept(this, 'ExplanationOfBenefit', 'formCode', elem.formCodeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('form') then
    ComposeAttachment(this, 'ExplanationOfBenefit', 'form', elem.formElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('processNote') then
    for i := 0 to elem.processNoteList.Count - 1 do
      ComposeExplanationOfBenefitProcessNote(this, 'ExplanationOfBenefit', 'processNote', elem.processNoteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('benefitPeriod') then
    ComposePeriod(this, 'ExplanationOfBenefit', 'benefitPeriod', elem.benefitPeriodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('benefitBalance') then
    for i := 0 to elem.benefitBalanceList.Count - 1 do
      ComposeExplanationOfBenefitBenefitBalance(this, 'ExplanationOfBenefit', 'benefitBalance', elem.benefitBalanceList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_EXPLANATIONOFBENEFIT}
{$IFDEF FHIR_FAMILYMEMBERHISTORY}
function TFHIRTurtleParser.ParseFamilyMemberHistoryCondition(obj : TTurtleComplex) : TFhirFamilyMemberHistoryCondition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirFamilyMemberHistoryCondition.create;
  try
    ParseFamilyMemberHistoryConditionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseFamilyMemberHistoryConditionProperties(obj : TTurtleComplex; result : TFhirFamilyMemberHistoryCondition);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/FamilyMemberHistory.condition.code'));{q3b}
    result.outcome := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/FamilyMemberHistory.condition.outcome'));{q3b}
    result.contributedToDeathElement := ParseBoolean(obj.complex('http://hl7.org/fhir/FamilyMemberHistory.condition.contributedToDeath'));{q1}
    if obj.has('http://hl7.org/fhir/FamilyMemberHistory.condition.onsetAge', item) then
      result.onset := parseAge(item);
    if obj.has('http://hl7.org/fhir/FamilyMemberHistory.condition.onsetRange', item) then
      result.onset := parseRange(item);
    if obj.has('http://hl7.org/fhir/FamilyMemberHistory.condition.onsetPeriod', item) then
      result.onset := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/FamilyMemberHistory.condition.onsetString', item) then
      result.onset := parseString(item);
    for item in obj.complexes('http://hl7.org/fhir/FamilyMemberHistory.condition.note') do
      result.noteList.Add(parseAnnotation(item));
end;

procedure TFHIRTurtleComposer.ComposeFamilyMemberHistoryCondition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirFamilyMemberHistoryCondition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:FamilyMemberHistoryCondition'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'FamilyMemberHistory.condition', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'FamilyMemberHistory.condition', 'outcome', elem.outcomeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'FamilyMemberHistory.condition', 'contributedToDeath', elem.contributedToDeathElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and (elem.onset is TFhirAge) {6} then
    ComposeAge(this, 'FamilyMemberHistory.condition', 'onsetAge', TFhirAge(elem.onset), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.onset is TFhirRange) {6} then
    ComposeRange(this, 'FamilyMemberHistory.condition', 'onsetRange', TFhirRange(elem.onset), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.onset is TFhirPeriod) {6} then
    ComposePeriod(this, 'FamilyMemberHistory.condition', 'onsetPeriod', TFhirPeriod(elem.onset), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.onset is TFhirString) {6} then
    ComposeString(this, 'FamilyMemberHistory.condition', 'onsetString', TFhirString(elem.onset), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'FamilyMemberHistory.condition', 'note', elem.noteList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseFamilyMemberHistory(obj : TTurtleComplex) : TFhirFamilyMemberHistory;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirFamilyMemberHistory.create;
  try
    ParseFamilyMemberHistoryProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseFamilyMemberHistoryProperties(obj : TTurtleComplex; result : TFhirFamilyMemberHistory);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/FamilyMemberHistory.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/FamilyMemberHistory.instantiatesCanonical') do
      result.instantiatesCanonicalList.Add(parseCanonical(item));
    for item in obj.complexes('http://hl7.org/fhir/FamilyMemberHistory.instantiatesUri') do
      result.instantiatesUriList.Add(parseUri(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/FamilyMemberHistory.status'), CODES_TFhirHistoryStatusEnum, SYSTEMS_TFhirHistoryStatusEnum);
    result.dataAbsentReason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/FamilyMemberHistory.dataAbsentReason'));{q3b}
    result.patient := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/FamilyMemberHistory.patient'));{q3b}
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/FamilyMemberHistory.date'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/FamilyMemberHistory.name'));{q1}
    result.relationship := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/FamilyMemberHistory.relationship'));{q3b}
    result.sex := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/FamilyMemberHistory.sex'));{q3b}
    if obj.has('http://hl7.org/fhir/FamilyMemberHistory.bornPeriod', item) then
      result.born := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/FamilyMemberHistory.bornDate', item) then
      result.born := parseDate(item);
    if obj.has('http://hl7.org/fhir/FamilyMemberHistory.bornString', item) then
      result.born := parseString(item);
    if obj.has('http://hl7.org/fhir/FamilyMemberHistory.ageAge', item) then
      result.age := parseAge(item);
    if obj.has('http://hl7.org/fhir/FamilyMemberHistory.ageRange', item) then
      result.age := parseRange(item);
    if obj.has('http://hl7.org/fhir/FamilyMemberHistory.ageString', item) then
      result.age := parseString(item);
    result.estimatedAgeElement := ParseBoolean(obj.complex('http://hl7.org/fhir/FamilyMemberHistory.estimatedAge'));{q1}
    if obj.has('http://hl7.org/fhir/FamilyMemberHistory.deceasedAge', item) then
      result.deceased := parseAge(item);
    if obj.has('http://hl7.org/fhir/FamilyMemberHistory.deceasedRange', item) then
      result.deceased := parseRange(item);
    if obj.has('http://hl7.org/fhir/FamilyMemberHistory.deceasedBoolean', item) then
      result.deceased := parseBoolean(item);
    if obj.has('http://hl7.org/fhir/FamilyMemberHistory.deceasedDate', item) then
      result.deceased := parseDate(item);
    if obj.has('http://hl7.org/fhir/FamilyMemberHistory.deceasedString', item) then
      result.deceased := parseString(item);
    for item in obj.complexes('http://hl7.org/fhir/FamilyMemberHistory.reasonCode') do
      result.reasonCodeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/FamilyMemberHistory.reasonReference') do
      result.reasonReferenceList.Add(parseReference{TFhirCondition}(item));
    for item in obj.complexes('http://hl7.org/fhir/FamilyMemberHistory.note') do
      result.noteList.Add(parseAnnotation(item));
    for item in obj.complexes('http://hl7.org/fhir/FamilyMemberHistory.condition') do
      result.conditionList.Add(parseFamilyMemberHistoryCondition(item));
end;

procedure TFHIRTurtleComposer.ComposeFamilyMemberHistory(parent :  TTurtleComplex; parentType, name : String; elem : TFhirFamilyMemberHistory; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:FamilyMemberHistory'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'FamilyMemberHistory', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('instantiatesCanonical') then
    for i := 0 to elem.instantiatesCanonicalList.Count - 1 do
      ComposeCanonical(this, 'FamilyMemberHistory', 'instantiatesCanonical', elem.instantiatesCanonicalList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('instantiatesUri') then
    for i := 0 to elem.instantiatesUriList.Count - 1 do
      ComposeUri(this, 'FamilyMemberHistory', 'instantiatesUri', elem.instantiatesUriList[i], false, i);{x.d3}
  ComposeEnum(this, 'FamilyMemberHistory', 'status', elem.StatusElement, CODES_TFhirHistoryStatusEnum, SYSTEMS_TFhirHistoryStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dataAbsentReason') then
    ComposeCodeableConcept(this, 'FamilyMemberHistory', 'dataAbsentReason', elem.dataAbsentReasonElement, false, -1);{x.2f}
  ComposeReference{TFhirPatient}(this, 'FamilyMemberHistory', 'patient', elem.patientElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(this, 'FamilyMemberHistory', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(this, 'FamilyMemberHistory', 'name', elem.nameElement, false, -1);{x.2ea}
  ComposeCodeableConcept(this, 'FamilyMemberHistory', 'relationship', elem.relationshipElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('sex') then
    ComposeCodeableConcept(this, 'FamilyMemberHistory', 'sex', elem.sexElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and (elem.born is TFhirPeriod) {6} then
    ComposePeriod(this, 'FamilyMemberHistory', 'bornPeriod', TFhirPeriod(elem.born), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.born is TFhirDate) {6} then
    ComposeDate(this, 'FamilyMemberHistory', 'bornDate', TFhirDate(elem.born), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.born is TFhirString) {6} then
    ComposeString(this, 'FamilyMemberHistory', 'bornString', TFhirString(elem.born), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.age is TFhirAge) {6} then
    ComposeAge(this, 'FamilyMemberHistory', 'ageAge', TFhirAge(elem.age), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.age is TFhirRange) {6} then
    ComposeRange(this, 'FamilyMemberHistory', 'ageRange', TFhirRange(elem.age), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.age is TFhirString) {6} then
    ComposeString(this, 'FamilyMemberHistory', 'ageString', TFhirString(elem.age), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('estimatedAge') then
    ComposeBoolean(this, 'FamilyMemberHistory', 'estimatedAge', elem.estimatedAgeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.deceased is TFhirAge) {6} then
    ComposeAge(this, 'FamilyMemberHistory', 'deceasedAge', TFhirAge(elem.deceased), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.deceased is TFhirRange) {6} then
    ComposeRange(this, 'FamilyMemberHistory', 'deceasedRange', TFhirRange(elem.deceased), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.deceased is TFhirBoolean) {6} then
    ComposeBoolean(this, 'FamilyMemberHistory', 'deceasedBoolean', TFhirBoolean(elem.deceased), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.deceased is TFhirDate) {6} then
    ComposeDate(this, 'FamilyMemberHistory', 'deceasedDate', TFhirDate(elem.deceased), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.deceased is TFhirString) {6} then
    ComposeString(this, 'FamilyMemberHistory', 'deceasedString', TFhirString(elem.deceased), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonCode') then
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'FamilyMemberHistory', 'reasonCode', elem.reasonCodeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonReference') then
    for i := 0 to elem.reasonReferenceList.Count - 1 do
      ComposeReference{TFhirCondition}(this, 'FamilyMemberHistory', 'reasonReference', elem.reasonReferenceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'FamilyMemberHistory', 'note', elem.noteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('condition') then
    for i := 0 to elem.conditionList.Count - 1 do
      ComposeFamilyMemberHistoryCondition(this, 'FamilyMemberHistory', 'condition', elem.conditionList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_FAMILYMEMBERHISTORY}
{$IFDEF FHIR_FLAG}
function TFHIRTurtleParser.ParseFlag(obj : TTurtleComplex) : TFhirFlag;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirFlag.create;
  try
    ParseFlagProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseFlagProperties(obj : TTurtleComplex; result : TFhirFlag);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Flag.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Flag.status'), CODES_TFhirFlagStatusEnum, SYSTEMS_TFhirFlagStatusEnum);
    for item in obj.complexes('http://hl7.org/fhir/Flag.category') do
      result.categoryList.Add(parseCodeableConcept(item));
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Flag.code'));{q3b}
    result.subject := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/Flag.subject'));{q3b}
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Flag.period'));{q3b}
    result.encounter := ParseReference{TFhirEncounter}(obj.complex('http://hl7.org/fhir/Flag.encounter'));{q3b}
    result.author := ParseReference{TFhirDevice}(obj.complex('http://hl7.org/fhir/Flag.author'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeFlag(parent :  TTurtleComplex; parentType, name : String; elem : TFhirFlag; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Flag'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Flag', 'identifier', elem.identifierList[i], false, i);{x.d3}
  ComposeEnum(this, 'Flag', 'status', elem.StatusElement, CODES_TFhirFlagStatusEnum, SYSTEMS_TFhirFlagStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(this, 'Flag', 'category', elem.categoryList[i], false, i);{x.d3}
  ComposeCodeableConcept(this, 'Flag', 'code', elem.codeElement, false, -1);{x.2f}
  ComposeReference{TFhirPatient}(this, 'Flag', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('period') then
    ComposePeriod(this, 'Flag', 'period', elem.periodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(this, 'Flag', 'encounter', elem.encounterElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('author') then
    ComposeReference{TFhirDevice}(this, 'Flag', 'author', elem.authorElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_FLAG}
{$IFDEF FHIR_GOAL}
function TFHIRTurtleParser.ParseGoalTarget(obj : TTurtleComplex) : TFhirGoalTarget;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirGoalTarget.create;
  try
    ParseGoalTargetProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseGoalTargetProperties(obj : TTurtleComplex; result : TFhirGoalTarget);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.measure := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Goal.target.measure'));{q3b}
    if obj.has('http://hl7.org/fhir/Goal.target.detailQuantity', item) then
      result.detail := parseQuantity(item);
    if obj.has('http://hl7.org/fhir/Goal.target.detailRange', item) then
      result.detail := parseRange(item);
    if obj.has('http://hl7.org/fhir/Goal.target.detailCodeableConcept', item) then
      result.detail := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/Goal.target.detailRatio', item) then
      result.detail := parseRatio(item);
    if obj.has('http://hl7.org/fhir/Goal.target.detailString', item) then
      result.detail := parseString(item);
    if obj.has('http://hl7.org/fhir/Goal.target.detailBoolean', item) then
      result.detail := parseBoolean(item);
    if obj.has('http://hl7.org/fhir/Goal.target.detailInteger', item) then
      result.detail := parseInteger(item);
    if obj.has('http://hl7.org/fhir/Goal.target.dueDuration', item) then
      result.due := parseDuration(item);
    if obj.has('http://hl7.org/fhir/Goal.target.dueDate', item) then
      result.due := parseDate(item);
end;

procedure TFHIRTurtleComposer.ComposeGoalTarget(parent :  TTurtleComplex; parentType, name : String; elem : TFhirGoalTarget; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:GoalTarget'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Goal.target', 'measure', elem.measureElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.detail is TFhirQuantity) {6} then
    ComposeQuantity(this, 'Goal.target', 'detailQuantity', TFhirQuantity(elem.detail), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.detail is TFhirRange) {6} then
    ComposeRange(this, 'Goal.target', 'detailRange', TFhirRange(elem.detail), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.detail is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Goal.target', 'detailCodeableConcept', TFhirCodeableConcept(elem.detail), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.detail is TFhirRatio) {6} then
    ComposeRatio(this, 'Goal.target', 'detailRatio', TFhirRatio(elem.detail), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.detail is TFhirString) {6} then
    ComposeString(this, 'Goal.target', 'detailString', TFhirString(elem.detail), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.detail is TFhirBoolean) {6} then
    ComposeBoolean(this, 'Goal.target', 'detailBoolean', TFhirBoolean(elem.detail), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.detail is TFhirInteger) {6} then
    ComposeInteger(this, 'Goal.target', 'detailInteger', TFhirInteger(elem.detail), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.due is TFhirDuration) {6} then
    ComposeDuration(this, 'Goal.target', 'dueDuration', TFhirDuration(elem.due), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.due is TFhirDate) {6} then
    ComposeDate(this, 'Goal.target', 'dueDate', TFhirDate(elem.due), false, -1);{x.d9}
end;

function TFHIRTurtleParser.ParseGoal(obj : TTurtleComplex) : TFhirGoal;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirGoal.create;
  try
    ParseGoalProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseGoalProperties(obj : TTurtleComplex; result : TFhirGoal);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Goal.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.lifecycleStatusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Goal.lifecycleStatus'), CODES_TFhirGoalStatusEnum, SYSTEMS_TFhirGoalStatusEnum);
    result.achievementStatus := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Goal.achievementStatus'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Goal.category') do
      result.categoryList.Add(parseCodeableConcept(item));
    result.priority := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Goal.priority'));{q3b}
    result.description := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Goal.description'));{q3b}
    result.subject := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/Goal.subject'));{q3b}
    if obj.has('http://hl7.org/fhir/Goal.startCodeableConcept', item) then
      result.start := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/Goal.startDate', item) then
      result.start := parseDate(item);
    for item in obj.complexes('http://hl7.org/fhir/Goal.target') do
      result.targetList.Add(parseGoalTarget(item));
    result.statusDateElement := ParseDate(obj.complex('http://hl7.org/fhir/Goal.statusDate'));{q1}
    result.statusReasonElement := ParseString(obj.complex('http://hl7.org/fhir/Goal.statusReason'));{q1}
    result.expressedBy := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/Goal.expressedBy'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Goal.addresses') do
      result.addressesList.Add(parseReference{TFhirCondition}(item));
    for item in obj.complexes('http://hl7.org/fhir/Goal.note') do
      result.noteList.Add(parseAnnotation(item));
    for item in obj.complexes('http://hl7.org/fhir/Goal.outcomeCode') do
      result.outcomeCodeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Goal.outcomeReference') do
      result.outcomeReferenceList.Add(parseReference{TFhirObservation}(item));
end;

procedure TFHIRTurtleComposer.ComposeGoal(parent :  TTurtleComplex; parentType, name : String; elem : TFhirGoal; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Goal'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Goal', 'identifier', elem.identifierList[i], false, i);{x.d3}
  ComposeEnum(this, 'Goal', 'lifecycleStatus', elem.LifecycleStatusElement, CODES_TFhirGoalStatusEnum, SYSTEMS_TFhirGoalStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('achievementStatus') then
    ComposeCodeableConcept(this, 'Goal', 'achievementStatus', elem.achievementStatusElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(this, 'Goal', 'category', elem.categoryList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('priority') then
    ComposeCodeableConcept(this, 'Goal', 'priority', elem.priorityElement, false, -1);{x.2f}
  ComposeCodeableConcept(this, 'Goal', 'description', elem.descriptionElement, false, -1);{x.2f}
  ComposeReference{TFhirPatient}(this, 'Goal', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.start is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Goal', 'startCodeableConcept', TFhirCodeableConcept(elem.start), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.start is TFhirDate) {6} then
    ComposeDate(this, 'Goal', 'startDate', TFhirDate(elem.start), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) and doCompose('target') then
    for i := 0 to elem.targetList.Count - 1 do
      ComposeGoalTarget(this, 'Goal', 'target', elem.targetList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('statusDate') then
    ComposeDate(this, 'Goal', 'statusDate', elem.statusDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('statusReason') then
    ComposeString(this, 'Goal', 'statusReason', elem.statusReasonElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('expressedBy') then
    ComposeReference{TFhirPatient}(this, 'Goal', 'expressedBy', elem.expressedByElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('addresses') then
    for i := 0 to elem.addressesList.Count - 1 do
      ComposeReference{TFhirCondition}(this, 'Goal', 'addresses', elem.addressesList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'Goal', 'note', elem.noteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('outcomeCode') then
    for i := 0 to elem.outcomeCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'Goal', 'outcomeCode', elem.outcomeCodeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('outcomeReference') then
    for i := 0 to elem.outcomeReferenceList.Count - 1 do
      ComposeReference{TFhirObservation}(this, 'Goal', 'outcomeReference', elem.outcomeReferenceList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_GOAL}
{$IFDEF FHIR_GRAPHDEFINITION}
function TFHIRTurtleParser.ParseGraphDefinitionLink(obj : TTurtleComplex) : TFhirGraphDefinitionLink;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirGraphDefinitionLink.create;
  try
    ParseGraphDefinitionLinkProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseGraphDefinitionLinkProperties(obj : TTurtleComplex; result : TFhirGraphDefinitionLink);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.pathElement := ParseString(obj.complex('http://hl7.org/fhir/GraphDefinition.link.path'));{q1}
    result.sliceNameElement := ParseString(obj.complex('http://hl7.org/fhir/GraphDefinition.link.sliceName'));{q1}
    result.minElement := ParseInteger(obj.complex('http://hl7.org/fhir/GraphDefinition.link.min'));{q1}
    result.maxElement := ParseString(obj.complex('http://hl7.org/fhir/GraphDefinition.link.max'));{q1}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/GraphDefinition.link.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/GraphDefinition.link.target') do
      result.targetList.Add(parseGraphDefinitionLinkTarget(item));
end;

procedure TFHIRTurtleComposer.ComposeGraphDefinitionLink(parent :  TTurtleComplex; parentType, name : String; elem : TFhirGraphDefinitionLink; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:GraphDefinitionLink'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'GraphDefinition.link', 'path', elem.pathElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'GraphDefinition.link', 'sliceName', elem.sliceNameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(this, 'GraphDefinition.link', 'min', elem.minElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'GraphDefinition.link', 'max', elem.maxElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'GraphDefinition.link', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.targetList.Count - 1 do
      ComposeGraphDefinitionLinkTarget(this, 'GraphDefinition.link', 'target', elem.targetList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseGraphDefinitionLinkTarget(obj : TTurtleComplex) : TFhirGraphDefinitionLinkTarget;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirGraphDefinitionLinkTarget.create;
  try
    ParseGraphDefinitionLinkTargetProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseGraphDefinitionLinkTargetProperties(obj : TTurtleComplex; result : TFhirGraphDefinitionLinkTarget);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/GraphDefinition.link.target.type'), CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum);
    result.paramsElement := ParseString(obj.complex('http://hl7.org/fhir/GraphDefinition.link.target.params'));{q1}
    result.profileElement := ParseCanonical(obj.complex('http://hl7.org/fhir/GraphDefinition.link.target.profile'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/GraphDefinition.link.target.compartment') do
      result.compartmentList.Add(parseGraphDefinitionLinkTargetCompartment(item));
    for item in obj.complexes('http://hl7.org/fhir/GraphDefinition.link.target.link') do
      result.link_List.Add(parseGraphDefinitionLink(item));
end;

procedure TFHIRTurtleComposer.ComposeGraphDefinitionLinkTarget(parent :  TTurtleComplex; parentType, name : String; elem : TFhirGraphDefinitionLinkTarget; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:GraphDefinitionLinkTarget'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'GraphDefinition.link.target', 'type', elem.Type_Element, CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'GraphDefinition.link.target', 'params', elem.paramsElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(this, 'GraphDefinition.link.target', 'profile', elem.profileElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.compartmentList.Count - 1 do
      ComposeGraphDefinitionLinkTargetCompartment(this, 'GraphDefinition.link.target', 'compartment', elem.compartmentList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.link_List.Count - 1 do
      ComposeGraphDefinitionLink(this, 'GraphDefinition.link.target', 'link', elem.link_List[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseGraphDefinitionLinkTargetCompartment(obj : TTurtleComplex) : TFhirGraphDefinitionLinkTargetCompartment;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirGraphDefinitionLinkTargetCompartment.create;
  try
    ParseGraphDefinitionLinkTargetCompartmentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseGraphDefinitionLinkTargetCompartmentProperties(obj : TTurtleComplex; result : TFhirGraphDefinitionLinkTargetCompartment);
begin
    ParseBackboneElementProperties(obj, result);
    result.useElement := ParseEnum(obj.complex('http://hl7.org/fhir/GraphDefinition.link.target.compartment.use'), CODES_TFhirGraphCompartmentUseEnum, SYSTEMS_TFhirGraphCompartmentUseEnum);
    result.codeElement := ParseEnum(obj.complex('http://hl7.org/fhir/GraphDefinition.link.target.compartment.code'), CODES_TFhirCompartmentTypeEnum, SYSTEMS_TFhirCompartmentTypeEnum);
    result.ruleElement := ParseEnum(obj.complex('http://hl7.org/fhir/GraphDefinition.link.target.compartment.rule'), CODES_TFhirGraphCompartmentRuleEnum, SYSTEMS_TFhirGraphCompartmentRuleEnum);
    result.expressionElement := ParseString(obj.complex('http://hl7.org/fhir/GraphDefinition.link.target.compartment.expression'));{q1}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/GraphDefinition.link.target.compartment.description'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeGraphDefinitionLinkTargetCompartment(parent :  TTurtleComplex; parentType, name : String; elem : TFhirGraphDefinitionLinkTargetCompartment; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:GraphDefinitionLinkTargetCompartment'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'GraphDefinition.link.target.compartment', 'use', elem.UseElement, CODES_TFhirGraphCompartmentUseEnum, SYSTEMS_TFhirGraphCompartmentUseEnum, false, -1);{x.d4}
  ComposeEnum(this, 'GraphDefinition.link.target.compartment', 'code', elem.CodeElement, CODES_TFhirCompartmentTypeEnum, SYSTEMS_TFhirCompartmentTypeEnum, false, -1);{x.d4}
  ComposeEnum(this, 'GraphDefinition.link.target.compartment', 'rule', elem.RuleElement, CODES_TFhirGraphCompartmentRuleEnum, SYSTEMS_TFhirGraphCompartmentRuleEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'GraphDefinition.link.target.compartment', 'expression', elem.expressionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'GraphDefinition.link.target.compartment', 'description', elem.descriptionElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseGraphDefinition(obj : TTurtleComplex) : TFhirGraphDefinition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirGraphDefinition.create;
  try
    ParseGraphDefinitionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseGraphDefinitionProperties(obj : TTurtleComplex; result : TFhirGraphDefinition);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/GraphDefinition.url'));{q1}
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/GraphDefinition.version'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/GraphDefinition.name'));{q1}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/GraphDefinition.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    result.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/GraphDefinition.experimental'));{q1}
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/GraphDefinition.date'));{q1}
    result.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/GraphDefinition.publisher'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/GraphDefinition.contact') do
      result.contactList.Add(parseContactDetail(item));
    result.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/GraphDefinition.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/GraphDefinition.useContext') do
      result.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/GraphDefinition.jurisdiction') do
      result.jurisdictionList.Add(parseCodeableConcept(item));
    result.purposeElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/GraphDefinition.purpose'));{q1}
    result.startElement := ParseEnum(obj.complex('http://hl7.org/fhir/GraphDefinition.start'), CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum);
    result.profileElement := ParseCanonical(obj.complex('http://hl7.org/fhir/GraphDefinition.profile'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/GraphDefinition.link') do
      result.link_List.Add(parseGraphDefinitionLink(item));
end;

procedure TFHIRTurtleComposer.ComposeGraphDefinition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirGraphDefinition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:GraphDefinition'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUri(this, 'GraphDefinition', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(this, 'GraphDefinition', 'version', elem.versionElement, false, -1);{x.2ea}
  ComposeString(this, 'GraphDefinition', 'name', elem.nameElement, false, -1);{x.2ea}
  ComposeEnum(this, 'GraphDefinition', 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(this, 'GraphDefinition', 'experimental', elem.experimentalElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(this, 'GraphDefinition', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(this, 'GraphDefinition', 'publisher', elem.publisherElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(this, 'GraphDefinition', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdown(this, 'GraphDefinition', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(this, 'GraphDefinition', 'useContext', elem.useContextList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'GraphDefinition', 'jurisdiction', elem.jurisdictionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdown(this, 'GraphDefinition', 'purpose', elem.purposeElement, false, -1);{x.2ea}
  ComposeEnum(this, 'GraphDefinition', 'start', elem.StartElement, CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('profile') then
    ComposeCanonical(this, 'GraphDefinition', 'profile', elem.profileElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('link_') then
    for i := 0 to elem.link_List.Count - 1 do
      ComposeGraphDefinitionLink(this, 'GraphDefinition', 'link', elem.link_List[i], false, i);{x.d3}
end;

{$ENDIF FHIR_GRAPHDEFINITION}
{$IFDEF FHIR_GROUP}
function TFHIRTurtleParser.ParseGroupCharacteristic(obj : TTurtleComplex) : TFhirGroupCharacteristic;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirGroupCharacteristic.create;
  try
    ParseGroupCharacteristicProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseGroupCharacteristicProperties(obj : TTurtleComplex; result : TFhirGroupCharacteristic);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Group.characteristic.code'));{q3b}
    if obj.has('http://hl7.org/fhir/Group.characteristic.valueCodeableConcept', item) then
      result.value := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/Group.characteristic.valueQuantity', item) then
      result.value := parseQuantity(item);
    if obj.has('http://hl7.org/fhir/Group.characteristic.valueRange', item) then
      result.value := parseRange(item);
    if obj.has('http://hl7.org/fhir/Group.characteristic.valueReference', item) then
      result.value := parseReference(item);
    if obj.has('http://hl7.org/fhir/Group.characteristic.valueBoolean', item) then
      result.value := parseBoolean(item);
    result.excludeElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Group.characteristic.exclude'));{q1}
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Group.characteristic.period'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeGroupCharacteristic(parent :  TTurtleComplex; parentType, name : String; elem : TFhirGroupCharacteristic; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:GroupCharacteristic'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'Group.characteristic', 'code', elem.codeElement, false, -1);{x.2f}
  if (elem.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Group.characteristic', 'valueCodeableConcept', TFhirCodeableConcept(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'Group.characteristic', 'valueQuantity', TFhirQuantity(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirRange) {6} then
    ComposeRange(this, 'Group.characteristic', 'valueRange', TFhirRange(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirReference) {6} then
    ComposeReference(this, 'Group.characteristic', 'valueReference', TFhirReference(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirBoolean) {6} then
    ComposeBoolean(this, 'Group.characteristic', 'valueBoolean', TFhirBoolean(elem.value), false, -1);{x.d9}
  ComposeBoolean(this, 'Group.characteristic', 'exclude', elem.excludeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'Group.characteristic', 'period', elem.periodElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseGroupMember(obj : TTurtleComplex) : TFhirGroupMember;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirGroupMember.create;
  try
    ParseGroupMemberProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseGroupMemberProperties(obj : TTurtleComplex; result : TFhirGroupMember);
begin
    ParseBackboneElementProperties(obj, result);
    result.entity := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/Group.member.entity'));{q3b}
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Group.member.period'));{q3b}
    result.inactiveElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Group.member.inactive'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeGroupMember(parent :  TTurtleComplex; parentType, name : String; elem : TFhirGroupMember; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:GroupMember'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeReference{TFhirPatient}(this, 'Group.member', 'entity', elem.entityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'Group.member', 'period', elem.periodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'Group.member', 'inactive', elem.inactiveElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseGroup(obj : TTurtleComplex) : TFhirGroup;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirGroup.create;
  try
    ParseGroupProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseGroupProperties(obj : TTurtleComplex; result : TFhirGroup);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Group.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.activeElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Group.active'));{q1}
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/Group.type'), CODES_TFhirGroupTypeEnum, SYSTEMS_TFhirGroupTypeEnum);
    result.actualElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Group.actual'));{q1}
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Group.code'));{q3b}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/Group.name'));{q1}
    result.quantityElement := ParseUnsignedInt(obj.complex('http://hl7.org/fhir/Group.quantity'));{q1}
    result.managingEntity := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/Group.managingEntity'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Group.characteristic') do
      result.characteristicList.Add(parseGroupCharacteristic(item));
    for item in obj.complexes('http://hl7.org/fhir/Group.member') do
      result.memberList.Add(parseGroupMember(item));
end;

procedure TFHIRTurtleComposer.ComposeGroup(parent :  TTurtleComplex; parentType, name : String; elem : TFhirGroup; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Group'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Group', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('active') then
    ComposeBoolean(this, 'Group', 'active', elem.activeElement, false, -1);{x.2ea}
  ComposeEnum(this, 'Group', 'type', elem.Type_Element, CODES_TFhirGroupTypeEnum, SYSTEMS_TFhirGroupTypeEnum, false, -1);{x.d4}
  ComposeBoolean(this, 'Group', 'actual', elem.actualElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') then
    ComposeCodeableConcept(this, 'Group', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(this, 'Group', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('quantity') then
    ComposeUnsignedInt(this, 'Group', 'quantity', elem.quantityElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('managingEntity') then
    ComposeReference{TFhirOrganization}(this, 'Group', 'managingEntity', elem.managingEntityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('characteristic') then
    for i := 0 to elem.characteristicList.Count - 1 do
      ComposeGroupCharacteristic(this, 'Group', 'characteristic', elem.characteristicList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('member') then
    for i := 0 to elem.memberList.Count - 1 do
      ComposeGroupMember(this, 'Group', 'member', elem.memberList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_GROUP}
{$IFDEF FHIR_GUIDANCERESPONSE}
function TFHIRTurtleParser.ParseGuidanceResponse(obj : TTurtleComplex) : TFhirGuidanceResponse;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirGuidanceResponse.create;
  try
    ParseGuidanceResponseProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseGuidanceResponseProperties(obj : TTurtleComplex; result : TFhirGuidanceResponse);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.requestIdentifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/GuidanceResponse.requestIdentifier'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/GuidanceResponse.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    if obj.has('http://hl7.org/fhir/GuidanceResponse.moduleCanonical', item) then
      result.module := parseCanonical(item);
    if obj.has('http://hl7.org/fhir/GuidanceResponse.moduleCodeableConcept', item) then
      result.module := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/GuidanceResponse.moduleUri', item) then
      result.module := parseUri(item);
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/GuidanceResponse.status'), CODES_TFhirGuidanceResponseStatusEnum, SYSTEMS_TFhirGuidanceResponseStatusEnum);
    result.subject := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/GuidanceResponse.subject'));{q3b}
    result.encounter := ParseReference{TFhirEncounter}(obj.complex('http://hl7.org/fhir/GuidanceResponse.encounter'));{q3b}
    result.occurrenceDateTimeElement := ParseDateTime(obj.complex('http://hl7.org/fhir/GuidanceResponse.occurrenceDateTime'));{q1}
    result.performer := ParseReference{TFhirDevice}(obj.complex('http://hl7.org/fhir/GuidanceResponse.performer'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/GuidanceResponse.reasonCode') do
      result.reasonCodeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/GuidanceResponse.reasonReference') do
      result.reasonReferenceList.Add(parseReference{TFhirCondition}(item));
    for item in obj.complexes('http://hl7.org/fhir/GuidanceResponse.note') do
      result.noteList.Add(parseAnnotation(item));
    for item in obj.complexes('http://hl7.org/fhir/GuidanceResponse.evaluationMessage') do
      result.evaluationMessageList.Add(parseReference{TFhirOperationOutcome}(item));
    result.outputParameters := ParseReference{TFhirParameters}(obj.complex('http://hl7.org/fhir/GuidanceResponse.outputParameters'));{q3b}
    result.result := ParseReference{TFhirCarePlan}(obj.complex('http://hl7.org/fhir/GuidanceResponse.result'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/GuidanceResponse.dataRequirement') do
      result.dataRequirementList.Add(parseDataRequirement(item));
end;

procedure TFHIRTurtleComposer.ComposeGuidanceResponse(parent :  TTurtleComplex; parentType, name : String; elem : TFhirGuidanceResponse; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:GuidanceResponse'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requestIdentifier') then
    ComposeIdentifier(this, 'GuidanceResponse', 'requestIdentifier', elem.requestIdentifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'GuidanceResponse', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (elem.module is TFhirCanonical) {6} then
    ComposeCanonical(this, 'GuidanceResponse', 'moduleCanonical', TFhirCanonical(elem.module), false, -1){x.d9}
  else if (elem.module is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'GuidanceResponse', 'moduleCodeableConcept', TFhirCodeableConcept(elem.module), false, -1){x.d9}
  else if (elem.module is TFhirUri) {6} then
    ComposeUri(this, 'GuidanceResponse', 'moduleUri', TFhirUri(elem.module), false, -1);{x.d9}
  ComposeEnum(this, 'GuidanceResponse', 'status', elem.StatusElement, CODES_TFhirGuidanceResponseStatusEnum, SYSTEMS_TFhirGuidanceResponseStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('subject') then
    ComposeReference{TFhirPatient}(this, 'GuidanceResponse', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(this, 'GuidanceResponse', 'encounter', elem.encounterElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('occurrenceDateTime') then
    ComposeDateTime(this, 'GuidanceResponse', 'occurrenceDateTime', elem.occurrenceDateTimeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('performer') then
    ComposeReference{TFhirDevice}(this, 'GuidanceResponse', 'performer', elem.performerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('reasonCode') then
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'GuidanceResponse', 'reasonCode', elem.reasonCodeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('reasonReference') then
    for i := 0 to elem.reasonReferenceList.Count - 1 do
      ComposeReference{TFhirCondition}(this, 'GuidanceResponse', 'reasonReference', elem.reasonReferenceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'GuidanceResponse', 'note', elem.noteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('evaluationMessage') then
    for i := 0 to elem.evaluationMessageList.Count - 1 do
      ComposeReference{TFhirOperationOutcome}(this, 'GuidanceResponse', 'evaluationMessage', elem.evaluationMessageList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('outputParameters') then
    ComposeReference{TFhirParameters}(this, 'GuidanceResponse', 'outputParameters', elem.outputParametersElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('result') then
    ComposeReference{TFhirCarePlan}(this, 'GuidanceResponse', 'result', elem.resultElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('dataRequirement') then
    for i := 0 to elem.dataRequirementList.Count - 1 do
      ComposeDataRequirement(this, 'GuidanceResponse', 'dataRequirement', elem.dataRequirementList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_GUIDANCERESPONSE}
{$IFDEF FHIR_HEALTHCARESERVICE}
function TFHIRTurtleParser.ParseHealthcareServiceEligibility(obj : TTurtleComplex) : TFhirHealthcareServiceEligibility;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirHealthcareServiceEligibility.create;
  try
    ParseHealthcareServiceEligibilityProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseHealthcareServiceEligibilityProperties(obj : TTurtleComplex; result : TFhirHealthcareServiceEligibility);
begin
    ParseBackboneElementProperties(obj, result);
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/HealthcareService.eligibility.code'));{q3b}
    result.commentElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/HealthcareService.eligibility.comment'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeHealthcareServiceEligibility(parent :  TTurtleComplex; parentType, name : String; elem : TFhirHealthcareServiceEligibility; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:HealthcareServiceEligibility'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'HealthcareService.eligibility', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'HealthcareService.eligibility', 'comment', elem.commentElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseHealthcareServiceAvailableTime(obj : TTurtleComplex) : TFhirHealthcareServiceAvailableTime;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirHealthcareServiceAvailableTime.create;
  try
    ParseHealthcareServiceAvailableTimeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseHealthcareServiceAvailableTimeProperties(obj : TTurtleComplex; result : TFhirHealthcareServiceAvailableTime);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/HealthcareService.availableTime.daysOfWeek') do
      result.daysOfWeekList.Add(parseEnum(item, CODES_TFhirDaysOfWeekEnum, SYSTEMS_TFhirDaysOfWeekEnum));
    result.allDayElement := ParseBoolean(obj.complex('http://hl7.org/fhir/HealthcareService.availableTime.allDay'));{q1}
    result.availableStartTimeElement := ParseTime(obj.complex('http://hl7.org/fhir/HealthcareService.availableTime.availableStartTime'));{q1}
    result.availableEndTimeElement := ParseTime(obj.complex('http://hl7.org/fhir/HealthcareService.availableTime.availableEndTime'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeHealthcareServiceAvailableTime(parent :  TTurtleComplex; parentType, name : String; elem : TFhirHealthcareServiceAvailableTime; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:HealthcareServiceAvailableTime'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.daysOfWeekList.Count - 1 do
      ComposeEnum(this, 'HealthcareService.availableTime', 'daysOfWeek', elem.daysOfWeekList[i], CODES_TFhirDaysOfWeekEnum, SYSTEMS_TFhirDaysOfWeekEnum, false, i); {x.d1}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.daysOfWeekList.Count - 1 do
      ComposeEnum(this, 'HealthcareService.availableTime', 'daysOfWeek', elem.daysOfWeekList[i], CODES_TFhirDaysOfWeekEnum, SYSTEMS_TFhirDaysOfWeekEnum, false, i);{x.d2}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'HealthcareService.availableTime', 'allDay', elem.allDayElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeTime(this, 'HealthcareService.availableTime', 'availableStartTime', elem.availableStartTimeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeTime(this, 'HealthcareService.availableTime', 'availableEndTime', elem.availableEndTimeElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseHealthcareServiceNotAvailable(obj : TTurtleComplex) : TFhirHealthcareServiceNotAvailable;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirHealthcareServiceNotAvailable.create;
  try
    ParseHealthcareServiceNotAvailableProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseHealthcareServiceNotAvailableProperties(obj : TTurtleComplex; result : TFhirHealthcareServiceNotAvailable);
begin
    ParseBackboneElementProperties(obj, result);
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/HealthcareService.notAvailable.description'));{q1}
    result.during := ParsePeriod(obj.complex('http://hl7.org/fhir/HealthcareService.notAvailable.during'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeHealthcareServiceNotAvailable(parent :  TTurtleComplex; parentType, name : String; elem : TFhirHealthcareServiceNotAvailable; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:HealthcareServiceNotAvailable'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeString(this, 'HealthcareService.notAvailable', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'HealthcareService.notAvailable', 'during', elem.duringElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseHealthcareService(obj : TTurtleComplex) : TFhirHealthcareService;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirHealthcareService.create;
  try
    ParseHealthcareServiceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseHealthcareServiceProperties(obj : TTurtleComplex; result : TFhirHealthcareService);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/HealthcareService.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.activeElement := ParseBoolean(obj.complex('http://hl7.org/fhir/HealthcareService.active'));{q1}
    result.providedBy := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/HealthcareService.providedBy'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/HealthcareService.category') do
      result.categoryList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/HealthcareService.type') do
      result.type_List.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/HealthcareService.specialty') do
      result.specialtyList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/HealthcareService.location') do
      result.locationList.Add(parseReference{TFhirLocation}(item));
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/HealthcareService.name'));{q1}
    result.commentElement := ParseString(obj.complex('http://hl7.org/fhir/HealthcareService.comment'));{q1}
    result.extraDetailsElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/HealthcareService.extraDetails'));{q1}
    result.photo := ParseAttachment(obj.complex('http://hl7.org/fhir/HealthcareService.photo'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/HealthcareService.telecom') do
      result.telecomList.Add(parseContactPoint(item));
    for item in obj.complexes('http://hl7.org/fhir/HealthcareService.coverageArea') do
      result.coverageAreaList.Add(parseReference{TFhirLocation}(item));
    for item in obj.complexes('http://hl7.org/fhir/HealthcareService.serviceProvisionCode') do
      result.serviceProvisionCodeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/HealthcareService.eligibility') do
      result.eligibilityList.Add(parseHealthcareServiceEligibility(item));
    for item in obj.complexes('http://hl7.org/fhir/HealthcareService.program') do
      result.program_List.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/HealthcareService.characteristic') do
      result.characteristicList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/HealthcareService.communication') do
      result.communicationList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/HealthcareService.referralMethod') do
      result.referralMethodList.Add(parseCodeableConcept(item));
    result.appointmentRequiredElement := ParseBoolean(obj.complex('http://hl7.org/fhir/HealthcareService.appointmentRequired'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/HealthcareService.availableTime') do
      result.availableTimeList.Add(parseHealthcareServiceAvailableTime(item));
    for item in obj.complexes('http://hl7.org/fhir/HealthcareService.notAvailable') do
      result.notAvailableList.Add(parseHealthcareServiceNotAvailable(item));
    result.availabilityExceptionsElement := ParseString(obj.complex('http://hl7.org/fhir/HealthcareService.availabilityExceptions'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/HealthcareService.endpoint') do
      result.endpointList.Add(parseReference{TFhirEndpoint}(item));
end;

procedure TFHIRTurtleComposer.ComposeHealthcareService(parent :  TTurtleComplex; parentType, name : String; elem : TFhirHealthcareService; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:HealthcareService'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'HealthcareService', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('active') then
    ComposeBoolean(this, 'HealthcareService', 'active', elem.activeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('providedBy') then
    ComposeReference{TFhirOrganization}(this, 'HealthcareService', 'providedBy', elem.providedByElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(this, 'HealthcareService', 'category', elem.categoryList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(this, 'HealthcareService', 'type', elem.type_List[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('specialty') then
    for i := 0 to elem.specialtyList.Count - 1 do
      ComposeCodeableConcept(this, 'HealthcareService', 'specialty', elem.specialtyList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('location') then
    for i := 0 to elem.locationList.Count - 1 do
      ComposeReference{TFhirLocation}(this, 'HealthcareService', 'location', elem.locationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(this, 'HealthcareService', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('comment') then
    ComposeString(this, 'HealthcareService', 'comment', elem.commentElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('extraDetails') then
    ComposeMarkdown(this, 'HealthcareService', 'extraDetails', elem.extraDetailsElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('photo') then
    ComposeAttachment(this, 'HealthcareService', 'photo', elem.photoElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('telecom') then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(this, 'HealthcareService', 'telecom', elem.telecomList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('coverageArea') then
    for i := 0 to elem.coverageAreaList.Count - 1 do
      ComposeReference{TFhirLocation}(this, 'HealthcareService', 'coverageArea', elem.coverageAreaList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('serviceProvisionCode') then
    for i := 0 to elem.serviceProvisionCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'HealthcareService', 'serviceProvisionCode', elem.serviceProvisionCodeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('eligibility') then
    for i := 0 to elem.eligibilityList.Count - 1 do
      ComposeHealthcareServiceEligibility(this, 'HealthcareService', 'eligibility', elem.eligibilityList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('program_') then
    for i := 0 to elem.program_List.Count - 1 do
      ComposeCodeableConcept(this, 'HealthcareService', 'program', elem.program_List[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('characteristic') then
    for i := 0 to elem.characteristicList.Count - 1 do
      ComposeCodeableConcept(this, 'HealthcareService', 'characteristic', elem.characteristicList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('communication') then
    for i := 0 to elem.communicationList.Count - 1 do
      ComposeCodeableConcept(this, 'HealthcareService', 'communication', elem.communicationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('referralMethod') then
    for i := 0 to elem.referralMethodList.Count - 1 do
      ComposeCodeableConcept(this, 'HealthcareService', 'referralMethod', elem.referralMethodList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('appointmentRequired') then
    ComposeBoolean(this, 'HealthcareService', 'appointmentRequired', elem.appointmentRequiredElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('availableTime') then
    for i := 0 to elem.availableTimeList.Count - 1 do
      ComposeHealthcareServiceAvailableTime(this, 'HealthcareService', 'availableTime', elem.availableTimeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('notAvailable') then
    for i := 0 to elem.notAvailableList.Count - 1 do
      ComposeHealthcareServiceNotAvailable(this, 'HealthcareService', 'notAvailable', elem.notAvailableList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('availabilityExceptions') then
    ComposeString(this, 'HealthcareService', 'availabilityExceptions', elem.availabilityExceptionsElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('endpoint') then
    for i := 0 to elem.endpointList.Count - 1 do
      ComposeReference{TFhirEndpoint}(this, 'HealthcareService', 'endpoint', elem.endpointList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_HEALTHCARESERVICE}
{$IFDEF FHIR_IMAGINGSTUDY}
function TFHIRTurtleParser.ParseImagingStudySeries(obj : TTurtleComplex) : TFhirImagingStudySeries;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImagingStudySeries.create;
  try
    ParseImagingStudySeriesProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImagingStudySeriesProperties(obj : TTurtleComplex; result : TFhirImagingStudySeries);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.uidElement := ParseId(obj.complex('http://hl7.org/fhir/ImagingStudy.series.uid'));{q1}
    result.numberElement := ParseUnsignedInt(obj.complex('http://hl7.org/fhir/ImagingStudy.series.number'));{q1}
    result.modality := ParseCoding(obj.complex('http://hl7.org/fhir/ImagingStudy.series.modality'));{q3b}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/ImagingStudy.series.description'));{q1}
    result.numberOfInstancesElement := ParseUnsignedInt(obj.complex('http://hl7.org/fhir/ImagingStudy.series.numberOfInstances'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ImagingStudy.series.endpoint') do
      result.endpointList.Add(parseReference{TFhirEndpoint}(item));
    result.bodySite := ParseCoding(obj.complex('http://hl7.org/fhir/ImagingStudy.series.bodySite'));{q3b}
    result.laterality := ParseCoding(obj.complex('http://hl7.org/fhir/ImagingStudy.series.laterality'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ImagingStudy.series.specimen') do
      result.specimenList.Add(parseReference{TFhirSpecimen}(item));
    result.startedElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ImagingStudy.series.started'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ImagingStudy.series.performer') do
      result.performerList.Add(parseImagingStudySeriesPerformer(item));
    for item in obj.complexes('http://hl7.org/fhir/ImagingStudy.series.instance') do
      result.instanceList.Add(parseImagingStudySeriesInstance(item));
end;

procedure TFHIRTurtleComposer.ComposeImagingStudySeries(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImagingStudySeries; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImagingStudySeries'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeId(this, 'ImagingStudy.series', 'uid', elem.uidElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedInt(this, 'ImagingStudy.series', 'number', elem.numberElement, false, -1);{x.2ea}
  ComposeCoding(this, 'ImagingStudy.series', 'modality', elem.modalityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ImagingStudy.series', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedInt(this, 'ImagingStudy.series', 'numberOfInstances', elem.numberOfInstancesElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.endpointList.Count - 1 do
      ComposeReference{TFhirEndpoint}(this, 'ImagingStudy.series', 'endpoint', elem.endpointList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(this, 'ImagingStudy.series', 'bodySite', elem.bodySiteElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(this, 'ImagingStudy.series', 'laterality', elem.lateralityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.specimenList.Count - 1 do
      ComposeReference{TFhirSpecimen}(this, 'ImagingStudy.series', 'specimen', elem.specimenList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'ImagingStudy.series', 'started', elem.startedElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.performerList.Count - 1 do
      ComposeImagingStudySeriesPerformer(this, 'ImagingStudy.series', 'performer', elem.performerList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.instanceList.Count - 1 do
      ComposeImagingStudySeriesInstance(this, 'ImagingStudy.series', 'instance', elem.instanceList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseImagingStudySeriesPerformer(obj : TTurtleComplex) : TFhirImagingStudySeriesPerformer;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImagingStudySeriesPerformer.create;
  try
    ParseImagingStudySeriesPerformerProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImagingStudySeriesPerformerProperties(obj : TTurtleComplex; result : TFhirImagingStudySeriesPerformer);
begin
    ParseBackboneElementProperties(obj, result);
    result.function_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ImagingStudy.series.performer.function'));{q3b}
    result.actor := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/ImagingStudy.series.performer.actor'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeImagingStudySeriesPerformer(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImagingStudySeriesPerformer; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImagingStudySeriesPerformer'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'ImagingStudy.series.performer', 'function', elem.function_Element, false, -1);{x.2f}
  ComposeReference{TFhirPractitioner}(this, 'ImagingStudy.series.performer', 'actor', elem.actorElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseImagingStudySeriesInstance(obj : TTurtleComplex) : TFhirImagingStudySeriesInstance;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImagingStudySeriesInstance.create;
  try
    ParseImagingStudySeriesInstanceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImagingStudySeriesInstanceProperties(obj : TTurtleComplex; result : TFhirImagingStudySeriesInstance);
begin
    ParseBackboneElementProperties(obj, result);
    result.uidElement := ParseId(obj.complex('http://hl7.org/fhir/ImagingStudy.series.instance.uid'));{q1}
    result.sopClass := ParseCoding(obj.complex('http://hl7.org/fhir/ImagingStudy.series.instance.sopClass'));{q3b}
    result.numberElement := ParseUnsignedInt(obj.complex('http://hl7.org/fhir/ImagingStudy.series.instance.number'));{q1}
    result.titleElement := ParseString(obj.complex('http://hl7.org/fhir/ImagingStudy.series.instance.title'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeImagingStudySeriesInstance(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImagingStudySeriesInstance; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImagingStudySeriesInstance'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeId(this, 'ImagingStudy.series.instance', 'uid', elem.uidElement, false, -1);{x.2ea}
  ComposeCoding(this, 'ImagingStudy.series.instance', 'sopClass', elem.sopClassElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeUnsignedInt(this, 'ImagingStudy.series.instance', 'number', elem.numberElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ImagingStudy.series.instance', 'title', elem.titleElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseImagingStudy(obj : TTurtleComplex) : TFhirImagingStudy;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImagingStudy.create;
  try
    ParseImagingStudyProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImagingStudyProperties(obj : TTurtleComplex; result : TFhirImagingStudy);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/ImagingStudy.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/ImagingStudy.status'), CODES_TFhirImagingstudyStatusEnum, SYSTEMS_TFhirImagingstudyStatusEnum);
    for item in obj.complexes('http://hl7.org/fhir/ImagingStudy.modality') do
      result.modalityList.Add(parseCoding(item));
    result.subject := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/ImagingStudy.subject'));{q3b}
    result.encounter := ParseReference{TFhirEncounter}(obj.complex('http://hl7.org/fhir/ImagingStudy.encounter'));{q3b}
    result.startedElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ImagingStudy.started'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ImagingStudy.basedOn') do
      result.basedOnList.Add(parseReference{TFhirCarePlan}(item));
    result.referrer := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/ImagingStudy.referrer'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ImagingStudy.interpreter') do
      result.interpreterList.Add(parseReference{TFhirPractitioner}(item));
    for item in obj.complexes('http://hl7.org/fhir/ImagingStudy.endpoint') do
      result.endpointList.Add(parseReference{TFhirEndpoint}(item));
    result.numberOfSeriesElement := ParseUnsignedInt(obj.complex('http://hl7.org/fhir/ImagingStudy.numberOfSeries'));{q1}
    result.numberOfInstancesElement := ParseUnsignedInt(obj.complex('http://hl7.org/fhir/ImagingStudy.numberOfInstances'));{q1}
    result.procedureReference := ParseReference{TFhirProcedure}(obj.complex('http://hl7.org/fhir/ImagingStudy.procedureReference'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ImagingStudy.procedureCode') do
      result.procedureCodeList.Add(parseCodeableConcept(item));
    result.location := ParseReference{TFhirLocation}(obj.complex('http://hl7.org/fhir/ImagingStudy.location'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ImagingStudy.reasonCode') do
      result.reasonCodeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/ImagingStudy.reasonReference') do
      result.reasonReferenceList.Add(parseReference{TFhirCondition}(item));
    for item in obj.complexes('http://hl7.org/fhir/ImagingStudy.note') do
      result.noteList.Add(parseAnnotation(item));
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/ImagingStudy.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ImagingStudy.series') do
      result.seriesList.Add(parseImagingStudySeries(item));
end;

procedure TFHIRTurtleComposer.ComposeImagingStudy(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImagingStudy; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImagingStudy'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'ImagingStudy', 'identifier', elem.identifierList[i], false, i);{x.d3}
  ComposeEnum(this, 'ImagingStudy', 'status', elem.StatusElement, CODES_TFhirImagingstudyStatusEnum, SYSTEMS_TFhirImagingstudyStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('modality') then
    for i := 0 to elem.modalityList.Count - 1 do
      ComposeCoding(this, 'ImagingStudy', 'modality', elem.modalityList[i], false, i);{x.d3}
  ComposeReference{TFhirPatient}(this, 'ImagingStudy', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(this, 'ImagingStudy', 'encounter', elem.encounterElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('started') then
    ComposeDateTime(this, 'ImagingStudy', 'started', elem.startedElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('basedOn') then
    for i := 0 to elem.basedOnList.Count - 1 do
      ComposeReference{TFhirCarePlan}(this, 'ImagingStudy', 'basedOn', elem.basedOnList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('referrer') then
    ComposeReference{TFhirPractitioner}(this, 'ImagingStudy', 'referrer', elem.referrerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('interpreter') then
    for i := 0 to elem.interpreterList.Count - 1 do
      ComposeReference{TFhirPractitioner}(this, 'ImagingStudy', 'interpreter', elem.interpreterList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('endpoint') then
    for i := 0 to elem.endpointList.Count - 1 do
      ComposeReference{TFhirEndpoint}(this, 'ImagingStudy', 'endpoint', elem.endpointList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('numberOfSeries') then
    ComposeUnsignedInt(this, 'ImagingStudy', 'numberOfSeries', elem.numberOfSeriesElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('numberOfInstances') then
    ComposeUnsignedInt(this, 'ImagingStudy', 'numberOfInstances', elem.numberOfInstancesElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('procedureReference') then
    ComposeReference{TFhirProcedure}(this, 'ImagingStudy', 'procedureReference', elem.procedureReferenceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('procedureCode') then
    for i := 0 to elem.procedureCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'ImagingStudy', 'procedureCode', elem.procedureCodeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('location') then
    ComposeReference{TFhirLocation}(this, 'ImagingStudy', 'location', elem.locationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonCode') then
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'ImagingStudy', 'reasonCode', elem.reasonCodeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonReference') then
    for i := 0 to elem.reasonReferenceList.Count - 1 do
      ComposeReference{TFhirCondition}(this, 'ImagingStudy', 'reasonReference', elem.reasonReferenceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'ImagingStudy', 'note', elem.noteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeString(this, 'ImagingStudy', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('series') then
    for i := 0 to elem.seriesList.Count - 1 do
      ComposeImagingStudySeries(this, 'ImagingStudy', 'series', elem.seriesList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_IMAGINGSTUDY}
{$IFDEF FHIR_IMMUNIZATION}
function TFHIRTurtleParser.ParseImmunizationPerformer(obj : TTurtleComplex) : TFhirImmunizationPerformer;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImmunizationPerformer.create;
  try
    ParseImmunizationPerformerProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImmunizationPerformerProperties(obj : TTurtleComplex; result : TFhirImmunizationPerformer);
begin
    ParseBackboneElementProperties(obj, result);
    result.function_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Immunization.performer.function'));{q3b}
    result.actor := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/Immunization.performer.actor'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeImmunizationPerformer(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImmunizationPerformer; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImmunizationPerformer'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Immunization.performer', 'function', elem.function_Element, false, -1);{x.2f}
  ComposeReference{TFhirPractitioner}(this, 'Immunization.performer', 'actor', elem.actorElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseImmunizationEducation(obj : TTurtleComplex) : TFhirImmunizationEducation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImmunizationEducation.create;
  try
    ParseImmunizationEducationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImmunizationEducationProperties(obj : TTurtleComplex; result : TFhirImmunizationEducation);
begin
    ParseBackboneElementProperties(obj, result);
    result.documentTypeElement := ParseString(obj.complex('http://hl7.org/fhir/Immunization.education.documentType'));{q1}
    result.referenceElement := ParseUri(obj.complex('http://hl7.org/fhir/Immunization.education.reference'));{q1}
    result.publicationDateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Immunization.education.publicationDate'));{q1}
    result.presentationDateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Immunization.education.presentationDate'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeImmunizationEducation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImmunizationEducation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImmunizationEducation'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Immunization.education', 'documentType', elem.documentTypeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'Immunization.education', 'reference', elem.referenceElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'Immunization.education', 'publicationDate', elem.publicationDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'Immunization.education', 'presentationDate', elem.presentationDateElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseImmunizationReaction(obj : TTurtleComplex) : TFhirImmunizationReaction;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImmunizationReaction.create;
  try
    ParseImmunizationReactionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImmunizationReactionProperties(obj : TTurtleComplex; result : TFhirImmunizationReaction);
begin
    ParseBackboneElementProperties(obj, result);
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Immunization.reaction.date'));{q1}
    result.detail := ParseReference{TFhirObservation}(obj.complex('http://hl7.org/fhir/Immunization.reaction.detail'));{q3b}
    result.reportedElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Immunization.reaction.reported'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeImmunizationReaction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImmunizationReaction; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImmunizationReaction'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'Immunization.reaction', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirObservation}(this, 'Immunization.reaction', 'detail', elem.detailElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'Immunization.reaction', 'reported', elem.reportedElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseImmunizationProtocolApplied(obj : TTurtleComplex) : TFhirImmunizationProtocolApplied;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImmunizationProtocolApplied.create;
  try
    ParseImmunizationProtocolAppliedProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImmunizationProtocolAppliedProperties(obj : TTurtleComplex; result : TFhirImmunizationProtocolApplied);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.seriesElement := ParseString(obj.complex('http://hl7.org/fhir/Immunization.protocolApplied.series'));{q1}
    result.authority := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/Immunization.protocolApplied.authority'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Immunization.protocolApplied.targetDisease') do
      result.targetDiseaseList.Add(parseCodeableConcept(item));
    if obj.has('http://hl7.org/fhir/Immunization.protocolApplied.doseNumberPositiveInt', item) then
      result.doseNumber := parsePositiveInt(item);
    if obj.has('http://hl7.org/fhir/Immunization.protocolApplied.doseNumberString', item) then
      result.doseNumber := parseString(item);
    if obj.has('http://hl7.org/fhir/Immunization.protocolApplied.seriesDosesPositiveInt', item) then
      result.seriesDoses := parsePositiveInt(item);
    if obj.has('http://hl7.org/fhir/Immunization.protocolApplied.seriesDosesString', item) then
      result.seriesDoses := parseString(item);
end;

procedure TFHIRTurtleComposer.ComposeImmunizationProtocolApplied(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImmunizationProtocolApplied; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImmunizationProtocolApplied'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Immunization.protocolApplied', 'series', elem.seriesElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(this, 'Immunization.protocolApplied', 'authority', elem.authorityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.targetDiseaseList.Count - 1 do
      ComposeCodeableConcept(this, 'Immunization.protocolApplied', 'targetDisease', elem.targetDiseaseList[i], false, i);{x.d3}
  if (elem.doseNumber is TFhirPositiveInt) {6} then
    ComposePositiveInt(this, 'Immunization.protocolApplied', 'doseNumberPositiveInt', TFhirPositiveInt(elem.doseNumber), false, -1){x.d9}
  else if (elem.doseNumber is TFhirString) {6} then
    ComposeString(this, 'Immunization.protocolApplied', 'doseNumberString', TFhirString(elem.doseNumber), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) and (elem.seriesDoses is TFhirPositiveInt) {6} then
    ComposePositiveInt(this, 'Immunization.protocolApplied', 'seriesDosesPositiveInt', TFhirPositiveInt(elem.seriesDoses), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.seriesDoses is TFhirString) {6} then
    ComposeString(this, 'Immunization.protocolApplied', 'seriesDosesString', TFhirString(elem.seriesDoses), false, -1);{x.d9}
end;

function TFHIRTurtleParser.ParseImmunization(obj : TTurtleComplex) : TFhirImmunization;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImmunization.create;
  try
    ParseImmunizationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImmunizationProperties(obj : TTurtleComplex; result : TFhirImmunization);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Immunization.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Immunization.status'), CODES_TFhirImmunizationStatusEnum, SYSTEMS_TFhirImmunizationStatusEnum);
    result.statusReason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Immunization.statusReason'));{q3b}
    result.vaccineCode := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Immunization.vaccineCode'));{q3b}
    result.patient := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/Immunization.patient'));{q3b}
    result.encounter := ParseReference{TFhirEncounter}(obj.complex('http://hl7.org/fhir/Immunization.encounter'));{q3b}
    if obj.has('http://hl7.org/fhir/Immunization.occurrenceDateTime', item) then
      result.occurrence := parseDateTime(item);
    if obj.has('http://hl7.org/fhir/Immunization.occurrenceString', item) then
      result.occurrence := parseString(item);
    result.recordedElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Immunization.recorded'));{q1}
    result.primarySourceElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Immunization.primarySource'));{q1}
    result.reportOrigin := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Immunization.reportOrigin'));{q3b}
    result.location := ParseReference{TFhirLocation}(obj.complex('http://hl7.org/fhir/Immunization.location'));{q3b}
    result.manufacturer := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/Immunization.manufacturer'));{q3b}
    result.lotNumberElement := ParseString(obj.complex('http://hl7.org/fhir/Immunization.lotNumber'));{q1}
    result.expirationDateElement := ParseDate(obj.complex('http://hl7.org/fhir/Immunization.expirationDate'));{q1}
    result.site := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Immunization.site'));{q3b}
    result.route := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Immunization.route'));{q3b}
    result.doseQuantity := ParseQuantity(obj.complex('http://hl7.org/fhir/Immunization.doseQuantity'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Immunization.performer') do
      result.performerList.Add(parseImmunizationPerformer(item));
    for item in obj.complexes('http://hl7.org/fhir/Immunization.note') do
      result.noteList.Add(parseAnnotation(item));
    for item in obj.complexes('http://hl7.org/fhir/Immunization.reasonCode') do
      result.reasonCodeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Immunization.reasonReference') do
      result.reasonReferenceList.Add(parseReference{TFhirCondition}(item));
    result.isSubpotentElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Immunization.isSubpotent'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Immunization.subpotentReason') do
      result.subpotentReasonList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Immunization.education') do
      result.educationList.Add(parseImmunizationEducation(item));
    for item in obj.complexes('http://hl7.org/fhir/Immunization.programEligibility') do
      result.programEligibilityList.Add(parseCodeableConcept(item));
    result.fundingSource := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Immunization.fundingSource'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Immunization.reaction') do
      result.reactionList.Add(parseImmunizationReaction(item));
    for item in obj.complexes('http://hl7.org/fhir/Immunization.protocolApplied') do
      result.protocolAppliedList.Add(parseImmunizationProtocolApplied(item));
end;

procedure TFHIRTurtleComposer.ComposeImmunization(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImmunization; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Immunization'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Immunization', 'identifier', elem.identifierList[i], false, i);{x.d3}
  ComposeEnum(this, 'Immunization', 'status', elem.StatusElement, CODES_TFhirImmunizationStatusEnum, SYSTEMS_TFhirImmunizationStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('statusReason') then
    ComposeCodeableConcept(this, 'Immunization', 'statusReason', elem.statusReasonElement, false, -1);{x.2f}
  ComposeCodeableConcept(this, 'Immunization', 'vaccineCode', elem.vaccineCodeElement, false, -1);{x.2f}
  ComposeReference{TFhirPatient}(this, 'Immunization', 'patient', elem.patientElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(this, 'Immunization', 'encounter', elem.encounterElement, false, -1);{x.2f}
  if (elem.occurrence is TFhirDateTime) {6} then
    ComposeDateTime(this, 'Immunization', 'occurrenceDateTime', TFhirDateTime(elem.occurrence), false, -1){x.d9}
  else if (elem.occurrence is TFhirString) {6} then
    ComposeString(this, 'Immunization', 'occurrenceString', TFhirString(elem.occurrence), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) and doCompose('recorded') then
    ComposeDateTime(this, 'Immunization', 'recorded', elem.recordedElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('primarySource') then
    ComposeBoolean(this, 'Immunization', 'primarySource', elem.primarySourceElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('reportOrigin') then
    ComposeCodeableConcept(this, 'Immunization', 'reportOrigin', elem.reportOriginElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('location') then
    ComposeReference{TFhirLocation}(this, 'Immunization', 'location', elem.locationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('manufacturer') then
    ComposeReference{TFhirOrganization}(this, 'Immunization', 'manufacturer', elem.manufacturerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('lotNumber') then
    ComposeString(this, 'Immunization', 'lotNumber', elem.lotNumberElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('expirationDate') then
    ComposeDate(this, 'Immunization', 'expirationDate', elem.expirationDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('site') then
    ComposeCodeableConcept(this, 'Immunization', 'site', elem.siteElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('route') then
    ComposeCodeableConcept(this, 'Immunization', 'route', elem.routeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('doseQuantity') then
    ComposeQuantity(this, 'Immunization', 'doseQuantity', elem.doseQuantityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('performer') then
    for i := 0 to elem.performerList.Count - 1 do
      ComposeImmunizationPerformer(this, 'Immunization', 'performer', elem.performerList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'Immunization', 'note', elem.noteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('reasonCode') then
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'Immunization', 'reasonCode', elem.reasonCodeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('reasonReference') then
    for i := 0 to elem.reasonReferenceList.Count - 1 do
      ComposeReference{TFhirCondition}(this, 'Immunization', 'reasonReference', elem.reasonReferenceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('isSubpotent') then
    ComposeBoolean(this, 'Immunization', 'isSubpotent', elem.isSubpotentElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('subpotentReason') then
    for i := 0 to elem.subpotentReasonList.Count - 1 do
      ComposeCodeableConcept(this, 'Immunization', 'subpotentReason', elem.subpotentReasonList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('education') then
    for i := 0 to elem.educationList.Count - 1 do
      ComposeImmunizationEducation(this, 'Immunization', 'education', elem.educationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('programEligibility') then
    for i := 0 to elem.programEligibilityList.Count - 1 do
      ComposeCodeableConcept(this, 'Immunization', 'programEligibility', elem.programEligibilityList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('fundingSource') then
    ComposeCodeableConcept(this, 'Immunization', 'fundingSource', elem.fundingSourceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('reaction') then
    for i := 0 to elem.reactionList.Count - 1 do
      ComposeImmunizationReaction(this, 'Immunization', 'reaction', elem.reactionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('protocolApplied') then
    for i := 0 to elem.protocolAppliedList.Count - 1 do
      ComposeImmunizationProtocolApplied(this, 'Immunization', 'protocolApplied', elem.protocolAppliedList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_IMMUNIZATION}
{$IFDEF FHIR_IMMUNIZATIONEVALUATION}
function TFHIRTurtleParser.ParseImmunizationEvaluation(obj : TTurtleComplex) : TFhirImmunizationEvaluation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImmunizationEvaluation.create;
  try
    ParseImmunizationEvaluationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImmunizationEvaluationProperties(obj : TTurtleComplex; result : TFhirImmunizationEvaluation);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/ImmunizationEvaluation.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/ImmunizationEvaluation.status'), CODES_TFhirImmunizationEvaluationStatusEnum, SYSTEMS_TFhirImmunizationEvaluationStatusEnum);
    result.patient := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/ImmunizationEvaluation.patient'));{q3b}
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ImmunizationEvaluation.date'));{q1}
    result.authority := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/ImmunizationEvaluation.authority'));{q3b}
    result.targetDisease := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ImmunizationEvaluation.targetDisease'));{q3b}
    result.immunizationEvent := ParseReference{TFhirImmunization}(obj.complex('http://hl7.org/fhir/ImmunizationEvaluation.immunizationEvent'));{q3b}
    result.doseStatus := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ImmunizationEvaluation.doseStatus'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ImmunizationEvaluation.doseStatusReason') do
      result.doseStatusReasonList.Add(parseCodeableConcept(item));
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/ImmunizationEvaluation.description'));{q1}
    result.seriesElement := ParseString(obj.complex('http://hl7.org/fhir/ImmunizationEvaluation.series'));{q1}
    if obj.has('http://hl7.org/fhir/ImmunizationEvaluation.doseNumberPositiveInt', item) then
      result.doseNumber := parsePositiveInt(item);
    if obj.has('http://hl7.org/fhir/ImmunizationEvaluation.doseNumberString', item) then
      result.doseNumber := parseString(item);
    if obj.has('http://hl7.org/fhir/ImmunizationEvaluation.seriesDosesPositiveInt', item) then
      result.seriesDoses := parsePositiveInt(item);
    if obj.has('http://hl7.org/fhir/ImmunizationEvaluation.seriesDosesString', item) then
      result.seriesDoses := parseString(item);
end;

procedure TFHIRTurtleComposer.ComposeImmunizationEvaluation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImmunizationEvaluation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImmunizationEvaluation'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'ImmunizationEvaluation', 'identifier', elem.identifierList[i], false, i);{x.d3}
  ComposeEnum(this, 'ImmunizationEvaluation', 'status', elem.StatusElement, CODES_TFhirImmunizationEvaluationStatusEnum, SYSTEMS_TFhirImmunizationEvaluationStatusEnum, false, -1);{x.d4}
  ComposeReference{TFhirPatient}(this, 'ImmunizationEvaluation', 'patient', elem.patientElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('date') then
    ComposeDateTime(this, 'ImmunizationEvaluation', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('authority') then
    ComposeReference{TFhirOrganization}(this, 'ImmunizationEvaluation', 'authority', elem.authorityElement, false, -1);{x.2f}
  ComposeCodeableConcept(this, 'ImmunizationEvaluation', 'targetDisease', elem.targetDiseaseElement, false, -1);{x.2f}
  ComposeReference{TFhirImmunization}(this, 'ImmunizationEvaluation', 'immunizationEvent', elem.immunizationEventElement, false, -1);{x.2f}
  ComposeCodeableConcept(this, 'ImmunizationEvaluation', 'doseStatus', elem.doseStatusElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('doseStatusReason') then
    for i := 0 to elem.doseStatusReasonList.Count - 1 do
      ComposeCodeableConcept(this, 'ImmunizationEvaluation', 'doseStatusReason', elem.doseStatusReasonList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeString(this, 'ImmunizationEvaluation', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('series') then
    ComposeString(this, 'ImmunizationEvaluation', 'series', elem.seriesElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and (elem.doseNumber is TFhirPositiveInt) {6} then
    ComposePositiveInt(this, 'ImmunizationEvaluation', 'doseNumberPositiveInt', TFhirPositiveInt(elem.doseNumber), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.doseNumber is TFhirString) {6} then
    ComposeString(this, 'ImmunizationEvaluation', 'doseNumberString', TFhirString(elem.doseNumber), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) and (elem.seriesDoses is TFhirPositiveInt) {6} then
    ComposePositiveInt(this, 'ImmunizationEvaluation', 'seriesDosesPositiveInt', TFhirPositiveInt(elem.seriesDoses), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.seriesDoses is TFhirString) {6} then
    ComposeString(this, 'ImmunizationEvaluation', 'seriesDosesString', TFhirString(elem.seriesDoses), false, -1);{x.d9}
end;

{$ENDIF FHIR_IMMUNIZATIONEVALUATION}
{$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
function TFHIRTurtleParser.ParseImmunizationRecommendationRecommendation(obj : TTurtleComplex) : TFhirImmunizationRecommendationRecommendation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImmunizationRecommendationRecommendation.create;
  try
    ParseImmunizationRecommendationRecommendationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImmunizationRecommendationRecommendationProperties(obj : TTurtleComplex; result : TFhirImmunizationRecommendationRecommendation);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/ImmunizationRecommendation.recommendation.vaccineCode') do
      result.vaccineCodeList.Add(parseCodeableConcept(item));
    result.targetDisease := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ImmunizationRecommendation.recommendation.targetDisease'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ImmunizationRecommendation.recommendation.contraindicatedVaccineCode') do
      result.contraindicatedVaccineCodeList.Add(parseCodeableConcept(item));
    result.forecastStatus := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ImmunizationRecommendation.recommendation.forecastStatus'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ImmunizationRecommendation.recommendation.forecastReason') do
      result.forecastReasonList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/ImmunizationRecommendation.recommendation.dateCriterion') do
      result.dateCriterionList.Add(parseImmunizationRecommendationRecommendationDateCriterion(item));
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/ImmunizationRecommendation.recommendation.description'));{q1}
    result.seriesElement := ParseString(obj.complex('http://hl7.org/fhir/ImmunizationRecommendation.recommendation.series'));{q1}
    if obj.has('http://hl7.org/fhir/ImmunizationRecommendation.recommendation.doseNumberPositiveInt', item) then
      result.doseNumber := parsePositiveInt(item);
    if obj.has('http://hl7.org/fhir/ImmunizationRecommendation.recommendation.doseNumberString', item) then
      result.doseNumber := parseString(item);
    if obj.has('http://hl7.org/fhir/ImmunizationRecommendation.recommendation.seriesDosesPositiveInt', item) then
      result.seriesDoses := parsePositiveInt(item);
    if obj.has('http://hl7.org/fhir/ImmunizationRecommendation.recommendation.seriesDosesString', item) then
      result.seriesDoses := parseString(item);
    for item in obj.complexes('http://hl7.org/fhir/ImmunizationRecommendation.recommendation.supportingImmunization') do
      result.supportingImmunizationList.Add(parseReference{TFhirImmunization}(item));
    for item in obj.complexes('http://hl7.org/fhir/ImmunizationRecommendation.recommendation.supportingPatientInformation') do
      result.supportingPatientInformationList.Add(parseReference{TFhirReference}(item));
end;

procedure TFHIRTurtleComposer.ComposeImmunizationRecommendationRecommendation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImmunizationRecommendationRecommendation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImmunizationRecommendationRecommendation'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.vaccineCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'ImmunizationRecommendation.recommendation', 'vaccineCode', elem.vaccineCodeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'ImmunizationRecommendation.recommendation', 'targetDisease', elem.targetDiseaseElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.contraindicatedVaccineCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'ImmunizationRecommendation.recommendation', 'contraindicatedVaccineCode', elem.contraindicatedVaccineCodeList[i], false, i);{x.d3}
  ComposeCodeableConcept(this, 'ImmunizationRecommendation.recommendation', 'forecastStatus', elem.forecastStatusElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.forecastReasonList.Count - 1 do
      ComposeCodeableConcept(this, 'ImmunizationRecommendation.recommendation', 'forecastReason', elem.forecastReasonList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.dateCriterionList.Count - 1 do
      ComposeImmunizationRecommendationRecommendationDateCriterion(this, 'ImmunizationRecommendation.recommendation', 'dateCriterion', elem.dateCriterionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ImmunizationRecommendation.recommendation', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ImmunizationRecommendation.recommendation', 'series', elem.seriesElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.doseNumber is TFhirPositiveInt) {6} then
    ComposePositiveInt(this, 'ImmunizationRecommendation.recommendation', 'doseNumberPositiveInt', TFhirPositiveInt(elem.doseNumber), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.doseNumber is TFhirString) {6} then
    ComposeString(this, 'ImmunizationRecommendation.recommendation', 'doseNumberString', TFhirString(elem.doseNumber), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) and (elem.seriesDoses is TFhirPositiveInt) {6} then
    ComposePositiveInt(this, 'ImmunizationRecommendation.recommendation', 'seriesDosesPositiveInt', TFhirPositiveInt(elem.seriesDoses), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.seriesDoses is TFhirString) {6} then
    ComposeString(this, 'ImmunizationRecommendation.recommendation', 'seriesDosesString', TFhirString(elem.seriesDoses), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.supportingImmunizationList.Count - 1 do
      ComposeReference{TFhirImmunization}(this, 'ImmunizationRecommendation.recommendation', 'supportingImmunization', elem.supportingImmunizationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.supportingPatientInformationList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'ImmunizationRecommendation.recommendation', 'supportingPatientInformation', elem.supportingPatientInformationList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseImmunizationRecommendationRecommendationDateCriterion(obj : TTurtleComplex) : TFhirImmunizationRecommendationRecommendationDateCriterion;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImmunizationRecommendationRecommendationDateCriterion.create;
  try
    ParseImmunizationRecommendationRecommendationDateCriterionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImmunizationRecommendationRecommendationDateCriterionProperties(obj : TTurtleComplex; result : TFhirImmunizationRecommendationRecommendationDateCriterion);
begin
    ParseBackboneElementProperties(obj, result);
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ImmunizationRecommendation.recommendation.dateCriterion.code'));{q3b}
    result.valueElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ImmunizationRecommendation.recommendation.dateCriterion.value'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeImmunizationRecommendationRecommendationDateCriterion(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImmunizationRecommendationRecommendationDateCriterion; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImmunizationRecommendationRecommendationDateCriterion'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'ImmunizationRecommendation.recommendation.dateCriterion', 'code', elem.codeElement, false, -1);{x.2f}
  ComposeDateTime(this, 'ImmunizationRecommendation.recommendation.dateCriterion', 'value', elem.valueElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseImmunizationRecommendation(obj : TTurtleComplex) : TFhirImmunizationRecommendation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImmunizationRecommendation.create;
  try
    ParseImmunizationRecommendationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImmunizationRecommendationProperties(obj : TTurtleComplex; result : TFhirImmunizationRecommendation);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/ImmunizationRecommendation.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.patient := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/ImmunizationRecommendation.patient'));{q3b}
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ImmunizationRecommendation.date'));{q1}
    result.authority := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/ImmunizationRecommendation.authority'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ImmunizationRecommendation.recommendation') do
      result.recommendationList.Add(parseImmunizationRecommendationRecommendation(item));
end;

procedure TFHIRTurtleComposer.ComposeImmunizationRecommendation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImmunizationRecommendation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImmunizationRecommendation'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'ImmunizationRecommendation', 'identifier', elem.identifierList[i], false, i);{x.d3}
  ComposeReference{TFhirPatient}(this, 'ImmunizationRecommendation', 'patient', elem.patientElement, false, -1);{x.2f}
  ComposeDateTime(this, 'ImmunizationRecommendation', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('authority') then
    ComposeReference{TFhirOrganization}(this, 'ImmunizationRecommendation', 'authority', elem.authorityElement, false, -1);{x.2f}
  for i := 0 to elem.recommendationList.Count - 1 do
      ComposeImmunizationRecommendationRecommendation(this, 'ImmunizationRecommendation', 'recommendation', elem.recommendationList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_IMMUNIZATIONRECOMMENDATION}
{$IFDEF FHIR_IMPLEMENTATIONGUIDE}
function TFHIRTurtleParser.ParseImplementationGuideDependsOn(obj : TTurtleComplex) : TFhirImplementationGuideDependsOn;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImplementationGuideDependsOn.create;
  try
    ParseImplementationGuideDependsOnProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImplementationGuideDependsOnProperties(obj : TTurtleComplex; result : TFhirImplementationGuideDependsOn);
begin
    ParseBackboneElementProperties(obj, result);
    result.uriElement := ParseCanonical(obj.complex('http://hl7.org/fhir/ImplementationGuide.dependsOn.uri'));{q1}
    result.packageIdElement := ParseId(obj.complex('http://hl7.org/fhir/ImplementationGuide.dependsOn.packageId'));{q1}
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/ImplementationGuide.dependsOn.version'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeImplementationGuideDependsOn(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImplementationGuideDependsOn; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImplementationGuideDependsOn'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCanonical(this, 'ImplementationGuide.dependsOn', 'uri', elem.uriElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeId(this, 'ImplementationGuide.dependsOn', 'packageId', elem.packageIdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ImplementationGuide.dependsOn', 'version', elem.versionElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseImplementationGuideGlobal(obj : TTurtleComplex) : TFhirImplementationGuideGlobal;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImplementationGuideGlobal.create;
  try
    ParseImplementationGuideGlobalProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImplementationGuideGlobalProperties(obj : TTurtleComplex; result : TFhirImplementationGuideGlobal);
begin
    ParseBackboneElementProperties(obj, result);
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/ImplementationGuide.global.type'), CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum);
    result.profileElement := ParseCanonical(obj.complex('http://hl7.org/fhir/ImplementationGuide.global.profile'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeImplementationGuideGlobal(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImplementationGuideGlobal; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImplementationGuideGlobal'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'ImplementationGuide.global', 'type', elem.Type_Element, CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, false, -1);{x.d4}
  ComposeCanonical(this, 'ImplementationGuide.global', 'profile', elem.profileElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseImplementationGuideDefinition(obj : TTurtleComplex) : TFhirImplementationGuideDefinition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImplementationGuideDefinition.create;
  try
    ParseImplementationGuideDefinitionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImplementationGuideDefinitionProperties(obj : TTurtleComplex; result : TFhirImplementationGuideDefinition);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/ImplementationGuide.definition.grouping') do
      result.groupingList.Add(parseImplementationGuideDefinitionGrouping(item));
    for item in obj.complexes('http://hl7.org/fhir/ImplementationGuide.definition.resource') do
      result.resourceList.Add(parseImplementationGuideDefinitionResource(item));
    result.page := ParseImplementationGuideDefinitionPage(obj.complex('http://hl7.org/fhir/ImplementationGuide.definition.page'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ImplementationGuide.definition.parameter') do
      result.parameterList.Add(parseImplementationGuideDefinitionParameter(item));
    for item in obj.complexes('http://hl7.org/fhir/ImplementationGuide.definition.template') do
      result.templateList.Add(parseImplementationGuideDefinitionTemplate(item));
end;

procedure TFHIRTurtleComposer.ComposeImplementationGuideDefinition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImplementationGuideDefinition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImplementationGuideDefinition'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.groupingList.Count - 1 do
      ComposeImplementationGuideDefinitionGrouping(this, 'ImplementationGuide.definition', 'grouping', elem.groupingList[i], false, i);{x.d3}
  for i := 0 to elem.resourceList.Count - 1 do
      ComposeImplementationGuideDefinitionResource(this, 'ImplementationGuide.definition', 'resource', elem.resourceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeImplementationGuideDefinitionPage(this, 'ImplementationGuide.definition', 'page', elem.pageElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.parameterList.Count - 1 do
      ComposeImplementationGuideDefinitionParameter(this, 'ImplementationGuide.definition', 'parameter', elem.parameterList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.templateList.Count - 1 do
      ComposeImplementationGuideDefinitionTemplate(this, 'ImplementationGuide.definition', 'template', elem.templateList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseImplementationGuideDefinitionGrouping(obj : TTurtleComplex) : TFhirImplementationGuideDefinitionGrouping;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImplementationGuideDefinitionGrouping.create;
  try
    ParseImplementationGuideDefinitionGroupingProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImplementationGuideDefinitionGroupingProperties(obj : TTurtleComplex; result : TFhirImplementationGuideDefinitionGrouping);
begin
    ParseBackboneElementProperties(obj, result);
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/ImplementationGuide.definition.grouping.name'));{q1}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/ImplementationGuide.definition.grouping.description'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeImplementationGuideDefinitionGrouping(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImplementationGuideDefinitionGrouping; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImplementationGuideDefinitionGrouping'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeString(this, 'ImplementationGuide.definition.grouping', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ImplementationGuide.definition.grouping', 'description', elem.descriptionElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseImplementationGuideDefinitionResource(obj : TTurtleComplex) : TFhirImplementationGuideDefinitionResource;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImplementationGuideDefinitionResource.create;
  try
    ParseImplementationGuideDefinitionResourceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImplementationGuideDefinitionResourceProperties(obj : TTurtleComplex; result : TFhirImplementationGuideDefinitionResource);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.reference := ParseReference{TFhirReference}(obj.complex('http://hl7.org/fhir/ImplementationGuide.definition.resource.reference'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ImplementationGuide.definition.resource.fhirVersion') do
      result.fhirVersionList.Add(parseEnum(item, CODES_TFhirFHIRVersionEnum, SYSTEMS_TFhirFHIRVersionEnum));
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/ImplementationGuide.definition.resource.name'));{q1}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/ImplementationGuide.definition.resource.description'));{q1}
    if obj.has('http://hl7.org/fhir/ImplementationGuide.definition.resource.exampleCanonical', item) then
      result.example := parseCanonical(item);
    if obj.has('http://hl7.org/fhir/ImplementationGuide.definition.resource.exampleBoolean', item) then
      result.example := parseBoolean(item);
    result.groupingIdElement := ParseId(obj.complex('http://hl7.org/fhir/ImplementationGuide.definition.resource.groupingId'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeImplementationGuideDefinitionResource(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImplementationGuideDefinitionResource; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImplementationGuideDefinitionResource'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeReference{TFhirReference}(this, 'ImplementationGuide.definition.resource', 'reference', elem.referenceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.fhirVersionList.Count - 1 do
      ComposeEnum(this, 'ImplementationGuide.definition.resource', 'fhirVersion', elem.fhirVersionList[i], CODES_TFhirFHIRVersionEnum, SYSTEMS_TFhirFHIRVersionEnum, false, i); {x.d1}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.fhirVersionList.Count - 1 do
      ComposeEnum(this, 'ImplementationGuide.definition.resource', 'fhirVersion', elem.fhirVersionList[i], CODES_TFhirFHIRVersionEnum, SYSTEMS_TFhirFHIRVersionEnum, false, i);{x.d2}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ImplementationGuide.definition.resource', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ImplementationGuide.definition.resource', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and (elem.example is TFhirCanonical) {6} then
    ComposeCanonical(this, 'ImplementationGuide.definition.resource', 'exampleCanonical', TFhirCanonical(elem.example), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.example is TFhirBoolean) {6} then
    ComposeBoolean(this, 'ImplementationGuide.definition.resource', 'exampleBoolean', TFhirBoolean(elem.example), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) then
    ComposeId(this, 'ImplementationGuide.definition.resource', 'groupingId', elem.groupingIdElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseImplementationGuideDefinitionPage(obj : TTurtleComplex) : TFhirImplementationGuideDefinitionPage;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImplementationGuideDefinitionPage.create;
  try
    ParseImplementationGuideDefinitionPageProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImplementationGuideDefinitionPageProperties(obj : TTurtleComplex; result : TFhirImplementationGuideDefinitionPage);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    if obj.has('http://hl7.org/fhir/ImplementationGuide.definition.page.nameUrl', item) then
      result.name := parseUrl(item);
    if obj.has('http://hl7.org/fhir/ImplementationGuide.definition.page.nameReference', item) {a3} then
      result.name := ParseReference(item);
    result.titleElement := ParseString(obj.complex('http://hl7.org/fhir/ImplementationGuide.definition.page.title'));{q1}
    result.generationElement := ParseEnum(obj.complex('http://hl7.org/fhir/ImplementationGuide.definition.page.generation'), CODES_TFhirGuidePageGenerationEnum, SYSTEMS_TFhirGuidePageGenerationEnum);
    for item in obj.complexes('http://hl7.org/fhir/ImplementationGuide.definition.page.page') do
      result.pageList.Add(parseImplementationGuideDefinitionPage(item));
end;

procedure TFHIRTurtleComposer.ComposeImplementationGuideDefinitionPage(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImplementationGuideDefinitionPage; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImplementationGuideDefinitionPage'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (elem.name is TFhirUrl) {6} then
    ComposeUrl(this, 'ImplementationGuide.definition.page', 'nameUrl', TFhirUrl(elem.name), false, -1){x.d9}
  else if (elem.name is TFhirReference) {2} then
    ComposeReference(this, 'ImplementationGuide.definition.page', 'nameReference', TFhirReference(elem.name), false,-1);{x.d8}
  ComposeString(this, 'ImplementationGuide.definition.page', 'title', elem.titleElement, false, -1);{x.2ea}
  ComposeEnum(this, 'ImplementationGuide.definition.page', 'generation', elem.GenerationElement, CODES_TFhirGuidePageGenerationEnum, SYSTEMS_TFhirGuidePageGenerationEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.pageList.Count - 1 do
      ComposeImplementationGuideDefinitionPage(this, 'ImplementationGuide.definition.page', 'page', elem.pageList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseImplementationGuideDefinitionParameter(obj : TTurtleComplex) : TFhirImplementationGuideDefinitionParameter;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImplementationGuideDefinitionParameter.create;
  try
    ParseImplementationGuideDefinitionParameterProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImplementationGuideDefinitionParameterProperties(obj : TTurtleComplex; result : TFhirImplementationGuideDefinitionParameter);
begin
    ParseBackboneElementProperties(obj, result);
    result.codeElement := ParseEnum(obj.complex('http://hl7.org/fhir/ImplementationGuide.definition.parameter.code'), CODES_TFhirGuideParameterCodeEnum, SYSTEMS_TFhirGuideParameterCodeEnum);
    result.valueElement := ParseString(obj.complex('http://hl7.org/fhir/ImplementationGuide.definition.parameter.value'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeImplementationGuideDefinitionParameter(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImplementationGuideDefinitionParameter; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImplementationGuideDefinitionParameter'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'ImplementationGuide.definition.parameter', 'code', elem.CodeElement, CODES_TFhirGuideParameterCodeEnum, SYSTEMS_TFhirGuideParameterCodeEnum, false, -1);{x.d4}
  ComposeString(this, 'ImplementationGuide.definition.parameter', 'value', elem.valueElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseImplementationGuideDefinitionTemplate(obj : TTurtleComplex) : TFhirImplementationGuideDefinitionTemplate;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImplementationGuideDefinitionTemplate.create;
  try
    ParseImplementationGuideDefinitionTemplateProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImplementationGuideDefinitionTemplateProperties(obj : TTurtleComplex; result : TFhirImplementationGuideDefinitionTemplate);
begin
    ParseBackboneElementProperties(obj, result);
    result.codeElement := ParseCode(obj.complex('http://hl7.org/fhir/ImplementationGuide.definition.template.code'));{q1}
    result.sourceElement := ParseString(obj.complex('http://hl7.org/fhir/ImplementationGuide.definition.template.source'));{q1}
    result.scopeElement := ParseString(obj.complex('http://hl7.org/fhir/ImplementationGuide.definition.template.scope'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeImplementationGuideDefinitionTemplate(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImplementationGuideDefinitionTemplate; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImplementationGuideDefinitionTemplate'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCode(this, 'ImplementationGuide.definition.template', 'code', elem.codeElement, false, -1);{x.2ea}
  ComposeString(this, 'ImplementationGuide.definition.template', 'source', elem.sourceElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ImplementationGuide.definition.template', 'scope', elem.scopeElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseImplementationGuideManifest(obj : TTurtleComplex) : TFhirImplementationGuideManifest;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImplementationGuideManifest.create;
  try
    ParseImplementationGuideManifestProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImplementationGuideManifestProperties(obj : TTurtleComplex; result : TFhirImplementationGuideManifest);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.renderingElement := ParseUrl(obj.complex('http://hl7.org/fhir/ImplementationGuide.manifest.rendering'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ImplementationGuide.manifest.resource') do
      result.resourceList.Add(parseImplementationGuideManifestResource(item));
    for item in obj.complexes('http://hl7.org/fhir/ImplementationGuide.manifest.page') do
      result.pageList.Add(parseImplementationGuideManifestPage(item));
    for item in obj.complexes('http://hl7.org/fhir/ImplementationGuide.manifest.image') do
      result.imageList.Add(parseString(item));
    for item in obj.complexes('http://hl7.org/fhir/ImplementationGuide.manifest.other') do
      result.otherList.Add(parseString(item));
end;

procedure TFHIRTurtleComposer.ComposeImplementationGuideManifest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImplementationGuideManifest; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImplementationGuideManifest'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUrl(this, 'ImplementationGuide.manifest', 'rendering', elem.renderingElement, false, -1);{x.2ea}
  for i := 0 to elem.resourceList.Count - 1 do
      ComposeImplementationGuideManifestResource(this, 'ImplementationGuide.manifest', 'resource', elem.resourceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.pageList.Count - 1 do
      ComposeImplementationGuideManifestPage(this, 'ImplementationGuide.manifest', 'page', elem.pageList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.imageList.Count - 1 do
      ComposeString(this, 'ImplementationGuide.manifest', 'image', elem.imageList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.otherList.Count - 1 do
      ComposeString(this, 'ImplementationGuide.manifest', 'other', elem.otherList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseImplementationGuideManifestResource(obj : TTurtleComplex) : TFhirImplementationGuideManifestResource;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImplementationGuideManifestResource.create;
  try
    ParseImplementationGuideManifestResourceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImplementationGuideManifestResourceProperties(obj : TTurtleComplex; result : TFhirImplementationGuideManifestResource);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.reference := ParseReference{TFhirReference}(obj.complex('http://hl7.org/fhir/ImplementationGuide.manifest.resource.reference'));{q3b}
    if obj.has('http://hl7.org/fhir/ImplementationGuide.manifest.resource.exampleCanonical', item) then
      result.example := parseCanonical(item);
    if obj.has('http://hl7.org/fhir/ImplementationGuide.manifest.resource.exampleBoolean', item) then
      result.example := parseBoolean(item);
    result.relativePathElement := ParseUrl(obj.complex('http://hl7.org/fhir/ImplementationGuide.manifest.resource.relativePath'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeImplementationGuideManifestResource(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImplementationGuideManifestResource; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImplementationGuideManifestResource'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeReference{TFhirReference}(this, 'ImplementationGuide.manifest.resource', 'reference', elem.referenceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and (elem.example is TFhirCanonical) {6} then
    ComposeCanonical(this, 'ImplementationGuide.manifest.resource', 'exampleCanonical', TFhirCanonical(elem.example), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.example is TFhirBoolean) {6} then
    ComposeBoolean(this, 'ImplementationGuide.manifest.resource', 'exampleBoolean', TFhirBoolean(elem.example), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) then
    ComposeUrl(this, 'ImplementationGuide.manifest.resource', 'relativePath', elem.relativePathElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseImplementationGuideManifestPage(obj : TTurtleComplex) : TFhirImplementationGuideManifestPage;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImplementationGuideManifestPage.create;
  try
    ParseImplementationGuideManifestPageProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImplementationGuideManifestPageProperties(obj : TTurtleComplex; result : TFhirImplementationGuideManifestPage);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/ImplementationGuide.manifest.page.name'));{q1}
    result.titleElement := ParseString(obj.complex('http://hl7.org/fhir/ImplementationGuide.manifest.page.title'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ImplementationGuide.manifest.page.anchor') do
      result.anchorList.Add(parseString(item));
end;

procedure TFHIRTurtleComposer.ComposeImplementationGuideManifestPage(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImplementationGuideManifestPage; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImplementationGuideManifestPage'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeString(this, 'ImplementationGuide.manifest.page', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ImplementationGuide.manifest.page', 'title', elem.titleElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.anchorList.Count - 1 do
      ComposeString(this, 'ImplementationGuide.manifest.page', 'anchor', elem.anchorList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseImplementationGuide(obj : TTurtleComplex) : TFhirImplementationGuide;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirImplementationGuide.create;
  try
    ParseImplementationGuideProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseImplementationGuideProperties(obj : TTurtleComplex; result : TFhirImplementationGuide);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/ImplementationGuide.url'));{q1}
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/ImplementationGuide.version'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/ImplementationGuide.name'));{q1}
    result.titleElement := ParseString(obj.complex('http://hl7.org/fhir/ImplementationGuide.title'));{q1}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/ImplementationGuide.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    result.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ImplementationGuide.experimental'));{q1}
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ImplementationGuide.date'));{q1}
    result.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/ImplementationGuide.publisher'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ImplementationGuide.contact') do
      result.contactList.Add(parseContactDetail(item));
    result.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ImplementationGuide.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ImplementationGuide.useContext') do
      result.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/ImplementationGuide.jurisdiction') do
      result.jurisdictionList.Add(parseCodeableConcept(item));
    result.copyrightElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ImplementationGuide.copyright'));{q1}
    result.packageIdElement := ParseId(obj.complex('http://hl7.org/fhir/ImplementationGuide.packageId'));{q1}
    result.licenseElement := ParseEnum(obj.complex('http://hl7.org/fhir/ImplementationGuide.license'), CODES_TFhirSpdxLicenseEnum, SYSTEMS_TFhirSpdxLicenseEnum);
    for item in obj.complexes('http://hl7.org/fhir/ImplementationGuide.fhirVersion') do
      result.fhirVersionList.Add(parseEnum(item, CODES_TFhirFHIRVersionEnum, SYSTEMS_TFhirFHIRVersionEnum));
    for item in obj.complexes('http://hl7.org/fhir/ImplementationGuide.dependsOn') do
      result.dependsOnList.Add(parseImplementationGuideDependsOn(item));
    for item in obj.complexes('http://hl7.org/fhir/ImplementationGuide.global') do
      result.globalList.Add(parseImplementationGuideGlobal(item));
    result.definition := ParseImplementationGuideDefinition(obj.complex('http://hl7.org/fhir/ImplementationGuide.definition'));{q3b}
    result.manifest := ParseImplementationGuideManifest(obj.complex('http://hl7.org/fhir/ImplementationGuide.manifest'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeImplementationGuide(parent :  TTurtleComplex; parentType, name : String; elem : TFhirImplementationGuide; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ImplementationGuide'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  ComposeUri(this, 'ImplementationGuide', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(this, 'ImplementationGuide', 'version', elem.versionElement, false, -1);{x.2ea}
  ComposeString(this, 'ImplementationGuide', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeString(this, 'ImplementationGuide', 'title', elem.titleElement, false, -1);{x.2ea}
  ComposeEnum(this, 'ImplementationGuide', 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(this, 'ImplementationGuide', 'experimental', elem.experimentalElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(this, 'ImplementationGuide', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(this, 'ImplementationGuide', 'publisher', elem.publisherElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(this, 'ImplementationGuide', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdown(this, 'ImplementationGuide', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(this, 'ImplementationGuide', 'useContext', elem.useContextList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'ImplementationGuide', 'jurisdiction', elem.jurisdictionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdown(this, 'ImplementationGuide', 'copyright', elem.copyrightElement, false, -1);{x.2ea}
  ComposeId(this, 'ImplementationGuide', 'packageId', elem.packageIdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('license') then
    ComposeEnum(this, 'ImplementationGuide', 'license', elem.LicenseElement, CODES_TFhirSpdxLicenseEnum, SYSTEMS_TFhirSpdxLicenseEnum, false, -1);{x.d4}
  for i := 0 to elem.fhirVersionList.Count - 1 do
      ComposeEnum(this, 'ImplementationGuide', 'fhirVersion', elem.fhirVersionList[i], CODES_TFhirFHIRVersionEnum, SYSTEMS_TFhirFHIRVersionEnum, false, i); {x.d1}
  for i := 0 to elem.fhirVersionList.Count - 1 do
      ComposeEnum(this, 'ImplementationGuide', 'fhirVersion', elem.fhirVersionList[i], CODES_TFhirFHIRVersionEnum, SYSTEMS_TFhirFHIRVersionEnum, false, i);{x.d2}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dependsOn') then
    for i := 0 to elem.dependsOnList.Count - 1 do
      ComposeImplementationGuideDependsOn(this, 'ImplementationGuide', 'dependsOn', elem.dependsOnList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('global') then
    for i := 0 to elem.globalList.Count - 1 do
      ComposeImplementationGuideGlobal(this, 'ImplementationGuide', 'global', elem.globalList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('definition') then
    ComposeImplementationGuideDefinition(this, 'ImplementationGuide', 'definition', elem.definitionElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('manifest') then
    ComposeImplementationGuideManifest(this, 'ImplementationGuide', 'manifest', elem.manifestElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_IMPLEMENTATIONGUIDE}
{$IFDEF FHIR_INSURANCEPLAN}
function TFHIRTurtleParser.ParseInsurancePlanContact(obj : TTurtleComplex) : TFhirInsurancePlanContact;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirInsurancePlanContact.create;
  try
    ParseInsurancePlanContactProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseInsurancePlanContactProperties(obj : TTurtleComplex; result : TFhirInsurancePlanContact);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.purpose := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/InsurancePlan.contact.purpose'));{q3b}
    result.name := ParseHumanName(obj.complex('http://hl7.org/fhir/InsurancePlan.contact.name'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/InsurancePlan.contact.telecom') do
      result.telecomList.Add(parseContactPoint(item));
    result.address := ParseAddress(obj.complex('http://hl7.org/fhir/InsurancePlan.contact.address'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeInsurancePlanContact(parent :  TTurtleComplex; parentType, name : String; elem : TFhirInsurancePlanContact; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:InsurancePlanContact'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'InsurancePlan.contact', 'purpose', elem.purposeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeHumanName(this, 'InsurancePlan.contact', 'name', elem.nameElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(this, 'InsurancePlan.contact', 'telecom', elem.telecomList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeAddress(this, 'InsurancePlan.contact', 'address', elem.addressElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseInsurancePlanCoverage(obj : TTurtleComplex) : TFhirInsurancePlanCoverage;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirInsurancePlanCoverage.create;
  try
    ParseInsurancePlanCoverageProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseInsurancePlanCoverageProperties(obj : TTurtleComplex; result : TFhirInsurancePlanCoverage);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/InsurancePlan.coverage.type'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/InsurancePlan.coverage.network') do
      result.networkList.Add(parseReference{TFhirOrganization}(item));
    for item in obj.complexes('http://hl7.org/fhir/InsurancePlan.coverage.benefit') do
      result.benefitList.Add(parseInsurancePlanCoverageBenefit(item));
end;

procedure TFHIRTurtleComposer.ComposeInsurancePlanCoverage(parent :  TTurtleComplex; parentType, name : String; elem : TFhirInsurancePlanCoverage; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:InsurancePlanCoverage'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'InsurancePlan.coverage', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.networkList.Count - 1 do
      ComposeReference{TFhirOrganization}(this, 'InsurancePlan.coverage', 'network', elem.networkList[i], false, i);{x.d3}
  for i := 0 to elem.benefitList.Count - 1 do
      ComposeInsurancePlanCoverageBenefit(this, 'InsurancePlan.coverage', 'benefit', elem.benefitList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseInsurancePlanCoverageBenefit(obj : TTurtleComplex) : TFhirInsurancePlanCoverageBenefit;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirInsurancePlanCoverageBenefit.create;
  try
    ParseInsurancePlanCoverageBenefitProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseInsurancePlanCoverageBenefitProperties(obj : TTurtleComplex; result : TFhirInsurancePlanCoverageBenefit);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/InsurancePlan.coverage.benefit.type'));{q3b}
    result.requirementElement := ParseString(obj.complex('http://hl7.org/fhir/InsurancePlan.coverage.benefit.requirement'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/InsurancePlan.coverage.benefit.limit') do
      result.limitList.Add(parseInsurancePlanCoverageBenefitLimit(item));
end;

procedure TFHIRTurtleComposer.ComposeInsurancePlanCoverageBenefit(parent :  TTurtleComplex; parentType, name : String; elem : TFhirInsurancePlanCoverageBenefit; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:InsurancePlanCoverageBenefit'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'InsurancePlan.coverage.benefit', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'InsurancePlan.coverage.benefit', 'requirement', elem.requirementElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.limitList.Count - 1 do
      ComposeInsurancePlanCoverageBenefitLimit(this, 'InsurancePlan.coverage.benefit', 'limit', elem.limitList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseInsurancePlanCoverageBenefitLimit(obj : TTurtleComplex) : TFhirInsurancePlanCoverageBenefitLimit;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirInsurancePlanCoverageBenefitLimit.create;
  try
    ParseInsurancePlanCoverageBenefitLimitProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseInsurancePlanCoverageBenefitLimitProperties(obj : TTurtleComplex; result : TFhirInsurancePlanCoverageBenefitLimit);
begin
    ParseBackboneElementProperties(obj, result);
    result.value := ParseQuantity(obj.complex('http://hl7.org/fhir/InsurancePlan.coverage.benefit.limit.value'));{q3b}
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/InsurancePlan.coverage.benefit.limit.code'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeInsurancePlanCoverageBenefitLimit(parent :  TTurtleComplex; parentType, name : String; elem : TFhirInsurancePlanCoverageBenefitLimit; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:InsurancePlanCoverageBenefitLimit'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'InsurancePlan.coverage.benefit.limit', 'value', elem.valueElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'InsurancePlan.coverage.benefit.limit', 'code', elem.codeElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseInsurancePlanPlan(obj : TTurtleComplex) : TFhirInsurancePlanPlan;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirInsurancePlanPlan.create;
  try
    ParseInsurancePlanPlanProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseInsurancePlanPlanProperties(obj : TTurtleComplex; result : TFhirInsurancePlanPlan);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/InsurancePlan.plan.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/InsurancePlan.plan.type'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/InsurancePlan.plan.coverageArea') do
      result.coverageAreaList.Add(parseReference{TFhirLocation}(item));
    for item in obj.complexes('http://hl7.org/fhir/InsurancePlan.plan.network') do
      result.networkList.Add(parseReference{TFhirOrganization}(item));
    for item in obj.complexes('http://hl7.org/fhir/InsurancePlan.plan.generalCost') do
      result.generalCostList.Add(parseInsurancePlanPlanGeneralCost(item));
    for item in obj.complexes('http://hl7.org/fhir/InsurancePlan.plan.specificCost') do
      result.specificCostList.Add(parseInsurancePlanPlanSpecificCost(item));
end;

procedure TFHIRTurtleComposer.ComposeInsurancePlanPlan(parent :  TTurtleComplex; parentType, name : String; elem : TFhirInsurancePlanPlan; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:InsurancePlanPlan'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'InsurancePlan.plan', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'InsurancePlan.plan', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.coverageAreaList.Count - 1 do
      ComposeReference{TFhirLocation}(this, 'InsurancePlan.plan', 'coverageArea', elem.coverageAreaList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.networkList.Count - 1 do
      ComposeReference{TFhirOrganization}(this, 'InsurancePlan.plan', 'network', elem.networkList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.generalCostList.Count - 1 do
      ComposeInsurancePlanPlanGeneralCost(this, 'InsurancePlan.plan', 'generalCost', elem.generalCostList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.specificCostList.Count - 1 do
      ComposeInsurancePlanPlanSpecificCost(this, 'InsurancePlan.plan', 'specificCost', elem.specificCostList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseInsurancePlanPlanGeneralCost(obj : TTurtleComplex) : TFhirInsurancePlanPlanGeneralCost;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirInsurancePlanPlanGeneralCost.create;
  try
    ParseInsurancePlanPlanGeneralCostProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseInsurancePlanPlanGeneralCostProperties(obj : TTurtleComplex; result : TFhirInsurancePlanPlanGeneralCost);
begin
    ParseBackboneElementProperties(obj, result);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/InsurancePlan.plan.generalCost.type'));{q3b}
    result.groupSizeElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/InsurancePlan.plan.generalCost.groupSize'));{q1}
    result.cost := ParseMoney(obj.complex('http://hl7.org/fhir/InsurancePlan.plan.generalCost.cost'));{q3b}
    result.commentElement := ParseString(obj.complex('http://hl7.org/fhir/InsurancePlan.plan.generalCost.comment'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeInsurancePlanPlanGeneralCost(parent :  TTurtleComplex; parentType, name : String; elem : TFhirInsurancePlanPlanGeneralCost; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:InsurancePlanPlanGeneralCost'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'InsurancePlan.plan.generalCost', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(this, 'InsurancePlan.plan.generalCost', 'groupSize', elem.groupSizeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'InsurancePlan.plan.generalCost', 'cost', elem.costElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'InsurancePlan.plan.generalCost', 'comment', elem.commentElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseInsurancePlanPlanSpecificCost(obj : TTurtleComplex) : TFhirInsurancePlanPlanSpecificCost;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirInsurancePlanPlanSpecificCost.create;
  try
    ParseInsurancePlanPlanSpecificCostProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseInsurancePlanPlanSpecificCostProperties(obj : TTurtleComplex; result : TFhirInsurancePlanPlanSpecificCost);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/InsurancePlan.plan.specificCost.category'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/InsurancePlan.plan.specificCost.benefit') do
      result.benefitList.Add(parseInsurancePlanPlanSpecificCostBenefit(item));
end;

procedure TFHIRTurtleComposer.ComposeInsurancePlanPlanSpecificCost(parent :  TTurtleComplex; parentType, name : String; elem : TFhirInsurancePlanPlanSpecificCost; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:InsurancePlanPlanSpecificCost'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'InsurancePlan.plan.specificCost', 'category', elem.categoryElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.benefitList.Count - 1 do
      ComposeInsurancePlanPlanSpecificCostBenefit(this, 'InsurancePlan.plan.specificCost', 'benefit', elem.benefitList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseInsurancePlanPlanSpecificCostBenefit(obj : TTurtleComplex) : TFhirInsurancePlanPlanSpecificCostBenefit;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirInsurancePlanPlanSpecificCostBenefit.create;
  try
    ParseInsurancePlanPlanSpecificCostBenefitProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseInsurancePlanPlanSpecificCostBenefitProperties(obj : TTurtleComplex; result : TFhirInsurancePlanPlanSpecificCostBenefit);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/InsurancePlan.plan.specificCost.benefit.type'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/InsurancePlan.plan.specificCost.benefit.cost') do
      result.costList.Add(parseInsurancePlanPlanSpecificCostBenefitCost(item));
end;

procedure TFHIRTurtleComposer.ComposeInsurancePlanPlanSpecificCostBenefit(parent :  TTurtleComplex; parentType, name : String; elem : TFhirInsurancePlanPlanSpecificCostBenefit; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:InsurancePlanPlanSpecificCostBenefit'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'InsurancePlan.plan.specificCost.benefit', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.costList.Count - 1 do
      ComposeInsurancePlanPlanSpecificCostBenefitCost(this, 'InsurancePlan.plan.specificCost.benefit', 'cost', elem.costList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseInsurancePlanPlanSpecificCostBenefitCost(obj : TTurtleComplex) : TFhirInsurancePlanPlanSpecificCostBenefitCost;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirInsurancePlanPlanSpecificCostBenefitCost.create;
  try
    ParseInsurancePlanPlanSpecificCostBenefitCostProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseInsurancePlanPlanSpecificCostBenefitCostProperties(obj : TTurtleComplex; result : TFhirInsurancePlanPlanSpecificCostBenefitCost);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/InsurancePlan.plan.specificCost.benefit.cost.type'));{q3b}
    result.applicability := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/InsurancePlan.plan.specificCost.benefit.cost.applicability'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/InsurancePlan.plan.specificCost.benefit.cost.qualifiers') do
      result.qualifiersList.Add(parseCodeableConcept(item));
    result.value := ParseQuantity(obj.complex('http://hl7.org/fhir/InsurancePlan.plan.specificCost.benefit.cost.value'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeInsurancePlanPlanSpecificCostBenefitCost(parent :  TTurtleComplex; parentType, name : String; elem : TFhirInsurancePlanPlanSpecificCostBenefitCost; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:InsurancePlanPlanSpecificCostBenefitCost'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'InsurancePlan.plan.specificCost.benefit.cost', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'InsurancePlan.plan.specificCost.benefit.cost', 'applicability', elem.applicabilityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.qualifiersList.Count - 1 do
      ComposeCodeableConcept(this, 'InsurancePlan.plan.specificCost.benefit.cost', 'qualifiers', elem.qualifiersList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'InsurancePlan.plan.specificCost.benefit.cost', 'value', elem.valueElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseInsurancePlan(obj : TTurtleComplex) : TFhirInsurancePlan;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirInsurancePlan.create;
  try
    ParseInsurancePlanProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseInsurancePlanProperties(obj : TTurtleComplex; result : TFhirInsurancePlan);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/InsurancePlan.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/InsurancePlan.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    for item in obj.complexes('http://hl7.org/fhir/InsurancePlan.type') do
      result.type_List.Add(parseCodeableConcept(item));
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/InsurancePlan.name'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/InsurancePlan.alias') do
      result.aliasList.Add(parseString(item));
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/InsurancePlan.period'));{q3b}
    result.ownedBy := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/InsurancePlan.ownedBy'));{q3b}
    result.administeredBy := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/InsurancePlan.administeredBy'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/InsurancePlan.coverageArea') do
      result.coverageAreaList.Add(parseReference{TFhirLocation}(item));
    for item in obj.complexes('http://hl7.org/fhir/InsurancePlan.contact') do
      result.contactList.Add(parseInsurancePlanContact(item));
    for item in obj.complexes('http://hl7.org/fhir/InsurancePlan.endpoint') do
      result.endpointList.Add(parseReference{TFhirEndpoint}(item));
    for item in obj.complexes('http://hl7.org/fhir/InsurancePlan.network') do
      result.networkList.Add(parseReference{TFhirOrganization}(item));
    for item in obj.complexes('http://hl7.org/fhir/InsurancePlan.coverage') do
      result.coverageList.Add(parseInsurancePlanCoverage(item));
    for item in obj.complexes('http://hl7.org/fhir/InsurancePlan.plan') do
      result.planList.Add(parseInsurancePlanPlan(item));
end;

procedure TFHIRTurtleComposer.ComposeInsurancePlan(parent :  TTurtleComplex; parentType, name : String; elem : TFhirInsurancePlan; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:InsurancePlan'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'InsurancePlan', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(this, 'InsurancePlan', 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(this, 'InsurancePlan', 'type', elem.type_List[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(this, 'InsurancePlan', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('alias') then
    for i := 0 to elem.aliasList.Count - 1 do
      ComposeString(this, 'InsurancePlan', 'alias', elem.aliasList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('period') then
    ComposePeriod(this, 'InsurancePlan', 'period', elem.periodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('ownedBy') then
    ComposeReference{TFhirOrganization}(this, 'InsurancePlan', 'ownedBy', elem.ownedByElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('administeredBy') then
    ComposeReference{TFhirOrganization}(this, 'InsurancePlan', 'administeredBy', elem.administeredByElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('coverageArea') then
    for i := 0 to elem.coverageAreaList.Count - 1 do
      ComposeReference{TFhirLocation}(this, 'InsurancePlan', 'coverageArea', elem.coverageAreaList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeInsurancePlanContact(this, 'InsurancePlan', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('endpoint') then
    for i := 0 to elem.endpointList.Count - 1 do
      ComposeReference{TFhirEndpoint}(this, 'InsurancePlan', 'endpoint', elem.endpointList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('network') then
    for i := 0 to elem.networkList.Count - 1 do
      ComposeReference{TFhirOrganization}(this, 'InsurancePlan', 'network', elem.networkList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('coverage') then
    for i := 0 to elem.coverageList.Count - 1 do
      ComposeInsurancePlanCoverage(this, 'InsurancePlan', 'coverage', elem.coverageList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('plan') then
    for i := 0 to elem.planList.Count - 1 do
      ComposeInsurancePlanPlan(this, 'InsurancePlan', 'plan', elem.planList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_INSURANCEPLAN}
{$IFDEF FHIR_INVOICE}
function TFHIRTurtleParser.ParseInvoiceParticipant(obj : TTurtleComplex) : TFhirInvoiceParticipant;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirInvoiceParticipant.create;
  try
    ParseInvoiceParticipantProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseInvoiceParticipantProperties(obj : TTurtleComplex; result : TFhirInvoiceParticipant);
begin
    ParseBackboneElementProperties(obj, result);
    result.role := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Invoice.participant.role'));{q3b}
    result.actor := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/Invoice.participant.actor'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeInvoiceParticipant(parent :  TTurtleComplex; parentType, name : String; elem : TFhirInvoiceParticipant; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:InvoiceParticipant'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Invoice.participant', 'role', elem.roleElement, false, -1);{x.2f}
  ComposeReference{TFhirPractitioner}(this, 'Invoice.participant', 'actor', elem.actorElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseInvoiceLineItem(obj : TTurtleComplex) : TFhirInvoiceLineItem;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirInvoiceLineItem.create;
  try
    ParseInvoiceLineItemProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseInvoiceLineItemProperties(obj : TTurtleComplex; result : TFhirInvoiceLineItem);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.sequenceElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Invoice.lineItem.sequence'));{q1}
    if obj.has('http://hl7.org/fhir/Invoice.lineItem.chargeItemReference', item) {a3} then
      result.chargeItem := ParseReference(item);
    if obj.has('http://hl7.org/fhir/Invoice.lineItem.chargeItemCodeableConcept', item) then
      result.chargeItem := parseCodeableConcept(item);
    for item in obj.complexes('http://hl7.org/fhir/Invoice.lineItem.priceComponent') do
      result.priceComponentList.Add(parseInvoiceLineItemPriceComponent(item));
end;

procedure TFHIRTurtleComposer.ComposeInvoiceLineItem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirInvoiceLineItem; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:InvoiceLineItem'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(this, 'Invoice.lineItem', 'sequence', elem.sequenceElement, false, -1);{x.2ea}
  if (elem.chargeItem is TFhirReference) {2} then
    ComposeReference(this, 'Invoice.lineItem', 'chargeItemReference', TFhirReference(elem.chargeItem), false,-1){x.d8}
  else if (elem.chargeItem is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Invoice.lineItem', 'chargeItemCodeableConcept', TFhirCodeableConcept(elem.chargeItem), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.priceComponentList.Count - 1 do
      ComposeInvoiceLineItemPriceComponent(this, 'Invoice.lineItem', 'priceComponent', elem.priceComponentList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseInvoiceLineItemPriceComponent(obj : TTurtleComplex) : TFhirInvoiceLineItemPriceComponent;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirInvoiceLineItemPriceComponent.create;
  try
    ParseInvoiceLineItemPriceComponentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseInvoiceLineItemPriceComponentProperties(obj : TTurtleComplex; result : TFhirInvoiceLineItemPriceComponent);
begin
    ParseBackboneElementProperties(obj, result);
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/Invoice.lineItem.priceComponent.type'), CODES_TFhirInvoicePriceComponentTypeEnum, SYSTEMS_TFhirInvoicePriceComponentTypeEnum);
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Invoice.lineItem.priceComponent.code'));{q3b}
    result.factorElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Invoice.lineItem.priceComponent.factor'));{q1}
    result.amount := ParseMoney(obj.complex('http://hl7.org/fhir/Invoice.lineItem.priceComponent.amount'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeInvoiceLineItemPriceComponent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirInvoiceLineItemPriceComponent; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:InvoiceLineItemPriceComponent'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'Invoice.lineItem.priceComponent', 'type', elem.Type_Element, CODES_TFhirInvoicePriceComponentTypeEnum, SYSTEMS_TFhirInvoicePriceComponentTypeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Invoice.lineItem.priceComponent', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'Invoice.lineItem.priceComponent', 'factor', elem.factorElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'Invoice.lineItem.priceComponent', 'amount', elem.amountElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseInvoice(obj : TTurtleComplex) : TFhirInvoice;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirInvoice.create;
  try
    ParseInvoiceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseInvoiceProperties(obj : TTurtleComplex; result : TFhirInvoice);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Invoice.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Invoice.status'), CODES_TFhirInvoiceStatusEnum, SYSTEMS_TFhirInvoiceStatusEnum);
    result.cancelledReasonElement := ParseString(obj.complex('http://hl7.org/fhir/Invoice.cancelledReason'));{q1}
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Invoice.type'));{q3b}
    result.subject := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/Invoice.subject'));{q3b}
    result.recipient := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/Invoice.recipient'));{q3b}
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Invoice.date'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Invoice.participant') do
      result.participantList.Add(parseInvoiceParticipant(item));
    result.issuer := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/Invoice.issuer'));{q3b}
    result.account := ParseReference{TFhirAccount}(obj.complex('http://hl7.org/fhir/Invoice.account'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Invoice.lineItem') do
      result.lineItemList.Add(parseInvoiceLineItem(item));
    for item in obj.complexes('http://hl7.org/fhir/Invoice.totalPriceComponent') do
      result.totalPriceComponentList.Add(parseInvoiceLineItemPriceComponent(item));
    result.totalNet := ParseMoney(obj.complex('http://hl7.org/fhir/Invoice.totalNet'));{q3b}
    result.totalGross := ParseMoney(obj.complex('http://hl7.org/fhir/Invoice.totalGross'));{q3b}
    result.paymentTermsElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/Invoice.paymentTerms'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Invoice.note') do
      result.noteList.Add(parseAnnotation(item));
end;

procedure TFHIRTurtleComposer.ComposeInvoice(parent :  TTurtleComplex; parentType, name : String; elem : TFhirInvoice; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Invoice'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Invoice', 'identifier', elem.identifierList[i], false, i);{x.d3}
  ComposeEnum(this, 'Invoice', 'status', elem.StatusElement, CODES_TFhirInvoiceStatusEnum, SYSTEMS_TFhirInvoiceStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('cancelledReason') then
    ComposeString(this, 'Invoice', 'cancelledReason', elem.cancelledReasonElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCodeableConcept(this, 'Invoice', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{TFhirPatient}(this, 'Invoice', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('recipient') then
    ComposeReference{TFhirOrganization}(this, 'Invoice', 'recipient', elem.recipientElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(this, 'Invoice', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('participant') then
    for i := 0 to elem.participantList.Count - 1 do
      ComposeInvoiceParticipant(this, 'Invoice', 'participant', elem.participantList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('issuer') then
    ComposeReference{TFhirOrganization}(this, 'Invoice', 'issuer', elem.issuerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('account') then
    ComposeReference{TFhirAccount}(this, 'Invoice', 'account', elem.accountElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('lineItem') then
    for i := 0 to elem.lineItemList.Count - 1 do
      ComposeInvoiceLineItem(this, 'Invoice', 'lineItem', elem.lineItemList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('totalPriceComponent') then
    for i := 0 to elem.totalPriceComponentList.Count - 1 do
      ComposeInvoiceLineItemPriceComponent(this, 'Invoice', 'totalPriceComponent', elem.totalPriceComponentList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('totalNet') then
    ComposeMoney(this, 'Invoice', 'totalNet', elem.totalNetElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('totalGross') then
    ComposeMoney(this, 'Invoice', 'totalGross', elem.totalGrossElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('paymentTerms') then
    ComposeMarkdown(this, 'Invoice', 'paymentTerms', elem.paymentTermsElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'Invoice', 'note', elem.noteList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_INVOICE}
{$IFDEF FHIR_LIBRARY}
function TFHIRTurtleParser.ParseLibrary(obj : TTurtleComplex) : TFhirLibrary;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirLibrary.create;
  try
    ParseLibraryProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseLibraryProperties(obj : TTurtleComplex; result : TFhirLibrary);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/Library.url'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Library.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/Library.version'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/Library.name'));{q1}
    result.titleElement := ParseString(obj.complex('http://hl7.org/fhir/Library.title'));{q1}
    result.subtitleElement := ParseString(obj.complex('http://hl7.org/fhir/Library.subtitle'));{q1}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Library.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    result.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Library.experimental'));{q1}
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Library.type'));{q3b}
    if obj.has('http://hl7.org/fhir/Library.subjectCodeableConcept', item) then
      result.subject := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/Library.subjectReference', item) {a3} then
      result.subject := ParseReference(item);
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Library.date'));{q1}
    result.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/Library.publisher'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Library.contact') do
      result.contactList.Add(parseContactDetail(item));
    result.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/Library.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Library.useContext') do
      result.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/Library.jurisdiction') do
      result.jurisdictionList.Add(parseCodeableConcept(item));
    result.purposeElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/Library.purpose'));{q1}
    result.usageElement := ParseString(obj.complex('http://hl7.org/fhir/Library.usage'));{q1}
    result.copyrightElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/Library.copyright'));{q1}
    result.approvalDateElement := ParseDate(obj.complex('http://hl7.org/fhir/Library.approvalDate'));{q1}
    result.lastReviewDateElement := ParseDate(obj.complex('http://hl7.org/fhir/Library.lastReviewDate'));{q1}
    result.effectivePeriod := ParsePeriod(obj.complex('http://hl7.org/fhir/Library.effectivePeriod'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Library.topic') do
      result.topicList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Library.author') do
      result.authorList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/Library.editor') do
      result.editorList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/Library.reviewer') do
      result.reviewerList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/Library.endorser') do
      result.endorserList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/Library.relatedArtifact') do
      result.relatedArtifactList.Add(parseRelatedArtifact(item));
    for item in obj.complexes('http://hl7.org/fhir/Library.parameter') do
      result.parameterList.Add(parseParameterDefinition(item));
    for item in obj.complexes('http://hl7.org/fhir/Library.dataRequirement') do
      result.dataRequirementList.Add(parseDataRequirement(item));
    for item in obj.complexes('http://hl7.org/fhir/Library.content') do
      result.contentList.Add(parseAttachment(item));
end;

procedure TFHIRTurtleComposer.ComposeLibrary(parent :  TTurtleComplex; parentType, name : String; elem : TFhirLibrary; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Library'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUri(this, 'Library', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Library', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(this, 'Library', 'version', elem.versionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(this, 'Library', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeString(this, 'Library', 'title', elem.titleElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('subtitle') then
    ComposeString(this, 'Library', 'subtitle', elem.subtitleElement, false, -1);{x.2ea}
  ComposeEnum(this, 'Library', 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(this, 'Library', 'experimental', elem.experimentalElement, false, -1);{x.2ea}
  ComposeCodeableConcept(this, 'Library', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and (elem.subject is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Library', 'subjectCodeableConcept', TFhirCodeableConcept(elem.subject), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.subject is TFhirReference) {2} then
    ComposeReference(this, 'Library', 'subjectReference', TFhirReference(elem.subject), false,-1);{x.d8}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(this, 'Library', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(this, 'Library', 'publisher', elem.publisherElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(this, 'Library', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeMarkdown(this, 'Library', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(this, 'Library', 'useContext', elem.useContextList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'Library', 'jurisdiction', elem.jurisdictionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdown(this, 'Library', 'purpose', elem.purposeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('usage') then
    ComposeString(this, 'Library', 'usage', elem.usageElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdown(this, 'Library', 'copyright', elem.copyrightElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('approvalDate') then
    ComposeDate(this, 'Library', 'approvalDate', elem.approvalDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('lastReviewDate') then
    ComposeDate(this, 'Library', 'lastReviewDate', elem.lastReviewDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('effectivePeriod') then
    ComposePeriod(this, 'Library', 'effectivePeriod', elem.effectivePeriodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('topic') then
    for i := 0 to elem.topicList.Count - 1 do
      ComposeCodeableConcept(this, 'Library', 'topic', elem.topicList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('author') then
    for i := 0 to elem.authorList.Count - 1 do
      ComposeContactDetail(this, 'Library', 'author', elem.authorList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('editor') then
    for i := 0 to elem.editorList.Count - 1 do
      ComposeContactDetail(this, 'Library', 'editor', elem.editorList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('reviewer') then
    for i := 0 to elem.reviewerList.Count - 1 do
      ComposeContactDetail(this, 'Library', 'reviewer', elem.reviewerList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('endorser') then
    for i := 0 to elem.endorserList.Count - 1 do
      ComposeContactDetail(this, 'Library', 'endorser', elem.endorserList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('relatedArtifact') then
    for i := 0 to elem.relatedArtifactList.Count - 1 do
      ComposeRelatedArtifact(this, 'Library', 'relatedArtifact', elem.relatedArtifactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('parameter') then
    for i := 0 to elem.parameterList.Count - 1 do
      ComposeParameterDefinition(this, 'Library', 'parameter', elem.parameterList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('dataRequirement') then
    for i := 0 to elem.dataRequirementList.Count - 1 do
      ComposeDataRequirement(this, 'Library', 'dataRequirement', elem.dataRequirementList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('content') then
    for i := 0 to elem.contentList.Count - 1 do
      ComposeAttachment(this, 'Library', 'content', elem.contentList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_LIBRARY}
{$IFDEF FHIR_LINKAGE}
function TFHIRTurtleParser.ParseLinkageItem(obj : TTurtleComplex) : TFhirLinkageItem;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirLinkageItem.create;
  try
    ParseLinkageItemProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseLinkageItemProperties(obj : TTurtleComplex; result : TFhirLinkageItem);
begin
    ParseBackboneElementProperties(obj, result);
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/Linkage.item.type'), CODES_TFhirLinkageTypeEnum, SYSTEMS_TFhirLinkageTypeEnum);
    result.resource := ParseReference{TFhirReference}(obj.complex('http://hl7.org/fhir/Linkage.item.resource'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeLinkageItem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirLinkageItem; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:LinkageItem'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'Linkage.item', 'type', elem.Type_Element, CODES_TFhirLinkageTypeEnum, SYSTEMS_TFhirLinkageTypeEnum, false, -1);{x.d4}
  ComposeReference{TFhirReference}(this, 'Linkage.item', 'resource', elem.resourceElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseLinkage(obj : TTurtleComplex) : TFhirLinkage;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirLinkage.create;
  try
    ParseLinkageProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseLinkageProperties(obj : TTurtleComplex; result : TFhirLinkage);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.activeElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Linkage.active'));{q1}
    result.author := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/Linkage.author'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Linkage.item') do
      result.itemList.Add(parseLinkageItem(item));
end;

procedure TFHIRTurtleComposer.ComposeLinkage(parent :  TTurtleComplex; parentType, name : String; elem : TFhirLinkage; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Linkage'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('active') then
    ComposeBoolean(this, 'Linkage', 'active', elem.activeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('author') then
    ComposeReference{TFhirPractitioner}(this, 'Linkage', 'author', elem.authorElement, false, -1);{x.2f}
  for i := 0 to elem.itemList.Count - 1 do
      ComposeLinkageItem(this, 'Linkage', 'item', elem.itemList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_LINKAGE}
{$IFDEF FHIR_LIST}
function TFHIRTurtleParser.ParseListEntry(obj : TTurtleComplex) : TFhirListEntry;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirListEntry.create;
  try
    ParseListEntryProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseListEntryProperties(obj : TTurtleComplex; result : TFhirListEntry);
begin
    ParseBackboneElementProperties(obj, result);
    result.flag := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/List.entry.flag'));{q3b}
    result.deletedElement := ParseBoolean(obj.complex('http://hl7.org/fhir/List.entry.deleted'));{q1}
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/List.entry.date'));{q1}
    result.item := ParseReference{TFhirReference}(obj.complex('http://hl7.org/fhir/List.entry.item'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeListEntry(parent :  TTurtleComplex; parentType, name : String; elem : TFhirListEntry; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ListEntry'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'List.entry', 'flag', elem.flagElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'List.entry', 'deleted', elem.deletedElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'List.entry', 'date', elem.dateElement, false, -1);{x.2ea}
  ComposeReference{TFhirReference}(this, 'List.entry', 'item', elem.itemElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseList(obj : TTurtleComplex) : TFhirList;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirList.create;
  try
    ParseListProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseListProperties(obj : TTurtleComplex; result : TFhirList);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/List.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/List.status'), CODES_TFhirListStatusEnum, SYSTEMS_TFhirListStatusEnum);
    result.modeElement := ParseEnum(obj.complex('http://hl7.org/fhir/List.mode'), CODES_TFhirListModeEnum, SYSTEMS_TFhirListModeEnum);
    result.titleElement := ParseString(obj.complex('http://hl7.org/fhir/List.title'));{q1}
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/List.code'));{q3b}
    result.subject := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/List.subject'));{q3b}
    result.encounter := ParseReference{TFhirEncounter}(obj.complex('http://hl7.org/fhir/List.encounter'));{q3b}
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/List.date'));{q1}
    result.source := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/List.source'));{q3b}
    result.orderedBy := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/List.orderedBy'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/List.note') do
      result.noteList.Add(parseAnnotation(item));
    for item in obj.complexes('http://hl7.org/fhir/List.entry') do
      result.entryList.Add(parseListEntry(item));
    result.emptyReason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/List.emptyReason'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeList(parent :  TTurtleComplex; parentType, name : String; elem : TFhirList; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:List'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'List', 'identifier', elem.identifierList[i], false, i);{x.d3}
  ComposeEnum(this, 'List', 'status', elem.StatusElement, CODES_TFhirListStatusEnum, SYSTEMS_TFhirListStatusEnum, false, -1);{x.d4}
  ComposeEnum(this, 'List', 'mode', elem.ModeElement, CODES_TFhirListModeEnum, SYSTEMS_TFhirListModeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeString(this, 'List', 'title', elem.titleElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') then
    ComposeCodeableConcept(this, 'List', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{TFhirPatient}(this, 'List', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(this, 'List', 'encounter', elem.encounterElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(this, 'List', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('source') then
    ComposeReference{TFhirPractitioner}(this, 'List', 'source', elem.sourceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('orderedBy') then
    ComposeCodeableConcept(this, 'List', 'orderedBy', elem.orderedByElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'List', 'note', elem.noteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('entry') then
    for i := 0 to elem.entryList.Count - 1 do
      ComposeListEntry(this, 'List', 'entry', elem.entryList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('emptyReason') then
    ComposeCodeableConcept(this, 'List', 'emptyReason', elem.emptyReasonElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_LIST}
{$IFDEF FHIR_LOCATION}
function TFHIRTurtleParser.ParseLocationPosition(obj : TTurtleComplex) : TFhirLocationPosition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirLocationPosition.create;
  try
    ParseLocationPositionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseLocationPositionProperties(obj : TTurtleComplex; result : TFhirLocationPosition);
begin
    ParseBackboneElementProperties(obj, result);
    result.longitudeElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Location.position.longitude'));{q1}
    result.latitudeElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Location.position.latitude'));{q1}
    result.altitudeElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Location.position.altitude'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeLocationPosition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirLocationPosition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:LocationPosition'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeDecimal(this, 'Location.position', 'longitude', elem.longitudeElement, false, -1);{x.2ea}
  ComposeDecimal(this, 'Location.position', 'latitude', elem.latitudeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'Location.position', 'altitude', elem.altitudeElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseLocationHoursOfOperation(obj : TTurtleComplex) : TFhirLocationHoursOfOperation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirLocationHoursOfOperation.create;
  try
    ParseLocationHoursOfOperationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseLocationHoursOfOperationProperties(obj : TTurtleComplex; result : TFhirLocationHoursOfOperation);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Location.hoursOfOperation.daysOfWeek') do
      result.daysOfWeekList.Add(parseEnum(item, CODES_TFhirDaysOfWeekEnum, SYSTEMS_TFhirDaysOfWeekEnum));
    result.allDayElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Location.hoursOfOperation.allDay'));{q1}
    result.openingTimeElement := ParseTime(obj.complex('http://hl7.org/fhir/Location.hoursOfOperation.openingTime'));{q1}
    result.closingTimeElement := ParseTime(obj.complex('http://hl7.org/fhir/Location.hoursOfOperation.closingTime'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeLocationHoursOfOperation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirLocationHoursOfOperation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:LocationHoursOfOperation'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.daysOfWeekList.Count - 1 do
      ComposeEnum(this, 'Location.hoursOfOperation', 'daysOfWeek', elem.daysOfWeekList[i], CODES_TFhirDaysOfWeekEnum, SYSTEMS_TFhirDaysOfWeekEnum, false, i); {x.d1}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.daysOfWeekList.Count - 1 do
      ComposeEnum(this, 'Location.hoursOfOperation', 'daysOfWeek', elem.daysOfWeekList[i], CODES_TFhirDaysOfWeekEnum, SYSTEMS_TFhirDaysOfWeekEnum, false, i);{x.d2}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'Location.hoursOfOperation', 'allDay', elem.allDayElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeTime(this, 'Location.hoursOfOperation', 'openingTime', elem.openingTimeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeTime(this, 'Location.hoursOfOperation', 'closingTime', elem.closingTimeElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseLocation(obj : TTurtleComplex) : TFhirLocation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirLocation.create;
  try
    ParseLocationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseLocationProperties(obj : TTurtleComplex; result : TFhirLocation);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Location.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Location.status'), CODES_TFhirLocationStatusEnum, SYSTEMS_TFhirLocationStatusEnum);
    result.operationalStatus := ParseCoding(obj.complex('http://hl7.org/fhir/Location.operationalStatus'));{q3b}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/Location.name'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Location.alias') do
      result.aliasList.Add(parseString(item));
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/Location.description'));{q1}
    result.modeElement := ParseEnum(obj.complex('http://hl7.org/fhir/Location.mode'), CODES_TFhirLocationModeEnum, SYSTEMS_TFhirLocationModeEnum);
    for item in obj.complexes('http://hl7.org/fhir/Location.type') do
      result.type_List.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Location.telecom') do
      result.telecomList.Add(parseContactPoint(item));
    result.address := ParseAddress(obj.complex('http://hl7.org/fhir/Location.address'));{q3b}
    result.physicalType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Location.physicalType'));{q3b}
    result.position := ParseLocationPosition(obj.complex('http://hl7.org/fhir/Location.position'));{q3b}
    result.managingOrganization := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/Location.managingOrganization'));{q3b}
    result.partOf := ParseReference{TFhirLocation}(obj.complex('http://hl7.org/fhir/Location.partOf'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Location.hoursOfOperation') do
      result.hoursOfOperationList.Add(parseLocationHoursOfOperation(item));
    result.availabilityExceptionsElement := ParseString(obj.complex('http://hl7.org/fhir/Location.availabilityExceptions'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Location.endpoint') do
      result.endpointList.Add(parseReference{TFhirEndpoint}(item));
end;

procedure TFHIRTurtleComposer.ComposeLocation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirLocation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Location'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Location', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(this, 'Location', 'status', elem.StatusElement, CODES_TFhirLocationStatusEnum, SYSTEMS_TFhirLocationStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('operationalStatus') then
    ComposeCoding(this, 'Location', 'operationalStatus', elem.operationalStatusElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(this, 'Location', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('alias') then
    for i := 0 to elem.aliasList.Count - 1 do
      ComposeString(this, 'Location', 'alias', elem.aliasList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeString(this, 'Location', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('mode') then
    ComposeEnum(this, 'Location', 'mode', elem.ModeElement, CODES_TFhirLocationModeEnum, SYSTEMS_TFhirLocationModeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(this, 'Location', 'type', elem.type_List[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('telecom') then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(this, 'Location', 'telecom', elem.telecomList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('address') then
    ComposeAddress(this, 'Location', 'address', elem.addressElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('physicalType') then
    ComposeCodeableConcept(this, 'Location', 'physicalType', elem.physicalTypeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('position') then
    ComposeLocationPosition(this, 'Location', 'position', elem.positionElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('managingOrganization') then
    ComposeReference{TFhirOrganization}(this, 'Location', 'managingOrganization', elem.managingOrganizationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('partOf') then
    ComposeReference{TFhirLocation}(this, 'Location', 'partOf', elem.partOfElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('hoursOfOperation') then
    for i := 0 to elem.hoursOfOperationList.Count - 1 do
      ComposeLocationHoursOfOperation(this, 'Location', 'hoursOfOperation', elem.hoursOfOperationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('availabilityExceptions') then
    ComposeString(this, 'Location', 'availabilityExceptions', elem.availabilityExceptionsElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('endpoint') then
    for i := 0 to elem.endpointList.Count - 1 do
      ComposeReference{TFhirEndpoint}(this, 'Location', 'endpoint', elem.endpointList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_LOCATION}
{$IFDEF FHIR_MEASURE}
function TFHIRTurtleParser.ParseMeasureGroup(obj : TTurtleComplex) : TFhirMeasureGroup;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMeasureGroup.create;
  try
    ParseMeasureGroupProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMeasureGroupProperties(obj : TTurtleComplex; result : TFhirMeasureGroup);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Measure.group.code'));{q3b}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/Measure.group.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Measure.group.population') do
      result.populationList.Add(parseMeasureGroupPopulation(item));
    for item in obj.complexes('http://hl7.org/fhir/Measure.group.stratifier') do
      result.stratifierList.Add(parseMeasureGroupStratifier(item));
end;

procedure TFHIRTurtleComposer.ComposeMeasureGroup(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMeasureGroup; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MeasureGroup'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Measure.group', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Measure.group', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.populationList.Count - 1 do
      ComposeMeasureGroupPopulation(this, 'Measure.group', 'population', elem.populationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.stratifierList.Count - 1 do
      ComposeMeasureGroupStratifier(this, 'Measure.group', 'stratifier', elem.stratifierList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseMeasureGroupPopulation(obj : TTurtleComplex) : TFhirMeasureGroupPopulation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMeasureGroupPopulation.create;
  try
    ParseMeasureGroupPopulationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMeasureGroupPopulationProperties(obj : TTurtleComplex; result : TFhirMeasureGroupPopulation);
begin
    ParseBackboneElementProperties(obj, result);
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Measure.group.population.code'));{q3b}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/Measure.group.population.description'));{q1}
    result.criteria := ParseExpression(obj.complex('http://hl7.org/fhir/Measure.group.population.criteria'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeMeasureGroupPopulation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMeasureGroupPopulation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MeasureGroupPopulation'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Measure.group.population', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Measure.group.population', 'description', elem.descriptionElement, false, -1);{x.2ea}
  ComposeExpression(this, 'Measure.group.population', 'criteria', elem.criteriaElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseMeasureGroupStratifier(obj : TTurtleComplex) : TFhirMeasureGroupStratifier;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMeasureGroupStratifier.create;
  try
    ParseMeasureGroupStratifierProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMeasureGroupStratifierProperties(obj : TTurtleComplex; result : TFhirMeasureGroupStratifier);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Measure.group.stratifier.code'));{q3b}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/Measure.group.stratifier.description'));{q1}
    result.criteria := ParseExpression(obj.complex('http://hl7.org/fhir/Measure.group.stratifier.criteria'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Measure.group.stratifier.component') do
      result.componentList.Add(parseMeasureGroupStratifierComponent(item));
end;

procedure TFHIRTurtleComposer.ComposeMeasureGroupStratifier(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMeasureGroupStratifier; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MeasureGroupStratifier'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Measure.group.stratifier', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Measure.group.stratifier', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeExpression(this, 'Measure.group.stratifier', 'criteria', elem.criteriaElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.componentList.Count - 1 do
      ComposeMeasureGroupStratifierComponent(this, 'Measure.group.stratifier', 'component', elem.componentList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseMeasureGroupStratifierComponent(obj : TTurtleComplex) : TFhirMeasureGroupStratifierComponent;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMeasureGroupStratifierComponent.create;
  try
    ParseMeasureGroupStratifierComponentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMeasureGroupStratifierComponentProperties(obj : TTurtleComplex; result : TFhirMeasureGroupStratifierComponent);
begin
    ParseBackboneElementProperties(obj, result);
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Measure.group.stratifier.component.code'));{q3b}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/Measure.group.stratifier.component.description'));{q1}
    result.criteria := ParseExpression(obj.complex('http://hl7.org/fhir/Measure.group.stratifier.component.criteria'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeMeasureGroupStratifierComponent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMeasureGroupStratifierComponent; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MeasureGroupStratifierComponent'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Measure.group.stratifier.component', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Measure.group.stratifier.component', 'description', elem.descriptionElement, false, -1);{x.2ea}
  ComposeExpression(this, 'Measure.group.stratifier.component', 'criteria', elem.criteriaElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseMeasureSupplementalData(obj : TTurtleComplex) : TFhirMeasureSupplementalData;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMeasureSupplementalData.create;
  try
    ParseMeasureSupplementalDataProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMeasureSupplementalDataProperties(obj : TTurtleComplex; result : TFhirMeasureSupplementalData);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Measure.supplementalData.code'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Measure.supplementalData.usage') do
      result.usageList.Add(parseCodeableConcept(item));
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/Measure.supplementalData.description'));{q1}
    result.criteria := ParseExpression(obj.complex('http://hl7.org/fhir/Measure.supplementalData.criteria'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeMeasureSupplementalData(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMeasureSupplementalData; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MeasureSupplementalData'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Measure.supplementalData', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.usageList.Count - 1 do
      ComposeCodeableConcept(this, 'Measure.supplementalData', 'usage', elem.usageList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Measure.supplementalData', 'description', elem.descriptionElement, false, -1);{x.2ea}
  ComposeExpression(this, 'Measure.supplementalData', 'criteria', elem.criteriaElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseMeasure(obj : TTurtleComplex) : TFhirMeasure;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMeasure.create;
  try
    ParseMeasureProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMeasureProperties(obj : TTurtleComplex; result : TFhirMeasure);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/Measure.url'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Measure.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/Measure.version'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/Measure.name'));{q1}
    result.titleElement := ParseString(obj.complex('http://hl7.org/fhir/Measure.title'));{q1}
    result.subtitleElement := ParseString(obj.complex('http://hl7.org/fhir/Measure.subtitle'));{q1}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Measure.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    result.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Measure.experimental'));{q1}
    if obj.has('http://hl7.org/fhir/Measure.subjectCodeableConcept', item) then
      result.subject := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/Measure.subjectReference', item) {a3} then
      result.subject := ParseReference(item);
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Measure.date'));{q1}
    result.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/Measure.publisher'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Measure.contact') do
      result.contactList.Add(parseContactDetail(item));
    result.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/Measure.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Measure.useContext') do
      result.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/Measure.jurisdiction') do
      result.jurisdictionList.Add(parseCodeableConcept(item));
    result.purposeElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/Measure.purpose'));{q1}
    result.usageElement := ParseString(obj.complex('http://hl7.org/fhir/Measure.usage'));{q1}
    result.copyrightElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/Measure.copyright'));{q1}
    result.approvalDateElement := ParseDate(obj.complex('http://hl7.org/fhir/Measure.approvalDate'));{q1}
    result.lastReviewDateElement := ParseDate(obj.complex('http://hl7.org/fhir/Measure.lastReviewDate'));{q1}
    result.effectivePeriod := ParsePeriod(obj.complex('http://hl7.org/fhir/Measure.effectivePeriod'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Measure.topic') do
      result.topicList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Measure.author') do
      result.authorList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/Measure.editor') do
      result.editorList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/Measure.reviewer') do
      result.reviewerList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/Measure.endorser') do
      result.endorserList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/Measure.relatedArtifact') do
      result.relatedArtifactList.Add(parseRelatedArtifact(item));
    for item in obj.complexes('http://hl7.org/fhir/Measure.library') do
      result.library_List.Add(parseCanonical(item));
    result.disclaimerElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/Measure.disclaimer'));{q1}
    result.scoring := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Measure.scoring'));{q3b}
    result.compositeScoring := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Measure.compositeScoring'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Measure.type') do
      result.type_List.Add(parseCodeableConcept(item));
    result.riskAdjustmentElement := ParseString(obj.complex('http://hl7.org/fhir/Measure.riskAdjustment'));{q1}
    result.rateAggregationElement := ParseString(obj.complex('http://hl7.org/fhir/Measure.rateAggregation'));{q1}
    result.rationaleElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/Measure.rationale'));{q1}
    result.clinicalRecommendationStatementElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/Measure.clinicalRecommendationStatement'));{q1}
    result.improvementNotation := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Measure.improvementNotation'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Measure.definition') do
      result.definitionList.Add(parseMarkdown(item));
    result.guidanceElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/Measure.guidance'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Measure.group') do
      result.groupList.Add(parseMeasureGroup(item));
    for item in obj.complexes('http://hl7.org/fhir/Measure.supplementalData') do
      result.supplementalDataList.Add(parseMeasureSupplementalData(item));
end;

procedure TFHIRTurtleComposer.ComposeMeasure(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMeasure; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Measure'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUri(this, 'Measure', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Measure', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(this, 'Measure', 'version', elem.versionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(this, 'Measure', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeString(this, 'Measure', 'title', elem.titleElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('subtitle') then
    ComposeString(this, 'Measure', 'subtitle', elem.subtitleElement, false, -1);{x.2ea}
  ComposeEnum(this, 'Measure', 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(this, 'Measure', 'experimental', elem.experimentalElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and (elem.subject is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Measure', 'subjectCodeableConcept', TFhirCodeableConcept(elem.subject), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.subject is TFhirReference) {2} then
    ComposeReference(this, 'Measure', 'subjectReference', TFhirReference(elem.subject), false,-1);{x.d8}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(this, 'Measure', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(this, 'Measure', 'publisher', elem.publisherElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(this, 'Measure', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeMarkdown(this, 'Measure', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(this, 'Measure', 'useContext', elem.useContextList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'Measure', 'jurisdiction', elem.jurisdictionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdown(this, 'Measure', 'purpose', elem.purposeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('usage') then
    ComposeString(this, 'Measure', 'usage', elem.usageElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdown(this, 'Measure', 'copyright', elem.copyrightElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('approvalDate') then
    ComposeDate(this, 'Measure', 'approvalDate', elem.approvalDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('lastReviewDate') then
    ComposeDate(this, 'Measure', 'lastReviewDate', elem.lastReviewDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('effectivePeriod') then
    ComposePeriod(this, 'Measure', 'effectivePeriod', elem.effectivePeriodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('topic') then
    for i := 0 to elem.topicList.Count - 1 do
      ComposeCodeableConcept(this, 'Measure', 'topic', elem.topicList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('author') then
    for i := 0 to elem.authorList.Count - 1 do
      ComposeContactDetail(this, 'Measure', 'author', elem.authorList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('editor') then
    for i := 0 to elem.editorList.Count - 1 do
      ComposeContactDetail(this, 'Measure', 'editor', elem.editorList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('reviewer') then
    for i := 0 to elem.reviewerList.Count - 1 do
      ComposeContactDetail(this, 'Measure', 'reviewer', elem.reviewerList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('endorser') then
    for i := 0 to elem.endorserList.Count - 1 do
      ComposeContactDetail(this, 'Measure', 'endorser', elem.endorserList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('relatedArtifact') then
    for i := 0 to elem.relatedArtifactList.Count - 1 do
      ComposeRelatedArtifact(this, 'Measure', 'relatedArtifact', elem.relatedArtifactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('library_') then
    for i := 0 to elem.library_List.Count - 1 do
      ComposeCanonical(this, 'Measure', 'library', elem.library_List[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('disclaimer') then
    ComposeMarkdown(this, 'Measure', 'disclaimer', elem.disclaimerElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('scoring') then
    ComposeCodeableConcept(this, 'Measure', 'scoring', elem.scoringElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('compositeScoring') then
    ComposeCodeableConcept(this, 'Measure', 'compositeScoring', elem.compositeScoringElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(this, 'Measure', 'type', elem.type_List[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('riskAdjustment') then
    ComposeString(this, 'Measure', 'riskAdjustment', elem.riskAdjustmentElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('rateAggregation') then
    ComposeString(this, 'Measure', 'rateAggregation', elem.rateAggregationElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('rationale') then
    ComposeMarkdown(this, 'Measure', 'rationale', elem.rationaleElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('clinicalRecommendationStatement') then
    ComposeMarkdown(this, 'Measure', 'clinicalRecommendationStatement', elem.clinicalRecommendationStatementElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('improvementNotation') then
    ComposeCodeableConcept(this, 'Measure', 'improvementNotation', elem.improvementNotationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('definition') then
    for i := 0 to elem.definitionList.Count - 1 do
      ComposeMarkdown(this, 'Measure', 'definition', elem.definitionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('guidance') then
    ComposeMarkdown(this, 'Measure', 'guidance', elem.guidanceElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('group') then
    for i := 0 to elem.groupList.Count - 1 do
      ComposeMeasureGroup(this, 'Measure', 'group', elem.groupList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('supplementalData') then
    for i := 0 to elem.supplementalDataList.Count - 1 do
      ComposeMeasureSupplementalData(this, 'Measure', 'supplementalData', elem.supplementalDataList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_MEASURE}
{$IFDEF FHIR_MEASUREREPORT}
function TFHIRTurtleParser.ParseMeasureReportGroup(obj : TTurtleComplex) : TFhirMeasureReportGroup;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMeasureReportGroup.create;
  try
    ParseMeasureReportGroupProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMeasureReportGroupProperties(obj : TTurtleComplex; result : TFhirMeasureReportGroup);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MeasureReport.group.code'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/MeasureReport.group.population') do
      result.populationList.Add(parseMeasureReportGroupPopulation(item));
    result.measureScore := ParseQuantity(obj.complex('http://hl7.org/fhir/MeasureReport.group.measureScore'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/MeasureReport.group.stratifier') do
      result.stratifierList.Add(parseMeasureReportGroupStratifier(item));
end;

procedure TFHIRTurtleComposer.ComposeMeasureReportGroup(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMeasureReportGroup; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MeasureReportGroup'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'MeasureReport.group', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.populationList.Count - 1 do
      ComposeMeasureReportGroupPopulation(this, 'MeasureReport.group', 'population', elem.populationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'MeasureReport.group', 'measureScore', elem.measureScoreElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.stratifierList.Count - 1 do
      ComposeMeasureReportGroupStratifier(this, 'MeasureReport.group', 'stratifier', elem.stratifierList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseMeasureReportGroupPopulation(obj : TTurtleComplex) : TFhirMeasureReportGroupPopulation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMeasureReportGroupPopulation.create;
  try
    ParseMeasureReportGroupPopulationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMeasureReportGroupPopulationProperties(obj : TTurtleComplex; result : TFhirMeasureReportGroupPopulation);
begin
    ParseBackboneElementProperties(obj, result);
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MeasureReport.group.population.code'));{q3b}
    result.countElement := ParseInteger(obj.complex('http://hl7.org/fhir/MeasureReport.group.population.count'));{q1}
    result.subjectResults := ParseReference{TFhirList}(obj.complex('http://hl7.org/fhir/MeasureReport.group.population.subjectResults'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeMeasureReportGroupPopulation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMeasureReportGroupPopulation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MeasureReportGroupPopulation'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'MeasureReport.group.population', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(this, 'MeasureReport.group.population', 'count', elem.countElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirList}(this, 'MeasureReport.group.population', 'subjectResults', elem.subjectResultsElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseMeasureReportGroupStratifier(obj : TTurtleComplex) : TFhirMeasureReportGroupStratifier;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMeasureReportGroupStratifier.create;
  try
    ParseMeasureReportGroupStratifierProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMeasureReportGroupStratifierProperties(obj : TTurtleComplex; result : TFhirMeasureReportGroupStratifier);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/MeasureReport.group.stratifier.code') do
      result.codeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/MeasureReport.group.stratifier.stratum') do
      result.stratumList.Add(parseMeasureReportGroupStratifierStratum(item));
end;

procedure TFHIRTurtleComposer.ComposeMeasureReportGroupStratifier(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMeasureReportGroupStratifier; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MeasureReportGroupStratifier'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.codeList.Count - 1 do
      ComposeCodeableConcept(this, 'MeasureReport.group.stratifier', 'code', elem.codeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.stratumList.Count - 1 do
      ComposeMeasureReportGroupStratifierStratum(this, 'MeasureReport.group.stratifier', 'stratum', elem.stratumList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseMeasureReportGroupStratifierStratum(obj : TTurtleComplex) : TFhirMeasureReportGroupStratifierStratum;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMeasureReportGroupStratifierStratum.create;
  try
    ParseMeasureReportGroupStratifierStratumProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMeasureReportGroupStratifierStratumProperties(obj : TTurtleComplex; result : TFhirMeasureReportGroupStratifierStratum);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.value := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MeasureReport.group.stratifier.stratum.value'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/MeasureReport.group.stratifier.stratum.component') do
      result.componentList.Add(parseMeasureReportGroupStratifierStratumComponent(item));
    for item in obj.complexes('http://hl7.org/fhir/MeasureReport.group.stratifier.stratum.population') do
      result.populationList.Add(parseMeasureReportGroupStratifierStratumPopulation(item));
    result.measureScore := ParseQuantity(obj.complex('http://hl7.org/fhir/MeasureReport.group.stratifier.stratum.measureScore'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeMeasureReportGroupStratifierStratum(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMeasureReportGroupStratifierStratum; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MeasureReportGroupStratifierStratum'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'MeasureReport.group.stratifier.stratum', 'value', elem.valueElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.componentList.Count - 1 do
      ComposeMeasureReportGroupStratifierStratumComponent(this, 'MeasureReport.group.stratifier.stratum', 'component', elem.componentList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.populationList.Count - 1 do
      ComposeMeasureReportGroupStratifierStratumPopulation(this, 'MeasureReport.group.stratifier.stratum', 'population', elem.populationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'MeasureReport.group.stratifier.stratum', 'measureScore', elem.measureScoreElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseMeasureReportGroupStratifierStratumComponent(obj : TTurtleComplex) : TFhirMeasureReportGroupStratifierStratumComponent;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMeasureReportGroupStratifierStratumComponent.create;
  try
    ParseMeasureReportGroupStratifierStratumComponentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMeasureReportGroupStratifierStratumComponentProperties(obj : TTurtleComplex; result : TFhirMeasureReportGroupStratifierStratumComponent);
begin
    ParseBackboneElementProperties(obj, result);
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MeasureReport.group.stratifier.stratum.component.code'));{q3b}
    result.value := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MeasureReport.group.stratifier.stratum.component.value'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeMeasureReportGroupStratifierStratumComponent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMeasureReportGroupStratifierStratumComponent; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MeasureReportGroupStratifierStratumComponent'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'MeasureReport.group.stratifier.stratum.component', 'code', elem.codeElement, false, -1);{x.2f}
  ComposeCodeableConcept(this, 'MeasureReport.group.stratifier.stratum.component', 'value', elem.valueElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseMeasureReportGroupStratifierStratumPopulation(obj : TTurtleComplex) : TFhirMeasureReportGroupStratifierStratumPopulation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMeasureReportGroupStratifierStratumPopulation.create;
  try
    ParseMeasureReportGroupStratifierStratumPopulationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMeasureReportGroupStratifierStratumPopulationProperties(obj : TTurtleComplex; result : TFhirMeasureReportGroupStratifierStratumPopulation);
begin
    ParseBackboneElementProperties(obj, result);
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MeasureReport.group.stratifier.stratum.population.code'));{q3b}
    result.countElement := ParseInteger(obj.complex('http://hl7.org/fhir/MeasureReport.group.stratifier.stratum.population.count'));{q1}
    result.subjectResults := ParseReference{TFhirList}(obj.complex('http://hl7.org/fhir/MeasureReport.group.stratifier.stratum.population.subjectResults'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeMeasureReportGroupStratifierStratumPopulation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMeasureReportGroupStratifierStratumPopulation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MeasureReportGroupStratifierStratumPopulation'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'MeasureReport.group.stratifier.stratum.population', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(this, 'MeasureReport.group.stratifier.stratum.population', 'count', elem.countElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirList}(this, 'MeasureReport.group.stratifier.stratum.population', 'subjectResults', elem.subjectResultsElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseMeasureReport(obj : TTurtleComplex) : TFhirMeasureReport;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMeasureReport.create;
  try
    ParseMeasureReportProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMeasureReportProperties(obj : TTurtleComplex; result : TFhirMeasureReport);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/MeasureReport.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/MeasureReport.status'), CODES_TFhirMeasureReportStatusEnum, SYSTEMS_TFhirMeasureReportStatusEnum);
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/MeasureReport.type'), CODES_TFhirMeasureReportTypeEnum, SYSTEMS_TFhirMeasureReportTypeEnum);
    result.measureElement := ParseCanonical(obj.complex('http://hl7.org/fhir/MeasureReport.measure'));{q1}
    result.subject := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/MeasureReport.subject'));{q3b}
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/MeasureReport.date'));{q1}
    result.reporter := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/MeasureReport.reporter'));{q3b}
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/MeasureReport.period'));{q3b}
    result.improvementNotation := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MeasureReport.improvementNotation'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/MeasureReport.group') do
      result.groupList.Add(parseMeasureReportGroup(item));
    for item in obj.complexes('http://hl7.org/fhir/MeasureReport.evaluatedResource') do
      result.evaluatedResourceList.Add(parseReference{TFhirReference}(item));
end;

procedure TFHIRTurtleComposer.ComposeMeasureReport(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMeasureReport; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MeasureReport'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'MeasureReport', 'identifier', elem.identifierList[i], false, i);{x.d3}
  ComposeEnum(this, 'MeasureReport', 'status', elem.StatusElement, CODES_TFhirMeasureReportStatusEnum, SYSTEMS_TFhirMeasureReportStatusEnum, false, -1);{x.d4}
  ComposeEnum(this, 'MeasureReport', 'type', elem.Type_Element, CODES_TFhirMeasureReportTypeEnum, SYSTEMS_TFhirMeasureReportTypeEnum, false, -1);{x.d4}
  ComposeCanonical(this, 'MeasureReport', 'measure', elem.measureElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{TFhirPatient}(this, 'MeasureReport', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(this, 'MeasureReport', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reporter') then
    ComposeReference{TFhirPractitioner}(this, 'MeasureReport', 'reporter', elem.reporterElement, false, -1);{x.2f}
  ComposePeriod(this, 'MeasureReport', 'period', elem.periodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('improvementNotation') then
    ComposeCodeableConcept(this, 'MeasureReport', 'improvementNotation', elem.improvementNotationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('group') then
    for i := 0 to elem.groupList.Count - 1 do
      ComposeMeasureReportGroup(this, 'MeasureReport', 'group', elem.groupList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('evaluatedResource') then
    for i := 0 to elem.evaluatedResourceList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'MeasureReport', 'evaluatedResource', elem.evaluatedResourceList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_MEASUREREPORT}
{$IFDEF FHIR_MEDIA}
function TFHIRTurtleParser.ParseMedia(obj : TTurtleComplex) : TFhirMedia;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedia.create;
  try
    ParseMediaProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMediaProperties(obj : TTurtleComplex; result : TFhirMedia);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Media.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/Media.basedOn') do
      result.basedOnList.Add(parseReference{TFhirServiceRequest}(item));
    for item in obj.complexes('http://hl7.org/fhir/Media.partOf') do
      result.partOfList.Add(parseReference{TFhirReference}(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Media.status'), CODES_TFhirEventStatusEnum, SYSTEMS_TFhirEventStatusEnum);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Media.type'));{q3b}
    result.modality := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Media.modality'));{q3b}
    result.view := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Media.view'));{q3b}
    result.subject := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/Media.subject'));{q3b}
    result.encounter := ParseReference{TFhirEncounter}(obj.complex('http://hl7.org/fhir/Media.encounter'));{q3b}
    if obj.has('http://hl7.org/fhir/Media.createdPeriod', item) then
      result.created := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/Media.createdDateTime', item) then
      result.created := parseDateTime(item);
    result.issuedElement := ParseInstant(obj.complex('http://hl7.org/fhir/Media.issued'));{q1}
    result.operator := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/Media.operator'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Media.reasonCode') do
      result.reasonCodeList.Add(parseCodeableConcept(item));
    result.bodySite := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Media.bodySite'));{q3b}
    result.deviceNameElement := ParseString(obj.complex('http://hl7.org/fhir/Media.deviceName'));{q1}
    result.device := ParseReference{TFhirDevice}(obj.complex('http://hl7.org/fhir/Media.device'));{q3b}
    result.heightElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Media.height'));{q1}
    result.widthElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Media.width'));{q1}
    result.framesElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Media.frames'));{q1}
    result.durationElement := ParseDecimal(obj.complex('http://hl7.org/fhir/Media.duration'));{q1}
    result.content := ParseAttachment(obj.complex('http://hl7.org/fhir/Media.content'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Media.note') do
      result.noteList.Add(parseAnnotation(item));
end;

procedure TFHIRTurtleComposer.ComposeMedia(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedia; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Media'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Media', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('basedOn') then
    for i := 0 to elem.basedOnList.Count - 1 do
      ComposeReference{TFhirServiceRequest}(this, 'Media', 'basedOn', elem.basedOnList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('partOf') then
    for i := 0 to elem.partOfList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'Media', 'partOf', elem.partOfList[i], false, i);{x.d3}
  ComposeEnum(this, 'Media', 'status', elem.StatusElement, CODES_TFhirEventStatusEnum, SYSTEMS_TFhirEventStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCodeableConcept(this, 'Media', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('modality') then
    ComposeCodeableConcept(this, 'Media', 'modality', elem.modalityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('view') then
    ComposeCodeableConcept(this, 'Media', 'view', elem.viewElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{TFhirPatient}(this, 'Media', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(this, 'Media', 'encounter', elem.encounterElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.created is TFhirPeriod) {6} then
    ComposePeriod(this, 'Media', 'createdPeriod', TFhirPeriod(elem.created), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.created is TFhirDateTime) {6} then
    ComposeDateTime(this, 'Media', 'createdDateTime', TFhirDateTime(elem.created), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('issued') then
    ComposeInstant(this, 'Media', 'issued', elem.issuedElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('operator') then
    ComposeReference{TFhirPractitioner}(this, 'Media', 'operator', elem.operatorElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonCode') then
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'Media', 'reasonCode', elem.reasonCodeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('bodySite') then
    ComposeCodeableConcept(this, 'Media', 'bodySite', elem.bodySiteElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('deviceName') then
    ComposeString(this, 'Media', 'deviceName', elem.deviceNameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('device') then
    ComposeReference{TFhirDevice}(this, 'Media', 'device', elem.deviceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('height') then
    ComposePositiveInt(this, 'Media', 'height', elem.heightElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('width') then
    ComposePositiveInt(this, 'Media', 'width', elem.widthElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('frames') then
    ComposePositiveInt(this, 'Media', 'frames', elem.framesElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('duration') then
    ComposeDecimal(this, 'Media', 'duration', elem.durationElement, false, -1);{x.2ea}
  ComposeAttachment(this, 'Media', 'content', elem.contentElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'Media', 'note', elem.noteList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_MEDIA}
{$IFDEF FHIR_MEDICATION}
function TFHIRTurtleParser.ParseMedicationIngredient(obj : TTurtleComplex) : TFhirMedicationIngredient;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationIngredient.create;
  try
    ParseMedicationIngredientProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationIngredientProperties(obj : TTurtleComplex; result : TFhirMedicationIngredient);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    if obj.has('http://hl7.org/fhir/Medication.ingredient.itemCodeableConcept', item) then
      result.item := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/Medication.ingredient.itemReference', item) {a3} then
      result.item := ParseReference(item);
    result.isActiveElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Medication.ingredient.isActive'));{q1}
    result.strength := ParseRatio(obj.complex('http://hl7.org/fhir/Medication.ingredient.strength'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeMedicationIngredient(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationIngredient; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationIngredient'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (elem.item is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Medication.ingredient', 'itemCodeableConcept', TFhirCodeableConcept(elem.item), false, -1){x.d9}
  else if (elem.item is TFhirReference) {2} then
    ComposeReference(this, 'Medication.ingredient', 'itemReference', TFhirReference(elem.item), false,-1);{x.d8}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'Medication.ingredient', 'isActive', elem.isActiveElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeRatio(this, 'Medication.ingredient', 'strength', elem.strengthElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseMedicationBatch(obj : TTurtleComplex) : TFhirMedicationBatch;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationBatch.create;
  try
    ParseMedicationBatchProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationBatchProperties(obj : TTurtleComplex; result : TFhirMedicationBatch);
begin
    ParseBackboneElementProperties(obj, result);
    result.lotNumberElement := ParseString(obj.complex('http://hl7.org/fhir/Medication.batch.lotNumber'));{q1}
    result.expirationDateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Medication.batch.expirationDate'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeMedicationBatch(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationBatch; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationBatch'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Medication.batch', 'lotNumber', elem.lotNumberElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'Medication.batch', 'expirationDate', elem.expirationDateElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseMedication(obj : TTurtleComplex) : TFhirMedication;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedication.create;
  try
    ParseMedicationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationProperties(obj : TTurtleComplex; result : TFhirMedication);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Medication.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Medication.code'));{q3b}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Medication.status'), CODES_TFhirMedicationStatusEnum, SYSTEMS_TFhirMedicationStatusEnum);
    result.manufacturer := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/Medication.manufacturer'));{q3b}
    result.form := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Medication.form'));{q3b}
    result.amount := ParseRatio(obj.complex('http://hl7.org/fhir/Medication.amount'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Medication.ingredient') do
      result.ingredientList.Add(parseMedicationIngredient(item));
    result.batch := ParseMedicationBatch(obj.complex('http://hl7.org/fhir/Medication.batch'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeMedication(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedication; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Medication'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Medication', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') then
    ComposeCodeableConcept(this, 'Medication', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(this, 'Medication', 'status', elem.StatusElement, CODES_TFhirMedicationStatusEnum, SYSTEMS_TFhirMedicationStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('manufacturer') then
    ComposeReference{TFhirOrganization}(this, 'Medication', 'manufacturer', elem.manufacturerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('form') then
    ComposeCodeableConcept(this, 'Medication', 'form', elem.formElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('amount') then
    ComposeRatio(this, 'Medication', 'amount', elem.amountElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('ingredient') then
    for i := 0 to elem.ingredientList.Count - 1 do
      ComposeMedicationIngredient(this, 'Medication', 'ingredient', elem.ingredientList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('batch') then
    ComposeMedicationBatch(this, 'Medication', 'batch', elem.batchElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_MEDICATION}
{$IFDEF FHIR_MEDICATIONADMINISTRATION}
function TFHIRTurtleParser.ParseMedicationAdministrationPerformer(obj : TTurtleComplex) : TFhirMedicationAdministrationPerformer;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationAdministrationPerformer.create;
  try
    ParseMedicationAdministrationPerformerProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationAdministrationPerformerProperties(obj : TTurtleComplex; result : TFhirMedicationAdministrationPerformer);
begin
    ParseBackboneElementProperties(obj, result);
    result.function_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationAdministration.performer.function'));{q3b}
    result.actor := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/MedicationAdministration.performer.actor'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeMedicationAdministrationPerformer(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationAdministrationPerformer; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationAdministrationPerformer'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'MedicationAdministration.performer', 'function', elem.function_Element, false, -1);{x.2f}
  ComposeReference{TFhirPractitioner}(this, 'MedicationAdministration.performer', 'actor', elem.actorElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseMedicationAdministrationDosage(obj : TTurtleComplex) : TFhirMedicationAdministrationDosage;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationAdministrationDosage.create;
  try
    ParseMedicationAdministrationDosageProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationAdministrationDosageProperties(obj : TTurtleComplex; result : TFhirMedicationAdministrationDosage);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.textElement := ParseString(obj.complex('http://hl7.org/fhir/MedicationAdministration.dosage.text'));{q1}
    result.site := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationAdministration.dosage.site'));{q3b}
    result.route := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationAdministration.dosage.route'));{q3b}
    result.method := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationAdministration.dosage.method'));{q3b}
    result.dose := ParseQuantity(obj.complex('http://hl7.org/fhir/MedicationAdministration.dosage.dose'));{q3b}
    if obj.has('http://hl7.org/fhir/MedicationAdministration.dosage.rateRatio', item) then
      result.rate := parseRatio(item);
    if obj.has('http://hl7.org/fhir/MedicationAdministration.dosage.rateQuantity', item) then
      result.rate := parseQuantity(item);
end;

procedure TFHIRTurtleComposer.ComposeMedicationAdministrationDosage(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationAdministrationDosage; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationAdministrationDosage'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'MedicationAdministration.dosage', 'text', elem.textElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'MedicationAdministration.dosage', 'site', elem.siteElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'MedicationAdministration.dosage', 'route', elem.routeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'MedicationAdministration.dosage', 'method', elem.methodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'MedicationAdministration.dosage', 'dose', elem.doseElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and (elem.rate is TFhirRatio) {6} then
    ComposeRatio(this, 'MedicationAdministration.dosage', 'rateRatio', TFhirRatio(elem.rate), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.rate is TFhirQuantity) {6} then
    ComposeQuantity(this, 'MedicationAdministration.dosage', 'rateQuantity', TFhirQuantity(elem.rate), false, -1);{x.d9}
end;

function TFHIRTurtleParser.ParseMedicationAdministration(obj : TTurtleComplex) : TFhirMedicationAdministration;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationAdministration.create;
  try
    ParseMedicationAdministrationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationAdministrationProperties(obj : TTurtleComplex; result : TFhirMedicationAdministration);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/MedicationAdministration.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationAdministration.instantiates') do
      result.instantiatesList.Add(parseUri(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationAdministration.partOf') do
      result.partOfList.Add(parseReference{TFhirMedicationAdministration}(item));
    result.statusElement := ParseCode(obj.complex('http://hl7.org/fhir/MedicationAdministration.status'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/MedicationAdministration.statusReason') do
      result.statusReasonList.Add(parseCodeableConcept(item));
    result.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationAdministration.category'));{q3b}
    if obj.has('http://hl7.org/fhir/MedicationAdministration.medicationCodeableConcept', item) then
      result.medication := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/MedicationAdministration.medicationReference', item) {a3} then
      result.medication := ParseReference(item);
    result.subject := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/MedicationAdministration.subject'));{q3b}
    result.context := ParseReference{TFhirEncounter}(obj.complex('http://hl7.org/fhir/MedicationAdministration.context'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/MedicationAdministration.supportingInformation') do
      result.supportingInformationList.Add(parseReference{TFhirReference}(item));
    if obj.has('http://hl7.org/fhir/MedicationAdministration.effectivePeriod', item) then
      result.effective := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/MedicationAdministration.effectiveDateTime', item) then
      result.effective := parseDateTime(item);
    for item in obj.complexes('http://hl7.org/fhir/MedicationAdministration.performer') do
      result.performerList.Add(parseMedicationAdministrationPerformer(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationAdministration.reasonCode') do
      result.reasonCodeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationAdministration.reasonReference') do
      result.reasonReferenceList.Add(parseReference{TFhirCondition}(item));
    result.request := ParseReference{TFhirMedicationRequest}(obj.complex('http://hl7.org/fhir/MedicationAdministration.request'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/MedicationAdministration.device') do
      result.deviceList.Add(parseReference{TFhirDevice}(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationAdministration.note') do
      result.noteList.Add(parseAnnotation(item));
    result.dosage := ParseMedicationAdministrationDosage(obj.complex('http://hl7.org/fhir/MedicationAdministration.dosage'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/MedicationAdministration.eventHistory') do
      result.eventHistoryList.Add(parseReference{TFhirProvenance}(item));
end;

procedure TFHIRTurtleComposer.ComposeMedicationAdministration(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationAdministration; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationAdministration'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'MedicationAdministration', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('instantiates') then
    for i := 0 to elem.instantiatesList.Count - 1 do
      ComposeUri(this, 'MedicationAdministration', 'instantiates', elem.instantiatesList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('partOf') then
    for i := 0 to elem.partOfList.Count - 1 do
      ComposeReference{TFhirMedicationAdministration}(this, 'MedicationAdministration', 'partOf', elem.partOfList[i], false, i);{x.d3}
  ComposeCode(this, 'MedicationAdministration', 'status', elem.statusElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('statusReason') then
    for i := 0 to elem.statusReasonList.Count - 1 do
      ComposeCodeableConcept(this, 'MedicationAdministration', 'statusReason', elem.statusReasonList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('category') then
    ComposeCodeableConcept(this, 'MedicationAdministration', 'category', elem.categoryElement, false, -1);{x.2f}
  if (elem.medication is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'MedicationAdministration', 'medicationCodeableConcept', TFhirCodeableConcept(elem.medication), false, -1){x.d9}
  else if (elem.medication is TFhirReference) {2} then
    ComposeReference(this, 'MedicationAdministration', 'medicationReference', TFhirReference(elem.medication), false,-1);{x.d8}
  ComposeReference{TFhirPatient}(this, 'MedicationAdministration', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('context') then
    ComposeReference{TFhirEncounter}(this, 'MedicationAdministration', 'context', elem.contextElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('supportingInformation') then
    for i := 0 to elem.supportingInformationList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'MedicationAdministration', 'supportingInformation', elem.supportingInformationList[i], false, i);{x.d3}
  if (elem.effective is TFhirPeriod) {6} then
    ComposePeriod(this, 'MedicationAdministration', 'effectivePeriod', TFhirPeriod(elem.effective), false, -1){x.d9}
  else if (elem.effective is TFhirDateTime) {6} then
    ComposeDateTime(this, 'MedicationAdministration', 'effectiveDateTime', TFhirDateTime(elem.effective), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('performer') then
    for i := 0 to elem.performerList.Count - 1 do
      ComposeMedicationAdministrationPerformer(this, 'MedicationAdministration', 'performer', elem.performerList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('reasonCode') then
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'MedicationAdministration', 'reasonCode', elem.reasonCodeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('reasonReference') then
    for i := 0 to elem.reasonReferenceList.Count - 1 do
      ComposeReference{TFhirCondition}(this, 'MedicationAdministration', 'reasonReference', elem.reasonReferenceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('request') then
    ComposeReference{TFhirMedicationRequest}(this, 'MedicationAdministration', 'request', elem.requestElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('device') then
    for i := 0 to elem.deviceList.Count - 1 do
      ComposeReference{TFhirDevice}(this, 'MedicationAdministration', 'device', elem.deviceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'MedicationAdministration', 'note', elem.noteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('dosage') then
    ComposeMedicationAdministrationDosage(this, 'MedicationAdministration', 'dosage', elem.dosageElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('eventHistory') then
    for i := 0 to elem.eventHistoryList.Count - 1 do
      ComposeReference{TFhirProvenance}(this, 'MedicationAdministration', 'eventHistory', elem.eventHistoryList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_MEDICATIONADMINISTRATION}
{$IFDEF FHIR_MEDICATIONDISPENSE}
function TFHIRTurtleParser.ParseMedicationDispensePerformer(obj : TTurtleComplex) : TFhirMedicationDispensePerformer;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationDispensePerformer.create;
  try
    ParseMedicationDispensePerformerProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationDispensePerformerProperties(obj : TTurtleComplex; result : TFhirMedicationDispensePerformer);
begin
    ParseBackboneElementProperties(obj, result);
    result.function_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationDispense.performer.function'));{q3b}
    result.actor := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/MedicationDispense.performer.actor'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeMedicationDispensePerformer(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationDispensePerformer; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationDispensePerformer'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'MedicationDispense.performer', 'function', elem.function_Element, false, -1);{x.2f}
  ComposeReference{TFhirPractitioner}(this, 'MedicationDispense.performer', 'actor', elem.actorElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseMedicationDispenseSubstitution(obj : TTurtleComplex) : TFhirMedicationDispenseSubstitution;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationDispenseSubstitution.create;
  try
    ParseMedicationDispenseSubstitutionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationDispenseSubstitutionProperties(obj : TTurtleComplex; result : TFhirMedicationDispenseSubstitution);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.wasSubstitutedElement := ParseBoolean(obj.complex('http://hl7.org/fhir/MedicationDispense.substitution.wasSubstituted'));{q1}
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationDispense.substitution.type'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/MedicationDispense.substitution.reason') do
      result.reasonList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationDispense.substitution.responsibleParty') do
      result.responsiblePartyList.Add(parseReference{TFhirPractitioner}(item));
end;

procedure TFHIRTurtleComposer.ComposeMedicationDispenseSubstitution(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationDispenseSubstitution; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationDispenseSubstitution'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeBoolean(this, 'MedicationDispense.substitution', 'wasSubstituted', elem.wasSubstitutedElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'MedicationDispense.substitution', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.reasonList.Count - 1 do
      ComposeCodeableConcept(this, 'MedicationDispense.substitution', 'reason', elem.reasonList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.responsiblePartyList.Count - 1 do
      ComposeReference{TFhirPractitioner}(this, 'MedicationDispense.substitution', 'responsibleParty', elem.responsiblePartyList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseMedicationDispense(obj : TTurtleComplex) : TFhirMedicationDispense;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationDispense.create;
  try
    ParseMedicationDispenseProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationDispenseProperties(obj : TTurtleComplex; result : TFhirMedicationDispense);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/MedicationDispense.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationDispense.partOf') do
      result.partOfList.Add(parseReference{TFhirProcedure}(item));
    result.statusElement := ParseCode(obj.complex('http://hl7.org/fhir/MedicationDispense.status'));{q1}
    if obj.has('http://hl7.org/fhir/MedicationDispense.statusReasonCodeableConcept', item) then
      result.statusReason := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/MedicationDispense.statusReasonReference', item) {a3} then
      result.statusReason := ParseReference(item);
    result.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationDispense.category'));{q3b}
    if obj.has('http://hl7.org/fhir/MedicationDispense.medicationCodeableConcept', item) then
      result.medication := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/MedicationDispense.medicationReference', item) {a3} then
      result.medication := ParseReference(item);
    result.subject := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/MedicationDispense.subject'));{q3b}
    result.context := ParseReference{TFhirEncounter}(obj.complex('http://hl7.org/fhir/MedicationDispense.context'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/MedicationDispense.supportingInformation') do
      result.supportingInformationList.Add(parseReference{TFhirReference}(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationDispense.performer') do
      result.performerList.Add(parseMedicationDispensePerformer(item));
    result.location := ParseReference{TFhirLocation}(obj.complex('http://hl7.org/fhir/MedicationDispense.location'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/MedicationDispense.authorizingPrescription') do
      result.authorizingPrescriptionList.Add(parseReference{TFhirMedicationRequest}(item));
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationDispense.type'));{q3b}
    result.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/MedicationDispense.quantity'));{q3b}
    result.daysSupply := ParseQuantity(obj.complex('http://hl7.org/fhir/MedicationDispense.daysSupply'));{q3b}
    result.whenPreparedElement := ParseDateTime(obj.complex('http://hl7.org/fhir/MedicationDispense.whenPrepared'));{q1}
    result.whenHandedOverElement := ParseDateTime(obj.complex('http://hl7.org/fhir/MedicationDispense.whenHandedOver'));{q1}
    result.destination := ParseReference{TFhirLocation}(obj.complex('http://hl7.org/fhir/MedicationDispense.destination'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/MedicationDispense.receiver') do
      result.receiverList.Add(parseReference{TFhirPatient}(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationDispense.note') do
      result.noteList.Add(parseAnnotation(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationDispense.dosageInstruction') do
      result.dosageInstructionList.Add(parseDosage(item));
    result.substitution := ParseMedicationDispenseSubstitution(obj.complex('http://hl7.org/fhir/MedicationDispense.substitution'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/MedicationDispense.detectedIssue') do
      result.detectedIssueList.Add(parseReference{TFhirDetectedIssue}(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationDispense.eventHistory') do
      result.eventHistoryList.Add(parseReference{TFhirProvenance}(item));
end;

procedure TFHIRTurtleComposer.ComposeMedicationDispense(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationDispense; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationDispense'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'MedicationDispense', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('partOf') then
    for i := 0 to elem.partOfList.Count - 1 do
      ComposeReference{TFhirProcedure}(this, 'MedicationDispense', 'partOf', elem.partOfList[i], false, i);{x.d3}
  ComposeCode(this, 'MedicationDispense', 'status', elem.statusElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and (elem.statusReason is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'MedicationDispense', 'statusReasonCodeableConcept', TFhirCodeableConcept(elem.statusReason), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.statusReason is TFhirReference) {2} then
    ComposeReference(this, 'MedicationDispense', 'statusReasonReference', TFhirReference(elem.statusReason), false,-1);{x.d8}
  if (SummaryOption in [soFull, soData]) and doCompose('category') then
    ComposeCodeableConcept(this, 'MedicationDispense', 'category', elem.categoryElement, false, -1);{x.2f}
  if (elem.medication is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'MedicationDispense', 'medicationCodeableConcept', TFhirCodeableConcept(elem.medication), false, -1){x.d9}
  else if (elem.medication is TFhirReference) {2} then
    ComposeReference(this, 'MedicationDispense', 'medicationReference', TFhirReference(elem.medication), false,-1);{x.d8}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{TFhirPatient}(this, 'MedicationDispense', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('context') then
    ComposeReference{TFhirEncounter}(this, 'MedicationDispense', 'context', elem.contextElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('supportingInformation') then
    for i := 0 to elem.supportingInformationList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'MedicationDispense', 'supportingInformation', elem.supportingInformationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('performer') then
    for i := 0 to elem.performerList.Count - 1 do
      ComposeMedicationDispensePerformer(this, 'MedicationDispense', 'performer', elem.performerList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('location') then
    ComposeReference{TFhirLocation}(this, 'MedicationDispense', 'location', elem.locationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('authorizingPrescription') then
    for i := 0 to elem.authorizingPrescriptionList.Count - 1 do
      ComposeReference{TFhirMedicationRequest}(this, 'MedicationDispense', 'authorizingPrescription', elem.authorizingPrescriptionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('type_') then
    ComposeCodeableConcept(this, 'MedicationDispense', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('quantity') then
    ComposeQuantity(this, 'MedicationDispense', 'quantity', elem.quantityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('daysSupply') then
    ComposeQuantity(this, 'MedicationDispense', 'daysSupply', elem.daysSupplyElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('whenPrepared') then
    ComposeDateTime(this, 'MedicationDispense', 'whenPrepared', elem.whenPreparedElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('whenHandedOver') then
    ComposeDateTime(this, 'MedicationDispense', 'whenHandedOver', elem.whenHandedOverElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('destination') then
    ComposeReference{TFhirLocation}(this, 'MedicationDispense', 'destination', elem.destinationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('receiver') then
    for i := 0 to elem.receiverList.Count - 1 do
      ComposeReference{TFhirPatient}(this, 'MedicationDispense', 'receiver', elem.receiverList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'MedicationDispense', 'note', elem.noteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('dosageInstruction') then
    for i := 0 to elem.dosageInstructionList.Count - 1 do
      ComposeDosage(this, 'MedicationDispense', 'dosageInstruction', elem.dosageInstructionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('substitution') then
    ComposeMedicationDispenseSubstitution(this, 'MedicationDispense', 'substitution', elem.substitutionElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('detectedIssue') then
    for i := 0 to elem.detectedIssueList.Count - 1 do
      ComposeReference{TFhirDetectedIssue}(this, 'MedicationDispense', 'detectedIssue', elem.detectedIssueList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('eventHistory') then
    for i := 0 to elem.eventHistoryList.Count - 1 do
      ComposeReference{TFhirProvenance}(this, 'MedicationDispense', 'eventHistory', elem.eventHistoryList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_MEDICATIONDISPENSE}
{$IFDEF FHIR_MEDICATIONKNOWLEDGE}
function TFHIRTurtleParser.ParseMedicationKnowledgeRelatedMedicationKnowledge(obj : TTurtleComplex) : TFhirMedicationKnowledgeRelatedMedicationKnowledge;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationKnowledgeRelatedMedicationKnowledge.create;
  try
    ParseMedicationKnowledgeRelatedMedicationKnowledgeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationKnowledgeRelatedMedicationKnowledgeProperties(obj : TTurtleComplex; result : TFhirMedicationKnowledgeRelatedMedicationKnowledge);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationKnowledge.relatedMedicationKnowledge.type'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/MedicationKnowledge.relatedMedicationKnowledge.reference') do
      result.referenceList.Add(parseReference{TFhirMedicationKnowledge}(item));
end;

procedure TFHIRTurtleComposer.ComposeMedicationKnowledgeRelatedMedicationKnowledge(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationKnowledgeRelatedMedicationKnowledge; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationKnowledgeRelatedMedicationKnowledge'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'MedicationKnowledge.relatedMedicationKnowledge', 'type', elem.type_Element, false, -1);{x.2f}
  for i := 0 to elem.referenceList.Count - 1 do
      ComposeReference{TFhirMedicationKnowledge}(this, 'MedicationKnowledge.relatedMedicationKnowledge', 'reference', elem.referenceList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseMedicationKnowledgeMonograph(obj : TTurtleComplex) : TFhirMedicationKnowledgeMonograph;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationKnowledgeMonograph.create;
  try
    ParseMedicationKnowledgeMonographProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationKnowledgeMonographProperties(obj : TTurtleComplex; result : TFhirMedicationKnowledgeMonograph);
begin
    ParseBackboneElementProperties(obj, result);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationKnowledge.monograph.type'));{q3b}
    result.source := ParseReference{TFhirDocumentReference}(obj.complex('http://hl7.org/fhir/MedicationKnowledge.monograph.source'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeMedicationKnowledgeMonograph(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationKnowledgeMonograph; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationKnowledgeMonograph'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'MedicationKnowledge.monograph', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirDocumentReference}(this, 'MedicationKnowledge.monograph', 'source', elem.sourceElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseMedicationKnowledgeIngredient(obj : TTurtleComplex) : TFhirMedicationKnowledgeIngredient;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationKnowledgeIngredient.create;
  try
    ParseMedicationKnowledgeIngredientProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationKnowledgeIngredientProperties(obj : TTurtleComplex; result : TFhirMedicationKnowledgeIngredient);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    if obj.has('http://hl7.org/fhir/MedicationKnowledge.ingredient.itemCodeableConcept', item) then
      result.item := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/MedicationKnowledge.ingredient.itemReference', item) {a3} then
      result.item := ParseReference(item);
    result.isActiveElement := ParseBoolean(obj.complex('http://hl7.org/fhir/MedicationKnowledge.ingredient.isActive'));{q1}
    result.strength := ParseRatio(obj.complex('http://hl7.org/fhir/MedicationKnowledge.ingredient.strength'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeMedicationKnowledgeIngredient(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationKnowledgeIngredient; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationKnowledgeIngredient'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (elem.item is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'MedicationKnowledge.ingredient', 'itemCodeableConcept', TFhirCodeableConcept(elem.item), false, -1){x.d9}
  else if (elem.item is TFhirReference) {2} then
    ComposeReference(this, 'MedicationKnowledge.ingredient', 'itemReference', TFhirReference(elem.item), false,-1);{x.d8}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'MedicationKnowledge.ingredient', 'isActive', elem.isActiveElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeRatio(this, 'MedicationKnowledge.ingredient', 'strength', elem.strengthElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseMedicationKnowledgeCost(obj : TTurtleComplex) : TFhirMedicationKnowledgeCost;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationKnowledgeCost.create;
  try
    ParseMedicationKnowledgeCostProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationKnowledgeCostProperties(obj : TTurtleComplex; result : TFhirMedicationKnowledgeCost);
begin
    ParseBackboneElementProperties(obj, result);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationKnowledge.cost.type'));{q3b}
    result.sourceElement := ParseString(obj.complex('http://hl7.org/fhir/MedicationKnowledge.cost.source'));{q1}
    result.cost := ParseMoney(obj.complex('http://hl7.org/fhir/MedicationKnowledge.cost.cost'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeMedicationKnowledgeCost(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationKnowledgeCost; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationKnowledgeCost'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'MedicationKnowledge.cost', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'MedicationKnowledge.cost', 'source', elem.sourceElement, false, -1);{x.2ea}
  ComposeMoney(this, 'MedicationKnowledge.cost', 'cost', elem.costElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseMedicationKnowledgeMonitoringProgram(obj : TTurtleComplex) : TFhirMedicationKnowledgeMonitoringProgram;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationKnowledgeMonitoringProgram.create;
  try
    ParseMedicationKnowledgeMonitoringProgramProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationKnowledgeMonitoringProgramProperties(obj : TTurtleComplex; result : TFhirMedicationKnowledgeMonitoringProgram);
begin
    ParseBackboneElementProperties(obj, result);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationKnowledge.monitoringProgram.type'));{q3b}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/MedicationKnowledge.monitoringProgram.name'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeMedicationKnowledgeMonitoringProgram(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationKnowledgeMonitoringProgram; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationKnowledgeMonitoringProgram'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'MedicationKnowledge.monitoringProgram', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'MedicationKnowledge.monitoringProgram', 'name', elem.nameElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseMedicationKnowledgeAdministrationGuidelines(obj : TTurtleComplex) : TFhirMedicationKnowledgeAdministrationGuidelines;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationKnowledgeAdministrationGuidelines.create;
  try
    ParseMedicationKnowledgeAdministrationGuidelinesProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationKnowledgeAdministrationGuidelinesProperties(obj : TTurtleComplex; result : TFhirMedicationKnowledgeAdministrationGuidelines);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/MedicationKnowledge.administrationGuidelines.dosage') do
      result.dosageList.Add(parseMedicationKnowledgeAdministrationGuidelinesDosage(item));
    if obj.has('http://hl7.org/fhir/MedicationKnowledge.administrationGuidelines.indicationCodeableConcept', item) then
      result.indication := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/MedicationKnowledge.administrationGuidelines.indicationReference', item) {a3} then
      result.indication := ParseReference(item);
    for item in obj.complexes('http://hl7.org/fhir/MedicationKnowledge.administrationGuidelines.patientCharacteristics') do
      result.patientCharacteristicsList.Add(parseMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics(item));
end;

procedure TFHIRTurtleComposer.ComposeMedicationKnowledgeAdministrationGuidelines(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationKnowledgeAdministrationGuidelines; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationKnowledgeAdministrationGuidelines'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.dosageList.Count - 1 do
      ComposeMedicationKnowledgeAdministrationGuidelinesDosage(this, 'MedicationKnowledge.administrationGuidelines', 'dosage', elem.dosageList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and (elem.indication is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'MedicationKnowledge.administrationGuidelines', 'indicationCodeableConcept', TFhirCodeableConcept(elem.indication), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.indication is TFhirReference) {2} then
    ComposeReference(this, 'MedicationKnowledge.administrationGuidelines', 'indicationReference', TFhirReference(elem.indication), false,-1);{x.d8}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.patientCharacteristicsList.Count - 1 do
      ComposeMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics(this, 'MedicationKnowledge.administrationGuidelines', 'patientCharacteristics', elem.patientCharacteristicsList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseMedicationKnowledgeAdministrationGuidelinesDosage(obj : TTurtleComplex) : TFhirMedicationKnowledgeAdministrationGuidelinesDosage;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationKnowledgeAdministrationGuidelinesDosage.create;
  try
    ParseMedicationKnowledgeAdministrationGuidelinesDosageProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationKnowledgeAdministrationGuidelinesDosageProperties(obj : TTurtleComplex; result : TFhirMedicationKnowledgeAdministrationGuidelinesDosage);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationKnowledge.administrationGuidelines.dosage.type'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/MedicationKnowledge.administrationGuidelines.dosage.dosage') do
      result.dosageList.Add(parseDosage(item));
end;

procedure TFHIRTurtleComposer.ComposeMedicationKnowledgeAdministrationGuidelinesDosage(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationKnowledgeAdministrationGuidelinesDosage; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationKnowledgeAdministrationGuidelinesDosage'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'MedicationKnowledge.administrationGuidelines.dosage', 'type', elem.type_Element, false, -1);{x.2f}
  for i := 0 to elem.dosageList.Count - 1 do
      ComposeDosage(this, 'MedicationKnowledge.administrationGuidelines.dosage', 'dosage', elem.dosageList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics(obj : TTurtleComplex) : TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics.create;
  try
    ParseMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsProperties(obj : TTurtleComplex; result : TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    if obj.has('http://hl7.org/fhir/MedicationKnowledge.administrationGuidelines.patientCharacteristics.characteristicCodeableConcept', item) then
      result.characteristic := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/MedicationKnowledge.administrationGuidelines.patientCharacteristics.characteristicQuantity', item) then
      result.characteristic := parseQuantity(item);
    for item in obj.complexes('http://hl7.org/fhir/MedicationKnowledge.administrationGuidelines.patientCharacteristics.value') do
      result.valueList.Add(parseString(item));
end;

procedure TFHIRTurtleComposer.ComposeMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationKnowledgeAdministrationGuidelinesPatientCharacteristics'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (elem.characteristic is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'MedicationKnowledge.administrationGuidelines.patientCharacteristics', 'characteristicCodeableConcept', TFhirCodeableConcept(elem.characteristic), false, -1){x.d9}
  else if (elem.characteristic is TFhirQuantity) {6} then
    ComposeQuantity(this, 'MedicationKnowledge.administrationGuidelines.patientCharacteristics', 'characteristicQuantity', TFhirQuantity(elem.characteristic), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.valueList.Count - 1 do
      ComposeString(this, 'MedicationKnowledge.administrationGuidelines.patientCharacteristics', 'value', elem.valueList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseMedicationKnowledgeMedicineClassification(obj : TTurtleComplex) : TFhirMedicationKnowledgeMedicineClassification;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationKnowledgeMedicineClassification.create;
  try
    ParseMedicationKnowledgeMedicineClassificationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationKnowledgeMedicineClassificationProperties(obj : TTurtleComplex; result : TFhirMedicationKnowledgeMedicineClassification);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationKnowledge.medicineClassification.type'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/MedicationKnowledge.medicineClassification.classification') do
      result.classificationList.Add(parseCodeableConcept(item));
end;

procedure TFHIRTurtleComposer.ComposeMedicationKnowledgeMedicineClassification(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationKnowledgeMedicineClassification; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationKnowledgeMedicineClassification'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'MedicationKnowledge.medicineClassification', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.classificationList.Count - 1 do
      ComposeCodeableConcept(this, 'MedicationKnowledge.medicineClassification', 'classification', elem.classificationList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseMedicationKnowledgePackaging(obj : TTurtleComplex) : TFhirMedicationKnowledgePackaging;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationKnowledgePackaging.create;
  try
    ParseMedicationKnowledgePackagingProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationKnowledgePackagingProperties(obj : TTurtleComplex; result : TFhirMedicationKnowledgePackaging);
begin
    ParseBackboneElementProperties(obj, result);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationKnowledge.packaging.type'));{q3b}
    result.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/MedicationKnowledge.packaging.quantity'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeMedicationKnowledgePackaging(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationKnowledgePackaging; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationKnowledgePackaging'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'MedicationKnowledge.packaging', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'MedicationKnowledge.packaging', 'quantity', elem.quantityElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseMedicationKnowledgeDrugCharacteristic(obj : TTurtleComplex) : TFhirMedicationKnowledgeDrugCharacteristic;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationKnowledgeDrugCharacteristic.create;
  try
    ParseMedicationKnowledgeDrugCharacteristicProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationKnowledgeDrugCharacteristicProperties(obj : TTurtleComplex; result : TFhirMedicationKnowledgeDrugCharacteristic);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationKnowledge.drugCharacteristic.type'));{q3b}
    if obj.has('http://hl7.org/fhir/MedicationKnowledge.drugCharacteristic.valueCodeableConcept', item) then
      result.value := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/MedicationKnowledge.drugCharacteristic.valueQuantity', item) then
      result.value := parseQuantity(item);
    if obj.has('http://hl7.org/fhir/MedicationKnowledge.drugCharacteristic.valueString', item) then
      result.value := parseString(item);
    if obj.has('http://hl7.org/fhir/MedicationKnowledge.drugCharacteristic.valueBase64Binary', item) then
      result.value := parseBase64Binary(item);
end;

procedure TFHIRTurtleComposer.ComposeMedicationKnowledgeDrugCharacteristic(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationKnowledgeDrugCharacteristic; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationKnowledgeDrugCharacteristic'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'MedicationKnowledge.drugCharacteristic', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and (elem.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'MedicationKnowledge.drugCharacteristic', 'valueCodeableConcept', TFhirCodeableConcept(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'MedicationKnowledge.drugCharacteristic', 'valueQuantity', TFhirQuantity(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirString) {6} then
    ComposeString(this, 'MedicationKnowledge.drugCharacteristic', 'valueString', TFhirString(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirBase64Binary) {6} then
    ComposeBase64Binary(this, 'MedicationKnowledge.drugCharacteristic', 'valueBase64Binary', TFhirBase64Binary(elem.value), false, -1);{x.d9}
end;

function TFHIRTurtleParser.ParseMedicationKnowledgeRegulatory(obj : TTurtleComplex) : TFhirMedicationKnowledgeRegulatory;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationKnowledgeRegulatory.create;
  try
    ParseMedicationKnowledgeRegulatoryProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationKnowledgeRegulatoryProperties(obj : TTurtleComplex; result : TFhirMedicationKnowledgeRegulatory);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.regulatoryAuthority := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/MedicationKnowledge.regulatory.regulatoryAuthority'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/MedicationKnowledge.regulatory.substitution') do
      result.substitutionList.Add(parseMedicationKnowledgeRegulatorySubstitution(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationKnowledge.regulatory.schedule') do
      result.scheduleList.Add(parseMedicationKnowledgeRegulatorySchedule(item));
    result.maxDispense := ParseMedicationKnowledgeRegulatoryMaxDispense(obj.complex('http://hl7.org/fhir/MedicationKnowledge.regulatory.maxDispense'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeMedicationKnowledgeRegulatory(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationKnowledgeRegulatory; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationKnowledgeRegulatory'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeReference{TFhirOrganization}(this, 'MedicationKnowledge.regulatory', 'regulatoryAuthority', elem.regulatoryAuthorityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.substitutionList.Count - 1 do
      ComposeMedicationKnowledgeRegulatorySubstitution(this, 'MedicationKnowledge.regulatory', 'substitution', elem.substitutionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.scheduleList.Count - 1 do
      ComposeMedicationKnowledgeRegulatorySchedule(this, 'MedicationKnowledge.regulatory', 'schedule', elem.scheduleList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeMedicationKnowledgeRegulatoryMaxDispense(this, 'MedicationKnowledge.regulatory', 'maxDispense', elem.maxDispenseElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseMedicationKnowledgeRegulatorySubstitution(obj : TTurtleComplex) : TFhirMedicationKnowledgeRegulatorySubstitution;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationKnowledgeRegulatorySubstitution.create;
  try
    ParseMedicationKnowledgeRegulatorySubstitutionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationKnowledgeRegulatorySubstitutionProperties(obj : TTurtleComplex; result : TFhirMedicationKnowledgeRegulatorySubstitution);
begin
    ParseBackboneElementProperties(obj, result);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationKnowledge.regulatory.substitution.type'));{q3b}
    result.allowedElement := ParseBoolean(obj.complex('http://hl7.org/fhir/MedicationKnowledge.regulatory.substitution.allowed'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeMedicationKnowledgeRegulatorySubstitution(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationKnowledgeRegulatorySubstitution; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationKnowledgeRegulatorySubstitution'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'MedicationKnowledge.regulatory.substitution', 'type', elem.type_Element, false, -1);{x.2f}
  ComposeBoolean(this, 'MedicationKnowledge.regulatory.substitution', 'allowed', elem.allowedElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseMedicationKnowledgeRegulatorySchedule(obj : TTurtleComplex) : TFhirMedicationKnowledgeRegulatorySchedule;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationKnowledgeRegulatorySchedule.create;
  try
    ParseMedicationKnowledgeRegulatoryScheduleProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationKnowledgeRegulatoryScheduleProperties(obj : TTurtleComplex; result : TFhirMedicationKnowledgeRegulatorySchedule);
begin
    ParseBackboneElementProperties(obj, result);
    result.schedule := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationKnowledge.regulatory.schedule.schedule'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeMedicationKnowledgeRegulatorySchedule(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationKnowledgeRegulatorySchedule; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationKnowledgeRegulatorySchedule'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'MedicationKnowledge.regulatory.schedule', 'schedule', elem.scheduleElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseMedicationKnowledgeRegulatoryMaxDispense(obj : TTurtleComplex) : TFhirMedicationKnowledgeRegulatoryMaxDispense;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationKnowledgeRegulatoryMaxDispense.create;
  try
    ParseMedicationKnowledgeRegulatoryMaxDispenseProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationKnowledgeRegulatoryMaxDispenseProperties(obj : TTurtleComplex; result : TFhirMedicationKnowledgeRegulatoryMaxDispense);
begin
    ParseBackboneElementProperties(obj, result);
    result.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/MedicationKnowledge.regulatory.maxDispense.quantity'));{q3b}
    result.period := ParseDuration(obj.complex('http://hl7.org/fhir/MedicationKnowledge.regulatory.maxDispense.period'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeMedicationKnowledgeRegulatoryMaxDispense(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationKnowledgeRegulatoryMaxDispense; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationKnowledgeRegulatoryMaxDispense'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeQuantity(this, 'MedicationKnowledge.regulatory.maxDispense', 'quantity', elem.quantityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeDuration(this, 'MedicationKnowledge.regulatory.maxDispense', 'period', elem.periodElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseMedicationKnowledgeKinetics(obj : TTurtleComplex) : TFhirMedicationKnowledgeKinetics;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationKnowledgeKinetics.create;
  try
    ParseMedicationKnowledgeKineticsProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationKnowledgeKineticsProperties(obj : TTurtleComplex; result : TFhirMedicationKnowledgeKinetics);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/MedicationKnowledge.kinetics.areaUnderCurve') do
      result.areaUnderCurveList.Add(parseQuantity(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationKnowledge.kinetics.lethalDose50') do
      result.lethalDose50List.Add(parseQuantity(item));
    result.halfLifePeriod := ParseDuration(obj.complex('http://hl7.org/fhir/MedicationKnowledge.kinetics.halfLifePeriod'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeMedicationKnowledgeKinetics(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationKnowledgeKinetics; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationKnowledgeKinetics'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.areaUnderCurveList.Count - 1 do
      ComposeQuantity(this, 'MedicationKnowledge.kinetics', 'areaUnderCurve', elem.areaUnderCurveList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.lethalDose50List.Count - 1 do
      ComposeQuantity(this, 'MedicationKnowledge.kinetics', 'lethalDose50', elem.lethalDose50List[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeDuration(this, 'MedicationKnowledge.kinetics', 'halfLifePeriod', elem.halfLifePeriodElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseMedicationKnowledge(obj : TTurtleComplex) : TFhirMedicationKnowledge;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationKnowledge.create;
  try
    ParseMedicationKnowledgeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationKnowledgeProperties(obj : TTurtleComplex; result : TFhirMedicationKnowledge);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationKnowledge.code'));{q3b}
    result.statusElement := ParseCode(obj.complex('http://hl7.org/fhir/MedicationKnowledge.status'));{q1}
    result.manufacturer := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/MedicationKnowledge.manufacturer'));{q3b}
    result.doseForm := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationKnowledge.doseForm'));{q3b}
    result.amount := ParseQuantity(obj.complex('http://hl7.org/fhir/MedicationKnowledge.amount'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/MedicationKnowledge.synonym') do
      result.synonymList.Add(parseString(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationKnowledge.relatedMedicationKnowledge') do
      result.relatedMedicationKnowledgeList.Add(parseMedicationKnowledgeRelatedMedicationKnowledge(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationKnowledge.associatedMedication') do
      result.associatedMedicationList.Add(parseReference{TFhirMedication}(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationKnowledge.productType') do
      result.productTypeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationKnowledge.monograph') do
      result.monographList.Add(parseMedicationKnowledgeMonograph(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationKnowledge.ingredient') do
      result.ingredientList.Add(parseMedicationKnowledgeIngredient(item));
    result.preparationInstructionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/MedicationKnowledge.preparationInstruction'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/MedicationKnowledge.intendedRoute') do
      result.intendedRouteList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationKnowledge.cost') do
      result.costList.Add(parseMedicationKnowledgeCost(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationKnowledge.monitoringProgram') do
      result.monitoringProgramList.Add(parseMedicationKnowledgeMonitoringProgram(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationKnowledge.administrationGuidelines') do
      result.administrationGuidelinesList.Add(parseMedicationKnowledgeAdministrationGuidelines(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationKnowledge.medicineClassification') do
      result.medicineClassificationList.Add(parseMedicationKnowledgeMedicineClassification(item));
    result.packaging := ParseMedicationKnowledgePackaging(obj.complex('http://hl7.org/fhir/MedicationKnowledge.packaging'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/MedicationKnowledge.drugCharacteristic') do
      result.drugCharacteristicList.Add(parseMedicationKnowledgeDrugCharacteristic(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationKnowledge.contraindication') do
      result.contraindicationList.Add(parseReference{TFhirDetectedIssue}(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationKnowledge.regulatory') do
      result.regulatoryList.Add(parseMedicationKnowledgeRegulatory(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationKnowledge.kinetics') do
      result.kineticsList.Add(parseMedicationKnowledgeKinetics(item));
end;

procedure TFHIRTurtleComposer.ComposeMedicationKnowledge(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationKnowledge; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationKnowledge'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') then
    ComposeCodeableConcept(this, 'MedicationKnowledge', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeCode(this, 'MedicationKnowledge', 'status', elem.statusElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('manufacturer') then
    ComposeReference{TFhirOrganization}(this, 'MedicationKnowledge', 'manufacturer', elem.manufacturerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('doseForm') then
    ComposeCodeableConcept(this, 'MedicationKnowledge', 'doseForm', elem.doseFormElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('amount') then
    ComposeQuantity(this, 'MedicationKnowledge', 'amount', elem.amountElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('synonym') then
    for i := 0 to elem.synonymList.Count - 1 do
      ComposeString(this, 'MedicationKnowledge', 'synonym', elem.synonymList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('relatedMedicationKnowledge') then
    for i := 0 to elem.relatedMedicationKnowledgeList.Count - 1 do
      ComposeMedicationKnowledgeRelatedMedicationKnowledge(this, 'MedicationKnowledge', 'relatedMedicationKnowledge', elem.relatedMedicationKnowledgeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('associatedMedication') then
    for i := 0 to elem.associatedMedicationList.Count - 1 do
      ComposeReference{TFhirMedication}(this, 'MedicationKnowledge', 'associatedMedication', elem.associatedMedicationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('productType') then
    for i := 0 to elem.productTypeList.Count - 1 do
      ComposeCodeableConcept(this, 'MedicationKnowledge', 'productType', elem.productTypeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('monograph') then
    for i := 0 to elem.monographList.Count - 1 do
      ComposeMedicationKnowledgeMonograph(this, 'MedicationKnowledge', 'monograph', elem.monographList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('ingredient') then
    for i := 0 to elem.ingredientList.Count - 1 do
      ComposeMedicationKnowledgeIngredient(this, 'MedicationKnowledge', 'ingredient', elem.ingredientList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('preparationInstruction') then
    ComposeMarkdown(this, 'MedicationKnowledge', 'preparationInstruction', elem.preparationInstructionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('intendedRoute') then
    for i := 0 to elem.intendedRouteList.Count - 1 do
      ComposeCodeableConcept(this, 'MedicationKnowledge', 'intendedRoute', elem.intendedRouteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('cost') then
    for i := 0 to elem.costList.Count - 1 do
      ComposeMedicationKnowledgeCost(this, 'MedicationKnowledge', 'cost', elem.costList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('monitoringProgram') then
    for i := 0 to elem.monitoringProgramList.Count - 1 do
      ComposeMedicationKnowledgeMonitoringProgram(this, 'MedicationKnowledge', 'monitoringProgram', elem.monitoringProgramList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('administrationGuidelines') then
    for i := 0 to elem.administrationGuidelinesList.Count - 1 do
      ComposeMedicationKnowledgeAdministrationGuidelines(this, 'MedicationKnowledge', 'administrationGuidelines', elem.administrationGuidelinesList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('medicineClassification') then
    for i := 0 to elem.medicineClassificationList.Count - 1 do
      ComposeMedicationKnowledgeMedicineClassification(this, 'MedicationKnowledge', 'medicineClassification', elem.medicineClassificationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('packaging') then
    ComposeMedicationKnowledgePackaging(this, 'MedicationKnowledge', 'packaging', elem.packagingElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('drugCharacteristic') then
    for i := 0 to elem.drugCharacteristicList.Count - 1 do
      ComposeMedicationKnowledgeDrugCharacteristic(this, 'MedicationKnowledge', 'drugCharacteristic', elem.drugCharacteristicList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('contraindication') then
    for i := 0 to elem.contraindicationList.Count - 1 do
      ComposeReference{TFhirDetectedIssue}(this, 'MedicationKnowledge', 'contraindication', elem.contraindicationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('regulatory') then
    for i := 0 to elem.regulatoryList.Count - 1 do
      ComposeMedicationKnowledgeRegulatory(this, 'MedicationKnowledge', 'regulatory', elem.regulatoryList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('kinetics') then
    for i := 0 to elem.kineticsList.Count - 1 do
      ComposeMedicationKnowledgeKinetics(this, 'MedicationKnowledge', 'kinetics', elem.kineticsList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_MEDICATIONKNOWLEDGE}
{$IFDEF FHIR_MEDICATIONREQUEST}
function TFHIRTurtleParser.ParseMedicationRequestDispenseRequest(obj : TTurtleComplex) : TFhirMedicationRequestDispenseRequest;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationRequestDispenseRequest.create;
  try
    ParseMedicationRequestDispenseRequestProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationRequestDispenseRequestProperties(obj : TTurtleComplex; result : TFhirMedicationRequestDispenseRequest);
begin
    ParseBackboneElementProperties(obj, result);
    result.initialFill := ParseMedicationRequestDispenseRequestInitialFill(obj.complex('http://hl7.org/fhir/MedicationRequest.dispenseRequest.initialFill'));{q3b}
    result.dispenseInterval := ParseDuration(obj.complex('http://hl7.org/fhir/MedicationRequest.dispenseRequest.dispenseInterval'));{q3b}
    result.validityPeriod := ParsePeriod(obj.complex('http://hl7.org/fhir/MedicationRequest.dispenseRequest.validityPeriod'));{q3b}
    result.numberOfRepeatsAllowedElement := ParseUnsignedInt(obj.complex('http://hl7.org/fhir/MedicationRequest.dispenseRequest.numberOfRepeatsAllowed'));{q1}
    result.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/MedicationRequest.dispenseRequest.quantity'));{q3b}
    result.expectedSupplyDuration := ParseDuration(obj.complex('http://hl7.org/fhir/MedicationRequest.dispenseRequest.expectedSupplyDuration'));{q3b}
    result.performer := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/MedicationRequest.dispenseRequest.performer'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeMedicationRequestDispenseRequest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationRequestDispenseRequest; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationRequestDispenseRequest'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeMedicationRequestDispenseRequestInitialFill(this, 'MedicationRequest.dispenseRequest', 'initialFill', elem.initialFillElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeDuration(this, 'MedicationRequest.dispenseRequest', 'dispenseInterval', elem.dispenseIntervalElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'MedicationRequest.dispenseRequest', 'validityPeriod', elem.validityPeriodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeUnsignedInt(this, 'MedicationRequest.dispenseRequest', 'numberOfRepeatsAllowed', elem.numberOfRepeatsAllowedElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'MedicationRequest.dispenseRequest', 'quantity', elem.quantityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeDuration(this, 'MedicationRequest.dispenseRequest', 'expectedSupplyDuration', elem.expectedSupplyDurationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(this, 'MedicationRequest.dispenseRequest', 'performer', elem.performerElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseMedicationRequestDispenseRequestInitialFill(obj : TTurtleComplex) : TFhirMedicationRequestDispenseRequestInitialFill;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationRequestDispenseRequestInitialFill.create;
  try
    ParseMedicationRequestDispenseRequestInitialFillProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationRequestDispenseRequestInitialFillProperties(obj : TTurtleComplex; result : TFhirMedicationRequestDispenseRequestInitialFill);
begin
    ParseBackboneElementProperties(obj, result);
    result.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/MedicationRequest.dispenseRequest.initialFill.quantity'));{q3b}
    result.duration := ParseDuration(obj.complex('http://hl7.org/fhir/MedicationRequest.dispenseRequest.initialFill.duration'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeMedicationRequestDispenseRequestInitialFill(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationRequestDispenseRequestInitialFill; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationRequestDispenseRequestInitialFill'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'MedicationRequest.dispenseRequest.initialFill', 'quantity', elem.quantityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeDuration(this, 'MedicationRequest.dispenseRequest.initialFill', 'duration', elem.durationElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseMedicationRequestSubstitution(obj : TTurtleComplex) : TFhirMedicationRequestSubstitution;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationRequestSubstitution.create;
  try
    ParseMedicationRequestSubstitutionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationRequestSubstitutionProperties(obj : TTurtleComplex; result : TFhirMedicationRequestSubstitution);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    if obj.has('http://hl7.org/fhir/MedicationRequest.substitution.allowedCodeableConcept', item) then
      result.allowed := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/MedicationRequest.substitution.allowedBoolean', item) then
      result.allowed := parseBoolean(item);
    result.reason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationRequest.substitution.reason'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeMedicationRequestSubstitution(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationRequestSubstitution; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationRequestSubstitution'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (elem.allowed is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'MedicationRequest.substitution', 'allowedCodeableConcept', TFhirCodeableConcept(elem.allowed), false, -1){x.d9}
  else if (elem.allowed is TFhirBoolean) {6} then
    ComposeBoolean(this, 'MedicationRequest.substitution', 'allowedBoolean', TFhirBoolean(elem.allowed), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'MedicationRequest.substitution', 'reason', elem.reasonElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseMedicationRequest(obj : TTurtleComplex) : TFhirMedicationRequest;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationRequest.create;
  try
    ParseMedicationRequestProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationRequestProperties(obj : TTurtleComplex; result : TFhirMedicationRequest);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/MedicationRequest.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/MedicationRequest.status'), CODES_TFhirMedicationrequestStatusEnum, SYSTEMS_TFhirMedicationrequestStatusEnum);
    result.statusReason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationRequest.statusReason'));{q3b}
    result.intentElement := ParseEnum(obj.complex('http://hl7.org/fhir/MedicationRequest.intent'), CODES_TFhirMedicationrequestIntentEnum, SYSTEMS_TFhirMedicationrequestIntentEnum);
    for item in obj.complexes('http://hl7.org/fhir/MedicationRequest.category') do
      result.categoryList.Add(parseCodeableConcept(item));
    result.priorityElement := ParseEnum(obj.complex('http://hl7.org/fhir/MedicationRequest.priority'), CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum);
    result.doNotPerformElement := ParseBoolean(obj.complex('http://hl7.org/fhir/MedicationRequest.doNotPerform'));{q1}
    if obj.has('http://hl7.org/fhir/MedicationRequest.reportedReference', item) {a3} then
      result.reported := ParseReference(item);
    if obj.has('http://hl7.org/fhir/MedicationRequest.reportedBoolean', item) then
      result.reported := parseBoolean(item);
    if obj.has('http://hl7.org/fhir/MedicationRequest.medicationCodeableConcept', item) then
      result.medication := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/MedicationRequest.medicationReference', item) {a3} then
      result.medication := ParseReference(item);
    result.subject := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/MedicationRequest.subject'));{q3b}
    result.encounter := ParseReference{TFhirEncounter}(obj.complex('http://hl7.org/fhir/MedicationRequest.encounter'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/MedicationRequest.supportingInformation') do
      result.supportingInformationList.Add(parseReference{TFhirReference}(item));
    result.authoredOnElement := ParseDateTime(obj.complex('http://hl7.org/fhir/MedicationRequest.authoredOn'));{q1}
    result.requester := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/MedicationRequest.requester'));{q3b}
    result.performer := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/MedicationRequest.performer'));{q3b}
    result.performerType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationRequest.performerType'));{q3b}
    result.recorder := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/MedicationRequest.recorder'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/MedicationRequest.reasonCode') do
      result.reasonCodeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationRequest.reasonReference') do
      result.reasonReferenceList.Add(parseReference{TFhirCondition}(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationRequest.instantiatesCanonical') do
      result.instantiatesCanonicalList.Add(parseCanonical(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationRequest.instantiatesUri') do
      result.instantiatesUriList.Add(parseUri(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationRequest.basedOn') do
      result.basedOnList.Add(parseReference{TFhirCarePlan}(item));
    result.groupIdentifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/MedicationRequest.groupIdentifier'));{q3b}
    result.courseOfTherapyType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationRequest.courseOfTherapyType'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/MedicationRequest.insurance') do
      result.insuranceList.Add(parseReference{TFhirCoverage}(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationRequest.note') do
      result.noteList.Add(parseAnnotation(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationRequest.dosageInstruction') do
      result.dosageInstructionList.Add(parseDosage(item));
    result.dispenseRequest := ParseMedicationRequestDispenseRequest(obj.complex('http://hl7.org/fhir/MedicationRequest.dispenseRequest'));{q3b}
    result.substitution := ParseMedicationRequestSubstitution(obj.complex('http://hl7.org/fhir/MedicationRequest.substitution'));{q3b}
    result.priorPrescription := ParseReference{TFhirMedicationRequest}(obj.complex('http://hl7.org/fhir/MedicationRequest.priorPrescription'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/MedicationRequest.detectedIssue') do
      result.detectedIssueList.Add(parseReference{TFhirDetectedIssue}(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationRequest.eventHistory') do
      result.eventHistoryList.Add(parseReference{TFhirProvenance}(item));
end;

procedure TFHIRTurtleComposer.ComposeMedicationRequest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationRequest; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationRequest'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'MedicationRequest', 'identifier', elem.identifierList[i], false, i);{x.d3}
  ComposeEnum(this, 'MedicationRequest', 'status', elem.StatusElement, CODES_TFhirMedicationrequestStatusEnum, SYSTEMS_TFhirMedicationrequestStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('statusReason') then
    ComposeCodeableConcept(this, 'MedicationRequest', 'statusReason', elem.statusReasonElement, false, -1);{x.2f}
  ComposeEnum(this, 'MedicationRequest', 'intent', elem.IntentElement, CODES_TFhirMedicationrequestIntentEnum, SYSTEMS_TFhirMedicationrequestIntentEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('category') then
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(this, 'MedicationRequest', 'category', elem.categoryList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('priority') then
    ComposeEnum(this, 'MedicationRequest', 'priority', elem.PriorityElement, CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('doNotPerform') then
    ComposeBoolean(this, 'MedicationRequest', 'doNotPerform', elem.doNotPerformElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.reported is TFhirReference) {2} then
    ComposeReference(this, 'MedicationRequest', 'reportedReference', TFhirReference(elem.reported), false,-1){x.d8}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.reported is TFhirBoolean) {6} then
    ComposeBoolean(this, 'MedicationRequest', 'reportedBoolean', TFhirBoolean(elem.reported), false, -1);{x.d9}
  if (elem.medication is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'MedicationRequest', 'medicationCodeableConcept', TFhirCodeableConcept(elem.medication), false, -1){x.d9}
  else if (elem.medication is TFhirReference) {2} then
    ComposeReference(this, 'MedicationRequest', 'medicationReference', TFhirReference(elem.medication), false,-1);{x.d8}
  ComposeReference{TFhirPatient}(this, 'MedicationRequest', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(this, 'MedicationRequest', 'encounter', elem.encounterElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('supportingInformation') then
    for i := 0 to elem.supportingInformationList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'MedicationRequest', 'supportingInformation', elem.supportingInformationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('authoredOn') then
    ComposeDateTime(this, 'MedicationRequest', 'authoredOn', elem.authoredOnElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requester') then
    ComposeReference{TFhirPractitioner}(this, 'MedicationRequest', 'requester', elem.requesterElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('performer') then
    ComposeReference{TFhirPractitioner}(this, 'MedicationRequest', 'performer', elem.performerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('performerType') then
    ComposeCodeableConcept(this, 'MedicationRequest', 'performerType', elem.performerTypeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('recorder') then
    ComposeReference{TFhirPractitioner}(this, 'MedicationRequest', 'recorder', elem.recorderElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('reasonCode') then
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'MedicationRequest', 'reasonCode', elem.reasonCodeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('reasonReference') then
    for i := 0 to elem.reasonReferenceList.Count - 1 do
      ComposeReference{TFhirCondition}(this, 'MedicationRequest', 'reasonReference', elem.reasonReferenceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('instantiatesCanonical') then
    for i := 0 to elem.instantiatesCanonicalList.Count - 1 do
      ComposeCanonical(this, 'MedicationRequest', 'instantiatesCanonical', elem.instantiatesCanonicalList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('instantiatesUri') then
    for i := 0 to elem.instantiatesUriList.Count - 1 do
      ComposeUri(this, 'MedicationRequest', 'instantiatesUri', elem.instantiatesUriList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('basedOn') then
    for i := 0 to elem.basedOnList.Count - 1 do
      ComposeReference{TFhirCarePlan}(this, 'MedicationRequest', 'basedOn', elem.basedOnList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('groupIdentifier') then
    ComposeIdentifier(this, 'MedicationRequest', 'groupIdentifier', elem.groupIdentifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('courseOfTherapyType') then
    ComposeCodeableConcept(this, 'MedicationRequest', 'courseOfTherapyType', elem.courseOfTherapyTypeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('insurance') then
    for i := 0 to elem.insuranceList.Count - 1 do
      ComposeReference{TFhirCoverage}(this, 'MedicationRequest', 'insurance', elem.insuranceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'MedicationRequest', 'note', elem.noteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('dosageInstruction') then
    for i := 0 to elem.dosageInstructionList.Count - 1 do
      ComposeDosage(this, 'MedicationRequest', 'dosageInstruction', elem.dosageInstructionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('dispenseRequest') then
    ComposeMedicationRequestDispenseRequest(this, 'MedicationRequest', 'dispenseRequest', elem.dispenseRequestElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('substitution') then
    ComposeMedicationRequestSubstitution(this, 'MedicationRequest', 'substitution', elem.substitutionElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('priorPrescription') then
    ComposeReference{TFhirMedicationRequest}(this, 'MedicationRequest', 'priorPrescription', elem.priorPrescriptionElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('detectedIssue') then
    for i := 0 to elem.detectedIssueList.Count - 1 do
      ComposeReference{TFhirDetectedIssue}(this, 'MedicationRequest', 'detectedIssue', elem.detectedIssueList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('eventHistory') then
    for i := 0 to elem.eventHistoryList.Count - 1 do
      ComposeReference{TFhirProvenance}(this, 'MedicationRequest', 'eventHistory', elem.eventHistoryList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_MEDICATIONREQUEST}
{$IFDEF FHIR_MEDICATIONSTATEMENT}
function TFHIRTurtleParser.ParseMedicationStatement(obj : TTurtleComplex) : TFhirMedicationStatement;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicationStatement.create;
  try
    ParseMedicationStatementProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicationStatementProperties(obj : TTurtleComplex; result : TFhirMedicationStatement);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/MedicationStatement.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationStatement.basedOn') do
      result.basedOnList.Add(parseReference{TFhirMedicationRequest}(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationStatement.partOf') do
      result.partOfList.Add(parseReference{TFhirMedicationAdministration}(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/MedicationStatement.status'), CODES_TFhirMedicationStatementStatusEnum, SYSTEMS_TFhirMedicationStatementStatusEnum);
    for item in obj.complexes('http://hl7.org/fhir/MedicationStatement.statusReason') do
      result.statusReasonList.Add(parseCodeableConcept(item));
    result.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicationStatement.category'));{q3b}
    if obj.has('http://hl7.org/fhir/MedicationStatement.medicationCodeableConcept', item) then
      result.medication := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/MedicationStatement.medicationReference', item) {a3} then
      result.medication := ParseReference(item);
    result.subject := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/MedicationStatement.subject'));{q3b}
    result.context := ParseReference{TFhirEncounter}(obj.complex('http://hl7.org/fhir/MedicationStatement.context'));{q3b}
    if obj.has('http://hl7.org/fhir/MedicationStatement.effectivePeriod', item) then
      result.effective := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/MedicationStatement.effectiveDateTime', item) then
      result.effective := parseDateTime(item);
    result.dateAssertedElement := ParseDateTime(obj.complex('http://hl7.org/fhir/MedicationStatement.dateAsserted'));{q1}
    result.informationSource := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/MedicationStatement.informationSource'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/MedicationStatement.derivedFrom') do
      result.derivedFromList.Add(parseReference{TFhirReference}(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationStatement.reasonCode') do
      result.reasonCodeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationStatement.reasonReference') do
      result.reasonReferenceList.Add(parseReference{TFhirCondition}(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationStatement.note') do
      result.noteList.Add(parseAnnotation(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicationStatement.dosage') do
      result.dosageList.Add(parseDosage(item));
end;

procedure TFHIRTurtleComposer.ComposeMedicationStatement(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicationStatement; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicationStatement'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'MedicationStatement', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('basedOn') then
    for i := 0 to elem.basedOnList.Count - 1 do
      ComposeReference{TFhirMedicationRequest}(this, 'MedicationStatement', 'basedOn', elem.basedOnList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('partOf') then
    for i := 0 to elem.partOfList.Count - 1 do
      ComposeReference{TFhirMedicationAdministration}(this, 'MedicationStatement', 'partOf', elem.partOfList[i], false, i);{x.d3}
  ComposeEnum(this, 'MedicationStatement', 'status', elem.StatusElement, CODES_TFhirMedicationStatementStatusEnum, SYSTEMS_TFhirMedicationStatementStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('statusReason') then
    for i := 0 to elem.statusReasonList.Count - 1 do
      ComposeCodeableConcept(this, 'MedicationStatement', 'statusReason', elem.statusReasonList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    ComposeCodeableConcept(this, 'MedicationStatement', 'category', elem.categoryElement, false, -1);{x.2f}
  if (elem.medication is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'MedicationStatement', 'medicationCodeableConcept', TFhirCodeableConcept(elem.medication), false, -1){x.d9}
  else if (elem.medication is TFhirReference) {2} then
    ComposeReference(this, 'MedicationStatement', 'medicationReference', TFhirReference(elem.medication), false,-1);{x.d8}
  ComposeReference{TFhirPatient}(this, 'MedicationStatement', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('context') then
    ComposeReference{TFhirEncounter}(this, 'MedicationStatement', 'context', elem.contextElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.effective is TFhirPeriod) {6} then
    ComposePeriod(this, 'MedicationStatement', 'effectivePeriod', TFhirPeriod(elem.effective), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.effective is TFhirDateTime) {6} then
    ComposeDateTime(this, 'MedicationStatement', 'effectiveDateTime', TFhirDateTime(elem.effective), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dateAsserted') then
    ComposeDateTime(this, 'MedicationStatement', 'dateAsserted', elem.dateAssertedElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('informationSource') then
    ComposeReference{TFhirPatient}(this, 'MedicationStatement', 'informationSource', elem.informationSourceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('derivedFrom') then
    for i := 0 to elem.derivedFromList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'MedicationStatement', 'derivedFrom', elem.derivedFromList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('reasonCode') then
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'MedicationStatement', 'reasonCode', elem.reasonCodeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('reasonReference') then
    for i := 0 to elem.reasonReferenceList.Count - 1 do
      ComposeReference{TFhirCondition}(this, 'MedicationStatement', 'reasonReference', elem.reasonReferenceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'MedicationStatement', 'note', elem.noteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('dosage') then
    for i := 0 to elem.dosageList.Count - 1 do
      ComposeDosage(this, 'MedicationStatement', 'dosage', elem.dosageList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_MEDICATIONSTATEMENT}
{$IFDEF FHIR_MEDICINALPRODUCT}
function TFHIRTurtleParser.ParseMedicinalProductName(obj : TTurtleComplex) : TFhirMedicinalProductName;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicinalProductName.create;
  try
    ParseMedicinalProductNameProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicinalProductNameProperties(obj : TTurtleComplex; result : TFhirMedicinalProductName);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.productNameElement := ParseString(obj.complex('http://hl7.org/fhir/MedicinalProduct.name.productName'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProduct.name.namePart') do
      result.namePartList.Add(parseMedicinalProductNameNamePart(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProduct.name.countryLanguage') do
      result.countryLanguageList.Add(parseMedicinalProductNameCountryLanguage(item));
end;

procedure TFHIRTurtleComposer.ComposeMedicinalProductName(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicinalProductName; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicinalProductName'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeString(this, 'MedicinalProduct.name', 'productName', elem.productNameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.namePartList.Count - 1 do
      ComposeMedicinalProductNameNamePart(this, 'MedicinalProduct.name', 'namePart', elem.namePartList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.countryLanguageList.Count - 1 do
      ComposeMedicinalProductNameCountryLanguage(this, 'MedicinalProduct.name', 'countryLanguage', elem.countryLanguageList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseMedicinalProductNameNamePart(obj : TTurtleComplex) : TFhirMedicinalProductNameNamePart;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicinalProductNameNamePart.create;
  try
    ParseMedicinalProductNameNamePartProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicinalProductNameNamePartProperties(obj : TTurtleComplex; result : TFhirMedicinalProductNameNamePart);
begin
    ParseBackboneElementProperties(obj, result);
    result.partElement := ParseString(obj.complex('http://hl7.org/fhir/MedicinalProduct.name.namePart.part'));{q1}
    result.type_ := ParseCoding(obj.complex('http://hl7.org/fhir/MedicinalProduct.name.namePart.type'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeMedicinalProductNameNamePart(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicinalProductNameNamePart; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicinalProductNameNamePart'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeString(this, 'MedicinalProduct.name.namePart', 'part', elem.partElement, false, -1);{x.2ea}
  ComposeCoding(this, 'MedicinalProduct.name.namePart', 'type', elem.type_Element, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseMedicinalProductNameCountryLanguage(obj : TTurtleComplex) : TFhirMedicinalProductNameCountryLanguage;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicinalProductNameCountryLanguage.create;
  try
    ParseMedicinalProductNameCountryLanguageProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicinalProductNameCountryLanguageProperties(obj : TTurtleComplex; result : TFhirMedicinalProductNameCountryLanguage);
begin
    ParseBackboneElementProperties(obj, result);
    result.country := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicinalProduct.name.countryLanguage.country'));{q3b}
    result.jurisdiction := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicinalProduct.name.countryLanguage.jurisdiction'));{q3b}
    result.language := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicinalProduct.name.countryLanguage.language'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeMedicinalProductNameCountryLanguage(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicinalProductNameCountryLanguage; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicinalProductNameCountryLanguage'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'MedicinalProduct.name.countryLanguage', 'country', elem.countryElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'MedicinalProduct.name.countryLanguage', 'jurisdiction', elem.jurisdictionElement, false, -1);{x.2f}
  ComposeCodeableConcept(this, 'MedicinalProduct.name.countryLanguage', 'language', elem.languageElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseMedicinalProductManufacturingBusinessOperation(obj : TTurtleComplex) : TFhirMedicinalProductManufacturingBusinessOperation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicinalProductManufacturingBusinessOperation.create;
  try
    ParseMedicinalProductManufacturingBusinessOperationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicinalProductManufacturingBusinessOperationProperties(obj : TTurtleComplex; result : TFhirMedicinalProductManufacturingBusinessOperation);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.operationType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicinalProduct.manufacturingBusinessOperation.operationType'));{q3b}
    result.authorisationReferenceNumber := ParseIdentifier(obj.complex('http://hl7.org/fhir/MedicinalProduct.manufacturingBusinessOperation.authorisationReferenceNumber'));{q3b}
    result.effectiveDateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/MedicinalProduct.manufacturingBusinessOperation.effectiveDate'));{q1}
    result.confidentialityIndicator := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicinalProduct.manufacturingBusinessOperation.confidentialityIndicator'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProduct.manufacturingBusinessOperation.manufacturer') do
      result.manufacturerList.Add(parseReference{TFhirOrganization}(item));
    result.regulator := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/MedicinalProduct.manufacturingBusinessOperation.regulator'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeMedicinalProductManufacturingBusinessOperation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicinalProductManufacturingBusinessOperation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicinalProductManufacturingBusinessOperation'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'MedicinalProduct.manufacturingBusinessOperation', 'operationType', elem.operationTypeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'MedicinalProduct.manufacturingBusinessOperation', 'authorisationReferenceNumber', elem.authorisationReferenceNumberElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'MedicinalProduct.manufacturingBusinessOperation', 'effectiveDate', elem.effectiveDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'MedicinalProduct.manufacturingBusinessOperation', 'confidentialityIndicator', elem.confidentialityIndicatorElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.manufacturerList.Count - 1 do
      ComposeReference{TFhirOrganization}(this, 'MedicinalProduct.manufacturingBusinessOperation', 'manufacturer', elem.manufacturerList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(this, 'MedicinalProduct.manufacturingBusinessOperation', 'regulator', elem.regulatorElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseMedicinalProductSpecialDesignation(obj : TTurtleComplex) : TFhirMedicinalProductSpecialDesignation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicinalProductSpecialDesignation.create;
  try
    ParseMedicinalProductSpecialDesignationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicinalProductSpecialDesignationProperties(obj : TTurtleComplex; result : TFhirMedicinalProductSpecialDesignation);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProduct.specialDesignation.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicinalProduct.specialDesignation.type'));{q3b}
    result.intendedUse := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicinalProduct.specialDesignation.intendedUse'));{q3b}
    if obj.has('http://hl7.org/fhir/MedicinalProduct.specialDesignation.indicationCodeableConcept', item) then
      result.indication := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/MedicinalProduct.specialDesignation.indicationReference', item) {a3} then
      result.indication := ParseReference(item);
    result.status := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicinalProduct.specialDesignation.status'));{q3b}
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/MedicinalProduct.specialDesignation.date'));{q1}
    result.species := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicinalProduct.specialDesignation.species'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeMedicinalProductSpecialDesignation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicinalProductSpecialDesignation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicinalProductSpecialDesignation'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'MedicinalProduct.specialDesignation', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'MedicinalProduct.specialDesignation', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'MedicinalProduct.specialDesignation', 'intendedUse', elem.intendedUseElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.indication is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'MedicinalProduct.specialDesignation', 'indicationCodeableConcept', TFhirCodeableConcept(elem.indication), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.indication is TFhirReference) {2} then
    ComposeReference(this, 'MedicinalProduct.specialDesignation', 'indicationReference', TFhirReference(elem.indication), false,-1);{x.d8}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'MedicinalProduct.specialDesignation', 'status', elem.statusElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'MedicinalProduct.specialDesignation', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'MedicinalProduct.specialDesignation', 'species', elem.speciesElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseMedicinalProduct(obj : TTurtleComplex) : TFhirMedicinalProduct;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicinalProduct.create;
  try
    ParseMedicinalProductProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicinalProductProperties(obj : TTurtleComplex; result : TFhirMedicinalProduct);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProduct.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicinalProduct.type'));{q3b}
    result.domain := ParseCoding(obj.complex('http://hl7.org/fhir/MedicinalProduct.domain'));{q3b}
    result.combinedPharmaceuticalDoseForm := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicinalProduct.combinedPharmaceuticalDoseForm'));{q3b}
    result.legalStatusOfSupply := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicinalProduct.legalStatusOfSupply'));{q3b}
    result.additionalMonitoringIndicator := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicinalProduct.additionalMonitoringIndicator'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProduct.specialMeasures') do
      result.specialMeasuresList.Add(parseString(item));
    result.paediatricUseIndicator := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicinalProduct.paediatricUseIndicator'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProduct.productClassification') do
      result.productClassificationList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProduct.marketingStatus') do
      result.marketingStatusList.Add(parseMarketingStatus(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProduct.pharmaceuticalProduct') do
      result.pharmaceuticalProductList.Add(parseReference{TFhirMedicinalProductPharmaceutical}(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProduct.packagedMedicinalProduct') do
      result.packagedMedicinalProductList.Add(parseReference{TFhirMedicinalProductPackaged}(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProduct.attachedDocument') do
      result.attachedDocumentList.Add(parseReference{TFhirDocumentReference}(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProduct.masterFile') do
      result.masterFileList.Add(parseReference{TFhirDocumentReference}(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProduct.contact') do
      result.contactList.Add(parseReference{TFhirOrganization}(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProduct.clinicalTrial') do
      result.clinicalTrialList.Add(parseReference{TFhirResearchStudy}(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProduct.name') do
      result.nameList.Add(parseMedicinalProductName(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProduct.crossReference') do
      result.crossReferenceList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProduct.manufacturingBusinessOperation') do
      result.manufacturingBusinessOperationList.Add(parseMedicinalProductManufacturingBusinessOperation(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProduct.specialDesignation') do
      result.specialDesignationList.Add(parseMedicinalProductSpecialDesignation(item));
end;

procedure TFHIRTurtleComposer.ComposeMedicinalProduct(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicinalProduct; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicinalProduct'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'MedicinalProduct', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCodeableConcept(this, 'MedicinalProduct', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('domain') then
    ComposeCoding(this, 'MedicinalProduct', 'domain', elem.domainElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('combinedPharmaceuticalDoseForm') then
    ComposeCodeableConcept(this, 'MedicinalProduct', 'combinedPharmaceuticalDoseForm', elem.combinedPharmaceuticalDoseFormElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('legalStatusOfSupply') then
    ComposeCodeableConcept(this, 'MedicinalProduct', 'legalStatusOfSupply', elem.legalStatusOfSupplyElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('additionalMonitoringIndicator') then
    ComposeCodeableConcept(this, 'MedicinalProduct', 'additionalMonitoringIndicator', elem.additionalMonitoringIndicatorElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('specialMeasures') then
    for i := 0 to elem.specialMeasuresList.Count - 1 do
      ComposeString(this, 'MedicinalProduct', 'specialMeasures', elem.specialMeasuresList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('paediatricUseIndicator') then
    ComposeCodeableConcept(this, 'MedicinalProduct', 'paediatricUseIndicator', elem.paediatricUseIndicatorElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('productClassification') then
    for i := 0 to elem.productClassificationList.Count - 1 do
      ComposeCodeableConcept(this, 'MedicinalProduct', 'productClassification', elem.productClassificationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('marketingStatus') then
    for i := 0 to elem.marketingStatusList.Count - 1 do
      ComposeMarketingStatus(this, 'MedicinalProduct', 'marketingStatus', elem.marketingStatusList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('pharmaceuticalProduct') then
    for i := 0 to elem.pharmaceuticalProductList.Count - 1 do
      ComposeReference{TFhirMedicinalProductPharmaceutical}(this, 'MedicinalProduct', 'pharmaceuticalProduct', elem.pharmaceuticalProductList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('packagedMedicinalProduct') then
    for i := 0 to elem.packagedMedicinalProductList.Count - 1 do
      ComposeReference{TFhirMedicinalProductPackaged}(this, 'MedicinalProduct', 'packagedMedicinalProduct', elem.packagedMedicinalProductList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('attachedDocument') then
    for i := 0 to elem.attachedDocumentList.Count - 1 do
      ComposeReference{TFhirDocumentReference}(this, 'MedicinalProduct', 'attachedDocument', elem.attachedDocumentList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('masterFile') then
    for i := 0 to elem.masterFileList.Count - 1 do
      ComposeReference{TFhirDocumentReference}(this, 'MedicinalProduct', 'masterFile', elem.masterFileList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeReference{TFhirOrganization}(this, 'MedicinalProduct', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('clinicalTrial') then
    for i := 0 to elem.clinicalTrialList.Count - 1 do
      ComposeReference{TFhirResearchStudy}(this, 'MedicinalProduct', 'clinicalTrial', elem.clinicalTrialList[i], false, i);{x.d3}
  for i := 0 to elem.nameList.Count - 1 do
      ComposeMedicinalProductName(this, 'MedicinalProduct', 'name', elem.nameList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('crossReference') then
    for i := 0 to elem.crossReferenceList.Count - 1 do
      ComposeIdentifier(this, 'MedicinalProduct', 'crossReference', elem.crossReferenceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('manufacturingBusinessOperation') then
    for i := 0 to elem.manufacturingBusinessOperationList.Count - 1 do
      ComposeMedicinalProductManufacturingBusinessOperation(this, 'MedicinalProduct', 'manufacturingBusinessOperation', elem.manufacturingBusinessOperationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('specialDesignation') then
    for i := 0 to elem.specialDesignationList.Count - 1 do
      ComposeMedicinalProductSpecialDesignation(this, 'MedicinalProduct', 'specialDesignation', elem.specialDesignationList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_MEDICINALPRODUCT}
{$IFDEF FHIR_MEDICINALPRODUCTAUTHORIZATION}
function TFHIRTurtleParser.ParseMedicinalProductAuthorizationJurisdictionalAuthorization(obj : TTurtleComplex) : TFhirMedicinalProductAuthorizationJurisdictionalAuthorization;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicinalProductAuthorizationJurisdictionalAuthorization.create;
  try
    ParseMedicinalProductAuthorizationJurisdictionalAuthorizationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicinalProductAuthorizationJurisdictionalAuthorizationProperties(obj : TTurtleComplex; result : TFhirMedicinalProductAuthorizationJurisdictionalAuthorization);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProductAuthorization.jurisdictionalAuthorization.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.country := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicinalProductAuthorization.jurisdictionalAuthorization.country'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProductAuthorization.jurisdictionalAuthorization.jurisdiction') do
      result.jurisdictionList.Add(parseCodeableConcept(item));
    result.legalStatusOfSupply := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicinalProductAuthorization.jurisdictionalAuthorization.legalStatusOfSupply'));{q3b}
    result.validityPeriod := ParsePeriod(obj.complex('http://hl7.org/fhir/MedicinalProductAuthorization.jurisdictionalAuthorization.validityPeriod'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeMedicinalProductAuthorizationJurisdictionalAuthorization(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicinalProductAuthorizationJurisdictionalAuthorization; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicinalProductAuthorizationJurisdictionalAuthorization'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'MedicinalProductAuthorization.jurisdictionalAuthorization', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'MedicinalProductAuthorization.jurisdictionalAuthorization', 'country', elem.countryElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'MedicinalProductAuthorization.jurisdictionalAuthorization', 'jurisdiction', elem.jurisdictionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'MedicinalProductAuthorization.jurisdictionalAuthorization', 'legalStatusOfSupply', elem.legalStatusOfSupplyElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(this, 'MedicinalProductAuthorization.jurisdictionalAuthorization', 'validityPeriod', elem.validityPeriodElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseMedicinalProductAuthorizationProcedure(obj : TTurtleComplex) : TFhirMedicinalProductAuthorizationProcedure;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicinalProductAuthorizationProcedure.create;
  try
    ParseMedicinalProductAuthorizationProcedureProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicinalProductAuthorizationProcedureProperties(obj : TTurtleComplex; result : TFhirMedicinalProductAuthorizationProcedure);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/MedicinalProductAuthorization.procedure.identifier'));{q3b}
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicinalProductAuthorization.procedure.type'));{q3b}
    if obj.has('http://hl7.org/fhir/MedicinalProductAuthorization.procedure.datePeriod', item) then
      result.date := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/MedicinalProductAuthorization.procedure.dateDateTime', item) then
      result.date := parseDateTime(item);
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProductAuthorization.procedure.application') do
      result.applicationList.Add(parseMedicinalProductAuthorizationProcedure(item));
end;

procedure TFHIRTurtleComposer.ComposeMedicinalProductAuthorizationProcedure(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicinalProductAuthorizationProcedure; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicinalProductAuthorizationProcedure'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'MedicinalProductAuthorization.procedure', 'identifier', elem.identifierElement, false, -1);{x.2f}
  ComposeCodeableConcept(this, 'MedicinalProductAuthorization.procedure', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.date is TFhirPeriod) {6} then
    ComposePeriod(this, 'MedicinalProductAuthorization.procedure', 'datePeriod', TFhirPeriod(elem.date), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.date is TFhirDateTime) {6} then
    ComposeDateTime(this, 'MedicinalProductAuthorization.procedure', 'dateDateTime', TFhirDateTime(elem.date), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.applicationList.Count - 1 do
      ComposeMedicinalProductAuthorizationProcedure(this, 'MedicinalProductAuthorization.procedure', 'application', elem.applicationList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseMedicinalProductAuthorization(obj : TTurtleComplex) : TFhirMedicinalProductAuthorization;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicinalProductAuthorization.create;
  try
    ParseMedicinalProductAuthorizationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicinalProductAuthorizationProperties(obj : TTurtleComplex; result : TFhirMedicinalProductAuthorization);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProductAuthorization.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.subject := ParseReference{TFhirMedicinalProduct}(obj.complex('http://hl7.org/fhir/MedicinalProductAuthorization.subject'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProductAuthorization.country') do
      result.countryList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProductAuthorization.jurisdiction') do
      result.jurisdictionList.Add(parseCodeableConcept(item));
    result.status := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicinalProductAuthorization.status'));{q3b}
    result.statusDateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/MedicinalProductAuthorization.statusDate'));{q1}
    result.restoreDateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/MedicinalProductAuthorization.restoreDate'));{q1}
    result.validityPeriod := ParsePeriod(obj.complex('http://hl7.org/fhir/MedicinalProductAuthorization.validityPeriod'));{q3b}
    result.dataExclusivityPeriod := ParsePeriod(obj.complex('http://hl7.org/fhir/MedicinalProductAuthorization.dataExclusivityPeriod'));{q3b}
    result.dateOfFirstAuthorizationElement := ParseDateTime(obj.complex('http://hl7.org/fhir/MedicinalProductAuthorization.dateOfFirstAuthorization'));{q1}
    result.internationalBirthDateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/MedicinalProductAuthorization.internationalBirthDate'));{q1}
    result.legalBasis := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicinalProductAuthorization.legalBasis'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProductAuthorization.jurisdictionalAuthorization') do
      result.jurisdictionalAuthorizationList.Add(parseMedicinalProductAuthorizationJurisdictionalAuthorization(item));
    result.holder := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/MedicinalProductAuthorization.holder'));{q3b}
    result.regulator := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/MedicinalProductAuthorization.regulator'));{q3b}
    result.procedure_ := ParseMedicinalProductAuthorizationProcedure(obj.complex('http://hl7.org/fhir/MedicinalProductAuthorization.procedure'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeMedicinalProductAuthorization(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicinalProductAuthorization; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicinalProductAuthorization'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'MedicinalProductAuthorization', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{TFhirMedicinalProduct}(this, 'MedicinalProductAuthorization', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('country') then
    for i := 0 to elem.countryList.Count - 1 do
      ComposeCodeableConcept(this, 'MedicinalProductAuthorization', 'country', elem.countryList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'MedicinalProductAuthorization', 'jurisdiction', elem.jurisdictionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeCodeableConcept(this, 'MedicinalProductAuthorization', 'status', elem.statusElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('statusDate') then
    ComposeDateTime(this, 'MedicinalProductAuthorization', 'statusDate', elem.statusDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('restoreDate') then
    ComposeDateTime(this, 'MedicinalProductAuthorization', 'restoreDate', elem.restoreDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('validityPeriod') then
    ComposePeriod(this, 'MedicinalProductAuthorization', 'validityPeriod', elem.validityPeriodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dataExclusivityPeriod') then
    ComposePeriod(this, 'MedicinalProductAuthorization', 'dataExclusivityPeriod', elem.dataExclusivityPeriodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dateOfFirstAuthorization') then
    ComposeDateTime(this, 'MedicinalProductAuthorization', 'dateOfFirstAuthorization', elem.dateOfFirstAuthorizationElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('internationalBirthDate') then
    ComposeDateTime(this, 'MedicinalProductAuthorization', 'internationalBirthDate', elem.internationalBirthDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('legalBasis') then
    ComposeCodeableConcept(this, 'MedicinalProductAuthorization', 'legalBasis', elem.legalBasisElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdictionalAuthorization') then
    for i := 0 to elem.jurisdictionalAuthorizationList.Count - 1 do
      ComposeMedicinalProductAuthorizationJurisdictionalAuthorization(this, 'MedicinalProductAuthorization', 'jurisdictionalAuthorization', elem.jurisdictionalAuthorizationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('holder') then
    ComposeReference{TFhirOrganization}(this, 'MedicinalProductAuthorization', 'holder', elem.holderElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('regulator') then
    ComposeReference{TFhirOrganization}(this, 'MedicinalProductAuthorization', 'regulator', elem.regulatorElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('procedure_') then
    ComposeMedicinalProductAuthorizationProcedure(this, 'MedicinalProductAuthorization', 'procedure', elem.procedure_Element, false, -1);{x.2f}
end;

{$ENDIF FHIR_MEDICINALPRODUCTAUTHORIZATION}
{$IFDEF FHIR_MEDICINALPRODUCTCONTRAINDICATION}
function TFHIRTurtleParser.ParseMedicinalProductContraindicationOtherTherapy(obj : TTurtleComplex) : TFhirMedicinalProductContraindicationOtherTherapy;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicinalProductContraindicationOtherTherapy.create;
  try
    ParseMedicinalProductContraindicationOtherTherapyProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicinalProductContraindicationOtherTherapyProperties(obj : TTurtleComplex; result : TFhirMedicinalProductContraindicationOtherTherapy);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.therapyRelationshipType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicinalProductContraindication.otherTherapy.therapyRelationshipType'));{q3b}
    if obj.has('http://hl7.org/fhir/MedicinalProductContraindication.otherTherapy.medicationCodeableConcept', item) then
      result.medication := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/MedicinalProductContraindication.otherTherapy.medicationReference', item) {a3} then
      result.medication := ParseReference(item);
end;

procedure TFHIRTurtleComposer.ComposeMedicinalProductContraindicationOtherTherapy(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicinalProductContraindicationOtherTherapy; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicinalProductContraindicationOtherTherapy'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'MedicinalProductContraindication.otherTherapy', 'therapyRelationshipType', elem.therapyRelationshipTypeElement, false, -1);{x.2f}
  if (elem.medication is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'MedicinalProductContraindication.otherTherapy', 'medicationCodeableConcept', TFhirCodeableConcept(elem.medication), false, -1){x.d9}
  else if (elem.medication is TFhirReference) {2} then
    ComposeReference(this, 'MedicinalProductContraindication.otherTherapy', 'medicationReference', TFhirReference(elem.medication), false,-1);{x.d8}
end;

function TFHIRTurtleParser.ParseMedicinalProductContraindication(obj : TTurtleComplex) : TFhirMedicinalProductContraindication;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicinalProductContraindication.create;
  try
    ParseMedicinalProductContraindicationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicinalProductContraindicationProperties(obj : TTurtleComplex; result : TFhirMedicinalProductContraindication);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProductContraindication.subject') do
      result.subjectList.Add(parseReference{TFhirMedicinalProduct}(item));
    result.disease := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicinalProductContraindication.disease'));{q3b}
    result.diseaseStatus := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicinalProductContraindication.diseaseStatus'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProductContraindication.comorbidity') do
      result.comorbidityList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProductContraindication.therapeuticIndication') do
      result.therapeuticIndicationList.Add(parseReference{TFhirMedicinalProductIndication}(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProductContraindication.otherTherapy') do
      result.otherTherapyList.Add(parseMedicinalProductContraindicationOtherTherapy(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProductContraindication.population') do
      result.populationList.Add(parsePopulation(item));
end;

procedure TFHIRTurtleComposer.ComposeMedicinalProductContraindication(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicinalProductContraindication; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicinalProductContraindication'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    for i := 0 to elem.subjectList.Count - 1 do
      ComposeReference{TFhirMedicinalProduct}(this, 'MedicinalProductContraindication', 'subject', elem.subjectList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('disease') then
    ComposeCodeableConcept(this, 'MedicinalProductContraindication', 'disease', elem.diseaseElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('diseaseStatus') then
    ComposeCodeableConcept(this, 'MedicinalProductContraindication', 'diseaseStatus', elem.diseaseStatusElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('comorbidity') then
    for i := 0 to elem.comorbidityList.Count - 1 do
      ComposeCodeableConcept(this, 'MedicinalProductContraindication', 'comorbidity', elem.comorbidityList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('therapeuticIndication') then
    for i := 0 to elem.therapeuticIndicationList.Count - 1 do
      ComposeReference{TFhirMedicinalProductIndication}(this, 'MedicinalProductContraindication', 'therapeuticIndication', elem.therapeuticIndicationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('otherTherapy') then
    for i := 0 to elem.otherTherapyList.Count - 1 do
      ComposeMedicinalProductContraindicationOtherTherapy(this, 'MedicinalProductContraindication', 'otherTherapy', elem.otherTherapyList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('population') then
    for i := 0 to elem.populationList.Count - 1 do
      ComposePopulation(this, 'MedicinalProductContraindication', 'population', elem.populationList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_MEDICINALPRODUCTCONTRAINDICATION}
{$IFDEF FHIR_MEDICINALPRODUCTINDICATION}
function TFHIRTurtleParser.ParseMedicinalProductIndicationOtherTherapy(obj : TTurtleComplex) : TFhirMedicinalProductIndicationOtherTherapy;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicinalProductIndicationOtherTherapy.create;
  try
    ParseMedicinalProductIndicationOtherTherapyProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicinalProductIndicationOtherTherapyProperties(obj : TTurtleComplex; result : TFhirMedicinalProductIndicationOtherTherapy);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.therapyRelationshipType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicinalProductIndication.otherTherapy.therapyRelationshipType'));{q3b}
    if obj.has('http://hl7.org/fhir/MedicinalProductIndication.otherTherapy.medicationCodeableConcept', item) then
      result.medication := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/MedicinalProductIndication.otherTherapy.medicationReference', item) {a3} then
      result.medication := ParseReference(item);
end;

procedure TFHIRTurtleComposer.ComposeMedicinalProductIndicationOtherTherapy(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicinalProductIndicationOtherTherapy; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicinalProductIndicationOtherTherapy'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'MedicinalProductIndication.otherTherapy', 'therapyRelationshipType', elem.therapyRelationshipTypeElement, false, -1);{x.2f}
  if (elem.medication is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'MedicinalProductIndication.otherTherapy', 'medicationCodeableConcept', TFhirCodeableConcept(elem.medication), false, -1){x.d9}
  else if (elem.medication is TFhirReference) {2} then
    ComposeReference(this, 'MedicinalProductIndication.otherTherapy', 'medicationReference', TFhirReference(elem.medication), false,-1);{x.d8}
end;

function TFHIRTurtleParser.ParseMedicinalProductIndication(obj : TTurtleComplex) : TFhirMedicinalProductIndication;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicinalProductIndication.create;
  try
    ParseMedicinalProductIndicationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicinalProductIndicationProperties(obj : TTurtleComplex; result : TFhirMedicinalProductIndication);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProductIndication.subject') do
      result.subjectList.Add(parseReference{TFhirMedicinalProduct}(item));
    result.diseaseSymptomProcedure := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicinalProductIndication.diseaseSymptomProcedure'));{q3b}
    result.diseaseStatus := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicinalProductIndication.diseaseStatus'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProductIndication.comorbidity') do
      result.comorbidityList.Add(parseCodeableConcept(item));
    result.intendedEffect := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicinalProductIndication.intendedEffect'));{q3b}
    result.duration := ParseQuantity(obj.complex('http://hl7.org/fhir/MedicinalProductIndication.duration'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProductIndication.otherTherapy') do
      result.otherTherapyList.Add(parseMedicinalProductIndicationOtherTherapy(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProductIndication.undesirableEffect') do
      result.undesirableEffectList.Add(parseReference{TFhirMedicinalProductUndesirableEffect}(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProductIndication.population') do
      result.populationList.Add(parsePopulation(item));
end;

procedure TFHIRTurtleComposer.ComposeMedicinalProductIndication(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicinalProductIndication; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicinalProductIndication'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    for i := 0 to elem.subjectList.Count - 1 do
      ComposeReference{TFhirMedicinalProduct}(this, 'MedicinalProductIndication', 'subject', elem.subjectList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('diseaseSymptomProcedure') then
    ComposeCodeableConcept(this, 'MedicinalProductIndication', 'diseaseSymptomProcedure', elem.diseaseSymptomProcedureElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('diseaseStatus') then
    ComposeCodeableConcept(this, 'MedicinalProductIndication', 'diseaseStatus', elem.diseaseStatusElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('comorbidity') then
    for i := 0 to elem.comorbidityList.Count - 1 do
      ComposeCodeableConcept(this, 'MedicinalProductIndication', 'comorbidity', elem.comorbidityList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('intendedEffect') then
    ComposeCodeableConcept(this, 'MedicinalProductIndication', 'intendedEffect', elem.intendedEffectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('duration') then
    ComposeQuantity(this, 'MedicinalProductIndication', 'duration', elem.durationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('otherTherapy') then
    for i := 0 to elem.otherTherapyList.Count - 1 do
      ComposeMedicinalProductIndicationOtherTherapy(this, 'MedicinalProductIndication', 'otherTherapy', elem.otherTherapyList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('undesirableEffect') then
    for i := 0 to elem.undesirableEffectList.Count - 1 do
      ComposeReference{TFhirMedicinalProductUndesirableEffect}(this, 'MedicinalProductIndication', 'undesirableEffect', elem.undesirableEffectList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('population') then
    for i := 0 to elem.populationList.Count - 1 do
      ComposePopulation(this, 'MedicinalProductIndication', 'population', elem.populationList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_MEDICINALPRODUCTINDICATION}
{$IFDEF FHIR_MEDICINALPRODUCTINGREDIENT}
function TFHIRTurtleParser.ParseMedicinalProductIngredientSpecifiedSubstance(obj : TTurtleComplex) : TFhirMedicinalProductIngredientSpecifiedSubstance;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicinalProductIngredientSpecifiedSubstance.create;
  try
    ParseMedicinalProductIngredientSpecifiedSubstanceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicinalProductIngredientSpecifiedSubstanceProperties(obj : TTurtleComplex; result : TFhirMedicinalProductIngredientSpecifiedSubstance);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicinalProductIngredient.specifiedSubstance.code'));{q3b}
    result.group := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicinalProductIngredient.specifiedSubstance.group'));{q3b}
    result.confidentiality := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicinalProductIngredient.specifiedSubstance.confidentiality'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProductIngredient.specifiedSubstance.strength') do
      result.strengthList.Add(parseMedicinalProductIngredientSpecifiedSubstanceStrength(item));
end;

procedure TFHIRTurtleComposer.ComposeMedicinalProductIngredientSpecifiedSubstance(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicinalProductIngredientSpecifiedSubstance; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicinalProductIngredientSpecifiedSubstance'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'MedicinalProductIngredient.specifiedSubstance', 'code', elem.codeElement, false, -1);{x.2f}
  ComposeCodeableConcept(this, 'MedicinalProductIngredient.specifiedSubstance', 'group', elem.groupElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'MedicinalProductIngredient.specifiedSubstance', 'confidentiality', elem.confidentialityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.strengthList.Count - 1 do
      ComposeMedicinalProductIngredientSpecifiedSubstanceStrength(this, 'MedicinalProductIngredient.specifiedSubstance', 'strength', elem.strengthList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseMedicinalProductIngredientSpecifiedSubstanceStrength(obj : TTurtleComplex) : TFhirMedicinalProductIngredientSpecifiedSubstanceStrength;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicinalProductIngredientSpecifiedSubstanceStrength.create;
  try
    ParseMedicinalProductIngredientSpecifiedSubstanceStrengthProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicinalProductIngredientSpecifiedSubstanceStrengthProperties(obj : TTurtleComplex; result : TFhirMedicinalProductIngredientSpecifiedSubstanceStrength);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.presentation := ParseRatio(obj.complex('http://hl7.org/fhir/MedicinalProductIngredient.specifiedSubstance.strength.presentation'));{q3b}
    result.presentationLowLimit := ParseRatio(obj.complex('http://hl7.org/fhir/MedicinalProductIngredient.specifiedSubstance.strength.presentationLowLimit'));{q3b}
    result.concentration := ParseRatio(obj.complex('http://hl7.org/fhir/MedicinalProductIngredient.specifiedSubstance.strength.concentration'));{q3b}
    result.concentrationLowLimit := ParseRatio(obj.complex('http://hl7.org/fhir/MedicinalProductIngredient.specifiedSubstance.strength.concentrationLowLimit'));{q3b}
    result.measurementPointElement := ParseString(obj.complex('http://hl7.org/fhir/MedicinalProductIngredient.specifiedSubstance.strength.measurementPoint'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProductIngredient.specifiedSubstance.strength.country') do
      result.countryList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProductIngredient.specifiedSubstance.strength.referenceStrength') do
      result.referenceStrengthList.Add(parseMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength(item));
end;

procedure TFHIRTurtleComposer.ComposeMedicinalProductIngredientSpecifiedSubstanceStrength(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicinalProductIngredientSpecifiedSubstanceStrength; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicinalProductIngredientSpecifiedSubstanceStrength'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeRatio(this, 'MedicinalProductIngredient.specifiedSubstance.strength', 'presentation', elem.presentationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeRatio(this, 'MedicinalProductIngredient.specifiedSubstance.strength', 'presentationLowLimit', elem.presentationLowLimitElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeRatio(this, 'MedicinalProductIngredient.specifiedSubstance.strength', 'concentration', elem.concentrationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeRatio(this, 'MedicinalProductIngredient.specifiedSubstance.strength', 'concentrationLowLimit', elem.concentrationLowLimitElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'MedicinalProductIngredient.specifiedSubstance.strength', 'measurementPoint', elem.measurementPointElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.countryList.Count - 1 do
      ComposeCodeableConcept(this, 'MedicinalProductIngredient.specifiedSubstance.strength', 'country', elem.countryList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.referenceStrengthList.Count - 1 do
      ComposeMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength(this, 'MedicinalProductIngredient.specifiedSubstance.strength', 'referenceStrength', elem.referenceStrengthList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength(obj : TTurtleComplex) : TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength.create;
  try
    ParseMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrengthProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrengthProperties(obj : TTurtleComplex; result : TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.substance := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicinalProductIngredient.specifiedSubstance.strength.referenceStrength.substance'));{q3b}
    result.strength := ParseRatio(obj.complex('http://hl7.org/fhir/MedicinalProductIngredient.specifiedSubstance.strength.referenceStrength.strength'));{q3b}
    result.strengthLowLimit := ParseRatio(obj.complex('http://hl7.org/fhir/MedicinalProductIngredient.specifiedSubstance.strength.referenceStrength.strengthLowLimit'));{q3b}
    result.measurementPointElement := ParseString(obj.complex('http://hl7.org/fhir/MedicinalProductIngredient.specifiedSubstance.strength.referenceStrength.measurementPoint'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProductIngredient.specifiedSubstance.strength.referenceStrength.country') do
      result.countryList.Add(parseCodeableConcept(item));
end;

procedure TFHIRTurtleComposer.ComposeMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'MedicinalProductIngredient.specifiedSubstance.strength.referenceStrength', 'substance', elem.substanceElement, false, -1);{x.2f}
  ComposeRatio(this, 'MedicinalProductIngredient.specifiedSubstance.strength.referenceStrength', 'strength', elem.strengthElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeRatio(this, 'MedicinalProductIngredient.specifiedSubstance.strength.referenceStrength', 'strengthLowLimit', elem.strengthLowLimitElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'MedicinalProductIngredient.specifiedSubstance.strength.referenceStrength', 'measurementPoint', elem.measurementPointElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.countryList.Count - 1 do
      ComposeCodeableConcept(this, 'MedicinalProductIngredient.specifiedSubstance.strength.referenceStrength', 'country', elem.countryList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseMedicinalProductIngredientSubstance(obj : TTurtleComplex) : TFhirMedicinalProductIngredientSubstance;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicinalProductIngredientSubstance.create;
  try
    ParseMedicinalProductIngredientSubstanceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicinalProductIngredientSubstanceProperties(obj : TTurtleComplex; result : TFhirMedicinalProductIngredientSubstance);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicinalProductIngredient.substance.code'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProductIngredient.substance.strength') do
      result.strengthList.Add(parseMedicinalProductIngredientSpecifiedSubstanceStrength(item));
end;

procedure TFHIRTurtleComposer.ComposeMedicinalProductIngredientSubstance(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicinalProductIngredientSubstance; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicinalProductIngredientSubstance'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'MedicinalProductIngredient.substance', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.strengthList.Count - 1 do
      ComposeMedicinalProductIngredientSpecifiedSubstanceStrength(this, 'MedicinalProductIngredient.substance', 'strength', elem.strengthList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseMedicinalProductIngredient(obj : TTurtleComplex) : TFhirMedicinalProductIngredient;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicinalProductIngredient.create;
  try
    ParseMedicinalProductIngredientProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicinalProductIngredientProperties(obj : TTurtleComplex; result : TFhirMedicinalProductIngredient);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/MedicinalProductIngredient.identifier'));{q3b}
    result.role := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicinalProductIngredient.role'));{q3b}
    result.allergenicIndicatorElement := ParseBoolean(obj.complex('http://hl7.org/fhir/MedicinalProductIngredient.allergenicIndicator'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProductIngredient.manufacturer') do
      result.manufacturerList.Add(parseReference{TFhirOrganization}(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProductIngredient.specifiedSubstance') do
      result.specifiedSubstanceList.Add(parseMedicinalProductIngredientSpecifiedSubstance(item));
    result.substance := ParseMedicinalProductIngredientSubstance(obj.complex('http://hl7.org/fhir/MedicinalProductIngredient.substance'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeMedicinalProductIngredient(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicinalProductIngredient; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicinalProductIngredient'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(this, 'MedicinalProductIngredient', 'identifier', elem.identifierElement, false, -1);{x.2f}
  ComposeCodeableConcept(this, 'MedicinalProductIngredient', 'role', elem.roleElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('allergenicIndicator') then
    ComposeBoolean(this, 'MedicinalProductIngredient', 'allergenicIndicator', elem.allergenicIndicatorElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('manufacturer') then
    for i := 0 to elem.manufacturerList.Count - 1 do
      ComposeReference{TFhirOrganization}(this, 'MedicinalProductIngredient', 'manufacturer', elem.manufacturerList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('specifiedSubstance') then
    for i := 0 to elem.specifiedSubstanceList.Count - 1 do
      ComposeMedicinalProductIngredientSpecifiedSubstance(this, 'MedicinalProductIngredient', 'specifiedSubstance', elem.specifiedSubstanceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('substance') then
    ComposeMedicinalProductIngredientSubstance(this, 'MedicinalProductIngredient', 'substance', elem.substanceElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_MEDICINALPRODUCTINGREDIENT}
{$IFDEF FHIR_MEDICINALPRODUCTINTERACTION}
function TFHIRTurtleParser.ParseMedicinalProductInteractionInteractant(obj : TTurtleComplex) : TFhirMedicinalProductInteractionInteractant;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicinalProductInteractionInteractant.create;
  try
    ParseMedicinalProductInteractionInteractantProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicinalProductInteractionInteractantProperties(obj : TTurtleComplex; result : TFhirMedicinalProductInteractionInteractant);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    if obj.has('http://hl7.org/fhir/MedicinalProductInteraction.interactant.itemReference', item) {a3} then
      result.item := ParseReference(item);
    if obj.has('http://hl7.org/fhir/MedicinalProductInteraction.interactant.itemCodeableConcept', item) then
      result.item := parseCodeableConcept(item);
end;

procedure TFHIRTurtleComposer.ComposeMedicinalProductInteractionInteractant(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicinalProductInteractionInteractant; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicinalProductInteractionInteractant'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (elem.item is TFhirReference) {2} then
    ComposeReference(this, 'MedicinalProductInteraction.interactant', 'itemReference', TFhirReference(elem.item), false,-1){x.d8}
  else if (elem.item is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'MedicinalProductInteraction.interactant', 'itemCodeableConcept', TFhirCodeableConcept(elem.item), false, -1);{x.d9}
end;

function TFHIRTurtleParser.ParseMedicinalProductInteraction(obj : TTurtleComplex) : TFhirMedicinalProductInteraction;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicinalProductInteraction.create;
  try
    ParseMedicinalProductInteractionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicinalProductInteractionProperties(obj : TTurtleComplex; result : TFhirMedicinalProductInteraction);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProductInteraction.subject') do
      result.subjectList.Add(parseReference{TFhirMedicinalProduct}(item));
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/MedicinalProductInteraction.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProductInteraction.interactant') do
      result.interactantList.Add(parseMedicinalProductInteractionInteractant(item));
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicinalProductInteraction.type'));{q3b}
    result.effect := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicinalProductInteraction.effect'));{q3b}
    result.incidence := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicinalProductInteraction.incidence'));{q3b}
    result.management := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicinalProductInteraction.management'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeMedicinalProductInteraction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicinalProductInteraction; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicinalProductInteraction'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    for i := 0 to elem.subjectList.Count - 1 do
      ComposeReference{TFhirMedicinalProduct}(this, 'MedicinalProductInteraction', 'subject', elem.subjectList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeString(this, 'MedicinalProductInteraction', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('interactant') then
    for i := 0 to elem.interactantList.Count - 1 do
      ComposeMedicinalProductInteractionInteractant(this, 'MedicinalProductInteraction', 'interactant', elem.interactantList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCodeableConcept(this, 'MedicinalProductInteraction', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('effect') then
    ComposeCodeableConcept(this, 'MedicinalProductInteraction', 'effect', elem.effectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('incidence') then
    ComposeCodeableConcept(this, 'MedicinalProductInteraction', 'incidence', elem.incidenceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('management') then
    ComposeCodeableConcept(this, 'MedicinalProductInteraction', 'management', elem.managementElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_MEDICINALPRODUCTINTERACTION}
{$IFDEF FHIR_MEDICINALPRODUCTMANUFACTURED}
function TFHIRTurtleParser.ParseMedicinalProductManufactured(obj : TTurtleComplex) : TFhirMedicinalProductManufactured;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicinalProductManufactured.create;
  try
    ParseMedicinalProductManufacturedProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicinalProductManufacturedProperties(obj : TTurtleComplex; result : TFhirMedicinalProductManufactured);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.manufacturedDoseForm := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicinalProductManufactured.manufacturedDoseForm'));{q3b}
    result.unitOfPresentation := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicinalProductManufactured.unitOfPresentation'));{q3b}
    result.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/MedicinalProductManufactured.quantity'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProductManufactured.manufacturer') do
      result.manufacturerList.Add(parseReference{TFhirOrganization}(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProductManufactured.ingredient') do
      result.ingredientList.Add(parseReference{TFhirMedicinalProductIngredient}(item));
    result.physicalCharacteristics := ParseProdCharacteristic(obj.complex('http://hl7.org/fhir/MedicinalProductManufactured.physicalCharacteristics'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProductManufactured.otherCharacteristics') do
      result.otherCharacteristicsList.Add(parseCodeableConcept(item));
end;

procedure TFHIRTurtleComposer.ComposeMedicinalProductManufactured(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicinalProductManufactured; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicinalProductManufactured'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'MedicinalProductManufactured', 'manufacturedDoseForm', elem.manufacturedDoseFormElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('unitOfPresentation') then
    ComposeCodeableConcept(this, 'MedicinalProductManufactured', 'unitOfPresentation', elem.unitOfPresentationElement, false, -1);{x.2f}
  ComposeQuantity(this, 'MedicinalProductManufactured', 'quantity', elem.quantityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('manufacturer') then
    for i := 0 to elem.manufacturerList.Count - 1 do
      ComposeReference{TFhirOrganization}(this, 'MedicinalProductManufactured', 'manufacturer', elem.manufacturerList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('ingredient') then
    for i := 0 to elem.ingredientList.Count - 1 do
      ComposeReference{TFhirMedicinalProductIngredient}(this, 'MedicinalProductManufactured', 'ingredient', elem.ingredientList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('physicalCharacteristics') then
    ComposeProdCharacteristic(this, 'MedicinalProductManufactured', 'physicalCharacteristics', elem.physicalCharacteristicsElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('otherCharacteristics') then
    for i := 0 to elem.otherCharacteristicsList.Count - 1 do
      ComposeCodeableConcept(this, 'MedicinalProductManufactured', 'otherCharacteristics', elem.otherCharacteristicsList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_MEDICINALPRODUCTMANUFACTURED}
{$IFDEF FHIR_MEDICINALPRODUCTPACKAGED}
function TFHIRTurtleParser.ParseMedicinalProductPackagedBatchIdentifier(obj : TTurtleComplex) : TFhirMedicinalProductPackagedBatchIdentifier;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicinalProductPackagedBatchIdentifier.create;
  try
    ParseMedicinalProductPackagedBatchIdentifierProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicinalProductPackagedBatchIdentifierProperties(obj : TTurtleComplex; result : TFhirMedicinalProductPackagedBatchIdentifier);
begin
    ParseBackboneElementProperties(obj, result);
    result.outerPackaging := ParseIdentifier(obj.complex('http://hl7.org/fhir/MedicinalProductPackaged.batchIdentifier.outerPackaging'));{q3b}
    result.immediatePackaging := ParseIdentifier(obj.complex('http://hl7.org/fhir/MedicinalProductPackaged.batchIdentifier.immediatePackaging'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeMedicinalProductPackagedBatchIdentifier(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicinalProductPackagedBatchIdentifier; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicinalProductPackagedBatchIdentifier'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeIdentifier(this, 'MedicinalProductPackaged.batchIdentifier', 'outerPackaging', elem.outerPackagingElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'MedicinalProductPackaged.batchIdentifier', 'immediatePackaging', elem.immediatePackagingElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseMedicinalProductPackagedPackageItem(obj : TTurtleComplex) : TFhirMedicinalProductPackagedPackageItem;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicinalProductPackagedPackageItem.create;
  try
    ParseMedicinalProductPackagedPackageItemProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicinalProductPackagedPackageItemProperties(obj : TTurtleComplex; result : TFhirMedicinalProductPackagedPackageItem);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProductPackaged.packageItem.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicinalProductPackaged.packageItem.type'));{q3b}
    result.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/MedicinalProductPackaged.packageItem.quantity'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProductPackaged.packageItem.material') do
      result.materialList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProductPackaged.packageItem.alternateMaterial') do
      result.alternateMaterialList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProductPackaged.packageItem.device') do
      result.deviceList.Add(parseReference{TFhirDeviceDefinition}(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProductPackaged.packageItem.manufacturedItem') do
      result.manufacturedItemList.Add(parseReference{TFhirMedicinalProductManufactured}(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProductPackaged.packageItem.packageItem') do
      result.packageItemList.Add(parseMedicinalProductPackagedPackageItem(item));
    result.physicalCharacteristics := ParseProdCharacteristic(obj.complex('http://hl7.org/fhir/MedicinalProductPackaged.packageItem.physicalCharacteristics'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProductPackaged.packageItem.otherCharacteristics') do
      result.otherCharacteristicsList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProductPackaged.packageItem.shelfLifeStorage') do
      result.shelfLifeStorageList.Add(parseProductShelfLife(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProductPackaged.packageItem.manufacturer') do
      result.manufacturerList.Add(parseReference{TFhirOrganization}(item));
end;

procedure TFHIRTurtleComposer.ComposeMedicinalProductPackagedPackageItem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicinalProductPackagedPackageItem; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicinalProductPackagedPackageItem'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'MedicinalProductPackaged.packageItem', 'identifier', elem.identifierList[i], false, i);{x.d3}
  ComposeCodeableConcept(this, 'MedicinalProductPackaged.packageItem', 'type', elem.type_Element, false, -1);{x.2f}
  ComposeQuantity(this, 'MedicinalProductPackaged.packageItem', 'quantity', elem.quantityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.materialList.Count - 1 do
      ComposeCodeableConcept(this, 'MedicinalProductPackaged.packageItem', 'material', elem.materialList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.alternateMaterialList.Count - 1 do
      ComposeCodeableConcept(this, 'MedicinalProductPackaged.packageItem', 'alternateMaterial', elem.alternateMaterialList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.deviceList.Count - 1 do
      ComposeReference{TFhirDeviceDefinition}(this, 'MedicinalProductPackaged.packageItem', 'device', elem.deviceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.manufacturedItemList.Count - 1 do
      ComposeReference{TFhirMedicinalProductManufactured}(this, 'MedicinalProductPackaged.packageItem', 'manufacturedItem', elem.manufacturedItemList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.packageItemList.Count - 1 do
      ComposeMedicinalProductPackagedPackageItem(this, 'MedicinalProductPackaged.packageItem', 'packageItem', elem.packageItemList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeProdCharacteristic(this, 'MedicinalProductPackaged.packageItem', 'physicalCharacteristics', elem.physicalCharacteristicsElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.otherCharacteristicsList.Count - 1 do
      ComposeCodeableConcept(this, 'MedicinalProductPackaged.packageItem', 'otherCharacteristics', elem.otherCharacteristicsList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.shelfLifeStorageList.Count - 1 do
      ComposeProductShelfLife(this, 'MedicinalProductPackaged.packageItem', 'shelfLifeStorage', elem.shelfLifeStorageList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.manufacturerList.Count - 1 do
      ComposeReference{TFhirOrganization}(this, 'MedicinalProductPackaged.packageItem', 'manufacturer', elem.manufacturerList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseMedicinalProductPackaged(obj : TTurtleComplex) : TFhirMedicinalProductPackaged;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicinalProductPackaged.create;
  try
    ParseMedicinalProductPackagedProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicinalProductPackagedProperties(obj : TTurtleComplex; result : TFhirMedicinalProductPackaged);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProductPackaged.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProductPackaged.subject') do
      result.subjectList.Add(parseReference{TFhirMedicinalProduct}(item));
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/MedicinalProductPackaged.description'));{q1}
    result.legalStatusOfSupply := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicinalProductPackaged.legalStatusOfSupply'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProductPackaged.marketingStatus') do
      result.marketingStatusList.Add(parseMarketingStatus(item));
    result.marketingAuthorization := ParseReference{TFhirMedicinalProductAuthorization}(obj.complex('http://hl7.org/fhir/MedicinalProductPackaged.marketingAuthorization'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProductPackaged.manufacturer') do
      result.manufacturerList.Add(parseReference{TFhirOrganization}(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProductPackaged.batchIdentifier') do
      result.batchIdentifierList.Add(parseMedicinalProductPackagedBatchIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProductPackaged.packageItem') do
      result.packageItemList.Add(parseMedicinalProductPackagedPackageItem(item));
end;

procedure TFHIRTurtleComposer.ComposeMedicinalProductPackaged(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicinalProductPackaged; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicinalProductPackaged'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'MedicinalProductPackaged', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    for i := 0 to elem.subjectList.Count - 1 do
      ComposeReference{TFhirMedicinalProduct}(this, 'MedicinalProductPackaged', 'subject', elem.subjectList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeString(this, 'MedicinalProductPackaged', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('legalStatusOfSupply') then
    ComposeCodeableConcept(this, 'MedicinalProductPackaged', 'legalStatusOfSupply', elem.legalStatusOfSupplyElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('marketingStatus') then
    for i := 0 to elem.marketingStatusList.Count - 1 do
      ComposeMarketingStatus(this, 'MedicinalProductPackaged', 'marketingStatus', elem.marketingStatusList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('marketingAuthorization') then
    ComposeReference{TFhirMedicinalProductAuthorization}(this, 'MedicinalProductPackaged', 'marketingAuthorization', elem.marketingAuthorizationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('manufacturer') then
    for i := 0 to elem.manufacturerList.Count - 1 do
      ComposeReference{TFhirOrganization}(this, 'MedicinalProductPackaged', 'manufacturer', elem.manufacturerList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('batchIdentifier') then
    for i := 0 to elem.batchIdentifierList.Count - 1 do
      ComposeMedicinalProductPackagedBatchIdentifier(this, 'MedicinalProductPackaged', 'batchIdentifier', elem.batchIdentifierList[i], false, i);{x.d3}
  for i := 0 to elem.packageItemList.Count - 1 do
      ComposeMedicinalProductPackagedPackageItem(this, 'MedicinalProductPackaged', 'packageItem', elem.packageItemList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_MEDICINALPRODUCTPACKAGED}
{$IFDEF FHIR_MEDICINALPRODUCTPHARMACEUTICAL}
function TFHIRTurtleParser.ParseMedicinalProductPharmaceuticalCharacteristics(obj : TTurtleComplex) : TFhirMedicinalProductPharmaceuticalCharacteristics;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicinalProductPharmaceuticalCharacteristics.create;
  try
    ParseMedicinalProductPharmaceuticalCharacteristicsProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicinalProductPharmaceuticalCharacteristicsProperties(obj : TTurtleComplex; result : TFhirMedicinalProductPharmaceuticalCharacteristics);
begin
    ParseBackboneElementProperties(obj, result);
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicinalProductPharmaceutical.characteristics.code'));{q3b}
    result.status := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicinalProductPharmaceutical.characteristics.status'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeMedicinalProductPharmaceuticalCharacteristics(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicinalProductPharmaceuticalCharacteristics; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicinalProductPharmaceuticalCharacteristics'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'MedicinalProductPharmaceutical.characteristics', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'MedicinalProductPharmaceutical.characteristics', 'status', elem.statusElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseMedicinalProductPharmaceuticalRouteOfAdministration(obj : TTurtleComplex) : TFhirMedicinalProductPharmaceuticalRouteOfAdministration;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicinalProductPharmaceuticalRouteOfAdministration.create;
  try
    ParseMedicinalProductPharmaceuticalRouteOfAdministrationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicinalProductPharmaceuticalRouteOfAdministrationProperties(obj : TTurtleComplex; result : TFhirMedicinalProductPharmaceuticalRouteOfAdministration);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicinalProductPharmaceutical.routeOfAdministration.code'));{q3b}
    result.firstDose := ParseQuantity(obj.complex('http://hl7.org/fhir/MedicinalProductPharmaceutical.routeOfAdministration.firstDose'));{q3b}
    result.maxSingleDose := ParseQuantity(obj.complex('http://hl7.org/fhir/MedicinalProductPharmaceutical.routeOfAdministration.maxSingleDose'));{q3b}
    result.maxDosePerDay := ParseQuantity(obj.complex('http://hl7.org/fhir/MedicinalProductPharmaceutical.routeOfAdministration.maxDosePerDay'));{q3b}
    result.maxDosePerTreatmentPeriod := ParseRatio(obj.complex('http://hl7.org/fhir/MedicinalProductPharmaceutical.routeOfAdministration.maxDosePerTreatmentPeriod'));{q3b}
    result.maxTreatmentPeriod := ParseDuration(obj.complex('http://hl7.org/fhir/MedicinalProductPharmaceutical.routeOfAdministration.maxTreatmentPeriod'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProductPharmaceutical.routeOfAdministration.targetSpecies') do
      result.targetSpeciesList.Add(parseMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies(item));
end;

procedure TFHIRTurtleComposer.ComposeMedicinalProductPharmaceuticalRouteOfAdministration(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicinalProductPharmaceuticalRouteOfAdministration; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicinalProductPharmaceuticalRouteOfAdministration'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'MedicinalProductPharmaceutical.routeOfAdministration', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'MedicinalProductPharmaceutical.routeOfAdministration', 'firstDose', elem.firstDoseElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'MedicinalProductPharmaceutical.routeOfAdministration', 'maxSingleDose', elem.maxSingleDoseElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'MedicinalProductPharmaceutical.routeOfAdministration', 'maxDosePerDay', elem.maxDosePerDayElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeRatio(this, 'MedicinalProductPharmaceutical.routeOfAdministration', 'maxDosePerTreatmentPeriod', elem.maxDosePerTreatmentPeriodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDuration(this, 'MedicinalProductPharmaceutical.routeOfAdministration', 'maxTreatmentPeriod', elem.maxTreatmentPeriodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.targetSpeciesList.Count - 1 do
      ComposeMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies(this, 'MedicinalProductPharmaceutical.routeOfAdministration', 'targetSpecies', elem.targetSpeciesList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies(obj : TTurtleComplex) : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies.create;
  try
    ParseMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesProperties(obj : TTurtleComplex; result : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicinalProductPharmaceutical.routeOfAdministration.targetSpecies.code'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProductPharmaceutical.routeOfAdministration.targetSpecies.withdrawalPeriod') do
      result.withdrawalPeriodList.Add(parseMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod(item));
end;

procedure TFHIRTurtleComposer.ComposeMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'MedicinalProductPharmaceutical.routeOfAdministration.targetSpecies', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.withdrawalPeriodList.Count - 1 do
      ComposeMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod(this, 'MedicinalProductPharmaceutical.routeOfAdministration.targetSpecies', 'withdrawalPeriod', elem.withdrawalPeriodList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod(obj : TTurtleComplex) : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod.create;
  try
    ParseMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriodProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriodProperties(obj : TTurtleComplex; result : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod);
begin
    ParseBackboneElementProperties(obj, result);
    result.tissue := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicinalProductPharmaceutical.routeOfAdministration.targetSpecies.withdrawalPeriod.tissue'));{q3b}
    result.value := ParseQuantity(obj.complex('http://hl7.org/fhir/MedicinalProductPharmaceutical.routeOfAdministration.targetSpecies.withdrawalPeriod.value'));{q3b}
    result.supportingInformationElement := ParseString(obj.complex('http://hl7.org/fhir/MedicinalProductPharmaceutical.routeOfAdministration.targetSpecies.withdrawalPeriod.supportingInformation'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'MedicinalProductPharmaceutical.routeOfAdministration.targetSpecies.withdrawalPeriod', 'tissue', elem.tissueElement, false, -1);{x.2f}
  ComposeQuantity(this, 'MedicinalProductPharmaceutical.routeOfAdministration.targetSpecies.withdrawalPeriod', 'value', elem.valueElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'MedicinalProductPharmaceutical.routeOfAdministration.targetSpecies.withdrawalPeriod', 'supportingInformation', elem.supportingInformationElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseMedicinalProductPharmaceutical(obj : TTurtleComplex) : TFhirMedicinalProductPharmaceutical;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicinalProductPharmaceutical.create;
  try
    ParseMedicinalProductPharmaceuticalProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicinalProductPharmaceuticalProperties(obj : TTurtleComplex; result : TFhirMedicinalProductPharmaceutical);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProductPharmaceutical.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.administrableDoseForm := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicinalProductPharmaceutical.administrableDoseForm'));{q3b}
    result.unitOfPresentation := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicinalProductPharmaceutical.unitOfPresentation'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProductPharmaceutical.ingredient') do
      result.ingredientList.Add(parseReference{TFhirMedicinalProductIngredient}(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProductPharmaceutical.device') do
      result.deviceList.Add(parseReference{TFhirDeviceDefinition}(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProductPharmaceutical.characteristics') do
      result.characteristicsList.Add(parseMedicinalProductPharmaceuticalCharacteristics(item));
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProductPharmaceutical.routeOfAdministration') do
      result.routeOfAdministrationList.Add(parseMedicinalProductPharmaceuticalRouteOfAdministration(item));
end;

procedure TFHIRTurtleComposer.ComposeMedicinalProductPharmaceutical(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicinalProductPharmaceutical; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicinalProductPharmaceutical'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'MedicinalProductPharmaceutical', 'identifier', elem.identifierList[i], false, i);{x.d3}
  ComposeCodeableConcept(this, 'MedicinalProductPharmaceutical', 'administrableDoseForm', elem.administrableDoseFormElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('unitOfPresentation') then
    ComposeCodeableConcept(this, 'MedicinalProductPharmaceutical', 'unitOfPresentation', elem.unitOfPresentationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('ingredient') then
    for i := 0 to elem.ingredientList.Count - 1 do
      ComposeReference{TFhirMedicinalProductIngredient}(this, 'MedicinalProductPharmaceutical', 'ingredient', elem.ingredientList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('device') then
    for i := 0 to elem.deviceList.Count - 1 do
      ComposeReference{TFhirDeviceDefinition}(this, 'MedicinalProductPharmaceutical', 'device', elem.deviceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('characteristics') then
    for i := 0 to elem.characteristicsList.Count - 1 do
      ComposeMedicinalProductPharmaceuticalCharacteristics(this, 'MedicinalProductPharmaceutical', 'characteristics', elem.characteristicsList[i], false, i);{x.d3}
  for i := 0 to elem.routeOfAdministrationList.Count - 1 do
      ComposeMedicinalProductPharmaceuticalRouteOfAdministration(this, 'MedicinalProductPharmaceutical', 'routeOfAdministration', elem.routeOfAdministrationList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_MEDICINALPRODUCTPHARMACEUTICAL}
{$IFDEF FHIR_MEDICINALPRODUCTUNDESIRABLEEFFECT}
function TFHIRTurtleParser.ParseMedicinalProductUndesirableEffect(obj : TTurtleComplex) : TFhirMedicinalProductUndesirableEffect;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMedicinalProductUndesirableEffect.create;
  try
    ParseMedicinalProductUndesirableEffectProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMedicinalProductUndesirableEffectProperties(obj : TTurtleComplex; result : TFhirMedicinalProductUndesirableEffect);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProductUndesirableEffect.subject') do
      result.subjectList.Add(parseReference{TFhirMedicinalProduct}(item));
    result.symptomConditionEffect := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicinalProductUndesirableEffect.symptomConditionEffect'));{q3b}
    result.classification := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicinalProductUndesirableEffect.classification'));{q3b}
    result.frequencyOfOccurrence := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MedicinalProductUndesirableEffect.frequencyOfOccurrence'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/MedicinalProductUndesirableEffect.population') do
      result.populationList.Add(parsePopulation(item));
end;

procedure TFHIRTurtleComposer.ComposeMedicinalProductUndesirableEffect(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMedicinalProductUndesirableEffect; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MedicinalProductUndesirableEffect'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    for i := 0 to elem.subjectList.Count - 1 do
      ComposeReference{TFhirMedicinalProduct}(this, 'MedicinalProductUndesirableEffect', 'subject', elem.subjectList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('symptomConditionEffect') then
    ComposeCodeableConcept(this, 'MedicinalProductUndesirableEffect', 'symptomConditionEffect', elem.symptomConditionEffectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('classification') then
    ComposeCodeableConcept(this, 'MedicinalProductUndesirableEffect', 'classification', elem.classificationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('frequencyOfOccurrence') then
    ComposeCodeableConcept(this, 'MedicinalProductUndesirableEffect', 'frequencyOfOccurrence', elem.frequencyOfOccurrenceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('population') then
    for i := 0 to elem.populationList.Count - 1 do
      ComposePopulation(this, 'MedicinalProductUndesirableEffect', 'population', elem.populationList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_MEDICINALPRODUCTUNDESIRABLEEFFECT}
{$IFDEF FHIR_MESSAGEDEFINITION}
function TFHIRTurtleParser.ParseMessageDefinitionFocus(obj : TTurtleComplex) : TFhirMessageDefinitionFocus;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMessageDefinitionFocus.create;
  try
    ParseMessageDefinitionFocusProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMessageDefinitionFocusProperties(obj : TTurtleComplex; result : TFhirMessageDefinitionFocus);
begin
    ParseBackboneElementProperties(obj, result);
    result.codeElement := ParseEnum(obj.complex('http://hl7.org/fhir/MessageDefinition.focus.code'), CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum);
    result.profileElement := ParseCanonical(obj.complex('http://hl7.org/fhir/MessageDefinition.focus.profile'));{q1}
    result.minElement := ParseUnsignedInt(obj.complex('http://hl7.org/fhir/MessageDefinition.focus.min'));{q1}
    result.maxElement := ParseString(obj.complex('http://hl7.org/fhir/MessageDefinition.focus.max'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeMessageDefinitionFocus(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMessageDefinitionFocus; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MessageDefinitionFocus'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'MessageDefinition.focus', 'code', elem.CodeElement, CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(this, 'MessageDefinition.focus', 'profile', elem.profileElement, false, -1);{x.2ea}
  ComposeUnsignedInt(this, 'MessageDefinition.focus', 'min', elem.minElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'MessageDefinition.focus', 'max', elem.maxElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseMessageDefinitionAllowedResponse(obj : TTurtleComplex) : TFhirMessageDefinitionAllowedResponse;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMessageDefinitionAllowedResponse.create;
  try
    ParseMessageDefinitionAllowedResponseProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMessageDefinitionAllowedResponseProperties(obj : TTurtleComplex; result : TFhirMessageDefinitionAllowedResponse);
begin
    ParseBackboneElementProperties(obj, result);
    result.messageElement := ParseCanonical(obj.complex('http://hl7.org/fhir/MessageDefinition.allowedResponse.message'));{q1}
    result.situationElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/MessageDefinition.allowedResponse.situation'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeMessageDefinitionAllowedResponse(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMessageDefinitionAllowedResponse; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MessageDefinitionAllowedResponse'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCanonical(this, 'MessageDefinition.allowedResponse', 'message', elem.messageElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'MessageDefinition.allowedResponse', 'situation', elem.situationElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseMessageDefinition(obj : TTurtleComplex) : TFhirMessageDefinition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMessageDefinition.create;
  try
    ParseMessageDefinitionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMessageDefinitionProperties(obj : TTurtleComplex; result : TFhirMessageDefinition);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/MessageDefinition.url'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/MessageDefinition.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/MessageDefinition.version'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/MessageDefinition.name'));{q1}
    result.titleElement := ParseString(obj.complex('http://hl7.org/fhir/MessageDefinition.title'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/MessageDefinition.replaces') do
      result.replacesList.Add(parseCanonical(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/MessageDefinition.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    result.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/MessageDefinition.experimental'));{q1}
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/MessageDefinition.date'));{q1}
    result.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/MessageDefinition.publisher'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/MessageDefinition.contact') do
      result.contactList.Add(parseContactDetail(item));
    result.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/MessageDefinition.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/MessageDefinition.useContext') do
      result.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/MessageDefinition.jurisdiction') do
      result.jurisdictionList.Add(parseCodeableConcept(item));
    result.purposeElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/MessageDefinition.purpose'));{q1}
    result.copyrightElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/MessageDefinition.copyright'));{q1}
    result.baseElement := ParseCanonical(obj.complex('http://hl7.org/fhir/MessageDefinition.base'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/MessageDefinition.parent') do
      result.parentList.Add(parseCanonical(item));
    if obj.has('http://hl7.org/fhir/MessageDefinition.eventCoding', item) then
      result.event := parseCoding(item);
    if obj.has('http://hl7.org/fhir/MessageDefinition.eventUri', item) then
      result.event := parseUri(item);
    result.categoryElement := ParseEnum(obj.complex('http://hl7.org/fhir/MessageDefinition.category'), CODES_TFhirMessageSignificanceCategoryEnum, SYSTEMS_TFhirMessageSignificanceCategoryEnum);
    for item in obj.complexes('http://hl7.org/fhir/MessageDefinition.focus') do
      result.focusList.Add(parseMessageDefinitionFocus(item));
    result.responseRequiredElement := ParseEnum(obj.complex('http://hl7.org/fhir/MessageDefinition.responseRequired'), CODES_TFhirMessageheaderResponseRequestEnum, SYSTEMS_TFhirMessageheaderResponseRequestEnum);
    for item in obj.complexes('http://hl7.org/fhir/MessageDefinition.allowedResponse') do
      result.allowedResponseList.Add(parseMessageDefinitionAllowedResponse(item));
    for item in obj.complexes('http://hl7.org/fhir/MessageDefinition.graph') do
      result.graphList.Add(parseCanonical(item));
end;

procedure TFHIRTurtleComposer.ComposeMessageDefinition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMessageDefinition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MessageDefinition'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUri(this, 'MessageDefinition', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'MessageDefinition', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(this, 'MessageDefinition', 'version', elem.versionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(this, 'MessageDefinition', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeString(this, 'MessageDefinition', 'title', elem.titleElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('replaces') then
    for i := 0 to elem.replacesList.Count - 1 do
      ComposeCanonical(this, 'MessageDefinition', 'replaces', elem.replacesList[i], false, i);{x.d3}
  ComposeEnum(this, 'MessageDefinition', 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(this, 'MessageDefinition', 'experimental', elem.experimentalElement, false, -1);{x.2ea}
  ComposeDateTime(this, 'MessageDefinition', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(this, 'MessageDefinition', 'publisher', elem.publisherElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(this, 'MessageDefinition', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeMarkdown(this, 'MessageDefinition', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(this, 'MessageDefinition', 'useContext', elem.useContextList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'MessageDefinition', 'jurisdiction', elem.jurisdictionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('purpose') then
    ComposeMarkdown(this, 'MessageDefinition', 'purpose', elem.purposeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdown(this, 'MessageDefinition', 'copyright', elem.copyrightElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('base') then
    ComposeCanonical(this, 'MessageDefinition', 'base', elem.baseElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('parent') then
    for i := 0 to elem.parentList.Count - 1 do
      ComposeCanonical(this, 'MessageDefinition', 'parent', elem.parentList[i], false, i);{x.d3}
  if (elem.event is TFhirCoding) {6} then
    ComposeCoding(this, 'MessageDefinition', 'eventCoding', TFhirCoding(elem.event), false, -1){x.d9}
  else if (elem.event is TFhirUri) {6} then
    ComposeUri(this, 'MessageDefinition', 'eventUri', TFhirUri(elem.event), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    ComposeEnum(this, 'MessageDefinition', 'category', elem.CategoryElement, CODES_TFhirMessageSignificanceCategoryEnum, SYSTEMS_TFhirMessageSignificanceCategoryEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('focus') then
    for i := 0 to elem.focusList.Count - 1 do
      ComposeMessageDefinitionFocus(this, 'MessageDefinition', 'focus', elem.focusList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('responseRequired') then
    ComposeEnum(this, 'MessageDefinition', 'responseRequired', elem.ResponseRequiredElement, CODES_TFhirMessageheaderResponseRequestEnum, SYSTEMS_TFhirMessageheaderResponseRequestEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('allowedResponse') then
    for i := 0 to elem.allowedResponseList.Count - 1 do
      ComposeMessageDefinitionAllowedResponse(this, 'MessageDefinition', 'allowedResponse', elem.allowedResponseList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('graph') then
    for i := 0 to elem.graphList.Count - 1 do
      ComposeCanonical(this, 'MessageDefinition', 'graph', elem.graphList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_MESSAGEDEFINITION}
{$IFDEF FHIR_MESSAGEHEADER}
function TFHIRTurtleParser.ParseMessageHeaderDestination(obj : TTurtleComplex) : TFhirMessageHeaderDestination;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMessageHeaderDestination.create;
  try
    ParseMessageHeaderDestinationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMessageHeaderDestinationProperties(obj : TTurtleComplex; result : TFhirMessageHeaderDestination);
begin
    ParseBackboneElementProperties(obj, result);
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/MessageHeader.destination.name'));{q1}
    result.target := ParseReference{TFhirDevice}(obj.complex('http://hl7.org/fhir/MessageHeader.destination.target'));{q3b}
    result.endpointElement := ParseUrl(obj.complex('http://hl7.org/fhir/MessageHeader.destination.endpoint'));{q1}
    result.receiver := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/MessageHeader.destination.receiver'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeMessageHeaderDestination(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMessageHeaderDestination; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MessageHeaderDestination'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'MessageHeader.destination', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirDevice}(this, 'MessageHeader.destination', 'target', elem.targetElement, false, -1);{x.2f}
  ComposeUrl(this, 'MessageHeader.destination', 'endpoint', elem.endpointElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(this, 'MessageHeader.destination', 'receiver', elem.receiverElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseMessageHeaderSource(obj : TTurtleComplex) : TFhirMessageHeaderSource;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMessageHeaderSource.create;
  try
    ParseMessageHeaderSourceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMessageHeaderSourceProperties(obj : TTurtleComplex; result : TFhirMessageHeaderSource);
begin
    ParseBackboneElementProperties(obj, result);
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/MessageHeader.source.name'));{q1}
    result.softwareElement := ParseString(obj.complex('http://hl7.org/fhir/MessageHeader.source.software'));{q1}
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/MessageHeader.source.version'));{q1}
    result.contact := ParseContactPoint(obj.complex('http://hl7.org/fhir/MessageHeader.source.contact'));{q3b}
    result.endpointElement := ParseUrl(obj.complex('http://hl7.org/fhir/MessageHeader.source.endpoint'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeMessageHeaderSource(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMessageHeaderSource; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MessageHeaderSource'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'MessageHeader.source', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'MessageHeader.source', 'software', elem.softwareElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'MessageHeader.source', 'version', elem.versionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeContactPoint(this, 'MessageHeader.source', 'contact', elem.contactElement, false, -1);{x.2f}
  ComposeUrl(this, 'MessageHeader.source', 'endpoint', elem.endpointElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseMessageHeaderResponse(obj : TTurtleComplex) : TFhirMessageHeaderResponse;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMessageHeaderResponse.create;
  try
    ParseMessageHeaderResponseProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMessageHeaderResponseProperties(obj : TTurtleComplex; result : TFhirMessageHeaderResponse);
begin
    ParseBackboneElementProperties(obj, result);
    result.identifierElement := ParseId(obj.complex('http://hl7.org/fhir/MessageHeader.response.identifier'));{q1}
    result.codeElement := ParseEnum(obj.complex('http://hl7.org/fhir/MessageHeader.response.code'), CODES_TFhirResponseCodeEnum, SYSTEMS_TFhirResponseCodeEnum);
    result.details := ParseReference{TFhirOperationOutcome}(obj.complex('http://hl7.org/fhir/MessageHeader.response.details'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeMessageHeaderResponse(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMessageHeaderResponse; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MessageHeaderResponse'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeId(this, 'MessageHeader.response', 'identifier', elem.identifierElement, false, -1);{x.2ea}
  ComposeEnum(this, 'MessageHeader.response', 'code', elem.CodeElement, CODES_TFhirResponseCodeEnum, SYSTEMS_TFhirResponseCodeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOperationOutcome}(this, 'MessageHeader.response', 'details', elem.detailsElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseMessageHeader(obj : TTurtleComplex) : TFhirMessageHeader;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMessageHeader.create;
  try
    ParseMessageHeaderProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMessageHeaderProperties(obj : TTurtleComplex; result : TFhirMessageHeader);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    if obj.has('http://hl7.org/fhir/MessageHeader.eventCoding', item) then
      result.event := parseCoding(item);
    if obj.has('http://hl7.org/fhir/MessageHeader.eventUri', item) then
      result.event := parseUri(item);
    for item in obj.complexes('http://hl7.org/fhir/MessageHeader.destination') do
      result.destinationList.Add(parseMessageHeaderDestination(item));
    result.sender := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/MessageHeader.sender'));{q3b}
    result.enterer := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/MessageHeader.enterer'));{q3b}
    result.author := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/MessageHeader.author'));{q3b}
    result.source := ParseMessageHeaderSource(obj.complex('http://hl7.org/fhir/MessageHeader.source'));{q3b}
    result.responsible := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/MessageHeader.responsible'));{q3b}
    result.reason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MessageHeader.reason'));{q3b}
    result.response := ParseMessageHeaderResponse(obj.complex('http://hl7.org/fhir/MessageHeader.response'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/MessageHeader.focus') do
      result.focusList.Add(parseReference{TFhirReference}(item));
    result.definitionElement := ParseCanonical(obj.complex('http://hl7.org/fhir/MessageHeader.definition'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeMessageHeader(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMessageHeader; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MessageHeader'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (elem.event is TFhirCoding) {6} then
    ComposeCoding(this, 'MessageHeader', 'eventCoding', TFhirCoding(elem.event), false, -1){x.d9}
  else if (elem.event is TFhirUri) {6} then
    ComposeUri(this, 'MessageHeader', 'eventUri', TFhirUri(elem.event), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('destination') then
    for i := 0 to elem.destinationList.Count - 1 do
      ComposeMessageHeaderDestination(this, 'MessageHeader', 'destination', elem.destinationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('sender') then
    ComposeReference{TFhirPractitioner}(this, 'MessageHeader', 'sender', elem.senderElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('enterer') then
    ComposeReference{TFhirPractitioner}(this, 'MessageHeader', 'enterer', elem.entererElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('author') then
    ComposeReference{TFhirPractitioner}(this, 'MessageHeader', 'author', elem.authorElement, false, -1);{x.2f}
  ComposeMessageHeaderSource(this, 'MessageHeader', 'source', elem.sourceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('responsible') then
    ComposeReference{TFhirPractitioner}(this, 'MessageHeader', 'responsible', elem.responsibleElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reason') then
    ComposeCodeableConcept(this, 'MessageHeader', 'reason', elem.reasonElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('response') then
    ComposeMessageHeaderResponse(this, 'MessageHeader', 'response', elem.responseElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('focus') then
    for i := 0 to elem.focusList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'MessageHeader', 'focus', elem.focusList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('definition') then
    ComposeCanonical(this, 'MessageHeader', 'definition', elem.definitionElement, false, -1);{x.2ea}
end;

{$ENDIF FHIR_MESSAGEHEADER}
{$IFDEF FHIR_MOLECULARSEQUENCE}
function TFHIRTurtleParser.ParseMolecularSequenceReferenceSeq(obj : TTurtleComplex) : TFhirMolecularSequenceReferenceSeq;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMolecularSequenceReferenceSeq.create;
  try
    ParseMolecularSequenceReferenceSeqProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMolecularSequenceReferenceSeqProperties(obj : TTurtleComplex; result : TFhirMolecularSequenceReferenceSeq);
begin
    ParseBackboneElementProperties(obj, result);
    result.chromosome := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MolecularSequence.referenceSeq.chromosome'));{q3b}
    result.genomeBuildElement := ParseString(obj.complex('http://hl7.org/fhir/MolecularSequence.referenceSeq.genomeBuild'));{q1}
    result.orientationElement := ParseEnum(obj.complex('http://hl7.org/fhir/MolecularSequence.referenceSeq.orientation'), CODES_TFhirOrientationTypeEnum, SYSTEMS_TFhirOrientationTypeEnum);
    result.referenceSeqId := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MolecularSequence.referenceSeq.referenceSeqId'));{q3b}
    result.referenceSeqPointer := ParseReference{TFhirMolecularSequence}(obj.complex('http://hl7.org/fhir/MolecularSequence.referenceSeq.referenceSeqPointer'));{q3b}
    result.referenceSeqStringElement := ParseString(obj.complex('http://hl7.org/fhir/MolecularSequence.referenceSeq.referenceSeqString'));{q1}
    result.strandElement := ParseEnum(obj.complex('http://hl7.org/fhir/MolecularSequence.referenceSeq.strand'), CODES_TFhirStrandTypeEnum, SYSTEMS_TFhirStrandTypeEnum);
    result.windowStartElement := ParseInteger(obj.complex('http://hl7.org/fhir/MolecularSequence.referenceSeq.windowStart'));{q1}
    result.windowEndElement := ParseInteger(obj.complex('http://hl7.org/fhir/MolecularSequence.referenceSeq.windowEnd'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeMolecularSequenceReferenceSeq(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMolecularSequenceReferenceSeq; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MolecularSequenceReferenceSeq'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'MolecularSequence.referenceSeq', 'chromosome', elem.chromosomeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'MolecularSequence.referenceSeq', 'genomeBuild', elem.genomeBuildElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'MolecularSequence.referenceSeq', 'orientation', elem.OrientationElement, CODES_TFhirOrientationTypeEnum, SYSTEMS_TFhirOrientationTypeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'MolecularSequence.referenceSeq', 'referenceSeqId', elem.referenceSeqIdElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirMolecularSequence}(this, 'MolecularSequence.referenceSeq', 'referenceSeqPointer', elem.referenceSeqPointerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'MolecularSequence.referenceSeq', 'referenceSeqString', elem.referenceSeqStringElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'MolecularSequence.referenceSeq', 'strand', elem.StrandElement, CODES_TFhirStrandTypeEnum, SYSTEMS_TFhirStrandTypeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(this, 'MolecularSequence.referenceSeq', 'windowStart', elem.windowStartElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(this, 'MolecularSequence.referenceSeq', 'windowEnd', elem.windowEndElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseMolecularSequenceVariant(obj : TTurtleComplex) : TFhirMolecularSequenceVariant;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMolecularSequenceVariant.create;
  try
    ParseMolecularSequenceVariantProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMolecularSequenceVariantProperties(obj : TTurtleComplex; result : TFhirMolecularSequenceVariant);
begin
    ParseBackboneElementProperties(obj, result);
    result.startElement := ParseInteger(obj.complex('http://hl7.org/fhir/MolecularSequence.variant.start'));{q1}
    result.end_Element := ParseInteger(obj.complex('http://hl7.org/fhir/MolecularSequence.variant.end'));{q1}
    result.observedAlleleElement := ParseString(obj.complex('http://hl7.org/fhir/MolecularSequence.variant.observedAllele'));{q1}
    result.referenceAlleleElement := ParseString(obj.complex('http://hl7.org/fhir/MolecularSequence.variant.referenceAllele'));{q1}
    result.cigarElement := ParseString(obj.complex('http://hl7.org/fhir/MolecularSequence.variant.cigar'));{q1}
    result.variantPointer := ParseReference{TFhirObservation}(obj.complex('http://hl7.org/fhir/MolecularSequence.variant.variantPointer'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeMolecularSequenceVariant(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMolecularSequenceVariant; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MolecularSequenceVariant'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(this, 'MolecularSequence.variant', 'start', elem.startElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(this, 'MolecularSequence.variant', 'end', elem.end_Element, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'MolecularSequence.variant', 'observedAllele', elem.observedAlleleElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'MolecularSequence.variant', 'referenceAllele', elem.referenceAlleleElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'MolecularSequence.variant', 'cigar', elem.cigarElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirObservation}(this, 'MolecularSequence.variant', 'variantPointer', elem.variantPointerElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseMolecularSequenceQuality(obj : TTurtleComplex) : TFhirMolecularSequenceQuality;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMolecularSequenceQuality.create;
  try
    ParseMolecularSequenceQualityProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMolecularSequenceQualityProperties(obj : TTurtleComplex; result : TFhirMolecularSequenceQuality);
begin
    ParseBackboneElementProperties(obj, result);
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/MolecularSequence.quality.type'), CODES_TFhirQualityTypeEnum, SYSTEMS_TFhirQualityTypeEnum);
    result.standardSequence := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MolecularSequence.quality.standardSequence'));{q3b}
    result.startElement := ParseInteger(obj.complex('http://hl7.org/fhir/MolecularSequence.quality.start'));{q1}
    result.end_Element := ParseInteger(obj.complex('http://hl7.org/fhir/MolecularSequence.quality.end'));{q1}
    result.score := ParseQuantity(obj.complex('http://hl7.org/fhir/MolecularSequence.quality.score'));{q3b}
    result.method := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MolecularSequence.quality.method'));{q3b}
    result.truthTPElement := ParseDecimal(obj.complex('http://hl7.org/fhir/MolecularSequence.quality.truthTP'));{q1}
    result.queryTPElement := ParseDecimal(obj.complex('http://hl7.org/fhir/MolecularSequence.quality.queryTP'));{q1}
    result.truthFNElement := ParseDecimal(obj.complex('http://hl7.org/fhir/MolecularSequence.quality.truthFN'));{q1}
    result.queryFPElement := ParseDecimal(obj.complex('http://hl7.org/fhir/MolecularSequence.quality.queryFP'));{q1}
    result.gtFPElement := ParseDecimal(obj.complex('http://hl7.org/fhir/MolecularSequence.quality.gtFP'));{q1}
    result.precisionElement := ParseDecimal(obj.complex('http://hl7.org/fhir/MolecularSequence.quality.precision'));{q1}
    result.recallElement := ParseDecimal(obj.complex('http://hl7.org/fhir/MolecularSequence.quality.recall'));{q1}
    result.fScore_Element := ParseDecimal(obj.complex('http://hl7.org/fhir/MolecularSequence.quality.fScore'));{q1}
    result.roc := ParseMolecularSequenceQualityRoc(obj.complex('http://hl7.org/fhir/MolecularSequence.quality.roc'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeMolecularSequenceQuality(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMolecularSequenceQuality; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MolecularSequenceQuality'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'MolecularSequence.quality', 'type', elem.Type_Element, CODES_TFhirQualityTypeEnum, SYSTEMS_TFhirQualityTypeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'MolecularSequence.quality', 'standardSequence', elem.standardSequenceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(this, 'MolecularSequence.quality', 'start', elem.startElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(this, 'MolecularSequence.quality', 'end', elem.end_Element, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'MolecularSequence.quality', 'score', elem.scoreElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'MolecularSequence.quality', 'method', elem.methodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'MolecularSequence.quality', 'truthTP', elem.truthTPElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'MolecularSequence.quality', 'queryTP', elem.queryTPElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'MolecularSequence.quality', 'truthFN', elem.truthFNElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'MolecularSequence.quality', 'queryFP', elem.queryFPElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'MolecularSequence.quality', 'gtFP', elem.gtFPElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'MolecularSequence.quality', 'precision', elem.precisionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'MolecularSequence.quality', 'recall', elem.recallElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(this, 'MolecularSequence.quality', 'fScore', elem.fScore_Element, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMolecularSequenceQualityRoc(this, 'MolecularSequence.quality', 'roc', elem.rocElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseMolecularSequenceQualityRoc(obj : TTurtleComplex) : TFhirMolecularSequenceQualityRoc;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMolecularSequenceQualityRoc.create;
  try
    ParseMolecularSequenceQualityRocProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMolecularSequenceQualityRocProperties(obj : TTurtleComplex; result : TFhirMolecularSequenceQualityRoc);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/MolecularSequence.quality.roc.score') do
      result.scoreList.Add(parseInteger(item));
    for item in obj.complexes('http://hl7.org/fhir/MolecularSequence.quality.roc.numTP') do
      result.numTPList.Add(parseInteger(item));
    for item in obj.complexes('http://hl7.org/fhir/MolecularSequence.quality.roc.numFP') do
      result.numFPList.Add(parseInteger(item));
    for item in obj.complexes('http://hl7.org/fhir/MolecularSequence.quality.roc.numFN') do
      result.numFNList.Add(parseInteger(item));
    for item in obj.complexes('http://hl7.org/fhir/MolecularSequence.quality.roc.precision') do
      result.precisionList.Add(parseDecimal(item));
    for item in obj.complexes('http://hl7.org/fhir/MolecularSequence.quality.roc.sensitivity') do
      result.sensitivityList.Add(parseDecimal(item));
    for item in obj.complexes('http://hl7.org/fhir/MolecularSequence.quality.roc.fMeasure') do
      result.fMeasureList.Add(parseDecimal(item));
end;

procedure TFHIRTurtleComposer.ComposeMolecularSequenceQualityRoc(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMolecularSequenceQualityRoc; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MolecularSequenceQualityRoc'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.scoreList.Count - 1 do
      ComposeInteger(this, 'MolecularSequence.quality.roc', 'score', elem.scoreList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.numTPList.Count - 1 do
      ComposeInteger(this, 'MolecularSequence.quality.roc', 'numTP', elem.numTPList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.numFPList.Count - 1 do
      ComposeInteger(this, 'MolecularSequence.quality.roc', 'numFP', elem.numFPList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.numFNList.Count - 1 do
      ComposeInteger(this, 'MolecularSequence.quality.roc', 'numFN', elem.numFNList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.precisionList.Count - 1 do
      ComposeDecimal(this, 'MolecularSequence.quality.roc', 'precision', elem.precisionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.sensitivityList.Count - 1 do
      ComposeDecimal(this, 'MolecularSequence.quality.roc', 'sensitivity', elem.sensitivityList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.fMeasureList.Count - 1 do
      ComposeDecimal(this, 'MolecularSequence.quality.roc', 'fMeasure', elem.fMeasureList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseMolecularSequenceRepository(obj : TTurtleComplex) : TFhirMolecularSequenceRepository;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMolecularSequenceRepository.create;
  try
    ParseMolecularSequenceRepositoryProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMolecularSequenceRepositoryProperties(obj : TTurtleComplex; result : TFhirMolecularSequenceRepository);
begin
    ParseBackboneElementProperties(obj, result);
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/MolecularSequence.repository.type'), CODES_TFhirRepositoryTypeEnum, SYSTEMS_TFhirRepositoryTypeEnum);
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/MolecularSequence.repository.url'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/MolecularSequence.repository.name'));{q1}
    result.datasetIdElement := ParseString(obj.complex('http://hl7.org/fhir/MolecularSequence.repository.datasetId'));{q1}
    result.variantsetIdElement := ParseString(obj.complex('http://hl7.org/fhir/MolecularSequence.repository.variantsetId'));{q1}
    result.readsetIdElement := ParseString(obj.complex('http://hl7.org/fhir/MolecularSequence.repository.readsetId'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeMolecularSequenceRepository(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMolecularSequenceRepository; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MolecularSequenceRepository'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'MolecularSequence.repository', 'type', elem.Type_Element, CODES_TFhirRepositoryTypeEnum, SYSTEMS_TFhirRepositoryTypeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'MolecularSequence.repository', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'MolecularSequence.repository', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'MolecularSequence.repository', 'datasetId', elem.datasetIdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'MolecularSequence.repository', 'variantsetId', elem.variantsetIdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'MolecularSequence.repository', 'readsetId', elem.readsetIdElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseMolecularSequenceStructureVariant(obj : TTurtleComplex) : TFhirMolecularSequenceStructureVariant;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMolecularSequenceStructureVariant.create;
  try
    ParseMolecularSequenceStructureVariantProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMolecularSequenceStructureVariantProperties(obj : TTurtleComplex; result : TFhirMolecularSequenceStructureVariant);
begin
    ParseBackboneElementProperties(obj, result);
    result.variantType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/MolecularSequence.structureVariant.variantType'));{q3b}
    result.exactElement := ParseBoolean(obj.complex('http://hl7.org/fhir/MolecularSequence.structureVariant.exact'));{q1}
    result.lengthElement := ParseInteger(obj.complex('http://hl7.org/fhir/MolecularSequence.structureVariant.length'));{q1}
    result.outer := ParseMolecularSequenceStructureVariantOuter(obj.complex('http://hl7.org/fhir/MolecularSequence.structureVariant.outer'));{q3b}
    result.inner := ParseMolecularSequenceStructureVariantInner(obj.complex('http://hl7.org/fhir/MolecularSequence.structureVariant.inner'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeMolecularSequenceStructureVariant(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMolecularSequenceStructureVariant; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MolecularSequenceStructureVariant'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'MolecularSequence.structureVariant', 'variantType', elem.variantTypeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'MolecularSequence.structureVariant', 'exact', elem.exactElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(this, 'MolecularSequence.structureVariant', 'length', elem.lengthElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMolecularSequenceStructureVariantOuter(this, 'MolecularSequence.structureVariant', 'outer', elem.outerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMolecularSequenceStructureVariantInner(this, 'MolecularSequence.structureVariant', 'inner', elem.innerElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseMolecularSequenceStructureVariantOuter(obj : TTurtleComplex) : TFhirMolecularSequenceStructureVariantOuter;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMolecularSequenceStructureVariantOuter.create;
  try
    ParseMolecularSequenceStructureVariantOuterProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMolecularSequenceStructureVariantOuterProperties(obj : TTurtleComplex; result : TFhirMolecularSequenceStructureVariantOuter);
begin
    ParseBackboneElementProperties(obj, result);
    result.startElement := ParseInteger(obj.complex('http://hl7.org/fhir/MolecularSequence.structureVariant.outer.start'));{q1}
    result.end_Element := ParseInteger(obj.complex('http://hl7.org/fhir/MolecularSequence.structureVariant.outer.end'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeMolecularSequenceStructureVariantOuter(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMolecularSequenceStructureVariantOuter; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MolecularSequenceStructureVariantOuter'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(this, 'MolecularSequence.structureVariant.outer', 'start', elem.startElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(this, 'MolecularSequence.structureVariant.outer', 'end', elem.end_Element, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseMolecularSequenceStructureVariantInner(obj : TTurtleComplex) : TFhirMolecularSequenceStructureVariantInner;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMolecularSequenceStructureVariantInner.create;
  try
    ParseMolecularSequenceStructureVariantInnerProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMolecularSequenceStructureVariantInnerProperties(obj : TTurtleComplex; result : TFhirMolecularSequenceStructureVariantInner);
begin
    ParseBackboneElementProperties(obj, result);
    result.startElement := ParseInteger(obj.complex('http://hl7.org/fhir/MolecularSequence.structureVariant.inner.start'));{q1}
    result.end_Element := ParseInteger(obj.complex('http://hl7.org/fhir/MolecularSequence.structureVariant.inner.end'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeMolecularSequenceStructureVariantInner(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMolecularSequenceStructureVariantInner; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MolecularSequenceStructureVariantInner'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(this, 'MolecularSequence.structureVariant.inner', 'start', elem.startElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(this, 'MolecularSequence.structureVariant.inner', 'end', elem.end_Element, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseMolecularSequence(obj : TTurtleComplex) : TFhirMolecularSequence;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirMolecularSequence.create;
  try
    ParseMolecularSequenceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseMolecularSequenceProperties(obj : TTurtleComplex; result : TFhirMolecularSequence);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/MolecularSequence.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/MolecularSequence.type'), CODES_TFhirSequenceTypeEnum, SYSTEMS_TFhirSequenceTypeEnum);
    result.coordinateSystemElement := ParseInteger(obj.complex('http://hl7.org/fhir/MolecularSequence.coordinateSystem'));{q1}
    result.patient := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/MolecularSequence.patient'));{q3b}
    result.specimen := ParseReference{TFhirSpecimen}(obj.complex('http://hl7.org/fhir/MolecularSequence.specimen'));{q3b}
    result.device := ParseReference{TFhirDevice}(obj.complex('http://hl7.org/fhir/MolecularSequence.device'));{q3b}
    result.performer := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/MolecularSequence.performer'));{q3b}
    result.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/MolecularSequence.quantity'));{q3b}
    result.referenceSeq := ParseMolecularSequenceReferenceSeq(obj.complex('http://hl7.org/fhir/MolecularSequence.referenceSeq'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/MolecularSequence.variant') do
      result.variantList.Add(parseMolecularSequenceVariant(item));
    result.observedSeqElement := ParseString(obj.complex('http://hl7.org/fhir/MolecularSequence.observedSeq'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/MolecularSequence.quality') do
      result.qualityList.Add(parseMolecularSequenceQuality(item));
    result.readCoverageElement := ParseInteger(obj.complex('http://hl7.org/fhir/MolecularSequence.readCoverage'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/MolecularSequence.repository') do
      result.repositoryList.Add(parseMolecularSequenceRepository(item));
    for item in obj.complexes('http://hl7.org/fhir/MolecularSequence.pointer') do
      result.pointerList.Add(parseReference{TFhirMolecularSequence}(item));
    for item in obj.complexes('http://hl7.org/fhir/MolecularSequence.structureVariant') do
      result.structureVariantList.Add(parseMolecularSequenceStructureVariant(item));
end;

procedure TFHIRTurtleComposer.ComposeMolecularSequence(parent :  TTurtleComplex; parentType, name : String; elem : TFhirMolecularSequence; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:MolecularSequence'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'MolecularSequence', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeEnum(this, 'MolecularSequence', 'type', elem.Type_Element, CODES_TFhirSequenceTypeEnum, SYSTEMS_TFhirSequenceTypeEnum, false, -1);{x.d4}
  ComposeInteger(this, 'MolecularSequence', 'coordinateSystem', elem.coordinateSystemElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('patient') then
    ComposeReference{TFhirPatient}(this, 'MolecularSequence', 'patient', elem.patientElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('specimen') then
    ComposeReference{TFhirSpecimen}(this, 'MolecularSequence', 'specimen', elem.specimenElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('device') then
    ComposeReference{TFhirDevice}(this, 'MolecularSequence', 'device', elem.deviceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('performer') then
    ComposeReference{TFhirOrganization}(this, 'MolecularSequence', 'performer', elem.performerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('quantity') then
    ComposeQuantity(this, 'MolecularSequence', 'quantity', elem.quantityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('referenceSeq') then
    ComposeMolecularSequenceReferenceSeq(this, 'MolecularSequence', 'referenceSeq', elem.referenceSeqElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('variant') then
    for i := 0 to elem.variantList.Count - 1 do
      ComposeMolecularSequenceVariant(this, 'MolecularSequence', 'variant', elem.variantList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('observedSeq') then
    ComposeString(this, 'MolecularSequence', 'observedSeq', elem.observedSeqElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('quality') then
    for i := 0 to elem.qualityList.Count - 1 do
      ComposeMolecularSequenceQuality(this, 'MolecularSequence', 'quality', elem.qualityList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('readCoverage') then
    ComposeInteger(this, 'MolecularSequence', 'readCoverage', elem.readCoverageElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('repository') then
    for i := 0 to elem.repositoryList.Count - 1 do
      ComposeMolecularSequenceRepository(this, 'MolecularSequence', 'repository', elem.repositoryList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('pointer') then
    for i := 0 to elem.pointerList.Count - 1 do
      ComposeReference{TFhirMolecularSequence}(this, 'MolecularSequence', 'pointer', elem.pointerList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('structureVariant') then
    for i := 0 to elem.structureVariantList.Count - 1 do
      ComposeMolecularSequenceStructureVariant(this, 'MolecularSequence', 'structureVariant', elem.structureVariantList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_MOLECULARSEQUENCE}
{$IFDEF FHIR_NAMINGSYSTEM}
function TFHIRTurtleParser.ParseNamingSystemUniqueId(obj : TTurtleComplex) : TFhirNamingSystemUniqueId;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirNamingSystemUniqueId.create;
  try
    ParseNamingSystemUniqueIdProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseNamingSystemUniqueIdProperties(obj : TTurtleComplex; result : TFhirNamingSystemUniqueId);
begin
    ParseBackboneElementProperties(obj, result);
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/NamingSystem.uniqueId.type'), CODES_TFhirNamingsystemIdentifierTypeEnum, SYSTEMS_TFhirNamingsystemIdentifierTypeEnum);
    result.valueElement := ParseString(obj.complex('http://hl7.org/fhir/NamingSystem.uniqueId.value'));{q1}
    result.preferredElement := ParseBoolean(obj.complex('http://hl7.org/fhir/NamingSystem.uniqueId.preferred'));{q1}
    result.commentElement := ParseString(obj.complex('http://hl7.org/fhir/NamingSystem.uniqueId.comment'));{q1}
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/NamingSystem.uniqueId.period'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeNamingSystemUniqueId(parent :  TTurtleComplex; parentType, name : String; elem : TFhirNamingSystemUniqueId; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:NamingSystemUniqueId'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'NamingSystem.uniqueId', 'type', elem.Type_Element, CODES_TFhirNamingsystemIdentifierTypeEnum, SYSTEMS_TFhirNamingsystemIdentifierTypeEnum, false, -1);{x.d4}
  ComposeString(this, 'NamingSystem.uniqueId', 'value', elem.valueElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'NamingSystem.uniqueId', 'preferred', elem.preferredElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'NamingSystem.uniqueId', 'comment', elem.commentElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'NamingSystem.uniqueId', 'period', elem.periodElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseNamingSystem(obj : TTurtleComplex) : TFhirNamingSystem;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirNamingSystem.create;
  try
    ParseNamingSystemProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseNamingSystemProperties(obj : TTurtleComplex; result : TFhirNamingSystem);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/NamingSystem.name'));{q1}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/NamingSystem.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    result.kindElement := ParseEnum(obj.complex('http://hl7.org/fhir/NamingSystem.kind'), CODES_TFhirNamingsystemTypeEnum, SYSTEMS_TFhirNamingsystemTypeEnum);
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/NamingSystem.date'));{q1}
    result.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/NamingSystem.publisher'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/NamingSystem.contact') do
      result.contactList.Add(parseContactDetail(item));
    result.responsibleElement := ParseString(obj.complex('http://hl7.org/fhir/NamingSystem.responsible'));{q1}
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/NamingSystem.type'));{q3b}
    result.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/NamingSystem.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/NamingSystem.useContext') do
      result.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/NamingSystem.jurisdiction') do
      result.jurisdictionList.Add(parseCodeableConcept(item));
    result.usageElement := ParseString(obj.complex('http://hl7.org/fhir/NamingSystem.usage'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/NamingSystem.uniqueId') do
      result.uniqueIdList.Add(parseNamingSystemUniqueId(item));
end;

procedure TFHIRTurtleComposer.ComposeNamingSystem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirNamingSystem; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:NamingSystem'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  ComposeString(this, 'NamingSystem', 'name', elem.nameElement, false, -1);{x.2ea}
  ComposeEnum(this, 'NamingSystem', 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);{x.d4}
  ComposeEnum(this, 'NamingSystem', 'kind', elem.KindElement, CODES_TFhirNamingsystemTypeEnum, SYSTEMS_TFhirNamingsystemTypeEnum, false, -1);{x.d4}
  ComposeDateTime(this, 'NamingSystem', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(this, 'NamingSystem', 'publisher', elem.publisherElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(this, 'NamingSystem', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('responsible') then
    ComposeString(this, 'NamingSystem', 'responsible', elem.responsibleElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('type_') then
    ComposeCodeableConcept(this, 'NamingSystem', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdown(this, 'NamingSystem', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(this, 'NamingSystem', 'useContext', elem.useContextList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'NamingSystem', 'jurisdiction', elem.jurisdictionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('usage') then
    ComposeString(this, 'NamingSystem', 'usage', elem.usageElement, false, -1);{x.2ea}
  for i := 0 to elem.uniqueIdList.Count - 1 do
      ComposeNamingSystemUniqueId(this, 'NamingSystem', 'uniqueId', elem.uniqueIdList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_NAMINGSYSTEM}
{$IFDEF FHIR_NUTRITIONORDER}
function TFHIRTurtleParser.ParseNutritionOrderOralDiet(obj : TTurtleComplex) : TFhirNutritionOrderOralDiet;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirNutritionOrderOralDiet.create;
  try
    ParseNutritionOrderOralDietProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseNutritionOrderOralDietProperties(obj : TTurtleComplex; result : TFhirNutritionOrderOralDiet);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/NutritionOrder.oralDiet.type') do
      result.type_List.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/NutritionOrder.oralDiet.schedule') do
      result.scheduleList.Add(parseTiming(item));
    for item in obj.complexes('http://hl7.org/fhir/NutritionOrder.oralDiet.nutrient') do
      result.nutrientList.Add(parseNutritionOrderOralDietNutrient(item));
    for item in obj.complexes('http://hl7.org/fhir/NutritionOrder.oralDiet.texture') do
      result.textureList.Add(parseNutritionOrderOralDietTexture(item));
    for item in obj.complexes('http://hl7.org/fhir/NutritionOrder.oralDiet.fluidConsistencyType') do
      result.fluidConsistencyTypeList.Add(parseCodeableConcept(item));
    result.instructionElement := ParseString(obj.complex('http://hl7.org/fhir/NutritionOrder.oralDiet.instruction'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeNutritionOrderOralDiet(parent :  TTurtleComplex; parentType, name : String; elem : TFhirNutritionOrderOralDiet; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:NutritionOrderOralDiet'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(this, 'NutritionOrder.oralDiet', 'type', elem.type_List[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.scheduleList.Count - 1 do
      ComposeTiming(this, 'NutritionOrder.oralDiet', 'schedule', elem.scheduleList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.nutrientList.Count - 1 do
      ComposeNutritionOrderOralDietNutrient(this, 'NutritionOrder.oralDiet', 'nutrient', elem.nutrientList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.textureList.Count - 1 do
      ComposeNutritionOrderOralDietTexture(this, 'NutritionOrder.oralDiet', 'texture', elem.textureList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.fluidConsistencyTypeList.Count - 1 do
      ComposeCodeableConcept(this, 'NutritionOrder.oralDiet', 'fluidConsistencyType', elem.fluidConsistencyTypeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'NutritionOrder.oralDiet', 'instruction', elem.instructionElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseNutritionOrderOralDietNutrient(obj : TTurtleComplex) : TFhirNutritionOrderOralDietNutrient;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirNutritionOrderOralDietNutrient.create;
  try
    ParseNutritionOrderOralDietNutrientProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseNutritionOrderOralDietNutrientProperties(obj : TTurtleComplex; result : TFhirNutritionOrderOralDietNutrient);
begin
    ParseBackboneElementProperties(obj, result);
    result.modifier := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/NutritionOrder.oralDiet.nutrient.modifier'));{q3b}
    result.amount := ParseQuantity(obj.complex('http://hl7.org/fhir/NutritionOrder.oralDiet.nutrient.amount'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeNutritionOrderOralDietNutrient(parent :  TTurtleComplex; parentType, name : String; elem : TFhirNutritionOrderOralDietNutrient; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:NutritionOrderOralDietNutrient'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'NutritionOrder.oralDiet.nutrient', 'modifier', elem.modifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'NutritionOrder.oralDiet.nutrient', 'amount', elem.amountElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseNutritionOrderOralDietTexture(obj : TTurtleComplex) : TFhirNutritionOrderOralDietTexture;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirNutritionOrderOralDietTexture.create;
  try
    ParseNutritionOrderOralDietTextureProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseNutritionOrderOralDietTextureProperties(obj : TTurtleComplex; result : TFhirNutritionOrderOralDietTexture);
begin
    ParseBackboneElementProperties(obj, result);
    result.modifier := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/NutritionOrder.oralDiet.texture.modifier'));{q3b}
    result.foodType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/NutritionOrder.oralDiet.texture.foodType'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeNutritionOrderOralDietTexture(parent :  TTurtleComplex; parentType, name : String; elem : TFhirNutritionOrderOralDietTexture; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:NutritionOrderOralDietTexture'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'NutritionOrder.oralDiet.texture', 'modifier', elem.modifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'NutritionOrder.oralDiet.texture', 'foodType', elem.foodTypeElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseNutritionOrderSupplement(obj : TTurtleComplex) : TFhirNutritionOrderSupplement;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirNutritionOrderSupplement.create;
  try
    ParseNutritionOrderSupplementProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseNutritionOrderSupplementProperties(obj : TTurtleComplex; result : TFhirNutritionOrderSupplement);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/NutritionOrder.supplement.type'));{q3b}
    result.productNameElement := ParseString(obj.complex('http://hl7.org/fhir/NutritionOrder.supplement.productName'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/NutritionOrder.supplement.schedule') do
      result.scheduleList.Add(parseTiming(item));
    result.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/NutritionOrder.supplement.quantity'));{q3b}
    result.instructionElement := ParseString(obj.complex('http://hl7.org/fhir/NutritionOrder.supplement.instruction'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeNutritionOrderSupplement(parent :  TTurtleComplex; parentType, name : String; elem : TFhirNutritionOrderSupplement; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:NutritionOrderSupplement'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'NutritionOrder.supplement', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'NutritionOrder.supplement', 'productName', elem.productNameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.scheduleList.Count - 1 do
      ComposeTiming(this, 'NutritionOrder.supplement', 'schedule', elem.scheduleList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'NutritionOrder.supplement', 'quantity', elem.quantityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'NutritionOrder.supplement', 'instruction', elem.instructionElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseNutritionOrderEnteralFormula(obj : TTurtleComplex) : TFhirNutritionOrderEnteralFormula;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirNutritionOrderEnteralFormula.create;
  try
    ParseNutritionOrderEnteralFormulaProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseNutritionOrderEnteralFormulaProperties(obj : TTurtleComplex; result : TFhirNutritionOrderEnteralFormula);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.baseFormulaType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/NutritionOrder.enteralFormula.baseFormulaType'));{q3b}
    result.baseFormulaProductNameElement := ParseString(obj.complex('http://hl7.org/fhir/NutritionOrder.enteralFormula.baseFormulaProductName'));{q1}
    result.additiveType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/NutritionOrder.enteralFormula.additiveType'));{q3b}
    result.additiveProductNameElement := ParseString(obj.complex('http://hl7.org/fhir/NutritionOrder.enteralFormula.additiveProductName'));{q1}
    result.caloricDensity := ParseQuantity(obj.complex('http://hl7.org/fhir/NutritionOrder.enteralFormula.caloricDensity'));{q3b}
    result.routeofAdministration := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/NutritionOrder.enteralFormula.routeofAdministration'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/NutritionOrder.enteralFormula.administration') do
      result.administrationList.Add(parseNutritionOrderEnteralFormulaAdministration(item));
    result.maxVolumeToDeliver := ParseQuantity(obj.complex('http://hl7.org/fhir/NutritionOrder.enteralFormula.maxVolumeToDeliver'));{q3b}
    result.administrationInstructionElement := ParseString(obj.complex('http://hl7.org/fhir/NutritionOrder.enteralFormula.administrationInstruction'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeNutritionOrderEnteralFormula(parent :  TTurtleComplex; parentType, name : String; elem : TFhirNutritionOrderEnteralFormula; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:NutritionOrderEnteralFormula'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'NutritionOrder.enteralFormula', 'baseFormulaType', elem.baseFormulaTypeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'NutritionOrder.enteralFormula', 'baseFormulaProductName', elem.baseFormulaProductNameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'NutritionOrder.enteralFormula', 'additiveType', elem.additiveTypeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'NutritionOrder.enteralFormula', 'additiveProductName', elem.additiveProductNameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'NutritionOrder.enteralFormula', 'caloricDensity', elem.caloricDensityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'NutritionOrder.enteralFormula', 'routeofAdministration', elem.routeofAdministrationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.administrationList.Count - 1 do
      ComposeNutritionOrderEnteralFormulaAdministration(this, 'NutritionOrder.enteralFormula', 'administration', elem.administrationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'NutritionOrder.enteralFormula', 'maxVolumeToDeliver', elem.maxVolumeToDeliverElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'NutritionOrder.enteralFormula', 'administrationInstruction', elem.administrationInstructionElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseNutritionOrderEnteralFormulaAdministration(obj : TTurtleComplex) : TFhirNutritionOrderEnteralFormulaAdministration;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirNutritionOrderEnteralFormulaAdministration.create;
  try
    ParseNutritionOrderEnteralFormulaAdministrationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseNutritionOrderEnteralFormulaAdministrationProperties(obj : TTurtleComplex; result : TFhirNutritionOrderEnteralFormulaAdministration);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.schedule := ParseTiming(obj.complex('http://hl7.org/fhir/NutritionOrder.enteralFormula.administration.schedule'));{q3b}
    result.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/NutritionOrder.enteralFormula.administration.quantity'));{q3b}
    if obj.has('http://hl7.org/fhir/NutritionOrder.enteralFormula.administration.rateQuantity', item) then
      result.rate := parseQuantity(item);
    if obj.has('http://hl7.org/fhir/NutritionOrder.enteralFormula.administration.rateRatio', item) then
      result.rate := parseRatio(item);
end;

procedure TFHIRTurtleComposer.ComposeNutritionOrderEnteralFormulaAdministration(parent :  TTurtleComplex; parentType, name : String; elem : TFhirNutritionOrderEnteralFormulaAdministration; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:NutritionOrderEnteralFormulaAdministration'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeTiming(this, 'NutritionOrder.enteralFormula.administration', 'schedule', elem.scheduleElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'NutritionOrder.enteralFormula.administration', 'quantity', elem.quantityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and (elem.rate is TFhirQuantity) {6} then
    ComposeQuantity(this, 'NutritionOrder.enteralFormula.administration', 'rateQuantity', TFhirQuantity(elem.rate), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.rate is TFhirRatio) {6} then
    ComposeRatio(this, 'NutritionOrder.enteralFormula.administration', 'rateRatio', TFhirRatio(elem.rate), false, -1);{x.d9}
end;

function TFHIRTurtleParser.ParseNutritionOrder(obj : TTurtleComplex) : TFhirNutritionOrder;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirNutritionOrder.create;
  try
    ParseNutritionOrderProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseNutritionOrderProperties(obj : TTurtleComplex; result : TFhirNutritionOrder);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/NutritionOrder.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/NutritionOrder.instantiatesCanonical') do
      result.instantiatesCanonicalList.Add(parseCanonical(item));
    for item in obj.complexes('http://hl7.org/fhir/NutritionOrder.instantiatesUri') do
      result.instantiatesUriList.Add(parseUri(item));
    for item in obj.complexes('http://hl7.org/fhir/NutritionOrder.instantiates') do
      result.instantiatesList.Add(parseUri(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/NutritionOrder.status'), CODES_TFhirRequestStatusEnum, SYSTEMS_TFhirRequestStatusEnum);
    result.intentElement := ParseEnum(obj.complex('http://hl7.org/fhir/NutritionOrder.intent'), CODES_TFhirRequestIntentEnum, SYSTEMS_TFhirRequestIntentEnum);
    result.patient := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/NutritionOrder.patient'));{q3b}
    result.encounter := ParseReference{TFhirEncounter}(obj.complex('http://hl7.org/fhir/NutritionOrder.encounter'));{q3b}
    result.dateTimeElement := ParseDateTime(obj.complex('http://hl7.org/fhir/NutritionOrder.dateTime'));{q1}
    result.orderer := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/NutritionOrder.orderer'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/NutritionOrder.allergyIntolerance') do
      result.allergyIntoleranceList.Add(parseReference{TFhirAllergyIntolerance}(item));
    for item in obj.complexes('http://hl7.org/fhir/NutritionOrder.foodPreferenceModifier') do
      result.foodPreferenceModifierList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/NutritionOrder.excludeFoodModifier') do
      result.excludeFoodModifierList.Add(parseCodeableConcept(item));
    result.oralDiet := ParseNutritionOrderOralDiet(obj.complex('http://hl7.org/fhir/NutritionOrder.oralDiet'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/NutritionOrder.supplement') do
      result.supplementList.Add(parseNutritionOrderSupplement(item));
    result.enteralFormula := ParseNutritionOrderEnteralFormula(obj.complex('http://hl7.org/fhir/NutritionOrder.enteralFormula'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/NutritionOrder.note') do
      result.noteList.Add(parseAnnotation(item));
end;

procedure TFHIRTurtleComposer.ComposeNutritionOrder(parent :  TTurtleComplex; parentType, name : String; elem : TFhirNutritionOrder; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:NutritionOrder'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'NutritionOrder', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('instantiatesCanonical') then
    for i := 0 to elem.instantiatesCanonicalList.Count - 1 do
      ComposeCanonical(this, 'NutritionOrder', 'instantiatesCanonical', elem.instantiatesCanonicalList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('instantiatesUri') then
    for i := 0 to elem.instantiatesUriList.Count - 1 do
      ComposeUri(this, 'NutritionOrder', 'instantiatesUri', elem.instantiatesUriList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('instantiates') then
    for i := 0 to elem.instantiatesList.Count - 1 do
      ComposeUri(this, 'NutritionOrder', 'instantiates', elem.instantiatesList[i], false, i);{x.d3}
  ComposeEnum(this, 'NutritionOrder', 'status', elem.StatusElement, CODES_TFhirRequestStatusEnum, SYSTEMS_TFhirRequestStatusEnum, false, -1);{x.d4}
  ComposeEnum(this, 'NutritionOrder', 'intent', elem.IntentElement, CODES_TFhirRequestIntentEnum, SYSTEMS_TFhirRequestIntentEnum, false, -1);{x.d4}
  ComposeReference{TFhirPatient}(this, 'NutritionOrder', 'patient', elem.patientElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(this, 'NutritionOrder', 'encounter', elem.encounterElement, false, -1);{x.2f}
  ComposeDateTime(this, 'NutritionOrder', 'dateTime', elem.dateTimeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('orderer') then
    ComposeReference{TFhirPractitioner}(this, 'NutritionOrder', 'orderer', elem.ordererElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('allergyIntolerance') then
    for i := 0 to elem.allergyIntoleranceList.Count - 1 do
      ComposeReference{TFhirAllergyIntolerance}(this, 'NutritionOrder', 'allergyIntolerance', elem.allergyIntoleranceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('foodPreferenceModifier') then
    for i := 0 to elem.foodPreferenceModifierList.Count - 1 do
      ComposeCodeableConcept(this, 'NutritionOrder', 'foodPreferenceModifier', elem.foodPreferenceModifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('excludeFoodModifier') then
    for i := 0 to elem.excludeFoodModifierList.Count - 1 do
      ComposeCodeableConcept(this, 'NutritionOrder', 'excludeFoodModifier', elem.excludeFoodModifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('oralDiet') then
    ComposeNutritionOrderOralDiet(this, 'NutritionOrder', 'oralDiet', elem.oralDietElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('supplement') then
    for i := 0 to elem.supplementList.Count - 1 do
      ComposeNutritionOrderSupplement(this, 'NutritionOrder', 'supplement', elem.supplementList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('enteralFormula') then
    ComposeNutritionOrderEnteralFormula(this, 'NutritionOrder', 'enteralFormula', elem.enteralFormulaElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'NutritionOrder', 'note', elem.noteList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_NUTRITIONORDER}
{$IFDEF FHIR_OBSERVATION}
function TFHIRTurtleParser.ParseObservationReferenceRange(obj : TTurtleComplex) : TFhirObservationReferenceRange;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirObservationReferenceRange.create;
  try
    ParseObservationReferenceRangeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseObservationReferenceRangeProperties(obj : TTurtleComplex; result : TFhirObservationReferenceRange);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.low := ParseQuantity(obj.complex('http://hl7.org/fhir/Observation.referenceRange.low'));{q3b}
    result.high := ParseQuantity(obj.complex('http://hl7.org/fhir/Observation.referenceRange.high'));{q3b}
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Observation.referenceRange.type'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Observation.referenceRange.appliesTo') do
      result.appliesToList.Add(parseCodeableConcept(item));
    result.age := ParseRange(obj.complex('http://hl7.org/fhir/Observation.referenceRange.age'));{q3b}
    result.textElement := ParseString(obj.complex('http://hl7.org/fhir/Observation.referenceRange.text'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeObservationReferenceRange(parent :  TTurtleComplex; parentType, name : String; elem : TFhirObservationReferenceRange; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ObservationReferenceRange'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'Observation.referenceRange', 'low', elem.lowElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'Observation.referenceRange', 'high', elem.highElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Observation.referenceRange', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.appliesToList.Count - 1 do
      ComposeCodeableConcept(this, 'Observation.referenceRange', 'appliesTo', elem.appliesToList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeRange(this, 'Observation.referenceRange', 'age', elem.ageElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Observation.referenceRange', 'text', elem.textElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseObservationComponent(obj : TTurtleComplex) : TFhirObservationComponent;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirObservationComponent.create;
  try
    ParseObservationComponentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseObservationComponentProperties(obj : TTurtleComplex; result : TFhirObservationComponent);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Observation.component.code'));{q3b}
    if obj.has('http://hl7.org/fhir/Observation.component.valueQuantity', item) then
      result.value := parseQuantity(item);
    if obj.has('http://hl7.org/fhir/Observation.component.valueCodeableConcept', item) then
      result.value := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/Observation.component.valueRange', item) then
      result.value := parseRange(item);
    if obj.has('http://hl7.org/fhir/Observation.component.valueRatio', item) then
      result.value := parseRatio(item);
    if obj.has('http://hl7.org/fhir/Observation.component.valueSampledData', item) then
      result.value := parseSampledData(item);
    if obj.has('http://hl7.org/fhir/Observation.component.valuePeriod', item) then
      result.value := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/Observation.component.valueString', item) then
      result.value := parseString(item);
    if obj.has('http://hl7.org/fhir/Observation.component.valueBoolean', item) then
      result.value := parseBoolean(item);
    if obj.has('http://hl7.org/fhir/Observation.component.valueInteger', item) then
      result.value := parseInteger(item);
    if obj.has('http://hl7.org/fhir/Observation.component.valueTime', item) then
      result.value := parseTime(item);
    if obj.has('http://hl7.org/fhir/Observation.component.valueDateTime', item) then
      result.value := parseDateTime(item);
    result.dataAbsentReason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Observation.component.dataAbsentReason'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Observation.component.interpretation') do
      result.interpretationList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Observation.component.referenceRange') do
      result.referenceRangeList.Add(parseObservationReferenceRange(item));
end;

procedure TFHIRTurtleComposer.ComposeObservationComponent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirObservationComponent; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ObservationComponent'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'Observation.component', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'Observation.component', 'valueQuantity', TFhirQuantity(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Observation.component', 'valueCodeableConcept', TFhirCodeableConcept(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirRange) {6} then
    ComposeRange(this, 'Observation.component', 'valueRange', TFhirRange(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirRatio) {6} then
    ComposeRatio(this, 'Observation.component', 'valueRatio', TFhirRatio(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirSampledData) {6} then
    ComposeSampledData(this, 'Observation.component', 'valueSampledData', TFhirSampledData(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirPeriod) {6} then
    ComposePeriod(this, 'Observation.component', 'valuePeriod', TFhirPeriod(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirString) {6} then
    ComposeString(this, 'Observation.component', 'valueString', TFhirString(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirBoolean) {6} then
    ComposeBoolean(this, 'Observation.component', 'valueBoolean', TFhirBoolean(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirInteger) {6} then
    ComposeInteger(this, 'Observation.component', 'valueInteger', TFhirInteger(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirTime) {6} then
    ComposeTime(this, 'Observation.component', 'valueTime', TFhirTime(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirDateTime) {6} then
    ComposeDateTime(this, 'Observation.component', 'valueDateTime', TFhirDateTime(elem.value), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Observation.component', 'dataAbsentReason', elem.dataAbsentReasonElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.interpretationList.Count - 1 do
      ComposeCodeableConcept(this, 'Observation.component', 'interpretation', elem.interpretationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.referenceRangeList.Count - 1 do
      ComposeObservationReferenceRange(this, 'Observation.component', 'referenceRange', elem.referenceRangeList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseObservation(obj : TTurtleComplex) : TFhirObservation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirObservation.create;
  try
    ParseObservationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseObservationProperties(obj : TTurtleComplex; result : TFhirObservation);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Observation.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/Observation.basedOn') do
      result.basedOnList.Add(parseReference{TFhirCarePlan}(item));
    for item in obj.complexes('http://hl7.org/fhir/Observation.partOf') do
      result.partOfList.Add(parseReference{TFhirMedicationAdministration}(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Observation.status'), CODES_TFhirObservationStatusEnum, SYSTEMS_TFhirObservationStatusEnum);
    for item in obj.complexes('http://hl7.org/fhir/Observation.category') do
      result.categoryList.Add(parseCodeableConcept(item));
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Observation.code'));{q3b}
    result.subject := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/Observation.subject'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Observation.focus') do
      result.focusList.Add(parseReference{TFhirReference}(item));
    result.encounter := ParseReference{TFhirEncounter}(obj.complex('http://hl7.org/fhir/Observation.encounter'));{q3b}
    if obj.has('http://hl7.org/fhir/Observation.effectivePeriod', item) then
      result.effective := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/Observation.effectiveTiming', item) then
      result.effective := parseTiming(item);
    if obj.has('http://hl7.org/fhir/Observation.effectiveDateTime', item) then
      result.effective := parseDateTime(item);
    if obj.has('http://hl7.org/fhir/Observation.effectiveInstant', item) then
      result.effective := parseInstant(item);
    result.issuedElement := ParseInstant(obj.complex('http://hl7.org/fhir/Observation.issued'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Observation.performer') do
      result.performerList.Add(parseReference{TFhirPractitioner}(item));
    if obj.has('http://hl7.org/fhir/Observation.valueQuantity', item) then
      result.value := parseQuantity(item);
    if obj.has('http://hl7.org/fhir/Observation.valueCodeableConcept', item) then
      result.value := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/Observation.valueRange', item) then
      result.value := parseRange(item);
    if obj.has('http://hl7.org/fhir/Observation.valueRatio', item) then
      result.value := parseRatio(item);
    if obj.has('http://hl7.org/fhir/Observation.valueSampledData', item) then
      result.value := parseSampledData(item);
    if obj.has('http://hl7.org/fhir/Observation.valuePeriod', item) then
      result.value := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/Observation.valueString', item) then
      result.value := parseString(item);
    if obj.has('http://hl7.org/fhir/Observation.valueBoolean', item) then
      result.value := parseBoolean(item);
    if obj.has('http://hl7.org/fhir/Observation.valueInteger', item) then
      result.value := parseInteger(item);
    if obj.has('http://hl7.org/fhir/Observation.valueTime', item) then
      result.value := parseTime(item);
    if obj.has('http://hl7.org/fhir/Observation.valueDateTime', item) then
      result.value := parseDateTime(item);
    result.dataAbsentReason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Observation.dataAbsentReason'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Observation.interpretation') do
      result.interpretationList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Observation.note') do
      result.noteList.Add(parseAnnotation(item));
    result.bodySite := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Observation.bodySite'));{q3b}
    result.method := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Observation.method'));{q3b}
    result.specimen := ParseReference{TFhirSpecimen}(obj.complex('http://hl7.org/fhir/Observation.specimen'));{q3b}
    result.device := ParseReference{TFhirDevice}(obj.complex('http://hl7.org/fhir/Observation.device'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Observation.referenceRange') do
      result.referenceRangeList.Add(parseObservationReferenceRange(item));
    for item in obj.complexes('http://hl7.org/fhir/Observation.hasMember') do
      result.hasMemberList.Add(parseReference{TFhirObservation}(item));
    for item in obj.complexes('http://hl7.org/fhir/Observation.derivedFrom') do
      result.derivedFromList.Add(parseReference{TFhirDocumentReference}(item));
    for item in obj.complexes('http://hl7.org/fhir/Observation.component') do
      result.componentList.Add(parseObservationComponent(item));
end;

procedure TFHIRTurtleComposer.ComposeObservation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirObservation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Observation'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Observation', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('basedOn') then
    for i := 0 to elem.basedOnList.Count - 1 do
      ComposeReference{TFhirCarePlan}(this, 'Observation', 'basedOn', elem.basedOnList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('partOf') then
    for i := 0 to elem.partOfList.Count - 1 do
      ComposeReference{TFhirMedicationAdministration}(this, 'Observation', 'partOf', elem.partOfList[i], false, i);{x.d3}
  ComposeEnum(this, 'Observation', 'status', elem.StatusElement, CODES_TFhirObservationStatusEnum, SYSTEMS_TFhirObservationStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('category') then
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(this, 'Observation', 'category', elem.categoryList[i], false, i);{x.d3}
  ComposeCodeableConcept(this, 'Observation', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{TFhirPatient}(this, 'Observation', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('focus') then
    for i := 0 to elem.focusList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'Observation', 'focus', elem.focusList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(this, 'Observation', 'encounter', elem.encounterElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.effective is TFhirPeriod) {6} then
    ComposePeriod(this, 'Observation', 'effectivePeriod', TFhirPeriod(elem.effective), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.effective is TFhirTiming) {6} then
    ComposeTiming(this, 'Observation', 'effectiveTiming', TFhirTiming(elem.effective), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.effective is TFhirDateTime) {6} then
    ComposeDateTime(this, 'Observation', 'effectiveDateTime', TFhirDateTime(elem.effective), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.effective is TFhirInstant) {6} then
    ComposeInstant(this, 'Observation', 'effectiveInstant', TFhirInstant(elem.effective), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('issued') then
    ComposeInstant(this, 'Observation', 'issued', elem.issuedElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('performer') then
    for i := 0 to elem.performerList.Count - 1 do
      ComposeReference{TFhirPractitioner}(this, 'Observation', 'performer', elem.performerList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'Observation', 'valueQuantity', TFhirQuantity(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Observation', 'valueCodeableConcept', TFhirCodeableConcept(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirRange) {6} then
    ComposeRange(this, 'Observation', 'valueRange', TFhirRange(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirRatio) {6} then
    ComposeRatio(this, 'Observation', 'valueRatio', TFhirRatio(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirSampledData) {6} then
    ComposeSampledData(this, 'Observation', 'valueSampledData', TFhirSampledData(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirPeriod) {6} then
    ComposePeriod(this, 'Observation', 'valuePeriod', TFhirPeriod(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirString) {6} then
    ComposeString(this, 'Observation', 'valueString', TFhirString(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirBoolean) {6} then
    ComposeBoolean(this, 'Observation', 'valueBoolean', TFhirBoolean(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirInteger) {6} then
    ComposeInteger(this, 'Observation', 'valueInteger', TFhirInteger(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirTime) {6} then
    ComposeTime(this, 'Observation', 'valueTime', TFhirTime(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirDateTime) {6} then
    ComposeDateTime(this, 'Observation', 'valueDateTime', TFhirDateTime(elem.value), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) and doCompose('dataAbsentReason') then
    ComposeCodeableConcept(this, 'Observation', 'dataAbsentReason', elem.dataAbsentReasonElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('interpretation') then
    for i := 0 to elem.interpretationList.Count - 1 do
      ComposeCodeableConcept(this, 'Observation', 'interpretation', elem.interpretationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'Observation', 'note', elem.noteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('bodySite') then
    ComposeCodeableConcept(this, 'Observation', 'bodySite', elem.bodySiteElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('method') then
    ComposeCodeableConcept(this, 'Observation', 'method', elem.methodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('specimen') then
    ComposeReference{TFhirSpecimen}(this, 'Observation', 'specimen', elem.specimenElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('device') then
    ComposeReference{TFhirDevice}(this, 'Observation', 'device', elem.deviceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('referenceRange') then
    for i := 0 to elem.referenceRangeList.Count - 1 do
      ComposeObservationReferenceRange(this, 'Observation', 'referenceRange', elem.referenceRangeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('hasMember') then
    for i := 0 to elem.hasMemberList.Count - 1 do
      ComposeReference{TFhirObservation}(this, 'Observation', 'hasMember', elem.hasMemberList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('derivedFrom') then
    for i := 0 to elem.derivedFromList.Count - 1 do
      ComposeReference{TFhirDocumentReference}(this, 'Observation', 'derivedFrom', elem.derivedFromList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('component') then
    for i := 0 to elem.componentList.Count - 1 do
      ComposeObservationComponent(this, 'Observation', 'component', elem.componentList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_OBSERVATION}
{$IFDEF FHIR_OBSERVATIONDEFINITION}
function TFHIRTurtleParser.ParseObservationDefinitionQuantitativeDetails(obj : TTurtleComplex) : TFhirObservationDefinitionQuantitativeDetails;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirObservationDefinitionQuantitativeDetails.create;
  try
    ParseObservationDefinitionQuantitativeDetailsProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseObservationDefinitionQuantitativeDetailsProperties(obj : TTurtleComplex; result : TFhirObservationDefinitionQuantitativeDetails);
begin
    ParseBackboneElementProperties(obj, result);
    result.customaryUnit := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ObservationDefinition.quantitativeDetails.customaryUnit'));{q3b}
    result.unit_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ObservationDefinition.quantitativeDetails.unit'));{q3b}
    result.conversionFactorElement := ParseDecimal(obj.complex('http://hl7.org/fhir/ObservationDefinition.quantitativeDetails.conversionFactor'));{q1}
    result.decimalPrecisionElement := ParseInteger(obj.complex('http://hl7.org/fhir/ObservationDefinition.quantitativeDetails.decimalPrecision'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeObservationDefinitionQuantitativeDetails(parent :  TTurtleComplex; parentType, name : String; elem : TFhirObservationDefinitionQuantitativeDetails; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ObservationDefinitionQuantitativeDetails'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ObservationDefinition.quantitativeDetails', 'customaryUnit', elem.customaryUnitElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ObservationDefinition.quantitativeDetails', 'unit', elem.unit_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'ObservationDefinition.quantitativeDetails', 'conversionFactor', elem.conversionFactorElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(this, 'ObservationDefinition.quantitativeDetails', 'decimalPrecision', elem.decimalPrecisionElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseObservationDefinitionQualifiedInterval(obj : TTurtleComplex) : TFhirObservationDefinitionQualifiedInterval;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirObservationDefinitionQualifiedInterval.create;
  try
    ParseObservationDefinitionQualifiedIntervalProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseObservationDefinitionQualifiedIntervalProperties(obj : TTurtleComplex; result : TFhirObservationDefinitionQualifiedInterval);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.categoryElement := ParseEnum(obj.complex('http://hl7.org/fhir/ObservationDefinition.qualifiedInterval.category'), CODES_TFhirObservationRangeCategoryEnum, SYSTEMS_TFhirObservationRangeCategoryEnum);
    result.range := ParseRange(obj.complex('http://hl7.org/fhir/ObservationDefinition.qualifiedInterval.range'));{q3b}
    result.context := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ObservationDefinition.qualifiedInterval.context'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ObservationDefinition.qualifiedInterval.appliesTo') do
      result.appliesToList.Add(parseCodeableConcept(item));
    result.genderElement := ParseEnum(obj.complex('http://hl7.org/fhir/ObservationDefinition.qualifiedInterval.gender'), CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum);
    result.age := ParseRange(obj.complex('http://hl7.org/fhir/ObservationDefinition.qualifiedInterval.age'));{q3b}
    result.gestationalAge := ParseRange(obj.complex('http://hl7.org/fhir/ObservationDefinition.qualifiedInterval.gestationalAge'));{q3b}
    result.conditionElement := ParseString(obj.complex('http://hl7.org/fhir/ObservationDefinition.qualifiedInterval.condition'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeObservationDefinitionQualifiedInterval(parent :  TTurtleComplex; parentType, name : String; elem : TFhirObservationDefinitionQualifiedInterval; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ObservationDefinitionQualifiedInterval'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'ObservationDefinition.qualifiedInterval', 'category', elem.CategoryElement, CODES_TFhirObservationRangeCategoryEnum, SYSTEMS_TFhirObservationRangeCategoryEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeRange(this, 'ObservationDefinition.qualifiedInterval', 'range', elem.rangeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ObservationDefinition.qualifiedInterval', 'context', elem.contextElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.appliesToList.Count - 1 do
      ComposeCodeableConcept(this, 'ObservationDefinition.qualifiedInterval', 'appliesTo', elem.appliesToList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'ObservationDefinition.qualifiedInterval', 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeRange(this, 'ObservationDefinition.qualifiedInterval', 'age', elem.ageElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeRange(this, 'ObservationDefinition.qualifiedInterval', 'gestationalAge', elem.gestationalAgeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ObservationDefinition.qualifiedInterval', 'condition', elem.conditionElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseObservationDefinition(obj : TTurtleComplex) : TFhirObservationDefinition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirObservationDefinition.create;
  try
    ParseObservationDefinitionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseObservationDefinitionProperties(obj : TTurtleComplex; result : TFhirObservationDefinition);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/ObservationDefinition.category') do
      result.categoryList.Add(parseCodeableConcept(item));
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ObservationDefinition.code'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ObservationDefinition.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/ObservationDefinition.permittedDataType') do
      result.permittedDataTypeList.Add(parseEnum(item, CODES_TFhirPermittedDataTypeEnum, SYSTEMS_TFhirPermittedDataTypeEnum));
    result.multipleResultsAllowedElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ObservationDefinition.multipleResultsAllowed'));{q1}
    result.method := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ObservationDefinition.method'));{q3b}
    result.preferredReportNameElement := ParseString(obj.complex('http://hl7.org/fhir/ObservationDefinition.preferredReportName'));{q1}
    result.quantitativeDetails := ParseObservationDefinitionQuantitativeDetails(obj.complex('http://hl7.org/fhir/ObservationDefinition.quantitativeDetails'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ObservationDefinition.qualifiedInterval') do
      result.qualifiedIntervalList.Add(parseObservationDefinitionQualifiedInterval(item));
    result.validCodedValueSet := ParseReference{TFhirValueSet}(obj.complex('http://hl7.org/fhir/ObservationDefinition.validCodedValueSet'));{q3b}
    result.normalCodedValueSet := ParseReference{TFhirValueSet}(obj.complex('http://hl7.org/fhir/ObservationDefinition.normalCodedValueSet'));{q3b}
    result.abnormalCodedValueSet := ParseReference{TFhirValueSet}(obj.complex('http://hl7.org/fhir/ObservationDefinition.abnormalCodedValueSet'));{q3b}
    result.criticalCodedValueSet := ParseReference{TFhirValueSet}(obj.complex('http://hl7.org/fhir/ObservationDefinition.criticalCodedValueSet'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeObservationDefinition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirObservationDefinition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ObservationDefinition'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(this, 'ObservationDefinition', 'category', elem.categoryList[i], false, i);{x.d3}
  ComposeCodeableConcept(this, 'ObservationDefinition', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'ObservationDefinition', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('permittedDataType') then
    for i := 0 to elem.permittedDataTypeList.Count - 1 do
      ComposeEnum(this, 'ObservationDefinition', 'permittedDataType', elem.permittedDataTypeList[i], CODES_TFhirPermittedDataTypeEnum, SYSTEMS_TFhirPermittedDataTypeEnum, false, i); {x.d1}
  if (SummaryOption in [soFull, soData]) and doCompose('permittedDataType') then
    for i := 0 to elem.permittedDataTypeList.Count - 1 do
      ComposeEnum(this, 'ObservationDefinition', 'permittedDataType', elem.permittedDataTypeList[i], CODES_TFhirPermittedDataTypeEnum, SYSTEMS_TFhirPermittedDataTypeEnum, false, i);{x.d2}
  if (SummaryOption in [soFull, soData]) and doCompose('multipleResultsAllowed') then
    ComposeBoolean(this, 'ObservationDefinition', 'multipleResultsAllowed', elem.multipleResultsAllowedElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('method') then
    ComposeCodeableConcept(this, 'ObservationDefinition', 'method', elem.methodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('preferredReportName') then
    ComposeString(this, 'ObservationDefinition', 'preferredReportName', elem.preferredReportNameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('quantitativeDetails') then
    ComposeObservationDefinitionQuantitativeDetails(this, 'ObservationDefinition', 'quantitativeDetails', elem.quantitativeDetailsElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('qualifiedInterval') then
    for i := 0 to elem.qualifiedIntervalList.Count - 1 do
      ComposeObservationDefinitionQualifiedInterval(this, 'ObservationDefinition', 'qualifiedInterval', elem.qualifiedIntervalList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('validCodedValueSet') then
    ComposeReference{TFhirValueSet}(this, 'ObservationDefinition', 'validCodedValueSet', elem.validCodedValueSetElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('normalCodedValueSet') then
    ComposeReference{TFhirValueSet}(this, 'ObservationDefinition', 'normalCodedValueSet', elem.normalCodedValueSetElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('abnormalCodedValueSet') then
    ComposeReference{TFhirValueSet}(this, 'ObservationDefinition', 'abnormalCodedValueSet', elem.abnormalCodedValueSetElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('criticalCodedValueSet') then
    ComposeReference{TFhirValueSet}(this, 'ObservationDefinition', 'criticalCodedValueSet', elem.criticalCodedValueSetElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_OBSERVATIONDEFINITION}
{$IFDEF FHIR_OPERATIONDEFINITION}
function TFHIRTurtleParser.ParseOperationDefinitionParameter(obj : TTurtleComplex) : TFhirOperationDefinitionParameter;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirOperationDefinitionParameter.create;
  try
    ParseOperationDefinitionParameterProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseOperationDefinitionParameterProperties(obj : TTurtleComplex; result : TFhirOperationDefinitionParameter);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.nameElement := ParseCode(obj.complex('http://hl7.org/fhir/OperationDefinition.parameter.name'));{q1}
    result.useElement := ParseEnum(obj.complex('http://hl7.org/fhir/OperationDefinition.parameter.use'), CODES_TFhirOperationParameterUseEnum, SYSTEMS_TFhirOperationParameterUseEnum);
    result.minElement := ParseInteger(obj.complex('http://hl7.org/fhir/OperationDefinition.parameter.min'));{q1}
    result.maxElement := ParseString(obj.complex('http://hl7.org/fhir/OperationDefinition.parameter.max'));{q1}
    result.documentationElement := ParseString(obj.complex('http://hl7.org/fhir/OperationDefinition.parameter.documentation'));{q1}
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/OperationDefinition.parameter.type'), CODES_TFhirAllTypesEnum, SYSTEMS_TFhirAllTypesEnum);
    for item in obj.complexes('http://hl7.org/fhir/OperationDefinition.parameter.targetProfile') do
      result.targetProfileList.Add(parseCanonical(item));
    result.searchTypeElement := ParseEnum(obj.complex('http://hl7.org/fhir/OperationDefinition.parameter.searchType'), CODES_TFhirSearchParamTypeEnum, SYSTEMS_TFhirSearchParamTypeEnum);
    result.binding := ParseOperationDefinitionParameterBinding(obj.complex('http://hl7.org/fhir/OperationDefinition.parameter.binding'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/OperationDefinition.parameter.referencedFrom') do
      result.referencedFromList.Add(parseOperationDefinitionParameterReferencedFrom(item));
    for item in obj.complexes('http://hl7.org/fhir/OperationDefinition.parameter.part') do
      result.partList.Add(parseOperationDefinitionParameter(item));
end;

procedure TFHIRTurtleComposer.ComposeOperationDefinitionParameter(parent :  TTurtleComplex; parentType, name : String; elem : TFhirOperationDefinitionParameter; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:OperationDefinitionParameter'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCode(this, 'OperationDefinition.parameter', 'name', elem.nameElement, false, -1);{x.2ea}
  ComposeEnum(this, 'OperationDefinition.parameter', 'use', elem.UseElement, CODES_TFhirOperationParameterUseEnum, SYSTEMS_TFhirOperationParameterUseEnum, false, -1);{x.d4}
  ComposeInteger(this, 'OperationDefinition.parameter', 'min', elem.minElement, false, -1);{x.2ea}
  ComposeString(this, 'OperationDefinition.parameter', 'max', elem.maxElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'OperationDefinition.parameter', 'documentation', elem.documentationElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'OperationDefinition.parameter', 'type', elem.Type_Element, CODES_TFhirAllTypesEnum, SYSTEMS_TFhirAllTypesEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.targetProfileList.Count - 1 do
      ComposeCanonical(this, 'OperationDefinition.parameter', 'targetProfile', elem.targetProfileList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'OperationDefinition.parameter', 'searchType', elem.SearchTypeElement, CODES_TFhirSearchParamTypeEnum, SYSTEMS_TFhirSearchParamTypeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeOperationDefinitionParameterBinding(this, 'OperationDefinition.parameter', 'binding', elem.bindingElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.referencedFromList.Count - 1 do
      ComposeOperationDefinitionParameterReferencedFrom(this, 'OperationDefinition.parameter', 'referencedFrom', elem.referencedFromList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.partList.Count - 1 do
      ComposeOperationDefinitionParameter(this, 'OperationDefinition.parameter', 'part', elem.partList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseOperationDefinitionParameterBinding(obj : TTurtleComplex) : TFhirOperationDefinitionParameterBinding;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirOperationDefinitionParameterBinding.create;
  try
    ParseOperationDefinitionParameterBindingProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseOperationDefinitionParameterBindingProperties(obj : TTurtleComplex; result : TFhirOperationDefinitionParameterBinding);
begin
    ParseBackboneElementProperties(obj, result);
    result.strengthElement := ParseEnum(obj.complex('http://hl7.org/fhir/OperationDefinition.parameter.binding.strength'), CODES_TFhirBindingStrengthEnum, SYSTEMS_TFhirBindingStrengthEnum);
    result.valueSetElement := ParseCanonical(obj.complex('http://hl7.org/fhir/OperationDefinition.parameter.binding.valueSet'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeOperationDefinitionParameterBinding(parent :  TTurtleComplex; parentType, name : String; elem : TFhirOperationDefinitionParameterBinding; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:OperationDefinitionParameterBinding'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'OperationDefinition.parameter.binding', 'strength', elem.StrengthElement, CODES_TFhirBindingStrengthEnum, SYSTEMS_TFhirBindingStrengthEnum, false, -1);{x.d4}
  ComposeCanonical(this, 'OperationDefinition.parameter.binding', 'valueSet', elem.valueSetElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseOperationDefinitionParameterReferencedFrom(obj : TTurtleComplex) : TFhirOperationDefinitionParameterReferencedFrom;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirOperationDefinitionParameterReferencedFrom.create;
  try
    ParseOperationDefinitionParameterReferencedFromProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseOperationDefinitionParameterReferencedFromProperties(obj : TTurtleComplex; result : TFhirOperationDefinitionParameterReferencedFrom);
begin
    ParseBackboneElementProperties(obj, result);
    result.sourceElement := ParseString(obj.complex('http://hl7.org/fhir/OperationDefinition.parameter.referencedFrom.source'));{q1}
    result.sourceIdElement := ParseString(obj.complex('http://hl7.org/fhir/OperationDefinition.parameter.referencedFrom.sourceId'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeOperationDefinitionParameterReferencedFrom(parent :  TTurtleComplex; parentType, name : String; elem : TFhirOperationDefinitionParameterReferencedFrom; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:OperationDefinitionParameterReferencedFrom'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeString(this, 'OperationDefinition.parameter.referencedFrom', 'source', elem.sourceElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'OperationDefinition.parameter.referencedFrom', 'sourceId', elem.sourceIdElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseOperationDefinitionOverload(obj : TTurtleComplex) : TFhirOperationDefinitionOverload;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirOperationDefinitionOverload.create;
  try
    ParseOperationDefinitionOverloadProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseOperationDefinitionOverloadProperties(obj : TTurtleComplex; result : TFhirOperationDefinitionOverload);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/OperationDefinition.overload.parameterName') do
      result.parameterNameList.Add(parseString(item));
    result.commentElement := ParseString(obj.complex('http://hl7.org/fhir/OperationDefinition.overload.comment'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeOperationDefinitionOverload(parent :  TTurtleComplex; parentType, name : String; elem : TFhirOperationDefinitionOverload; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:OperationDefinitionOverload'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.parameterNameList.Count - 1 do
      ComposeString(this, 'OperationDefinition.overload', 'parameterName', elem.parameterNameList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'OperationDefinition.overload', 'comment', elem.commentElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseOperationDefinition(obj : TTurtleComplex) : TFhirOperationDefinition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirOperationDefinition.create;
  try
    ParseOperationDefinitionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseOperationDefinitionProperties(obj : TTurtleComplex; result : TFhirOperationDefinition);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/OperationDefinition.url'));{q1}
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/OperationDefinition.version'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/OperationDefinition.name'));{q1}
    result.titleElement := ParseString(obj.complex('http://hl7.org/fhir/OperationDefinition.title'));{q1}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/OperationDefinition.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    result.kindElement := ParseEnum(obj.complex('http://hl7.org/fhir/OperationDefinition.kind'), CODES_TFhirOperationKindEnum, SYSTEMS_TFhirOperationKindEnum);
    result.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/OperationDefinition.experimental'));{q1}
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/OperationDefinition.date'));{q1}
    result.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/OperationDefinition.publisher'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/OperationDefinition.contact') do
      result.contactList.Add(parseContactDetail(item));
    result.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/OperationDefinition.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/OperationDefinition.useContext') do
      result.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/OperationDefinition.jurisdiction') do
      result.jurisdictionList.Add(parseCodeableConcept(item));
    result.purposeElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/OperationDefinition.purpose'));{q1}
    result.affectsStateElement := ParseBoolean(obj.complex('http://hl7.org/fhir/OperationDefinition.affectsState'));{q1}
    result.codeElement := ParseCode(obj.complex('http://hl7.org/fhir/OperationDefinition.code'));{q1}
    result.commentElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/OperationDefinition.comment'));{q1}
    result.baseElement := ParseCanonical(obj.complex('http://hl7.org/fhir/OperationDefinition.base'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/OperationDefinition.resource') do
      result.resource.Add(parseEnum(item, CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum));
    result.systemElement := ParseBoolean(obj.complex('http://hl7.org/fhir/OperationDefinition.system'));{q1}
    result.type_Element := ParseBoolean(obj.complex('http://hl7.org/fhir/OperationDefinition.type'));{q1}
    result.instanceElement := ParseBoolean(obj.complex('http://hl7.org/fhir/OperationDefinition.instance'));{q1}
    result.inputProfileElement := ParseCanonical(obj.complex('http://hl7.org/fhir/OperationDefinition.inputProfile'));{q1}
    result.outputProfileElement := ParseCanonical(obj.complex('http://hl7.org/fhir/OperationDefinition.outputProfile'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/OperationDefinition.parameter') do
      result.parameterList.Add(parseOperationDefinitionParameter(item));
    for item in obj.complexes('http://hl7.org/fhir/OperationDefinition.overload') do
      result.overloadList.Add(parseOperationDefinitionOverload(item));
end;

procedure TFHIRTurtleComposer.ComposeOperationDefinition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirOperationDefinition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:OperationDefinition'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUri(this, 'OperationDefinition', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(this, 'OperationDefinition', 'version', elem.versionElement, false, -1);{x.2ea}
  ComposeString(this, 'OperationDefinition', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeString(this, 'OperationDefinition', 'title', elem.titleElement, false, -1);{x.2ea}
  ComposeEnum(this, 'OperationDefinition', 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);{x.d4}
  ComposeEnum(this, 'OperationDefinition', 'kind', elem.KindElement, CODES_TFhirOperationKindEnum, SYSTEMS_TFhirOperationKindEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(this, 'OperationDefinition', 'experimental', elem.experimentalElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(this, 'OperationDefinition', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(this, 'OperationDefinition', 'publisher', elem.publisherElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(this, 'OperationDefinition', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdown(this, 'OperationDefinition', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(this, 'OperationDefinition', 'useContext', elem.useContextList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'OperationDefinition', 'jurisdiction', elem.jurisdictionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdown(this, 'OperationDefinition', 'purpose', elem.purposeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('affectsState') then
    ComposeBoolean(this, 'OperationDefinition', 'affectsState', elem.affectsStateElement, false, -1);{x.2ea}
  ComposeCode(this, 'OperationDefinition', 'code', elem.codeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('comment') then
    ComposeMarkdown(this, 'OperationDefinition', 'comment', elem.commentElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('base') then
    ComposeCanonical(this, 'OperationDefinition', 'base', elem.baseElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('resource') then
    for i := 0 to elem.resource.Count - 1 do
      ComposeEnum(this, 'OperationDefinition', 'resource', elem.resource[i], CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, false, i); {x.d1}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('resource') then
    for i := 0 to elem.resource.Count - 1 do
      ComposeEnum(this, 'OperationDefinition', 'resource', elem.resource[i], CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, false, i);{x.d2}
  ComposeBoolean(this, 'OperationDefinition', 'system', elem.systemElement, false, -1);{x.2ea}
  ComposeBoolean(this, 'OperationDefinition', 'type', elem.type_Element, false, -1);{x.2ea}
  ComposeBoolean(this, 'OperationDefinition', 'instance', elem.instanceElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('inputProfile') then
    ComposeCanonical(this, 'OperationDefinition', 'inputProfile', elem.inputProfileElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('outputProfile') then
    ComposeCanonical(this, 'OperationDefinition', 'outputProfile', elem.outputProfileElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('parameter') then
    for i := 0 to elem.parameterList.Count - 1 do
      ComposeOperationDefinitionParameter(this, 'OperationDefinition', 'parameter', elem.parameterList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('overload') then
    for i := 0 to elem.overloadList.Count - 1 do
      ComposeOperationDefinitionOverload(this, 'OperationDefinition', 'overload', elem.overloadList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_OPERATIONDEFINITION}
{$IFDEF FHIR_OPERATIONOUTCOME}
function TFHIRTurtleParser.ParseOperationOutcomeIssue(obj : TTurtleComplex) : TFhirOperationOutcomeIssue;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirOperationOutcomeIssue.create;
  try
    ParseOperationOutcomeIssueProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseOperationOutcomeIssueProperties(obj : TTurtleComplex; result : TFhirOperationOutcomeIssue);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.severityElement := ParseEnum(obj.complex('http://hl7.org/fhir/OperationOutcome.issue.severity'), CODES_TFhirIssueSeverityEnum, SYSTEMS_TFhirIssueSeverityEnum);
    result.codeElement := ParseEnum(obj.complex('http://hl7.org/fhir/OperationOutcome.issue.code'), CODES_TFhirIssueTypeEnum, SYSTEMS_TFhirIssueTypeEnum);
    result.details := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/OperationOutcome.issue.details'));{q3b}
    result.diagnosticsElement := ParseString(obj.complex('http://hl7.org/fhir/OperationOutcome.issue.diagnostics'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/OperationOutcome.issue.location') do
      result.locationList.Add(parseString(item));
    for item in obj.complexes('http://hl7.org/fhir/OperationOutcome.issue.expression') do
      result.expressionList.Add(parseString(item));
end;

procedure TFHIRTurtleComposer.ComposeOperationOutcomeIssue(parent :  TTurtleComplex; parentType, name : String; elem : TFhirOperationOutcomeIssue; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:OperationOutcomeIssue'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'OperationOutcome.issue', 'severity', elem.SeverityElement, CODES_TFhirIssueSeverityEnum, SYSTEMS_TFhirIssueSeverityEnum, false, -1);{x.d4}
  ComposeEnum(this, 'OperationOutcome.issue', 'code', elem.CodeElement, CODES_TFhirIssueTypeEnum, SYSTEMS_TFhirIssueTypeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'OperationOutcome.issue', 'details', elem.detailsElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'OperationOutcome.issue', 'diagnostics', elem.diagnosticsElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.locationList.Count - 1 do
      ComposeString(this, 'OperationOutcome.issue', 'location', elem.locationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.expressionList.Count - 1 do
      ComposeString(this, 'OperationOutcome.issue', 'expression', elem.expressionList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseOperationOutcome(obj : TTurtleComplex) : TFhirOperationOutcome;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirOperationOutcome.create;
  try
    ParseOperationOutcomeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseOperationOutcomeProperties(obj : TTurtleComplex; result : TFhirOperationOutcome);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/OperationOutcome.issue') do
      result.issueList.Add(parseOperationOutcomeIssue(item));
end;

procedure TFHIRTurtleComposer.ComposeOperationOutcome(parent :  TTurtleComplex; parentType, name : String; elem : TFhirOperationOutcome; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:OperationOutcome'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  for i := 0 to elem.issueList.Count - 1 do
      ComposeOperationOutcomeIssue(this, 'OperationOutcome', 'issue', elem.issueList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_OPERATIONOUTCOME}
{$IFDEF FHIR_ORGANIZATION}
function TFHIRTurtleParser.ParseOrganizationContact(obj : TTurtleComplex) : TFhirOrganizationContact;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirOrganizationContact.create;
  try
    ParseOrganizationContactProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseOrganizationContactProperties(obj : TTurtleComplex; result : TFhirOrganizationContact);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.purpose := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Organization.contact.purpose'));{q3b}
    result.name := ParseHumanName(obj.complex('http://hl7.org/fhir/Organization.contact.name'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Organization.contact.telecom') do
      result.telecomList.Add(parseContactPoint(item));
    result.address := ParseAddress(obj.complex('http://hl7.org/fhir/Organization.contact.address'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeOrganizationContact(parent :  TTurtleComplex; parentType, name : String; elem : TFhirOrganizationContact; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:OrganizationContact'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Organization.contact', 'purpose', elem.purposeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeHumanName(this, 'Organization.contact', 'name', elem.nameElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(this, 'Organization.contact', 'telecom', elem.telecomList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeAddress(this, 'Organization.contact', 'address', elem.addressElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseOrganization(obj : TTurtleComplex) : TFhirOrganization;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirOrganization.create;
  try
    ParseOrganizationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseOrganizationProperties(obj : TTurtleComplex; result : TFhirOrganization);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Organization.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.activeElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Organization.active'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Organization.type') do
      result.type_List.Add(parseCodeableConcept(item));
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/Organization.name'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Organization.alias') do
      result.aliasList.Add(parseString(item));
    for item in obj.complexes('http://hl7.org/fhir/Organization.telecom') do
      result.telecomList.Add(parseContactPoint(item));
    for item in obj.complexes('http://hl7.org/fhir/Organization.address') do
      result.addressList.Add(parseAddress(item));
    result.partOf := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/Organization.partOf'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Organization.contact') do
      result.contactList.Add(parseOrganizationContact(item));
    for item in obj.complexes('http://hl7.org/fhir/Organization.endpoint') do
      result.endpointList.Add(parseReference{TFhirEndpoint}(item));
end;

procedure TFHIRTurtleComposer.ComposeOrganization(parent :  TTurtleComplex; parentType, name : String; elem : TFhirOrganization; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Organization'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Organization', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('active') then
    ComposeBoolean(this, 'Organization', 'active', elem.activeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(this, 'Organization', 'type', elem.type_List[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(this, 'Organization', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('alias') then
    for i := 0 to elem.aliasList.Count - 1 do
      ComposeString(this, 'Organization', 'alias', elem.aliasList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('telecom') then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(this, 'Organization', 'telecom', elem.telecomList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('address') then
    for i := 0 to elem.addressList.Count - 1 do
      ComposeAddress(this, 'Organization', 'address', elem.addressList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('partOf') then
    ComposeReference{TFhirOrganization}(this, 'Organization', 'partOf', elem.partOfElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeOrganizationContact(this, 'Organization', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('endpoint') then
    for i := 0 to elem.endpointList.Count - 1 do
      ComposeReference{TFhirEndpoint}(this, 'Organization', 'endpoint', elem.endpointList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_ORGANIZATION}
{$IFDEF FHIR_ORGANIZATIONAFFILIATION}
function TFHIRTurtleParser.ParseOrganizationAffiliation(obj : TTurtleComplex) : TFhirOrganizationAffiliation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirOrganizationAffiliation.create;
  try
    ParseOrganizationAffiliationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseOrganizationAffiliationProperties(obj : TTurtleComplex; result : TFhirOrganizationAffiliation);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/OrganizationAffiliation.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.activeElement := ParseBoolean(obj.complex('http://hl7.org/fhir/OrganizationAffiliation.active'));{q1}
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/OrganizationAffiliation.period'));{q3b}
    result.organization := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/OrganizationAffiliation.organization'));{q3b}
    result.participatingOrganization := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/OrganizationAffiliation.participatingOrganization'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/OrganizationAffiliation.network') do
      result.networkList.Add(parseReference{TFhirOrganization}(item));
    for item in obj.complexes('http://hl7.org/fhir/OrganizationAffiliation.code') do
      result.codeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/OrganizationAffiliation.specialty') do
      result.specialtyList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/OrganizationAffiliation.location') do
      result.locationList.Add(parseReference{TFhirLocation}(item));
    for item in obj.complexes('http://hl7.org/fhir/OrganizationAffiliation.healthcareService') do
      result.healthcareServiceList.Add(parseReference{TFhirHealthcareService}(item));
    for item in obj.complexes('http://hl7.org/fhir/OrganizationAffiliation.telecom') do
      result.telecomList.Add(parseContactPoint(item));
    for item in obj.complexes('http://hl7.org/fhir/OrganizationAffiliation.endpoint') do
      result.endpointList.Add(parseReference{TFhirEndpoint}(item));
end;

procedure TFHIRTurtleComposer.ComposeOrganizationAffiliation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirOrganizationAffiliation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:OrganizationAffiliation'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'OrganizationAffiliation', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('active') then
    ComposeBoolean(this, 'OrganizationAffiliation', 'active', elem.activeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('period') then
    ComposePeriod(this, 'OrganizationAffiliation', 'period', elem.periodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('organization') then
    ComposeReference{TFhirOrganization}(this, 'OrganizationAffiliation', 'organization', elem.organizationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('participatingOrganization') then
    ComposeReference{TFhirOrganization}(this, 'OrganizationAffiliation', 'participatingOrganization', elem.participatingOrganizationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('network') then
    for i := 0 to elem.networkList.Count - 1 do
      ComposeReference{TFhirOrganization}(this, 'OrganizationAffiliation', 'network', elem.networkList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') then
    for i := 0 to elem.codeList.Count - 1 do
      ComposeCodeableConcept(this, 'OrganizationAffiliation', 'code', elem.codeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('specialty') then
    for i := 0 to elem.specialtyList.Count - 1 do
      ComposeCodeableConcept(this, 'OrganizationAffiliation', 'specialty', elem.specialtyList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('location') then
    for i := 0 to elem.locationList.Count - 1 do
      ComposeReference{TFhirLocation}(this, 'OrganizationAffiliation', 'location', elem.locationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('healthcareService') then
    for i := 0 to elem.healthcareServiceList.Count - 1 do
      ComposeReference{TFhirHealthcareService}(this, 'OrganizationAffiliation', 'healthcareService', elem.healthcareServiceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('telecom') then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(this, 'OrganizationAffiliation', 'telecom', elem.telecomList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('endpoint') then
    for i := 0 to elem.endpointList.Count - 1 do
      ComposeReference{TFhirEndpoint}(this, 'OrganizationAffiliation', 'endpoint', elem.endpointList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_ORGANIZATIONAFFILIATION}
{$IFDEF FHIR_PATIENT}
function TFHIRTurtleParser.ParsePatientContact(obj : TTurtleComplex) : TFhirPatientContact;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPatientContact.create;
  try
    ParsePatientContactProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePatientContactProperties(obj : TTurtleComplex; result : TFhirPatientContact);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Patient.contact.relationship') do
      result.relationshipList.Add(parseCodeableConcept(item));
    result.name := ParseHumanName(obj.complex('http://hl7.org/fhir/Patient.contact.name'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Patient.contact.telecom') do
      result.telecomList.Add(parseContactPoint(item));
    result.address := ParseAddress(obj.complex('http://hl7.org/fhir/Patient.contact.address'));{q3b}
    result.genderElement := ParseEnum(obj.complex('http://hl7.org/fhir/Patient.contact.gender'), CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum);
    result.organization := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/Patient.contact.organization'));{q3b}
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Patient.contact.period'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposePatientContact(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPatientContact; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PatientContact'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.relationshipList.Count - 1 do
      ComposeCodeableConcept(this, 'Patient.contact', 'relationship', elem.relationshipList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeHumanName(this, 'Patient.contact', 'name', elem.nameElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(this, 'Patient.contact', 'telecom', elem.telecomList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeAddress(this, 'Patient.contact', 'address', elem.addressElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'Patient.contact', 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(this, 'Patient.contact', 'organization', elem.organizationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'Patient.contact', 'period', elem.periodElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParsePatientCommunication(obj : TTurtleComplex) : TFhirPatientCommunication;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPatientCommunication.create;
  try
    ParsePatientCommunicationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePatientCommunicationProperties(obj : TTurtleComplex; result : TFhirPatientCommunication);
begin
    ParseBackboneElementProperties(obj, result);
    result.language := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Patient.communication.language'));{q3b}
    result.preferredElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Patient.communication.preferred'));{q1}
end;

procedure TFHIRTurtleComposer.ComposePatientCommunication(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPatientCommunication; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PatientCommunication'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'Patient.communication', 'language', elem.languageElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'Patient.communication', 'preferred', elem.preferredElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParsePatientLink(obj : TTurtleComplex) : TFhirPatientLink;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPatientLink.create;
  try
    ParsePatientLinkProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePatientLinkProperties(obj : TTurtleComplex; result : TFhirPatientLink);
begin
    ParseBackboneElementProperties(obj, result);
    result.other := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/Patient.link.other'));{q3b}
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/Patient.link.type'), CODES_TFhirLinkTypeEnum, SYSTEMS_TFhirLinkTypeEnum);
end;

procedure TFHIRTurtleComposer.ComposePatientLink(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPatientLink; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PatientLink'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeReference{TFhirPatient}(this, 'Patient.link', 'other', elem.otherElement, false, -1);{x.2f}
  ComposeEnum(this, 'Patient.link', 'type', elem.Type_Element, CODES_TFhirLinkTypeEnum, SYSTEMS_TFhirLinkTypeEnum, false, -1);{x.d4}
end;

function TFHIRTurtleParser.ParsePatient(obj : TTurtleComplex) : TFhirPatient;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPatient.create;
  try
    ParsePatientProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePatientProperties(obj : TTurtleComplex; result : TFhirPatient);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Patient.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.activeElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Patient.active'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Patient.name') do
      result.nameList.Add(parseHumanName(item));
    for item in obj.complexes('http://hl7.org/fhir/Patient.telecom') do
      result.telecomList.Add(parseContactPoint(item));
    result.genderElement := ParseEnum(obj.complex('http://hl7.org/fhir/Patient.gender'), CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum);
    result.birthDateElement := ParseDate(obj.complex('http://hl7.org/fhir/Patient.birthDate'));{q1}
    if obj.has('http://hl7.org/fhir/Patient.deceasedBoolean', item) then
      result.deceased := parseBoolean(item);
    if obj.has('http://hl7.org/fhir/Patient.deceasedDateTime', item) then
      result.deceased := parseDateTime(item);
    for item in obj.complexes('http://hl7.org/fhir/Patient.address') do
      result.addressList.Add(parseAddress(item));
    result.maritalStatus := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Patient.maritalStatus'));{q3b}
    if obj.has('http://hl7.org/fhir/Patient.multipleBirthBoolean', item) then
      result.multipleBirth := parseBoolean(item);
    if obj.has('http://hl7.org/fhir/Patient.multipleBirthInteger', item) then
      result.multipleBirth := parseInteger(item);
    for item in obj.complexes('http://hl7.org/fhir/Patient.photo') do
      result.photoList.Add(parseAttachment(item));
    for item in obj.complexes('http://hl7.org/fhir/Patient.contact') do
      result.contactList.Add(parsePatientContact(item));
    for item in obj.complexes('http://hl7.org/fhir/Patient.communication') do
      result.communicationList.Add(parsePatientCommunication(item));
    for item in obj.complexes('http://hl7.org/fhir/Patient.generalPractitioner') do
      result.generalPractitionerList.Add(parseReference{TFhirOrganization}(item));
    result.managingOrganization := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/Patient.managingOrganization'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Patient.link') do
      result.link_List.Add(parsePatientLink(item));
end;

procedure TFHIRTurtleComposer.ComposePatient(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPatient; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Patient'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Patient', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('active') then
    ComposeBoolean(this, 'Patient', 'active', elem.activeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    for i := 0 to elem.nameList.Count - 1 do
      ComposeHumanName(this, 'Patient', 'name', elem.nameList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('telecom') then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(this, 'Patient', 'telecom', elem.telecomList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('gender') then
    ComposeEnum(this, 'Patient', 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('birthDate') then
    ComposeDate(this, 'Patient', 'birthDate', elem.birthDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.deceased is TFhirBoolean) {6} then
    ComposeBoolean(this, 'Patient', 'deceasedBoolean', TFhirBoolean(elem.deceased), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.deceased is TFhirDateTime) {6} then
    ComposeDateTime(this, 'Patient', 'deceasedDateTime', TFhirDateTime(elem.deceased), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('address') then
    for i := 0 to elem.addressList.Count - 1 do
      ComposeAddress(this, 'Patient', 'address', elem.addressList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('maritalStatus') then
    ComposeCodeableConcept(this, 'Patient', 'maritalStatus', elem.maritalStatusElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and (elem.multipleBirth is TFhirBoolean) {6} then
    ComposeBoolean(this, 'Patient', 'multipleBirthBoolean', TFhirBoolean(elem.multipleBirth), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.multipleBirth is TFhirInteger) {6} then
    ComposeInteger(this, 'Patient', 'multipleBirthInteger', TFhirInteger(elem.multipleBirth), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) and doCompose('photo') then
    for i := 0 to elem.photoList.Count - 1 do
      ComposeAttachment(this, 'Patient', 'photo', elem.photoList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposePatientContact(this, 'Patient', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('communication') then
    for i := 0 to elem.communicationList.Count - 1 do
      ComposePatientCommunication(this, 'Patient', 'communication', elem.communicationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('generalPractitioner') then
    for i := 0 to elem.generalPractitionerList.Count - 1 do
      ComposeReference{TFhirOrganization}(this, 'Patient', 'generalPractitioner', elem.generalPractitionerList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('managingOrganization') then
    ComposeReference{TFhirOrganization}(this, 'Patient', 'managingOrganization', elem.managingOrganizationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('link_') then
    for i := 0 to elem.link_List.Count - 1 do
      ComposePatientLink(this, 'Patient', 'link', elem.link_List[i], false, i);{x.d3}
end;

{$ENDIF FHIR_PATIENT}
{$IFDEF FHIR_PAYMENTNOTICE}
function TFHIRTurtleParser.ParsePaymentNotice(obj : TTurtleComplex) : TFhirPaymentNotice;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPaymentNotice.create;
  try
    ParsePaymentNoticeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePaymentNoticeProperties(obj : TTurtleComplex; result : TFhirPaymentNotice);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/PaymentNotice.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/PaymentNotice.status'), CODES_TFhirFmStatusEnum, SYSTEMS_TFhirFmStatusEnum);
    result.request := ParseReference{TFhirReference}(obj.complex('http://hl7.org/fhir/PaymentNotice.request'));{q3b}
    result.response := ParseReference{TFhirReference}(obj.complex('http://hl7.org/fhir/PaymentNotice.response'));{q3b}
    result.createdElement := ParseDateTime(obj.complex('http://hl7.org/fhir/PaymentNotice.created'));{q1}
    result.provider := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/PaymentNotice.provider'));{q3b}
    result.payment := ParseReference{TFhirPaymentReconciliation}(obj.complex('http://hl7.org/fhir/PaymentNotice.payment'));{q3b}
    result.paymentDateElement := ParseDate(obj.complex('http://hl7.org/fhir/PaymentNotice.paymentDate'));{q1}
    result.payee := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/PaymentNotice.payee'));{q3b}
    result.recipient := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/PaymentNotice.recipient'));{q3b}
    result.amount := ParseMoney(obj.complex('http://hl7.org/fhir/PaymentNotice.amount'));{q3b}
    result.paymentStatus := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/PaymentNotice.paymentStatus'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposePaymentNotice(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPaymentNotice; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PaymentNotice'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'PaymentNotice', 'identifier', elem.identifierList[i], false, i);{x.d3}
  ComposeEnum(this, 'PaymentNotice', 'status', elem.StatusElement, CODES_TFhirFmStatusEnum, SYSTEMS_TFhirFmStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('request') then
    ComposeReference{TFhirReference}(this, 'PaymentNotice', 'request', elem.requestElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('response') then
    ComposeReference{TFhirReference}(this, 'PaymentNotice', 'response', elem.responseElement, false, -1);{x.2f}
  ComposeDateTime(this, 'PaymentNotice', 'created', elem.createdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('provider') then
    ComposeReference{TFhirPractitioner}(this, 'PaymentNotice', 'provider', elem.providerElement, false, -1);{x.2f}
  ComposeReference{TFhirPaymentReconciliation}(this, 'PaymentNotice', 'payment', elem.paymentElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('paymentDate') then
    ComposeDate(this, 'PaymentNotice', 'paymentDate', elem.paymentDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('payee') then
    ComposeReference{TFhirPractitioner}(this, 'PaymentNotice', 'payee', elem.payeeElement, false, -1);{x.2f}
  ComposeReference{TFhirOrganization}(this, 'PaymentNotice', 'recipient', elem.recipientElement, false, -1);{x.2f}
  ComposeMoney(this, 'PaymentNotice', 'amount', elem.amountElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('paymentStatus') then
    ComposeCodeableConcept(this, 'PaymentNotice', 'paymentStatus', elem.paymentStatusElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_PAYMENTNOTICE}
{$IFDEF FHIR_PAYMENTRECONCILIATION}
function TFHIRTurtleParser.ParsePaymentReconciliationDetail(obj : TTurtleComplex) : TFhirPaymentReconciliationDetail;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPaymentReconciliationDetail.create;
  try
    ParsePaymentReconciliationDetailProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePaymentReconciliationDetailProperties(obj : TTurtleComplex; result : TFhirPaymentReconciliationDetail);
begin
    ParseBackboneElementProperties(obj, result);
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/PaymentReconciliation.detail.identifier'));{q3b}
    result.predecessor := ParseIdentifier(obj.complex('http://hl7.org/fhir/PaymentReconciliation.detail.predecessor'));{q3b}
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/PaymentReconciliation.detail.type'));{q3b}
    result.request := ParseReference{TFhirReference}(obj.complex('http://hl7.org/fhir/PaymentReconciliation.detail.request'));{q3b}
    result.submitter := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/PaymentReconciliation.detail.submitter'));{q3b}
    result.response := ParseReference{TFhirReference}(obj.complex('http://hl7.org/fhir/PaymentReconciliation.detail.response'));{q3b}
    result.dateElement := ParseDate(obj.complex('http://hl7.org/fhir/PaymentReconciliation.detail.date'));{q1}
    result.responsible := ParseReference{TFhirPractitionerRole}(obj.complex('http://hl7.org/fhir/PaymentReconciliation.detail.responsible'));{q3b}
    result.payee := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/PaymentReconciliation.detail.payee'));{q3b}
    result.amount := ParseMoney(obj.complex('http://hl7.org/fhir/PaymentReconciliation.detail.amount'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposePaymentReconciliationDetail(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPaymentReconciliationDetail; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PaymentReconciliationDetail'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(this, 'PaymentReconciliation.detail', 'identifier', elem.identifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(this, 'PaymentReconciliation.detail', 'predecessor', elem.predecessorElement, false, -1);{x.2f}
  ComposeCodeableConcept(this, 'PaymentReconciliation.detail', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirReference}(this, 'PaymentReconciliation.detail', 'request', elem.requestElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirPractitioner}(this, 'PaymentReconciliation.detail', 'submitter', elem.submitterElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirReference}(this, 'PaymentReconciliation.detail', 'response', elem.responseElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeDate(this, 'PaymentReconciliation.detail', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirPractitionerRole}(this, 'PaymentReconciliation.detail', 'responsible', elem.responsibleElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirPractitioner}(this, 'PaymentReconciliation.detail', 'payee', elem.payeeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(this, 'PaymentReconciliation.detail', 'amount', elem.amountElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParsePaymentReconciliationProcessNote(obj : TTurtleComplex) : TFhirPaymentReconciliationProcessNote;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPaymentReconciliationProcessNote.create;
  try
    ParsePaymentReconciliationProcessNoteProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePaymentReconciliationProcessNoteProperties(obj : TTurtleComplex; result : TFhirPaymentReconciliationProcessNote);
begin
    ParseBackboneElementProperties(obj, result);
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/PaymentReconciliation.processNote.type'), CODES_TFhirNoteTypeEnum, SYSTEMS_TFhirNoteTypeEnum);
    result.textElement := ParseString(obj.complex('http://hl7.org/fhir/PaymentReconciliation.processNote.text'));{q1}
end;

procedure TFHIRTurtleComposer.ComposePaymentReconciliationProcessNote(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPaymentReconciliationProcessNote; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PaymentReconciliationProcessNote'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'PaymentReconciliation.processNote', 'type', elem.Type_Element, CODES_TFhirNoteTypeEnum, SYSTEMS_TFhirNoteTypeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'PaymentReconciliation.processNote', 'text', elem.textElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParsePaymentReconciliation(obj : TTurtleComplex) : TFhirPaymentReconciliation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPaymentReconciliation.create;
  try
    ParsePaymentReconciliationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePaymentReconciliationProperties(obj : TTurtleComplex; result : TFhirPaymentReconciliation);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/PaymentReconciliation.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/PaymentReconciliation.status'), CODES_TFhirFmStatusEnum, SYSTEMS_TFhirFmStatusEnum);
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/PaymentReconciliation.period'));{q3b}
    result.createdElement := ParseDateTime(obj.complex('http://hl7.org/fhir/PaymentReconciliation.created'));{q1}
    result.paymentIssuer := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/PaymentReconciliation.paymentIssuer'));{q3b}
    result.request := ParseReference{TFhirTask}(obj.complex('http://hl7.org/fhir/PaymentReconciliation.request'));{q3b}
    result.requestor := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/PaymentReconciliation.requestor'));{q3b}
    result.outcomeElement := ParseEnum(obj.complex('http://hl7.org/fhir/PaymentReconciliation.outcome'), CODES_TFhirRemittanceOutcomeEnum, SYSTEMS_TFhirRemittanceOutcomeEnum);
    result.dispositionElement := ParseString(obj.complex('http://hl7.org/fhir/PaymentReconciliation.disposition'));{q1}
    result.paymentDateElement := ParseDate(obj.complex('http://hl7.org/fhir/PaymentReconciliation.paymentDate'));{q1}
    result.paymentAmount := ParseMoney(obj.complex('http://hl7.org/fhir/PaymentReconciliation.paymentAmount'));{q3b}
    result.paymentIdentifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/PaymentReconciliation.paymentIdentifier'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/PaymentReconciliation.detail') do
      result.detailList.Add(parsePaymentReconciliationDetail(item));
    result.formCode := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/PaymentReconciliation.formCode'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/PaymentReconciliation.processNote') do
      result.processNoteList.Add(parsePaymentReconciliationProcessNote(item));
end;

procedure TFHIRTurtleComposer.ComposePaymentReconciliation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPaymentReconciliation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PaymentReconciliation'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'PaymentReconciliation', 'identifier', elem.identifierList[i], false, i);{x.d3}
  ComposeEnum(this, 'PaymentReconciliation', 'status', elem.StatusElement, CODES_TFhirFmStatusEnum, SYSTEMS_TFhirFmStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('period') then
    ComposePeriod(this, 'PaymentReconciliation', 'period', elem.periodElement, false, -1);{x.2f}
  ComposeDateTime(this, 'PaymentReconciliation', 'created', elem.createdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('paymentIssuer') then
    ComposeReference{TFhirOrganization}(this, 'PaymentReconciliation', 'paymentIssuer', elem.paymentIssuerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('request') then
    ComposeReference{TFhirTask}(this, 'PaymentReconciliation', 'request', elem.requestElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('requestor') then
    ComposeReference{TFhirPractitioner}(this, 'PaymentReconciliation', 'requestor', elem.requestorElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('outcome') then
    ComposeEnum(this, 'PaymentReconciliation', 'outcome', elem.OutcomeElement, CODES_TFhirRemittanceOutcomeEnum, SYSTEMS_TFhirRemittanceOutcomeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('disposition') then
    ComposeString(this, 'PaymentReconciliation', 'disposition', elem.dispositionElement, false, -1);{x.2ea}
  ComposeDate(this, 'PaymentReconciliation', 'paymentDate', elem.paymentDateElement, false, -1);{x.2ea}
  ComposeMoney(this, 'PaymentReconciliation', 'paymentAmount', elem.paymentAmountElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('paymentIdentifier') then
    ComposeIdentifier(this, 'PaymentReconciliation', 'paymentIdentifier', elem.paymentIdentifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('detail') then
    for i := 0 to elem.detailList.Count - 1 do
      ComposePaymentReconciliationDetail(this, 'PaymentReconciliation', 'detail', elem.detailList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('formCode') then
    ComposeCodeableConcept(this, 'PaymentReconciliation', 'formCode', elem.formCodeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('processNote') then
    for i := 0 to elem.processNoteList.Count - 1 do
      ComposePaymentReconciliationProcessNote(this, 'PaymentReconciliation', 'processNote', elem.processNoteList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_PAYMENTRECONCILIATION}
{$IFDEF FHIR_PERSON}
function TFHIRTurtleParser.ParsePersonLink(obj : TTurtleComplex) : TFhirPersonLink;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPersonLink.create;
  try
    ParsePersonLinkProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePersonLinkProperties(obj : TTurtleComplex; result : TFhirPersonLink);
begin
    ParseBackboneElementProperties(obj, result);
    result.target := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/Person.link.target'));{q3b}
    result.assuranceElement := ParseEnum(obj.complex('http://hl7.org/fhir/Person.link.assurance'), CODES_TFhirIdentityAssuranceLevelEnum, SYSTEMS_TFhirIdentityAssuranceLevelEnum);
end;

procedure TFHIRTurtleComposer.ComposePersonLink(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPersonLink; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PersonLink'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeReference{TFhirPatient}(this, 'Person.link', 'target', elem.targetElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'Person.link', 'assurance', elem.AssuranceElement, CODES_TFhirIdentityAssuranceLevelEnum, SYSTEMS_TFhirIdentityAssuranceLevelEnum, false, -1);{x.d4}
end;

function TFHIRTurtleParser.ParsePerson(obj : TTurtleComplex) : TFhirPerson;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPerson.create;
  try
    ParsePersonProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePersonProperties(obj : TTurtleComplex; result : TFhirPerson);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Person.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/Person.name') do
      result.nameList.Add(parseHumanName(item));
    for item in obj.complexes('http://hl7.org/fhir/Person.telecom') do
      result.telecomList.Add(parseContactPoint(item));
    result.genderElement := ParseEnum(obj.complex('http://hl7.org/fhir/Person.gender'), CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum);
    result.birthDateElement := ParseDate(obj.complex('http://hl7.org/fhir/Person.birthDate'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Person.address') do
      result.addressList.Add(parseAddress(item));
    result.photo := ParseAttachment(obj.complex('http://hl7.org/fhir/Person.photo'));{q3b}
    result.managingOrganization := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/Person.managingOrganization'));{q3b}
    result.activeElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Person.active'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Person.link') do
      result.link_List.Add(parsePersonLink(item));
end;

procedure TFHIRTurtleComposer.ComposePerson(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPerson; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Person'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Person', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    for i := 0 to elem.nameList.Count - 1 do
      ComposeHumanName(this, 'Person', 'name', elem.nameList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('telecom') then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(this, 'Person', 'telecom', elem.telecomList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('gender') then
    ComposeEnum(this, 'Person', 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('birthDate') then
    ComposeDate(this, 'Person', 'birthDate', elem.birthDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('address') then
    for i := 0 to elem.addressList.Count - 1 do
      ComposeAddress(this, 'Person', 'address', elem.addressList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('photo') then
    ComposeAttachment(this, 'Person', 'photo', elem.photoElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('managingOrganization') then
    ComposeReference{TFhirOrganization}(this, 'Person', 'managingOrganization', elem.managingOrganizationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('active') then
    ComposeBoolean(this, 'Person', 'active', elem.activeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('link_') then
    for i := 0 to elem.link_List.Count - 1 do
      ComposePersonLink(this, 'Person', 'link', elem.link_List[i], false, i);{x.d3}
end;

{$ENDIF FHIR_PERSON}
{$IFDEF FHIR_PLANDEFINITION}
function TFHIRTurtleParser.ParsePlanDefinitionGoal(obj : TTurtleComplex) : TFhirPlanDefinitionGoal;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPlanDefinitionGoal.create;
  try
    ParsePlanDefinitionGoalProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePlanDefinitionGoalProperties(obj : TTurtleComplex; result : TFhirPlanDefinitionGoal);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/PlanDefinition.goal.category'));{q3b}
    result.description := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/PlanDefinition.goal.description'));{q3b}
    result.priority := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/PlanDefinition.goal.priority'));{q3b}
    result.start := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/PlanDefinition.goal.start'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.goal.addresses') do
      result.addressesList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.goal.documentation') do
      result.documentationList.Add(parseRelatedArtifact(item));
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.goal.target') do
      result.targetList.Add(parsePlanDefinitionGoalTarget(item));
end;

procedure TFHIRTurtleComposer.ComposePlanDefinitionGoal(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPlanDefinitionGoal; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PlanDefinitionGoal'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'PlanDefinition.goal', 'category', elem.categoryElement, false, -1);{x.2f}
  ComposeCodeableConcept(this, 'PlanDefinition.goal', 'description', elem.descriptionElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'PlanDefinition.goal', 'priority', elem.priorityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'PlanDefinition.goal', 'start', elem.startElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.addressesList.Count - 1 do
      ComposeCodeableConcept(this, 'PlanDefinition.goal', 'addresses', elem.addressesList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.documentationList.Count - 1 do
      ComposeRelatedArtifact(this, 'PlanDefinition.goal', 'documentation', elem.documentationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.targetList.Count - 1 do
      ComposePlanDefinitionGoalTarget(this, 'PlanDefinition.goal', 'target', elem.targetList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParsePlanDefinitionGoalTarget(obj : TTurtleComplex) : TFhirPlanDefinitionGoalTarget;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPlanDefinitionGoalTarget.create;
  try
    ParsePlanDefinitionGoalTargetProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePlanDefinitionGoalTargetProperties(obj : TTurtleComplex; result : TFhirPlanDefinitionGoalTarget);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.measure := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/PlanDefinition.goal.target.measure'));{q3b}
    if obj.has('http://hl7.org/fhir/PlanDefinition.goal.target.detailQuantity', item) then
      result.detail := parseQuantity(item);
    if obj.has('http://hl7.org/fhir/PlanDefinition.goal.target.detailRange', item) then
      result.detail := parseRange(item);
    if obj.has('http://hl7.org/fhir/PlanDefinition.goal.target.detailCodeableConcept', item) then
      result.detail := parseCodeableConcept(item);
    result.due := ParseDuration(obj.complex('http://hl7.org/fhir/PlanDefinition.goal.target.due'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposePlanDefinitionGoalTarget(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPlanDefinitionGoalTarget; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PlanDefinitionGoalTarget'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'PlanDefinition.goal.target', 'measure', elem.measureElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and (elem.detail is TFhirQuantity) {6} then
    ComposeQuantity(this, 'PlanDefinition.goal.target', 'detailQuantity', TFhirQuantity(elem.detail), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.detail is TFhirRange) {6} then
    ComposeRange(this, 'PlanDefinition.goal.target', 'detailRange', TFhirRange(elem.detail), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.detail is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'PlanDefinition.goal.target', 'detailCodeableConcept', TFhirCodeableConcept(elem.detail), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) then
    ComposeDuration(this, 'PlanDefinition.goal.target', 'due', elem.dueElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParsePlanDefinitionAction(obj : TTurtleComplex) : TFhirPlanDefinitionAction;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPlanDefinitionAction.create;
  try
    ParsePlanDefinitionActionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePlanDefinitionActionProperties(obj : TTurtleComplex; result : TFhirPlanDefinitionAction);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.prefixElement := ParseString(obj.complex('http://hl7.org/fhir/PlanDefinition.action.prefix'));{q1}
    result.titleElement := ParseString(obj.complex('http://hl7.org/fhir/PlanDefinition.action.title'));{q1}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/PlanDefinition.action.description'));{q1}
    result.textEquivalentElement := ParseString(obj.complex('http://hl7.org/fhir/PlanDefinition.action.textEquivalent'));{q1}
    result.priorityElement := ParseEnum(obj.complex('http://hl7.org/fhir/PlanDefinition.action.priority'), CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum);
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.action.code') do
      result.codeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.action.reason') do
      result.reasonList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.action.documentation') do
      result.documentationList.Add(parseRelatedArtifact(item));
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.action.goalId') do
      result.goalIdList.Add(parseId(item));
    if obj.has('http://hl7.org/fhir/PlanDefinition.action.subjectCodeableConcept', item) then
      result.subject := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/PlanDefinition.action.subjectReference', item) {a3} then
      result.subject := ParseReference(item);
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.action.trigger') do
      result.triggerList.Add(parseTriggerDefinition(item));
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.action.condition') do
      result.conditionList.Add(parsePlanDefinitionActionCondition(item));
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.action.input') do
      result.inputList.Add(parseDataRequirement(item));
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.action.output') do
      result.outputList.Add(parseDataRequirement(item));
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.action.relatedAction') do
      result.relatedActionList.Add(parsePlanDefinitionActionRelatedAction(item));
    if obj.has('http://hl7.org/fhir/PlanDefinition.action.timingAge', item) then
      result.timing := parseAge(item);
    if obj.has('http://hl7.org/fhir/PlanDefinition.action.timingPeriod', item) then
      result.timing := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/PlanDefinition.action.timingDuration', item) then
      result.timing := parseDuration(item);
    if obj.has('http://hl7.org/fhir/PlanDefinition.action.timingRange', item) then
      result.timing := parseRange(item);
    if obj.has('http://hl7.org/fhir/PlanDefinition.action.timingTiming', item) then
      result.timing := parseTiming(item);
    if obj.has('http://hl7.org/fhir/PlanDefinition.action.timingDateTime', item) then
      result.timing := parseDateTime(item);
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.action.participant') do
      result.participantList.Add(parsePlanDefinitionActionParticipant(item));
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/PlanDefinition.action.type'));{q3b}
    result.groupingBehaviorElement := ParseEnum(obj.complex('http://hl7.org/fhir/PlanDefinition.action.groupingBehavior'), CODES_TFhirActionGroupingBehaviorEnum, SYSTEMS_TFhirActionGroupingBehaviorEnum);
    result.selectionBehaviorElement := ParseEnum(obj.complex('http://hl7.org/fhir/PlanDefinition.action.selectionBehavior'), CODES_TFhirActionSelectionBehaviorEnum, SYSTEMS_TFhirActionSelectionBehaviorEnum);
    result.requiredBehaviorElement := ParseEnum(obj.complex('http://hl7.org/fhir/PlanDefinition.action.requiredBehavior'), CODES_TFhirActionRequiredBehaviorEnum, SYSTEMS_TFhirActionRequiredBehaviorEnum);
    result.precheckBehaviorElement := ParseEnum(obj.complex('http://hl7.org/fhir/PlanDefinition.action.precheckBehavior'), CODES_TFhirActionPrecheckBehaviorEnum, SYSTEMS_TFhirActionPrecheckBehaviorEnum);
    result.cardinalityBehaviorElement := ParseEnum(obj.complex('http://hl7.org/fhir/PlanDefinition.action.cardinalityBehavior'), CODES_TFhirActionCardinalityBehaviorEnum, SYSTEMS_TFhirActionCardinalityBehaviorEnum);
    if obj.has('http://hl7.org/fhir/PlanDefinition.action.definitionCanonical', item) then
      result.definition := parseCanonical(item);
    if obj.has('http://hl7.org/fhir/PlanDefinition.action.definitionUri', item) then
      result.definition := parseUri(item);
    result.transformElement := ParseCanonical(obj.complex('http://hl7.org/fhir/PlanDefinition.action.transform'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.action.dynamicValue') do
      result.dynamicValueList.Add(parsePlanDefinitionActionDynamicValue(item));
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.action.action') do
      result.actionList.Add(parsePlanDefinitionAction(item));
end;

procedure TFHIRTurtleComposer.ComposePlanDefinitionAction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPlanDefinitionAction; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PlanDefinitionAction'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'PlanDefinition.action', 'prefix', elem.prefixElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'PlanDefinition.action', 'title', elem.titleElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'PlanDefinition.action', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'PlanDefinition.action', 'textEquivalent', elem.textEquivalentElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'PlanDefinition.action', 'priority', elem.PriorityElement, CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.codeList.Count - 1 do
      ComposeCodeableConcept(this, 'PlanDefinition.action', 'code', elem.codeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.reasonList.Count - 1 do
      ComposeCodeableConcept(this, 'PlanDefinition.action', 'reason', elem.reasonList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.documentationList.Count - 1 do
      ComposeRelatedArtifact(this, 'PlanDefinition.action', 'documentation', elem.documentationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.goalIdList.Count - 1 do
      ComposeId(this, 'PlanDefinition.action', 'goalId', elem.goalIdList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and (elem.subject is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'PlanDefinition.action', 'subjectCodeableConcept', TFhirCodeableConcept(elem.subject), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.subject is TFhirReference) {2} then
    ComposeReference(this, 'PlanDefinition.action', 'subjectReference', TFhirReference(elem.subject), false,-1);{x.d8}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.triggerList.Count - 1 do
      ComposeTriggerDefinition(this, 'PlanDefinition.action', 'trigger', elem.triggerList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.conditionList.Count - 1 do
      ComposePlanDefinitionActionCondition(this, 'PlanDefinition.action', 'condition', elem.conditionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.inputList.Count - 1 do
      ComposeDataRequirement(this, 'PlanDefinition.action', 'input', elem.inputList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.outputList.Count - 1 do
      ComposeDataRequirement(this, 'PlanDefinition.action', 'output', elem.outputList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.relatedActionList.Count - 1 do
      ComposePlanDefinitionActionRelatedAction(this, 'PlanDefinition.action', 'relatedAction', elem.relatedActionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirAge) {6} then
    ComposeAge(this, 'PlanDefinition.action', 'timingAge', TFhirAge(elem.timing), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirPeriod) {6} then
    ComposePeriod(this, 'PlanDefinition.action', 'timingPeriod', TFhirPeriod(elem.timing), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirDuration) {6} then
    ComposeDuration(this, 'PlanDefinition.action', 'timingDuration', TFhirDuration(elem.timing), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirRange) {6} then
    ComposeRange(this, 'PlanDefinition.action', 'timingRange', TFhirRange(elem.timing), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirTiming) {6} then
    ComposeTiming(this, 'PlanDefinition.action', 'timingTiming', TFhirTiming(elem.timing), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirDateTime) {6} then
    ComposeDateTime(this, 'PlanDefinition.action', 'timingDateTime', TFhirDateTime(elem.timing), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.participantList.Count - 1 do
      ComposePlanDefinitionActionParticipant(this, 'PlanDefinition.action', 'participant', elem.participantList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'PlanDefinition.action', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'PlanDefinition.action', 'groupingBehavior', elem.GroupingBehaviorElement, CODES_TFhirActionGroupingBehaviorEnum, SYSTEMS_TFhirActionGroupingBehaviorEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'PlanDefinition.action', 'selectionBehavior', elem.SelectionBehaviorElement, CODES_TFhirActionSelectionBehaviorEnum, SYSTEMS_TFhirActionSelectionBehaviorEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'PlanDefinition.action', 'requiredBehavior', elem.RequiredBehaviorElement, CODES_TFhirActionRequiredBehaviorEnum, SYSTEMS_TFhirActionRequiredBehaviorEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'PlanDefinition.action', 'precheckBehavior', elem.PrecheckBehaviorElement, CODES_TFhirActionPrecheckBehaviorEnum, SYSTEMS_TFhirActionPrecheckBehaviorEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'PlanDefinition.action', 'cardinalityBehavior', elem.CardinalityBehaviorElement, CODES_TFhirActionCardinalityBehaviorEnum, SYSTEMS_TFhirActionCardinalityBehaviorEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and (elem.definition is TFhirCanonical) {6} then
    ComposeCanonical(this, 'PlanDefinition.action', 'definitionCanonical', TFhirCanonical(elem.definition), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.definition is TFhirUri) {6} then
    ComposeUri(this, 'PlanDefinition.action', 'definitionUri', TFhirUri(elem.definition), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(this, 'PlanDefinition.action', 'transform', elem.transformElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.dynamicValueList.Count - 1 do
      ComposePlanDefinitionActionDynamicValue(this, 'PlanDefinition.action', 'dynamicValue', elem.dynamicValueList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.actionList.Count - 1 do
      ComposePlanDefinitionAction(this, 'PlanDefinition.action', 'action', elem.actionList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParsePlanDefinitionActionCondition(obj : TTurtleComplex) : TFhirPlanDefinitionActionCondition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPlanDefinitionActionCondition.create;
  try
    ParsePlanDefinitionActionConditionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePlanDefinitionActionConditionProperties(obj : TTurtleComplex; result : TFhirPlanDefinitionActionCondition);
begin
    ParseBackboneElementProperties(obj, result);
    result.kindElement := ParseEnum(obj.complex('http://hl7.org/fhir/PlanDefinition.action.condition.kind'), CODES_TFhirActionConditionKindEnum, SYSTEMS_TFhirActionConditionKindEnum);
    result.expression := ParseExpression(obj.complex('http://hl7.org/fhir/PlanDefinition.action.condition.expression'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposePlanDefinitionActionCondition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPlanDefinitionActionCondition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PlanDefinitionActionCondition'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'PlanDefinition.action.condition', 'kind', elem.KindElement, CODES_TFhirActionConditionKindEnum, SYSTEMS_TFhirActionConditionKindEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeExpression(this, 'PlanDefinition.action.condition', 'expression', elem.expressionElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParsePlanDefinitionActionRelatedAction(obj : TTurtleComplex) : TFhirPlanDefinitionActionRelatedAction;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPlanDefinitionActionRelatedAction.create;
  try
    ParsePlanDefinitionActionRelatedActionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePlanDefinitionActionRelatedActionProperties(obj : TTurtleComplex; result : TFhirPlanDefinitionActionRelatedAction);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.actionIdElement := ParseId(obj.complex('http://hl7.org/fhir/PlanDefinition.action.relatedAction.actionId'));{q1}
    result.relationshipElement := ParseEnum(obj.complex('http://hl7.org/fhir/PlanDefinition.action.relatedAction.relationship'), CODES_TFhirActionRelationshipTypeEnum, SYSTEMS_TFhirActionRelationshipTypeEnum);
    if obj.has('http://hl7.org/fhir/PlanDefinition.action.relatedAction.offsetDuration', item) then
      result.offset := parseDuration(item);
    if obj.has('http://hl7.org/fhir/PlanDefinition.action.relatedAction.offsetRange', item) then
      result.offset := parseRange(item);
end;

procedure TFHIRTurtleComposer.ComposePlanDefinitionActionRelatedAction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPlanDefinitionActionRelatedAction; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PlanDefinitionActionRelatedAction'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeId(this, 'PlanDefinition.action.relatedAction', 'actionId', elem.actionIdElement, false, -1);{x.2ea}
  ComposeEnum(this, 'PlanDefinition.action.relatedAction', 'relationship', elem.RelationshipElement, CODES_TFhirActionRelationshipTypeEnum, SYSTEMS_TFhirActionRelationshipTypeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and (elem.offset is TFhirDuration) {6} then
    ComposeDuration(this, 'PlanDefinition.action.relatedAction', 'offsetDuration', TFhirDuration(elem.offset), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.offset is TFhirRange) {6} then
    ComposeRange(this, 'PlanDefinition.action.relatedAction', 'offsetRange', TFhirRange(elem.offset), false, -1);{x.d9}
end;

function TFHIRTurtleParser.ParsePlanDefinitionActionParticipant(obj : TTurtleComplex) : TFhirPlanDefinitionActionParticipant;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPlanDefinitionActionParticipant.create;
  try
    ParsePlanDefinitionActionParticipantProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePlanDefinitionActionParticipantProperties(obj : TTurtleComplex; result : TFhirPlanDefinitionActionParticipant);
begin
    ParseBackboneElementProperties(obj, result);
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/PlanDefinition.action.participant.type'), CODES_TFhirActionParticipantTypeEnum, SYSTEMS_TFhirActionParticipantTypeEnum);
    result.role := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/PlanDefinition.action.participant.role'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposePlanDefinitionActionParticipant(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPlanDefinitionActionParticipant; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PlanDefinitionActionParticipant'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'PlanDefinition.action.participant', 'type', elem.Type_Element, CODES_TFhirActionParticipantTypeEnum, SYSTEMS_TFhirActionParticipantTypeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'PlanDefinition.action.participant', 'role', elem.roleElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParsePlanDefinitionActionDynamicValue(obj : TTurtleComplex) : TFhirPlanDefinitionActionDynamicValue;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPlanDefinitionActionDynamicValue.create;
  try
    ParsePlanDefinitionActionDynamicValueProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePlanDefinitionActionDynamicValueProperties(obj : TTurtleComplex; result : TFhirPlanDefinitionActionDynamicValue);
begin
    ParseBackboneElementProperties(obj, result);
    result.pathElement := ParseString(obj.complex('http://hl7.org/fhir/PlanDefinition.action.dynamicValue.path'));{q1}
    result.expression := ParseExpression(obj.complex('http://hl7.org/fhir/PlanDefinition.action.dynamicValue.expression'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposePlanDefinitionActionDynamicValue(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPlanDefinitionActionDynamicValue; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PlanDefinitionActionDynamicValue'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'PlanDefinition.action.dynamicValue', 'path', elem.pathElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeExpression(this, 'PlanDefinition.action.dynamicValue', 'expression', elem.expressionElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParsePlanDefinition(obj : TTurtleComplex) : TFhirPlanDefinition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPlanDefinition.create;
  try
    ParsePlanDefinitionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePlanDefinitionProperties(obj : TTurtleComplex; result : TFhirPlanDefinition);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/PlanDefinition.url'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/PlanDefinition.version'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/PlanDefinition.name'));{q1}
    result.titleElement := ParseString(obj.complex('http://hl7.org/fhir/PlanDefinition.title'));{q1}
    result.subtitleElement := ParseString(obj.complex('http://hl7.org/fhir/PlanDefinition.subtitle'));{q1}
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/PlanDefinition.type'));{q3b}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/PlanDefinition.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    result.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/PlanDefinition.experimental'));{q1}
    if obj.has('http://hl7.org/fhir/PlanDefinition.subjectCodeableConcept', item) then
      result.subject := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/PlanDefinition.subjectReference', item) {a3} then
      result.subject := ParseReference(item);
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/PlanDefinition.date'));{q1}
    result.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/PlanDefinition.publisher'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.contact') do
      result.contactList.Add(parseContactDetail(item));
    result.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/PlanDefinition.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.useContext') do
      result.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.jurisdiction') do
      result.jurisdictionList.Add(parseCodeableConcept(item));
    result.purposeElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/PlanDefinition.purpose'));{q1}
    result.usageElement := ParseString(obj.complex('http://hl7.org/fhir/PlanDefinition.usage'));{q1}
    result.copyrightElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/PlanDefinition.copyright'));{q1}
    result.approvalDateElement := ParseDate(obj.complex('http://hl7.org/fhir/PlanDefinition.approvalDate'));{q1}
    result.lastReviewDateElement := ParseDate(obj.complex('http://hl7.org/fhir/PlanDefinition.lastReviewDate'));{q1}
    result.effectivePeriod := ParsePeriod(obj.complex('http://hl7.org/fhir/PlanDefinition.effectivePeriod'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.topic') do
      result.topicList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.author') do
      result.authorList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.editor') do
      result.editorList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.reviewer') do
      result.reviewerList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.endorser') do
      result.endorserList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.relatedArtifact') do
      result.relatedArtifactList.Add(parseRelatedArtifact(item));
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.library') do
      result.library_List.Add(parseCanonical(item));
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.goal') do
      result.goalList.Add(parsePlanDefinitionGoal(item));
    for item in obj.complexes('http://hl7.org/fhir/PlanDefinition.action') do
      result.actionList.Add(parsePlanDefinitionAction(item));
end;

procedure TFHIRTurtleComposer.ComposePlanDefinition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPlanDefinition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PlanDefinition'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUri(this, 'PlanDefinition', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'PlanDefinition', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(this, 'PlanDefinition', 'version', elem.versionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(this, 'PlanDefinition', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeString(this, 'PlanDefinition', 'title', elem.titleElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('subtitle') then
    ComposeString(this, 'PlanDefinition', 'subtitle', elem.subtitleElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCodeableConcept(this, 'PlanDefinition', 'type', elem.type_Element, false, -1);{x.2f}
  ComposeEnum(this, 'PlanDefinition', 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(this, 'PlanDefinition', 'experimental', elem.experimentalElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and (elem.subject is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'PlanDefinition', 'subjectCodeableConcept', TFhirCodeableConcept(elem.subject), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.subject is TFhirReference) {2} then
    ComposeReference(this, 'PlanDefinition', 'subjectReference', TFhirReference(elem.subject), false,-1);{x.d8}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(this, 'PlanDefinition', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(this, 'PlanDefinition', 'publisher', elem.publisherElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(this, 'PlanDefinition', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeMarkdown(this, 'PlanDefinition', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(this, 'PlanDefinition', 'useContext', elem.useContextList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'PlanDefinition', 'jurisdiction', elem.jurisdictionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdown(this, 'PlanDefinition', 'purpose', elem.purposeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('usage') then
    ComposeString(this, 'PlanDefinition', 'usage', elem.usageElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdown(this, 'PlanDefinition', 'copyright', elem.copyrightElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('approvalDate') then
    ComposeDate(this, 'PlanDefinition', 'approvalDate', elem.approvalDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('lastReviewDate') then
    ComposeDate(this, 'PlanDefinition', 'lastReviewDate', elem.lastReviewDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('effectivePeriod') then
    ComposePeriod(this, 'PlanDefinition', 'effectivePeriod', elem.effectivePeriodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('topic') then
    for i := 0 to elem.topicList.Count - 1 do
      ComposeCodeableConcept(this, 'PlanDefinition', 'topic', elem.topicList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('author') then
    for i := 0 to elem.authorList.Count - 1 do
      ComposeContactDetail(this, 'PlanDefinition', 'author', elem.authorList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('editor') then
    for i := 0 to elem.editorList.Count - 1 do
      ComposeContactDetail(this, 'PlanDefinition', 'editor', elem.editorList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('reviewer') then
    for i := 0 to elem.reviewerList.Count - 1 do
      ComposeContactDetail(this, 'PlanDefinition', 'reviewer', elem.reviewerList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('endorser') then
    for i := 0 to elem.endorserList.Count - 1 do
      ComposeContactDetail(this, 'PlanDefinition', 'endorser', elem.endorserList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('relatedArtifact') then
    for i := 0 to elem.relatedArtifactList.Count - 1 do
      ComposeRelatedArtifact(this, 'PlanDefinition', 'relatedArtifact', elem.relatedArtifactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('library_') then
    for i := 0 to elem.library_List.Count - 1 do
      ComposeCanonical(this, 'PlanDefinition', 'library', elem.library_List[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('goal') then
    for i := 0 to elem.goalList.Count - 1 do
      ComposePlanDefinitionGoal(this, 'PlanDefinition', 'goal', elem.goalList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('action') then
    for i := 0 to elem.actionList.Count - 1 do
      ComposePlanDefinitionAction(this, 'PlanDefinition', 'action', elem.actionList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_PLANDEFINITION}
{$IFDEF FHIR_PRACTITIONER}
function TFHIRTurtleParser.ParsePractitionerQualification(obj : TTurtleComplex) : TFhirPractitionerQualification;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPractitionerQualification.create;
  try
    ParsePractitionerQualificationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePractitionerQualificationProperties(obj : TTurtleComplex; result : TFhirPractitionerQualification);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Practitioner.qualification.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Practitioner.qualification.code'));{q3b}
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Practitioner.qualification.period'));{q3b}
    result.issuer := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/Practitioner.qualification.issuer'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposePractitionerQualification(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPractitionerQualification; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PractitionerQualification'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Practitioner.qualification', 'identifier', elem.identifierList[i], false, i);{x.d3}
  ComposeCodeableConcept(this, 'Practitioner.qualification', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'Practitioner.qualification', 'period', elem.periodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(this, 'Practitioner.qualification', 'issuer', elem.issuerElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParsePractitioner(obj : TTurtleComplex) : TFhirPractitioner;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPractitioner.create;
  try
    ParsePractitionerProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePractitionerProperties(obj : TTurtleComplex; result : TFhirPractitioner);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Practitioner.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.activeElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Practitioner.active'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Practitioner.name') do
      result.nameList.Add(parseHumanName(item));
    for item in obj.complexes('http://hl7.org/fhir/Practitioner.telecom') do
      result.telecomList.Add(parseContactPoint(item));
    for item in obj.complexes('http://hl7.org/fhir/Practitioner.address') do
      result.addressList.Add(parseAddress(item));
    result.genderElement := ParseEnum(obj.complex('http://hl7.org/fhir/Practitioner.gender'), CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum);
    result.birthDateElement := ParseDate(obj.complex('http://hl7.org/fhir/Practitioner.birthDate'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Practitioner.photo') do
      result.photoList.Add(parseAttachment(item));
    for item in obj.complexes('http://hl7.org/fhir/Practitioner.qualification') do
      result.qualificationList.Add(parsePractitionerQualification(item));
    for item in obj.complexes('http://hl7.org/fhir/Practitioner.communication') do
      result.communicationList.Add(parseCodeableConcept(item));
end;

procedure TFHIRTurtleComposer.ComposePractitioner(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPractitioner; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Practitioner'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Practitioner', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('active') then
    ComposeBoolean(this, 'Practitioner', 'active', elem.activeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    for i := 0 to elem.nameList.Count - 1 do
      ComposeHumanName(this, 'Practitioner', 'name', elem.nameList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('telecom') then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(this, 'Practitioner', 'telecom', elem.telecomList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('address') then
    for i := 0 to elem.addressList.Count - 1 do
      ComposeAddress(this, 'Practitioner', 'address', elem.addressList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('gender') then
    ComposeEnum(this, 'Practitioner', 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('birthDate') then
    ComposeDate(this, 'Practitioner', 'birthDate', elem.birthDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('photo') then
    for i := 0 to elem.photoList.Count - 1 do
      ComposeAttachment(this, 'Practitioner', 'photo', elem.photoList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('qualification') then
    for i := 0 to elem.qualificationList.Count - 1 do
      ComposePractitionerQualification(this, 'Practitioner', 'qualification', elem.qualificationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('communication') then
    for i := 0 to elem.communicationList.Count - 1 do
      ComposeCodeableConcept(this, 'Practitioner', 'communication', elem.communicationList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_PRACTITIONER}
{$IFDEF FHIR_PRACTITIONERROLE}
function TFHIRTurtleParser.ParsePractitionerRoleAvailableTime(obj : TTurtleComplex) : TFhirPractitionerRoleAvailableTime;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPractitionerRoleAvailableTime.create;
  try
    ParsePractitionerRoleAvailableTimeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePractitionerRoleAvailableTimeProperties(obj : TTurtleComplex; result : TFhirPractitionerRoleAvailableTime);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/PractitionerRole.availableTime.daysOfWeek') do
      result.daysOfWeekList.Add(parseEnum(item, CODES_TFhirDaysOfWeekEnum, SYSTEMS_TFhirDaysOfWeekEnum));
    result.allDayElement := ParseBoolean(obj.complex('http://hl7.org/fhir/PractitionerRole.availableTime.allDay'));{q1}
    result.availableStartTimeElement := ParseTime(obj.complex('http://hl7.org/fhir/PractitionerRole.availableTime.availableStartTime'));{q1}
    result.availableEndTimeElement := ParseTime(obj.complex('http://hl7.org/fhir/PractitionerRole.availableTime.availableEndTime'));{q1}
end;

procedure TFHIRTurtleComposer.ComposePractitionerRoleAvailableTime(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPractitionerRoleAvailableTime; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PractitionerRoleAvailableTime'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.daysOfWeekList.Count - 1 do
      ComposeEnum(this, 'PractitionerRole.availableTime', 'daysOfWeek', elem.daysOfWeekList[i], CODES_TFhirDaysOfWeekEnum, SYSTEMS_TFhirDaysOfWeekEnum, false, i); {x.d1}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.daysOfWeekList.Count - 1 do
      ComposeEnum(this, 'PractitionerRole.availableTime', 'daysOfWeek', elem.daysOfWeekList[i], CODES_TFhirDaysOfWeekEnum, SYSTEMS_TFhirDaysOfWeekEnum, false, i);{x.d2}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'PractitionerRole.availableTime', 'allDay', elem.allDayElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeTime(this, 'PractitionerRole.availableTime', 'availableStartTime', elem.availableStartTimeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeTime(this, 'PractitionerRole.availableTime', 'availableEndTime', elem.availableEndTimeElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParsePractitionerRoleNotAvailable(obj : TTurtleComplex) : TFhirPractitionerRoleNotAvailable;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPractitionerRoleNotAvailable.create;
  try
    ParsePractitionerRoleNotAvailableProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePractitionerRoleNotAvailableProperties(obj : TTurtleComplex; result : TFhirPractitionerRoleNotAvailable);
begin
    ParseBackboneElementProperties(obj, result);
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/PractitionerRole.notAvailable.description'));{q1}
    result.during := ParsePeriod(obj.complex('http://hl7.org/fhir/PractitionerRole.notAvailable.during'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposePractitionerRoleNotAvailable(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPractitionerRoleNotAvailable; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PractitionerRoleNotAvailable'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeString(this, 'PractitionerRole.notAvailable', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'PractitionerRole.notAvailable', 'during', elem.duringElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParsePractitionerRole(obj : TTurtleComplex) : TFhirPractitionerRole;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirPractitionerRole.create;
  try
    ParsePractitionerRoleProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParsePractitionerRoleProperties(obj : TTurtleComplex; result : TFhirPractitionerRole);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/PractitionerRole.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.activeElement := ParseBoolean(obj.complex('http://hl7.org/fhir/PractitionerRole.active'));{q1}
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/PractitionerRole.period'));{q3b}
    result.practitioner := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/PractitionerRole.practitioner'));{q3b}
    result.organization := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/PractitionerRole.organization'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/PractitionerRole.code') do
      result.codeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/PractitionerRole.specialty') do
      result.specialtyList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/PractitionerRole.location') do
      result.locationList.Add(parseReference{TFhirLocation}(item));
    for item in obj.complexes('http://hl7.org/fhir/PractitionerRole.healthcareService') do
      result.healthcareServiceList.Add(parseReference{TFhirHealthcareService}(item));
    for item in obj.complexes('http://hl7.org/fhir/PractitionerRole.telecom') do
      result.telecomList.Add(parseContactPoint(item));
    for item in obj.complexes('http://hl7.org/fhir/PractitionerRole.availableTime') do
      result.availableTimeList.Add(parsePractitionerRoleAvailableTime(item));
    for item in obj.complexes('http://hl7.org/fhir/PractitionerRole.notAvailable') do
      result.notAvailableList.Add(parsePractitionerRoleNotAvailable(item));
    result.availabilityExceptionsElement := ParseString(obj.complex('http://hl7.org/fhir/PractitionerRole.availabilityExceptions'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/PractitionerRole.endpoint') do
      result.endpointList.Add(parseReference{TFhirEndpoint}(item));
end;

procedure TFHIRTurtleComposer.ComposePractitionerRole(parent :  TTurtleComplex; parentType, name : String; elem : TFhirPractitionerRole; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:PractitionerRole'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'PractitionerRole', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('active') then
    ComposeBoolean(this, 'PractitionerRole', 'active', elem.activeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('period') then
    ComposePeriod(this, 'PractitionerRole', 'period', elem.periodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('practitioner') then
    ComposeReference{TFhirPractitioner}(this, 'PractitionerRole', 'practitioner', elem.practitionerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('organization') then
    ComposeReference{TFhirOrganization}(this, 'PractitionerRole', 'organization', elem.organizationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') then
    for i := 0 to elem.codeList.Count - 1 do
      ComposeCodeableConcept(this, 'PractitionerRole', 'code', elem.codeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('specialty') then
    for i := 0 to elem.specialtyList.Count - 1 do
      ComposeCodeableConcept(this, 'PractitionerRole', 'specialty', elem.specialtyList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('location') then
    for i := 0 to elem.locationList.Count - 1 do
      ComposeReference{TFhirLocation}(this, 'PractitionerRole', 'location', elem.locationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('healthcareService') then
    for i := 0 to elem.healthcareServiceList.Count - 1 do
      ComposeReference{TFhirHealthcareService}(this, 'PractitionerRole', 'healthcareService', elem.healthcareServiceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('telecom') then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(this, 'PractitionerRole', 'telecom', elem.telecomList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('availableTime') then
    for i := 0 to elem.availableTimeList.Count - 1 do
      ComposePractitionerRoleAvailableTime(this, 'PractitionerRole', 'availableTime', elem.availableTimeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('notAvailable') then
    for i := 0 to elem.notAvailableList.Count - 1 do
      ComposePractitionerRoleNotAvailable(this, 'PractitionerRole', 'notAvailable', elem.notAvailableList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('availabilityExceptions') then
    ComposeString(this, 'PractitionerRole', 'availabilityExceptions', elem.availabilityExceptionsElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('endpoint') then
    for i := 0 to elem.endpointList.Count - 1 do
      ComposeReference{TFhirEndpoint}(this, 'PractitionerRole', 'endpoint', elem.endpointList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_PRACTITIONERROLE}
{$IFDEF FHIR_PROCEDURE}
function TFHIRTurtleParser.ParseProcedurePerformer(obj : TTurtleComplex) : TFhirProcedurePerformer;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirProcedurePerformer.create;
  try
    ParseProcedurePerformerProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseProcedurePerformerProperties(obj : TTurtleComplex; result : TFhirProcedurePerformer);
begin
    ParseBackboneElementProperties(obj, result);
    result.function_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Procedure.performer.function'));{q3b}
    result.actor := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/Procedure.performer.actor'));{q3b}
    result.onBehalfOf := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/Procedure.performer.onBehalfOf'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeProcedurePerformer(parent :  TTurtleComplex; parentType, name : String; elem : TFhirProcedurePerformer; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ProcedurePerformer'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Procedure.performer', 'function', elem.function_Element, false, -1);{x.2f}
  ComposeReference{TFhirPractitioner}(this, 'Procedure.performer', 'actor', elem.actorElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(this, 'Procedure.performer', 'onBehalfOf', elem.onBehalfOfElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseProcedureFocalDevice(obj : TTurtleComplex) : TFhirProcedureFocalDevice;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirProcedureFocalDevice.create;
  try
    ParseProcedureFocalDeviceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseProcedureFocalDeviceProperties(obj : TTurtleComplex; result : TFhirProcedureFocalDevice);
begin
    ParseBackboneElementProperties(obj, result);
    result.action := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Procedure.focalDevice.action'));{q3b}
    result.manipulated := ParseReference{TFhirDevice}(obj.complex('http://hl7.org/fhir/Procedure.focalDevice.manipulated'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeProcedureFocalDevice(parent :  TTurtleComplex; parentType, name : String; elem : TFhirProcedureFocalDevice; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ProcedureFocalDevice'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Procedure.focalDevice', 'action', elem.actionElement, false, -1);{x.2f}
  ComposeReference{TFhirDevice}(this, 'Procedure.focalDevice', 'manipulated', elem.manipulatedElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseProcedure(obj : TTurtleComplex) : TFhirProcedure;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirProcedure.create;
  try
    ParseProcedureProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseProcedureProperties(obj : TTurtleComplex; result : TFhirProcedure);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Procedure.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/Procedure.instantiatesCanonical') do
      result.instantiatesCanonicalList.Add(parseCanonical(item));
    for item in obj.complexes('http://hl7.org/fhir/Procedure.instantiatesUri') do
      result.instantiatesUriList.Add(parseUri(item));
    for item in obj.complexes('http://hl7.org/fhir/Procedure.basedOn') do
      result.basedOnList.Add(parseReference{TFhirCarePlan}(item));
    for item in obj.complexes('http://hl7.org/fhir/Procedure.partOf') do
      result.partOfList.Add(parseReference{TFhirProcedure}(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Procedure.status'), CODES_TFhirEventStatusEnum, SYSTEMS_TFhirEventStatusEnum);
    result.statusReason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Procedure.statusReason'));{q3b}
    result.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Procedure.category'));{q3b}
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Procedure.code'));{q3b}
    result.subject := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/Procedure.subject'));{q3b}
    result.encounter := ParseReference{TFhirEncounter}(obj.complex('http://hl7.org/fhir/Procedure.encounter'));{q3b}
    if obj.has('http://hl7.org/fhir/Procedure.performedPeriod', item) then
      result.performed := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/Procedure.performedAge', item) then
      result.performed := parseAge(item);
    if obj.has('http://hl7.org/fhir/Procedure.performedRange', item) then
      result.performed := parseRange(item);
    if obj.has('http://hl7.org/fhir/Procedure.performedDateTime', item) then
      result.performed := parseDateTime(item);
    if obj.has('http://hl7.org/fhir/Procedure.performedString', item) then
      result.performed := parseString(item);
    result.recorder := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/Procedure.recorder'));{q3b}
    result.asserter := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/Procedure.asserter'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Procedure.performer') do
      result.performerList.Add(parseProcedurePerformer(item));
    result.location := ParseReference{TFhirLocation}(obj.complex('http://hl7.org/fhir/Procedure.location'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Procedure.reasonCode') do
      result.reasonCodeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Procedure.reasonReference') do
      result.reasonReferenceList.Add(parseReference{TFhirCondition}(item));
    for item in obj.complexes('http://hl7.org/fhir/Procedure.bodySite') do
      result.bodySiteList.Add(parseCodeableConcept(item));
    result.outcome := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Procedure.outcome'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Procedure.report') do
      result.reportList.Add(parseReference{TFhirDiagnosticReport}(item));
    for item in obj.complexes('http://hl7.org/fhir/Procedure.complication') do
      result.complicationList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Procedure.complicationDetail') do
      result.complicationDetailList.Add(parseReference{TFhirCondition}(item));
    for item in obj.complexes('http://hl7.org/fhir/Procedure.followUp') do
      result.followUpList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Procedure.note') do
      result.noteList.Add(parseAnnotation(item));
    for item in obj.complexes('http://hl7.org/fhir/Procedure.focalDevice') do
      result.focalDeviceList.Add(parseProcedureFocalDevice(item));
    for item in obj.complexes('http://hl7.org/fhir/Procedure.usedReference') do
      result.usedReferenceList.Add(parseReference{TFhirDevice}(item));
    for item in obj.complexes('http://hl7.org/fhir/Procedure.usedCode') do
      result.usedCodeList.Add(parseCodeableConcept(item));
end;

procedure TFHIRTurtleComposer.ComposeProcedure(parent :  TTurtleComplex; parentType, name : String; elem : TFhirProcedure; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Procedure'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Procedure', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('instantiatesCanonical') then
    for i := 0 to elem.instantiatesCanonicalList.Count - 1 do
      ComposeCanonical(this, 'Procedure', 'instantiatesCanonical', elem.instantiatesCanonicalList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('instantiatesUri') then
    for i := 0 to elem.instantiatesUriList.Count - 1 do
      ComposeUri(this, 'Procedure', 'instantiatesUri', elem.instantiatesUriList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('basedOn') then
    for i := 0 to elem.basedOnList.Count - 1 do
      ComposeReference{TFhirCarePlan}(this, 'Procedure', 'basedOn', elem.basedOnList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('partOf') then
    for i := 0 to elem.partOfList.Count - 1 do
      ComposeReference{TFhirProcedure}(this, 'Procedure', 'partOf', elem.partOfList[i], false, i);{x.d3}
  ComposeEnum(this, 'Procedure', 'status', elem.StatusElement, CODES_TFhirEventStatusEnum, SYSTEMS_TFhirEventStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('statusReason') then
    ComposeCodeableConcept(this, 'Procedure', 'statusReason', elem.statusReasonElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    ComposeCodeableConcept(this, 'Procedure', 'category', elem.categoryElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') then
    ComposeCodeableConcept(this, 'Procedure', 'code', elem.codeElement, false, -1);{x.2f}
  ComposeReference{TFhirPatient}(this, 'Procedure', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(this, 'Procedure', 'encounter', elem.encounterElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.performed is TFhirPeriod) {6} then
    ComposePeriod(this, 'Procedure', 'performedPeriod', TFhirPeriod(elem.performed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.performed is TFhirAge) {6} then
    ComposeAge(this, 'Procedure', 'performedAge', TFhirAge(elem.performed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.performed is TFhirRange) {6} then
    ComposeRange(this, 'Procedure', 'performedRange', TFhirRange(elem.performed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.performed is TFhirDateTime) {6} then
    ComposeDateTime(this, 'Procedure', 'performedDateTime', TFhirDateTime(elem.performed), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.performed is TFhirString) {6} then
    ComposeString(this, 'Procedure', 'performedString', TFhirString(elem.performed), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('recorder') then
    ComposeReference{TFhirPatient}(this, 'Procedure', 'recorder', elem.recorderElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('asserter') then
    ComposeReference{TFhirPatient}(this, 'Procedure', 'asserter', elem.asserterElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('performer') then
    for i := 0 to elem.performerList.Count - 1 do
      ComposeProcedurePerformer(this, 'Procedure', 'performer', elem.performerList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('location') then
    ComposeReference{TFhirLocation}(this, 'Procedure', 'location', elem.locationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonCode') then
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'Procedure', 'reasonCode', elem.reasonCodeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonReference') then
    for i := 0 to elem.reasonReferenceList.Count - 1 do
      ComposeReference{TFhirCondition}(this, 'Procedure', 'reasonReference', elem.reasonReferenceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('bodySite') then
    for i := 0 to elem.bodySiteList.Count - 1 do
      ComposeCodeableConcept(this, 'Procedure', 'bodySite', elem.bodySiteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('outcome') then
    ComposeCodeableConcept(this, 'Procedure', 'outcome', elem.outcomeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('report') then
    for i := 0 to elem.reportList.Count - 1 do
      ComposeReference{TFhirDiagnosticReport}(this, 'Procedure', 'report', elem.reportList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('complication') then
    for i := 0 to elem.complicationList.Count - 1 do
      ComposeCodeableConcept(this, 'Procedure', 'complication', elem.complicationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('complicationDetail') then
    for i := 0 to elem.complicationDetailList.Count - 1 do
      ComposeReference{TFhirCondition}(this, 'Procedure', 'complicationDetail', elem.complicationDetailList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('followUp') then
    for i := 0 to elem.followUpList.Count - 1 do
      ComposeCodeableConcept(this, 'Procedure', 'followUp', elem.followUpList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'Procedure', 'note', elem.noteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('focalDevice') then
    for i := 0 to elem.focalDeviceList.Count - 1 do
      ComposeProcedureFocalDevice(this, 'Procedure', 'focalDevice', elem.focalDeviceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('usedReference') then
    for i := 0 to elem.usedReferenceList.Count - 1 do
      ComposeReference{TFhirDevice}(this, 'Procedure', 'usedReference', elem.usedReferenceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('usedCode') then
    for i := 0 to elem.usedCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'Procedure', 'usedCode', elem.usedCodeList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_PROCEDURE}
{$IFDEF FHIR_PROVENANCE}
function TFHIRTurtleParser.ParseProvenanceAgent(obj : TTurtleComplex) : TFhirProvenanceAgent;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirProvenanceAgent.create;
  try
    ParseProvenanceAgentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseProvenanceAgentProperties(obj : TTurtleComplex; result : TFhirProvenanceAgent);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Provenance.agent.type'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Provenance.agent.role') do
      result.roleList.Add(parseCodeableConcept(item));
    result.who := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/Provenance.agent.who'));{q3b}
    result.onBehalfOf := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/Provenance.agent.onBehalfOf'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeProvenanceAgent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirProvenanceAgent; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ProvenanceAgent'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'Provenance.agent', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.roleList.Count - 1 do
      ComposeCodeableConcept(this, 'Provenance.agent', 'role', elem.roleList[i], false, i);{x.d3}
  ComposeReference{TFhirPractitioner}(this, 'Provenance.agent', 'who', elem.whoElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirPractitioner}(this, 'Provenance.agent', 'onBehalfOf', elem.onBehalfOfElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseProvenanceEntity(obj : TTurtleComplex) : TFhirProvenanceEntity;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirProvenanceEntity.create;
  try
    ParseProvenanceEntityProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseProvenanceEntityProperties(obj : TTurtleComplex; result : TFhirProvenanceEntity);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.roleElement := ParseEnum(obj.complex('http://hl7.org/fhir/Provenance.entity.role'), CODES_TFhirProvenanceEntityRoleEnum, SYSTEMS_TFhirProvenanceEntityRoleEnum);
    result.what := ParseReference{TFhirReference}(obj.complex('http://hl7.org/fhir/Provenance.entity.what'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Provenance.entity.agent') do
      result.agentList.Add(parseProvenanceAgent(item));
end;

procedure TFHIRTurtleComposer.ComposeProvenanceEntity(parent :  TTurtleComplex; parentType, name : String; elem : TFhirProvenanceEntity; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ProvenanceEntity'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'Provenance.entity', 'role', elem.RoleElement, CODES_TFhirProvenanceEntityRoleEnum, SYSTEMS_TFhirProvenanceEntityRoleEnum, false, -1);{x.d4}
  ComposeReference{TFhirReference}(this, 'Provenance.entity', 'what', elem.whatElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.agentList.Count - 1 do
      ComposeProvenanceAgent(this, 'Provenance.entity', 'agent', elem.agentList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseProvenance(obj : TTurtleComplex) : TFhirProvenance;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirProvenance.create;
  try
    ParseProvenanceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseProvenanceProperties(obj : TTurtleComplex; result : TFhirProvenance);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Provenance.target') do
      result.targetList.Add(parseReference{TFhirReference}(item));
    if obj.has('http://hl7.org/fhir/Provenance.occurredPeriod', item) then
      result.occurred := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/Provenance.occurredDateTime', item) then
      result.occurred := parseDateTime(item);
    result.recordedElement := ParseInstant(obj.complex('http://hl7.org/fhir/Provenance.recorded'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Provenance.policy') do
      result.policyList.Add(parseUri(item));
    result.location := ParseReference{TFhirLocation}(obj.complex('http://hl7.org/fhir/Provenance.location'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Provenance.reason') do
      result.reasonList.Add(parseCodeableConcept(item));
    result.activity := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Provenance.activity'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Provenance.agent') do
      result.agentList.Add(parseProvenanceAgent(item));
    for item in obj.complexes('http://hl7.org/fhir/Provenance.entity') do
      result.entityList.Add(parseProvenanceEntity(item));
    for item in obj.complexes('http://hl7.org/fhir/Provenance.signature') do
      result.signatureList.Add(parseSignature(item));
end;

procedure TFHIRTurtleComposer.ComposeProvenance(parent :  TTurtleComplex; parentType, name : String; elem : TFhirProvenance; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Provenance'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  for i := 0 to elem.targetList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'Provenance', 'target', elem.targetList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and (elem.occurred is TFhirPeriod) {6} then
    ComposePeriod(this, 'Provenance', 'occurredPeriod', TFhirPeriod(elem.occurred), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.occurred is TFhirDateTime) {6} then
    ComposeDateTime(this, 'Provenance', 'occurredDateTime', TFhirDateTime(elem.occurred), false, -1);{x.d9}
  ComposeInstant(this, 'Provenance', 'recorded', elem.recordedElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('policy') then
    for i := 0 to elem.policyList.Count - 1 do
      ComposeUri(this, 'Provenance', 'policy', elem.policyList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('location') then
    ComposeReference{TFhirLocation}(this, 'Provenance', 'location', elem.locationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('reason') then
    for i := 0 to elem.reasonList.Count - 1 do
      ComposeCodeableConcept(this, 'Provenance', 'reason', elem.reasonList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('activity') then
    ComposeCodeableConcept(this, 'Provenance', 'activity', elem.activityElement, false, -1);{x.2f}
  for i := 0 to elem.agentList.Count - 1 do
      ComposeProvenanceAgent(this, 'Provenance', 'agent', elem.agentList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('entity') then
    for i := 0 to elem.entityList.Count - 1 do
      ComposeProvenanceEntity(this, 'Provenance', 'entity', elem.entityList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('signature') then
    for i := 0 to elem.signatureList.Count - 1 do
      ComposeSignature(this, 'Provenance', 'signature', elem.signatureList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_PROVENANCE}
{$IFDEF FHIR_QUESTIONNAIRE}
function TFHIRTurtleParser.ParseQuestionnaireItem(obj : TTurtleComplex) : TFhirQuestionnaireItem;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirQuestionnaireItem.create;
  try
    ParseQuestionnaireItemProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseQuestionnaireItemProperties(obj : TTurtleComplex; result : TFhirQuestionnaireItem);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.linkIdElement := ParseString(obj.complex('http://hl7.org/fhir/Questionnaire.item.linkId'));{q1}
    result.definitionElement := ParseUri(obj.complex('http://hl7.org/fhir/Questionnaire.item.definition'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Questionnaire.item.code') do
      result.codeList.Add(parseCoding(item));
    result.prefixElement := ParseString(obj.complex('http://hl7.org/fhir/Questionnaire.item.prefix'));{q1}
    result.textElement := ParseString(obj.complex('http://hl7.org/fhir/Questionnaire.item.text'));{q1}
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/Questionnaire.item.type'), CODES_TFhirItemTypeEnum, SYSTEMS_TFhirItemTypeEnum);
    for item in obj.complexes('http://hl7.org/fhir/Questionnaire.item.enableWhen') do
      result.enableWhenList.Add(parseQuestionnaireItemEnableWhen(item));
    result.enableBehaviorElement := ParseEnum(obj.complex('http://hl7.org/fhir/Questionnaire.item.enableBehavior'), CODES_TFhirQuestionnaireEnableBehaviorEnum, SYSTEMS_TFhirQuestionnaireEnableBehaviorEnum);
    result.requiredElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Questionnaire.item.required'));{q1}
    result.repeatsElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Questionnaire.item.repeats'));{q1}
    result.readOnlyElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Questionnaire.item.readOnly'));{q1}
    result.maxLengthElement := ParseInteger(obj.complex('http://hl7.org/fhir/Questionnaire.item.maxLength'));{q1}
    result.answerValueSetElement := ParseCanonical(obj.complex('http://hl7.org/fhir/Questionnaire.item.answerValueSet'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Questionnaire.item.answerOption') do
      result.answerOptionList.Add(parseQuestionnaireItemAnswerOption(item));
    for item in obj.complexes('http://hl7.org/fhir/Questionnaire.item.initial') do
      result.initialList.Add(parseQuestionnaireItemInitial(item));
    for item in obj.complexes('http://hl7.org/fhir/Questionnaire.item.item') do
      result.itemList.Add(parseQuestionnaireItem(item));
end;

procedure TFHIRTurtleComposer.ComposeQuestionnaireItem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirQuestionnaireItem; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:QuestionnaireItem'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeString(this, 'Questionnaire.item', 'linkId', elem.linkIdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'Questionnaire.item', 'definition', elem.definitionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.codeList.Count - 1 do
      ComposeCoding(this, 'Questionnaire.item', 'code', elem.codeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Questionnaire.item', 'prefix', elem.prefixElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Questionnaire.item', 'text', elem.textElement, false, -1);{x.2ea}
  ComposeEnum(this, 'Questionnaire.item', 'type', elem.Type_Element, CODES_TFhirItemTypeEnum, SYSTEMS_TFhirItemTypeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.enableWhenList.Count - 1 do
      ComposeQuestionnaireItemEnableWhen(this, 'Questionnaire.item', 'enableWhen', elem.enableWhenList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'Questionnaire.item', 'enableBehavior', elem.EnableBehaviorElement, CODES_TFhirQuestionnaireEnableBehaviorEnum, SYSTEMS_TFhirQuestionnaireEnableBehaviorEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'Questionnaire.item', 'required', elem.requiredElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'Questionnaire.item', 'repeats', elem.repeatsElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'Questionnaire.item', 'readOnly', elem.readOnlyElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(this, 'Questionnaire.item', 'maxLength', elem.maxLengthElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(this, 'Questionnaire.item', 'answerValueSet', elem.answerValueSetElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.answerOptionList.Count - 1 do
      ComposeQuestionnaireItemAnswerOption(this, 'Questionnaire.item', 'answerOption', elem.answerOptionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.initialList.Count - 1 do
      ComposeQuestionnaireItemInitial(this, 'Questionnaire.item', 'initial', elem.initialList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.itemList.Count - 1 do
      ComposeQuestionnaireItem(this, 'Questionnaire.item', 'item', elem.itemList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseQuestionnaireItemEnableWhen(obj : TTurtleComplex) : TFhirQuestionnaireItemEnableWhen;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirQuestionnaireItemEnableWhen.create;
  try
    ParseQuestionnaireItemEnableWhenProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseQuestionnaireItemEnableWhenProperties(obj : TTurtleComplex; result : TFhirQuestionnaireItemEnableWhen);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.questionElement := ParseString(obj.complex('http://hl7.org/fhir/Questionnaire.item.enableWhen.question'));{q1}
    result.operatorElement := ParseEnum(obj.complex('http://hl7.org/fhir/Questionnaire.item.enableWhen.operator'), CODES_TFhirQuestionnaireEnableOperatorEnum, SYSTEMS_TFhirQuestionnaireEnableOperatorEnum);
    if obj.has('http://hl7.org/fhir/Questionnaire.item.enableWhen.answerCoding', item) then
      result.answer := parseCoding(item);
    if obj.has('http://hl7.org/fhir/Questionnaire.item.enableWhen.answerQuantity', item) then
      result.answer := parseQuantity(item);
    if obj.has('http://hl7.org/fhir/Questionnaire.item.enableWhen.answerReference', item) {a3} then
      result.answer := ParseReference(item);
    if obj.has('http://hl7.org/fhir/Questionnaire.item.enableWhen.answerBoolean', item) then
      result.answer := parseBoolean(item);
    if obj.has('http://hl7.org/fhir/Questionnaire.item.enableWhen.answerDecimal', item) then
      result.answer := parseDecimal(item);
    if obj.has('http://hl7.org/fhir/Questionnaire.item.enableWhen.answerInteger', item) then
      result.answer := parseInteger(item);
    if obj.has('http://hl7.org/fhir/Questionnaire.item.enableWhen.answerDate', item) then
      result.answer := parseDate(item);
    if obj.has('http://hl7.org/fhir/Questionnaire.item.enableWhen.answerDateTime', item) then
      result.answer := parseDateTime(item);
    if obj.has('http://hl7.org/fhir/Questionnaire.item.enableWhen.answerTime', item) then
      result.answer := parseTime(item);
    if obj.has('http://hl7.org/fhir/Questionnaire.item.enableWhen.answerString', item) then
      result.answer := parseString(item);
end;

procedure TFHIRTurtleComposer.ComposeQuestionnaireItemEnableWhen(parent :  TTurtleComplex; parentType, name : String; elem : TFhirQuestionnaireItemEnableWhen; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:QuestionnaireItemEnableWhen'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeString(this, 'Questionnaire.item.enableWhen', 'question', elem.questionElement, false, -1);{x.2ea}
  ComposeEnum(this, 'Questionnaire.item.enableWhen', 'operator', elem.OperatorElement, CODES_TFhirQuestionnaireEnableOperatorEnum, SYSTEMS_TFhirQuestionnaireEnableOperatorEnum, false, -1);{x.d4}
  if (elem.answer is TFhirCoding) {6} then
    ComposeCoding(this, 'Questionnaire.item.enableWhen', 'answerCoding', TFhirCoding(elem.answer), false, -1){x.d9}
  else if (elem.answer is TFhirQuantity) {6} then
    ComposeQuantity(this, 'Questionnaire.item.enableWhen', 'answerQuantity', TFhirQuantity(elem.answer), false, -1){x.d9}
  else if (elem.answer is TFhirReference) {2} then
    ComposeReference(this, 'Questionnaire.item.enableWhen', 'answerReference', TFhirReference(elem.answer), false,-1){x.d8}
  else if (elem.answer is TFhirBoolean) {6} then
    ComposeBoolean(this, 'Questionnaire.item.enableWhen', 'answerBoolean', TFhirBoolean(elem.answer), false, -1){x.d9}
  else if (elem.answer is TFhirDecimal) {6} then
    ComposeDecimal(this, 'Questionnaire.item.enableWhen', 'answerDecimal', TFhirDecimal(elem.answer), false, -1){x.d9}
  else if (elem.answer is TFhirInteger) {6} then
    ComposeInteger(this, 'Questionnaire.item.enableWhen', 'answerInteger', TFhirInteger(elem.answer), false, -1){x.d9}
  else if (elem.answer is TFhirDate) {6} then
    ComposeDate(this, 'Questionnaire.item.enableWhen', 'answerDate', TFhirDate(elem.answer), false, -1){x.d9}
  else if (elem.answer is TFhirDateTime) {6} then
    ComposeDateTime(this, 'Questionnaire.item.enableWhen', 'answerDateTime', TFhirDateTime(elem.answer), false, -1){x.d9}
  else if (elem.answer is TFhirTime) {6} then
    ComposeTime(this, 'Questionnaire.item.enableWhen', 'answerTime', TFhirTime(elem.answer), false, -1){x.d9}
  else if (elem.answer is TFhirString) {6} then
    ComposeString(this, 'Questionnaire.item.enableWhen', 'answerString', TFhirString(elem.answer), false, -1);{x.d9}
end;

function TFHIRTurtleParser.ParseQuestionnaireItemAnswerOption(obj : TTurtleComplex) : TFhirQuestionnaireItemAnswerOption;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirQuestionnaireItemAnswerOption.create;
  try
    ParseQuestionnaireItemAnswerOptionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseQuestionnaireItemAnswerOptionProperties(obj : TTurtleComplex; result : TFhirQuestionnaireItemAnswerOption);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    if obj.has('http://hl7.org/fhir/Questionnaire.item.answerOption.valueCoding', item) then
      result.value := parseCoding(item);
    if obj.has('http://hl7.org/fhir/Questionnaire.item.answerOption.valueReference', item) {a3} then
      result.value := ParseReference(item);
    if obj.has('http://hl7.org/fhir/Questionnaire.item.answerOption.valueInteger', item) then
      result.value := parseInteger(item);
    if obj.has('http://hl7.org/fhir/Questionnaire.item.answerOption.valueDate', item) then
      result.value := parseDate(item);
    if obj.has('http://hl7.org/fhir/Questionnaire.item.answerOption.valueTime', item) then
      result.value := parseTime(item);
    if obj.has('http://hl7.org/fhir/Questionnaire.item.answerOption.valueString', item) then
      result.value := parseString(item);
    result.initialSelectedElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Questionnaire.item.answerOption.initialSelected'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeQuestionnaireItemAnswerOption(parent :  TTurtleComplex; parentType, name : String; elem : TFhirQuestionnaireItemAnswerOption; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:QuestionnaireItemAnswerOption'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (elem.value is TFhirCoding) {6} then
    ComposeCoding(this, 'Questionnaire.item.answerOption', 'valueCoding', TFhirCoding(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirReference) {2} then
    ComposeReference(this, 'Questionnaire.item.answerOption', 'valueReference', TFhirReference(elem.value), false,-1){x.d8}
  else if (elem.value is TFhirInteger) {6} then
    ComposeInteger(this, 'Questionnaire.item.answerOption', 'valueInteger', TFhirInteger(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirDate) {6} then
    ComposeDate(this, 'Questionnaire.item.answerOption', 'valueDate', TFhirDate(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirTime) {6} then
    ComposeTime(this, 'Questionnaire.item.answerOption', 'valueTime', TFhirTime(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirString) {6} then
    ComposeString(this, 'Questionnaire.item.answerOption', 'valueString', TFhirString(elem.value), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'Questionnaire.item.answerOption', 'initialSelected', elem.initialSelectedElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseQuestionnaireItemInitial(obj : TTurtleComplex) : TFhirQuestionnaireItemInitial;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirQuestionnaireItemInitial.create;
  try
    ParseQuestionnaireItemInitialProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseQuestionnaireItemInitialProperties(obj : TTurtleComplex; result : TFhirQuestionnaireItemInitial);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    if obj.has('http://hl7.org/fhir/Questionnaire.item.initial.valueAttachment', item) then
      result.value := parseAttachment(item);
    if obj.has('http://hl7.org/fhir/Questionnaire.item.initial.valueCoding', item) then
      result.value := parseCoding(item);
    if obj.has('http://hl7.org/fhir/Questionnaire.item.initial.valueQuantity', item) then
      result.value := parseQuantity(item);
    if obj.has('http://hl7.org/fhir/Questionnaire.item.initial.valueReference', item) {a3} then
      result.value := ParseReference(item);
    if obj.has('http://hl7.org/fhir/Questionnaire.item.initial.valueBoolean', item) then
      result.value := parseBoolean(item);
    if obj.has('http://hl7.org/fhir/Questionnaire.item.initial.valueDecimal', item) then
      result.value := parseDecimal(item);
    if obj.has('http://hl7.org/fhir/Questionnaire.item.initial.valueInteger', item) then
      result.value := parseInteger(item);
    if obj.has('http://hl7.org/fhir/Questionnaire.item.initial.valueDate', item) then
      result.value := parseDate(item);
    if obj.has('http://hl7.org/fhir/Questionnaire.item.initial.valueDateTime', item) then
      result.value := parseDateTime(item);
    if obj.has('http://hl7.org/fhir/Questionnaire.item.initial.valueTime', item) then
      result.value := parseTime(item);
    if obj.has('http://hl7.org/fhir/Questionnaire.item.initial.valueString', item) then
      result.value := parseString(item);
    if obj.has('http://hl7.org/fhir/Questionnaire.item.initial.valueUri', item) then
      result.value := parseUri(item);
end;

procedure TFHIRTurtleComposer.ComposeQuestionnaireItemInitial(parent :  TTurtleComplex; parentType, name : String; elem : TFhirQuestionnaireItemInitial; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:QuestionnaireItemInitial'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (elem.value is TFhirAttachment) {6} then
    ComposeAttachment(this, 'Questionnaire.item.initial', 'valueAttachment', TFhirAttachment(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirCoding) {6} then
    ComposeCoding(this, 'Questionnaire.item.initial', 'valueCoding', TFhirCoding(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'Questionnaire.item.initial', 'valueQuantity', TFhirQuantity(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirReference) {2} then
    ComposeReference(this, 'Questionnaire.item.initial', 'valueReference', TFhirReference(elem.value), false,-1){x.d8}
  else if (elem.value is TFhirBoolean) {6} then
    ComposeBoolean(this, 'Questionnaire.item.initial', 'valueBoolean', TFhirBoolean(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirDecimal) {6} then
    ComposeDecimal(this, 'Questionnaire.item.initial', 'valueDecimal', TFhirDecimal(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirInteger) {6} then
    ComposeInteger(this, 'Questionnaire.item.initial', 'valueInteger', TFhirInteger(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirDate) {6} then
    ComposeDate(this, 'Questionnaire.item.initial', 'valueDate', TFhirDate(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirDateTime) {6} then
    ComposeDateTime(this, 'Questionnaire.item.initial', 'valueDateTime', TFhirDateTime(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirTime) {6} then
    ComposeTime(this, 'Questionnaire.item.initial', 'valueTime', TFhirTime(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirString) {6} then
    ComposeString(this, 'Questionnaire.item.initial', 'valueString', TFhirString(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirUri) {6} then
    ComposeUri(this, 'Questionnaire.item.initial', 'valueUri', TFhirUri(elem.value), false, -1);{x.d9}
end;

function TFHIRTurtleParser.ParseQuestionnaire(obj : TTurtleComplex) : TFhirQuestionnaire;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirQuestionnaire.create;
  try
    ParseQuestionnaireProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseQuestionnaireProperties(obj : TTurtleComplex; result : TFhirQuestionnaire);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/Questionnaire.url'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Questionnaire.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/Questionnaire.version'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/Questionnaire.name'));{q1}
    result.titleElement := ParseString(obj.complex('http://hl7.org/fhir/Questionnaire.title'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Questionnaire.derivedFrom') do
      result.derivedFromList.Add(parseCanonical(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Questionnaire.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    result.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Questionnaire.experimental'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Questionnaire.subjectType') do
      result.subjectType.Add(parseEnum(item, CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum));
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Questionnaire.date'));{q1}
    result.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/Questionnaire.publisher'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Questionnaire.contact') do
      result.contactList.Add(parseContactDetail(item));
    result.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/Questionnaire.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Questionnaire.useContext') do
      result.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/Questionnaire.jurisdiction') do
      result.jurisdictionList.Add(parseCodeableConcept(item));
    result.purposeElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/Questionnaire.purpose'));{q1}
    result.copyrightElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/Questionnaire.copyright'));{q1}
    result.approvalDateElement := ParseDate(obj.complex('http://hl7.org/fhir/Questionnaire.approvalDate'));{q1}
    result.lastReviewDateElement := ParseDate(obj.complex('http://hl7.org/fhir/Questionnaire.lastReviewDate'));{q1}
    result.effectivePeriod := ParsePeriod(obj.complex('http://hl7.org/fhir/Questionnaire.effectivePeriod'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Questionnaire.code') do
      result.codeList.Add(parseCoding(item));
    for item in obj.complexes('http://hl7.org/fhir/Questionnaire.item') do
      result.itemList.Add(parseQuestionnaireItem(item));
end;

procedure TFHIRTurtleComposer.ComposeQuestionnaire(parent :  TTurtleComplex; parentType, name : String; elem : TFhirQuestionnaire; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Questionnaire'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUri(this, 'Questionnaire', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Questionnaire', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(this, 'Questionnaire', 'version', elem.versionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(this, 'Questionnaire', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeString(this, 'Questionnaire', 'title', elem.titleElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('derivedFrom') then
    for i := 0 to elem.derivedFromList.Count - 1 do
      ComposeCanonical(this, 'Questionnaire', 'derivedFrom', elem.derivedFromList[i], false, i);{x.d3}
  ComposeEnum(this, 'Questionnaire', 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(this, 'Questionnaire', 'experimental', elem.experimentalElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subjectType') then
    for i := 0 to elem.subjectType.Count - 1 do
      ComposeEnum(this, 'Questionnaire', 'subjectType', elem.subjectType[i], CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, false, i); {x.d1}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subjectType') then
    for i := 0 to elem.subjectType.Count - 1 do
      ComposeEnum(this, 'Questionnaire', 'subjectType', elem.subjectType[i], CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, false, i);{x.d2}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(this, 'Questionnaire', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(this, 'Questionnaire', 'publisher', elem.publisherElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(this, 'Questionnaire', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdown(this, 'Questionnaire', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(this, 'Questionnaire', 'useContext', elem.useContextList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'Questionnaire', 'jurisdiction', elem.jurisdictionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdown(this, 'Questionnaire', 'purpose', elem.purposeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdown(this, 'Questionnaire', 'copyright', elem.copyrightElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('approvalDate') then
    ComposeDate(this, 'Questionnaire', 'approvalDate', elem.approvalDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('lastReviewDate') then
    ComposeDate(this, 'Questionnaire', 'lastReviewDate', elem.lastReviewDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('effectivePeriod') then
    ComposePeriod(this, 'Questionnaire', 'effectivePeriod', elem.effectivePeriodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') then
    for i := 0 to elem.codeList.Count - 1 do
      ComposeCoding(this, 'Questionnaire', 'code', elem.codeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('item') then
    for i := 0 to elem.itemList.Count - 1 do
      ComposeQuestionnaireItem(this, 'Questionnaire', 'item', elem.itemList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_QUESTIONNAIRE}
{$IFDEF FHIR_QUESTIONNAIRERESPONSE}
function TFHIRTurtleParser.ParseQuestionnaireResponseItem(obj : TTurtleComplex) : TFhirQuestionnaireResponseItem;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirQuestionnaireResponseItem.create;
  try
    ParseQuestionnaireResponseItemProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseQuestionnaireResponseItemProperties(obj : TTurtleComplex; result : TFhirQuestionnaireResponseItem);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.linkIdElement := ParseString(obj.complex('http://hl7.org/fhir/QuestionnaireResponse.item.linkId'));{q1}
    result.definitionElement := ParseUri(obj.complex('http://hl7.org/fhir/QuestionnaireResponse.item.definition'));{q1}
    result.textElement := ParseString(obj.complex('http://hl7.org/fhir/QuestionnaireResponse.item.text'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/QuestionnaireResponse.item.answer') do
      result.answerList.Add(parseQuestionnaireResponseItemAnswer(item));
    for item in obj.complexes('http://hl7.org/fhir/QuestionnaireResponse.item.item') do
      result.itemList.Add(parseQuestionnaireResponseItem(item));
end;

procedure TFHIRTurtleComposer.ComposeQuestionnaireResponseItem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirQuestionnaireResponseItem; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:QuestionnaireResponseItem'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeString(this, 'QuestionnaireResponse.item', 'linkId', elem.linkIdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'QuestionnaireResponse.item', 'definition', elem.definitionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'QuestionnaireResponse.item', 'text', elem.textElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.answerList.Count - 1 do
      ComposeQuestionnaireResponseItemAnswer(this, 'QuestionnaireResponse.item', 'answer', elem.answerList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.itemList.Count - 1 do
      ComposeQuestionnaireResponseItem(this, 'QuestionnaireResponse.item', 'item', elem.itemList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseQuestionnaireResponseItemAnswer(obj : TTurtleComplex) : TFhirQuestionnaireResponseItemAnswer;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirQuestionnaireResponseItemAnswer.create;
  try
    ParseQuestionnaireResponseItemAnswerProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseQuestionnaireResponseItemAnswerProperties(obj : TTurtleComplex; result : TFhirQuestionnaireResponseItemAnswer);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    if obj.has('http://hl7.org/fhir/QuestionnaireResponse.item.answer.valueAttachment', item) then
      result.value := parseAttachment(item);
    if obj.has('http://hl7.org/fhir/QuestionnaireResponse.item.answer.valueCoding', item) then
      result.value := parseCoding(item);
    if obj.has('http://hl7.org/fhir/QuestionnaireResponse.item.answer.valueQuantity', item) then
      result.value := parseQuantity(item);
    if obj.has('http://hl7.org/fhir/QuestionnaireResponse.item.answer.valueReference', item) {a3} then
      result.value := ParseReference(item);
    if obj.has('http://hl7.org/fhir/QuestionnaireResponse.item.answer.valueBoolean', item) then
      result.value := parseBoolean(item);
    if obj.has('http://hl7.org/fhir/QuestionnaireResponse.item.answer.valueDecimal', item) then
      result.value := parseDecimal(item);
    if obj.has('http://hl7.org/fhir/QuestionnaireResponse.item.answer.valueInteger', item) then
      result.value := parseInteger(item);
    if obj.has('http://hl7.org/fhir/QuestionnaireResponse.item.answer.valueDate', item) then
      result.value := parseDate(item);
    if obj.has('http://hl7.org/fhir/QuestionnaireResponse.item.answer.valueDateTime', item) then
      result.value := parseDateTime(item);
    if obj.has('http://hl7.org/fhir/QuestionnaireResponse.item.answer.valueTime', item) then
      result.value := parseTime(item);
    if obj.has('http://hl7.org/fhir/QuestionnaireResponse.item.answer.valueString', item) then
      result.value := parseString(item);
    if obj.has('http://hl7.org/fhir/QuestionnaireResponse.item.answer.valueUri', item) then
      result.value := parseUri(item);
    for item in obj.complexes('http://hl7.org/fhir/QuestionnaireResponse.item.answer.item') do
      result.itemList.Add(parseQuestionnaireResponseItem(item));
end;

procedure TFHIRTurtleComposer.ComposeQuestionnaireResponseItemAnswer(parent :  TTurtleComplex; parentType, name : String; elem : TFhirQuestionnaireResponseItemAnswer; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:QuestionnaireResponseItemAnswer'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) and (elem.value is TFhirAttachment) {6} then
    ComposeAttachment(this, 'QuestionnaireResponse.item.answer', 'valueAttachment', TFhirAttachment(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirCoding) {6} then
    ComposeCoding(this, 'QuestionnaireResponse.item.answer', 'valueCoding', TFhirCoding(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'QuestionnaireResponse.item.answer', 'valueQuantity', TFhirQuantity(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirReference) {2} then
    ComposeReference(this, 'QuestionnaireResponse.item.answer', 'valueReference', TFhirReference(elem.value), false,-1){x.d8}
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirBoolean) {6} then
    ComposeBoolean(this, 'QuestionnaireResponse.item.answer', 'valueBoolean', TFhirBoolean(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirDecimal) {6} then
    ComposeDecimal(this, 'QuestionnaireResponse.item.answer', 'valueDecimal', TFhirDecimal(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirInteger) {6} then
    ComposeInteger(this, 'QuestionnaireResponse.item.answer', 'valueInteger', TFhirInteger(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirDate) {6} then
    ComposeDate(this, 'QuestionnaireResponse.item.answer', 'valueDate', TFhirDate(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirDateTime) {6} then
    ComposeDateTime(this, 'QuestionnaireResponse.item.answer', 'valueDateTime', TFhirDateTime(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirTime) {6} then
    ComposeTime(this, 'QuestionnaireResponse.item.answer', 'valueTime', TFhirTime(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirString) {6} then
    ComposeString(this, 'QuestionnaireResponse.item.answer', 'valueString', TFhirString(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirUri) {6} then
    ComposeUri(this, 'QuestionnaireResponse.item.answer', 'valueUri', TFhirUri(elem.value), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.itemList.Count - 1 do
      ComposeQuestionnaireResponseItem(this, 'QuestionnaireResponse.item.answer', 'item', elem.itemList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseQuestionnaireResponse(obj : TTurtleComplex) : TFhirQuestionnaireResponse;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirQuestionnaireResponse.create;
  try
    ParseQuestionnaireResponseProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseQuestionnaireResponseProperties(obj : TTurtleComplex; result : TFhirQuestionnaireResponse);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/QuestionnaireResponse.identifier'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/QuestionnaireResponse.basedOn') do
      result.basedOnList.Add(parseReference{TFhirCarePlan}(item));
    for item in obj.complexes('http://hl7.org/fhir/QuestionnaireResponse.partOf') do
      result.partOfList.Add(parseReference{TFhirObservation}(item));
    result.questionnaireElement := ParseCanonical(obj.complex('http://hl7.org/fhir/QuestionnaireResponse.questionnaire'));{q1}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/QuestionnaireResponse.status'), CODES_TFhirQuestionnaireAnswersStatusEnum, SYSTEMS_TFhirQuestionnaireAnswersStatusEnum);
    result.subject := ParseReference{TFhirReference}(obj.complex('http://hl7.org/fhir/QuestionnaireResponse.subject'));{q3b}
    result.encounter := ParseReference{TFhirEncounter}(obj.complex('http://hl7.org/fhir/QuestionnaireResponse.encounter'));{q3b}
    result.authoredElement := ParseDateTime(obj.complex('http://hl7.org/fhir/QuestionnaireResponse.authored'));{q1}
    result.author := ParseReference{TFhirDevice}(obj.complex('http://hl7.org/fhir/QuestionnaireResponse.author'));{q3b}
    result.source := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/QuestionnaireResponse.source'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/QuestionnaireResponse.item') do
      result.itemList.Add(parseQuestionnaireResponseItem(item));
end;

procedure TFHIRTurtleComposer.ComposeQuestionnaireResponse(parent :  TTurtleComplex; parentType, name : String; elem : TFhirQuestionnaireResponse; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:QuestionnaireResponse'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(this, 'QuestionnaireResponse', 'identifier', elem.identifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('basedOn') then
    for i := 0 to elem.basedOnList.Count - 1 do
      ComposeReference{TFhirCarePlan}(this, 'QuestionnaireResponse', 'basedOn', elem.basedOnList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('partOf') then
    for i := 0 to elem.partOfList.Count - 1 do
      ComposeReference{TFhirObservation}(this, 'QuestionnaireResponse', 'partOf', elem.partOfList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('questionnaire') then
    ComposeCanonical(this, 'QuestionnaireResponse', 'questionnaire', elem.questionnaireElement, false, -1);{x.2ea}
  ComposeEnum(this, 'QuestionnaireResponse', 'status', elem.StatusElement, CODES_TFhirQuestionnaireAnswersStatusEnum, SYSTEMS_TFhirQuestionnaireAnswersStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{TFhirReference}(this, 'QuestionnaireResponse', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(this, 'QuestionnaireResponse', 'encounter', elem.encounterElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('authored') then
    ComposeDateTime(this, 'QuestionnaireResponse', 'authored', elem.authoredElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('author') then
    ComposeReference{TFhirDevice}(this, 'QuestionnaireResponse', 'author', elem.authorElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('source') then
    ComposeReference{TFhirPatient}(this, 'QuestionnaireResponse', 'source', elem.sourceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('item') then
    for i := 0 to elem.itemList.Count - 1 do
      ComposeQuestionnaireResponseItem(this, 'QuestionnaireResponse', 'item', elem.itemList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_QUESTIONNAIRERESPONSE}
{$IFDEF FHIR_RELATEDPERSON}
function TFHIRTurtleParser.ParseRelatedPersonCommunication(obj : TTurtleComplex) : TFhirRelatedPersonCommunication;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirRelatedPersonCommunication.create;
  try
    ParseRelatedPersonCommunicationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseRelatedPersonCommunicationProperties(obj : TTurtleComplex; result : TFhirRelatedPersonCommunication);
begin
    ParseBackboneElementProperties(obj, result);
    result.language := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/RelatedPerson.communication.language'));{q3b}
    result.preferredElement := ParseBoolean(obj.complex('http://hl7.org/fhir/RelatedPerson.communication.preferred'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeRelatedPersonCommunication(parent :  TTurtleComplex; parentType, name : String; elem : TFhirRelatedPersonCommunication; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:RelatedPersonCommunication'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'RelatedPerson.communication', 'language', elem.languageElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'RelatedPerson.communication', 'preferred', elem.preferredElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseRelatedPerson(obj : TTurtleComplex) : TFhirRelatedPerson;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirRelatedPerson.create;
  try
    ParseRelatedPersonProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseRelatedPersonProperties(obj : TTurtleComplex; result : TFhirRelatedPerson);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/RelatedPerson.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.activeElement := ParseBoolean(obj.complex('http://hl7.org/fhir/RelatedPerson.active'));{q1}
    result.patient := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/RelatedPerson.patient'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/RelatedPerson.relationship') do
      result.relationshipList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/RelatedPerson.name') do
      result.nameList.Add(parseHumanName(item));
    for item in obj.complexes('http://hl7.org/fhir/RelatedPerson.telecom') do
      result.telecomList.Add(parseContactPoint(item));
    result.genderElement := ParseEnum(obj.complex('http://hl7.org/fhir/RelatedPerson.gender'), CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum);
    result.birthDateElement := ParseDate(obj.complex('http://hl7.org/fhir/RelatedPerson.birthDate'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/RelatedPerson.address') do
      result.addressList.Add(parseAddress(item));
    for item in obj.complexes('http://hl7.org/fhir/RelatedPerson.photo') do
      result.photoList.Add(parseAttachment(item));
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/RelatedPerson.period'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/RelatedPerson.communication') do
      result.communicationList.Add(parseRelatedPersonCommunication(item));
end;

procedure TFHIRTurtleComposer.ComposeRelatedPerson(parent :  TTurtleComplex; parentType, name : String; elem : TFhirRelatedPerson; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:RelatedPerson'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'RelatedPerson', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('active') then
    ComposeBoolean(this, 'RelatedPerson', 'active', elem.activeElement, false, -1);{x.2ea}
  ComposeReference{TFhirPatient}(this, 'RelatedPerson', 'patient', elem.patientElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('relationship') then
    for i := 0 to elem.relationshipList.Count - 1 do
      ComposeCodeableConcept(this, 'RelatedPerson', 'relationship', elem.relationshipList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    for i := 0 to elem.nameList.Count - 1 do
      ComposeHumanName(this, 'RelatedPerson', 'name', elem.nameList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('telecom') then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(this, 'RelatedPerson', 'telecom', elem.telecomList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('gender') then
    ComposeEnum(this, 'RelatedPerson', 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('birthDate') then
    ComposeDate(this, 'RelatedPerson', 'birthDate', elem.birthDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('address') then
    for i := 0 to elem.addressList.Count - 1 do
      ComposeAddress(this, 'RelatedPerson', 'address', elem.addressList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('photo') then
    for i := 0 to elem.photoList.Count - 1 do
      ComposeAttachment(this, 'RelatedPerson', 'photo', elem.photoList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('period') then
    ComposePeriod(this, 'RelatedPerson', 'period', elem.periodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('communication') then
    for i := 0 to elem.communicationList.Count - 1 do
      ComposeRelatedPersonCommunication(this, 'RelatedPerson', 'communication', elem.communicationList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_RELATEDPERSON}
{$IFDEF FHIR_REQUESTGROUP}
function TFHIRTurtleParser.ParseRequestGroupAction(obj : TTurtleComplex) : TFhirRequestGroupAction;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirRequestGroupAction.create;
  try
    ParseRequestGroupActionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseRequestGroupActionProperties(obj : TTurtleComplex; result : TFhirRequestGroupAction);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.prefixElement := ParseString(obj.complex('http://hl7.org/fhir/RequestGroup.action.prefix'));{q1}
    result.titleElement := ParseString(obj.complex('http://hl7.org/fhir/RequestGroup.action.title'));{q1}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/RequestGroup.action.description'));{q1}
    result.textEquivalentElement := ParseString(obj.complex('http://hl7.org/fhir/RequestGroup.action.textEquivalent'));{q1}
    result.priorityElement := ParseEnum(obj.complex('http://hl7.org/fhir/RequestGroup.action.priority'), CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum);
    for item in obj.complexes('http://hl7.org/fhir/RequestGroup.action.code') do
      result.codeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/RequestGroup.action.documentation') do
      result.documentationList.Add(parseRelatedArtifact(item));
    for item in obj.complexes('http://hl7.org/fhir/RequestGroup.action.condition') do
      result.conditionList.Add(parseRequestGroupActionCondition(item));
    for item in obj.complexes('http://hl7.org/fhir/RequestGroup.action.relatedAction') do
      result.relatedActionList.Add(parseRequestGroupActionRelatedAction(item));
    if obj.has('http://hl7.org/fhir/RequestGroup.action.timingAge', item) then
      result.timing := parseAge(item);
    if obj.has('http://hl7.org/fhir/RequestGroup.action.timingPeriod', item) then
      result.timing := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/RequestGroup.action.timingDuration', item) then
      result.timing := parseDuration(item);
    if obj.has('http://hl7.org/fhir/RequestGroup.action.timingRange', item) then
      result.timing := parseRange(item);
    if obj.has('http://hl7.org/fhir/RequestGroup.action.timingTiming', item) then
      result.timing := parseTiming(item);
    if obj.has('http://hl7.org/fhir/RequestGroup.action.timingDateTime', item) then
      result.timing := parseDateTime(item);
    for item in obj.complexes('http://hl7.org/fhir/RequestGroup.action.participant') do
      result.participantList.Add(parseReference{TFhirPatient}(item));
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/RequestGroup.action.type'));{q3b}
    result.groupingBehaviorElement := ParseEnum(obj.complex('http://hl7.org/fhir/RequestGroup.action.groupingBehavior'), CODES_TFhirActionGroupingBehaviorEnum, SYSTEMS_TFhirActionGroupingBehaviorEnum);
    result.selectionBehaviorElement := ParseEnum(obj.complex('http://hl7.org/fhir/RequestGroup.action.selectionBehavior'), CODES_TFhirActionSelectionBehaviorEnum, SYSTEMS_TFhirActionSelectionBehaviorEnum);
    result.requiredBehaviorElement := ParseEnum(obj.complex('http://hl7.org/fhir/RequestGroup.action.requiredBehavior'), CODES_TFhirActionRequiredBehaviorEnum, SYSTEMS_TFhirActionRequiredBehaviorEnum);
    result.precheckBehaviorElement := ParseEnum(obj.complex('http://hl7.org/fhir/RequestGroup.action.precheckBehavior'), CODES_TFhirActionPrecheckBehaviorEnum, SYSTEMS_TFhirActionPrecheckBehaviorEnum);
    result.cardinalityBehaviorElement := ParseEnum(obj.complex('http://hl7.org/fhir/RequestGroup.action.cardinalityBehavior'), CODES_TFhirActionCardinalityBehaviorEnum, SYSTEMS_TFhirActionCardinalityBehaviorEnum);
    result.resource := ParseReference{TFhirReference}(obj.complex('http://hl7.org/fhir/RequestGroup.action.resource'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/RequestGroup.action.action') do
      result.actionList.Add(parseRequestGroupAction(item));
end;

procedure TFHIRTurtleComposer.ComposeRequestGroupAction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirRequestGroupAction; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:RequestGroupAction'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'RequestGroup.action', 'prefix', elem.prefixElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'RequestGroup.action', 'title', elem.titleElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'RequestGroup.action', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'RequestGroup.action', 'textEquivalent', elem.textEquivalentElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'RequestGroup.action', 'priority', elem.PriorityElement, CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.codeList.Count - 1 do
      ComposeCodeableConcept(this, 'RequestGroup.action', 'code', elem.codeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.documentationList.Count - 1 do
      ComposeRelatedArtifact(this, 'RequestGroup.action', 'documentation', elem.documentationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.conditionList.Count - 1 do
      ComposeRequestGroupActionCondition(this, 'RequestGroup.action', 'condition', elem.conditionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.relatedActionList.Count - 1 do
      ComposeRequestGroupActionRelatedAction(this, 'RequestGroup.action', 'relatedAction', elem.relatedActionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirAge) {6} then
    ComposeAge(this, 'RequestGroup.action', 'timingAge', TFhirAge(elem.timing), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirPeriod) {6} then
    ComposePeriod(this, 'RequestGroup.action', 'timingPeriod', TFhirPeriod(elem.timing), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirDuration) {6} then
    ComposeDuration(this, 'RequestGroup.action', 'timingDuration', TFhirDuration(elem.timing), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirRange) {6} then
    ComposeRange(this, 'RequestGroup.action', 'timingRange', TFhirRange(elem.timing), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirTiming) {6} then
    ComposeTiming(this, 'RequestGroup.action', 'timingTiming', TFhirTiming(elem.timing), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirDateTime) {6} then
    ComposeDateTime(this, 'RequestGroup.action', 'timingDateTime', TFhirDateTime(elem.timing), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.participantList.Count - 1 do
      ComposeReference{TFhirPatient}(this, 'RequestGroup.action', 'participant', elem.participantList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'RequestGroup.action', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'RequestGroup.action', 'groupingBehavior', elem.GroupingBehaviorElement, CODES_TFhirActionGroupingBehaviorEnum, SYSTEMS_TFhirActionGroupingBehaviorEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'RequestGroup.action', 'selectionBehavior', elem.SelectionBehaviorElement, CODES_TFhirActionSelectionBehaviorEnum, SYSTEMS_TFhirActionSelectionBehaviorEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'RequestGroup.action', 'requiredBehavior', elem.RequiredBehaviorElement, CODES_TFhirActionRequiredBehaviorEnum, SYSTEMS_TFhirActionRequiredBehaviorEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'RequestGroup.action', 'precheckBehavior', elem.PrecheckBehaviorElement, CODES_TFhirActionPrecheckBehaviorEnum, SYSTEMS_TFhirActionPrecheckBehaviorEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'RequestGroup.action', 'cardinalityBehavior', elem.CardinalityBehaviorElement, CODES_TFhirActionCardinalityBehaviorEnum, SYSTEMS_TFhirActionCardinalityBehaviorEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirReference}(this, 'RequestGroup.action', 'resource', elem.resourceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.actionList.Count - 1 do
      ComposeRequestGroupAction(this, 'RequestGroup.action', 'action', elem.actionList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseRequestGroupActionCondition(obj : TTurtleComplex) : TFhirRequestGroupActionCondition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirRequestGroupActionCondition.create;
  try
    ParseRequestGroupActionConditionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseRequestGroupActionConditionProperties(obj : TTurtleComplex; result : TFhirRequestGroupActionCondition);
begin
    ParseBackboneElementProperties(obj, result);
    result.kindElement := ParseEnum(obj.complex('http://hl7.org/fhir/RequestGroup.action.condition.kind'), CODES_TFhirActionConditionKindEnum, SYSTEMS_TFhirActionConditionKindEnum);
    result.expression := ParseExpression(obj.complex('http://hl7.org/fhir/RequestGroup.action.condition.expression'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeRequestGroupActionCondition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirRequestGroupActionCondition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:RequestGroupActionCondition'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'RequestGroup.action.condition', 'kind', elem.KindElement, CODES_TFhirActionConditionKindEnum, SYSTEMS_TFhirActionConditionKindEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeExpression(this, 'RequestGroup.action.condition', 'expression', elem.expressionElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseRequestGroupActionRelatedAction(obj : TTurtleComplex) : TFhirRequestGroupActionRelatedAction;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirRequestGroupActionRelatedAction.create;
  try
    ParseRequestGroupActionRelatedActionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseRequestGroupActionRelatedActionProperties(obj : TTurtleComplex; result : TFhirRequestGroupActionRelatedAction);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.actionIdElement := ParseId(obj.complex('http://hl7.org/fhir/RequestGroup.action.relatedAction.actionId'));{q1}
    result.relationshipElement := ParseEnum(obj.complex('http://hl7.org/fhir/RequestGroup.action.relatedAction.relationship'), CODES_TFhirActionRelationshipTypeEnum, SYSTEMS_TFhirActionRelationshipTypeEnum);
    if obj.has('http://hl7.org/fhir/RequestGroup.action.relatedAction.offsetDuration', item) then
      result.offset := parseDuration(item);
    if obj.has('http://hl7.org/fhir/RequestGroup.action.relatedAction.offsetRange', item) then
      result.offset := parseRange(item);
end;

procedure TFHIRTurtleComposer.ComposeRequestGroupActionRelatedAction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirRequestGroupActionRelatedAction; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:RequestGroupActionRelatedAction'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeId(this, 'RequestGroup.action.relatedAction', 'actionId', elem.actionIdElement, false, -1);{x.2ea}
  ComposeEnum(this, 'RequestGroup.action.relatedAction', 'relationship', elem.RelationshipElement, CODES_TFhirActionRelationshipTypeEnum, SYSTEMS_TFhirActionRelationshipTypeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and (elem.offset is TFhirDuration) {6} then
    ComposeDuration(this, 'RequestGroup.action.relatedAction', 'offsetDuration', TFhirDuration(elem.offset), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.offset is TFhirRange) {6} then
    ComposeRange(this, 'RequestGroup.action.relatedAction', 'offsetRange', TFhirRange(elem.offset), false, -1);{x.d9}
end;

function TFHIRTurtleParser.ParseRequestGroup(obj : TTurtleComplex) : TFhirRequestGroup;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirRequestGroup.create;
  try
    ParseRequestGroupProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseRequestGroupProperties(obj : TTurtleComplex; result : TFhirRequestGroup);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/RequestGroup.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/RequestGroup.instantiatesCanonical') do
      result.instantiatesCanonicalList.Add(parseCanonical(item));
    for item in obj.complexes('http://hl7.org/fhir/RequestGroup.instantiatesUri') do
      result.instantiatesUriList.Add(parseUri(item));
    for item in obj.complexes('http://hl7.org/fhir/RequestGroup.basedOn') do
      result.basedOnList.Add(parseReference{TFhirReference}(item));
    for item in obj.complexes('http://hl7.org/fhir/RequestGroup.replaces') do
      result.replacesList.Add(parseReference{TFhirReference}(item));
    result.groupIdentifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/RequestGroup.groupIdentifier'));{q3b}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/RequestGroup.status'), CODES_TFhirRequestStatusEnum, SYSTEMS_TFhirRequestStatusEnum);
    result.intentElement := ParseEnum(obj.complex('http://hl7.org/fhir/RequestGroup.intent'), CODES_TFhirRequestIntentEnum, SYSTEMS_TFhirRequestIntentEnum);
    result.priorityElement := ParseEnum(obj.complex('http://hl7.org/fhir/RequestGroup.priority'), CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum);
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/RequestGroup.code'));{q3b}
    result.subject := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/RequestGroup.subject'));{q3b}
    result.encounter := ParseReference{TFhirEncounter}(obj.complex('http://hl7.org/fhir/RequestGroup.encounter'));{q3b}
    result.authoredOnElement := ParseDateTime(obj.complex('http://hl7.org/fhir/RequestGroup.authoredOn'));{q1}
    result.author := ParseReference{TFhirDevice}(obj.complex('http://hl7.org/fhir/RequestGroup.author'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/RequestGroup.reasonCode') do
      result.reasonCodeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/RequestGroup.reasonReference') do
      result.reasonReferenceList.Add(parseReference{TFhirCondition}(item));
    for item in obj.complexes('http://hl7.org/fhir/RequestGroup.note') do
      result.noteList.Add(parseAnnotation(item));
    for item in obj.complexes('http://hl7.org/fhir/RequestGroup.action') do
      result.actionList.Add(parseRequestGroupAction(item));
end;

procedure TFHIRTurtleComposer.ComposeRequestGroup(parent :  TTurtleComplex; parentType, name : String; elem : TFhirRequestGroup; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:RequestGroup'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'RequestGroup', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('instantiatesCanonical') then
    for i := 0 to elem.instantiatesCanonicalList.Count - 1 do
      ComposeCanonical(this, 'RequestGroup', 'instantiatesCanonical', elem.instantiatesCanonicalList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('instantiatesUri') then
    for i := 0 to elem.instantiatesUriList.Count - 1 do
      ComposeUri(this, 'RequestGroup', 'instantiatesUri', elem.instantiatesUriList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('basedOn') then
    for i := 0 to elem.basedOnList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'RequestGroup', 'basedOn', elem.basedOnList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('replaces') then
    for i := 0 to elem.replacesList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'RequestGroup', 'replaces', elem.replacesList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('groupIdentifier') then
    ComposeIdentifier(this, 'RequestGroup', 'groupIdentifier', elem.groupIdentifierElement, false, -1);{x.2f}
  ComposeEnum(this, 'RequestGroup', 'status', elem.StatusElement, CODES_TFhirRequestStatusEnum, SYSTEMS_TFhirRequestStatusEnum, false, -1);{x.d4}
  ComposeEnum(this, 'RequestGroup', 'intent', elem.IntentElement, CODES_TFhirRequestIntentEnum, SYSTEMS_TFhirRequestIntentEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('priority') then
    ComposeEnum(this, 'RequestGroup', 'priority', elem.PriorityElement, CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') then
    ComposeCodeableConcept(this, 'RequestGroup', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('subject') then
    ComposeReference{TFhirPatient}(this, 'RequestGroup', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(this, 'RequestGroup', 'encounter', elem.encounterElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('authoredOn') then
    ComposeDateTime(this, 'RequestGroup', 'authoredOn', elem.authoredOnElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('author') then
    ComposeReference{TFhirDevice}(this, 'RequestGroup', 'author', elem.authorElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('reasonCode') then
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'RequestGroup', 'reasonCode', elem.reasonCodeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('reasonReference') then
    for i := 0 to elem.reasonReferenceList.Count - 1 do
      ComposeReference{TFhirCondition}(this, 'RequestGroup', 'reasonReference', elem.reasonReferenceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'RequestGroup', 'note', elem.noteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('action') then
    for i := 0 to elem.actionList.Count - 1 do
      ComposeRequestGroupAction(this, 'RequestGroup', 'action', elem.actionList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_REQUESTGROUP}
{$IFDEF FHIR_RESEARCHDEFINITION}
function TFHIRTurtleParser.ParseResearchDefinition(obj : TTurtleComplex) : TFhirResearchDefinition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirResearchDefinition.create;
  try
    ParseResearchDefinitionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseResearchDefinitionProperties(obj : TTurtleComplex; result : TFhirResearchDefinition);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/ResearchDefinition.url'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ResearchDefinition.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/ResearchDefinition.version'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/ResearchDefinition.name'));{q1}
    result.titleElement := ParseString(obj.complex('http://hl7.org/fhir/ResearchDefinition.title'));{q1}
    result.shortTitleElement := ParseString(obj.complex('http://hl7.org/fhir/ResearchDefinition.shortTitle'));{q1}
    result.subtitleElement := ParseString(obj.complex('http://hl7.org/fhir/ResearchDefinition.subtitle'));{q1}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/ResearchDefinition.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    result.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ResearchDefinition.experimental'));{q1}
    if obj.has('http://hl7.org/fhir/ResearchDefinition.subjectCodeableConcept', item) then
      result.subject := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/ResearchDefinition.subjectReference', item) {a3} then
      result.subject := ParseReference(item);
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ResearchDefinition.date'));{q1}
    result.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/ResearchDefinition.publisher'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ResearchDefinition.contact') do
      result.contactList.Add(parseContactDetail(item));
    result.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ResearchDefinition.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ResearchDefinition.comment') do
      result.commentList.Add(parseString(item));
    for item in obj.complexes('http://hl7.org/fhir/ResearchDefinition.useContext') do
      result.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/ResearchDefinition.jurisdiction') do
      result.jurisdictionList.Add(parseCodeableConcept(item));
    result.purposeElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ResearchDefinition.purpose'));{q1}
    result.usageElement := ParseString(obj.complex('http://hl7.org/fhir/ResearchDefinition.usage'));{q1}
    result.copyrightElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ResearchDefinition.copyright'));{q1}
    result.approvalDateElement := ParseDate(obj.complex('http://hl7.org/fhir/ResearchDefinition.approvalDate'));{q1}
    result.lastReviewDateElement := ParseDate(obj.complex('http://hl7.org/fhir/ResearchDefinition.lastReviewDate'));{q1}
    result.effectivePeriod := ParsePeriod(obj.complex('http://hl7.org/fhir/ResearchDefinition.effectivePeriod'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ResearchDefinition.topic') do
      result.topicList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/ResearchDefinition.author') do
      result.authorList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/ResearchDefinition.editor') do
      result.editorList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/ResearchDefinition.reviewer') do
      result.reviewerList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/ResearchDefinition.endorser') do
      result.endorserList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/ResearchDefinition.relatedArtifact') do
      result.relatedArtifactList.Add(parseRelatedArtifact(item));
    for item in obj.complexes('http://hl7.org/fhir/ResearchDefinition.library') do
      result.library_List.Add(parseCanonical(item));
    result.population := ParseReference{TFhirResearchElementDefinition}(obj.complex('http://hl7.org/fhir/ResearchDefinition.population'));{q3b}
    result.exposure := ParseReference{TFhirResearchElementDefinition}(obj.complex('http://hl7.org/fhir/ResearchDefinition.exposure'));{q3b}
    result.exposureAlternative := ParseReference{TFhirResearchElementDefinition}(obj.complex('http://hl7.org/fhir/ResearchDefinition.exposureAlternative'));{q3b}
    result.outcome := ParseReference{TFhirResearchElementDefinition}(obj.complex('http://hl7.org/fhir/ResearchDefinition.outcome'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeResearchDefinition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirResearchDefinition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ResearchDefinition'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUri(this, 'ResearchDefinition', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'ResearchDefinition', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(this, 'ResearchDefinition', 'version', elem.versionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(this, 'ResearchDefinition', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeString(this, 'ResearchDefinition', 'title', elem.titleElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('shortTitle') then
    ComposeString(this, 'ResearchDefinition', 'shortTitle', elem.shortTitleElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('subtitle') then
    ComposeString(this, 'ResearchDefinition', 'subtitle', elem.subtitleElement, false, -1);{x.2ea}
  ComposeEnum(this, 'ResearchDefinition', 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(this, 'ResearchDefinition', 'experimental', elem.experimentalElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and (elem.subject is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'ResearchDefinition', 'subjectCodeableConcept', TFhirCodeableConcept(elem.subject), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.subject is TFhirReference) {2} then
    ComposeReference(this, 'ResearchDefinition', 'subjectReference', TFhirReference(elem.subject), false,-1);{x.d8}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(this, 'ResearchDefinition', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(this, 'ResearchDefinition', 'publisher', elem.publisherElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(this, 'ResearchDefinition', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeMarkdown(this, 'ResearchDefinition', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('comment') then
    for i := 0 to elem.commentList.Count - 1 do
      ComposeString(this, 'ResearchDefinition', 'comment', elem.commentList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(this, 'ResearchDefinition', 'useContext', elem.useContextList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'ResearchDefinition', 'jurisdiction', elem.jurisdictionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdown(this, 'ResearchDefinition', 'purpose', elem.purposeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('usage') then
    ComposeString(this, 'ResearchDefinition', 'usage', elem.usageElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdown(this, 'ResearchDefinition', 'copyright', elem.copyrightElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('approvalDate') then
    ComposeDate(this, 'ResearchDefinition', 'approvalDate', elem.approvalDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('lastReviewDate') then
    ComposeDate(this, 'ResearchDefinition', 'lastReviewDate', elem.lastReviewDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('effectivePeriod') then
    ComposePeriod(this, 'ResearchDefinition', 'effectivePeriod', elem.effectivePeriodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('topic') then
    for i := 0 to elem.topicList.Count - 1 do
      ComposeCodeableConcept(this, 'ResearchDefinition', 'topic', elem.topicList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('author') then
    for i := 0 to elem.authorList.Count - 1 do
      ComposeContactDetail(this, 'ResearchDefinition', 'author', elem.authorList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('editor') then
    for i := 0 to elem.editorList.Count - 1 do
      ComposeContactDetail(this, 'ResearchDefinition', 'editor', elem.editorList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('reviewer') then
    for i := 0 to elem.reviewerList.Count - 1 do
      ComposeContactDetail(this, 'ResearchDefinition', 'reviewer', elem.reviewerList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('endorser') then
    for i := 0 to elem.endorserList.Count - 1 do
      ComposeContactDetail(this, 'ResearchDefinition', 'endorser', elem.endorserList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('relatedArtifact') then
    for i := 0 to elem.relatedArtifactList.Count - 1 do
      ComposeRelatedArtifact(this, 'ResearchDefinition', 'relatedArtifact', elem.relatedArtifactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('library_') then
    for i := 0 to elem.library_List.Count - 1 do
      ComposeCanonical(this, 'ResearchDefinition', 'library', elem.library_List[i], false, i);{x.d3}
  ComposeReference{TFhirResearchElementDefinition}(this, 'ResearchDefinition', 'population', elem.populationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('exposure') then
    ComposeReference{TFhirResearchElementDefinition}(this, 'ResearchDefinition', 'exposure', elem.exposureElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('exposureAlternative') then
    ComposeReference{TFhirResearchElementDefinition}(this, 'ResearchDefinition', 'exposureAlternative', elem.exposureAlternativeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('outcome') then
    ComposeReference{TFhirResearchElementDefinition}(this, 'ResearchDefinition', 'outcome', elem.outcomeElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_RESEARCHDEFINITION}
{$IFDEF FHIR_RESEARCHELEMENTDEFINITION}
function TFHIRTurtleParser.ParseResearchElementDefinitionCharacteristic(obj : TTurtleComplex) : TFhirResearchElementDefinitionCharacteristic;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirResearchElementDefinitionCharacteristic.create;
  try
    ParseResearchElementDefinitionCharacteristicProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseResearchElementDefinitionCharacteristicProperties(obj : TTurtleComplex; result : TFhirResearchElementDefinitionCharacteristic);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    if obj.has('http://hl7.org/fhir/ResearchElementDefinition.characteristic.definitionCodeableConcept', item) then
      result.definition := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/ResearchElementDefinition.characteristic.definitionCanonical', item) then
      result.definition := parseCanonical(item);
    if obj.has('http://hl7.org/fhir/ResearchElementDefinition.characteristic.definitionExpression', item) then
      result.definition := parseExpression(item);
    if obj.has('http://hl7.org/fhir/ResearchElementDefinition.characteristic.definitionDataRequirement', item) then
      result.definition := parseDataRequirement(item);
    for item in obj.complexes('http://hl7.org/fhir/ResearchElementDefinition.characteristic.usageContext') do
      result.usageContextList.Add(parseUsageContext(item));
    result.excludeElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ResearchElementDefinition.characteristic.exclude'));{q1}
    result.unitOfMeasure := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ResearchElementDefinition.characteristic.unitOfMeasure'));{q3b}
    result.studyEffectiveDescriptionElement := ParseString(obj.complex('http://hl7.org/fhir/ResearchElementDefinition.characteristic.studyEffectiveDescription'));{q1}
    if obj.has('http://hl7.org/fhir/ResearchElementDefinition.characteristic.studyEffectivePeriod', item) then
      result.studyEffective := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/ResearchElementDefinition.characteristic.studyEffectiveDuration', item) then
      result.studyEffective := parseDuration(item);
    if obj.has('http://hl7.org/fhir/ResearchElementDefinition.characteristic.studyEffectiveTiming', item) then
      result.studyEffective := parseTiming(item);
    if obj.has('http://hl7.org/fhir/ResearchElementDefinition.characteristic.studyEffectiveDateTime', item) then
      result.studyEffective := parseDateTime(item);
    result.studyEffectiveTimeFromStart := ParseDuration(obj.complex('http://hl7.org/fhir/ResearchElementDefinition.characteristic.studyEffectiveTimeFromStart'));{q3b}
    result.studyEffectiveGroupMeasureElement := ParseEnum(obj.complex('http://hl7.org/fhir/ResearchElementDefinition.characteristic.studyEffectiveGroupMeasure'), CODES_TFhirGroupMeasureEnum, SYSTEMS_TFhirGroupMeasureEnum);
    result.participantEffectiveDescriptionElement := ParseString(obj.complex('http://hl7.org/fhir/ResearchElementDefinition.characteristic.participantEffectiveDescription'));{q1}
    if obj.has('http://hl7.org/fhir/ResearchElementDefinition.characteristic.participantEffectivePeriod', item) then
      result.participantEffective := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/ResearchElementDefinition.characteristic.participantEffectiveDuration', item) then
      result.participantEffective := parseDuration(item);
    if obj.has('http://hl7.org/fhir/ResearchElementDefinition.characteristic.participantEffectiveTiming', item) then
      result.participantEffective := parseTiming(item);
    if obj.has('http://hl7.org/fhir/ResearchElementDefinition.characteristic.participantEffectiveDateTime', item) then
      result.participantEffective := parseDateTime(item);
    result.participantEffectiveTimeFromStart := ParseDuration(obj.complex('http://hl7.org/fhir/ResearchElementDefinition.characteristic.participantEffectiveTimeFromStart'));{q3b}
    result.participantEffectiveGroupMeasureElement := ParseEnum(obj.complex('http://hl7.org/fhir/ResearchElementDefinition.characteristic.participantEffectiveGroupMeasure'), CODES_TFhirGroupMeasureEnum, SYSTEMS_TFhirGroupMeasureEnum);
end;

procedure TFHIRTurtleComposer.ComposeResearchElementDefinitionCharacteristic(parent :  TTurtleComplex; parentType, name : String; elem : TFhirResearchElementDefinitionCharacteristic; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ResearchElementDefinitionCharacteristic'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (elem.definition is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'ResearchElementDefinition.characteristic', 'definitionCodeableConcept', TFhirCodeableConcept(elem.definition), false, -1){x.d9}
  else if (elem.definition is TFhirCanonical) {6} then
    ComposeCanonical(this, 'ResearchElementDefinition.characteristic', 'definitionCanonical', TFhirCanonical(elem.definition), false, -1){x.d9}
  else if (elem.definition is TFhirExpression) {6} then
    ComposeExpression(this, 'ResearchElementDefinition.characteristic', 'definitionExpression', TFhirExpression(elem.definition), false, -1){x.d9}
  else if (elem.definition is TFhirDataRequirement) {6} then
    ComposeDataRequirement(this, 'ResearchElementDefinition.characteristic', 'definitionDataRequirement', TFhirDataRequirement(elem.definition), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.usageContextList.Count - 1 do
      ComposeUsageContext(this, 'ResearchElementDefinition.characteristic', 'usageContext', elem.usageContextList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'ResearchElementDefinition.characteristic', 'exclude', elem.excludeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ResearchElementDefinition.characteristic', 'unitOfMeasure', elem.unitOfMeasureElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ResearchElementDefinition.characteristic', 'studyEffectiveDescription', elem.studyEffectiveDescriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and (elem.studyEffective is TFhirPeriod) {6} then
    ComposePeriod(this, 'ResearchElementDefinition.characteristic', 'studyEffectivePeriod', TFhirPeriod(elem.studyEffective), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.studyEffective is TFhirDuration) {6} then
    ComposeDuration(this, 'ResearchElementDefinition.characteristic', 'studyEffectiveDuration', TFhirDuration(elem.studyEffective), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.studyEffective is TFhirTiming) {6} then
    ComposeTiming(this, 'ResearchElementDefinition.characteristic', 'studyEffectiveTiming', TFhirTiming(elem.studyEffective), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.studyEffective is TFhirDateTime) {6} then
    ComposeDateTime(this, 'ResearchElementDefinition.characteristic', 'studyEffectiveDateTime', TFhirDateTime(elem.studyEffective), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) then
    ComposeDuration(this, 'ResearchElementDefinition.characteristic', 'studyEffectiveTimeFromStart', elem.studyEffectiveTimeFromStartElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'ResearchElementDefinition.characteristic', 'studyEffectiveGroupMeasure', elem.StudyEffectiveGroupMeasureElement, CODES_TFhirGroupMeasureEnum, SYSTEMS_TFhirGroupMeasureEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ResearchElementDefinition.characteristic', 'participantEffectiveDescription', elem.participantEffectiveDescriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and (elem.participantEffective is TFhirPeriod) {6} then
    ComposePeriod(this, 'ResearchElementDefinition.characteristic', 'participantEffectivePeriod', TFhirPeriod(elem.participantEffective), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.participantEffective is TFhirDuration) {6} then
    ComposeDuration(this, 'ResearchElementDefinition.characteristic', 'participantEffectiveDuration', TFhirDuration(elem.participantEffective), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.participantEffective is TFhirTiming) {6} then
    ComposeTiming(this, 'ResearchElementDefinition.characteristic', 'participantEffectiveTiming', TFhirTiming(elem.participantEffective), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.participantEffective is TFhirDateTime) {6} then
    ComposeDateTime(this, 'ResearchElementDefinition.characteristic', 'participantEffectiveDateTime', TFhirDateTime(elem.participantEffective), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) then
    ComposeDuration(this, 'ResearchElementDefinition.characteristic', 'participantEffectiveTimeFromStart', elem.participantEffectiveTimeFromStartElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'ResearchElementDefinition.characteristic', 'participantEffectiveGroupMeasure', elem.ParticipantEffectiveGroupMeasureElement, CODES_TFhirGroupMeasureEnum, SYSTEMS_TFhirGroupMeasureEnum, false, -1);{x.d4}
end;

function TFHIRTurtleParser.ParseResearchElementDefinition(obj : TTurtleComplex) : TFhirResearchElementDefinition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirResearchElementDefinition.create;
  try
    ParseResearchElementDefinitionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseResearchElementDefinitionProperties(obj : TTurtleComplex; result : TFhirResearchElementDefinition);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/ResearchElementDefinition.url'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ResearchElementDefinition.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/ResearchElementDefinition.version'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/ResearchElementDefinition.name'));{q1}
    result.titleElement := ParseString(obj.complex('http://hl7.org/fhir/ResearchElementDefinition.title'));{q1}
    result.shortTitleElement := ParseString(obj.complex('http://hl7.org/fhir/ResearchElementDefinition.shortTitle'));{q1}
    result.subtitleElement := ParseString(obj.complex('http://hl7.org/fhir/ResearchElementDefinition.subtitle'));{q1}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/ResearchElementDefinition.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    result.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ResearchElementDefinition.experimental'));{q1}
    if obj.has('http://hl7.org/fhir/ResearchElementDefinition.subjectCodeableConcept', item) then
      result.subject := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/ResearchElementDefinition.subjectReference', item) {a3} then
      result.subject := ParseReference(item);
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ResearchElementDefinition.date'));{q1}
    result.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/ResearchElementDefinition.publisher'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ResearchElementDefinition.contact') do
      result.contactList.Add(parseContactDetail(item));
    result.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ResearchElementDefinition.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ResearchElementDefinition.comment') do
      result.commentList.Add(parseString(item));
    for item in obj.complexes('http://hl7.org/fhir/ResearchElementDefinition.useContext') do
      result.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/ResearchElementDefinition.jurisdiction') do
      result.jurisdictionList.Add(parseCodeableConcept(item));
    result.purposeElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ResearchElementDefinition.purpose'));{q1}
    result.usageElement := ParseString(obj.complex('http://hl7.org/fhir/ResearchElementDefinition.usage'));{q1}
    result.copyrightElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ResearchElementDefinition.copyright'));{q1}
    result.approvalDateElement := ParseDate(obj.complex('http://hl7.org/fhir/ResearchElementDefinition.approvalDate'));{q1}
    result.lastReviewDateElement := ParseDate(obj.complex('http://hl7.org/fhir/ResearchElementDefinition.lastReviewDate'));{q1}
    result.effectivePeriod := ParsePeriod(obj.complex('http://hl7.org/fhir/ResearchElementDefinition.effectivePeriod'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ResearchElementDefinition.topic') do
      result.topicList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/ResearchElementDefinition.author') do
      result.authorList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/ResearchElementDefinition.editor') do
      result.editorList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/ResearchElementDefinition.reviewer') do
      result.reviewerList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/ResearchElementDefinition.endorser') do
      result.endorserList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/ResearchElementDefinition.relatedArtifact') do
      result.relatedArtifactList.Add(parseRelatedArtifact(item));
    for item in obj.complexes('http://hl7.org/fhir/ResearchElementDefinition.library') do
      result.library_List.Add(parseCanonical(item));
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/ResearchElementDefinition.type'), CODES_TFhirResearchElementTypeEnum, SYSTEMS_TFhirResearchElementTypeEnum);
    result.variableTypeElement := ParseEnum(obj.complex('http://hl7.org/fhir/ResearchElementDefinition.variableType'), CODES_TFhirVariableTypeEnum, SYSTEMS_TFhirVariableTypeEnum);
    for item in obj.complexes('http://hl7.org/fhir/ResearchElementDefinition.characteristic') do
      result.characteristicList.Add(parseResearchElementDefinitionCharacteristic(item));
end;

procedure TFHIRTurtleComposer.ComposeResearchElementDefinition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirResearchElementDefinition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ResearchElementDefinition'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUri(this, 'ResearchElementDefinition', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'ResearchElementDefinition', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(this, 'ResearchElementDefinition', 'version', elem.versionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(this, 'ResearchElementDefinition', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeString(this, 'ResearchElementDefinition', 'title', elem.titleElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('shortTitle') then
    ComposeString(this, 'ResearchElementDefinition', 'shortTitle', elem.shortTitleElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('subtitle') then
    ComposeString(this, 'ResearchElementDefinition', 'subtitle', elem.subtitleElement, false, -1);{x.2ea}
  ComposeEnum(this, 'ResearchElementDefinition', 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(this, 'ResearchElementDefinition', 'experimental', elem.experimentalElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and (elem.subject is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'ResearchElementDefinition', 'subjectCodeableConcept', TFhirCodeableConcept(elem.subject), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.subject is TFhirReference) {2} then
    ComposeReference(this, 'ResearchElementDefinition', 'subjectReference', TFhirReference(elem.subject), false,-1);{x.d8}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(this, 'ResearchElementDefinition', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(this, 'ResearchElementDefinition', 'publisher', elem.publisherElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(this, 'ResearchElementDefinition', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeMarkdown(this, 'ResearchElementDefinition', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('comment') then
    for i := 0 to elem.commentList.Count - 1 do
      ComposeString(this, 'ResearchElementDefinition', 'comment', elem.commentList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(this, 'ResearchElementDefinition', 'useContext', elem.useContextList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'ResearchElementDefinition', 'jurisdiction', elem.jurisdictionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdown(this, 'ResearchElementDefinition', 'purpose', elem.purposeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('usage') then
    ComposeString(this, 'ResearchElementDefinition', 'usage', elem.usageElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdown(this, 'ResearchElementDefinition', 'copyright', elem.copyrightElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('approvalDate') then
    ComposeDate(this, 'ResearchElementDefinition', 'approvalDate', elem.approvalDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('lastReviewDate') then
    ComposeDate(this, 'ResearchElementDefinition', 'lastReviewDate', elem.lastReviewDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('effectivePeriod') then
    ComposePeriod(this, 'ResearchElementDefinition', 'effectivePeriod', elem.effectivePeriodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('topic') then
    for i := 0 to elem.topicList.Count - 1 do
      ComposeCodeableConcept(this, 'ResearchElementDefinition', 'topic', elem.topicList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('author') then
    for i := 0 to elem.authorList.Count - 1 do
      ComposeContactDetail(this, 'ResearchElementDefinition', 'author', elem.authorList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('editor') then
    for i := 0 to elem.editorList.Count - 1 do
      ComposeContactDetail(this, 'ResearchElementDefinition', 'editor', elem.editorList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('reviewer') then
    for i := 0 to elem.reviewerList.Count - 1 do
      ComposeContactDetail(this, 'ResearchElementDefinition', 'reviewer', elem.reviewerList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('endorser') then
    for i := 0 to elem.endorserList.Count - 1 do
      ComposeContactDetail(this, 'ResearchElementDefinition', 'endorser', elem.endorserList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('relatedArtifact') then
    for i := 0 to elem.relatedArtifactList.Count - 1 do
      ComposeRelatedArtifact(this, 'ResearchElementDefinition', 'relatedArtifact', elem.relatedArtifactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('library_') then
    for i := 0 to elem.library_List.Count - 1 do
      ComposeCanonical(this, 'ResearchElementDefinition', 'library', elem.library_List[i], false, i);{x.d3}
  ComposeEnum(this, 'ResearchElementDefinition', 'type', elem.Type_Element, CODES_TFhirResearchElementTypeEnum, SYSTEMS_TFhirResearchElementTypeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('variableType') then
    ComposeEnum(this, 'ResearchElementDefinition', 'variableType', elem.VariableTypeElement, CODES_TFhirVariableTypeEnum, SYSTEMS_TFhirVariableTypeEnum, false, -1);{x.d4}
  for i := 0 to elem.characteristicList.Count - 1 do
      ComposeResearchElementDefinitionCharacteristic(this, 'ResearchElementDefinition', 'characteristic', elem.characteristicList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_RESEARCHELEMENTDEFINITION}
{$IFDEF FHIR_RESEARCHSTUDY}
function TFHIRTurtleParser.ParseResearchStudyArm(obj : TTurtleComplex) : TFhirResearchStudyArm;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirResearchStudyArm.create;
  try
    ParseResearchStudyArmProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseResearchStudyArmProperties(obj : TTurtleComplex; result : TFhirResearchStudyArm);
begin
    ParseBackboneElementProperties(obj, result);
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/ResearchStudy.arm.name'));{q1}
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ResearchStudy.arm.type'));{q3b}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/ResearchStudy.arm.description'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeResearchStudyArm(parent :  TTurtleComplex; parentType, name : String; elem : TFhirResearchStudyArm; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ResearchStudyArm'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeString(this, 'ResearchStudy.arm', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ResearchStudy.arm', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ResearchStudy.arm', 'description', elem.descriptionElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseResearchStudyObjective(obj : TTurtleComplex) : TFhirResearchStudyObjective;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirResearchStudyObjective.create;
  try
    ParseResearchStudyObjectiveProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseResearchStudyObjectiveProperties(obj : TTurtleComplex; result : TFhirResearchStudyObjective);
begin
    ParseBackboneElementProperties(obj, result);
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/ResearchStudy.objective.name'));{q1}
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ResearchStudy.objective.type'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeResearchStudyObjective(parent :  TTurtleComplex; parentType, name : String; elem : TFhirResearchStudyObjective; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ResearchStudyObjective'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ResearchStudy.objective', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'ResearchStudy.objective', 'type', elem.type_Element, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseResearchStudy(obj : TTurtleComplex) : TFhirResearchStudy;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirResearchStudy.create;
  try
    ParseResearchStudyProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseResearchStudyProperties(obj : TTurtleComplex; result : TFhirResearchStudy);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/ResearchStudy.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.titleElement := ParseString(obj.complex('http://hl7.org/fhir/ResearchStudy.title'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ResearchStudy.protocol') do
      result.protocolList.Add(parseReference{TFhirPlanDefinition}(item));
    for item in obj.complexes('http://hl7.org/fhir/ResearchStudy.partOf') do
      result.partOfList.Add(parseReference{TFhirResearchStudy}(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/ResearchStudy.status'), CODES_TFhirResearchStudyStatusEnum, SYSTEMS_TFhirResearchStudyStatusEnum);
    result.primaryPurposeType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ResearchStudy.primaryPurposeType'));{q3b}
    result.phase := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ResearchStudy.phase'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ResearchStudy.category') do
      result.categoryList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/ResearchStudy.focus') do
      result.focusList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/ResearchStudy.condition') do
      result.conditionList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/ResearchStudy.contact') do
      result.contactList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/ResearchStudy.relatedArtifact') do
      result.relatedArtifactList.Add(parseRelatedArtifact(item));
    for item in obj.complexes('http://hl7.org/fhir/ResearchStudy.keyword') do
      result.keywordList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/ResearchStudy.location') do
      result.locationList.Add(parseCodeableConcept(item));
    result.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ResearchStudy.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ResearchStudy.enrollment') do
      result.enrollmentList.Add(parseReference{TFhirGroup}(item));
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/ResearchStudy.period'));{q3b}
    result.sponsor := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/ResearchStudy.sponsor'));{q3b}
    result.principalInvestigator := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/ResearchStudy.principalInvestigator'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ResearchStudy.site') do
      result.siteList.Add(parseReference{TFhirLocation}(item));
    result.reasonStopped := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ResearchStudy.reasonStopped'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ResearchStudy.note') do
      result.noteList.Add(parseAnnotation(item));
    for item in obj.complexes('http://hl7.org/fhir/ResearchStudy.arm') do
      result.armList.Add(parseResearchStudyArm(item));
    for item in obj.complexes('http://hl7.org/fhir/ResearchStudy.objective') do
      result.objectiveList.Add(parseResearchStudyObjective(item));
end;

procedure TFHIRTurtleComposer.ComposeResearchStudy(parent :  TTurtleComplex; parentType, name : String; elem : TFhirResearchStudy; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ResearchStudy'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'ResearchStudy', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeString(this, 'ResearchStudy', 'title', elem.titleElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('protocol') then
    for i := 0 to elem.protocolList.Count - 1 do
      ComposeReference{TFhirPlanDefinition}(this, 'ResearchStudy', 'protocol', elem.protocolList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('partOf') then
    for i := 0 to elem.partOfList.Count - 1 do
      ComposeReference{TFhirResearchStudy}(this, 'ResearchStudy', 'partOf', elem.partOfList[i], false, i);{x.d3}
  ComposeEnum(this, 'ResearchStudy', 'status', elem.StatusElement, CODES_TFhirResearchStudyStatusEnum, SYSTEMS_TFhirResearchStudyStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('primaryPurposeType') then
    ComposeCodeableConcept(this, 'ResearchStudy', 'primaryPurposeType', elem.primaryPurposeTypeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('phase') then
    ComposeCodeableConcept(this, 'ResearchStudy', 'phase', elem.phaseElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(this, 'ResearchStudy', 'category', elem.categoryList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('focus') then
    for i := 0 to elem.focusList.Count - 1 do
      ComposeCodeableConcept(this, 'ResearchStudy', 'focus', elem.focusList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('condition') then
    for i := 0 to elem.conditionList.Count - 1 do
      ComposeCodeableConcept(this, 'ResearchStudy', 'condition', elem.conditionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(this, 'ResearchStudy', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('relatedArtifact') then
    for i := 0 to elem.relatedArtifactList.Count - 1 do
      ComposeRelatedArtifact(this, 'ResearchStudy', 'relatedArtifact', elem.relatedArtifactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('keyword') then
    for i := 0 to elem.keywordList.Count - 1 do
      ComposeCodeableConcept(this, 'ResearchStudy', 'keyword', elem.keywordList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('location') then
    for i := 0 to elem.locationList.Count - 1 do
      ComposeCodeableConcept(this, 'ResearchStudy', 'location', elem.locationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdown(this, 'ResearchStudy', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('enrollment') then
    for i := 0 to elem.enrollmentList.Count - 1 do
      ComposeReference{TFhirGroup}(this, 'ResearchStudy', 'enrollment', elem.enrollmentList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('period') then
    ComposePeriod(this, 'ResearchStudy', 'period', elem.periodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('sponsor') then
    ComposeReference{TFhirOrganization}(this, 'ResearchStudy', 'sponsor', elem.sponsorElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('principalInvestigator') then
    ComposeReference{TFhirPractitioner}(this, 'ResearchStudy', 'principalInvestigator', elem.principalInvestigatorElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('site') then
    for i := 0 to elem.siteList.Count - 1 do
      ComposeReference{TFhirLocation}(this, 'ResearchStudy', 'site', elem.siteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonStopped') then
    ComposeCodeableConcept(this, 'ResearchStudy', 'reasonStopped', elem.reasonStoppedElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'ResearchStudy', 'note', elem.noteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('arm') then
    for i := 0 to elem.armList.Count - 1 do
      ComposeResearchStudyArm(this, 'ResearchStudy', 'arm', elem.armList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('objective') then
    for i := 0 to elem.objectiveList.Count - 1 do
      ComposeResearchStudyObjective(this, 'ResearchStudy', 'objective', elem.objectiveList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_RESEARCHSTUDY}
{$IFDEF FHIR_RESEARCHSUBJECT}
function TFHIRTurtleParser.ParseResearchSubject(obj : TTurtleComplex) : TFhirResearchSubject;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirResearchSubject.create;
  try
    ParseResearchSubjectProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseResearchSubjectProperties(obj : TTurtleComplex; result : TFhirResearchSubject);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/ResearchSubject.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/ResearchSubject.status'), CODES_TFhirResearchSubjectStatusEnum, SYSTEMS_TFhirResearchSubjectStatusEnum);
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/ResearchSubject.period'));{q3b}
    result.study := ParseReference{TFhirResearchStudy}(obj.complex('http://hl7.org/fhir/ResearchSubject.study'));{q3b}
    result.individual := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/ResearchSubject.individual'));{q3b}
    result.assignedArmElement := ParseString(obj.complex('http://hl7.org/fhir/ResearchSubject.assignedArm'));{q1}
    result.actualArmElement := ParseString(obj.complex('http://hl7.org/fhir/ResearchSubject.actualArm'));{q1}
    result.consent := ParseReference{TFhirConsent}(obj.complex('http://hl7.org/fhir/ResearchSubject.consent'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeResearchSubject(parent :  TTurtleComplex; parentType, name : String; elem : TFhirResearchSubject; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ResearchSubject'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'ResearchSubject', 'identifier', elem.identifierList[i], false, i);{x.d3}
  ComposeEnum(this, 'ResearchSubject', 'status', elem.StatusElement, CODES_TFhirResearchSubjectStatusEnum, SYSTEMS_TFhirResearchSubjectStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('period') then
    ComposePeriod(this, 'ResearchSubject', 'period', elem.periodElement, false, -1);{x.2f}
  ComposeReference{TFhirResearchStudy}(this, 'ResearchSubject', 'study', elem.studyElement, false, -1);{x.2f}
  ComposeReference{TFhirPatient}(this, 'ResearchSubject', 'individual', elem.individualElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('assignedArm') then
    ComposeString(this, 'ResearchSubject', 'assignedArm', elem.assignedArmElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('actualArm') then
    ComposeString(this, 'ResearchSubject', 'actualArm', elem.actualArmElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('consent') then
    ComposeReference{TFhirConsent}(this, 'ResearchSubject', 'consent', elem.consentElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_RESEARCHSUBJECT}
{$IFDEF FHIR_RISKASSESSMENT}
function TFHIRTurtleParser.ParseRiskAssessmentPrediction(obj : TTurtleComplex) : TFhirRiskAssessmentPrediction;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirRiskAssessmentPrediction.create;
  try
    ParseRiskAssessmentPredictionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseRiskAssessmentPredictionProperties(obj : TTurtleComplex; result : TFhirRiskAssessmentPrediction);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.outcome := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/RiskAssessment.prediction.outcome'));{q3b}
    if obj.has('http://hl7.org/fhir/RiskAssessment.prediction.probabilityRange', item) then
      result.probability := parseRange(item);
    if obj.has('http://hl7.org/fhir/RiskAssessment.prediction.probabilityDecimal', item) then
      result.probability := parseDecimal(item);
    result.qualitativeRisk := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/RiskAssessment.prediction.qualitativeRisk'));{q3b}
    result.relativeRiskElement := ParseDecimal(obj.complex('http://hl7.org/fhir/RiskAssessment.prediction.relativeRisk'));{q1}
    if obj.has('http://hl7.org/fhir/RiskAssessment.prediction.whenPeriod', item) then
      result.when := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/RiskAssessment.prediction.whenRange', item) then
      result.when := parseRange(item);
    result.rationaleElement := ParseString(obj.complex('http://hl7.org/fhir/RiskAssessment.prediction.rationale'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeRiskAssessmentPrediction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirRiskAssessmentPrediction; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:RiskAssessmentPrediction'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'RiskAssessment.prediction', 'outcome', elem.outcomeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and (elem.probability is TFhirRange) {6} then
    ComposeRange(this, 'RiskAssessment.prediction', 'probabilityRange', TFhirRange(elem.probability), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.probability is TFhirDecimal) {6} then
    ComposeDecimal(this, 'RiskAssessment.prediction', 'probabilityDecimal', TFhirDecimal(elem.probability), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'RiskAssessment.prediction', 'qualitativeRisk', elem.qualitativeRiskElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'RiskAssessment.prediction', 'relativeRisk', elem.relativeRiskElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and (elem.when is TFhirPeriod) {6} then
    ComposePeriod(this, 'RiskAssessment.prediction', 'whenPeriod', TFhirPeriod(elem.when), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.when is TFhirRange) {6} then
    ComposeRange(this, 'RiskAssessment.prediction', 'whenRange', TFhirRange(elem.when), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'RiskAssessment.prediction', 'rationale', elem.rationaleElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseRiskAssessment(obj : TTurtleComplex) : TFhirRiskAssessment;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirRiskAssessment.create;
  try
    ParseRiskAssessmentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseRiskAssessmentProperties(obj : TTurtleComplex; result : TFhirRiskAssessment);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/RiskAssessment.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.basedOn := ParseReference{TFhirReference}(obj.complex('http://hl7.org/fhir/RiskAssessment.basedOn'));{q3b}
    result.parent := ParseReference{TFhirReference}(obj.complex('http://hl7.org/fhir/RiskAssessment.parent'));{q3b}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/RiskAssessment.status'), CODES_TFhirObservationStatusEnum, SYSTEMS_TFhirObservationStatusEnum);
    result.method := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/RiskAssessment.method'));{q3b}
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/RiskAssessment.code'));{q3b}
    result.subject := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/RiskAssessment.subject'));{q3b}
    result.encounter := ParseReference{TFhirEncounter}(obj.complex('http://hl7.org/fhir/RiskAssessment.encounter'));{q3b}
    if obj.has('http://hl7.org/fhir/RiskAssessment.occurrencePeriod', item) then
      result.occurrence := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/RiskAssessment.occurrenceDateTime', item) then
      result.occurrence := parseDateTime(item);
    result.condition := ParseReference{TFhirCondition}(obj.complex('http://hl7.org/fhir/RiskAssessment.condition'));{q3b}
    result.performer := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/RiskAssessment.performer'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/RiskAssessment.reasonCode') do
      result.reasonCodeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/RiskAssessment.reasonReference') do
      result.reasonReferenceList.Add(parseReference{TFhirCondition}(item));
    for item in obj.complexes('http://hl7.org/fhir/RiskAssessment.basis') do
      result.basisList.Add(parseReference{TFhirReference}(item));
    for item in obj.complexes('http://hl7.org/fhir/RiskAssessment.prediction') do
      result.predictionList.Add(parseRiskAssessmentPrediction(item));
    result.mitigationElement := ParseString(obj.complex('http://hl7.org/fhir/RiskAssessment.mitigation'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/RiskAssessment.note') do
      result.noteList.Add(parseAnnotation(item));
end;

procedure TFHIRTurtleComposer.ComposeRiskAssessment(parent :  TTurtleComplex; parentType, name : String; elem : TFhirRiskAssessment; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:RiskAssessment'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'RiskAssessment', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('basedOn') then
    ComposeReference{TFhirReference}(this, 'RiskAssessment', 'basedOn', elem.basedOnElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('parent') then
    ComposeReference{TFhirReference}(this, 'RiskAssessment', 'parent', elem.parentElement, false, -1);{x.2f}
  ComposeEnum(this, 'RiskAssessment', 'status', elem.StatusElement, CODES_TFhirObservationStatusEnum, SYSTEMS_TFhirObservationStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('method') then
    ComposeCodeableConcept(this, 'RiskAssessment', 'method', elem.methodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') then
    ComposeCodeableConcept(this, 'RiskAssessment', 'code', elem.codeElement, false, -1);{x.2f}
  ComposeReference{TFhirPatient}(this, 'RiskAssessment', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(this, 'RiskAssessment', 'encounter', elem.encounterElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirPeriod) {6} then
    ComposePeriod(this, 'RiskAssessment', 'occurrencePeriod', TFhirPeriod(elem.occurrence), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirDateTime) {6} then
    ComposeDateTime(this, 'RiskAssessment', 'occurrenceDateTime', TFhirDateTime(elem.occurrence), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('condition') then
    ComposeReference{TFhirCondition}(this, 'RiskAssessment', 'condition', elem.conditionElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('performer') then
    ComposeReference{TFhirPractitioner}(this, 'RiskAssessment', 'performer', elem.performerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('reasonCode') then
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'RiskAssessment', 'reasonCode', elem.reasonCodeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('reasonReference') then
    for i := 0 to elem.reasonReferenceList.Count - 1 do
      ComposeReference{TFhirCondition}(this, 'RiskAssessment', 'reasonReference', elem.reasonReferenceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('basis') then
    for i := 0 to elem.basisList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'RiskAssessment', 'basis', elem.basisList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('prediction') then
    for i := 0 to elem.predictionList.Count - 1 do
      ComposeRiskAssessmentPrediction(this, 'RiskAssessment', 'prediction', elem.predictionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('mitigation') then
    ComposeString(this, 'RiskAssessment', 'mitigation', elem.mitigationElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'RiskAssessment', 'note', elem.noteList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_RISKASSESSMENT}
{$IFDEF FHIR_RISKEVIDENCESYNTHESIS}
function TFHIRTurtleParser.ParseRiskEvidenceSynthesisSampleSize(obj : TTurtleComplex) : TFhirRiskEvidenceSynthesisSampleSize;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirRiskEvidenceSynthesisSampleSize.create;
  try
    ParseRiskEvidenceSynthesisSampleSizeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseRiskEvidenceSynthesisSampleSizeProperties(obj : TTurtleComplex; result : TFhirRiskEvidenceSynthesisSampleSize);
begin
    ParseBackboneElementProperties(obj, result);
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/RiskEvidenceSynthesis.sampleSize.description'));{q1}
    result.numberOfStudiesElement := ParseInteger(obj.complex('http://hl7.org/fhir/RiskEvidenceSynthesis.sampleSize.numberOfStudies'));{q1}
    result.numberOfParticipantsElement := ParseInteger(obj.complex('http://hl7.org/fhir/RiskEvidenceSynthesis.sampleSize.numberOfParticipants'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeRiskEvidenceSynthesisSampleSize(parent :  TTurtleComplex; parentType, name : String; elem : TFhirRiskEvidenceSynthesisSampleSize; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:RiskEvidenceSynthesisSampleSize'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'RiskEvidenceSynthesis.sampleSize', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(this, 'RiskEvidenceSynthesis.sampleSize', 'numberOfStudies', elem.numberOfStudiesElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(this, 'RiskEvidenceSynthesis.sampleSize', 'numberOfParticipants', elem.numberOfParticipantsElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseRiskEvidenceSynthesisRiskEstimate(obj : TTurtleComplex) : TFhirRiskEvidenceSynthesisRiskEstimate;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirRiskEvidenceSynthesisRiskEstimate.create;
  try
    ParseRiskEvidenceSynthesisRiskEstimateProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseRiskEvidenceSynthesisRiskEstimateProperties(obj : TTurtleComplex; result : TFhirRiskEvidenceSynthesisRiskEstimate);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/RiskEvidenceSynthesis.riskEstimate.description'));{q1}
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/RiskEvidenceSynthesis.riskEstimate.type'));{q3b}
    result.valueElement := ParseDecimal(obj.complex('http://hl7.org/fhir/RiskEvidenceSynthesis.riskEstimate.value'));{q1}
    result.unitOfMeasure := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/RiskEvidenceSynthesis.riskEstimate.unitOfMeasure'));{q3b}
    result.denominatorCountElement := ParseInteger(obj.complex('http://hl7.org/fhir/RiskEvidenceSynthesis.riskEstimate.denominatorCount'));{q1}
    result.numeratorCountElement := ParseInteger(obj.complex('http://hl7.org/fhir/RiskEvidenceSynthesis.riskEstimate.numeratorCount'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/RiskEvidenceSynthesis.riskEstimate.precisionEstimate') do
      result.precisionEstimateList.Add(parseRiskEvidenceSynthesisRiskEstimatePrecisionEstimate(item));
end;

procedure TFHIRTurtleComposer.ComposeRiskEvidenceSynthesisRiskEstimate(parent :  TTurtleComplex; parentType, name : String; elem : TFhirRiskEvidenceSynthesisRiskEstimate; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:RiskEvidenceSynthesisRiskEstimate'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'RiskEvidenceSynthesis.riskEstimate', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'RiskEvidenceSynthesis.riskEstimate', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'RiskEvidenceSynthesis.riskEstimate', 'value', elem.valueElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'RiskEvidenceSynthesis.riskEstimate', 'unitOfMeasure', elem.unitOfMeasureElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(this, 'RiskEvidenceSynthesis.riskEstimate', 'denominatorCount', elem.denominatorCountElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(this, 'RiskEvidenceSynthesis.riskEstimate', 'numeratorCount', elem.numeratorCountElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.precisionEstimateList.Count - 1 do
      ComposeRiskEvidenceSynthesisRiskEstimatePrecisionEstimate(this, 'RiskEvidenceSynthesis.riskEstimate', 'precisionEstimate', elem.precisionEstimateList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseRiskEvidenceSynthesisRiskEstimatePrecisionEstimate(obj : TTurtleComplex) : TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate.create;
  try
    ParseRiskEvidenceSynthesisRiskEstimatePrecisionEstimateProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseRiskEvidenceSynthesisRiskEstimatePrecisionEstimateProperties(obj : TTurtleComplex; result : TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate);
begin
    ParseBackboneElementProperties(obj, result);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/RiskEvidenceSynthesis.riskEstimate.precisionEstimate.type'));{q3b}
    result.levelElement := ParseDecimal(obj.complex('http://hl7.org/fhir/RiskEvidenceSynthesis.riskEstimate.precisionEstimate.level'));{q1}
    result.fromElement := ParseDecimal(obj.complex('http://hl7.org/fhir/RiskEvidenceSynthesis.riskEstimate.precisionEstimate.from'));{q1}
    result.to_Element := ParseDecimal(obj.complex('http://hl7.org/fhir/RiskEvidenceSynthesis.riskEstimate.precisionEstimate.to'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeRiskEvidenceSynthesisRiskEstimatePrecisionEstimate(parent :  TTurtleComplex; parentType, name : String; elem : TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:RiskEvidenceSynthesisRiskEstimatePrecisionEstimate'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'RiskEvidenceSynthesis.riskEstimate.precisionEstimate', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'RiskEvidenceSynthesis.riskEstimate.precisionEstimate', 'level', elem.levelElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'RiskEvidenceSynthesis.riskEstimate.precisionEstimate', 'from', elem.fromElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'RiskEvidenceSynthesis.riskEstimate.precisionEstimate', 'to', elem.to_Element, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseRiskEvidenceSynthesisCertainty(obj : TTurtleComplex) : TFhirRiskEvidenceSynthesisCertainty;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirRiskEvidenceSynthesisCertainty.create;
  try
    ParseRiskEvidenceSynthesisCertaintyProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseRiskEvidenceSynthesisCertaintyProperties(obj : TTurtleComplex; result : TFhirRiskEvidenceSynthesisCertainty);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/RiskEvidenceSynthesis.certainty.rating') do
      result.ratingList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/RiskEvidenceSynthesis.certainty.note') do
      result.noteList.Add(parseAnnotation(item));
    for item in obj.complexes('http://hl7.org/fhir/RiskEvidenceSynthesis.certainty.certaintySubcomponent') do
      result.certaintySubcomponentList.Add(parseRiskEvidenceSynthesisCertaintyCertaintySubcomponent(item));
end;

procedure TFHIRTurtleComposer.ComposeRiskEvidenceSynthesisCertainty(parent :  TTurtleComplex; parentType, name : String; elem : TFhirRiskEvidenceSynthesisCertainty; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:RiskEvidenceSynthesisCertainty'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.ratingList.Count - 1 do
      ComposeCodeableConcept(this, 'RiskEvidenceSynthesis.certainty', 'rating', elem.ratingList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'RiskEvidenceSynthesis.certainty', 'note', elem.noteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.certaintySubcomponentList.Count - 1 do
      ComposeRiskEvidenceSynthesisCertaintyCertaintySubcomponent(this, 'RiskEvidenceSynthesis.certainty', 'certaintySubcomponent', elem.certaintySubcomponentList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseRiskEvidenceSynthesisCertaintyCertaintySubcomponent(obj : TTurtleComplex) : TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent.create;
  try
    ParseRiskEvidenceSynthesisCertaintyCertaintySubcomponentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseRiskEvidenceSynthesisCertaintyCertaintySubcomponentProperties(obj : TTurtleComplex; result : TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/RiskEvidenceSynthesis.certainty.certaintySubcomponent.type'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/RiskEvidenceSynthesis.certainty.certaintySubcomponent.rating') do
      result.ratingList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/RiskEvidenceSynthesis.certainty.certaintySubcomponent.note') do
      result.noteList.Add(parseAnnotation(item));
end;

procedure TFHIRTurtleComposer.ComposeRiskEvidenceSynthesisCertaintyCertaintySubcomponent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:RiskEvidenceSynthesisCertaintyCertaintySubcomponent'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'RiskEvidenceSynthesis.certainty.certaintySubcomponent', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.ratingList.Count - 1 do
      ComposeCodeableConcept(this, 'RiskEvidenceSynthesis.certainty.certaintySubcomponent', 'rating', elem.ratingList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'RiskEvidenceSynthesis.certainty.certaintySubcomponent', 'note', elem.noteList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseRiskEvidenceSynthesis(obj : TTurtleComplex) : TFhirRiskEvidenceSynthesis;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirRiskEvidenceSynthesis.create;
  try
    ParseRiskEvidenceSynthesisProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseRiskEvidenceSynthesisProperties(obj : TTurtleComplex; result : TFhirRiskEvidenceSynthesis);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/RiskEvidenceSynthesis.url'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/RiskEvidenceSynthesis.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/RiskEvidenceSynthesis.version'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/RiskEvidenceSynthesis.name'));{q1}
    result.titleElement := ParseString(obj.complex('http://hl7.org/fhir/RiskEvidenceSynthesis.title'));{q1}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/RiskEvidenceSynthesis.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/RiskEvidenceSynthesis.date'));{q1}
    result.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/RiskEvidenceSynthesis.publisher'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/RiskEvidenceSynthesis.contact') do
      result.contactList.Add(parseContactDetail(item));
    result.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/RiskEvidenceSynthesis.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/RiskEvidenceSynthesis.note') do
      result.noteList.Add(parseAnnotation(item));
    for item in obj.complexes('http://hl7.org/fhir/RiskEvidenceSynthesis.useContext') do
      result.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/RiskEvidenceSynthesis.jurisdiction') do
      result.jurisdictionList.Add(parseCodeableConcept(item));
    result.copyrightElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/RiskEvidenceSynthesis.copyright'));{q1}
    result.approvalDateElement := ParseDate(obj.complex('http://hl7.org/fhir/RiskEvidenceSynthesis.approvalDate'));{q1}
    result.lastReviewDateElement := ParseDate(obj.complex('http://hl7.org/fhir/RiskEvidenceSynthesis.lastReviewDate'));{q1}
    result.effectivePeriod := ParsePeriod(obj.complex('http://hl7.org/fhir/RiskEvidenceSynthesis.effectivePeriod'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/RiskEvidenceSynthesis.topic') do
      result.topicList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/RiskEvidenceSynthesis.author') do
      result.authorList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/RiskEvidenceSynthesis.editor') do
      result.editorList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/RiskEvidenceSynthesis.reviewer') do
      result.reviewerList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/RiskEvidenceSynthesis.endorser') do
      result.endorserList.Add(parseContactDetail(item));
    for item in obj.complexes('http://hl7.org/fhir/RiskEvidenceSynthesis.relatedArtifact') do
      result.relatedArtifactList.Add(parseRelatedArtifact(item));
    result.synthesisType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/RiskEvidenceSynthesis.synthesisType'));{q3b}
    result.studyType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/RiskEvidenceSynthesis.studyType'));{q3b}
    result.population := ParseReference{TFhirEvidenceVariable}(obj.complex('http://hl7.org/fhir/RiskEvidenceSynthesis.population'));{q3b}
    result.exposure := ParseReference{TFhirEvidenceVariable}(obj.complex('http://hl7.org/fhir/RiskEvidenceSynthesis.exposure'));{q3b}
    result.outcome := ParseReference{TFhirEvidenceVariable}(obj.complex('http://hl7.org/fhir/RiskEvidenceSynthesis.outcome'));{q3b}
    result.sampleSize := ParseRiskEvidenceSynthesisSampleSize(obj.complex('http://hl7.org/fhir/RiskEvidenceSynthesis.sampleSize'));{q3b}
    result.riskEstimate := ParseRiskEvidenceSynthesisRiskEstimate(obj.complex('http://hl7.org/fhir/RiskEvidenceSynthesis.riskEstimate'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/RiskEvidenceSynthesis.certainty') do
      result.certaintyList.Add(parseRiskEvidenceSynthesisCertainty(item));
end;

procedure TFHIRTurtleComposer.ComposeRiskEvidenceSynthesis(parent :  TTurtleComplex; parentType, name : String; elem : TFhirRiskEvidenceSynthesis; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:RiskEvidenceSynthesis'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUri(this, 'RiskEvidenceSynthesis', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'RiskEvidenceSynthesis', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(this, 'RiskEvidenceSynthesis', 'version', elem.versionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(this, 'RiskEvidenceSynthesis', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeString(this, 'RiskEvidenceSynthesis', 'title', elem.titleElement, false, -1);{x.2ea}
  ComposeEnum(this, 'RiskEvidenceSynthesis', 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(this, 'RiskEvidenceSynthesis', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(this, 'RiskEvidenceSynthesis', 'publisher', elem.publisherElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(this, 'RiskEvidenceSynthesis', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeMarkdown(this, 'RiskEvidenceSynthesis', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'RiskEvidenceSynthesis', 'note', elem.noteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(this, 'RiskEvidenceSynthesis', 'useContext', elem.useContextList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'RiskEvidenceSynthesis', 'jurisdiction', elem.jurisdictionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdown(this, 'RiskEvidenceSynthesis', 'copyright', elem.copyrightElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('approvalDate') then
    ComposeDate(this, 'RiskEvidenceSynthesis', 'approvalDate', elem.approvalDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('lastReviewDate') then
    ComposeDate(this, 'RiskEvidenceSynthesis', 'lastReviewDate', elem.lastReviewDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('effectivePeriod') then
    ComposePeriod(this, 'RiskEvidenceSynthesis', 'effectivePeriod', elem.effectivePeriodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('topic') then
    for i := 0 to elem.topicList.Count - 1 do
      ComposeCodeableConcept(this, 'RiskEvidenceSynthesis', 'topic', elem.topicList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('author') then
    for i := 0 to elem.authorList.Count - 1 do
      ComposeContactDetail(this, 'RiskEvidenceSynthesis', 'author', elem.authorList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('editor') then
    for i := 0 to elem.editorList.Count - 1 do
      ComposeContactDetail(this, 'RiskEvidenceSynthesis', 'editor', elem.editorList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('reviewer') then
    for i := 0 to elem.reviewerList.Count - 1 do
      ComposeContactDetail(this, 'RiskEvidenceSynthesis', 'reviewer', elem.reviewerList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('endorser') then
    for i := 0 to elem.endorserList.Count - 1 do
      ComposeContactDetail(this, 'RiskEvidenceSynthesis', 'endorser', elem.endorserList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('relatedArtifact') then
    for i := 0 to elem.relatedArtifactList.Count - 1 do
      ComposeRelatedArtifact(this, 'RiskEvidenceSynthesis', 'relatedArtifact', elem.relatedArtifactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('synthesisType') then
    ComposeCodeableConcept(this, 'RiskEvidenceSynthesis', 'synthesisType', elem.synthesisTypeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('studyType') then
    ComposeCodeableConcept(this, 'RiskEvidenceSynthesis', 'studyType', elem.studyTypeElement, false, -1);{x.2f}
  ComposeReference{TFhirEvidenceVariable}(this, 'RiskEvidenceSynthesis', 'population', elem.populationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('exposure') then
    ComposeReference{TFhirEvidenceVariable}(this, 'RiskEvidenceSynthesis', 'exposure', elem.exposureElement, false, -1);{x.2f}
  ComposeReference{TFhirEvidenceVariable}(this, 'RiskEvidenceSynthesis', 'outcome', elem.outcomeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('sampleSize') then
    ComposeRiskEvidenceSynthesisSampleSize(this, 'RiskEvidenceSynthesis', 'sampleSize', elem.sampleSizeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('riskEstimate') then
    ComposeRiskEvidenceSynthesisRiskEstimate(this, 'RiskEvidenceSynthesis', 'riskEstimate', elem.riskEstimateElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('certainty') then
    for i := 0 to elem.certaintyList.Count - 1 do
      ComposeRiskEvidenceSynthesisCertainty(this, 'RiskEvidenceSynthesis', 'certainty', elem.certaintyList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_RISKEVIDENCESYNTHESIS}
{$IFDEF FHIR_SCHEDULE}
function TFHIRTurtleParser.ParseSchedule(obj : TTurtleComplex) : TFhirSchedule;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSchedule.create;
  try
    ParseScheduleProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseScheduleProperties(obj : TTurtleComplex; result : TFhirSchedule);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Schedule.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.activeElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Schedule.active'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Schedule.serviceCategory') do
      result.serviceCategoryList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Schedule.serviceType') do
      result.serviceTypeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Schedule.specialty') do
      result.specialtyList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Schedule.actor') do
      result.actorList.Add(parseReference{TFhirPatient}(item));
    result.planningHorizon := ParsePeriod(obj.complex('http://hl7.org/fhir/Schedule.planningHorizon'));{q3b}
    result.commentElement := ParseString(obj.complex('http://hl7.org/fhir/Schedule.comment'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeSchedule(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSchedule; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Schedule'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Schedule', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('active') then
    ComposeBoolean(this, 'Schedule', 'active', elem.activeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('serviceCategory') then
    for i := 0 to elem.serviceCategoryList.Count - 1 do
      ComposeCodeableConcept(this, 'Schedule', 'serviceCategory', elem.serviceCategoryList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('serviceType') then
    for i := 0 to elem.serviceTypeList.Count - 1 do
      ComposeCodeableConcept(this, 'Schedule', 'serviceType', elem.serviceTypeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('specialty') then
    for i := 0 to elem.specialtyList.Count - 1 do
      ComposeCodeableConcept(this, 'Schedule', 'specialty', elem.specialtyList[i], false, i);{x.d3}
  for i := 0 to elem.actorList.Count - 1 do
      ComposeReference{TFhirPatient}(this, 'Schedule', 'actor', elem.actorList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('planningHorizon') then
    ComposePeriod(this, 'Schedule', 'planningHorizon', elem.planningHorizonElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('comment') then
    ComposeString(this, 'Schedule', 'comment', elem.commentElement, false, -1);{x.2ea}
end;

{$ENDIF FHIR_SCHEDULE}
{$IFDEF FHIR_SEARCHPARAMETER}
function TFHIRTurtleParser.ParseSearchParameterComponent(obj : TTurtleComplex) : TFhirSearchParameterComponent;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSearchParameterComponent.create;
  try
    ParseSearchParameterComponentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSearchParameterComponentProperties(obj : TTurtleComplex; result : TFhirSearchParameterComponent);
begin
    ParseBackboneElementProperties(obj, result);
    result.definitionElement := ParseCanonical(obj.complex('http://hl7.org/fhir/SearchParameter.component.definition'));{q1}
    result.expressionElement := ParseString(obj.complex('http://hl7.org/fhir/SearchParameter.component.expression'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeSearchParameterComponent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSearchParameterComponent; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SearchParameterComponent'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCanonical(this, 'SearchParameter.component', 'definition', elem.definitionElement, false, -1);{x.2ea}
  ComposeString(this, 'SearchParameter.component', 'expression', elem.expressionElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseSearchParameter(obj : TTurtleComplex) : TFhirSearchParameter;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSearchParameter.create;
  try
    ParseSearchParameterProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSearchParameterProperties(obj : TTurtleComplex; result : TFhirSearchParameter);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/SearchParameter.url'));{q1}
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/SearchParameter.version'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/SearchParameter.name'));{q1}
    result.derivedFromElement := ParseCanonical(obj.complex('http://hl7.org/fhir/SearchParameter.derivedFrom'));{q1}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/SearchParameter.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    result.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/SearchParameter.experimental'));{q1}
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/SearchParameter.date'));{q1}
    result.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/SearchParameter.publisher'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/SearchParameter.contact') do
      result.contactList.Add(parseContactDetail(item));
    result.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/SearchParameter.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/SearchParameter.useContext') do
      result.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/SearchParameter.jurisdiction') do
      result.jurisdictionList.Add(parseCodeableConcept(item));
    result.purposeElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/SearchParameter.purpose'));{q1}
    result.codeElement := ParseCode(obj.complex('http://hl7.org/fhir/SearchParameter.code'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/SearchParameter.base') do
      result.base.Add(parseEnum(item, CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum));
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/SearchParameter.type'), CODES_TFhirSearchParamTypeEnum, SYSTEMS_TFhirSearchParamTypeEnum);
    result.expressionElement := ParseString(obj.complex('http://hl7.org/fhir/SearchParameter.expression'));{q1}
    result.xpathElement := ParseString(obj.complex('http://hl7.org/fhir/SearchParameter.xpath'));{q1}
    result.xpathUsageElement := ParseEnum(obj.complex('http://hl7.org/fhir/SearchParameter.xpathUsage'), CODES_TFhirSearchXpathUsageEnum, SYSTEMS_TFhirSearchXpathUsageEnum);
    for item in obj.complexes('http://hl7.org/fhir/SearchParameter.target') do
      result.target.Add(parseEnum(item, CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum));
    result.multipleOrElement := ParseBoolean(obj.complex('http://hl7.org/fhir/SearchParameter.multipleOr'));{q1}
    result.multipleAndElement := ParseBoolean(obj.complex('http://hl7.org/fhir/SearchParameter.multipleAnd'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/SearchParameter.comparator') do
      result.comparatorList.Add(parseEnum(item, CODES_TFhirSearchComparatorEnum, SYSTEMS_TFhirSearchComparatorEnum));
    for item in obj.complexes('http://hl7.org/fhir/SearchParameter.modifier') do
      result.modifierList.Add(parseEnum(item, CODES_TFhirSearchModifierCodeEnum, SYSTEMS_TFhirSearchModifierCodeEnum));
    for item in obj.complexes('http://hl7.org/fhir/SearchParameter.chain') do
      result.chainList.Add(parseString(item));
    for item in obj.complexes('http://hl7.org/fhir/SearchParameter.component') do
      result.componentList.Add(parseSearchParameterComponent(item));
end;

procedure TFHIRTurtleComposer.ComposeSearchParameter(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSearchParameter; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SearchParameter'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  ComposeUri(this, 'SearchParameter', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(this, 'SearchParameter', 'version', elem.versionElement, false, -1);{x.2ea}
  ComposeString(this, 'SearchParameter', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('derivedFrom') then
    ComposeCanonical(this, 'SearchParameter', 'derivedFrom', elem.derivedFromElement, false, -1);{x.2ea}
  ComposeEnum(this, 'SearchParameter', 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(this, 'SearchParameter', 'experimental', elem.experimentalElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(this, 'SearchParameter', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(this, 'SearchParameter', 'publisher', elem.publisherElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(this, 'SearchParameter', 'contact', elem.contactList[i], false, i);{x.d3}
  ComposeMarkdown(this, 'SearchParameter', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(this, 'SearchParameter', 'useContext', elem.useContextList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'SearchParameter', 'jurisdiction', elem.jurisdictionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdown(this, 'SearchParameter', 'purpose', elem.purposeElement, false, -1);{x.2ea}
  ComposeCode(this, 'SearchParameter', 'code', elem.codeElement, false, -1);{x.2ea}
  for i := 0 to elem.base.Count - 1 do
      ComposeEnum(this, 'SearchParameter', 'base', elem.base[i], CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, false, i); {x.d1}
  for i := 0 to elem.base.Count - 1 do
      ComposeEnum(this, 'SearchParameter', 'base', elem.base[i], CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, false, i);{x.d2}
  ComposeEnum(this, 'SearchParameter', 'type', elem.Type_Element, CODES_TFhirSearchParamTypeEnum, SYSTEMS_TFhirSearchParamTypeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('expression') then
    ComposeString(this, 'SearchParameter', 'expression', elem.expressionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('xpath') then
    ComposeString(this, 'SearchParameter', 'xpath', elem.xpathElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('xpathUsage') then
    ComposeEnum(this, 'SearchParameter', 'xpathUsage', elem.XpathUsageElement, CODES_TFhirSearchXpathUsageEnum, SYSTEMS_TFhirSearchXpathUsageEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('target') then
    for i := 0 to elem.target.Count - 1 do
      ComposeEnum(this, 'SearchParameter', 'target', elem.target[i], CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, false, i); {x.d1}
  if (SummaryOption in [soFull, soData]) and doCompose('target') then
    for i := 0 to elem.target.Count - 1 do
      ComposeEnum(this, 'SearchParameter', 'target', elem.target[i], CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, false, i);{x.d2}
  if (SummaryOption in [soFull, soData]) and doCompose('multipleOr') then
    ComposeBoolean(this, 'SearchParameter', 'multipleOr', elem.multipleOrElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('multipleAnd') then
    ComposeBoolean(this, 'SearchParameter', 'multipleAnd', elem.multipleAndElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('comparator') then
    for i := 0 to elem.comparatorList.Count - 1 do
      ComposeEnum(this, 'SearchParameter', 'comparator', elem.comparatorList[i], CODES_TFhirSearchComparatorEnum, SYSTEMS_TFhirSearchComparatorEnum, false, i); {x.d1}
  if (SummaryOption in [soFull, soData]) and doCompose('comparator') then
    for i := 0 to elem.comparatorList.Count - 1 do
      ComposeEnum(this, 'SearchParameter', 'comparator', elem.comparatorList[i], CODES_TFhirSearchComparatorEnum, SYSTEMS_TFhirSearchComparatorEnum, false, i);{x.d2}
  if (SummaryOption in [soFull, soData]) and doCompose('modifier') then
    for i := 0 to elem.modifierList.Count - 1 do
      ComposeEnum(this, 'SearchParameter', 'modifier', elem.modifierList[i], CODES_TFhirSearchModifierCodeEnum, SYSTEMS_TFhirSearchModifierCodeEnum, false, i); {x.d1}
  if (SummaryOption in [soFull, soData]) and doCompose('modifier') then
    for i := 0 to elem.modifierList.Count - 1 do
      ComposeEnum(this, 'SearchParameter', 'modifier', elem.modifierList[i], CODES_TFhirSearchModifierCodeEnum, SYSTEMS_TFhirSearchModifierCodeEnum, false, i);{x.d2}
  if (SummaryOption in [soFull, soData]) and doCompose('chain') then
    for i := 0 to elem.chainList.Count - 1 do
      ComposeString(this, 'SearchParameter', 'chain', elem.chainList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('component') then
    for i := 0 to elem.componentList.Count - 1 do
      ComposeSearchParameterComponent(this, 'SearchParameter', 'component', elem.componentList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_SEARCHPARAMETER}
{$IFDEF FHIR_SERVICEREQUEST}
function TFHIRTurtleParser.ParseServiceRequest(obj : TTurtleComplex) : TFhirServiceRequest;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirServiceRequest.create;
  try
    ParseServiceRequestProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseServiceRequestProperties(obj : TTurtleComplex; result : TFhirServiceRequest);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/ServiceRequest.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/ServiceRequest.instantiatesCanonical') do
      result.instantiatesCanonicalList.Add(parseCanonical(item));
    for item in obj.complexes('http://hl7.org/fhir/ServiceRequest.instantiatesUri') do
      result.instantiatesUriList.Add(parseUri(item));
    for item in obj.complexes('http://hl7.org/fhir/ServiceRequest.basedOn') do
      result.basedOnList.Add(parseReference{TFhirCarePlan}(item));
    for item in obj.complexes('http://hl7.org/fhir/ServiceRequest.replaces') do
      result.replacesList.Add(parseReference{TFhirServiceRequest}(item));
    result.requisition := ParseIdentifier(obj.complex('http://hl7.org/fhir/ServiceRequest.requisition'));{q3b}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/ServiceRequest.status'), CODES_TFhirRequestStatusEnum, SYSTEMS_TFhirRequestStatusEnum);
    result.intentElement := ParseEnum(obj.complex('http://hl7.org/fhir/ServiceRequest.intent'), CODES_TFhirRequestIntentEnum, SYSTEMS_TFhirRequestIntentEnum);
    for item in obj.complexes('http://hl7.org/fhir/ServiceRequest.category') do
      result.categoryList.Add(parseCodeableConcept(item));
    result.priorityElement := ParseEnum(obj.complex('http://hl7.org/fhir/ServiceRequest.priority'), CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum);
    result.doNotPerformElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ServiceRequest.doNotPerform'));{q1}
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ServiceRequest.code'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ServiceRequest.orderDetail') do
      result.orderDetailList.Add(parseCodeableConcept(item));
    if obj.has('http://hl7.org/fhir/ServiceRequest.quantityQuantity', item) then
      result.quantity := parseQuantity(item);
    if obj.has('http://hl7.org/fhir/ServiceRequest.quantityRatio', item) then
      result.quantity := parseRatio(item);
    if obj.has('http://hl7.org/fhir/ServiceRequest.quantityRange', item) then
      result.quantity := parseRange(item);
    result.subject := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/ServiceRequest.subject'));{q3b}
    result.encounter := ParseReference{TFhirEncounter}(obj.complex('http://hl7.org/fhir/ServiceRequest.encounter'));{q3b}
    if obj.has('http://hl7.org/fhir/ServiceRequest.occurrencePeriod', item) then
      result.occurrence := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/ServiceRequest.occurrenceTiming', item) then
      result.occurrence := parseTiming(item);
    if obj.has('http://hl7.org/fhir/ServiceRequest.occurrenceDateTime', item) then
      result.occurrence := parseDateTime(item);
    if obj.has('http://hl7.org/fhir/ServiceRequest.asNeededCodeableConcept', item) then
      result.asNeeded := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/ServiceRequest.asNeededBoolean', item) then
      result.asNeeded := parseBoolean(item);
    result.authoredOnElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ServiceRequest.authoredOn'));{q1}
    result.requester := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/ServiceRequest.requester'));{q3b}
    result.performerType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/ServiceRequest.performerType'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/ServiceRequest.performer') do
      result.performerList.Add(parseReference{TFhirPractitioner}(item));
    for item in obj.complexes('http://hl7.org/fhir/ServiceRequest.locationCode') do
      result.locationCodeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/ServiceRequest.locationReference') do
      result.locationReferenceList.Add(parseReference{TFhirLocation}(item));
    for item in obj.complexes('http://hl7.org/fhir/ServiceRequest.reasonCode') do
      result.reasonCodeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/ServiceRequest.reasonReference') do
      result.reasonReferenceList.Add(parseReference{TFhirCondition}(item));
    for item in obj.complexes('http://hl7.org/fhir/ServiceRequest.insurance') do
      result.insuranceList.Add(parseReference{TFhirCoverage}(item));
    for item in obj.complexes('http://hl7.org/fhir/ServiceRequest.supportingInfo') do
      result.supportingInfoList.Add(parseReference{TFhirReference}(item));
    for item in obj.complexes('http://hl7.org/fhir/ServiceRequest.specimen') do
      result.specimenList.Add(parseReference{TFhirSpecimen}(item));
    for item in obj.complexes('http://hl7.org/fhir/ServiceRequest.bodySite') do
      result.bodySiteList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/ServiceRequest.note') do
      result.noteList.Add(parseAnnotation(item));
    result.patientInstructionElement := ParseString(obj.complex('http://hl7.org/fhir/ServiceRequest.patientInstruction'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ServiceRequest.relevantHistory') do
      result.relevantHistoryList.Add(parseReference{TFhirProvenance}(item));
end;

procedure TFHIRTurtleComposer.ComposeServiceRequest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirServiceRequest; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ServiceRequest'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'ServiceRequest', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('instantiatesCanonical') then
    for i := 0 to elem.instantiatesCanonicalList.Count - 1 do
      ComposeCanonical(this, 'ServiceRequest', 'instantiatesCanonical', elem.instantiatesCanonicalList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('instantiatesUri') then
    for i := 0 to elem.instantiatesUriList.Count - 1 do
      ComposeUri(this, 'ServiceRequest', 'instantiatesUri', elem.instantiatesUriList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('basedOn') then
    for i := 0 to elem.basedOnList.Count - 1 do
      ComposeReference{TFhirCarePlan}(this, 'ServiceRequest', 'basedOn', elem.basedOnList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('replaces') then
    for i := 0 to elem.replacesList.Count - 1 do
      ComposeReference{TFhirServiceRequest}(this, 'ServiceRequest', 'replaces', elem.replacesList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requisition') then
    ComposeIdentifier(this, 'ServiceRequest', 'requisition', elem.requisitionElement, false, -1);{x.2f}
  ComposeEnum(this, 'ServiceRequest', 'status', elem.StatusElement, CODES_TFhirRequestStatusEnum, SYSTEMS_TFhirRequestStatusEnum, false, -1);{x.d4}
  ComposeEnum(this, 'ServiceRequest', 'intent', elem.IntentElement, CODES_TFhirRequestIntentEnum, SYSTEMS_TFhirRequestIntentEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(this, 'ServiceRequest', 'category', elem.categoryList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('priority') then
    ComposeEnum(this, 'ServiceRequest', 'priority', elem.PriorityElement, CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('doNotPerform') then
    ComposeBoolean(this, 'ServiceRequest', 'doNotPerform', elem.doNotPerformElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') then
    ComposeCodeableConcept(this, 'ServiceRequest', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('orderDetail') then
    for i := 0 to elem.orderDetailList.Count - 1 do
      ComposeCodeableConcept(this, 'ServiceRequest', 'orderDetail', elem.orderDetailList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.quantity is TFhirQuantity) {6} then
    ComposeQuantity(this, 'ServiceRequest', 'quantityQuantity', TFhirQuantity(elem.quantity), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.quantity is TFhirRatio) {6} then
    ComposeRatio(this, 'ServiceRequest', 'quantityRatio', TFhirRatio(elem.quantity), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.quantity is TFhirRange) {6} then
    ComposeRange(this, 'ServiceRequest', 'quantityRange', TFhirRange(elem.quantity), false, -1);{x.d9}
  ComposeReference{TFhirPatient}(this, 'ServiceRequest', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(this, 'ServiceRequest', 'encounter', elem.encounterElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirPeriod) {6} then
    ComposePeriod(this, 'ServiceRequest', 'occurrencePeriod', TFhirPeriod(elem.occurrence), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirTiming) {6} then
    ComposeTiming(this, 'ServiceRequest', 'occurrenceTiming', TFhirTiming(elem.occurrence), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirDateTime) {6} then
    ComposeDateTime(this, 'ServiceRequest', 'occurrenceDateTime', TFhirDateTime(elem.occurrence), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.asNeeded is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'ServiceRequest', 'asNeededCodeableConcept', TFhirCodeableConcept(elem.asNeeded), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.asNeeded is TFhirBoolean) {6} then
    ComposeBoolean(this, 'ServiceRequest', 'asNeededBoolean', TFhirBoolean(elem.asNeeded), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('authoredOn') then
    ComposeDateTime(this, 'ServiceRequest', 'authoredOn', elem.authoredOnElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requester') then
    ComposeReference{TFhirPractitioner}(this, 'ServiceRequest', 'requester', elem.requesterElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('performerType') then
    ComposeCodeableConcept(this, 'ServiceRequest', 'performerType', elem.performerTypeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('performer') then
    for i := 0 to elem.performerList.Count - 1 do
      ComposeReference{TFhirPractitioner}(this, 'ServiceRequest', 'performer', elem.performerList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('locationCode') then
    for i := 0 to elem.locationCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'ServiceRequest', 'locationCode', elem.locationCodeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('locationReference') then
    for i := 0 to elem.locationReferenceList.Count - 1 do
      ComposeReference{TFhirLocation}(this, 'ServiceRequest', 'locationReference', elem.locationReferenceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonCode') then
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'ServiceRequest', 'reasonCode', elem.reasonCodeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonReference') then
    for i := 0 to elem.reasonReferenceList.Count - 1 do
      ComposeReference{TFhirCondition}(this, 'ServiceRequest', 'reasonReference', elem.reasonReferenceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('insurance') then
    for i := 0 to elem.insuranceList.Count - 1 do
      ComposeReference{TFhirCoverage}(this, 'ServiceRequest', 'insurance', elem.insuranceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('supportingInfo') then
    for i := 0 to elem.supportingInfoList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'ServiceRequest', 'supportingInfo', elem.supportingInfoList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('specimen') then
    for i := 0 to elem.specimenList.Count - 1 do
      ComposeReference{TFhirSpecimen}(this, 'ServiceRequest', 'specimen', elem.specimenList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('bodySite') then
    for i := 0 to elem.bodySiteList.Count - 1 do
      ComposeCodeableConcept(this, 'ServiceRequest', 'bodySite', elem.bodySiteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'ServiceRequest', 'note', elem.noteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('patientInstruction') then
    ComposeString(this, 'ServiceRequest', 'patientInstruction', elem.patientInstructionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('relevantHistory') then
    for i := 0 to elem.relevantHistoryList.Count - 1 do
      ComposeReference{TFhirProvenance}(this, 'ServiceRequest', 'relevantHistory', elem.relevantHistoryList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_SERVICEREQUEST}
{$IFDEF FHIR_SLOT}
function TFHIRTurtleParser.ParseSlot(obj : TTurtleComplex) : TFhirSlot;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSlot.create;
  try
    ParseSlotProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSlotProperties(obj : TTurtleComplex; result : TFhirSlot);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Slot.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/Slot.serviceCategory') do
      result.serviceCategoryList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Slot.serviceType') do
      result.serviceTypeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Slot.specialty') do
      result.specialtyList.Add(parseCodeableConcept(item));
    result.appointmentType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Slot.appointmentType'));{q3b}
    result.schedule := ParseReference{TFhirSchedule}(obj.complex('http://hl7.org/fhir/Slot.schedule'));{q3b}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Slot.status'), CODES_TFhirSlotstatusEnum, SYSTEMS_TFhirSlotstatusEnum);
    result.startElement := ParseInstant(obj.complex('http://hl7.org/fhir/Slot.start'));{q1}
    result.end_Element := ParseInstant(obj.complex('http://hl7.org/fhir/Slot.end'));{q1}
    result.overbookedElement := ParseBoolean(obj.complex('http://hl7.org/fhir/Slot.overbooked'));{q1}
    result.commentElement := ParseString(obj.complex('http://hl7.org/fhir/Slot.comment'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeSlot(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSlot; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Slot'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Slot', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('serviceCategory') then
    for i := 0 to elem.serviceCategoryList.Count - 1 do
      ComposeCodeableConcept(this, 'Slot', 'serviceCategory', elem.serviceCategoryList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('serviceType') then
    for i := 0 to elem.serviceTypeList.Count - 1 do
      ComposeCodeableConcept(this, 'Slot', 'serviceType', elem.serviceTypeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('specialty') then
    for i := 0 to elem.specialtyList.Count - 1 do
      ComposeCodeableConcept(this, 'Slot', 'specialty', elem.specialtyList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('appointmentType') then
    ComposeCodeableConcept(this, 'Slot', 'appointmentType', elem.appointmentTypeElement, false, -1);{x.2f}
  ComposeReference{TFhirSchedule}(this, 'Slot', 'schedule', elem.scheduleElement, false, -1);{x.2f}
  ComposeEnum(this, 'Slot', 'status', elem.StatusElement, CODES_TFhirSlotstatusEnum, SYSTEMS_TFhirSlotstatusEnum, false, -1);{x.d4}
  ComposeInstant(this, 'Slot', 'start', elem.startElement, false, -1);{x.2ea}
  ComposeInstant(this, 'Slot', 'end', elem.end_Element, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('overbooked') then
    ComposeBoolean(this, 'Slot', 'overbooked', elem.overbookedElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('comment') then
    ComposeString(this, 'Slot', 'comment', elem.commentElement, false, -1);{x.2ea}
end;

{$ENDIF FHIR_SLOT}
{$IFDEF FHIR_SPECIMEN}
function TFHIRTurtleParser.ParseSpecimenCollection(obj : TTurtleComplex) : TFhirSpecimenCollection;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSpecimenCollection.create;
  try
    ParseSpecimenCollectionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSpecimenCollectionProperties(obj : TTurtleComplex; result : TFhirSpecimenCollection);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.collector := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/Specimen.collection.collector'));{q3b}
    if obj.has('http://hl7.org/fhir/Specimen.collection.collectedPeriod', item) then
      result.collected := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/Specimen.collection.collectedDateTime', item) then
      result.collected := parseDateTime(item);
    result.duration := ParseDuration(obj.complex('http://hl7.org/fhir/Specimen.collection.duration'));{q3b}
    result.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/Specimen.collection.quantity'));{q3b}
    result.method := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Specimen.collection.method'));{q3b}
    result.bodySite := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Specimen.collection.bodySite'));{q3b}
    if obj.has('http://hl7.org/fhir/Specimen.collection.fastingStatusCodeableConcept', item) then
      result.fastingStatus := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/Specimen.collection.fastingStatusDuration', item) then
      result.fastingStatus := parseDuration(item);
end;

procedure TFHIRTurtleComposer.ComposeSpecimenCollection(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSpecimenCollection; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SpecimenCollection'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(this, 'Specimen.collection', 'collector', elem.collectorElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.collected is TFhirPeriod) {6} then
    ComposePeriod(this, 'Specimen.collection', 'collectedPeriod', TFhirPeriod(elem.collected), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.collected is TFhirDateTime) {6} then
    ComposeDateTime(this, 'Specimen.collection', 'collectedDateTime', TFhirDateTime(elem.collected), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDuration(this, 'Specimen.collection', 'duration', elem.durationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'Specimen.collection', 'quantity', elem.quantityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Specimen.collection', 'method', elem.methodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Specimen.collection', 'bodySite', elem.bodySiteElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.fastingStatus is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Specimen.collection', 'fastingStatusCodeableConcept', TFhirCodeableConcept(elem.fastingStatus), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.fastingStatus is TFhirDuration) {6} then
    ComposeDuration(this, 'Specimen.collection', 'fastingStatusDuration', TFhirDuration(elem.fastingStatus), false, -1);{x.d9}
end;

function TFHIRTurtleParser.ParseSpecimenProcessing(obj : TTurtleComplex) : TFhirSpecimenProcessing;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSpecimenProcessing.create;
  try
    ParseSpecimenProcessingProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSpecimenProcessingProperties(obj : TTurtleComplex; result : TFhirSpecimenProcessing);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/Specimen.processing.description'));{q1}
    result.procedure_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Specimen.processing.procedure'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Specimen.processing.additive') do
      result.additiveList.Add(parseReference{TFhirSubstance}(item));
    if obj.has('http://hl7.org/fhir/Specimen.processing.timePeriod', item) then
      result.time := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/Specimen.processing.timeDateTime', item) then
      result.time := parseDateTime(item);
end;

procedure TFHIRTurtleComposer.ComposeSpecimenProcessing(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSpecimenProcessing; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SpecimenProcessing'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Specimen.processing', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Specimen.processing', 'procedure', elem.procedure_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.additiveList.Count - 1 do
      ComposeReference{TFhirSubstance}(this, 'Specimen.processing', 'additive', elem.additiveList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and (elem.time is TFhirPeriod) {6} then
    ComposePeriod(this, 'Specimen.processing', 'timePeriod', TFhirPeriod(elem.time), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.time is TFhirDateTime) {6} then
    ComposeDateTime(this, 'Specimen.processing', 'timeDateTime', TFhirDateTime(elem.time), false, -1);{x.d9}
end;

function TFHIRTurtleParser.ParseSpecimenContainer(obj : TTurtleComplex) : TFhirSpecimenContainer;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSpecimenContainer.create;
  try
    ParseSpecimenContainerProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSpecimenContainerProperties(obj : TTurtleComplex; result : TFhirSpecimenContainer);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Specimen.container.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/Specimen.container.description'));{q1}
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Specimen.container.type'));{q3b}
    result.capacity := ParseQuantity(obj.complex('http://hl7.org/fhir/Specimen.container.capacity'));{q3b}
    result.specimenQuantity := ParseQuantity(obj.complex('http://hl7.org/fhir/Specimen.container.specimenQuantity'));{q3b}
    if obj.has('http://hl7.org/fhir/Specimen.container.additiveCodeableConcept', item) then
      result.additive := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/Specimen.container.additiveReference', item) {a3} then
      result.additive := ParseReference(item);
end;

procedure TFHIRTurtleComposer.ComposeSpecimenContainer(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSpecimenContainer; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SpecimenContainer'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Specimen.container', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'Specimen.container', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'Specimen.container', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'Specimen.container', 'capacity', elem.capacityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'Specimen.container', 'specimenQuantity', elem.specimenQuantityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and (elem.additive is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Specimen.container', 'additiveCodeableConcept', TFhirCodeableConcept(elem.additive), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.additive is TFhirReference) {2} then
    ComposeReference(this, 'Specimen.container', 'additiveReference', TFhirReference(elem.additive), false,-1);{x.d8}
end;

function TFHIRTurtleParser.ParseSpecimen(obj : TTurtleComplex) : TFhirSpecimen;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSpecimen.create;
  try
    ParseSpecimenProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSpecimenProperties(obj : TTurtleComplex; result : TFhirSpecimen);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Specimen.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.accessionIdentifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/Specimen.accessionIdentifier'));{q3b}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Specimen.status'), CODES_TFhirSpecimenStatusEnum, SYSTEMS_TFhirSpecimenStatusEnum);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Specimen.type'));{q3b}
    result.subject := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/Specimen.subject'));{q3b}
    result.receivedTimeElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Specimen.receivedTime'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Specimen.parent') do
      result.parentList.Add(parseReference{TFhirSpecimen}(item));
    for item in obj.complexes('http://hl7.org/fhir/Specimen.request') do
      result.requestList.Add(parseReference{TFhirServiceRequest}(item));
    result.collection := ParseSpecimenCollection(obj.complex('http://hl7.org/fhir/Specimen.collection'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Specimen.processing') do
      result.processingList.Add(parseSpecimenProcessing(item));
    for item in obj.complexes('http://hl7.org/fhir/Specimen.container') do
      result.containerList.Add(parseSpecimenContainer(item));
    for item in obj.complexes('http://hl7.org/fhir/Specimen.condition') do
      result.conditionList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/Specimen.note') do
      result.noteList.Add(parseAnnotation(item));
end;

procedure TFHIRTurtleComposer.ComposeSpecimen(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSpecimen; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Specimen'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Specimen', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('accessionIdentifier') then
    ComposeIdentifier(this, 'Specimen', 'accessionIdentifier', elem.accessionIdentifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(this, 'Specimen', 'status', elem.StatusElement, CODES_TFhirSpecimenStatusEnum, SYSTEMS_TFhirSpecimenStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCodeableConcept(this, 'Specimen', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{TFhirPatient}(this, 'Specimen', 'subject', elem.subjectElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('receivedTime') then
    ComposeDateTime(this, 'Specimen', 'receivedTime', elem.receivedTimeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('parent') then
    for i := 0 to elem.parentList.Count - 1 do
      ComposeReference{TFhirSpecimen}(this, 'Specimen', 'parent', elem.parentList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('request') then
    for i := 0 to elem.requestList.Count - 1 do
      ComposeReference{TFhirServiceRequest}(this, 'Specimen', 'request', elem.requestList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('collection') then
    ComposeSpecimenCollection(this, 'Specimen', 'collection', elem.collectionElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('processing') then
    for i := 0 to elem.processingList.Count - 1 do
      ComposeSpecimenProcessing(this, 'Specimen', 'processing', elem.processingList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('container') then
    for i := 0 to elem.containerList.Count - 1 do
      ComposeSpecimenContainer(this, 'Specimen', 'container', elem.containerList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('condition') then
    for i := 0 to elem.conditionList.Count - 1 do
      ComposeCodeableConcept(this, 'Specimen', 'condition', elem.conditionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'Specimen', 'note', elem.noteList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_SPECIMEN}
{$IFDEF FHIR_SPECIMENDEFINITION}
function TFHIRTurtleParser.ParseSpecimenDefinitionTypeTested(obj : TTurtleComplex) : TFhirSpecimenDefinitionTypeTested;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSpecimenDefinitionTypeTested.create;
  try
    ParseSpecimenDefinitionTypeTestedProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSpecimenDefinitionTypeTestedProperties(obj : TTurtleComplex; result : TFhirSpecimenDefinitionTypeTested);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.isDerivedElement := ParseBoolean(obj.complex('http://hl7.org/fhir/SpecimenDefinition.typeTested.isDerived'));{q1}
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SpecimenDefinition.typeTested.type'));{q3b}
    result.preferenceElement := ParseEnum(obj.complex('http://hl7.org/fhir/SpecimenDefinition.typeTested.preference'), CODES_TFhirSpecimenContainedPreferenceEnum, SYSTEMS_TFhirSpecimenContainedPreferenceEnum);
    result.container := ParseSpecimenDefinitionTypeTestedContainer(obj.complex('http://hl7.org/fhir/SpecimenDefinition.typeTested.container'));{q3b}
    result.requirementElement := ParseString(obj.complex('http://hl7.org/fhir/SpecimenDefinition.typeTested.requirement'));{q1}
    result.retentionTime := ParseDuration(obj.complex('http://hl7.org/fhir/SpecimenDefinition.typeTested.retentionTime'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/SpecimenDefinition.typeTested.rejectionCriterion') do
      result.rejectionCriterionList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/SpecimenDefinition.typeTested.handling') do
      result.handlingList.Add(parseSpecimenDefinitionTypeTestedHandling(item));
end;

procedure TFHIRTurtleComposer.ComposeSpecimenDefinitionTypeTested(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSpecimenDefinitionTypeTested; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SpecimenDefinitionTypeTested'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'SpecimenDefinition.typeTested', 'isDerived', elem.isDerivedElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'SpecimenDefinition.typeTested', 'type', elem.type_Element, false, -1);{x.2f}
  ComposeEnum(this, 'SpecimenDefinition.typeTested', 'preference', elem.PreferenceElement, CODES_TFhirSpecimenContainedPreferenceEnum, SYSTEMS_TFhirSpecimenContainedPreferenceEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeSpecimenDefinitionTypeTestedContainer(this, 'SpecimenDefinition.typeTested', 'container', elem.containerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'SpecimenDefinition.typeTested', 'requirement', elem.requirementElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeDuration(this, 'SpecimenDefinition.typeTested', 'retentionTime', elem.retentionTimeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.rejectionCriterionList.Count - 1 do
      ComposeCodeableConcept(this, 'SpecimenDefinition.typeTested', 'rejectionCriterion', elem.rejectionCriterionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.handlingList.Count - 1 do
      ComposeSpecimenDefinitionTypeTestedHandling(this, 'SpecimenDefinition.typeTested', 'handling', elem.handlingList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseSpecimenDefinitionTypeTestedContainer(obj : TTurtleComplex) : TFhirSpecimenDefinitionTypeTestedContainer;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSpecimenDefinitionTypeTestedContainer.create;
  try
    ParseSpecimenDefinitionTypeTestedContainerProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSpecimenDefinitionTypeTestedContainerProperties(obj : TTurtleComplex; result : TFhirSpecimenDefinitionTypeTestedContainer);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.material := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SpecimenDefinition.typeTested.container.material'));{q3b}
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SpecimenDefinition.typeTested.container.type'));{q3b}
    result.cap := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SpecimenDefinition.typeTested.container.cap'));{q3b}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/SpecimenDefinition.typeTested.container.description'));{q1}
    result.capacity := ParseQuantity(obj.complex('http://hl7.org/fhir/SpecimenDefinition.typeTested.container.capacity'));{q3b}
    if obj.has('http://hl7.org/fhir/SpecimenDefinition.typeTested.container.minimumVolumeQuantity', item) then
      result.minimumVolume := parseQuantity(item);
    if obj.has('http://hl7.org/fhir/SpecimenDefinition.typeTested.container.minimumVolumeString', item) then
      result.minimumVolume := parseString(item);
    for item in obj.complexes('http://hl7.org/fhir/SpecimenDefinition.typeTested.container.additive') do
      result.additiveList.Add(parseSpecimenDefinitionTypeTestedContainerAdditive(item));
    result.preparationElement := ParseString(obj.complex('http://hl7.org/fhir/SpecimenDefinition.typeTested.container.preparation'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeSpecimenDefinitionTypeTestedContainer(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSpecimenDefinitionTypeTestedContainer; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SpecimenDefinitionTypeTestedContainer'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'SpecimenDefinition.typeTested.container', 'material', elem.materialElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'SpecimenDefinition.typeTested.container', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'SpecimenDefinition.typeTested.container', 'cap', elem.capElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'SpecimenDefinition.typeTested.container', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'SpecimenDefinition.typeTested.container', 'capacity', elem.capacityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and (elem.minimumVolume is TFhirQuantity) {6} then
    ComposeQuantity(this, 'SpecimenDefinition.typeTested.container', 'minimumVolumeQuantity', TFhirQuantity(elem.minimumVolume), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.minimumVolume is TFhirString) {6} then
    ComposeString(this, 'SpecimenDefinition.typeTested.container', 'minimumVolumeString', TFhirString(elem.minimumVolume), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.additiveList.Count - 1 do
      ComposeSpecimenDefinitionTypeTestedContainerAdditive(this, 'SpecimenDefinition.typeTested.container', 'additive', elem.additiveList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'SpecimenDefinition.typeTested.container', 'preparation', elem.preparationElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseSpecimenDefinitionTypeTestedContainerAdditive(obj : TTurtleComplex) : TFhirSpecimenDefinitionTypeTestedContainerAdditive;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSpecimenDefinitionTypeTestedContainerAdditive.create;
  try
    ParseSpecimenDefinitionTypeTestedContainerAdditiveProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSpecimenDefinitionTypeTestedContainerAdditiveProperties(obj : TTurtleComplex; result : TFhirSpecimenDefinitionTypeTestedContainerAdditive);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    if obj.has('http://hl7.org/fhir/SpecimenDefinition.typeTested.container.additive.additiveCodeableConcept', item) then
      result.additive := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/SpecimenDefinition.typeTested.container.additive.additiveReference', item) {a3} then
      result.additive := ParseReference(item);
end;

procedure TFHIRTurtleComposer.ComposeSpecimenDefinitionTypeTestedContainerAdditive(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSpecimenDefinitionTypeTestedContainerAdditive; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SpecimenDefinitionTypeTestedContainerAdditive'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (elem.additive is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'SpecimenDefinition.typeTested.container.additive', 'additiveCodeableConcept', TFhirCodeableConcept(elem.additive), false, -1){x.d9}
  else if (elem.additive is TFhirReference) {2} then
    ComposeReference(this, 'SpecimenDefinition.typeTested.container.additive', 'additiveReference', TFhirReference(elem.additive), false,-1);{x.d8}
end;

function TFHIRTurtleParser.ParseSpecimenDefinitionTypeTestedHandling(obj : TTurtleComplex) : TFhirSpecimenDefinitionTypeTestedHandling;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSpecimenDefinitionTypeTestedHandling.create;
  try
    ParseSpecimenDefinitionTypeTestedHandlingProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSpecimenDefinitionTypeTestedHandlingProperties(obj : TTurtleComplex; result : TFhirSpecimenDefinitionTypeTestedHandling);
begin
    ParseBackboneElementProperties(obj, result);
    result.temperatureQualifier := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SpecimenDefinition.typeTested.handling.temperatureQualifier'));{q3b}
    result.temperatureRange := ParseRange(obj.complex('http://hl7.org/fhir/SpecimenDefinition.typeTested.handling.temperatureRange'));{q3b}
    result.maxDuration := ParseDuration(obj.complex('http://hl7.org/fhir/SpecimenDefinition.typeTested.handling.maxDuration'));{q3b}
    result.instructionElement := ParseString(obj.complex('http://hl7.org/fhir/SpecimenDefinition.typeTested.handling.instruction'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeSpecimenDefinitionTypeTestedHandling(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSpecimenDefinitionTypeTestedHandling; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SpecimenDefinitionTypeTestedHandling'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'SpecimenDefinition.typeTested.handling', 'temperatureQualifier', elem.temperatureQualifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeRange(this, 'SpecimenDefinition.typeTested.handling', 'temperatureRange', elem.temperatureRangeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeDuration(this, 'SpecimenDefinition.typeTested.handling', 'maxDuration', elem.maxDurationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'SpecimenDefinition.typeTested.handling', 'instruction', elem.instructionElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseSpecimenDefinition(obj : TTurtleComplex) : TFhirSpecimenDefinition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSpecimenDefinition.create;
  try
    ParseSpecimenDefinitionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSpecimenDefinitionProperties(obj : TTurtleComplex; result : TFhirSpecimenDefinition);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/SpecimenDefinition.identifier'));{q3b}
    result.typeCollected := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SpecimenDefinition.typeCollected'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/SpecimenDefinition.patientPreparation') do
      result.patientPreparationList.Add(parseCodeableConcept(item));
    result.timeAspectElement := ParseString(obj.complex('http://hl7.org/fhir/SpecimenDefinition.timeAspect'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/SpecimenDefinition.collection') do
      result.collectionList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/SpecimenDefinition.typeTested') do
      result.typeTestedList.Add(parseSpecimenDefinitionTypeTested(item));
end;

procedure TFHIRTurtleComposer.ComposeSpecimenDefinition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSpecimenDefinition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SpecimenDefinition'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(this, 'SpecimenDefinition', 'identifier', elem.identifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('typeCollected') then
    ComposeCodeableConcept(this, 'SpecimenDefinition', 'typeCollected', elem.typeCollectedElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('patientPreparation') then
    for i := 0 to elem.patientPreparationList.Count - 1 do
      ComposeCodeableConcept(this, 'SpecimenDefinition', 'patientPreparation', elem.patientPreparationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('timeAspect') then
    ComposeString(this, 'SpecimenDefinition', 'timeAspect', elem.timeAspectElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('collection') then
    for i := 0 to elem.collectionList.Count - 1 do
      ComposeCodeableConcept(this, 'SpecimenDefinition', 'collection', elem.collectionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('typeTested') then
    for i := 0 to elem.typeTestedList.Count - 1 do
      ComposeSpecimenDefinitionTypeTested(this, 'SpecimenDefinition', 'typeTested', elem.typeTestedList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_SPECIMENDEFINITION}
{$IFDEF FHIR_STRUCTUREDEFINITION}
function TFHIRTurtleParser.ParseStructureDefinitionMapping(obj : TTurtleComplex) : TFhirStructureDefinitionMapping;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirStructureDefinitionMapping.create;
  try
    ParseStructureDefinitionMappingProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseStructureDefinitionMappingProperties(obj : TTurtleComplex; result : TFhirStructureDefinitionMapping);
begin
    ParseBackboneElementProperties(obj, result);
    result.identityElement := ParseId(obj.complex('http://hl7.org/fhir/StructureDefinition.mapping.identity'));{q1}
    result.uriElement := ParseUri(obj.complex('http://hl7.org/fhir/StructureDefinition.mapping.uri'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/StructureDefinition.mapping.name'));{q1}
    result.commentElement := ParseString(obj.complex('http://hl7.org/fhir/StructureDefinition.mapping.comment'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeStructureDefinitionMapping(parent :  TTurtleComplex; parentType, name : String; elem : TFhirStructureDefinitionMapping; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:StructureDefinitionMapping'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeId(this, 'StructureDefinition.mapping', 'identity', elem.identityElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'StructureDefinition.mapping', 'uri', elem.uriElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'StructureDefinition.mapping', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'StructureDefinition.mapping', 'comment', elem.commentElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseStructureDefinitionContext(obj : TTurtleComplex) : TFhirStructureDefinitionContext;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirStructureDefinitionContext.create;
  try
    ParseStructureDefinitionContextProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseStructureDefinitionContextProperties(obj : TTurtleComplex; result : TFhirStructureDefinitionContext);
begin
    ParseBackboneElementProperties(obj, result);
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/StructureDefinition.context.type'), CODES_TFhirExtensionContextTypeEnum, SYSTEMS_TFhirExtensionContextTypeEnum);
    result.expressionElement := ParseString(obj.complex('http://hl7.org/fhir/StructureDefinition.context.expression'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeStructureDefinitionContext(parent :  TTurtleComplex; parentType, name : String; elem : TFhirStructureDefinitionContext; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:StructureDefinitionContext'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'StructureDefinition.context', 'type', elem.Type_Element, CODES_TFhirExtensionContextTypeEnum, SYSTEMS_TFhirExtensionContextTypeEnum, false, -1);{x.d4}
  ComposeString(this, 'StructureDefinition.context', 'expression', elem.expressionElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseStructureDefinitionSnapshot(obj : TTurtleComplex) : TFhirStructureDefinitionSnapshot;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirStructureDefinitionSnapshot.create;
  try
    ParseStructureDefinitionSnapshotProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseStructureDefinitionSnapshotProperties(obj : TTurtleComplex; result : TFhirStructureDefinitionSnapshot);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/StructureDefinition.snapshot.element') do
      result.elementList.Add(parseElementDefinition(item));
end;

procedure TFHIRTurtleComposer.ComposeStructureDefinitionSnapshot(parent :  TTurtleComplex; parentType, name : String; elem : TFhirStructureDefinitionSnapshot; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:StructureDefinitionSnapshot'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  for i := 0 to elem.elementList.Count - 1 do
      ComposeElementDefinition(this, 'StructureDefinition.snapshot', 'element', elem.elementList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseStructureDefinitionDifferential(obj : TTurtleComplex) : TFhirStructureDefinitionDifferential;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirStructureDefinitionDifferential.create;
  try
    ParseStructureDefinitionDifferentialProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseStructureDefinitionDifferentialProperties(obj : TTurtleComplex; result : TFhirStructureDefinitionDifferential);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/StructureDefinition.differential.element') do
      result.elementList.Add(parseElementDefinition(item));
end;

procedure TFHIRTurtleComposer.ComposeStructureDefinitionDifferential(parent :  TTurtleComplex; parentType, name : String; elem : TFhirStructureDefinitionDifferential; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:StructureDefinitionDifferential'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  for i := 0 to elem.elementList.Count - 1 do
      ComposeElementDefinition(this, 'StructureDefinition.differential', 'element', elem.elementList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseStructureDefinition(obj : TTurtleComplex) : TFhirStructureDefinition;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirStructureDefinition.create;
  try
    ParseStructureDefinitionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseStructureDefinitionProperties(obj : TTurtleComplex; result : TFhirStructureDefinition);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/StructureDefinition.url'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/StructureDefinition.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/StructureDefinition.version'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/StructureDefinition.name'));{q1}
    result.titleElement := ParseString(obj.complex('http://hl7.org/fhir/StructureDefinition.title'));{q1}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/StructureDefinition.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    result.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/StructureDefinition.experimental'));{q1}
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/StructureDefinition.date'));{q1}
    result.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/StructureDefinition.publisher'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/StructureDefinition.contact') do
      result.contactList.Add(parseContactDetail(item));
    result.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/StructureDefinition.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/StructureDefinition.useContext') do
      result.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/StructureDefinition.jurisdiction') do
      result.jurisdictionList.Add(parseCodeableConcept(item));
    result.purposeElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/StructureDefinition.purpose'));{q1}
    result.copyrightElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/StructureDefinition.copyright'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/StructureDefinition.keyword') do
      result.keywordList.Add(parseCoding(item));
    result.fhirVersionElement := ParseEnum(obj.complex('http://hl7.org/fhir/StructureDefinition.fhirVersion'), CODES_TFhirFHIRVersionEnum, SYSTEMS_TFhirFHIRVersionEnum);
    for item in obj.complexes('http://hl7.org/fhir/StructureDefinition.mapping') do
      result.mappingList.Add(parseStructureDefinitionMapping(item));
    result.kindElement := ParseEnum(obj.complex('http://hl7.org/fhir/StructureDefinition.kind'), CODES_TFhirStructureDefinitionKindEnum, SYSTEMS_TFhirStructureDefinitionKindEnum);
    result.abstractElement := ParseBoolean(obj.complex('http://hl7.org/fhir/StructureDefinition.abstract'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/StructureDefinition.context') do
      result.contextList.Add(parseStructureDefinitionContext(item));
    for item in obj.complexes('http://hl7.org/fhir/StructureDefinition.contextInvariant') do
      result.contextInvariantList.Add(parseString(item));
    result.type_Element := ParseUri(obj.complex('http://hl7.org/fhir/StructureDefinition.type'));{q1}
    result.baseDefinitionElement := ParseCanonical(obj.complex('http://hl7.org/fhir/StructureDefinition.baseDefinition'));{q1}
    result.derivationElement := ParseEnum(obj.complex('http://hl7.org/fhir/StructureDefinition.derivation'), CODES_TFhirTypeDerivationRuleEnum, SYSTEMS_TFhirTypeDerivationRuleEnum);
    result.snapshot := ParseStructureDefinitionSnapshot(obj.complex('http://hl7.org/fhir/StructureDefinition.snapshot'));{q3b}
    result.differential := ParseStructureDefinitionDifferential(obj.complex('http://hl7.org/fhir/StructureDefinition.differential'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeStructureDefinition(parent :  TTurtleComplex; parentType, name : String; elem : TFhirStructureDefinition; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:StructureDefinition'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  ComposeUri(this, 'StructureDefinition', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'StructureDefinition', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(this, 'StructureDefinition', 'version', elem.versionElement, false, -1);{x.2ea}
  ComposeString(this, 'StructureDefinition', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeString(this, 'StructureDefinition', 'title', elem.titleElement, false, -1);{x.2ea}
  ComposeEnum(this, 'StructureDefinition', 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(this, 'StructureDefinition', 'experimental', elem.experimentalElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(this, 'StructureDefinition', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(this, 'StructureDefinition', 'publisher', elem.publisherElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(this, 'StructureDefinition', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdown(this, 'StructureDefinition', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(this, 'StructureDefinition', 'useContext', elem.useContextList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'StructureDefinition', 'jurisdiction', elem.jurisdictionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdown(this, 'StructureDefinition', 'purpose', elem.purposeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdown(this, 'StructureDefinition', 'copyright', elem.copyrightElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('keyword') then
    for i := 0 to elem.keywordList.Count - 1 do
      ComposeCoding(this, 'StructureDefinition', 'keyword', elem.keywordList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('fhirVersion') then
    ComposeEnum(this, 'StructureDefinition', 'fhirVersion', elem.FhirVersionElement, CODES_TFhirFHIRVersionEnum, SYSTEMS_TFhirFHIRVersionEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('mapping') then
    for i := 0 to elem.mappingList.Count - 1 do
      ComposeStructureDefinitionMapping(this, 'StructureDefinition', 'mapping', elem.mappingList[i], false, i);{x.d3}
  ComposeEnum(this, 'StructureDefinition', 'kind', elem.KindElement, CODES_TFhirStructureDefinitionKindEnum, SYSTEMS_TFhirStructureDefinitionKindEnum, false, -1);{x.d4}
  ComposeBoolean(this, 'StructureDefinition', 'abstract', elem.abstractElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('context') then
    for i := 0 to elem.contextList.Count - 1 do
      ComposeStructureDefinitionContext(this, 'StructureDefinition', 'context', elem.contextList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contextInvariant') then
    for i := 0 to elem.contextInvariantList.Count - 1 do
      ComposeString(this, 'StructureDefinition', 'contextInvariant', elem.contextInvariantList[i], false, i);{x.d3}
  ComposeUri(this, 'StructureDefinition', 'type', elem.type_Element, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('baseDefinition') then
    ComposeCanonical(this, 'StructureDefinition', 'baseDefinition', elem.baseDefinitionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('derivation') then
    ComposeEnum(this, 'StructureDefinition', 'derivation', elem.DerivationElement, CODES_TFhirTypeDerivationRuleEnum, SYSTEMS_TFhirTypeDerivationRuleEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('snapshot') then
    ComposeStructureDefinitionSnapshot(this, 'StructureDefinition', 'snapshot', elem.snapshotElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('differential') then
    ComposeStructureDefinitionDifferential(this, 'StructureDefinition', 'differential', elem.differentialElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_STRUCTUREDEFINITION}
{$IFDEF FHIR_STRUCTUREMAP}
function TFHIRTurtleParser.ParseStructureMapStructure(obj : TTurtleComplex) : TFhirStructureMapStructure;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirStructureMapStructure.create;
  try
    ParseStructureMapStructureProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseStructureMapStructureProperties(obj : TTurtleComplex; result : TFhirStructureMapStructure);
begin
    ParseBackboneElementProperties(obj, result);
    result.urlElement := ParseCanonical(obj.complex('http://hl7.org/fhir/StructureMap.structure.url'));{q1}
    result.modeElement := ParseEnum(obj.complex('http://hl7.org/fhir/StructureMap.structure.mode'), CODES_TFhirMapModelModeEnum, SYSTEMS_TFhirMapModelModeEnum);
    result.aliasElement := ParseString(obj.complex('http://hl7.org/fhir/StructureMap.structure.alias'));{q1}
    result.documentationElement := ParseString(obj.complex('http://hl7.org/fhir/StructureMap.structure.documentation'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeStructureMapStructure(parent :  TTurtleComplex; parentType, name : String; elem : TFhirStructureMapStructure; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:StructureMapStructure'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCanonical(this, 'StructureMap.structure', 'url', elem.urlElement, false, -1);{x.2ea}
  ComposeEnum(this, 'StructureMap.structure', 'mode', elem.ModeElement, CODES_TFhirMapModelModeEnum, SYSTEMS_TFhirMapModelModeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'StructureMap.structure', 'alias', elem.aliasElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'StructureMap.structure', 'documentation', elem.documentationElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseStructureMapGroup(obj : TTurtleComplex) : TFhirStructureMapGroup;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirStructureMapGroup.create;
  try
    ParseStructureMapGroupProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseStructureMapGroupProperties(obj : TTurtleComplex; result : TFhirStructureMapGroup);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.nameElement := ParseId(obj.complex('http://hl7.org/fhir/StructureMap.group.name'));{q1}
    result.extendsElement := ParseId(obj.complex('http://hl7.org/fhir/StructureMap.group.extends'));{q1}
    result.typeModeElement := ParseEnum(obj.complex('http://hl7.org/fhir/StructureMap.group.typeMode'), CODES_TFhirMapGroupTypeModeEnum, SYSTEMS_TFhirMapGroupTypeModeEnum);
    result.documentationElement := ParseString(obj.complex('http://hl7.org/fhir/StructureMap.group.documentation'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/StructureMap.group.input') do
      result.inputList.Add(parseStructureMapGroupInput(item));
    for item in obj.complexes('http://hl7.org/fhir/StructureMap.group.rule') do
      result.ruleList.Add(parseStructureMapGroupRule(item));
end;

procedure TFHIRTurtleComposer.ComposeStructureMapGroup(parent :  TTurtleComplex; parentType, name : String; elem : TFhirStructureMapGroup; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:StructureMapGroup'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeId(this, 'StructureMap.group', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeId(this, 'StructureMap.group', 'extends', elem.extendsElement, false, -1);{x.2ea}
  ComposeEnum(this, 'StructureMap.group', 'typeMode', elem.TypeModeElement, CODES_TFhirMapGroupTypeModeEnum, SYSTEMS_TFhirMapGroupTypeModeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'StructureMap.group', 'documentation', elem.documentationElement, false, -1);{x.2ea}
  for i := 0 to elem.inputList.Count - 1 do
      ComposeStructureMapGroupInput(this, 'StructureMap.group', 'input', elem.inputList[i], false, i);{x.d3}
  for i := 0 to elem.ruleList.Count - 1 do
      ComposeStructureMapGroupRule(this, 'StructureMap.group', 'rule', elem.ruleList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseStructureMapGroupInput(obj : TTurtleComplex) : TFhirStructureMapGroupInput;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirStructureMapGroupInput.create;
  try
    ParseStructureMapGroupInputProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseStructureMapGroupInputProperties(obj : TTurtleComplex; result : TFhirStructureMapGroupInput);
begin
    ParseBackboneElementProperties(obj, result);
    result.nameElement := ParseId(obj.complex('http://hl7.org/fhir/StructureMap.group.input.name'));{q1}
    result.type_Element := ParseString(obj.complex('http://hl7.org/fhir/StructureMap.group.input.type'));{q1}
    result.modeElement := ParseEnum(obj.complex('http://hl7.org/fhir/StructureMap.group.input.mode'), CODES_TFhirMapInputModeEnum, SYSTEMS_TFhirMapInputModeEnum);
    result.documentationElement := ParseString(obj.complex('http://hl7.org/fhir/StructureMap.group.input.documentation'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeStructureMapGroupInput(parent :  TTurtleComplex; parentType, name : String; elem : TFhirStructureMapGroupInput; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:StructureMapGroupInput'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeId(this, 'StructureMap.group.input', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'StructureMap.group.input', 'type', elem.type_Element, false, -1);{x.2ea}
  ComposeEnum(this, 'StructureMap.group.input', 'mode', elem.ModeElement, CODES_TFhirMapInputModeEnum, SYSTEMS_TFhirMapInputModeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'StructureMap.group.input', 'documentation', elem.documentationElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseStructureMapGroupRule(obj : TTurtleComplex) : TFhirStructureMapGroupRule;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirStructureMapGroupRule.create;
  try
    ParseStructureMapGroupRuleProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseStructureMapGroupRuleProperties(obj : TTurtleComplex; result : TFhirStructureMapGroupRule);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.nameElement := ParseId(obj.complex('http://hl7.org/fhir/StructureMap.group.rule.name'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/StructureMap.group.rule.source') do
      result.sourceList.Add(parseStructureMapGroupRuleSource(item));
    for item in obj.complexes('http://hl7.org/fhir/StructureMap.group.rule.target') do
      result.targetList.Add(parseStructureMapGroupRuleTarget(item));
    for item in obj.complexes('http://hl7.org/fhir/StructureMap.group.rule.rule') do
      result.ruleList.Add(parseStructureMapGroupRule(item));
    for item in obj.complexes('http://hl7.org/fhir/StructureMap.group.rule.dependent') do
      result.dependentList.Add(parseStructureMapGroupRuleDependent(item));
    result.documentationElement := ParseString(obj.complex('http://hl7.org/fhir/StructureMap.group.rule.documentation'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeStructureMapGroupRule(parent :  TTurtleComplex; parentType, name : String; elem : TFhirStructureMapGroupRule; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:StructureMapGroupRule'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeId(this, 'StructureMap.group.rule', 'name', elem.nameElement, false, -1);{x.2ea}
  for i := 0 to elem.sourceList.Count - 1 do
      ComposeStructureMapGroupRuleSource(this, 'StructureMap.group.rule', 'source', elem.sourceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.targetList.Count - 1 do
      ComposeStructureMapGroupRuleTarget(this, 'StructureMap.group.rule', 'target', elem.targetList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.ruleList.Count - 1 do
      ComposeStructureMapGroupRule(this, 'StructureMap.group.rule', 'rule', elem.ruleList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.dependentList.Count - 1 do
      ComposeStructureMapGroupRuleDependent(this, 'StructureMap.group.rule', 'dependent', elem.dependentList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'StructureMap.group.rule', 'documentation', elem.documentationElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseStructureMapGroupRuleSource(obj : TTurtleComplex) : TFhirStructureMapGroupRuleSource;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirStructureMapGroupRuleSource.create;
  try
    ParseStructureMapGroupRuleSourceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseStructureMapGroupRuleSourceProperties(obj : TTurtleComplex; result : TFhirStructureMapGroupRuleSource);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.contextElement := ParseId(obj.complex('http://hl7.org/fhir/StructureMap.group.rule.source.context'));{q1}
    result.minElement := ParseInteger(obj.complex('http://hl7.org/fhir/StructureMap.group.rule.source.min'));{q1}
    result.maxElement := ParseString(obj.complex('http://hl7.org/fhir/StructureMap.group.rule.source.max'));{q1}
    result.type_Element := ParseString(obj.complex('http://hl7.org/fhir/StructureMap.group.rule.source.type'));{q1}
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueCanonical', item) then
      result.defaultValue := parseCanonical(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueCode', item) then
      result.defaultValue := parseCode(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueId', item) then
      result.defaultValue := parseId(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueMarkdown', item) then
      result.defaultValue := parseMarkdown(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueOid', item) then
      result.defaultValue := parseOid(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValuePositiveInt', item) then
      result.defaultValue := parsePositiveInt(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueUnsignedInt', item) then
      result.defaultValue := parseUnsignedInt(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueUrl', item) then
      result.defaultValue := parseUrl(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueUuid', item) then
      result.defaultValue := parseUuid(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueAddress', item) then
      result.defaultValue := parseAddress(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueAge', item) then
      result.defaultValue := parseAge(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueAnnotation', item) then
      result.defaultValue := parseAnnotation(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueAttachment', item) then
      result.defaultValue := parseAttachment(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueCodeableConcept', item) then
      result.defaultValue := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueCoding', item) then
      result.defaultValue := parseCoding(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueContactPoint', item) then
      result.defaultValue := parseContactPoint(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueCount', item) then
      result.defaultValue := parseCount(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueDistance', item) then
      result.defaultValue := parseDistance(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueDuration', item) then
      result.defaultValue := parseDuration(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueHumanName', item) then
      result.defaultValue := parseHumanName(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueIdentifier', item) then
      result.defaultValue := parseIdentifier(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueMoney', item) then
      result.defaultValue := parseMoney(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValuePeriod', item) then
      result.defaultValue := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueQuantity', item) then
      result.defaultValue := parseQuantity(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueRange', item) then
      result.defaultValue := parseRange(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueRatio', item) then
      result.defaultValue := parseRatio(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueReference', item) then
      result.defaultValue := parseReference(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueSampledData', item) then
      result.defaultValue := parseSampledData(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueSignature', item) then
      result.defaultValue := parseSignature(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueTiming', item) then
      result.defaultValue := parseTiming(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueContactDetail', item) then
      result.defaultValue := parseContactDetail(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueContributor', item) then
      result.defaultValue := parseContributor(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueDataRequirement', item) then
      result.defaultValue := parseDataRequirement(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueExpression', item) then
      result.defaultValue := parseExpression(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueParameterDefinition', item) then
      result.defaultValue := parseParameterDefinition(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueRelatedArtifact', item) then
      result.defaultValue := parseRelatedArtifact(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueTriggerDefinition', item) then
      result.defaultValue := parseTriggerDefinition(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueUsageContext', item) then
      result.defaultValue := parseUsageContext(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueDosage', item) then
      result.defaultValue := parseDosage(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueBase64Binary', item) then
      result.defaultValue := parseBase64Binary(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueBoolean', item) then
      result.defaultValue := parseBoolean(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueDate', item) then
      result.defaultValue := parseDate(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueDateTime', item) then
      result.defaultValue := parseDateTime(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueDecimal', item) then
      result.defaultValue := parseDecimal(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueInstant', item) then
      result.defaultValue := parseInstant(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueInteger', item) then
      result.defaultValue := parseInteger(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueString', item) then
      result.defaultValue := parseString(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueTime', item) then
      result.defaultValue := parseTime(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.source.defaultValueUri', item) then
      result.defaultValue := parseUri(item);
    result.elementElement := ParseString(obj.complex('http://hl7.org/fhir/StructureMap.group.rule.source.element'));{q1}
    result.listModeElement := ParseEnum(obj.complex('http://hl7.org/fhir/StructureMap.group.rule.source.listMode'), CODES_TFhirMapSourceListModeEnum, SYSTEMS_TFhirMapSourceListModeEnum);
    result.variableElement := ParseId(obj.complex('http://hl7.org/fhir/StructureMap.group.rule.source.variable'));{q1}
    result.conditionElement := ParseString(obj.complex('http://hl7.org/fhir/StructureMap.group.rule.source.condition'));{q1}
    result.checkElement := ParseString(obj.complex('http://hl7.org/fhir/StructureMap.group.rule.source.check'));{q1}
    result.logMessageElement := ParseString(obj.complex('http://hl7.org/fhir/StructureMap.group.rule.source.logMessage'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeStructureMapGroupRuleSource(parent :  TTurtleComplex; parentType, name : String; elem : TFhirStructureMapGroupRuleSource; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:StructureMapGroupRuleSource'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeId(this, 'StructureMap.group.rule.source', 'context', elem.contextElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(this, 'StructureMap.group.rule.source', 'min', elem.minElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'StructureMap.group.rule.source', 'max', elem.maxElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'StructureMap.group.rule.source', 'type', elem.type_Element, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirCanonical) {6} then
    ComposeCanonical(this, 'StructureMap.group.rule.source', 'defaultValueCanonical', TFhirCanonical(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirCode) {6} then
    ComposeCode(this, 'StructureMap.group.rule.source', 'defaultValueCode', TFhirCode(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirId) {6} then
    ComposeId(this, 'StructureMap.group.rule.source', 'defaultValueId', TFhirId(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirMarkdown) {6} then
    ComposeMarkdown(this, 'StructureMap.group.rule.source', 'defaultValueMarkdown', TFhirMarkdown(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirOid) {6} then
    ComposeOid(this, 'StructureMap.group.rule.source', 'defaultValueOid', TFhirOid(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirPositiveInt) {6} then
    ComposePositiveInt(this, 'StructureMap.group.rule.source', 'defaultValuePositiveInt', TFhirPositiveInt(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(this, 'StructureMap.group.rule.source', 'defaultValueUnsignedInt', TFhirUnsignedInt(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirUrl) {6} then
    ComposeUrl(this, 'StructureMap.group.rule.source', 'defaultValueUrl', TFhirUrl(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirUuid) {6} then
    ComposeUuid(this, 'StructureMap.group.rule.source', 'defaultValueUuid', TFhirUuid(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirAddress) {6} then
    ComposeAddress(this, 'StructureMap.group.rule.source', 'defaultValueAddress', TFhirAddress(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirAge) {6} then
    ComposeAge(this, 'StructureMap.group.rule.source', 'defaultValueAge', TFhirAge(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirAnnotation) {6} then
    ComposeAnnotation(this, 'StructureMap.group.rule.source', 'defaultValueAnnotation', TFhirAnnotation(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirAttachment) {6} then
    ComposeAttachment(this, 'StructureMap.group.rule.source', 'defaultValueAttachment', TFhirAttachment(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'StructureMap.group.rule.source', 'defaultValueCodeableConcept', TFhirCodeableConcept(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirCoding) {6} then
    ComposeCoding(this, 'StructureMap.group.rule.source', 'defaultValueCoding', TFhirCoding(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirContactPoint) {6} then
    ComposeContactPoint(this, 'StructureMap.group.rule.source', 'defaultValueContactPoint', TFhirContactPoint(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirCount) {6} then
    ComposeCount(this, 'StructureMap.group.rule.source', 'defaultValueCount', TFhirCount(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirDistance) {6} then
    ComposeDistance(this, 'StructureMap.group.rule.source', 'defaultValueDistance', TFhirDistance(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirDuration) {6} then
    ComposeDuration(this, 'StructureMap.group.rule.source', 'defaultValueDuration', TFhirDuration(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirHumanName) {6} then
    ComposeHumanName(this, 'StructureMap.group.rule.source', 'defaultValueHumanName', TFhirHumanName(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirIdentifier) {6} then
    ComposeIdentifier(this, 'StructureMap.group.rule.source', 'defaultValueIdentifier', TFhirIdentifier(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirMoney) {6} then
    ComposeMoney(this, 'StructureMap.group.rule.source', 'defaultValueMoney', TFhirMoney(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirPeriod) {6} then
    ComposePeriod(this, 'StructureMap.group.rule.source', 'defaultValuePeriod', TFhirPeriod(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirQuantity) {6} then
    ComposeQuantity(this, 'StructureMap.group.rule.source', 'defaultValueQuantity', TFhirQuantity(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirRange) {6} then
    ComposeRange(this, 'StructureMap.group.rule.source', 'defaultValueRange', TFhirRange(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirRatio) {6} then
    ComposeRatio(this, 'StructureMap.group.rule.source', 'defaultValueRatio', TFhirRatio(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirReference) {6} then
    ComposeReference(this, 'StructureMap.group.rule.source', 'defaultValueReference', TFhirReference(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirSampledData) {6} then
    ComposeSampledData(this, 'StructureMap.group.rule.source', 'defaultValueSampledData', TFhirSampledData(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirSignature) {6} then
    ComposeSignature(this, 'StructureMap.group.rule.source', 'defaultValueSignature', TFhirSignature(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirTiming) {6} then
    ComposeTiming(this, 'StructureMap.group.rule.source', 'defaultValueTiming', TFhirTiming(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirContactDetail) {6} then
    ComposeContactDetail(this, 'StructureMap.group.rule.source', 'defaultValueContactDetail', TFhirContactDetail(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirContributor) {6} then
    ComposeContributor(this, 'StructureMap.group.rule.source', 'defaultValueContributor', TFhirContributor(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirDataRequirement) {6} then
    ComposeDataRequirement(this, 'StructureMap.group.rule.source', 'defaultValueDataRequirement', TFhirDataRequirement(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirExpression) {6} then
    ComposeExpression(this, 'StructureMap.group.rule.source', 'defaultValueExpression', TFhirExpression(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirParameterDefinition) {6} then
    ComposeParameterDefinition(this, 'StructureMap.group.rule.source', 'defaultValueParameterDefinition', TFhirParameterDefinition(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirRelatedArtifact) {6} then
    ComposeRelatedArtifact(this, 'StructureMap.group.rule.source', 'defaultValueRelatedArtifact', TFhirRelatedArtifact(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirTriggerDefinition) {6} then
    ComposeTriggerDefinition(this, 'StructureMap.group.rule.source', 'defaultValueTriggerDefinition', TFhirTriggerDefinition(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirUsageContext) {6} then
    ComposeUsageContext(this, 'StructureMap.group.rule.source', 'defaultValueUsageContext', TFhirUsageContext(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirDosage) {6} then
    ComposeDosage(this, 'StructureMap.group.rule.source', 'defaultValueDosage', TFhirDosage(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirBase64Binary) {6} then
    ComposeBase64Binary(this, 'StructureMap.group.rule.source', 'defaultValueBase64Binary', TFhirBase64Binary(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirBoolean) {6} then
    ComposeBoolean(this, 'StructureMap.group.rule.source', 'defaultValueBoolean', TFhirBoolean(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirDate) {6} then
    ComposeDate(this, 'StructureMap.group.rule.source', 'defaultValueDate', TFhirDate(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirDateTime) {6} then
    ComposeDateTime(this, 'StructureMap.group.rule.source', 'defaultValueDateTime', TFhirDateTime(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirDecimal) {6} then
    ComposeDecimal(this, 'StructureMap.group.rule.source', 'defaultValueDecimal', TFhirDecimal(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirInstant) {6} then
    ComposeInstant(this, 'StructureMap.group.rule.source', 'defaultValueInstant', TFhirInstant(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirInteger) {6} then
    ComposeInteger(this, 'StructureMap.group.rule.source', 'defaultValueInteger', TFhirInteger(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirString) {6} then
    ComposeString(this, 'StructureMap.group.rule.source', 'defaultValueString', TFhirString(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirTime) {6} then
    ComposeTime(this, 'StructureMap.group.rule.source', 'defaultValueTime', TFhirTime(elem.defaultValue), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirUri) {6} then
    ComposeUri(this, 'StructureMap.group.rule.source', 'defaultValueUri', TFhirUri(elem.defaultValue), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'StructureMap.group.rule.source', 'element', elem.elementElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'StructureMap.group.rule.source', 'listMode', elem.ListModeElement, CODES_TFhirMapSourceListModeEnum, SYSTEMS_TFhirMapSourceListModeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeId(this, 'StructureMap.group.rule.source', 'variable', elem.variableElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'StructureMap.group.rule.source', 'condition', elem.conditionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'StructureMap.group.rule.source', 'check', elem.checkElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'StructureMap.group.rule.source', 'logMessage', elem.logMessageElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseStructureMapGroupRuleTarget(obj : TTurtleComplex) : TFhirStructureMapGroupRuleTarget;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirStructureMapGroupRuleTarget.create;
  try
    ParseStructureMapGroupRuleTargetProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseStructureMapGroupRuleTargetProperties(obj : TTurtleComplex; result : TFhirStructureMapGroupRuleTarget);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.contextElement := ParseId(obj.complex('http://hl7.org/fhir/StructureMap.group.rule.target.context'));{q1}
    result.contextTypeElement := ParseEnum(obj.complex('http://hl7.org/fhir/StructureMap.group.rule.target.contextType'), CODES_TFhirMapContextTypeEnum, SYSTEMS_TFhirMapContextTypeEnum);
    result.elementElement := ParseString(obj.complex('http://hl7.org/fhir/StructureMap.group.rule.target.element'));{q1}
    result.variableElement := ParseId(obj.complex('http://hl7.org/fhir/StructureMap.group.rule.target.variable'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/StructureMap.group.rule.target.listMode') do
      result.listModeList.Add(parseEnum(item, CODES_TFhirMapTargetListModeEnum, SYSTEMS_TFhirMapTargetListModeEnum));
    result.listRuleIdElement := ParseId(obj.complex('http://hl7.org/fhir/StructureMap.group.rule.target.listRuleId'));{q1}
    result.transformElement := ParseEnum(obj.complex('http://hl7.org/fhir/StructureMap.group.rule.target.transform'), CODES_TFhirMapTransformEnum, SYSTEMS_TFhirMapTransformEnum);
    for item in obj.complexes('http://hl7.org/fhir/StructureMap.group.rule.target.parameter') do
      result.parameterList.Add(parseStructureMapGroupRuleTargetParameter(item));
end;

procedure TFHIRTurtleComposer.ComposeStructureMapGroupRuleTarget(parent :  TTurtleComplex; parentType, name : String; elem : TFhirStructureMapGroupRuleTarget; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:StructureMapGroupRuleTarget'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeId(this, 'StructureMap.group.rule.target', 'context', elem.contextElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'StructureMap.group.rule.target', 'contextType', elem.ContextTypeElement, CODES_TFhirMapContextTypeEnum, SYSTEMS_TFhirMapContextTypeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'StructureMap.group.rule.target', 'element', elem.elementElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeId(this, 'StructureMap.group.rule.target', 'variable', elem.variableElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.listModeList.Count - 1 do
      ComposeEnum(this, 'StructureMap.group.rule.target', 'listMode', elem.listModeList[i], CODES_TFhirMapTargetListModeEnum, SYSTEMS_TFhirMapTargetListModeEnum, false, i); {x.d1}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.listModeList.Count - 1 do
      ComposeEnum(this, 'StructureMap.group.rule.target', 'listMode', elem.listModeList[i], CODES_TFhirMapTargetListModeEnum, SYSTEMS_TFhirMapTargetListModeEnum, false, i);{x.d2}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeId(this, 'StructureMap.group.rule.target', 'listRuleId', elem.listRuleIdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(this, 'StructureMap.group.rule.target', 'transform', elem.TransformElement, CODES_TFhirMapTransformEnum, SYSTEMS_TFhirMapTransformEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.parameterList.Count - 1 do
      ComposeStructureMapGroupRuleTargetParameter(this, 'StructureMap.group.rule.target', 'parameter', elem.parameterList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseStructureMapGroupRuleTargetParameter(obj : TTurtleComplex) : TFhirStructureMapGroupRuleTargetParameter;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirStructureMapGroupRuleTargetParameter.create;
  try
    ParseStructureMapGroupRuleTargetParameterProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseStructureMapGroupRuleTargetParameterProperties(obj : TTurtleComplex; result : TFhirStructureMapGroupRuleTargetParameter);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.target.parameter.valueId', item) then
      result.value := parseId(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.target.parameter.valueString', item) then
      result.value := parseString(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.target.parameter.valueBoolean', item) then
      result.value := parseBoolean(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.target.parameter.valueInteger', item) then
      result.value := parseInteger(item);
    if obj.has('http://hl7.org/fhir/StructureMap.group.rule.target.parameter.valueDecimal', item) then
      result.value := parseDecimal(item);
end;

procedure TFHIRTurtleComposer.ComposeStructureMapGroupRuleTargetParameter(parent :  TTurtleComplex; parentType, name : String; elem : TFhirStructureMapGroupRuleTargetParameter; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:StructureMapGroupRuleTargetParameter'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (elem.value is TFhirId) {6} then
    ComposeId(this, 'StructureMap.group.rule.target.parameter', 'valueId', TFhirId(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirString) {6} then
    ComposeString(this, 'StructureMap.group.rule.target.parameter', 'valueString', TFhirString(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirBoolean) {6} then
    ComposeBoolean(this, 'StructureMap.group.rule.target.parameter', 'valueBoolean', TFhirBoolean(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirInteger) {6} then
    ComposeInteger(this, 'StructureMap.group.rule.target.parameter', 'valueInteger', TFhirInteger(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirDecimal) {6} then
    ComposeDecimal(this, 'StructureMap.group.rule.target.parameter', 'valueDecimal', TFhirDecimal(elem.value), false, -1);{x.d9}
end;

function TFHIRTurtleParser.ParseStructureMapGroupRuleDependent(obj : TTurtleComplex) : TFhirStructureMapGroupRuleDependent;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirStructureMapGroupRuleDependent.create;
  try
    ParseStructureMapGroupRuleDependentProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseStructureMapGroupRuleDependentProperties(obj : TTurtleComplex; result : TFhirStructureMapGroupRuleDependent);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.nameElement := ParseId(obj.complex('http://hl7.org/fhir/StructureMap.group.rule.dependent.name'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/StructureMap.group.rule.dependent.variable') do
      result.variableList.Add(parseString(item));
end;

procedure TFHIRTurtleComposer.ComposeStructureMapGroupRuleDependent(parent :  TTurtleComplex; parentType, name : String; elem : TFhirStructureMapGroupRuleDependent; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:StructureMapGroupRuleDependent'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeId(this, 'StructureMap.group.rule.dependent', 'name', elem.nameElement, false, -1);{x.2ea}
  for i := 0 to elem.variableList.Count - 1 do
      ComposeString(this, 'StructureMap.group.rule.dependent', 'variable', elem.variableList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseStructureMap(obj : TTurtleComplex) : TFhirStructureMap;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirStructureMap.create;
  try
    ParseStructureMapProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseStructureMapProperties(obj : TTurtleComplex; result : TFhirStructureMap);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/StructureMap.url'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/StructureMap.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/StructureMap.version'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/StructureMap.name'));{q1}
    result.titleElement := ParseString(obj.complex('http://hl7.org/fhir/StructureMap.title'));{q1}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/StructureMap.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    result.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/StructureMap.experimental'));{q1}
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/StructureMap.date'));{q1}
    result.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/StructureMap.publisher'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/StructureMap.contact') do
      result.contactList.Add(parseContactDetail(item));
    result.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/StructureMap.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/StructureMap.useContext') do
      result.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/StructureMap.jurisdiction') do
      result.jurisdictionList.Add(parseCodeableConcept(item));
    result.purposeElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/StructureMap.purpose'));{q1}
    result.copyrightElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/StructureMap.copyright'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/StructureMap.structure') do
      result.structureList.Add(parseStructureMapStructure(item));
    for item in obj.complexes('http://hl7.org/fhir/StructureMap.import') do
      result.importList.Add(parseCanonical(item));
    for item in obj.complexes('http://hl7.org/fhir/StructureMap.group') do
      result.groupList.Add(parseStructureMapGroup(item));
end;

procedure TFHIRTurtleComposer.ComposeStructureMap(parent :  TTurtleComplex; parentType, name : String; elem : TFhirStructureMap; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:StructureMap'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  ComposeUri(this, 'StructureMap', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'StructureMap', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(this, 'StructureMap', 'version', elem.versionElement, false, -1);{x.2ea}
  ComposeString(this, 'StructureMap', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeString(this, 'StructureMap', 'title', elem.titleElement, false, -1);{x.2ea}
  ComposeEnum(this, 'StructureMap', 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(this, 'StructureMap', 'experimental', elem.experimentalElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(this, 'StructureMap', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(this, 'StructureMap', 'publisher', elem.publisherElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(this, 'StructureMap', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdown(this, 'StructureMap', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(this, 'StructureMap', 'useContext', elem.useContextList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'StructureMap', 'jurisdiction', elem.jurisdictionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdown(this, 'StructureMap', 'purpose', elem.purposeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdown(this, 'StructureMap', 'copyright', elem.copyrightElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('structure') then
    for i := 0 to elem.structureList.Count - 1 do
      ComposeStructureMapStructure(this, 'StructureMap', 'structure', elem.structureList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('import') then
    for i := 0 to elem.importList.Count - 1 do
      ComposeCanonical(this, 'StructureMap', 'import', elem.importList[i], false, i);{x.d3}
  for i := 0 to elem.groupList.Count - 1 do
      ComposeStructureMapGroup(this, 'StructureMap', 'group', elem.groupList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_STRUCTUREMAP}
{$IFDEF FHIR_SUBSCRIPTION}
function TFHIRTurtleParser.ParseSubscriptionChannel(obj : TTurtleComplex) : TFhirSubscriptionChannel;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubscriptionChannel.create;
  try
    ParseSubscriptionChannelProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubscriptionChannelProperties(obj : TTurtleComplex; result : TFhirSubscriptionChannel);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/Subscription.channel.type'), CODES_TFhirSubscriptionChannelTypeEnum, SYSTEMS_TFhirSubscriptionChannelTypeEnum);
    result.endpointElement := ParseUrl(obj.complex('http://hl7.org/fhir/Subscription.channel.endpoint'));{q1}
    result.payloadElement := ParseCode(obj.complex('http://hl7.org/fhir/Subscription.channel.payload'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Subscription.channel.header') do
      result.headerList.Add(parseString(item));
end;

procedure TFHIRTurtleComposer.ComposeSubscriptionChannel(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubscriptionChannel; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubscriptionChannel'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'Subscription.channel', 'type', elem.Type_Element, CODES_TFhirSubscriptionChannelTypeEnum, SYSTEMS_TFhirSubscriptionChannelTypeEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUrl(this, 'Subscription.channel', 'endpoint', elem.endpointElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCode(this, 'Subscription.channel', 'payload', elem.payloadElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.headerList.Count - 1 do
      ComposeString(this, 'Subscription.channel', 'header', elem.headerList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseSubscription(obj : TTurtleComplex) : TFhirSubscription;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubscription.create;
  try
    ParseSubscriptionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubscriptionProperties(obj : TTurtleComplex; result : TFhirSubscription);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Subscription.status'), CODES_TFhirSubscriptionStatusEnum, SYSTEMS_TFhirSubscriptionStatusEnum);
    for item in obj.complexes('http://hl7.org/fhir/Subscription.contact') do
      result.contactList.Add(parseContactPoint(item));
    result.end_Element := ParseInstant(obj.complex('http://hl7.org/fhir/Subscription.end'));{q1}
    result.reasonElement := ParseString(obj.complex('http://hl7.org/fhir/Subscription.reason'));{q1}
    result.criteriaElement := ParseString(obj.complex('http://hl7.org/fhir/Subscription.criteria'));{q1}
    result.errorElement := ParseString(obj.complex('http://hl7.org/fhir/Subscription.error'));{q1}
    result.channel := ParseSubscriptionChannel(obj.complex('http://hl7.org/fhir/Subscription.channel'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeSubscription(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubscription; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Subscription'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  ComposeEnum(this, 'Subscription', 'status', elem.StatusElement, CODES_TFhirSubscriptionStatusEnum, SYSTEMS_TFhirSubscriptionStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactPoint(this, 'Subscription', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('end_') then
    ComposeInstant(this, 'Subscription', 'end', elem.end_Element, false, -1);{x.2ea}
  ComposeString(this, 'Subscription', 'reason', elem.reasonElement, false, -1);{x.2ea}
  ComposeString(this, 'Subscription', 'criteria', elem.criteriaElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('error') then
    ComposeString(this, 'Subscription', 'error', elem.errorElement, false, -1);{x.2ea}
  ComposeSubscriptionChannel(this, 'Subscription', 'channel', elem.channelElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_SUBSCRIPTION}
{$IFDEF FHIR_SUBSTANCE}
function TFHIRTurtleParser.ParseSubstanceInstance(obj : TTurtleComplex) : TFhirSubstanceInstance;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstanceInstance.create;
  try
    ParseSubstanceInstanceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstanceInstanceProperties(obj : TTurtleComplex; result : TFhirSubstanceInstance);
begin
    ParseBackboneElementProperties(obj, result);
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/Substance.instance.identifier'));{q3b}
    result.expiryElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Substance.instance.expiry'));{q1}
    result.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/Substance.instance.quantity'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeSubstanceInstance(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstanceInstance; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstanceInstance'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'Substance.instance', 'identifier', elem.identifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'Substance.instance', 'expiry', elem.expiryElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'Substance.instance', 'quantity', elem.quantityElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseSubstanceIngredient(obj : TTurtleComplex) : TFhirSubstanceIngredient;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstanceIngredient.create;
  try
    ParseSubstanceIngredientProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstanceIngredientProperties(obj : TTurtleComplex; result : TFhirSubstanceIngredient);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.quantity := ParseRatio(obj.complex('http://hl7.org/fhir/Substance.ingredient.quantity'));{q3b}
    if obj.has('http://hl7.org/fhir/Substance.ingredient.substanceCodeableConcept', item) then
      result.substance := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/Substance.ingredient.substanceReference', item) {a3} then
      result.substance := ParseReference(item);
end;

procedure TFHIRTurtleComposer.ComposeSubstanceIngredient(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstanceIngredient; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstanceIngredient'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeRatio(this, 'Substance.ingredient', 'quantity', elem.quantityElement, false, -1);{x.2f}
  if (elem.substance is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Substance.ingredient', 'substanceCodeableConcept', TFhirCodeableConcept(elem.substance), false, -1){x.d9}
  else if (elem.substance is TFhirReference) {2} then
    ComposeReference(this, 'Substance.ingredient', 'substanceReference', TFhirReference(elem.substance), false,-1);{x.d8}
end;

function TFHIRTurtleParser.ParseSubstance(obj : TTurtleComplex) : TFhirSubstance;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstance.create;
  try
    ParseSubstanceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstanceProperties(obj : TTurtleComplex; result : TFhirSubstance);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Substance.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Substance.status'), CODES_TFhirSubstanceStatusEnum, SYSTEMS_TFhirSubstanceStatusEnum);
    for item in obj.complexes('http://hl7.org/fhir/Substance.category') do
      result.categoryList.Add(parseCodeableConcept(item));
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Substance.code'));{q3b}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/Substance.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Substance.instance') do
      result.instanceList.Add(parseSubstanceInstance(item));
    for item in obj.complexes('http://hl7.org/fhir/Substance.ingredient') do
      result.ingredientList.Add(parseSubstanceIngredient(item));
end;

procedure TFHIRTurtleComposer.ComposeSubstance(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstance; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Substance'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Substance', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(this, 'Substance', 'status', elem.StatusElement, CODES_TFhirSubstanceStatusEnum, SYSTEMS_TFhirSubstanceStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(this, 'Substance', 'category', elem.categoryList[i], false, i);{x.d3}
  ComposeCodeableConcept(this, 'Substance', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeString(this, 'Substance', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('instance') then
    for i := 0 to elem.instanceList.Count - 1 do
      ComposeSubstanceInstance(this, 'Substance', 'instance', elem.instanceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('ingredient') then
    for i := 0 to elem.ingredientList.Count - 1 do
      ComposeSubstanceIngredient(this, 'Substance', 'ingredient', elem.ingredientList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_SUBSTANCE}
{$IFDEF FHIR_SUBSTANCENUCLEICACID}
function TFHIRTurtleParser.ParseSubstanceNucleicAcidSubunit(obj : TTurtleComplex) : TFhirSubstanceNucleicAcidSubunit;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstanceNucleicAcidSubunit.create;
  try
    ParseSubstanceNucleicAcidSubunitProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstanceNucleicAcidSubunitProperties(obj : TTurtleComplex; result : TFhirSubstanceNucleicAcidSubunit);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.subunitElement := ParseInteger(obj.complex('http://hl7.org/fhir/SubstanceNucleicAcid.subunit.subunit'));{q1}
    result.sequenceElement := ParseString(obj.complex('http://hl7.org/fhir/SubstanceNucleicAcid.subunit.sequence'));{q1}
    result.lengthElement := ParseInteger(obj.complex('http://hl7.org/fhir/SubstanceNucleicAcid.subunit.length'));{q1}
    result.sequenceAttachment := ParseAttachment(obj.complex('http://hl7.org/fhir/SubstanceNucleicAcid.subunit.sequenceAttachment'));{q3b}
    result.fivePrime := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceNucleicAcid.subunit.fivePrime'));{q3b}
    result.threePrime := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceNucleicAcid.subunit.threePrime'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/SubstanceNucleicAcid.subunit.linkage') do
      result.linkageList.Add(parseSubstanceNucleicAcidSubunitLinkage(item));
    for item in obj.complexes('http://hl7.org/fhir/SubstanceNucleicAcid.subunit.sugar') do
      result.sugarList.Add(parseSubstanceNucleicAcidSubunitSugar(item));
end;

procedure TFHIRTurtleComposer.ComposeSubstanceNucleicAcidSubunit(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstanceNucleicAcidSubunit; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstanceNucleicAcidSubunit'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(this, 'SubstanceNucleicAcid.subunit', 'subunit', elem.subunitElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SubstanceNucleicAcid.subunit', 'sequence', elem.sequenceElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(this, 'SubstanceNucleicAcid.subunit', 'length', elem.lengthElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeAttachment(this, 'SubstanceNucleicAcid.subunit', 'sequenceAttachment', elem.sequenceAttachmentElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceNucleicAcid.subunit', 'fivePrime', elem.fivePrimeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceNucleicAcid.subunit', 'threePrime', elem.threePrimeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.linkageList.Count - 1 do
      ComposeSubstanceNucleicAcidSubunitLinkage(this, 'SubstanceNucleicAcid.subunit', 'linkage', elem.linkageList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.sugarList.Count - 1 do
      ComposeSubstanceNucleicAcidSubunitSugar(this, 'SubstanceNucleicAcid.subunit', 'sugar', elem.sugarList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseSubstanceNucleicAcidSubunitLinkage(obj : TTurtleComplex) : TFhirSubstanceNucleicAcidSubunitLinkage;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstanceNucleicAcidSubunitLinkage.create;
  try
    ParseSubstanceNucleicAcidSubunitLinkageProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstanceNucleicAcidSubunitLinkageProperties(obj : TTurtleComplex; result : TFhirSubstanceNucleicAcidSubunitLinkage);
begin
    ParseBackboneElementProperties(obj, result);
    result.connectivityElement := ParseString(obj.complex('http://hl7.org/fhir/SubstanceNucleicAcid.subunit.linkage.connectivity'));{q1}
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/SubstanceNucleicAcid.subunit.linkage.identifier'));{q3b}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/SubstanceNucleicAcid.subunit.linkage.name'));{q1}
    result.residueSiteElement := ParseString(obj.complex('http://hl7.org/fhir/SubstanceNucleicAcid.subunit.linkage.residueSite'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeSubstanceNucleicAcidSubunitLinkage(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstanceNucleicAcidSubunitLinkage; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstanceNucleicAcidSubunitLinkage'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SubstanceNucleicAcid.subunit.linkage', 'connectivity', elem.connectivityElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'SubstanceNucleicAcid.subunit.linkage', 'identifier', elem.identifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SubstanceNucleicAcid.subunit.linkage', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SubstanceNucleicAcid.subunit.linkage', 'residueSite', elem.residueSiteElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseSubstanceNucleicAcidSubunitSugar(obj : TTurtleComplex) : TFhirSubstanceNucleicAcidSubunitSugar;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstanceNucleicAcidSubunitSugar.create;
  try
    ParseSubstanceNucleicAcidSubunitSugarProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstanceNucleicAcidSubunitSugarProperties(obj : TTurtleComplex; result : TFhirSubstanceNucleicAcidSubunitSugar);
begin
    ParseBackboneElementProperties(obj, result);
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/SubstanceNucleicAcid.subunit.sugar.identifier'));{q3b}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/SubstanceNucleicAcid.subunit.sugar.name'));{q1}
    result.residueSiteElement := ParseString(obj.complex('http://hl7.org/fhir/SubstanceNucleicAcid.subunit.sugar.residueSite'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeSubstanceNucleicAcidSubunitSugar(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstanceNucleicAcidSubunitSugar; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstanceNucleicAcidSubunitSugar'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'SubstanceNucleicAcid.subunit.sugar', 'identifier', elem.identifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SubstanceNucleicAcid.subunit.sugar', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SubstanceNucleicAcid.subunit.sugar', 'residueSite', elem.residueSiteElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseSubstanceNucleicAcid(obj : TTurtleComplex) : TFhirSubstanceNucleicAcid;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstanceNucleicAcid.create;
  try
    ParseSubstanceNucleicAcidProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstanceNucleicAcidProperties(obj : TTurtleComplex; result : TFhirSubstanceNucleicAcid);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.sequenceType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceNucleicAcid.sequenceType'));{q3b}
    result.numberOfSubunitsElement := ParseInteger(obj.complex('http://hl7.org/fhir/SubstanceNucleicAcid.numberOfSubunits'));{q1}
    result.areaOfHybridisationElement := ParseString(obj.complex('http://hl7.org/fhir/SubstanceNucleicAcid.areaOfHybridisation'));{q1}
    result.oligoNucleotideType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceNucleicAcid.oligoNucleotideType'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/SubstanceNucleicAcid.subunit') do
      result.subunitList.Add(parseSubstanceNucleicAcidSubunit(item));
end;

procedure TFHIRTurtleComposer.ComposeSubstanceNucleicAcid(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstanceNucleicAcid; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstanceNucleicAcid'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('sequenceType') then
    ComposeCodeableConcept(this, 'SubstanceNucleicAcid', 'sequenceType', elem.sequenceTypeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('numberOfSubunits') then
    ComposeInteger(this, 'SubstanceNucleicAcid', 'numberOfSubunits', elem.numberOfSubunitsElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('areaOfHybridisation') then
    ComposeString(this, 'SubstanceNucleicAcid', 'areaOfHybridisation', elem.areaOfHybridisationElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('oligoNucleotideType') then
    ComposeCodeableConcept(this, 'SubstanceNucleicAcid', 'oligoNucleotideType', elem.oligoNucleotideTypeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subunit') then
    for i := 0 to elem.subunitList.Count - 1 do
      ComposeSubstanceNucleicAcidSubunit(this, 'SubstanceNucleicAcid', 'subunit', elem.subunitList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_SUBSTANCENUCLEICACID}
{$IFDEF FHIR_SUBSTANCEPOLYMER}
function TFHIRTurtleParser.ParseSubstancePolymerMonomerSet(obj : TTurtleComplex) : TFhirSubstancePolymerMonomerSet;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstancePolymerMonomerSet.create;
  try
    ParseSubstancePolymerMonomerSetProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstancePolymerMonomerSetProperties(obj : TTurtleComplex; result : TFhirSubstancePolymerMonomerSet);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.ratioType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstancePolymer.monomerSet.ratioType'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/SubstancePolymer.monomerSet.startingMaterial') do
      result.startingMaterialList.Add(parseSubstancePolymerMonomerSetStartingMaterial(item));
end;

procedure TFHIRTurtleComposer.ComposeSubstancePolymerMonomerSet(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstancePolymerMonomerSet; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstancePolymerMonomerSet'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstancePolymer.monomerSet', 'ratioType', elem.ratioTypeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.startingMaterialList.Count - 1 do
      ComposeSubstancePolymerMonomerSetStartingMaterial(this, 'SubstancePolymer.monomerSet', 'startingMaterial', elem.startingMaterialList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseSubstancePolymerMonomerSetStartingMaterial(obj : TTurtleComplex) : TFhirSubstancePolymerMonomerSetStartingMaterial;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstancePolymerMonomerSetStartingMaterial.create;
  try
    ParseSubstancePolymerMonomerSetStartingMaterialProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstancePolymerMonomerSetStartingMaterialProperties(obj : TTurtleComplex; result : TFhirSubstancePolymerMonomerSetStartingMaterial);
begin
    ParseBackboneElementProperties(obj, result);
    result.material := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstancePolymer.monomerSet.startingMaterial.material'));{q3b}
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstancePolymer.monomerSet.startingMaterial.type'));{q3b}
    result.isDefiningElement := ParseBoolean(obj.complex('http://hl7.org/fhir/SubstancePolymer.monomerSet.startingMaterial.isDefining'));{q1}
    result.amount := ParseSubstanceAmount(obj.complex('http://hl7.org/fhir/SubstancePolymer.monomerSet.startingMaterial.amount'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeSubstancePolymerMonomerSetStartingMaterial(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstancePolymerMonomerSetStartingMaterial; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstancePolymerMonomerSetStartingMaterial'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstancePolymer.monomerSet.startingMaterial', 'material', elem.materialElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstancePolymer.monomerSet.startingMaterial', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'SubstancePolymer.monomerSet.startingMaterial', 'isDefining', elem.isDefiningElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeSubstanceAmount(this, 'SubstancePolymer.monomerSet.startingMaterial', 'amount', elem.amountElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseSubstancePolymerRepeat(obj : TTurtleComplex) : TFhirSubstancePolymerRepeat;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstancePolymerRepeat.create;
  try
    ParseSubstancePolymerRepeatProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstancePolymerRepeatProperties(obj : TTurtleComplex; result : TFhirSubstancePolymerRepeat);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.numberOfUnitsElement := ParseInteger(obj.complex('http://hl7.org/fhir/SubstancePolymer.repeat.numberOfUnits'));{q1}
    result.averageMolecularFormulaElement := ParseString(obj.complex('http://hl7.org/fhir/SubstancePolymer.repeat.averageMolecularFormula'));{q1}
    result.repeatUnitAmountType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstancePolymer.repeat.repeatUnitAmountType'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/SubstancePolymer.repeat.repeatUnit') do
      result.repeatUnitList.Add(parseSubstancePolymerRepeatRepeatUnit(item));
end;

procedure TFHIRTurtleComposer.ComposeSubstancePolymerRepeat(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstancePolymerRepeat; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstancePolymerRepeat'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(this, 'SubstancePolymer.repeat', 'numberOfUnits', elem.numberOfUnitsElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SubstancePolymer.repeat', 'averageMolecularFormula', elem.averageMolecularFormulaElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstancePolymer.repeat', 'repeatUnitAmountType', elem.repeatUnitAmountTypeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.repeatUnitList.Count - 1 do
      ComposeSubstancePolymerRepeatRepeatUnit(this, 'SubstancePolymer.repeat', 'repeatUnit', elem.repeatUnitList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseSubstancePolymerRepeatRepeatUnit(obj : TTurtleComplex) : TFhirSubstancePolymerRepeatRepeatUnit;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstancePolymerRepeatRepeatUnit.create;
  try
    ParseSubstancePolymerRepeatRepeatUnitProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstancePolymerRepeatRepeatUnitProperties(obj : TTurtleComplex; result : TFhirSubstancePolymerRepeatRepeatUnit);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.orientationOfPolymerisation := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstancePolymer.repeat.repeatUnit.orientationOfPolymerisation'));{q3b}
    result.repeatUnitElement := ParseString(obj.complex('http://hl7.org/fhir/SubstancePolymer.repeat.repeatUnit.repeatUnit'));{q1}
    result.amount := ParseSubstanceAmount(obj.complex('http://hl7.org/fhir/SubstancePolymer.repeat.repeatUnit.amount'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/SubstancePolymer.repeat.repeatUnit.degreeOfPolymerisation') do
      result.degreeOfPolymerisationList.Add(parseSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation(item));
    for item in obj.complexes('http://hl7.org/fhir/SubstancePolymer.repeat.repeatUnit.structuralRepresentation') do
      result.structuralRepresentationList.Add(parseSubstancePolymerRepeatRepeatUnitStructuralRepresentation(item));
end;

procedure TFHIRTurtleComposer.ComposeSubstancePolymerRepeatRepeatUnit(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstancePolymerRepeatRepeatUnit; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstancePolymerRepeatRepeatUnit'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstancePolymer.repeat.repeatUnit', 'orientationOfPolymerisation', elem.orientationOfPolymerisationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SubstancePolymer.repeat.repeatUnit', 'repeatUnit', elem.repeatUnitElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeSubstanceAmount(this, 'SubstancePolymer.repeat.repeatUnit', 'amount', elem.amountElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.degreeOfPolymerisationList.Count - 1 do
      ComposeSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation(this, 'SubstancePolymer.repeat.repeatUnit', 'degreeOfPolymerisation', elem.degreeOfPolymerisationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.structuralRepresentationList.Count - 1 do
      ComposeSubstancePolymerRepeatRepeatUnitStructuralRepresentation(this, 'SubstancePolymer.repeat.repeatUnit', 'structuralRepresentation', elem.structuralRepresentationList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation(obj : TTurtleComplex) : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.create;
  try
    ParseSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationProperties(obj : TTurtleComplex; result : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation);
begin
    ParseBackboneElementProperties(obj, result);
    result.degree := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstancePolymer.repeat.repeatUnit.degreeOfPolymerisation.degree'));{q3b}
    result.amount := ParseSubstanceAmount(obj.complex('http://hl7.org/fhir/SubstancePolymer.repeat.repeatUnit.degreeOfPolymerisation.amount'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstancePolymer.repeat.repeatUnit.degreeOfPolymerisation', 'degree', elem.degreeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeSubstanceAmount(this, 'SubstancePolymer.repeat.repeatUnit.degreeOfPolymerisation', 'amount', elem.amountElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseSubstancePolymerRepeatRepeatUnitStructuralRepresentation(obj : TTurtleComplex) : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.create;
  try
    ParseSubstancePolymerRepeatRepeatUnitStructuralRepresentationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstancePolymerRepeatRepeatUnitStructuralRepresentationProperties(obj : TTurtleComplex; result : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation);
begin
    ParseBackboneElementProperties(obj, result);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstancePolymer.repeat.repeatUnit.structuralRepresentation.type'));{q3b}
    result.representationElement := ParseString(obj.complex('http://hl7.org/fhir/SubstancePolymer.repeat.repeatUnit.structuralRepresentation.representation'));{q1}
    result.attachment := ParseAttachment(obj.complex('http://hl7.org/fhir/SubstancePolymer.repeat.repeatUnit.structuralRepresentation.attachment'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeSubstancePolymerRepeatRepeatUnitStructuralRepresentation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstancePolymerRepeatRepeatUnitStructuralRepresentation'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstancePolymer.repeat.repeatUnit.structuralRepresentation', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SubstancePolymer.repeat.repeatUnit.structuralRepresentation', 'representation', elem.representationElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeAttachment(this, 'SubstancePolymer.repeat.repeatUnit.structuralRepresentation', 'attachment', elem.attachmentElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseSubstancePolymer(obj : TTurtleComplex) : TFhirSubstancePolymer;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstancePolymer.create;
  try
    ParseSubstancePolymerProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstancePolymerProperties(obj : TTurtleComplex; result : TFhirSubstancePolymer);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.class_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstancePolymer.class'));{q3b}
    result.geometry := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstancePolymer.geometry'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/SubstancePolymer.copolymerConnectivity') do
      result.copolymerConnectivityList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/SubstancePolymer.modification') do
      result.modificationList.Add(parseString(item));
    for item in obj.complexes('http://hl7.org/fhir/SubstancePolymer.monomerSet') do
      result.monomerSetList.Add(parseSubstancePolymerMonomerSet(item));
    for item in obj.complexes('http://hl7.org/fhir/SubstancePolymer.repeat') do
      result.repeat_List.Add(parseSubstancePolymerRepeat(item));
end;

procedure TFHIRTurtleComposer.ComposeSubstancePolymer(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstancePolymer; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstancePolymer'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('class_') then
    ComposeCodeableConcept(this, 'SubstancePolymer', 'class', elem.class_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('geometry') then
    ComposeCodeableConcept(this, 'SubstancePolymer', 'geometry', elem.geometryElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('copolymerConnectivity') then
    for i := 0 to elem.copolymerConnectivityList.Count - 1 do
      ComposeCodeableConcept(this, 'SubstancePolymer', 'copolymerConnectivity', elem.copolymerConnectivityList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('modification') then
    for i := 0 to elem.modificationList.Count - 1 do
      ComposeString(this, 'SubstancePolymer', 'modification', elem.modificationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('monomerSet') then
    for i := 0 to elem.monomerSetList.Count - 1 do
      ComposeSubstancePolymerMonomerSet(this, 'SubstancePolymer', 'monomerSet', elem.monomerSetList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('repeat_') then
    for i := 0 to elem.repeat_List.Count - 1 do
      ComposeSubstancePolymerRepeat(this, 'SubstancePolymer', 'repeat', elem.repeat_List[i], false, i);{x.d3}
end;

{$ENDIF FHIR_SUBSTANCEPOLYMER}
{$IFDEF FHIR_SUBSTANCEPROTEIN}
function TFHIRTurtleParser.ParseSubstanceProteinSubunit(obj : TTurtleComplex) : TFhirSubstanceProteinSubunit;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstanceProteinSubunit.create;
  try
    ParseSubstanceProteinSubunitProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstanceProteinSubunitProperties(obj : TTurtleComplex; result : TFhirSubstanceProteinSubunit);
begin
    ParseBackboneElementProperties(obj, result);
    result.subunitElement := ParseInteger(obj.complex('http://hl7.org/fhir/SubstanceProtein.subunit.subunit'));{q1}
    result.sequenceElement := ParseString(obj.complex('http://hl7.org/fhir/SubstanceProtein.subunit.sequence'));{q1}
    result.lengthElement := ParseInteger(obj.complex('http://hl7.org/fhir/SubstanceProtein.subunit.length'));{q1}
    result.sequenceAttachment := ParseAttachment(obj.complex('http://hl7.org/fhir/SubstanceProtein.subunit.sequenceAttachment'));{q3b}
    result.nTerminalModificationId := ParseIdentifier(obj.complex('http://hl7.org/fhir/SubstanceProtein.subunit.nTerminalModificationId'));{q3b}
    result.nTerminalModificationElement := ParseString(obj.complex('http://hl7.org/fhir/SubstanceProtein.subunit.nTerminalModification'));{q1}
    result.cTerminalModificationId := ParseIdentifier(obj.complex('http://hl7.org/fhir/SubstanceProtein.subunit.cTerminalModificationId'));{q3b}
    result.cTerminalModificationElement := ParseString(obj.complex('http://hl7.org/fhir/SubstanceProtein.subunit.cTerminalModification'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeSubstanceProteinSubunit(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstanceProteinSubunit; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstanceProteinSubunit'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(this, 'SubstanceProtein.subunit', 'subunit', elem.subunitElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SubstanceProtein.subunit', 'sequence', elem.sequenceElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(this, 'SubstanceProtein.subunit', 'length', elem.lengthElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeAttachment(this, 'SubstanceProtein.subunit', 'sequenceAttachment', elem.sequenceAttachmentElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'SubstanceProtein.subunit', 'nTerminalModificationId', elem.nTerminalModificationIdElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SubstanceProtein.subunit', 'nTerminalModification', elem.nTerminalModificationElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'SubstanceProtein.subunit', 'cTerminalModificationId', elem.cTerminalModificationIdElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SubstanceProtein.subunit', 'cTerminalModification', elem.cTerminalModificationElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseSubstanceProtein(obj : TTurtleComplex) : TFhirSubstanceProtein;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstanceProtein.create;
  try
    ParseSubstanceProteinProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstanceProteinProperties(obj : TTurtleComplex; result : TFhirSubstanceProtein);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.sequenceType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceProtein.sequenceType'));{q3b}
    result.numberOfSubunitsElement := ParseInteger(obj.complex('http://hl7.org/fhir/SubstanceProtein.numberOfSubunits'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/SubstanceProtein.disulfideLinkage') do
      result.disulfideLinkageList.Add(parseString(item));
    for item in obj.complexes('http://hl7.org/fhir/SubstanceProtein.subunit') do
      result.subunitList.Add(parseSubstanceProteinSubunit(item));
end;

procedure TFHIRTurtleComposer.ComposeSubstanceProtein(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstanceProtein; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstanceProtein'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('sequenceType') then
    ComposeCodeableConcept(this, 'SubstanceProtein', 'sequenceType', elem.sequenceTypeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('numberOfSubunits') then
    ComposeInteger(this, 'SubstanceProtein', 'numberOfSubunits', elem.numberOfSubunitsElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('disulfideLinkage') then
    for i := 0 to elem.disulfideLinkageList.Count - 1 do
      ComposeString(this, 'SubstanceProtein', 'disulfideLinkage', elem.disulfideLinkageList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subunit') then
    for i := 0 to elem.subunitList.Count - 1 do
      ComposeSubstanceProteinSubunit(this, 'SubstanceProtein', 'subunit', elem.subunitList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_SUBSTANCEPROTEIN}
{$IFDEF FHIR_SUBSTANCEREFERENCEINFORMATION}
function TFHIRTurtleParser.ParseSubstanceReferenceInformationGene(obj : TTurtleComplex) : TFhirSubstanceReferenceInformationGene;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstanceReferenceInformationGene.create;
  try
    ParseSubstanceReferenceInformationGeneProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstanceReferenceInformationGeneProperties(obj : TTurtleComplex; result : TFhirSubstanceReferenceInformationGene);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.geneSequenceOrigin := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceReferenceInformation.gene.geneSequenceOrigin'));{q3b}
    result.gene := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceReferenceInformation.gene.gene'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/SubstanceReferenceInformation.gene.source') do
      result.sourceList.Add(parseReference{TFhirDocumentReference}(item));
end;

procedure TFHIRTurtleComposer.ComposeSubstanceReferenceInformationGene(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstanceReferenceInformationGene; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstanceReferenceInformationGene'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceReferenceInformation.gene', 'geneSequenceOrigin', elem.geneSequenceOriginElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceReferenceInformation.gene', 'gene', elem.geneElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.sourceList.Count - 1 do
      ComposeReference{TFhirDocumentReference}(this, 'SubstanceReferenceInformation.gene', 'source', elem.sourceList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseSubstanceReferenceInformationGeneElement(obj : TTurtleComplex) : TFhirSubstanceReferenceInformationGeneElement;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstanceReferenceInformationGeneElement.create;
  try
    ParseSubstanceReferenceInformationGeneElementProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstanceReferenceInformationGeneElementProperties(obj : TTurtleComplex; result : TFhirSubstanceReferenceInformationGeneElement);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceReferenceInformation.geneElement.type'));{q3b}
    result.element := ParseIdentifier(obj.complex('http://hl7.org/fhir/SubstanceReferenceInformation.geneElement.element'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/SubstanceReferenceInformation.geneElement.source') do
      result.sourceList.Add(parseReference{TFhirDocumentReference}(item));
end;

procedure TFHIRTurtleComposer.ComposeSubstanceReferenceInformationGeneElement(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstanceReferenceInformationGeneElement; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstanceReferenceInformationGeneElement'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceReferenceInformation.geneElement', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'SubstanceReferenceInformation.geneElement', 'element', elem.elementElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.sourceList.Count - 1 do
      ComposeReference{TFhirDocumentReference}(this, 'SubstanceReferenceInformation.geneElement', 'source', elem.sourceList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseSubstanceReferenceInformationClassification(obj : TTurtleComplex) : TFhirSubstanceReferenceInformationClassification;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstanceReferenceInformationClassification.create;
  try
    ParseSubstanceReferenceInformationClassificationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstanceReferenceInformationClassificationProperties(obj : TTurtleComplex; result : TFhirSubstanceReferenceInformationClassification);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.domain := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceReferenceInformation.classification.domain'));{q3b}
    result.classification := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceReferenceInformation.classification.classification'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/SubstanceReferenceInformation.classification.subtype') do
      result.subtypeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/SubstanceReferenceInformation.classification.source') do
      result.sourceList.Add(parseReference{TFhirDocumentReference}(item));
end;

procedure TFHIRTurtleComposer.ComposeSubstanceReferenceInformationClassification(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstanceReferenceInformationClassification; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstanceReferenceInformationClassification'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceReferenceInformation.classification', 'domain', elem.domainElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceReferenceInformation.classification', 'classification', elem.classificationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.subtypeList.Count - 1 do
      ComposeCodeableConcept(this, 'SubstanceReferenceInformation.classification', 'subtype', elem.subtypeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.sourceList.Count - 1 do
      ComposeReference{TFhirDocumentReference}(this, 'SubstanceReferenceInformation.classification', 'source', elem.sourceList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseSubstanceReferenceInformationTarget(obj : TTurtleComplex) : TFhirSubstanceReferenceInformationTarget;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstanceReferenceInformationTarget.create;
  try
    ParseSubstanceReferenceInformationTargetProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstanceReferenceInformationTargetProperties(obj : TTurtleComplex; result : TFhirSubstanceReferenceInformationTarget);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.target := ParseIdentifier(obj.complex('http://hl7.org/fhir/SubstanceReferenceInformation.target.target'));{q3b}
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceReferenceInformation.target.type'));{q3b}
    result.interaction := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceReferenceInformation.target.interaction'));{q3b}
    result.organism := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceReferenceInformation.target.organism'));{q3b}
    result.organismType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceReferenceInformation.target.organismType'));{q3b}
    if obj.has('http://hl7.org/fhir/SubstanceReferenceInformation.target.amountQuantity', item) then
      result.amount := parseQuantity(item);
    if obj.has('http://hl7.org/fhir/SubstanceReferenceInformation.target.amountRange', item) then
      result.amount := parseRange(item);
    if obj.has('http://hl7.org/fhir/SubstanceReferenceInformation.target.amountString', item) then
      result.amount := parseString(item);
    result.amountType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceReferenceInformation.target.amountType'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/SubstanceReferenceInformation.target.source') do
      result.sourceList.Add(parseReference{TFhirDocumentReference}(item));
end;

procedure TFHIRTurtleComposer.ComposeSubstanceReferenceInformationTarget(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstanceReferenceInformationTarget; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstanceReferenceInformationTarget'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'SubstanceReferenceInformation.target', 'target', elem.targetElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceReferenceInformation.target', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceReferenceInformation.target', 'interaction', elem.interactionElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceReferenceInformation.target', 'organism', elem.organismElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceReferenceInformation.target', 'organismType', elem.organismTypeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.amount is TFhirQuantity) {6} then
    ComposeQuantity(this, 'SubstanceReferenceInformation.target', 'amountQuantity', TFhirQuantity(elem.amount), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.amount is TFhirRange) {6} then
    ComposeRange(this, 'SubstanceReferenceInformation.target', 'amountRange', TFhirRange(elem.amount), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.amount is TFhirString) {6} then
    ComposeString(this, 'SubstanceReferenceInformation.target', 'amountString', TFhirString(elem.amount), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceReferenceInformation.target', 'amountType', elem.amountTypeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.sourceList.Count - 1 do
      ComposeReference{TFhirDocumentReference}(this, 'SubstanceReferenceInformation.target', 'source', elem.sourceList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseSubstanceReferenceInformation(obj : TTurtleComplex) : TFhirSubstanceReferenceInformation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstanceReferenceInformation.create;
  try
    ParseSubstanceReferenceInformationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstanceReferenceInformationProperties(obj : TTurtleComplex; result : TFhirSubstanceReferenceInformation);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.commentElement := ParseString(obj.complex('http://hl7.org/fhir/SubstanceReferenceInformation.comment'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/SubstanceReferenceInformation.gene') do
      result.geneList.Add(parseSubstanceReferenceInformationGene(item));
    for item in obj.complexes('http://hl7.org/fhir/SubstanceReferenceInformation.geneElement') do
      result.geneElementList.Add(parseSubstanceReferenceInformationGeneElement(item));
    for item in obj.complexes('http://hl7.org/fhir/SubstanceReferenceInformation.classification') do
      result.classificationList.Add(parseSubstanceReferenceInformationClassification(item));
    for item in obj.complexes('http://hl7.org/fhir/SubstanceReferenceInformation.target') do
      result.targetList.Add(parseSubstanceReferenceInformationTarget(item));
end;

procedure TFHIRTurtleComposer.ComposeSubstanceReferenceInformation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstanceReferenceInformation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstanceReferenceInformation'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('comment') then
    ComposeString(this, 'SubstanceReferenceInformation', 'comment', elem.commentElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('gene') then
    for i := 0 to elem.geneList.Count - 1 do
      ComposeSubstanceReferenceInformationGene(this, 'SubstanceReferenceInformation', 'gene', elem.geneList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('geneElement') then
    for i := 0 to elem.geneElementList.Count - 1 do
      ComposeSubstanceReferenceInformationGeneElement(this, 'SubstanceReferenceInformation', 'geneElement', elem.geneElementList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('classification') then
    for i := 0 to elem.classificationList.Count - 1 do
      ComposeSubstanceReferenceInformationClassification(this, 'SubstanceReferenceInformation', 'classification', elem.classificationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('target') then
    for i := 0 to elem.targetList.Count - 1 do
      ComposeSubstanceReferenceInformationTarget(this, 'SubstanceReferenceInformation', 'target', elem.targetList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_SUBSTANCEREFERENCEINFORMATION}
{$IFDEF FHIR_SUBSTANCESOURCEMATERIAL}
function TFHIRTurtleParser.ParseSubstanceSourceMaterialFractionDescription(obj : TTurtleComplex) : TFhirSubstanceSourceMaterialFractionDescription;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstanceSourceMaterialFractionDescription.create;
  try
    ParseSubstanceSourceMaterialFractionDescriptionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstanceSourceMaterialFractionDescriptionProperties(obj : TTurtleComplex; result : TFhirSubstanceSourceMaterialFractionDescription);
begin
    ParseBackboneElementProperties(obj, result);
    result.fractionElement := ParseString(obj.complex('http://hl7.org/fhir/SubstanceSourceMaterial.fractionDescription.fraction'));{q1}
    result.materialType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceSourceMaterial.fractionDescription.materialType'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeSubstanceSourceMaterialFractionDescription(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstanceSourceMaterialFractionDescription; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstanceSourceMaterialFractionDescription'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SubstanceSourceMaterial.fractionDescription', 'fraction', elem.fractionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceSourceMaterial.fractionDescription', 'materialType', elem.materialTypeElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseSubstanceSourceMaterialOrganism(obj : TTurtleComplex) : TFhirSubstanceSourceMaterialOrganism;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstanceSourceMaterialOrganism.create;
  try
    ParseSubstanceSourceMaterialOrganismProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstanceSourceMaterialOrganismProperties(obj : TTurtleComplex; result : TFhirSubstanceSourceMaterialOrganism);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.family := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceSourceMaterial.organism.family'));{q3b}
    result.genus := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceSourceMaterial.organism.genus'));{q3b}
    result.species := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceSourceMaterial.organism.species'));{q3b}
    result.intraspecificType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceSourceMaterial.organism.intraspecificType'));{q3b}
    result.intraspecificDescriptionElement := ParseString(obj.complex('http://hl7.org/fhir/SubstanceSourceMaterial.organism.intraspecificDescription'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/SubstanceSourceMaterial.organism.author') do
      result.authorList.Add(parseSubstanceSourceMaterialOrganismAuthor(item));
    result.hybrid := ParseSubstanceSourceMaterialOrganismHybrid(obj.complex('http://hl7.org/fhir/SubstanceSourceMaterial.organism.hybrid'));{q3b}
    result.organismGeneral := ParseSubstanceSourceMaterialOrganismOrganismGeneral(obj.complex('http://hl7.org/fhir/SubstanceSourceMaterial.organism.organismGeneral'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeSubstanceSourceMaterialOrganism(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstanceSourceMaterialOrganism; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstanceSourceMaterialOrganism'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceSourceMaterial.organism', 'family', elem.familyElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceSourceMaterial.organism', 'genus', elem.genusElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceSourceMaterial.organism', 'species', elem.speciesElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceSourceMaterial.organism', 'intraspecificType', elem.intraspecificTypeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SubstanceSourceMaterial.organism', 'intraspecificDescription', elem.intraspecificDescriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.authorList.Count - 1 do
      ComposeSubstanceSourceMaterialOrganismAuthor(this, 'SubstanceSourceMaterial.organism', 'author', elem.authorList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeSubstanceSourceMaterialOrganismHybrid(this, 'SubstanceSourceMaterial.organism', 'hybrid', elem.hybridElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeSubstanceSourceMaterialOrganismOrganismGeneral(this, 'SubstanceSourceMaterial.organism', 'organismGeneral', elem.organismGeneralElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseSubstanceSourceMaterialOrganismAuthor(obj : TTurtleComplex) : TFhirSubstanceSourceMaterialOrganismAuthor;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstanceSourceMaterialOrganismAuthor.create;
  try
    ParseSubstanceSourceMaterialOrganismAuthorProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstanceSourceMaterialOrganismAuthorProperties(obj : TTurtleComplex; result : TFhirSubstanceSourceMaterialOrganismAuthor);
begin
    ParseBackboneElementProperties(obj, result);
    result.authorType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceSourceMaterial.organism.author.authorType'));{q3b}
    result.authorDescriptionElement := ParseString(obj.complex('http://hl7.org/fhir/SubstanceSourceMaterial.organism.author.authorDescription'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeSubstanceSourceMaterialOrganismAuthor(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstanceSourceMaterialOrganismAuthor; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstanceSourceMaterialOrganismAuthor'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceSourceMaterial.organism.author', 'authorType', elem.authorTypeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SubstanceSourceMaterial.organism.author', 'authorDescription', elem.authorDescriptionElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseSubstanceSourceMaterialOrganismHybrid(obj : TTurtleComplex) : TFhirSubstanceSourceMaterialOrganismHybrid;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstanceSourceMaterialOrganismHybrid.create;
  try
    ParseSubstanceSourceMaterialOrganismHybridProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstanceSourceMaterialOrganismHybridProperties(obj : TTurtleComplex; result : TFhirSubstanceSourceMaterialOrganismHybrid);
begin
    ParseBackboneElementProperties(obj, result);
    result.maternalOrganismIdElement := ParseString(obj.complex('http://hl7.org/fhir/SubstanceSourceMaterial.organism.hybrid.maternalOrganismId'));{q1}
    result.maternalOrganismNameElement := ParseString(obj.complex('http://hl7.org/fhir/SubstanceSourceMaterial.organism.hybrid.maternalOrganismName'));{q1}
    result.paternalOrganismIdElement := ParseString(obj.complex('http://hl7.org/fhir/SubstanceSourceMaterial.organism.hybrid.paternalOrganismId'));{q1}
    result.paternalOrganismNameElement := ParseString(obj.complex('http://hl7.org/fhir/SubstanceSourceMaterial.organism.hybrid.paternalOrganismName'));{q1}
    result.hybridType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceSourceMaterial.organism.hybrid.hybridType'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeSubstanceSourceMaterialOrganismHybrid(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstanceSourceMaterialOrganismHybrid; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstanceSourceMaterialOrganismHybrid'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SubstanceSourceMaterial.organism.hybrid', 'maternalOrganismId', elem.maternalOrganismIdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SubstanceSourceMaterial.organism.hybrid', 'maternalOrganismName', elem.maternalOrganismNameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SubstanceSourceMaterial.organism.hybrid', 'paternalOrganismId', elem.paternalOrganismIdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SubstanceSourceMaterial.organism.hybrid', 'paternalOrganismName', elem.paternalOrganismNameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceSourceMaterial.organism.hybrid', 'hybridType', elem.hybridTypeElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseSubstanceSourceMaterialOrganismOrganismGeneral(obj : TTurtleComplex) : TFhirSubstanceSourceMaterialOrganismOrganismGeneral;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstanceSourceMaterialOrganismOrganismGeneral.create;
  try
    ParseSubstanceSourceMaterialOrganismOrganismGeneralProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstanceSourceMaterialOrganismOrganismGeneralProperties(obj : TTurtleComplex; result : TFhirSubstanceSourceMaterialOrganismOrganismGeneral);
begin
    ParseBackboneElementProperties(obj, result);
    result.kingdom := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceSourceMaterial.organism.organismGeneral.kingdom'));{q3b}
    result.phylum := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceSourceMaterial.organism.organismGeneral.phylum'));{q3b}
    result.class_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceSourceMaterial.organism.organismGeneral.class'));{q3b}
    result.order := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceSourceMaterial.organism.organismGeneral.order'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeSubstanceSourceMaterialOrganismOrganismGeneral(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstanceSourceMaterialOrganismOrganismGeneral; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstanceSourceMaterialOrganismOrganismGeneral'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceSourceMaterial.organism.organismGeneral', 'kingdom', elem.kingdomElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceSourceMaterial.organism.organismGeneral', 'phylum', elem.phylumElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceSourceMaterial.organism.organismGeneral', 'class', elem.class_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceSourceMaterial.organism.organismGeneral', 'order', elem.orderElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseSubstanceSourceMaterialPartDescription(obj : TTurtleComplex) : TFhirSubstanceSourceMaterialPartDescription;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstanceSourceMaterialPartDescription.create;
  try
    ParseSubstanceSourceMaterialPartDescriptionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstanceSourceMaterialPartDescriptionProperties(obj : TTurtleComplex; result : TFhirSubstanceSourceMaterialPartDescription);
begin
    ParseBackboneElementProperties(obj, result);
    result.part := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceSourceMaterial.partDescription.part'));{q3b}
    result.partLocation := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceSourceMaterial.partDescription.partLocation'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeSubstanceSourceMaterialPartDescription(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstanceSourceMaterialPartDescription; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstanceSourceMaterialPartDescription'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceSourceMaterial.partDescription', 'part', elem.partElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceSourceMaterial.partDescription', 'partLocation', elem.partLocationElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseSubstanceSourceMaterial(obj : TTurtleComplex) : TFhirSubstanceSourceMaterial;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstanceSourceMaterial.create;
  try
    ParseSubstanceSourceMaterialProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstanceSourceMaterialProperties(obj : TTurtleComplex; result : TFhirSubstanceSourceMaterial);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.sourceMaterialClass := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceSourceMaterial.sourceMaterialClass'));{q3b}
    result.sourceMaterialType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceSourceMaterial.sourceMaterialType'));{q3b}
    result.sourceMaterialState := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceSourceMaterial.sourceMaterialState'));{q3b}
    result.organismId := ParseIdentifier(obj.complex('http://hl7.org/fhir/SubstanceSourceMaterial.organismId'));{q3b}
    result.organismNameElement := ParseString(obj.complex('http://hl7.org/fhir/SubstanceSourceMaterial.organismName'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/SubstanceSourceMaterial.parentSubstanceId') do
      result.parentSubstanceIdList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/SubstanceSourceMaterial.parentSubstanceName') do
      result.parentSubstanceNameList.Add(parseString(item));
    for item in obj.complexes('http://hl7.org/fhir/SubstanceSourceMaterial.countryOfOrigin') do
      result.countryOfOriginList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/SubstanceSourceMaterial.geographicalLocation') do
      result.geographicalLocationList.Add(parseString(item));
    result.developmentStage := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceSourceMaterial.developmentStage'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/SubstanceSourceMaterial.fractionDescription') do
      result.fractionDescriptionList.Add(parseSubstanceSourceMaterialFractionDescription(item));
    result.organism := ParseSubstanceSourceMaterialOrganism(obj.complex('http://hl7.org/fhir/SubstanceSourceMaterial.organism'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/SubstanceSourceMaterial.partDescription') do
      result.partDescriptionList.Add(parseSubstanceSourceMaterialPartDescription(item));
end;

procedure TFHIRTurtleComposer.ComposeSubstanceSourceMaterial(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstanceSourceMaterial; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstanceSourceMaterial'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('sourceMaterialClass') then
    ComposeCodeableConcept(this, 'SubstanceSourceMaterial', 'sourceMaterialClass', elem.sourceMaterialClassElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('sourceMaterialType') then
    ComposeCodeableConcept(this, 'SubstanceSourceMaterial', 'sourceMaterialType', elem.sourceMaterialTypeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('sourceMaterialState') then
    ComposeCodeableConcept(this, 'SubstanceSourceMaterial', 'sourceMaterialState', elem.sourceMaterialStateElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('organismId') then
    ComposeIdentifier(this, 'SubstanceSourceMaterial', 'organismId', elem.organismIdElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('organismName') then
    ComposeString(this, 'SubstanceSourceMaterial', 'organismName', elem.organismNameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('parentSubstanceId') then
    for i := 0 to elem.parentSubstanceIdList.Count - 1 do
      ComposeIdentifier(this, 'SubstanceSourceMaterial', 'parentSubstanceId', elem.parentSubstanceIdList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('parentSubstanceName') then
    for i := 0 to elem.parentSubstanceNameList.Count - 1 do
      ComposeString(this, 'SubstanceSourceMaterial', 'parentSubstanceName', elem.parentSubstanceNameList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('countryOfOrigin') then
    for i := 0 to elem.countryOfOriginList.Count - 1 do
      ComposeCodeableConcept(this, 'SubstanceSourceMaterial', 'countryOfOrigin', elem.countryOfOriginList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('geographicalLocation') then
    for i := 0 to elem.geographicalLocationList.Count - 1 do
      ComposeString(this, 'SubstanceSourceMaterial', 'geographicalLocation', elem.geographicalLocationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('developmentStage') then
    ComposeCodeableConcept(this, 'SubstanceSourceMaterial', 'developmentStage', elem.developmentStageElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('fractionDescription') then
    for i := 0 to elem.fractionDescriptionList.Count - 1 do
      ComposeSubstanceSourceMaterialFractionDescription(this, 'SubstanceSourceMaterial', 'fractionDescription', elem.fractionDescriptionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('organism') then
    ComposeSubstanceSourceMaterialOrganism(this, 'SubstanceSourceMaterial', 'organism', elem.organismElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('partDescription') then
    for i := 0 to elem.partDescriptionList.Count - 1 do
      ComposeSubstanceSourceMaterialPartDescription(this, 'SubstanceSourceMaterial', 'partDescription', elem.partDescriptionList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_SUBSTANCESOURCEMATERIAL}
{$IFDEF FHIR_SUBSTANCESPECIFICATION}
function TFHIRTurtleParser.ParseSubstanceSpecificationMoiety(obj : TTurtleComplex) : TFhirSubstanceSpecificationMoiety;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstanceSpecificationMoiety.create;
  try
    ParseSubstanceSpecificationMoietyProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstanceSpecificationMoietyProperties(obj : TTurtleComplex; result : TFhirSubstanceSpecificationMoiety);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.role := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceSpecification.moiety.role'));{q3b}
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/SubstanceSpecification.moiety.identifier'));{q3b}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/SubstanceSpecification.moiety.name'));{q1}
    result.stereochemistry := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceSpecification.moiety.stereochemistry'));{q3b}
    result.opticalActivity := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceSpecification.moiety.opticalActivity'));{q3b}
    result.molecularFormulaElement := ParseString(obj.complex('http://hl7.org/fhir/SubstanceSpecification.moiety.molecularFormula'));{q1}
    if obj.has('http://hl7.org/fhir/SubstanceSpecification.moiety.amountQuantity', item) then
      result.amount := parseQuantity(item);
    if obj.has('http://hl7.org/fhir/SubstanceSpecification.moiety.amountString', item) then
      result.amount := parseString(item);
end;

procedure TFHIRTurtleComposer.ComposeSubstanceSpecificationMoiety(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstanceSpecificationMoiety; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstanceSpecificationMoiety'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceSpecification.moiety', 'role', elem.roleElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'SubstanceSpecification.moiety', 'identifier', elem.identifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SubstanceSpecification.moiety', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceSpecification.moiety', 'stereochemistry', elem.stereochemistryElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceSpecification.moiety', 'opticalActivity', elem.opticalActivityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SubstanceSpecification.moiety', 'molecularFormula', elem.molecularFormulaElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.amount is TFhirQuantity) {6} then
    ComposeQuantity(this, 'SubstanceSpecification.moiety', 'amountQuantity', TFhirQuantity(elem.amount), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.amount is TFhirString) {6} then
    ComposeString(this, 'SubstanceSpecification.moiety', 'amountString', TFhirString(elem.amount), false, -1);{x.d9}
end;

function TFHIRTurtleParser.ParseSubstanceSpecificationProperty(obj : TTurtleComplex) : TFhirSubstanceSpecificationProperty;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstanceSpecificationProperty.create;
  try
    ParseSubstanceSpecificationPropertyProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstanceSpecificationPropertyProperties(obj : TTurtleComplex; result : TFhirSubstanceSpecificationProperty);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceSpecification.property.category'));{q3b}
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceSpecification.property.code'));{q3b}
    result.parametersElement := ParseString(obj.complex('http://hl7.org/fhir/SubstanceSpecification.property.parameters'));{q1}
    if obj.has('http://hl7.org/fhir/SubstanceSpecification.property.definingSubstanceReference', item) {a3} then
      result.definingSubstance := ParseReference(item);
    if obj.has('http://hl7.org/fhir/SubstanceSpecification.property.definingSubstanceCodeableConcept', item) then
      result.definingSubstance := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/SubstanceSpecification.property.amountQuantity', item) then
      result.amount := parseQuantity(item);
    if obj.has('http://hl7.org/fhir/SubstanceSpecification.property.amountString', item) then
      result.amount := parseString(item);
end;

procedure TFHIRTurtleComposer.ComposeSubstanceSpecificationProperty(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstanceSpecificationProperty; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstanceSpecificationProperty'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceSpecification.property', 'category', elem.categoryElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceSpecification.property', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SubstanceSpecification.property', 'parameters', elem.parametersElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.definingSubstance is TFhirReference) {2} then
    ComposeReference(this, 'SubstanceSpecification.property', 'definingSubstanceReference', TFhirReference(elem.definingSubstance), false,-1){x.d8}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.definingSubstance is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'SubstanceSpecification.property', 'definingSubstanceCodeableConcept', TFhirCodeableConcept(elem.definingSubstance), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.amount is TFhirQuantity) {6} then
    ComposeQuantity(this, 'SubstanceSpecification.property', 'amountQuantity', TFhirQuantity(elem.amount), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.amount is TFhirString) {6} then
    ComposeString(this, 'SubstanceSpecification.property', 'amountString', TFhirString(elem.amount), false, -1);{x.d9}
end;

function TFHIRTurtleParser.ParseSubstanceSpecificationStructure(obj : TTurtleComplex) : TFhirSubstanceSpecificationStructure;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstanceSpecificationStructure.create;
  try
    ParseSubstanceSpecificationStructureProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstanceSpecificationStructureProperties(obj : TTurtleComplex; result : TFhirSubstanceSpecificationStructure);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.stereochemistry := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceSpecification.structure.stereochemistry'));{q3b}
    result.opticalActivity := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceSpecification.structure.opticalActivity'));{q3b}
    result.molecularFormulaElement := ParseString(obj.complex('http://hl7.org/fhir/SubstanceSpecification.structure.molecularFormula'));{q1}
    result.molecularFormulaByMoietyElement := ParseString(obj.complex('http://hl7.org/fhir/SubstanceSpecification.structure.molecularFormulaByMoiety'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/SubstanceSpecification.structure.isotope') do
      result.isotopeList.Add(parseSubstanceSpecificationStructureIsotope(item));
    result.molecularWeight := ParseSubstanceSpecificationStructureIsotopeMolecularWeight(obj.complex('http://hl7.org/fhir/SubstanceSpecification.structure.molecularWeight'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/SubstanceSpecification.structure.source') do
      result.sourceList.Add(parseReference{TFhirDocumentReference}(item));
    for item in obj.complexes('http://hl7.org/fhir/SubstanceSpecification.structure.representation') do
      result.representationList.Add(parseSubstanceSpecificationStructureRepresentation(item));
end;

procedure TFHIRTurtleComposer.ComposeSubstanceSpecificationStructure(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstanceSpecificationStructure; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstanceSpecificationStructure'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceSpecification.structure', 'stereochemistry', elem.stereochemistryElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceSpecification.structure', 'opticalActivity', elem.opticalActivityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SubstanceSpecification.structure', 'molecularFormula', elem.molecularFormulaElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SubstanceSpecification.structure', 'molecularFormulaByMoiety', elem.molecularFormulaByMoietyElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.isotopeList.Count - 1 do
      ComposeSubstanceSpecificationStructureIsotope(this, 'SubstanceSpecification.structure', 'isotope', elem.isotopeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeSubstanceSpecificationStructureIsotopeMolecularWeight(this, 'SubstanceSpecification.structure', 'molecularWeight', elem.molecularWeightElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.sourceList.Count - 1 do
      ComposeReference{TFhirDocumentReference}(this, 'SubstanceSpecification.structure', 'source', elem.sourceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.representationList.Count - 1 do
      ComposeSubstanceSpecificationStructureRepresentation(this, 'SubstanceSpecification.structure', 'representation', elem.representationList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseSubstanceSpecificationStructureIsotope(obj : TTurtleComplex) : TFhirSubstanceSpecificationStructureIsotope;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstanceSpecificationStructureIsotope.create;
  try
    ParseSubstanceSpecificationStructureIsotopeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstanceSpecificationStructureIsotopeProperties(obj : TTurtleComplex; result : TFhirSubstanceSpecificationStructureIsotope);
begin
    ParseBackboneElementProperties(obj, result);
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/SubstanceSpecification.structure.isotope.identifier'));{q3b}
    result.name := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceSpecification.structure.isotope.name'));{q3b}
    result.substitution := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceSpecification.structure.isotope.substitution'));{q3b}
    result.halfLife := ParseQuantity(obj.complex('http://hl7.org/fhir/SubstanceSpecification.structure.isotope.halfLife'));{q3b}
    result.molecularWeight := ParseSubstanceSpecificationStructureIsotopeMolecularWeight(obj.complex('http://hl7.org/fhir/SubstanceSpecification.structure.isotope.molecularWeight'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeSubstanceSpecificationStructureIsotope(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstanceSpecificationStructureIsotope; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstanceSpecificationStructureIsotope'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(this, 'SubstanceSpecification.structure.isotope', 'identifier', elem.identifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceSpecification.structure.isotope', 'name', elem.nameElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceSpecification.structure.isotope', 'substitution', elem.substitutionElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'SubstanceSpecification.structure.isotope', 'halfLife', elem.halfLifeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeSubstanceSpecificationStructureIsotopeMolecularWeight(this, 'SubstanceSpecification.structure.isotope', 'molecularWeight', elem.molecularWeightElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseSubstanceSpecificationStructureIsotopeMolecularWeight(obj : TTurtleComplex) : TFhirSubstanceSpecificationStructureIsotopeMolecularWeight;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstanceSpecificationStructureIsotopeMolecularWeight.create;
  try
    ParseSubstanceSpecificationStructureIsotopeMolecularWeightProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstanceSpecificationStructureIsotopeMolecularWeightProperties(obj : TTurtleComplex; result : TFhirSubstanceSpecificationStructureIsotopeMolecularWeight);
begin
    ParseBackboneElementProperties(obj, result);
    result.method := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceSpecification.structure.isotope.molecularWeight.method'));{q3b}
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceSpecification.structure.isotope.molecularWeight.type'));{q3b}
    result.amount := ParseQuantity(obj.complex('http://hl7.org/fhir/SubstanceSpecification.structure.isotope.molecularWeight.amount'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeSubstanceSpecificationStructureIsotopeMolecularWeight(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstanceSpecificationStructureIsotopeMolecularWeight; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstanceSpecificationStructureIsotopeMolecularWeight'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceSpecification.structure.isotope.molecularWeight', 'method', elem.methodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceSpecification.structure.isotope.molecularWeight', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(this, 'SubstanceSpecification.structure.isotope.molecularWeight', 'amount', elem.amountElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseSubstanceSpecificationStructureRepresentation(obj : TTurtleComplex) : TFhirSubstanceSpecificationStructureRepresentation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstanceSpecificationStructureRepresentation.create;
  try
    ParseSubstanceSpecificationStructureRepresentationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstanceSpecificationStructureRepresentationProperties(obj : TTurtleComplex; result : TFhirSubstanceSpecificationStructureRepresentation);
begin
    ParseBackboneElementProperties(obj, result);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceSpecification.structure.representation.type'));{q3b}
    result.representationElement := ParseString(obj.complex('http://hl7.org/fhir/SubstanceSpecification.structure.representation.representation'));{q1}
    result.attachment := ParseAttachment(obj.complex('http://hl7.org/fhir/SubstanceSpecification.structure.representation.attachment'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeSubstanceSpecificationStructureRepresentation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstanceSpecificationStructureRepresentation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstanceSpecificationStructureRepresentation'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceSpecification.structure.representation', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SubstanceSpecification.structure.representation', 'representation', elem.representationElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeAttachment(this, 'SubstanceSpecification.structure.representation', 'attachment', elem.attachmentElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseSubstanceSpecificationCode(obj : TTurtleComplex) : TFhirSubstanceSpecificationCode;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstanceSpecificationCode.create;
  try
    ParseSubstanceSpecificationCodeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstanceSpecificationCodeProperties(obj : TTurtleComplex; result : TFhirSubstanceSpecificationCode);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceSpecification.code.code'));{q3b}
    result.status := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceSpecification.code.status'));{q3b}
    result.statusDateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/SubstanceSpecification.code.statusDate'));{q1}
    result.commentElement := ParseString(obj.complex('http://hl7.org/fhir/SubstanceSpecification.code.comment'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/SubstanceSpecification.code.source') do
      result.sourceList.Add(parseReference{TFhirDocumentReference}(item));
end;

procedure TFHIRTurtleComposer.ComposeSubstanceSpecificationCode(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstanceSpecificationCode; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstanceSpecificationCode'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceSpecification.code', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceSpecification.code', 'status', elem.statusElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'SubstanceSpecification.code', 'statusDate', elem.statusDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'SubstanceSpecification.code', 'comment', elem.commentElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.sourceList.Count - 1 do
      ComposeReference{TFhirDocumentReference}(this, 'SubstanceSpecification.code', 'source', elem.sourceList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseSubstanceSpecificationName(obj : TTurtleComplex) : TFhirSubstanceSpecificationName;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstanceSpecificationName.create;
  try
    ParseSubstanceSpecificationNameProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstanceSpecificationNameProperties(obj : TTurtleComplex; result : TFhirSubstanceSpecificationName);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/SubstanceSpecification.name.name'));{q1}
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceSpecification.name.type'));{q3b}
    result.status := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceSpecification.name.status'));{q3b}
    result.preferredElement := ParseBoolean(obj.complex('http://hl7.org/fhir/SubstanceSpecification.name.preferred'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/SubstanceSpecification.name.language') do
      result.languageList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/SubstanceSpecification.name.domain') do
      result.domainList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/SubstanceSpecification.name.jurisdiction') do
      result.jurisdictionList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/SubstanceSpecification.name.synonym') do
      result.synonymList.Add(parseSubstanceSpecificationName(item));
    for item in obj.complexes('http://hl7.org/fhir/SubstanceSpecification.name.translation') do
      result.translationList.Add(parseSubstanceSpecificationName(item));
    for item in obj.complexes('http://hl7.org/fhir/SubstanceSpecification.name.official') do
      result.officialList.Add(parseSubstanceSpecificationNameOfficial(item));
    for item in obj.complexes('http://hl7.org/fhir/SubstanceSpecification.name.source') do
      result.sourceList.Add(parseReference{TFhirDocumentReference}(item));
end;

procedure TFHIRTurtleComposer.ComposeSubstanceSpecificationName(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstanceSpecificationName; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstanceSpecificationName'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeString(this, 'SubstanceSpecification.name', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceSpecification.name', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceSpecification.name', 'status', elem.statusElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'SubstanceSpecification.name', 'preferred', elem.preferredElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.languageList.Count - 1 do
      ComposeCodeableConcept(this, 'SubstanceSpecification.name', 'language', elem.languageList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.domainList.Count - 1 do
      ComposeCodeableConcept(this, 'SubstanceSpecification.name', 'domain', elem.domainList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'SubstanceSpecification.name', 'jurisdiction', elem.jurisdictionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.synonymList.Count - 1 do
      ComposeSubstanceSpecificationName(this, 'SubstanceSpecification.name', 'synonym', elem.synonymList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.translationList.Count - 1 do
      ComposeSubstanceSpecificationName(this, 'SubstanceSpecification.name', 'translation', elem.translationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.officialList.Count - 1 do
      ComposeSubstanceSpecificationNameOfficial(this, 'SubstanceSpecification.name', 'official', elem.officialList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.sourceList.Count - 1 do
      ComposeReference{TFhirDocumentReference}(this, 'SubstanceSpecification.name', 'source', elem.sourceList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseSubstanceSpecificationNameOfficial(obj : TTurtleComplex) : TFhirSubstanceSpecificationNameOfficial;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstanceSpecificationNameOfficial.create;
  try
    ParseSubstanceSpecificationNameOfficialProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstanceSpecificationNameOfficialProperties(obj : TTurtleComplex; result : TFhirSubstanceSpecificationNameOfficial);
begin
    ParseBackboneElementProperties(obj, result);
    result.authority := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceSpecification.name.official.authority'));{q3b}
    result.status := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceSpecification.name.official.status'));{q3b}
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/SubstanceSpecification.name.official.date'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeSubstanceSpecificationNameOfficial(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstanceSpecificationNameOfficial; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstanceSpecificationNameOfficial'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceSpecification.name.official', 'authority', elem.authorityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceSpecification.name.official', 'status', elem.statusElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(this, 'SubstanceSpecification.name.official', 'date', elem.dateElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseSubstanceSpecificationRelationship(obj : TTurtleComplex) : TFhirSubstanceSpecificationRelationship;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstanceSpecificationRelationship.create;
  try
    ParseSubstanceSpecificationRelationshipProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstanceSpecificationRelationshipProperties(obj : TTurtleComplex; result : TFhirSubstanceSpecificationRelationship);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    if obj.has('http://hl7.org/fhir/SubstanceSpecification.relationship.substanceReference', item) {a3} then
      result.substance := ParseReference(item);
    if obj.has('http://hl7.org/fhir/SubstanceSpecification.relationship.substanceCodeableConcept', item) then
      result.substance := parseCodeableConcept(item);
    result.relationship := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceSpecification.relationship.relationship'));{q3b}
    result.isDefiningElement := ParseBoolean(obj.complex('http://hl7.org/fhir/SubstanceSpecification.relationship.isDefining'));{q1}
    if obj.has('http://hl7.org/fhir/SubstanceSpecification.relationship.amountQuantity', item) then
      result.amount := parseQuantity(item);
    if obj.has('http://hl7.org/fhir/SubstanceSpecification.relationship.amountRange', item) then
      result.amount := parseRange(item);
    if obj.has('http://hl7.org/fhir/SubstanceSpecification.relationship.amountRatio', item) then
      result.amount := parseRatio(item);
    if obj.has('http://hl7.org/fhir/SubstanceSpecification.relationship.amountString', item) then
      result.amount := parseString(item);
    result.amountRatioLowLimit := ParseRatio(obj.complex('http://hl7.org/fhir/SubstanceSpecification.relationship.amountRatioLowLimit'));{q3b}
    result.amountType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceSpecification.relationship.amountType'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/SubstanceSpecification.relationship.source') do
      result.sourceList.Add(parseReference{TFhirDocumentReference}(item));
end;

procedure TFHIRTurtleComposer.ComposeSubstanceSpecificationRelationship(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstanceSpecificationRelationship; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstanceSpecificationRelationship'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.substance is TFhirReference) {2} then
    ComposeReference(this, 'SubstanceSpecification.relationship', 'substanceReference', TFhirReference(elem.substance), false,-1){x.d8}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.substance is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'SubstanceSpecification.relationship', 'substanceCodeableConcept', TFhirCodeableConcept(elem.substance), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceSpecification.relationship', 'relationship', elem.relationshipElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'SubstanceSpecification.relationship', 'isDefining', elem.isDefiningElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.amount is TFhirQuantity) {6} then
    ComposeQuantity(this, 'SubstanceSpecification.relationship', 'amountQuantity', TFhirQuantity(elem.amount), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.amount is TFhirRange) {6} then
    ComposeRange(this, 'SubstanceSpecification.relationship', 'amountRange', TFhirRange(elem.amount), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.amount is TFhirRatio) {6} then
    ComposeRatio(this, 'SubstanceSpecification.relationship', 'amountRatio', TFhirRatio(elem.amount), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.amount is TFhirString) {6} then
    ComposeString(this, 'SubstanceSpecification.relationship', 'amountString', TFhirString(elem.amount), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeRatio(this, 'SubstanceSpecification.relationship', 'amountRatioLowLimit', elem.amountRatioLowLimitElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'SubstanceSpecification.relationship', 'amountType', elem.amountTypeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.sourceList.Count - 1 do
      ComposeReference{TFhirDocumentReference}(this, 'SubstanceSpecification.relationship', 'source', elem.sourceList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseSubstanceSpecification(obj : TTurtleComplex) : TFhirSubstanceSpecification;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSubstanceSpecification.create;
  try
    ParseSubstanceSpecificationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSubstanceSpecificationProperties(obj : TTurtleComplex; result : TFhirSubstanceSpecification);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/SubstanceSpecification.identifier'));{q3b}
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceSpecification.type'));{q3b}
    result.status := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceSpecification.status'));{q3b}
    result.domain := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SubstanceSpecification.domain'));{q3b}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/SubstanceSpecification.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/SubstanceSpecification.source') do
      result.sourceList.Add(parseReference{TFhirDocumentReference}(item));
    result.commentElement := ParseString(obj.complex('http://hl7.org/fhir/SubstanceSpecification.comment'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/SubstanceSpecification.moiety') do
      result.moietyList.Add(parseSubstanceSpecificationMoiety(item));
    for item in obj.complexes('http://hl7.org/fhir/SubstanceSpecification.property') do
      result.property_List.Add(parseSubstanceSpecificationProperty(item));
    result.referenceInformation := ParseReference{TFhirSubstanceReferenceInformation}(obj.complex('http://hl7.org/fhir/SubstanceSpecification.referenceInformation'));{q3b}
    result.structure := ParseSubstanceSpecificationStructure(obj.complex('http://hl7.org/fhir/SubstanceSpecification.structure'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/SubstanceSpecification.code') do
      result.codeList.Add(parseSubstanceSpecificationCode(item));
    for item in obj.complexes('http://hl7.org/fhir/SubstanceSpecification.name') do
      result.nameList.Add(parseSubstanceSpecificationName(item));
    for item in obj.complexes('http://hl7.org/fhir/SubstanceSpecification.molecularWeight') do
      result.molecularWeightList.Add(parseSubstanceSpecificationStructureIsotopeMolecularWeight(item));
    for item in obj.complexes('http://hl7.org/fhir/SubstanceSpecification.relationship') do
      result.relationshipList.Add(parseSubstanceSpecificationRelationship(item));
    result.nucleicAcid := ParseReference{TFhirSubstanceNucleicAcid}(obj.complex('http://hl7.org/fhir/SubstanceSpecification.nucleicAcid'));{q3b}
    result.polymer := ParseReference{TFhirSubstancePolymer}(obj.complex('http://hl7.org/fhir/SubstanceSpecification.polymer'));{q3b}
    result.protein := ParseReference{TFhirSubstanceProtein}(obj.complex('http://hl7.org/fhir/SubstanceSpecification.protein'));{q3b}
    result.sourceMaterial := ParseReference{TFhirSubstanceSourceMaterial}(obj.complex('http://hl7.org/fhir/SubstanceSpecification.sourceMaterial'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeSubstanceSpecification(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSubstanceSpecification; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SubstanceSpecification'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(this, 'SubstanceSpecification', 'identifier', elem.identifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCodeableConcept(this, 'SubstanceSpecification', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeCodeableConcept(this, 'SubstanceSpecification', 'status', elem.statusElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('domain') then
    ComposeCodeableConcept(this, 'SubstanceSpecification', 'domain', elem.domainElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeString(this, 'SubstanceSpecification', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('source') then
    for i := 0 to elem.sourceList.Count - 1 do
      ComposeReference{TFhirDocumentReference}(this, 'SubstanceSpecification', 'source', elem.sourceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('comment') then
    ComposeString(this, 'SubstanceSpecification', 'comment', elem.commentElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('moiety') then
    for i := 0 to elem.moietyList.Count - 1 do
      ComposeSubstanceSpecificationMoiety(this, 'SubstanceSpecification', 'moiety', elem.moietyList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('property_') then
    for i := 0 to elem.property_List.Count - 1 do
      ComposeSubstanceSpecificationProperty(this, 'SubstanceSpecification', 'property', elem.property_List[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('referenceInformation') then
    ComposeReference{TFhirSubstanceReferenceInformation}(this, 'SubstanceSpecification', 'referenceInformation', elem.referenceInformationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('structure') then
    ComposeSubstanceSpecificationStructure(this, 'SubstanceSpecification', 'structure', elem.structureElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') then
    for i := 0 to elem.codeList.Count - 1 do
      ComposeSubstanceSpecificationCode(this, 'SubstanceSpecification', 'code', elem.codeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    for i := 0 to elem.nameList.Count - 1 do
      ComposeSubstanceSpecificationName(this, 'SubstanceSpecification', 'name', elem.nameList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('molecularWeight') then
    for i := 0 to elem.molecularWeightList.Count - 1 do
      ComposeSubstanceSpecificationStructureIsotopeMolecularWeight(this, 'SubstanceSpecification', 'molecularWeight', elem.molecularWeightList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('relationship') then
    for i := 0 to elem.relationshipList.Count - 1 do
      ComposeSubstanceSpecificationRelationship(this, 'SubstanceSpecification', 'relationship', elem.relationshipList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('nucleicAcid') then
    ComposeReference{TFhirSubstanceNucleicAcid}(this, 'SubstanceSpecification', 'nucleicAcid', elem.nucleicAcidElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('polymer') then
    ComposeReference{TFhirSubstancePolymer}(this, 'SubstanceSpecification', 'polymer', elem.polymerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('protein') then
    ComposeReference{TFhirSubstanceProtein}(this, 'SubstanceSpecification', 'protein', elem.proteinElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('sourceMaterial') then
    ComposeReference{TFhirSubstanceSourceMaterial}(this, 'SubstanceSpecification', 'sourceMaterial', elem.sourceMaterialElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_SUBSTANCESPECIFICATION}
{$IFDEF FHIR_SUPPLYDELIVERY}
function TFHIRTurtleParser.ParseSupplyDeliverySuppliedItem(obj : TTurtleComplex) : TFhirSupplyDeliverySuppliedItem;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSupplyDeliverySuppliedItem.create;
  try
    ParseSupplyDeliverySuppliedItemProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSupplyDeliverySuppliedItemProperties(obj : TTurtleComplex; result : TFhirSupplyDeliverySuppliedItem);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/SupplyDelivery.suppliedItem.quantity'));{q3b}
    if obj.has('http://hl7.org/fhir/SupplyDelivery.suppliedItem.itemCodeableConcept', item) then
      result.item := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/SupplyDelivery.suppliedItem.itemReference', item) {a3} then
      result.item := ParseReference(item);
end;

procedure TFHIRTurtleComposer.ComposeSupplyDeliverySuppliedItem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSupplyDeliverySuppliedItem; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SupplyDeliverySuppliedItem'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'SupplyDelivery.suppliedItem', 'quantity', elem.quantityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and (elem.item is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'SupplyDelivery.suppliedItem', 'itemCodeableConcept', TFhirCodeableConcept(elem.item), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.item is TFhirReference) {2} then
    ComposeReference(this, 'SupplyDelivery.suppliedItem', 'itemReference', TFhirReference(elem.item), false,-1);{x.d8}
end;

function TFHIRTurtleParser.ParseSupplyDelivery(obj : TTurtleComplex) : TFhirSupplyDelivery;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSupplyDelivery.create;
  try
    ParseSupplyDeliveryProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSupplyDeliveryProperties(obj : TTurtleComplex; result : TFhirSupplyDelivery);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/SupplyDelivery.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    for item in obj.complexes('http://hl7.org/fhir/SupplyDelivery.basedOn') do
      result.basedOnList.Add(parseReference{TFhirSupplyRequest}(item));
    for item in obj.complexes('http://hl7.org/fhir/SupplyDelivery.partOf') do
      result.partOfList.Add(parseReference{TFhirSupplyDelivery}(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/SupplyDelivery.status'), CODES_TFhirSupplydeliveryStatusEnum, SYSTEMS_TFhirSupplydeliveryStatusEnum);
    result.patient := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/SupplyDelivery.patient'));{q3b}
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SupplyDelivery.type'));{q3b}
    result.suppliedItem := ParseSupplyDeliverySuppliedItem(obj.complex('http://hl7.org/fhir/SupplyDelivery.suppliedItem'));{q3b}
    if obj.has('http://hl7.org/fhir/SupplyDelivery.occurrencePeriod', item) then
      result.occurrence := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/SupplyDelivery.occurrenceTiming', item) then
      result.occurrence := parseTiming(item);
    if obj.has('http://hl7.org/fhir/SupplyDelivery.occurrenceDateTime', item) then
      result.occurrence := parseDateTime(item);
    result.supplier := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/SupplyDelivery.supplier'));{q3b}
    result.destination := ParseReference{TFhirLocation}(obj.complex('http://hl7.org/fhir/SupplyDelivery.destination'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/SupplyDelivery.receiver') do
      result.receiverList.Add(parseReference{TFhirPractitioner}(item));
end;

procedure TFHIRTurtleComposer.ComposeSupplyDelivery(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSupplyDelivery; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SupplyDelivery'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'SupplyDelivery', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('basedOn') then
    for i := 0 to elem.basedOnList.Count - 1 do
      ComposeReference{TFhirSupplyRequest}(this, 'SupplyDelivery', 'basedOn', elem.basedOnList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('partOf') then
    for i := 0 to elem.partOfList.Count - 1 do
      ComposeReference{TFhirSupplyDelivery}(this, 'SupplyDelivery', 'partOf', elem.partOfList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(this, 'SupplyDelivery', 'status', elem.StatusElement, CODES_TFhirSupplydeliveryStatusEnum, SYSTEMS_TFhirSupplydeliveryStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('patient') then
    ComposeReference{TFhirPatient}(this, 'SupplyDelivery', 'patient', elem.patientElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('type_') then
    ComposeCodeableConcept(this, 'SupplyDelivery', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('suppliedItem') then
    ComposeSupplyDeliverySuppliedItem(this, 'SupplyDelivery', 'suppliedItem', elem.suppliedItemElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirPeriod) {6} then
    ComposePeriod(this, 'SupplyDelivery', 'occurrencePeriod', TFhirPeriod(elem.occurrence), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirTiming) {6} then
    ComposeTiming(this, 'SupplyDelivery', 'occurrenceTiming', TFhirTiming(elem.occurrence), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirDateTime) {6} then
    ComposeDateTime(this, 'SupplyDelivery', 'occurrenceDateTime', TFhirDateTime(elem.occurrence), false, -1);{x.d9}
  if (SummaryOption in [soFull, soData]) and doCompose('supplier') then
    ComposeReference{TFhirPractitioner}(this, 'SupplyDelivery', 'supplier', elem.supplierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('destination') then
    ComposeReference{TFhirLocation}(this, 'SupplyDelivery', 'destination', elem.destinationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('receiver') then
    for i := 0 to elem.receiverList.Count - 1 do
      ComposeReference{TFhirPractitioner}(this, 'SupplyDelivery', 'receiver', elem.receiverList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_SUPPLYDELIVERY}
{$IFDEF FHIR_SUPPLYREQUEST}
function TFHIRTurtleParser.ParseSupplyRequestParameter(obj : TTurtleComplex) : TFhirSupplyRequestParameter;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSupplyRequestParameter.create;
  try
    ParseSupplyRequestParameterProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSupplyRequestParameterProperties(obj : TTurtleComplex; result : TFhirSupplyRequestParameter);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SupplyRequest.parameter.code'));{q3b}
    if obj.has('http://hl7.org/fhir/SupplyRequest.parameter.valueCodeableConcept', item) then
      result.value := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/SupplyRequest.parameter.valueQuantity', item) then
      result.value := parseQuantity(item);
    if obj.has('http://hl7.org/fhir/SupplyRequest.parameter.valueRange', item) then
      result.value := parseRange(item);
    if obj.has('http://hl7.org/fhir/SupplyRequest.parameter.valueBoolean', item) then
      result.value := parseBoolean(item);
end;

procedure TFHIRTurtleComposer.ComposeSupplyRequestParameter(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSupplyRequestParameter; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SupplyRequestParameter'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'SupplyRequest.parameter', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and (elem.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'SupplyRequest.parameter', 'valueCodeableConcept', TFhirCodeableConcept(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'SupplyRequest.parameter', 'valueQuantity', TFhirQuantity(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirRange) {6} then
    ComposeRange(this, 'SupplyRequest.parameter', 'valueRange', TFhirRange(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirBoolean) {6} then
    ComposeBoolean(this, 'SupplyRequest.parameter', 'valueBoolean', TFhirBoolean(elem.value), false, -1);{x.d9}
end;

function TFHIRTurtleParser.ParseSupplyRequest(obj : TTurtleComplex) : TFhirSupplyRequest;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirSupplyRequest.create;
  try
    ParseSupplyRequestProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseSupplyRequestProperties(obj : TTurtleComplex; result : TFhirSupplyRequest);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/SupplyRequest.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/SupplyRequest.status'), CODES_TFhirSupplyrequestStatusEnum, SYSTEMS_TFhirSupplyrequestStatusEnum);
    result.category := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/SupplyRequest.category'));{q3b}
    result.priorityElement := ParseEnum(obj.complex('http://hl7.org/fhir/SupplyRequest.priority'), CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum);
    if obj.has('http://hl7.org/fhir/SupplyRequest.itemCodeableConcept', item) then
      result.item := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/SupplyRequest.itemReference', item) {a3} then
      result.item := ParseReference(item);
    result.quantity := ParseQuantity(obj.complex('http://hl7.org/fhir/SupplyRequest.quantity'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/SupplyRequest.parameter') do
      result.parameterList.Add(parseSupplyRequestParameter(item));
    if obj.has('http://hl7.org/fhir/SupplyRequest.occurrencePeriod', item) then
      result.occurrence := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/SupplyRequest.occurrenceTiming', item) then
      result.occurrence := parseTiming(item);
    if obj.has('http://hl7.org/fhir/SupplyRequest.occurrenceDateTime', item) then
      result.occurrence := parseDateTime(item);
    result.authoredOnElement := ParseDateTime(obj.complex('http://hl7.org/fhir/SupplyRequest.authoredOn'));{q1}
    result.requester := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/SupplyRequest.requester'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/SupplyRequest.supplier') do
      result.supplierList.Add(parseReference{TFhirOrganization}(item));
    for item in obj.complexes('http://hl7.org/fhir/SupplyRequest.reasonCode') do
      result.reasonCodeList.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/SupplyRequest.reasonReference') do
      result.reasonReferenceList.Add(parseReference{TFhirCondition}(item));
    result.deliverFrom := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/SupplyRequest.deliverFrom'));{q3b}
    result.deliverTo := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/SupplyRequest.deliverTo'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeSupplyRequest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirSupplyRequest; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:SupplyRequest'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'SupplyRequest', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(this, 'SupplyRequest', 'status', elem.StatusElement, CODES_TFhirSupplyrequestStatusEnum, SYSTEMS_TFhirSupplyrequestStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    ComposeCodeableConcept(this, 'SupplyRequest', 'category', elem.categoryElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('priority') then
    ComposeEnum(this, 'SupplyRequest', 'priority', elem.PriorityElement, CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum, false, -1);{x.d4}
  if (elem.item is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'SupplyRequest', 'itemCodeableConcept', TFhirCodeableConcept(elem.item), false, -1){x.d9}
  else if (elem.item is TFhirReference) {2} then
    ComposeReference(this, 'SupplyRequest', 'itemReference', TFhirReference(elem.item), false,-1);{x.d8}
  ComposeQuantity(this, 'SupplyRequest', 'quantity', elem.quantityElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('parameter') then
    for i := 0 to elem.parameterList.Count - 1 do
      ComposeSupplyRequestParameter(this, 'SupplyRequest', 'parameter', elem.parameterList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirPeriod) {6} then
    ComposePeriod(this, 'SupplyRequest', 'occurrencePeriod', TFhirPeriod(elem.occurrence), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirTiming) {6} then
    ComposeTiming(this, 'SupplyRequest', 'occurrenceTiming', TFhirTiming(elem.occurrence), false, -1){x.d9}
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirDateTime) {6} then
    ComposeDateTime(this, 'SupplyRequest', 'occurrenceDateTime', TFhirDateTime(elem.occurrence), false, -1);{x.d9}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('authoredOn') then
    ComposeDateTime(this, 'SupplyRequest', 'authoredOn', elem.authoredOnElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requester') then
    ComposeReference{TFhirPractitioner}(this, 'SupplyRequest', 'requester', elem.requesterElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('supplier') then
    for i := 0 to elem.supplierList.Count - 1 do
      ComposeReference{TFhirOrganization}(this, 'SupplyRequest', 'supplier', elem.supplierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('reasonCode') then
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(this, 'SupplyRequest', 'reasonCode', elem.reasonCodeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('reasonReference') then
    for i := 0 to elem.reasonReferenceList.Count - 1 do
      ComposeReference{TFhirCondition}(this, 'SupplyRequest', 'reasonReference', elem.reasonReferenceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('deliverFrom') then
    ComposeReference{TFhirOrganization}(this, 'SupplyRequest', 'deliverFrom', elem.deliverFromElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('deliverTo') then
    ComposeReference{TFhirOrganization}(this, 'SupplyRequest', 'deliverTo', elem.deliverToElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_SUPPLYREQUEST}
{$IFDEF FHIR_TASK}
function TFHIRTurtleParser.ParseTaskRestriction(obj : TTurtleComplex) : TFhirTaskRestriction;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTaskRestriction.create;
  try
    ParseTaskRestrictionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTaskRestrictionProperties(obj : TTurtleComplex; result : TFhirTaskRestriction);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.repetitionsElement := ParsePositiveInt(obj.complex('http://hl7.org/fhir/Task.restriction.repetitions'));{q1}
    result.period := ParsePeriod(obj.complex('http://hl7.org/fhir/Task.restriction.period'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Task.restriction.recipient') do
      result.recipientList.Add(parseReference{TFhirPatient}(item));
end;

procedure TFHIRTurtleComposer.ComposeTaskRestriction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTaskRestriction; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TaskRestriction'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(this, 'Task.restriction', 'repetitions', elem.repetitionsElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(this, 'Task.restriction', 'period', elem.periodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.recipientList.Count - 1 do
      ComposeReference{TFhirPatient}(this, 'Task.restriction', 'recipient', elem.recipientList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseTaskInput(obj : TTurtleComplex) : TFhirTaskInput;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTaskInput.create;
  try
    ParseTaskInputProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTaskInputProperties(obj : TTurtleComplex; result : TFhirTaskInput);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Task.input.type'));{q3b}
    if obj.has('http://hl7.org/fhir/Task.input.valueCanonical', item) then
      result.value := parseCanonical(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueCode', item) then
      result.value := parseCode(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueId', item) then
      result.value := parseId(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueMarkdown', item) then
      result.value := parseMarkdown(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueOid', item) then
      result.value := parseOid(item);
    if obj.has('http://hl7.org/fhir/Task.input.valuePositiveInt', item) then
      result.value := parsePositiveInt(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueUnsignedInt', item) then
      result.value := parseUnsignedInt(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueUrl', item) then
      result.value := parseUrl(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueUuid', item) then
      result.value := parseUuid(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueAddress', item) then
      result.value := parseAddress(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueAge', item) then
      result.value := parseAge(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueAnnotation', item) then
      result.value := parseAnnotation(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueAttachment', item) then
      result.value := parseAttachment(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueCodeableConcept', item) then
      result.value := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueCoding', item) then
      result.value := parseCoding(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueContactPoint', item) then
      result.value := parseContactPoint(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueCount', item) then
      result.value := parseCount(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueDistance', item) then
      result.value := parseDistance(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueDuration', item) then
      result.value := parseDuration(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueHumanName', item) then
      result.value := parseHumanName(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueIdentifier', item) then
      result.value := parseIdentifier(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueMoney', item) then
      result.value := parseMoney(item);
    if obj.has('http://hl7.org/fhir/Task.input.valuePeriod', item) then
      result.value := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueQuantity', item) then
      result.value := parseQuantity(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueRange', item) then
      result.value := parseRange(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueRatio', item) then
      result.value := parseRatio(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueReference', item) then
      result.value := parseReference(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueSampledData', item) then
      result.value := parseSampledData(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueSignature', item) then
      result.value := parseSignature(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueTiming', item) then
      result.value := parseTiming(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueContactDetail', item) then
      result.value := parseContactDetail(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueContributor', item) then
      result.value := parseContributor(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueDataRequirement', item) then
      result.value := parseDataRequirement(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueExpression', item) then
      result.value := parseExpression(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueParameterDefinition', item) then
      result.value := parseParameterDefinition(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueRelatedArtifact', item) then
      result.value := parseRelatedArtifact(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueTriggerDefinition', item) then
      result.value := parseTriggerDefinition(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueUsageContext', item) then
      result.value := parseUsageContext(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueDosage', item) then
      result.value := parseDosage(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueBase64Binary', item) then
      result.value := parseBase64Binary(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueBoolean', item) then
      result.value := parseBoolean(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueDate', item) then
      result.value := parseDate(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueDateTime', item) then
      result.value := parseDateTime(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueDecimal', item) then
      result.value := parseDecimal(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueInstant', item) then
      result.value := parseInstant(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueInteger', item) then
      result.value := parseInteger(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueString', item) then
      result.value := parseString(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueTime', item) then
      result.value := parseTime(item);
    if obj.has('http://hl7.org/fhir/Task.input.valueUri', item) then
      result.value := parseUri(item);
end;

procedure TFHIRTurtleComposer.ComposeTaskInput(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTaskInput; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TaskInput'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'Task.input', 'type', elem.type_Element, false, -1);{x.2f}
  if (elem.value is TFhirCanonical) {6} then
    ComposeCanonical(this, 'Task.input', 'valueCanonical', TFhirCanonical(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirCode) {6} then
    ComposeCode(this, 'Task.input', 'valueCode', TFhirCode(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirId) {6} then
    ComposeId(this, 'Task.input', 'valueId', TFhirId(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirMarkdown) {6} then
    ComposeMarkdown(this, 'Task.input', 'valueMarkdown', TFhirMarkdown(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirOid) {6} then
    ComposeOid(this, 'Task.input', 'valueOid', TFhirOid(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirPositiveInt) {6} then
    ComposePositiveInt(this, 'Task.input', 'valuePositiveInt', TFhirPositiveInt(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(this, 'Task.input', 'valueUnsignedInt', TFhirUnsignedInt(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirUrl) {6} then
    ComposeUrl(this, 'Task.input', 'valueUrl', TFhirUrl(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirUuid) {6} then
    ComposeUuid(this, 'Task.input', 'valueUuid', TFhirUuid(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirAddress) {6} then
    ComposeAddress(this, 'Task.input', 'valueAddress', TFhirAddress(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirAge) {6} then
    ComposeAge(this, 'Task.input', 'valueAge', TFhirAge(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirAnnotation) {6} then
    ComposeAnnotation(this, 'Task.input', 'valueAnnotation', TFhirAnnotation(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirAttachment) {6} then
    ComposeAttachment(this, 'Task.input', 'valueAttachment', TFhirAttachment(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Task.input', 'valueCodeableConcept', TFhirCodeableConcept(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirCoding) {6} then
    ComposeCoding(this, 'Task.input', 'valueCoding', TFhirCoding(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirContactPoint) {6} then
    ComposeContactPoint(this, 'Task.input', 'valueContactPoint', TFhirContactPoint(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirCount) {6} then
    ComposeCount(this, 'Task.input', 'valueCount', TFhirCount(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirDistance) {6} then
    ComposeDistance(this, 'Task.input', 'valueDistance', TFhirDistance(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirDuration) {6} then
    ComposeDuration(this, 'Task.input', 'valueDuration', TFhirDuration(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirHumanName) {6} then
    ComposeHumanName(this, 'Task.input', 'valueHumanName', TFhirHumanName(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirIdentifier) {6} then
    ComposeIdentifier(this, 'Task.input', 'valueIdentifier', TFhirIdentifier(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirMoney) {6} then
    ComposeMoney(this, 'Task.input', 'valueMoney', TFhirMoney(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirPeriod) {6} then
    ComposePeriod(this, 'Task.input', 'valuePeriod', TFhirPeriod(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'Task.input', 'valueQuantity', TFhirQuantity(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirRange) {6} then
    ComposeRange(this, 'Task.input', 'valueRange', TFhirRange(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirRatio) {6} then
    ComposeRatio(this, 'Task.input', 'valueRatio', TFhirRatio(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirReference) {6} then
    ComposeReference(this, 'Task.input', 'valueReference', TFhirReference(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirSampledData) {6} then
    ComposeSampledData(this, 'Task.input', 'valueSampledData', TFhirSampledData(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirSignature) {6} then
    ComposeSignature(this, 'Task.input', 'valueSignature', TFhirSignature(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirTiming) {6} then
    ComposeTiming(this, 'Task.input', 'valueTiming', TFhirTiming(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirContactDetail) {6} then
    ComposeContactDetail(this, 'Task.input', 'valueContactDetail', TFhirContactDetail(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirContributor) {6} then
    ComposeContributor(this, 'Task.input', 'valueContributor', TFhirContributor(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirDataRequirement) {6} then
    ComposeDataRequirement(this, 'Task.input', 'valueDataRequirement', TFhirDataRequirement(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirExpression) {6} then
    ComposeExpression(this, 'Task.input', 'valueExpression', TFhirExpression(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirParameterDefinition) {6} then
    ComposeParameterDefinition(this, 'Task.input', 'valueParameterDefinition', TFhirParameterDefinition(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirRelatedArtifact) {6} then
    ComposeRelatedArtifact(this, 'Task.input', 'valueRelatedArtifact', TFhirRelatedArtifact(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirTriggerDefinition) {6} then
    ComposeTriggerDefinition(this, 'Task.input', 'valueTriggerDefinition', TFhirTriggerDefinition(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirUsageContext) {6} then
    ComposeUsageContext(this, 'Task.input', 'valueUsageContext', TFhirUsageContext(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirDosage) {6} then
    ComposeDosage(this, 'Task.input', 'valueDosage', TFhirDosage(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirBase64Binary) {6} then
    ComposeBase64Binary(this, 'Task.input', 'valueBase64Binary', TFhirBase64Binary(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirBoolean) {6} then
    ComposeBoolean(this, 'Task.input', 'valueBoolean', TFhirBoolean(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirDate) {6} then
    ComposeDate(this, 'Task.input', 'valueDate', TFhirDate(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirDateTime) {6} then
    ComposeDateTime(this, 'Task.input', 'valueDateTime', TFhirDateTime(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirDecimal) {6} then
    ComposeDecimal(this, 'Task.input', 'valueDecimal', TFhirDecimal(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirInstant) {6} then
    ComposeInstant(this, 'Task.input', 'valueInstant', TFhirInstant(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirInteger) {6} then
    ComposeInteger(this, 'Task.input', 'valueInteger', TFhirInteger(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirString) {6} then
    ComposeString(this, 'Task.input', 'valueString', TFhirString(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirTime) {6} then
    ComposeTime(this, 'Task.input', 'valueTime', TFhirTime(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirUri) {6} then
    ComposeUri(this, 'Task.input', 'valueUri', TFhirUri(elem.value), false, -1);{x.d9}
end;

function TFHIRTurtleParser.ParseTaskOutput(obj : TTurtleComplex) : TFhirTaskOutput;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTaskOutput.create;
  try
    ParseTaskOutputProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTaskOutputProperties(obj : TTurtleComplex; result : TFhirTaskOutput);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.type_ := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Task.output.type'));{q3b}
    if obj.has('http://hl7.org/fhir/Task.output.valueCanonical', item) then
      result.value := parseCanonical(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueCode', item) then
      result.value := parseCode(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueId', item) then
      result.value := parseId(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueMarkdown', item) then
      result.value := parseMarkdown(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueOid', item) then
      result.value := parseOid(item);
    if obj.has('http://hl7.org/fhir/Task.output.valuePositiveInt', item) then
      result.value := parsePositiveInt(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueUnsignedInt', item) then
      result.value := parseUnsignedInt(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueUrl', item) then
      result.value := parseUrl(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueUuid', item) then
      result.value := parseUuid(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueAddress', item) then
      result.value := parseAddress(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueAge', item) then
      result.value := parseAge(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueAnnotation', item) then
      result.value := parseAnnotation(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueAttachment', item) then
      result.value := parseAttachment(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueCodeableConcept', item) then
      result.value := parseCodeableConcept(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueCoding', item) then
      result.value := parseCoding(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueContactPoint', item) then
      result.value := parseContactPoint(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueCount', item) then
      result.value := parseCount(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueDistance', item) then
      result.value := parseDistance(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueDuration', item) then
      result.value := parseDuration(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueHumanName', item) then
      result.value := parseHumanName(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueIdentifier', item) then
      result.value := parseIdentifier(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueMoney', item) then
      result.value := parseMoney(item);
    if obj.has('http://hl7.org/fhir/Task.output.valuePeriod', item) then
      result.value := parsePeriod(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueQuantity', item) then
      result.value := parseQuantity(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueRange', item) then
      result.value := parseRange(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueRatio', item) then
      result.value := parseRatio(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueReference', item) then
      result.value := parseReference(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueSampledData', item) then
      result.value := parseSampledData(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueSignature', item) then
      result.value := parseSignature(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueTiming', item) then
      result.value := parseTiming(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueContactDetail', item) then
      result.value := parseContactDetail(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueContributor', item) then
      result.value := parseContributor(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueDataRequirement', item) then
      result.value := parseDataRequirement(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueExpression', item) then
      result.value := parseExpression(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueParameterDefinition', item) then
      result.value := parseParameterDefinition(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueRelatedArtifact', item) then
      result.value := parseRelatedArtifact(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueTriggerDefinition', item) then
      result.value := parseTriggerDefinition(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueUsageContext', item) then
      result.value := parseUsageContext(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueDosage', item) then
      result.value := parseDosage(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueBase64Binary', item) then
      result.value := parseBase64Binary(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueBoolean', item) then
      result.value := parseBoolean(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueDate', item) then
      result.value := parseDate(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueDateTime', item) then
      result.value := parseDateTime(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueDecimal', item) then
      result.value := parseDecimal(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueInstant', item) then
      result.value := parseInstant(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueInteger', item) then
      result.value := parseInteger(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueString', item) then
      result.value := parseString(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueTime', item) then
      result.value := parseTime(item);
    if obj.has('http://hl7.org/fhir/Task.output.valueUri', item) then
      result.value := parseUri(item);
end;

procedure TFHIRTurtleComposer.ComposeTaskOutput(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTaskOutput; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TaskOutput'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'Task.output', 'type', elem.type_Element, false, -1);{x.2f}
  if (elem.value is TFhirCanonical) {6} then
    ComposeCanonical(this, 'Task.output', 'valueCanonical', TFhirCanonical(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirCode) {6} then
    ComposeCode(this, 'Task.output', 'valueCode', TFhirCode(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirId) {6} then
    ComposeId(this, 'Task.output', 'valueId', TFhirId(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirMarkdown) {6} then
    ComposeMarkdown(this, 'Task.output', 'valueMarkdown', TFhirMarkdown(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirOid) {6} then
    ComposeOid(this, 'Task.output', 'valueOid', TFhirOid(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirPositiveInt) {6} then
    ComposePositiveInt(this, 'Task.output', 'valuePositiveInt', TFhirPositiveInt(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirUnsignedInt) {6} then
    ComposeUnsignedInt(this, 'Task.output', 'valueUnsignedInt', TFhirUnsignedInt(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirUrl) {6} then
    ComposeUrl(this, 'Task.output', 'valueUrl', TFhirUrl(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirUuid) {6} then
    ComposeUuid(this, 'Task.output', 'valueUuid', TFhirUuid(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirAddress) {6} then
    ComposeAddress(this, 'Task.output', 'valueAddress', TFhirAddress(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirAge) {6} then
    ComposeAge(this, 'Task.output', 'valueAge', TFhirAge(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirAnnotation) {6} then
    ComposeAnnotation(this, 'Task.output', 'valueAnnotation', TFhirAnnotation(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirAttachment) {6} then
    ComposeAttachment(this, 'Task.output', 'valueAttachment', TFhirAttachment(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(this, 'Task.output', 'valueCodeableConcept', TFhirCodeableConcept(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirCoding) {6} then
    ComposeCoding(this, 'Task.output', 'valueCoding', TFhirCoding(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirContactPoint) {6} then
    ComposeContactPoint(this, 'Task.output', 'valueContactPoint', TFhirContactPoint(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirCount) {6} then
    ComposeCount(this, 'Task.output', 'valueCount', TFhirCount(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirDistance) {6} then
    ComposeDistance(this, 'Task.output', 'valueDistance', TFhirDistance(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirDuration) {6} then
    ComposeDuration(this, 'Task.output', 'valueDuration', TFhirDuration(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirHumanName) {6} then
    ComposeHumanName(this, 'Task.output', 'valueHumanName', TFhirHumanName(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirIdentifier) {6} then
    ComposeIdentifier(this, 'Task.output', 'valueIdentifier', TFhirIdentifier(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirMoney) {6} then
    ComposeMoney(this, 'Task.output', 'valueMoney', TFhirMoney(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirPeriod) {6} then
    ComposePeriod(this, 'Task.output', 'valuePeriod', TFhirPeriod(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirQuantity) {6} then
    ComposeQuantity(this, 'Task.output', 'valueQuantity', TFhirQuantity(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirRange) {6} then
    ComposeRange(this, 'Task.output', 'valueRange', TFhirRange(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirRatio) {6} then
    ComposeRatio(this, 'Task.output', 'valueRatio', TFhirRatio(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirReference) {6} then
    ComposeReference(this, 'Task.output', 'valueReference', TFhirReference(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirSampledData) {6} then
    ComposeSampledData(this, 'Task.output', 'valueSampledData', TFhirSampledData(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirSignature) {6} then
    ComposeSignature(this, 'Task.output', 'valueSignature', TFhirSignature(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirTiming) {6} then
    ComposeTiming(this, 'Task.output', 'valueTiming', TFhirTiming(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirContactDetail) {6} then
    ComposeContactDetail(this, 'Task.output', 'valueContactDetail', TFhirContactDetail(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirContributor) {6} then
    ComposeContributor(this, 'Task.output', 'valueContributor', TFhirContributor(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirDataRequirement) {6} then
    ComposeDataRequirement(this, 'Task.output', 'valueDataRequirement', TFhirDataRequirement(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirExpression) {6} then
    ComposeExpression(this, 'Task.output', 'valueExpression', TFhirExpression(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirParameterDefinition) {6} then
    ComposeParameterDefinition(this, 'Task.output', 'valueParameterDefinition', TFhirParameterDefinition(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirRelatedArtifact) {6} then
    ComposeRelatedArtifact(this, 'Task.output', 'valueRelatedArtifact', TFhirRelatedArtifact(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirTriggerDefinition) {6} then
    ComposeTriggerDefinition(this, 'Task.output', 'valueTriggerDefinition', TFhirTriggerDefinition(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirUsageContext) {6} then
    ComposeUsageContext(this, 'Task.output', 'valueUsageContext', TFhirUsageContext(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirDosage) {6} then
    ComposeDosage(this, 'Task.output', 'valueDosage', TFhirDosage(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirBase64Binary) {6} then
    ComposeBase64Binary(this, 'Task.output', 'valueBase64Binary', TFhirBase64Binary(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirBoolean) {6} then
    ComposeBoolean(this, 'Task.output', 'valueBoolean', TFhirBoolean(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirDate) {6} then
    ComposeDate(this, 'Task.output', 'valueDate', TFhirDate(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirDateTime) {6} then
    ComposeDateTime(this, 'Task.output', 'valueDateTime', TFhirDateTime(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirDecimal) {6} then
    ComposeDecimal(this, 'Task.output', 'valueDecimal', TFhirDecimal(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirInstant) {6} then
    ComposeInstant(this, 'Task.output', 'valueInstant', TFhirInstant(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirInteger) {6} then
    ComposeInteger(this, 'Task.output', 'valueInteger', TFhirInteger(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirString) {6} then
    ComposeString(this, 'Task.output', 'valueString', TFhirString(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirTime) {6} then
    ComposeTime(this, 'Task.output', 'valueTime', TFhirTime(elem.value), false, -1){x.d9}
  else if (elem.value is TFhirUri) {6} then
    ComposeUri(this, 'Task.output', 'valueUri', TFhirUri(elem.value), false, -1);{x.d9}
end;

function TFHIRTurtleParser.ParseTask(obj : TTurtleComplex) : TFhirTask;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTask.create;
  try
    ParseTaskProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTaskProperties(obj : TTurtleComplex; result : TFhirTask);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/Task.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.instantiatesCanonicalElement := ParseCanonical(obj.complex('http://hl7.org/fhir/Task.instantiatesCanonical'));{q1}
    result.instantiatesUriElement := ParseUri(obj.complex('http://hl7.org/fhir/Task.instantiatesUri'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/Task.basedOn') do
      result.basedOnList.Add(parseReference{TFhirReference}(item));
    result.groupIdentifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/Task.groupIdentifier'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Task.partOf') do
      result.partOfList.Add(parseReference{TFhirTask}(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/Task.status'), CODES_TFhirTaskStatusEnum, SYSTEMS_TFhirTaskStatusEnum);
    result.statusReason := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Task.statusReason'));{q3b}
    result.businessStatus := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Task.businessStatus'));{q3b}
    result.intentElement := ParseEnum(obj.complex('http://hl7.org/fhir/Task.intent'), CODES_TFhirTaskIntentEnum, SYSTEMS_TFhirTaskIntentEnum);
    result.priorityElement := ParseEnum(obj.complex('http://hl7.org/fhir/Task.priority'), CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum);
    result.code := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Task.code'));{q3b}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/Task.description'));{q1}
    result.focus := ParseReference{TFhirReference}(obj.complex('http://hl7.org/fhir/Task.focus'));{q3b}
    result.for_ := ParseReference{TFhirReference}(obj.complex('http://hl7.org/fhir/Task.for'));{q3b}
    result.encounter := ParseReference{TFhirEncounter}(obj.complex('http://hl7.org/fhir/Task.encounter'));{q3b}
    result.executionPeriod := ParsePeriod(obj.complex('http://hl7.org/fhir/Task.executionPeriod'));{q3b}
    result.authoredOnElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Task.authoredOn'));{q1}
    result.lastModifiedElement := ParseDateTime(obj.complex('http://hl7.org/fhir/Task.lastModified'));{q1}
    result.requester := ParseReference{TFhirDevice}(obj.complex('http://hl7.org/fhir/Task.requester'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Task.performerType') do
      result.performerTypeList.Add(parseCodeableConcept(item));
    result.owner := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/Task.owner'));{q3b}
    result.location := ParseReference{TFhirLocation}(obj.complex('http://hl7.org/fhir/Task.location'));{q3b}
    result.reasonCode := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/Task.reasonCode'));{q3b}
    result.reasonReference := ParseReference{TFhirReference}(obj.complex('http://hl7.org/fhir/Task.reasonReference'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Task.insurance') do
      result.insuranceList.Add(parseReference{TFhirCoverage}(item));
    for item in obj.complexes('http://hl7.org/fhir/Task.note') do
      result.noteList.Add(parseAnnotation(item));
    for item in obj.complexes('http://hl7.org/fhir/Task.relevantHistory') do
      result.relevantHistoryList.Add(parseReference{TFhirProvenance}(item));
    result.restriction := ParseTaskRestriction(obj.complex('http://hl7.org/fhir/Task.restriction'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/Task.input') do
      result.inputList.Add(parseTaskInput(item));
    for item in obj.complexes('http://hl7.org/fhir/Task.output') do
      result.outputList.Add(parseTaskOutput(item));
end;

procedure TFHIRTurtleComposer.ComposeTask(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTask; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:Task'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'Task', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('instantiatesCanonical') then
    ComposeCanonical(this, 'Task', 'instantiatesCanonical', elem.instantiatesCanonicalElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('instantiatesUri') then
    ComposeUri(this, 'Task', 'instantiatesUri', elem.instantiatesUriElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('basedOn') then
    for i := 0 to elem.basedOnList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'Task', 'basedOn', elem.basedOnList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('groupIdentifier') then
    ComposeIdentifier(this, 'Task', 'groupIdentifier', elem.groupIdentifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('partOf') then
    for i := 0 to elem.partOfList.Count - 1 do
      ComposeReference{TFhirTask}(this, 'Task', 'partOf', elem.partOfList[i], false, i);{x.d3}
  ComposeEnum(this, 'Task', 'status', elem.StatusElement, CODES_TFhirTaskStatusEnum, SYSTEMS_TFhirTaskStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('statusReason') then
    ComposeCodeableConcept(this, 'Task', 'statusReason', elem.statusReasonElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('businessStatus') then
    ComposeCodeableConcept(this, 'Task', 'businessStatus', elem.businessStatusElement, false, -1);{x.2f}
  ComposeEnum(this, 'Task', 'intent', elem.IntentElement, CODES_TFhirTaskIntentEnum, SYSTEMS_TFhirTaskIntentEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('priority') then
    ComposeEnum(this, 'Task', 'priority', elem.PriorityElement, CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') then
    ComposeCodeableConcept(this, 'Task', 'code', elem.codeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeString(this, 'Task', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('focus') then
    ComposeReference{TFhirReference}(this, 'Task', 'focus', elem.focusElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('for_') then
    ComposeReference{TFhirReference}(this, 'Task', 'for', elem.for_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(this, 'Task', 'encounter', elem.encounterElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('executionPeriod') then
    ComposePeriod(this, 'Task', 'executionPeriod', elem.executionPeriodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('authoredOn') then
    ComposeDateTime(this, 'Task', 'authoredOn', elem.authoredOnElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('lastModified') then
    ComposeDateTime(this, 'Task', 'lastModified', elem.lastModifiedElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requester') then
    ComposeReference{TFhirDevice}(this, 'Task', 'requester', elem.requesterElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('performerType') then
    for i := 0 to elem.performerTypeList.Count - 1 do
      ComposeCodeableConcept(this, 'Task', 'performerType', elem.performerTypeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('owner') then
    ComposeReference{TFhirPractitioner}(this, 'Task', 'owner', elem.ownerElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('location') then
    ComposeReference{TFhirLocation}(this, 'Task', 'location', elem.locationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('reasonCode') then
    ComposeCodeableConcept(this, 'Task', 'reasonCode', elem.reasonCodeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('reasonReference') then
    ComposeReference{TFhirReference}(this, 'Task', 'reasonReference', elem.reasonReferenceElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('insurance') then
    for i := 0 to elem.insuranceList.Count - 1 do
      ComposeReference{TFhirCoverage}(this, 'Task', 'insurance', elem.insuranceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'Task', 'note', elem.noteList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('relevantHistory') then
    for i := 0 to elem.relevantHistoryList.Count - 1 do
      ComposeReference{TFhirProvenance}(this, 'Task', 'relevantHistory', elem.relevantHistoryList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('restriction') then
    ComposeTaskRestriction(this, 'Task', 'restriction', elem.restrictionElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('input') then
    for i := 0 to elem.inputList.Count - 1 do
      ComposeTaskInput(this, 'Task', 'input', elem.inputList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('output') then
    for i := 0 to elem.outputList.Count - 1 do
      ComposeTaskOutput(this, 'Task', 'output', elem.outputList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_TASK}
{$IFDEF FHIR_TERMINOLOGYCAPABILITIES}
function TFHIRTurtleParser.ParseTerminologyCapabilitiesSoftware(obj : TTurtleComplex) : TFhirTerminologyCapabilitiesSoftware;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTerminologyCapabilitiesSoftware.create;
  try
    ParseTerminologyCapabilitiesSoftwareProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTerminologyCapabilitiesSoftwareProperties(obj : TTurtleComplex; result : TFhirTerminologyCapabilitiesSoftware);
begin
    ParseBackboneElementProperties(obj, result);
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.software.name'));{q1}
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.software.version'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeTerminologyCapabilitiesSoftware(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTerminologyCapabilitiesSoftware; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TerminologyCapabilitiesSoftware'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeString(this, 'TerminologyCapabilities.software', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'TerminologyCapabilities.software', 'version', elem.versionElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseTerminologyCapabilitiesImplementation(obj : TTurtleComplex) : TFhirTerminologyCapabilitiesImplementation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTerminologyCapabilitiesImplementation.create;
  try
    ParseTerminologyCapabilitiesImplementationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTerminologyCapabilitiesImplementationProperties(obj : TTurtleComplex; result : TFhirTerminologyCapabilitiesImplementation);
begin
    ParseBackboneElementProperties(obj, result);
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.implementation.description'));{q1}
    result.urlElement := ParseUrl(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.implementation.url'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeTerminologyCapabilitiesImplementation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTerminologyCapabilitiesImplementation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TerminologyCapabilitiesImplementation'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeString(this, 'TerminologyCapabilities.implementation', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUrl(this, 'TerminologyCapabilities.implementation', 'url', elem.urlElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseTerminologyCapabilitiesCodeSystem(obj : TTurtleComplex) : TFhirTerminologyCapabilitiesCodeSystem;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTerminologyCapabilitiesCodeSystem.create;
  try
    ParseTerminologyCapabilitiesCodeSystemProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTerminologyCapabilitiesCodeSystemProperties(obj : TTurtleComplex; result : TFhirTerminologyCapabilitiesCodeSystem);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.uriElement := ParseCanonical(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.codeSystem.uri'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/TerminologyCapabilities.codeSystem.version') do
      result.versionList.Add(parseTerminologyCapabilitiesCodeSystemVersion(item));
    result.subsumptionElement := ParseBoolean(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.codeSystem.subsumption'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeTerminologyCapabilitiesCodeSystem(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTerminologyCapabilitiesCodeSystem; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TerminologyCapabilitiesCodeSystem'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonical(this, 'TerminologyCapabilities.codeSystem', 'uri', elem.uriElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.versionList.Count - 1 do
      ComposeTerminologyCapabilitiesCodeSystemVersion(this, 'TerminologyCapabilities.codeSystem', 'version', elem.versionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'TerminologyCapabilities.codeSystem', 'subsumption', elem.subsumptionElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseTerminologyCapabilitiesCodeSystemVersion(obj : TTurtleComplex) : TFhirTerminologyCapabilitiesCodeSystemVersion;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTerminologyCapabilitiesCodeSystemVersion.create;
  try
    ParseTerminologyCapabilitiesCodeSystemVersionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTerminologyCapabilitiesCodeSystemVersionProperties(obj : TTurtleComplex; result : TFhirTerminologyCapabilitiesCodeSystemVersion);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.codeElement := ParseString(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.codeSystem.version.code'));{q1}
    result.isDefaultElement := ParseBoolean(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.codeSystem.version.isDefault'));{q1}
    result.compositionalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.codeSystem.version.compositional'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/TerminologyCapabilities.codeSystem.version.language') do
      result.languageList.Add(parseCode(item));
    for item in obj.complexes('http://hl7.org/fhir/TerminologyCapabilities.codeSystem.version.filter') do
      result.filterList.Add(parseTerminologyCapabilitiesCodeSystemVersionFilter(item));
    for item in obj.complexes('http://hl7.org/fhir/TerminologyCapabilities.codeSystem.version.property') do
      result.property_List.Add(parseCode(item));
end;

procedure TFHIRTurtleComposer.ComposeTerminologyCapabilitiesCodeSystemVersion(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTerminologyCapabilitiesCodeSystemVersion; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TerminologyCapabilitiesCodeSystemVersion'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'TerminologyCapabilities.codeSystem.version', 'code', elem.codeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'TerminologyCapabilities.codeSystem.version', 'isDefault', elem.isDefaultElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'TerminologyCapabilities.codeSystem.version', 'compositional', elem.compositionalElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.languageList.Count - 1 do
      ComposeCode(this, 'TerminologyCapabilities.codeSystem.version', 'language', elem.languageList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.filterList.Count - 1 do
      ComposeTerminologyCapabilitiesCodeSystemVersionFilter(this, 'TerminologyCapabilities.codeSystem.version', 'filter', elem.filterList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.property_List.Count - 1 do
      ComposeCode(this, 'TerminologyCapabilities.codeSystem.version', 'property', elem.property_List[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseTerminologyCapabilitiesCodeSystemVersionFilter(obj : TTurtleComplex) : TFhirTerminologyCapabilitiesCodeSystemVersionFilter;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTerminologyCapabilitiesCodeSystemVersionFilter.create;
  try
    ParseTerminologyCapabilitiesCodeSystemVersionFilterProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTerminologyCapabilitiesCodeSystemVersionFilterProperties(obj : TTurtleComplex; result : TFhirTerminologyCapabilitiesCodeSystemVersionFilter);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.codeElement := ParseCode(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.codeSystem.version.filter.code'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/TerminologyCapabilities.codeSystem.version.filter.op') do
      result.opList.Add(parseCode(item));
end;

procedure TFHIRTurtleComposer.ComposeTerminologyCapabilitiesCodeSystemVersionFilter(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTerminologyCapabilitiesCodeSystemVersionFilter; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TerminologyCapabilitiesCodeSystemVersionFilter'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCode(this, 'TerminologyCapabilities.codeSystem.version.filter', 'code', elem.codeElement, false, -1);{x.2ea}
  for i := 0 to elem.opList.Count - 1 do
      ComposeCode(this, 'TerminologyCapabilities.codeSystem.version.filter', 'op', elem.opList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseTerminologyCapabilitiesExpansion(obj : TTurtleComplex) : TFhirTerminologyCapabilitiesExpansion;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTerminologyCapabilitiesExpansion.create;
  try
    ParseTerminologyCapabilitiesExpansionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTerminologyCapabilitiesExpansionProperties(obj : TTurtleComplex; result : TFhirTerminologyCapabilitiesExpansion);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.hierarchicalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.expansion.hierarchical'));{q1}
    result.pagingElement := ParseBoolean(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.expansion.paging'));{q1}
    result.incompleteElement := ParseBoolean(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.expansion.incomplete'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/TerminologyCapabilities.expansion.parameter') do
      result.parameterList.Add(parseTerminologyCapabilitiesExpansionParameter(item));
    result.textFilterElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.expansion.textFilter'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeTerminologyCapabilitiesExpansion(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTerminologyCapabilitiesExpansion; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TerminologyCapabilitiesExpansion'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'TerminologyCapabilities.expansion', 'hierarchical', elem.hierarchicalElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'TerminologyCapabilities.expansion', 'paging', elem.pagingElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'TerminologyCapabilities.expansion', 'incomplete', elem.incompleteElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.parameterList.Count - 1 do
      ComposeTerminologyCapabilitiesExpansionParameter(this, 'TerminologyCapabilities.expansion', 'parameter', elem.parameterList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'TerminologyCapabilities.expansion', 'textFilter', elem.textFilterElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseTerminologyCapabilitiesExpansionParameter(obj : TTurtleComplex) : TFhirTerminologyCapabilitiesExpansionParameter;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTerminologyCapabilitiesExpansionParameter.create;
  try
    ParseTerminologyCapabilitiesExpansionParameterProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTerminologyCapabilitiesExpansionParameterProperties(obj : TTurtleComplex; result : TFhirTerminologyCapabilitiesExpansionParameter);
begin
    ParseBackboneElementProperties(obj, result);
    result.nameElement := ParseCode(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.expansion.parameter.name'));{q1}
    result.documentationElement := ParseString(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.expansion.parameter.documentation'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeTerminologyCapabilitiesExpansionParameter(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTerminologyCapabilitiesExpansionParameter; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TerminologyCapabilitiesExpansionParameter'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCode(this, 'TerminologyCapabilities.expansion.parameter', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TerminologyCapabilities.expansion.parameter', 'documentation', elem.documentationElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseTerminologyCapabilitiesValidateCode(obj : TTurtleComplex) : TFhirTerminologyCapabilitiesValidateCode;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTerminologyCapabilitiesValidateCode.create;
  try
    ParseTerminologyCapabilitiesValidateCodeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTerminologyCapabilitiesValidateCodeProperties(obj : TTurtleComplex; result : TFhirTerminologyCapabilitiesValidateCode);
begin
    ParseBackboneElementProperties(obj, result);
    result.translationsElement := ParseBoolean(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.validateCode.translations'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeTerminologyCapabilitiesValidateCode(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTerminologyCapabilitiesValidateCode; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TerminologyCapabilitiesValidateCode'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeBoolean(this, 'TerminologyCapabilities.validateCode', 'translations', elem.translationsElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseTerminologyCapabilitiesTranslation(obj : TTurtleComplex) : TFhirTerminologyCapabilitiesTranslation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTerminologyCapabilitiesTranslation.create;
  try
    ParseTerminologyCapabilitiesTranslationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTerminologyCapabilitiesTranslationProperties(obj : TTurtleComplex; result : TFhirTerminologyCapabilitiesTranslation);
begin
    ParseBackboneElementProperties(obj, result);
    result.needsMapElement := ParseBoolean(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.translation.needsMap'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeTerminologyCapabilitiesTranslation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTerminologyCapabilitiesTranslation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TerminologyCapabilitiesTranslation'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeBoolean(this, 'TerminologyCapabilities.translation', 'needsMap', elem.needsMapElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseTerminologyCapabilitiesClosure(obj : TTurtleComplex) : TFhirTerminologyCapabilitiesClosure;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTerminologyCapabilitiesClosure.create;
  try
    ParseTerminologyCapabilitiesClosureProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTerminologyCapabilitiesClosureProperties(obj : TTurtleComplex; result : TFhirTerminologyCapabilitiesClosure);
begin
    ParseBackboneElementProperties(obj, result);
    result.translationElement := ParseBoolean(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.closure.translation'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeTerminologyCapabilitiesClosure(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTerminologyCapabilitiesClosure; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TerminologyCapabilitiesClosure'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'TerminologyCapabilities.closure', 'translation', elem.translationElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseTerminologyCapabilities(obj : TTurtleComplex) : TFhirTerminologyCapabilities;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTerminologyCapabilities.create;
  try
    ParseTerminologyCapabilitiesProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTerminologyCapabilitiesProperties(obj : TTurtleComplex; result : TFhirTerminologyCapabilities);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.url'));{q1}
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.version'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.name'));{q1}
    result.titleElement := ParseString(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.title'));{q1}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    result.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.experimental'));{q1}
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.date'));{q1}
    result.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.publisher'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/TerminologyCapabilities.contact') do
      result.contactList.Add(parseContactDetail(item));
    result.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/TerminologyCapabilities.useContext') do
      result.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/TerminologyCapabilities.jurisdiction') do
      result.jurisdictionList.Add(parseCodeableConcept(item));
    result.purposeElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.purpose'));{q1}
    result.copyrightElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.copyright'));{q1}
    result.kindElement := ParseEnum(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.kind'), CODES_TFhirCapabilityStatementKindEnum, SYSTEMS_TFhirCapabilityStatementKindEnum);
    result.software := ParseTerminologyCapabilitiesSoftware(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.software'));{q3b}
    result.implementation_ := ParseTerminologyCapabilitiesImplementation(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.implementation'));{q3b}
    result.lockedDateElement := ParseBoolean(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.lockedDate'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/TerminologyCapabilities.codeSystem') do
      result.codeSystemList.Add(parseTerminologyCapabilitiesCodeSystem(item));
    result.expansion := ParseTerminologyCapabilitiesExpansion(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.expansion'));{q3b}
    result.codeSearchElement := ParseEnum(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.codeSearch'), CODES_TFhirCodeSearchSupportEnum, SYSTEMS_TFhirCodeSearchSupportEnum);
    result.validateCode := ParseTerminologyCapabilitiesValidateCode(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.validateCode'));{q3b}
    result.translation := ParseTerminologyCapabilitiesTranslation(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.translation'));{q3b}
    result.closure := ParseTerminologyCapabilitiesClosure(obj.complex('http://hl7.org/fhir/TerminologyCapabilities.closure'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeTerminologyCapabilities(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTerminologyCapabilities; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TerminologyCapabilities'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUri(this, 'TerminologyCapabilities', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(this, 'TerminologyCapabilities', 'version', elem.versionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(this, 'TerminologyCapabilities', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeString(this, 'TerminologyCapabilities', 'title', elem.titleElement, false, -1);{x.2ea}
  ComposeEnum(this, 'TerminologyCapabilities', 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(this, 'TerminologyCapabilities', 'experimental', elem.experimentalElement, false, -1);{x.2ea}
  ComposeDateTime(this, 'TerminologyCapabilities', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(this, 'TerminologyCapabilities', 'publisher', elem.publisherElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(this, 'TerminologyCapabilities', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdown(this, 'TerminologyCapabilities', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(this, 'TerminologyCapabilities', 'useContext', elem.useContextList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'TerminologyCapabilities', 'jurisdiction', elem.jurisdictionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdown(this, 'TerminologyCapabilities', 'purpose', elem.purposeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('copyright') then
    ComposeMarkdown(this, 'TerminologyCapabilities', 'copyright', elem.copyrightElement, false, -1);{x.2ea}
  ComposeEnum(this, 'TerminologyCapabilities', 'kind', elem.KindElement, CODES_TFhirCapabilityStatementKindEnum, SYSTEMS_TFhirCapabilityStatementKindEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('software') then
    ComposeTerminologyCapabilitiesSoftware(this, 'TerminologyCapabilities', 'software', elem.softwareElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('implementation_') then
    ComposeTerminologyCapabilitiesImplementation(this, 'TerminologyCapabilities', 'implementation', elem.implementation_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('lockedDate') then
    ComposeBoolean(this, 'TerminologyCapabilities', 'lockedDate', elem.lockedDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('codeSystem') then
    for i := 0 to elem.codeSystemList.Count - 1 do
      ComposeTerminologyCapabilitiesCodeSystem(this, 'TerminologyCapabilities', 'codeSystem', elem.codeSystemList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('expansion') then
    ComposeTerminologyCapabilitiesExpansion(this, 'TerminologyCapabilities', 'expansion', elem.expansionElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('codeSearch') then
    ComposeEnum(this, 'TerminologyCapabilities', 'codeSearch', elem.CodeSearchElement, CODES_TFhirCodeSearchSupportEnum, SYSTEMS_TFhirCodeSearchSupportEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) and doCompose('validateCode') then
    ComposeTerminologyCapabilitiesValidateCode(this, 'TerminologyCapabilities', 'validateCode', elem.validateCodeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('translation') then
    ComposeTerminologyCapabilitiesTranslation(this, 'TerminologyCapabilities', 'translation', elem.translationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('closure') then
    ComposeTerminologyCapabilitiesClosure(this, 'TerminologyCapabilities', 'closure', elem.closureElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_TERMINOLOGYCAPABILITIES}
{$IFDEF FHIR_TESTREPORT}
function TFHIRTurtleParser.ParseTestReportParticipant(obj : TTurtleComplex) : TFhirTestReportParticipant;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestReportParticipant.create;
  try
    ParseTestReportParticipantProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestReportParticipantProperties(obj : TTurtleComplex; result : TFhirTestReportParticipant);
begin
    ParseBackboneElementProperties(obj, result);
    result.type_Element := ParseEnum(obj.complex('http://hl7.org/fhir/TestReport.participant.type'), CODES_TFhirReportParticipantTypeEnum, SYSTEMS_TFhirReportParticipantTypeEnum);
    result.uriElement := ParseUri(obj.complex('http://hl7.org/fhir/TestReport.participant.uri'));{q1}
    result.displayElement := ParseString(obj.complex('http://hl7.org/fhir/TestReport.participant.display'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeTestReportParticipant(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestReportParticipant; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestReportParticipant'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'TestReport.participant', 'type', elem.Type_Element, CODES_TFhirReportParticipantTypeEnum, SYSTEMS_TFhirReportParticipantTypeEnum, false, -1);{x.d4}
  ComposeUri(this, 'TestReport.participant', 'uri', elem.uriElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestReport.participant', 'display', elem.displayElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseTestReportSetup(obj : TTurtleComplex) : TFhirTestReportSetup;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestReportSetup.create;
  try
    ParseTestReportSetupProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestReportSetupProperties(obj : TTurtleComplex; result : TFhirTestReportSetup);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/TestReport.setup.action') do
      result.actionList.Add(parseTestReportSetupAction(item));
end;

procedure TFHIRTurtleComposer.ComposeTestReportSetup(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestReportSetup; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestReportSetup'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  for i := 0 to elem.actionList.Count - 1 do
      ComposeTestReportSetupAction(this, 'TestReport.setup', 'action', elem.actionList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseTestReportSetupAction(obj : TTurtleComplex) : TFhirTestReportSetupAction;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestReportSetupAction.create;
  try
    ParseTestReportSetupActionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestReportSetupActionProperties(obj : TTurtleComplex; result : TFhirTestReportSetupAction);
begin
    ParseBackboneElementProperties(obj, result);
    result.operation := ParseTestReportSetupActionOperation(obj.complex('http://hl7.org/fhir/TestReport.setup.action.operation'));{q3b}
    result.assert := ParseTestReportSetupActionAssert(obj.complex('http://hl7.org/fhir/TestReport.setup.action.assert'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeTestReportSetupAction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestReportSetupAction; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestReportSetupAction'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeTestReportSetupActionOperation(this, 'TestReport.setup.action', 'operation', elem.operationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeTestReportSetupActionAssert(this, 'TestReport.setup.action', 'assert', elem.assertElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseTestReportSetupActionOperation(obj : TTurtleComplex) : TFhirTestReportSetupActionOperation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestReportSetupActionOperation.create;
  try
    ParseTestReportSetupActionOperationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestReportSetupActionOperationProperties(obj : TTurtleComplex; result : TFhirTestReportSetupActionOperation);
begin
    ParseBackboneElementProperties(obj, result);
    result.resultElement := ParseEnum(obj.complex('http://hl7.org/fhir/TestReport.setup.action.operation.result'), CODES_TFhirReportActionResultCodesEnum, SYSTEMS_TFhirReportActionResultCodesEnum);
    result.messageElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/TestReport.setup.action.operation.message'));{q1}
    result.detailElement := ParseUri(obj.complex('http://hl7.org/fhir/TestReport.setup.action.operation.detail'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeTestReportSetupActionOperation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestReportSetupActionOperation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestReportSetupActionOperation'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'TestReport.setup.action.operation', 'result', elem.ResultElement, CODES_TFhirReportActionResultCodesEnum, SYSTEMS_TFhirReportActionResultCodesEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'TestReport.setup.action.operation', 'message', elem.messageElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'TestReport.setup.action.operation', 'detail', elem.detailElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseTestReportSetupActionAssert(obj : TTurtleComplex) : TFhirTestReportSetupActionAssert;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestReportSetupActionAssert.create;
  try
    ParseTestReportSetupActionAssertProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestReportSetupActionAssertProperties(obj : TTurtleComplex; result : TFhirTestReportSetupActionAssert);
begin
    ParseBackboneElementProperties(obj, result);
    result.resultElement := ParseEnum(obj.complex('http://hl7.org/fhir/TestReport.setup.action.assert.result'), CODES_TFhirReportActionResultCodesEnum, SYSTEMS_TFhirReportActionResultCodesEnum);
    result.messageElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/TestReport.setup.action.assert.message'));{q1}
    result.detailElement := ParseString(obj.complex('http://hl7.org/fhir/TestReport.setup.action.assert.detail'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeTestReportSetupActionAssert(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestReportSetupActionAssert; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestReportSetupActionAssert'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeEnum(this, 'TestReport.setup.action.assert', 'result', elem.ResultElement, CODES_TFhirReportActionResultCodesEnum, SYSTEMS_TFhirReportActionResultCodesEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdown(this, 'TestReport.setup.action.assert', 'message', elem.messageElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestReport.setup.action.assert', 'detail', elem.detailElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseTestReportTest(obj : TTurtleComplex) : TFhirTestReportTest;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestReportTest.create;
  try
    ParseTestReportTestProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestReportTestProperties(obj : TTurtleComplex; result : TFhirTestReportTest);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/TestReport.test.name'));{q1}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/TestReport.test.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/TestReport.test.action') do
      result.actionList.Add(parseTestReportTestAction(item));
end;

procedure TFHIRTurtleComposer.ComposeTestReportTest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestReportTest; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestReportTest'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestReport.test', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestReport.test', 'description', elem.descriptionElement, false, -1);{x.2ea}
  for i := 0 to elem.actionList.Count - 1 do
      ComposeTestReportTestAction(this, 'TestReport.test', 'action', elem.actionList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseTestReportTestAction(obj : TTurtleComplex) : TFhirTestReportTestAction;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestReportTestAction.create;
  try
    ParseTestReportTestActionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestReportTestActionProperties(obj : TTurtleComplex; result : TFhirTestReportTestAction);
begin
    ParseBackboneElementProperties(obj, result);
    result.operation := ParseTestReportSetupActionOperation(obj.complex('http://hl7.org/fhir/TestReport.test.action.operation'));{q3b}
    result.assert := ParseTestReportSetupActionAssert(obj.complex('http://hl7.org/fhir/TestReport.test.action.assert'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeTestReportTestAction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestReportTestAction; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestReportTestAction'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeTestReportSetupActionOperation(this, 'TestReport.test.action', 'operation', elem.operationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeTestReportSetupActionAssert(this, 'TestReport.test.action', 'assert', elem.assertElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseTestReportTeardown(obj : TTurtleComplex) : TFhirTestReportTeardown;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestReportTeardown.create;
  try
    ParseTestReportTeardownProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestReportTeardownProperties(obj : TTurtleComplex; result : TFhirTestReportTeardown);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/TestReport.teardown.action') do
      result.actionList.Add(parseTestReportTeardownAction(item));
end;

procedure TFHIRTurtleComposer.ComposeTestReportTeardown(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestReportTeardown; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestReportTeardown'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  for i := 0 to elem.actionList.Count - 1 do
      ComposeTestReportTeardownAction(this, 'TestReport.teardown', 'action', elem.actionList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseTestReportTeardownAction(obj : TTurtleComplex) : TFhirTestReportTeardownAction;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestReportTeardownAction.create;
  try
    ParseTestReportTeardownActionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestReportTeardownActionProperties(obj : TTurtleComplex; result : TFhirTestReportTeardownAction);
begin
    ParseBackboneElementProperties(obj, result);
    result.operation := ParseTestReportSetupActionOperation(obj.complex('http://hl7.org/fhir/TestReport.teardown.action.operation'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeTestReportTeardownAction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestReportTeardownAction; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestReportTeardownAction'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeTestReportSetupActionOperation(this, 'TestReport.teardown.action', 'operation', elem.operationElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseTestReport(obj : TTurtleComplex) : TFhirTestReport;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestReport.create;
  try
    ParseTestReportProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestReportProperties(obj : TTurtleComplex; result : TFhirTestReport);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/TestReport.identifier'));{q3b}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/TestReport.name'));{q1}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/TestReport.status'), CODES_TFhirReportStatusCodesEnum, SYSTEMS_TFhirReportStatusCodesEnum);
    result.testScript := ParseReference{TFhirTestScript}(obj.complex('http://hl7.org/fhir/TestReport.testScript'));{q3b}
    result.resultElement := ParseEnum(obj.complex('http://hl7.org/fhir/TestReport.result'), CODES_TFhirReportResultCodesEnum, SYSTEMS_TFhirReportResultCodesEnum);
    result.scoreElement := ParseDecimal(obj.complex('http://hl7.org/fhir/TestReport.score'));{q1}
    result.testerElement := ParseString(obj.complex('http://hl7.org/fhir/TestReport.tester'));{q1}
    result.issuedElement := ParseDateTime(obj.complex('http://hl7.org/fhir/TestReport.issued'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/TestReport.participant') do
      result.participantList.Add(parseTestReportParticipant(item));
    result.setup := ParseTestReportSetup(obj.complex('http://hl7.org/fhir/TestReport.setup'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/TestReport.test') do
      result.testList.Add(parseTestReportTest(item));
    result.teardown := ParseTestReportTeardown(obj.complex('http://hl7.org/fhir/TestReport.teardown'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeTestReport(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestReport; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestReport'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(this, 'TestReport', 'identifier', elem.identifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(this, 'TestReport', 'name', elem.nameElement, false, -1);{x.2ea}
  ComposeEnum(this, 'TestReport', 'status', elem.StatusElement, CODES_TFhirReportStatusCodesEnum, SYSTEMS_TFhirReportStatusCodesEnum, false, -1);{x.d4}
  ComposeReference{TFhirTestScript}(this, 'TestReport', 'testScript', elem.testScriptElement, false, -1);{x.2f}
  ComposeEnum(this, 'TestReport', 'result', elem.ResultElement, CODES_TFhirReportResultCodesEnum, SYSTEMS_TFhirReportResultCodesEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('score') then
    ComposeDecimal(this, 'TestReport', 'score', elem.scoreElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('tester') then
    ComposeString(this, 'TestReport', 'tester', elem.testerElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('issued') then
    ComposeDateTime(this, 'TestReport', 'issued', elem.issuedElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('participant') then
    for i := 0 to elem.participantList.Count - 1 do
      ComposeTestReportParticipant(this, 'TestReport', 'participant', elem.participantList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('setup') then
    ComposeTestReportSetup(this, 'TestReport', 'setup', elem.setupElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('test') then
    for i := 0 to elem.testList.Count - 1 do
      ComposeTestReportTest(this, 'TestReport', 'test', elem.testList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('teardown') then
    ComposeTestReportTeardown(this, 'TestReport', 'teardown', elem.teardownElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_TESTREPORT}
{$IFDEF FHIR_TESTSCRIPT}
function TFHIRTurtleParser.ParseTestScriptOrigin(obj : TTurtleComplex) : TFhirTestScriptOrigin;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScriptOrigin.create;
  try
    ParseTestScriptOriginProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptOriginProperties(obj : TTurtleComplex; result : TFhirTestScriptOrigin);
begin
    ParseBackboneElementProperties(obj, result);
    result.indexElement := ParseInteger(obj.complex('http://hl7.org/fhir/TestScript.origin.index'));{q1}
    result.profile := ParseCoding(obj.complex('http://hl7.org/fhir/TestScript.origin.profile'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeTestScriptOrigin(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptOrigin; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScriptOrigin'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeInteger(this, 'TestScript.origin', 'index', elem.indexElement, false, -1);{x.2ea}
  ComposeCoding(this, 'TestScript.origin', 'profile', elem.profileElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseTestScriptDestination(obj : TTurtleComplex) : TFhirTestScriptDestination;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScriptDestination.create;
  try
    ParseTestScriptDestinationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptDestinationProperties(obj : TTurtleComplex; result : TFhirTestScriptDestination);
begin
    ParseBackboneElementProperties(obj, result);
    result.indexElement := ParseInteger(obj.complex('http://hl7.org/fhir/TestScript.destination.index'));{q1}
    result.profile := ParseCoding(obj.complex('http://hl7.org/fhir/TestScript.destination.profile'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeTestScriptDestination(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptDestination; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScriptDestination'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeInteger(this, 'TestScript.destination', 'index', elem.indexElement, false, -1);{x.2ea}
  ComposeCoding(this, 'TestScript.destination', 'profile', elem.profileElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseTestScriptMetadata(obj : TTurtleComplex) : TFhirTestScriptMetadata;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScriptMetadata.create;
  try
    ParseTestScriptMetadataProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptMetadataProperties(obj : TTurtleComplex; result : TFhirTestScriptMetadata);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/TestScript.metadata.link') do
      result.link_List.Add(parseTestScriptMetadataLink(item));
    for item in obj.complexes('http://hl7.org/fhir/TestScript.metadata.capability') do
      result.capabilityList.Add(parseTestScriptMetadataCapability(item));
end;

procedure TFHIRTurtleComposer.ComposeTestScriptMetadata(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptMetadata; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScriptMetadata'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.link_List.Count - 1 do
      ComposeTestScriptMetadataLink(this, 'TestScript.metadata', 'link', elem.link_List[i], false, i);{x.d3}
  for i := 0 to elem.capabilityList.Count - 1 do
      ComposeTestScriptMetadataCapability(this, 'TestScript.metadata', 'capability', elem.capabilityList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseTestScriptMetadataLink(obj : TTurtleComplex) : TFhirTestScriptMetadataLink;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScriptMetadataLink.create;
  try
    ParseTestScriptMetadataLinkProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptMetadataLinkProperties(obj : TTurtleComplex; result : TFhirTestScriptMetadataLink);
begin
    ParseBackboneElementProperties(obj, result);
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/TestScript.metadata.link.url'));{q1}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.metadata.link.description'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeTestScriptMetadataLink(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptMetadataLink; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScriptMetadataLink'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeUri(this, 'TestScript.metadata.link', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.metadata.link', 'description', elem.descriptionElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseTestScriptMetadataCapability(obj : TTurtleComplex) : TFhirTestScriptMetadataCapability;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScriptMetadataCapability.create;
  try
    ParseTestScriptMetadataCapabilityProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptMetadataCapabilityProperties(obj : TTurtleComplex; result : TFhirTestScriptMetadataCapability);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.requiredElement := ParseBoolean(obj.complex('http://hl7.org/fhir/TestScript.metadata.capability.required'));{q1}
    result.validatedElement := ParseBoolean(obj.complex('http://hl7.org/fhir/TestScript.metadata.capability.validated'));{q1}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.metadata.capability.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/TestScript.metadata.capability.origin') do
      result.originList.Add(parseInteger(item));
    result.destinationElement := ParseInteger(obj.complex('http://hl7.org/fhir/TestScript.metadata.capability.destination'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/TestScript.metadata.capability.link') do
      result.link_List.Add(parseUri(item));
    result.capabilitiesElement := ParseCanonical(obj.complex('http://hl7.org/fhir/TestScript.metadata.capability.capabilities'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeTestScriptMetadataCapability(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptMetadataCapability; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScriptMetadataCapability'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeBoolean(this, 'TestScript.metadata.capability', 'required', elem.requiredElement, false, -1);{x.2ea}
  ComposeBoolean(this, 'TestScript.metadata.capability', 'validated', elem.validatedElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.metadata.capability', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.originList.Count - 1 do
      ComposeInteger(this, 'TestScript.metadata.capability', 'origin', elem.originList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(this, 'TestScript.metadata.capability', 'destination', elem.destinationElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.link_List.Count - 1 do
      ComposeUri(this, 'TestScript.metadata.capability', 'link', elem.link_List[i], false, i);{x.d3}
  ComposeCanonical(this, 'TestScript.metadata.capability', 'capabilities', elem.capabilitiesElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseTestScriptFixture(obj : TTurtleComplex) : TFhirTestScriptFixture;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScriptFixture.create;
  try
    ParseTestScriptFixtureProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptFixtureProperties(obj : TTurtleComplex; result : TFhirTestScriptFixture);
begin
    ParseBackboneElementProperties(obj, result);
    result.autocreateElement := ParseBoolean(obj.complex('http://hl7.org/fhir/TestScript.fixture.autocreate'));{q1}
    result.autodeleteElement := ParseBoolean(obj.complex('http://hl7.org/fhir/TestScript.fixture.autodelete'));{q1}
    result.resource := ParseReference{TFhirReference}(obj.complex('http://hl7.org/fhir/TestScript.fixture.resource'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeTestScriptFixture(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptFixture; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScriptFixture'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeBoolean(this, 'TestScript.fixture', 'autocreate', elem.autocreateElement, false, -1);{x.2ea}
  ComposeBoolean(this, 'TestScript.fixture', 'autodelete', elem.autodeleteElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirReference}(this, 'TestScript.fixture', 'resource', elem.resourceElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseTestScriptVariable(obj : TTurtleComplex) : TFhirTestScriptVariable;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScriptVariable.create;
  try
    ParseTestScriptVariableProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptVariableProperties(obj : TTurtleComplex; result : TFhirTestScriptVariable);
begin
    ParseBackboneElementProperties(obj, result);
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.variable.name'));{q1}
    result.defaultValueElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.variable.defaultValue'));{q1}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.variable.description'));{q1}
    result.expressionElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.variable.expression'));{q1}
    result.headerFieldElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.variable.headerField'));{q1}
    result.hintElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.variable.hint'));{q1}
    result.pathElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.variable.path'));{q1}
    result.sourceIdElement := ParseId(obj.complex('http://hl7.org/fhir/TestScript.variable.sourceId'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeTestScriptVariable(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptVariable; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScriptVariable'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeString(this, 'TestScript.variable', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.variable', 'defaultValue', elem.defaultValueElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.variable', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.variable', 'expression', elem.expressionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.variable', 'headerField', elem.headerFieldElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.variable', 'hint', elem.hintElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.variable', 'path', elem.pathElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeId(this, 'TestScript.variable', 'sourceId', elem.sourceIdElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseTestScriptSetup(obj : TTurtleComplex) : TFhirTestScriptSetup;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScriptSetup.create;
  try
    ParseTestScriptSetupProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptSetupProperties(obj : TTurtleComplex; result : TFhirTestScriptSetup);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/TestScript.setup.action') do
      result.actionList.Add(parseTestScriptSetupAction(item));
end;

procedure TFHIRTurtleComposer.ComposeTestScriptSetup(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptSetup; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScriptSetup'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  for i := 0 to elem.actionList.Count - 1 do
      ComposeTestScriptSetupAction(this, 'TestScript.setup', 'action', elem.actionList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseTestScriptSetupAction(obj : TTurtleComplex) : TFhirTestScriptSetupAction;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScriptSetupAction.create;
  try
    ParseTestScriptSetupActionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptSetupActionProperties(obj : TTurtleComplex; result : TFhirTestScriptSetupAction);
begin
    ParseBackboneElementProperties(obj, result);
    result.operation := ParseTestScriptSetupActionOperation(obj.complex('http://hl7.org/fhir/TestScript.setup.action.operation'));{q3b}
    result.assert := ParseTestScriptSetupActionAssert(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeTestScriptSetupAction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptSetupAction; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScriptSetupAction'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptSetupActionOperation(this, 'TestScript.setup.action', 'operation', elem.operationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptSetupActionAssert(this, 'TestScript.setup.action', 'assert', elem.assertElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseTestScriptSetupActionOperation(obj : TTurtleComplex) : TFhirTestScriptSetupActionOperation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScriptSetupActionOperation.create;
  try
    ParseTestScriptSetupActionOperationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptSetupActionOperationProperties(obj : TTurtleComplex; result : TFhirTestScriptSetupActionOperation);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.type_ := ParseCoding(obj.complex('http://hl7.org/fhir/TestScript.setup.action.operation.type'));{q3b}
    result.resourceElement := ParseCode(obj.complex('http://hl7.org/fhir/TestScript.setup.action.operation.resource'));{q1}
    result.label_Element := ParseString(obj.complex('http://hl7.org/fhir/TestScript.setup.action.operation.label'));{q1}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.setup.action.operation.description'));{q1}
    result.acceptElement := ParseCode(obj.complex('http://hl7.org/fhir/TestScript.setup.action.operation.accept'));{q1}
    result.contentTypeElement := ParseCode(obj.complex('http://hl7.org/fhir/TestScript.setup.action.operation.contentType'));{q1}
    result.destinationElement := ParseInteger(obj.complex('http://hl7.org/fhir/TestScript.setup.action.operation.destination'));{q1}
    result.encodeRequestUrlElement := ParseBoolean(obj.complex('http://hl7.org/fhir/TestScript.setup.action.operation.encodeRequestUrl'));{q1}
    result.methodElement := ParseEnum(obj.complex('http://hl7.org/fhir/TestScript.setup.action.operation.method'), CODES_TFhirHttpOperationsEnum, SYSTEMS_TFhirHttpOperationsEnum);
    result.originElement := ParseInteger(obj.complex('http://hl7.org/fhir/TestScript.setup.action.operation.origin'));{q1}
    result.paramsElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.setup.action.operation.params'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/TestScript.setup.action.operation.requestHeader') do
      result.requestHeaderList.Add(parseTestScriptSetupActionOperationRequestHeader(item));
    result.requestIdElement := ParseId(obj.complex('http://hl7.org/fhir/TestScript.setup.action.operation.requestId'));{q1}
    result.responseIdElement := ParseId(obj.complex('http://hl7.org/fhir/TestScript.setup.action.operation.responseId'));{q1}
    result.sourceIdElement := ParseId(obj.complex('http://hl7.org/fhir/TestScript.setup.action.operation.sourceId'));{q1}
    result.targetIdElement := ParseId(obj.complex('http://hl7.org/fhir/TestScript.setup.action.operation.targetId'));{q1}
    result.urlElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.setup.action.operation.url'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeTestScriptSetupActionOperation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptSetupActionOperation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScriptSetupActionOperation'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(this, 'TestScript.setup.action.operation', 'type', elem.type_Element, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(this, 'TestScript.setup.action.operation', 'resource', elem.resourceElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.setup.action.operation', 'label', elem.label_Element, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.setup.action.operation', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(this, 'TestScript.setup.action.operation', 'accept', elem.acceptElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(this, 'TestScript.setup.action.operation', 'contentType', elem.contentTypeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(this, 'TestScript.setup.action.operation', 'destination', elem.destinationElement, false, -1);{x.2ea}
  ComposeBoolean(this, 'TestScript.setup.action.operation', 'encodeRequestUrl', elem.encodeRequestUrlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'TestScript.setup.action.operation', 'method', elem.MethodElement, CODES_TFhirHttpOperationsEnum, SYSTEMS_TFhirHttpOperationsEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(this, 'TestScript.setup.action.operation', 'origin', elem.originElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.setup.action.operation', 'params', elem.paramsElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.requestHeaderList.Count - 1 do
      ComposeTestScriptSetupActionOperationRequestHeader(this, 'TestScript.setup.action.operation', 'requestHeader', elem.requestHeaderList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeId(this, 'TestScript.setup.action.operation', 'requestId', elem.requestIdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeId(this, 'TestScript.setup.action.operation', 'responseId', elem.responseIdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeId(this, 'TestScript.setup.action.operation', 'sourceId', elem.sourceIdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeId(this, 'TestScript.setup.action.operation', 'targetId', elem.targetIdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.setup.action.operation', 'url', elem.urlElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseTestScriptSetupActionOperationRequestHeader(obj : TTurtleComplex) : TFhirTestScriptSetupActionOperationRequestHeader;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScriptSetupActionOperationRequestHeader.create;
  try
    ParseTestScriptSetupActionOperationRequestHeaderProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptSetupActionOperationRequestHeaderProperties(obj : TTurtleComplex; result : TFhirTestScriptSetupActionOperationRequestHeader);
begin
    ParseBackboneElementProperties(obj, result);
    result.fieldElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.setup.action.operation.requestHeader.field'));{q1}
    result.valueElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.setup.action.operation.requestHeader.value'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeTestScriptSetupActionOperationRequestHeader(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptSetupActionOperationRequestHeader; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScriptSetupActionOperationRequestHeader'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeString(this, 'TestScript.setup.action.operation.requestHeader', 'field', elem.fieldElement, false, -1);{x.2ea}
  ComposeString(this, 'TestScript.setup.action.operation.requestHeader', 'value', elem.valueElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseTestScriptSetupActionAssert(obj : TTurtleComplex) : TFhirTestScriptSetupActionAssert;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScriptSetupActionAssert.create;
  try
    ParseTestScriptSetupActionAssertProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptSetupActionAssertProperties(obj : TTurtleComplex; result : TFhirTestScriptSetupActionAssert);
begin
    ParseBackboneElementProperties(obj, result);
    result.label_Element := ParseString(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.label'));{q1}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.description'));{q1}
    result.directionElement := ParseEnum(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.direction'), CODES_TFhirAssertDirectionCodesEnum, SYSTEMS_TFhirAssertDirectionCodesEnum);
    result.compareToSourceIdElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.compareToSourceId'));{q1}
    result.compareToSourceExpressionElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.compareToSourceExpression'));{q1}
    result.compareToSourcePathElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.compareToSourcePath'));{q1}
    result.contentTypeElement := ParseCode(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.contentType'));{q1}
    result.expressionElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.expression'));{q1}
    result.headerFieldElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.headerField'));{q1}
    result.minimumIdElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.minimumId'));{q1}
    result.navigationLinksElement := ParseBoolean(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.navigationLinks'));{q1}
    result.operatorElement := ParseEnum(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.operator'), CODES_TFhirAssertOperatorCodesEnum, SYSTEMS_TFhirAssertOperatorCodesEnum);
    result.pathElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.path'));{q1}
    result.requestMethodElement := ParseEnum(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.requestMethod'), CODES_TFhirHttpOperationsEnum, SYSTEMS_TFhirHttpOperationsEnum);
    result.requestURLElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.requestURL'));{q1}
    result.resourceElement := ParseCode(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.resource'));{q1}
    result.responseElement := ParseEnum(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.response'), CODES_TFhirAssertResponseCodeTypesEnum, SYSTEMS_TFhirAssertResponseCodeTypesEnum);
    result.responseCodeElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.responseCode'));{q1}
    result.sourceIdElement := ParseId(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.sourceId'));{q1}
    result.validateProfileIdElement := ParseId(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.validateProfileId'));{q1}
    result.valueElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.value'));{q1}
    result.warningOnlyElement := ParseBoolean(obj.complex('http://hl7.org/fhir/TestScript.setup.action.assert.warningOnly'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeTestScriptSetupActionAssert(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptSetupActionAssert; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScriptSetupActionAssert'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.setup.action.assert', 'label', elem.label_Element, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.setup.action.assert', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'TestScript.setup.action.assert', 'direction', elem.DirectionElement, CODES_TFhirAssertDirectionCodesEnum, SYSTEMS_TFhirAssertDirectionCodesEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.setup.action.assert', 'compareToSourceId', elem.compareToSourceIdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.setup.action.assert', 'compareToSourceExpression', elem.compareToSourceExpressionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.setup.action.assert', 'compareToSourcePath', elem.compareToSourcePathElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(this, 'TestScript.setup.action.assert', 'contentType', elem.contentTypeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.setup.action.assert', 'expression', elem.expressionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.setup.action.assert', 'headerField', elem.headerFieldElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.setup.action.assert', 'minimumId', elem.minimumIdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'TestScript.setup.action.assert', 'navigationLinks', elem.navigationLinksElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'TestScript.setup.action.assert', 'operator', elem.OperatorElement, CODES_TFhirAssertOperatorCodesEnum, SYSTEMS_TFhirAssertOperatorCodesEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.setup.action.assert', 'path', elem.pathElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'TestScript.setup.action.assert', 'requestMethod', elem.RequestMethodElement, CODES_TFhirHttpOperationsEnum, SYSTEMS_TFhirHttpOperationsEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.setup.action.assert', 'requestURL', elem.requestURLElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(this, 'TestScript.setup.action.assert', 'resource', elem.resourceElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(this, 'TestScript.setup.action.assert', 'response', elem.ResponseElement, CODES_TFhirAssertResponseCodeTypesEnum, SYSTEMS_TFhirAssertResponseCodeTypesEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.setup.action.assert', 'responseCode', elem.responseCodeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeId(this, 'TestScript.setup.action.assert', 'sourceId', elem.sourceIdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeId(this, 'TestScript.setup.action.assert', 'validateProfileId', elem.validateProfileIdElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.setup.action.assert', 'value', elem.valueElement, false, -1);{x.2ea}
  ComposeBoolean(this, 'TestScript.setup.action.assert', 'warningOnly', elem.warningOnlyElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseTestScriptTest(obj : TTurtleComplex) : TFhirTestScriptTest;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScriptTest.create;
  try
    ParseTestScriptTestProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptTestProperties(obj : TTurtleComplex; result : TFhirTestScriptTest);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.test.name'));{q1}
    result.descriptionElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.test.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/TestScript.test.action') do
      result.actionList.Add(parseTestScriptTestAction(item));
end;

procedure TFHIRTurtleComposer.ComposeTestScriptTest(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptTest; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScriptTest'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.test', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'TestScript.test', 'description', elem.descriptionElement, false, -1);{x.2ea}
  for i := 0 to elem.actionList.Count - 1 do
      ComposeTestScriptTestAction(this, 'TestScript.test', 'action', elem.actionList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseTestScriptTestAction(obj : TTurtleComplex) : TFhirTestScriptTestAction;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScriptTestAction.create;
  try
    ParseTestScriptTestActionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptTestActionProperties(obj : TTurtleComplex; result : TFhirTestScriptTestAction);
begin
    ParseBackboneElementProperties(obj, result);
    result.operation := ParseTestScriptSetupActionOperation(obj.complex('http://hl7.org/fhir/TestScript.test.action.operation'));{q3b}
    result.assert := ParseTestScriptSetupActionAssert(obj.complex('http://hl7.org/fhir/TestScript.test.action.assert'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeTestScriptTestAction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptTestAction; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScriptTestAction'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptSetupActionOperation(this, 'TestScript.test.action', 'operation', elem.operationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptSetupActionAssert(this, 'TestScript.test.action', 'assert', elem.assertElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseTestScriptTeardown(obj : TTurtleComplex) : TFhirTestScriptTeardown;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScriptTeardown.create;
  try
    ParseTestScriptTeardownProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptTeardownProperties(obj : TTurtleComplex; result : TFhirTestScriptTeardown);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/TestScript.teardown.action') do
      result.actionList.Add(parseTestScriptTeardownAction(item));
end;

procedure TFHIRTurtleComposer.ComposeTestScriptTeardown(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptTeardown; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScriptTeardown'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  for i := 0 to elem.actionList.Count - 1 do
      ComposeTestScriptTeardownAction(this, 'TestScript.teardown', 'action', elem.actionList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseTestScriptTeardownAction(obj : TTurtleComplex) : TFhirTestScriptTeardownAction;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScriptTeardownAction.create;
  try
    ParseTestScriptTeardownActionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptTeardownActionProperties(obj : TTurtleComplex; result : TFhirTestScriptTeardownAction);
begin
    ParseBackboneElementProperties(obj, result);
    result.operation := ParseTestScriptSetupActionOperation(obj.complex('http://hl7.org/fhir/TestScript.teardown.action.operation'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeTestScriptTeardownAction(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScriptTeardownAction; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScriptTeardownAction'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeTestScriptSetupActionOperation(this, 'TestScript.teardown.action', 'operation', elem.operationElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseTestScript(obj : TTurtleComplex) : TFhirTestScript;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirTestScript.create;
  try
    ParseTestScriptProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseTestScriptProperties(obj : TTurtleComplex; result : TFhirTestScript);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/TestScript.url'));{q1}
    result.identifier := ParseIdentifier(obj.complex('http://hl7.org/fhir/TestScript.identifier'));{q3b}
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.version'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.name'));{q1}
    result.titleElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.title'));{q1}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/TestScript.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    result.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/TestScript.experimental'));{q1}
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/TestScript.date'));{q1}
    result.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/TestScript.publisher'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/TestScript.contact') do
      result.contactList.Add(parseContactDetail(item));
    result.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/TestScript.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/TestScript.useContext') do
      result.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/TestScript.jurisdiction') do
      result.jurisdictionList.Add(parseCodeableConcept(item));
    result.purposeElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/TestScript.purpose'));{q1}
    result.copyrightElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/TestScript.copyright'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/TestScript.origin') do
      result.originList.Add(parseTestScriptOrigin(item));
    for item in obj.complexes('http://hl7.org/fhir/TestScript.destination') do
      result.destinationList.Add(parseTestScriptDestination(item));
    result.metadata := ParseTestScriptMetadata(obj.complex('http://hl7.org/fhir/TestScript.metadata'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/TestScript.fixture') do
      result.fixtureList.Add(parseTestScriptFixture(item));
    for item in obj.complexes('http://hl7.org/fhir/TestScript.profile') do
      result.profileList.Add(parseReference{TFhirReference}(item));
    for item in obj.complexes('http://hl7.org/fhir/TestScript.variable') do
      result.variableList.Add(parseTestScriptVariable(item));
    result.setup := ParseTestScriptSetup(obj.complex('http://hl7.org/fhir/TestScript.setup'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/TestScript.test') do
      result.testList.Add(parseTestScriptTest(item));
    result.teardown := ParseTestScriptTeardown(obj.complex('http://hl7.org/fhir/TestScript.teardown'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeTestScript(parent :  TTurtleComplex; parentType, name : String; elem : TFhirTestScript; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:TestScript'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  ComposeUri(this, 'TestScript', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(this, 'TestScript', 'identifier', elem.identifierElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(this, 'TestScript', 'version', elem.versionElement, false, -1);{x.2ea}
  ComposeString(this, 'TestScript', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeString(this, 'TestScript', 'title', elem.titleElement, false, -1);{x.2ea}
  ComposeEnum(this, 'TestScript', 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(this, 'TestScript', 'experimental', elem.experimentalElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(this, 'TestScript', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(this, 'TestScript', 'publisher', elem.publisherElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(this, 'TestScript', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdown(this, 'TestScript', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(this, 'TestScript', 'useContext', elem.useContextList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'TestScript', 'jurisdiction', elem.jurisdictionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdown(this, 'TestScript', 'purpose', elem.purposeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdown(this, 'TestScript', 'copyright', elem.copyrightElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('origin') then
    for i := 0 to elem.originList.Count - 1 do
      ComposeTestScriptOrigin(this, 'TestScript', 'origin', elem.originList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('destination') then
    for i := 0 to elem.destinationList.Count - 1 do
      ComposeTestScriptDestination(this, 'TestScript', 'destination', elem.destinationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('metadata') then
    ComposeTestScriptMetadata(this, 'TestScript', 'metadata', elem.metadataElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('fixture') then
    for i := 0 to elem.fixtureList.Count - 1 do
      ComposeTestScriptFixture(this, 'TestScript', 'fixture', elem.fixtureList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('profile') then
    for i := 0 to elem.profileList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'TestScript', 'profile', elem.profileList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('variable') then
    for i := 0 to elem.variableList.Count - 1 do
      ComposeTestScriptVariable(this, 'TestScript', 'variable', elem.variableList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('setup') then
    ComposeTestScriptSetup(this, 'TestScript', 'setup', elem.setupElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('test') then
    for i := 0 to elem.testList.Count - 1 do
      ComposeTestScriptTest(this, 'TestScript', 'test', elem.testList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('teardown') then
    ComposeTestScriptTeardown(this, 'TestScript', 'teardown', elem.teardownElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_TESTSCRIPT}
{$IFDEF FHIR_VALUESET}
function TFHIRTurtleParser.ParseValueSetCompose(obj : TTurtleComplex) : TFhirValueSetCompose;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirValueSetCompose.create;
  try
    ParseValueSetComposeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseValueSetComposeProperties(obj : TTurtleComplex; result : TFhirValueSetCompose);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.lockedDateElement := ParseDate(obj.complex('http://hl7.org/fhir/ValueSet.compose.lockedDate'));{q1}
    result.inactiveElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ValueSet.compose.inactive'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ValueSet.compose.include') do
      result.includeList.Add(parseValueSetComposeInclude(item));
    for item in obj.complexes('http://hl7.org/fhir/ValueSet.compose.exclude') do
      result.excludeList.Add(parseValueSetComposeInclude(item));
end;

procedure TFHIRTurtleComposer.ComposeValueSetCompose(parent :  TTurtleComplex; parentType, name : String; elem : TFhirValueSetCompose; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ValueSetCompose'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDate(this, 'ValueSet.compose', 'lockedDate', elem.lockedDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(this, 'ValueSet.compose', 'inactive', elem.inactiveElement, false, -1);{x.2ea}
  for i := 0 to elem.includeList.Count - 1 do
      ComposeValueSetComposeInclude(this, 'ValueSet.compose', 'include', elem.includeList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.excludeList.Count - 1 do
      ComposeValueSetComposeInclude(this, 'ValueSet.compose', 'exclude', elem.excludeList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseValueSetComposeInclude(obj : TTurtleComplex) : TFhirValueSetComposeInclude;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirValueSetComposeInclude.create;
  try
    ParseValueSetComposeIncludeProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseValueSetComposeIncludeProperties(obj : TTurtleComplex; result : TFhirValueSetComposeInclude);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.systemElement := ParseUri(obj.complex('http://hl7.org/fhir/ValueSet.compose.include.system'));{q1}
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/ValueSet.compose.include.version'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ValueSet.compose.include.concept') do
      result.conceptList.Add(parseValueSetComposeIncludeConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/ValueSet.compose.include.filter') do
      result.filterList.Add(parseValueSetComposeIncludeFilter(item));
    for item in obj.complexes('http://hl7.org/fhir/ValueSet.compose.include.valueSet') do
      result.valueSetList.Add(parseCanonical(item));
end;

procedure TFHIRTurtleComposer.ComposeValueSetComposeInclude(parent :  TTurtleComplex; parentType, name : String; elem : TFhirValueSetComposeInclude; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ValueSetComposeInclude'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(this, 'ValueSet.compose.include', 'system', elem.systemElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(this, 'ValueSet.compose.include', 'version', elem.versionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.conceptList.Count - 1 do
      ComposeValueSetComposeIncludeConcept(this, 'ValueSet.compose.include', 'concept', elem.conceptList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.filterList.Count - 1 do
      ComposeValueSetComposeIncludeFilter(this, 'ValueSet.compose.include', 'filter', elem.filterList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.valueSetList.Count - 1 do
      ComposeCanonical(this, 'ValueSet.compose.include', 'valueSet', elem.valueSetList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseValueSetComposeIncludeConcept(obj : TTurtleComplex) : TFhirValueSetComposeIncludeConcept;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirValueSetComposeIncludeConcept.create;
  try
    ParseValueSetComposeIncludeConceptProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseValueSetComposeIncludeConceptProperties(obj : TTurtleComplex; result : TFhirValueSetComposeIncludeConcept);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.codeElement := ParseCode(obj.complex('http://hl7.org/fhir/ValueSet.compose.include.concept.code'));{q1}
    result.displayElement := ParseString(obj.complex('http://hl7.org/fhir/ValueSet.compose.include.concept.display'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ValueSet.compose.include.concept.designation') do
      result.designationList.Add(parseValueSetComposeIncludeConceptDesignation(item));
end;

procedure TFHIRTurtleComposer.ComposeValueSetComposeIncludeConcept(parent :  TTurtleComplex; parentType, name : String; elem : TFhirValueSetComposeIncludeConcept; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ValueSetComposeIncludeConcept'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCode(this, 'ValueSet.compose.include.concept', 'code', elem.codeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ValueSet.compose.include.concept', 'display', elem.displayElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.designationList.Count - 1 do
      ComposeValueSetComposeIncludeConceptDesignation(this, 'ValueSet.compose.include.concept', 'designation', elem.designationList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseValueSetComposeIncludeConceptDesignation(obj : TTurtleComplex) : TFhirValueSetComposeIncludeConceptDesignation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirValueSetComposeIncludeConceptDesignation.create;
  try
    ParseValueSetComposeIncludeConceptDesignationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseValueSetComposeIncludeConceptDesignationProperties(obj : TTurtleComplex; result : TFhirValueSetComposeIncludeConceptDesignation);
begin
    ParseBackboneElementProperties(obj, result);
    result.languageElement := ParseCode(obj.complex('http://hl7.org/fhir/ValueSet.compose.include.concept.designation.language'));{q1}
    result.use := ParseCoding(obj.complex('http://hl7.org/fhir/ValueSet.compose.include.concept.designation.use'));{q3b}
    result.valueElement := ParseString(obj.complex('http://hl7.org/fhir/ValueSet.compose.include.concept.designation.value'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeValueSetComposeIncludeConceptDesignation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirValueSetComposeIncludeConceptDesignation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ValueSetComposeIncludeConceptDesignation'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(this, 'ValueSet.compose.include.concept.designation', 'language', elem.languageElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(this, 'ValueSet.compose.include.concept.designation', 'use', elem.useElement, false, -1);{x.2f}
  ComposeString(this, 'ValueSet.compose.include.concept.designation', 'value', elem.valueElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseValueSetComposeIncludeFilter(obj : TTurtleComplex) : TFhirValueSetComposeIncludeFilter;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirValueSetComposeIncludeFilter.create;
  try
    ParseValueSetComposeIncludeFilterProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseValueSetComposeIncludeFilterProperties(obj : TTurtleComplex; result : TFhirValueSetComposeIncludeFilter);
begin
    ParseBackboneElementProperties(obj, result);
    result.property_Element := ParseCode(obj.complex('http://hl7.org/fhir/ValueSet.compose.include.filter.property'));{q1}
    result.opElement := ParseEnum(obj.complex('http://hl7.org/fhir/ValueSet.compose.include.filter.op'), CODES_TFhirFilterOperatorEnum, SYSTEMS_TFhirFilterOperatorEnum);
    result.valueElement := ParseString(obj.complex('http://hl7.org/fhir/ValueSet.compose.include.filter.value'));{q1}
end;

procedure TFHIRTurtleComposer.ComposeValueSetComposeIncludeFilter(parent :  TTurtleComplex; parentType, name : String; elem : TFhirValueSetComposeIncludeFilter; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ValueSetComposeIncludeFilter'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCode(this, 'ValueSet.compose.include.filter', 'property', elem.property_Element, false, -1);{x.2ea}
  ComposeEnum(this, 'ValueSet.compose.include.filter', 'op', elem.OpElement, CODES_TFhirFilterOperatorEnum, SYSTEMS_TFhirFilterOperatorEnum, false, -1);{x.d4}
  ComposeString(this, 'ValueSet.compose.include.filter', 'value', elem.valueElement, false, -1);{x.2ea}
end;

function TFHIRTurtleParser.ParseValueSetExpansion(obj : TTurtleComplex) : TFhirValueSetExpansion;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirValueSetExpansion.create;
  try
    ParseValueSetExpansionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseValueSetExpansionProperties(obj : TTurtleComplex; result : TFhirValueSetExpansion);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.identifierElement := ParseUri(obj.complex('http://hl7.org/fhir/ValueSet.expansion.identifier'));{q1}
    result.timestampElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ValueSet.expansion.timestamp'));{q1}
    result.totalElement := ParseInteger(obj.complex('http://hl7.org/fhir/ValueSet.expansion.total'));{q1}
    result.offsetElement := ParseInteger(obj.complex('http://hl7.org/fhir/ValueSet.expansion.offset'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ValueSet.expansion.parameter') do
      result.parameterList.Add(parseValueSetExpansionParameter(item));
    for item in obj.complexes('http://hl7.org/fhir/ValueSet.expansion.contains') do
      result.containsList.Add(parseValueSetExpansionContains(item));
end;

procedure TFHIRTurtleComposer.ComposeValueSetExpansion(parent :  TTurtleComplex; parentType, name : String; elem : TFhirValueSetExpansion; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ValueSetExpansion'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'ValueSet.expansion', 'identifier', elem.identifierElement, false, -1);{x.2ea}
  ComposeDateTime(this, 'ValueSet.expansion', 'timestamp', elem.timestampElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(this, 'ValueSet.expansion', 'total', elem.totalElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(this, 'ValueSet.expansion', 'offset', elem.offsetElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.parameterList.Count - 1 do
      ComposeValueSetExpansionParameter(this, 'ValueSet.expansion', 'parameter', elem.parameterList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.containsList.Count - 1 do
      ComposeValueSetExpansionContains(this, 'ValueSet.expansion', 'contains', elem.containsList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseValueSetExpansionParameter(obj : TTurtleComplex) : TFhirValueSetExpansionParameter;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirValueSetExpansionParameter.create;
  try
    ParseValueSetExpansionParameterProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseValueSetExpansionParameterProperties(obj : TTurtleComplex; result : TFhirValueSetExpansionParameter);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/ValueSet.expansion.parameter.name'));{q1}
    if obj.has('http://hl7.org/fhir/ValueSet.expansion.parameter.valueCode', item) then
      result.value := parseCode(item);
    if obj.has('http://hl7.org/fhir/ValueSet.expansion.parameter.valueString', item) then
      result.value := parseString(item);
    if obj.has('http://hl7.org/fhir/ValueSet.expansion.parameter.valueBoolean', item) then
      result.value := parseBoolean(item);
    if obj.has('http://hl7.org/fhir/ValueSet.expansion.parameter.valueInteger', item) then
      result.value := parseInteger(item);
    if obj.has('http://hl7.org/fhir/ValueSet.expansion.parameter.valueDecimal', item) then
      result.value := parseDecimal(item);
    if obj.has('http://hl7.org/fhir/ValueSet.expansion.parameter.valueUri', item) then
      result.value := parseUri(item);
    if obj.has('http://hl7.org/fhir/ValueSet.expansion.parameter.valueDateTime', item) then
      result.value := parseDateTime(item);
end;

procedure TFHIRTurtleComposer.ComposeValueSetExpansionParameter(parent :  TTurtleComplex; parentType, name : String; elem : TFhirValueSetExpansionParameter; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ValueSetExpansionParameter'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeString(this, 'ValueSet.expansion.parameter', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and (elem.value is TFhirCode) {6} then
    ComposeCode(this, 'ValueSet.expansion.parameter', 'valueCode', TFhirCode(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirString) {6} then
    ComposeString(this, 'ValueSet.expansion.parameter', 'valueString', TFhirString(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirBoolean) {6} then
    ComposeBoolean(this, 'ValueSet.expansion.parameter', 'valueBoolean', TFhirBoolean(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirInteger) {6} then
    ComposeInteger(this, 'ValueSet.expansion.parameter', 'valueInteger', TFhirInteger(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirDecimal) {6} then
    ComposeDecimal(this, 'ValueSet.expansion.parameter', 'valueDecimal', TFhirDecimal(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirUri) {6} then
    ComposeUri(this, 'ValueSet.expansion.parameter', 'valueUri', TFhirUri(elem.value), false, -1){x.d9}
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirDateTime) {6} then
    ComposeDateTime(this, 'ValueSet.expansion.parameter', 'valueDateTime', TFhirDateTime(elem.value), false, -1);{x.d9}
end;

function TFHIRTurtleParser.ParseValueSetExpansionContains(obj : TTurtleComplex) : TFhirValueSetExpansionContains;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirValueSetExpansionContains.create;
  try
    ParseValueSetExpansionContainsProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseValueSetExpansionContainsProperties(obj : TTurtleComplex; result : TFhirValueSetExpansionContains);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.systemElement := ParseUri(obj.complex('http://hl7.org/fhir/ValueSet.expansion.contains.system'));{q1}
    result.abstractElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ValueSet.expansion.contains.abstract'));{q1}
    result.inactiveElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ValueSet.expansion.contains.inactive'));{q1}
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/ValueSet.expansion.contains.version'));{q1}
    result.codeElement := ParseCode(obj.complex('http://hl7.org/fhir/ValueSet.expansion.contains.code'));{q1}
    result.displayElement := ParseString(obj.complex('http://hl7.org/fhir/ValueSet.expansion.contains.display'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ValueSet.expansion.contains.designation') do
      result.designationList.Add(parseValueSetComposeIncludeConceptDesignation(item));
    for item in obj.complexes('http://hl7.org/fhir/ValueSet.expansion.contains.contains') do
      result.containsList.Add(parseValueSetExpansionContains(item));
end;

procedure TFHIRTurtleComposer.ComposeValueSetExpansionContains(parent :  TTurtleComplex; parentType, name : String; elem : TFhirValueSetExpansionContains; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ValueSetExpansionContains'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(this, 'ValueSet.expansion.contains', 'system', elem.systemElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'ValueSet.expansion.contains', 'abstract', elem.abstractElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(this, 'ValueSet.expansion.contains', 'inactive', elem.inactiveElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ValueSet.expansion.contains', 'version', elem.versionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(this, 'ValueSet.expansion.contains', 'code', elem.codeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'ValueSet.expansion.contains', 'display', elem.displayElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.designationList.Count - 1 do
      ComposeValueSetComposeIncludeConceptDesignation(this, 'ValueSet.expansion.contains', 'designation', elem.designationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.containsList.Count - 1 do
      ComposeValueSetExpansionContains(this, 'ValueSet.expansion.contains', 'contains', elem.containsList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseValueSet(obj : TTurtleComplex) : TFhirValueSet;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirValueSet.create;
  try
    ParseValueSetProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseValueSetProperties(obj : TTurtleComplex; result : TFhirValueSet);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    result.urlElement := ParseUri(obj.complex('http://hl7.org/fhir/ValueSet.url'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ValueSet.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.versionElement := ParseString(obj.complex('http://hl7.org/fhir/ValueSet.version'));{q1}
    result.nameElement := ParseString(obj.complex('http://hl7.org/fhir/ValueSet.name'));{q1}
    result.titleElement := ParseString(obj.complex('http://hl7.org/fhir/ValueSet.title'));{q1}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/ValueSet.status'), CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    result.experimentalElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ValueSet.experimental'));{q1}
    result.dateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/ValueSet.date'));{q1}
    result.publisherElement := ParseString(obj.complex('http://hl7.org/fhir/ValueSet.publisher'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ValueSet.contact') do
      result.contactList.Add(parseContactDetail(item));
    result.descriptionElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ValueSet.description'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/ValueSet.useContext') do
      result.useContextList.Add(parseUsageContext(item));
    for item in obj.complexes('http://hl7.org/fhir/ValueSet.jurisdiction') do
      result.jurisdictionList.Add(parseCodeableConcept(item));
    result.immutableElement := ParseBoolean(obj.complex('http://hl7.org/fhir/ValueSet.immutable'));{q1}
    result.purposeElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ValueSet.purpose'));{q1}
    result.copyrightElement := ParseMarkdown(obj.complex('http://hl7.org/fhir/ValueSet.copyright'));{q1}
    result.compose := ParseValueSetCompose(obj.complex('http://hl7.org/fhir/ValueSet.compose'));{q3b}
    result.expansion := ParseValueSetExpansion(obj.complex('http://hl7.org/fhir/ValueSet.expansion'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeValueSet(parent :  TTurtleComplex; parentType, name : String; elem : TFhirValueSet; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:ValueSet'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUri(this, 'ValueSet', 'url', elem.urlElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'ValueSet', 'identifier', elem.identifierList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(this, 'ValueSet', 'version', elem.versionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(this, 'ValueSet', 'name', elem.nameElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeString(this, 'ValueSet', 'title', elem.titleElement, false, -1);{x.2ea}
  ComposeEnum(this, 'ValueSet', 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(this, 'ValueSet', 'experimental', elem.experimentalElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(this, 'ValueSet', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(this, 'ValueSet', 'publisher', elem.publisherElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(this, 'ValueSet', 'contact', elem.contactList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdown(this, 'ValueSet', 'description', elem.descriptionElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(this, 'ValueSet', 'useContext', elem.useContextList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') then
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(this, 'ValueSet', 'jurisdiction', elem.jurisdictionList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('immutable') then
    ComposeBoolean(this, 'ValueSet', 'immutable', elem.immutableElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdown(this, 'ValueSet', 'purpose', elem.purposeElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdown(this, 'ValueSet', 'copyright', elem.copyrightElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('compose') then
    ComposeValueSetCompose(this, 'ValueSet', 'compose', elem.composeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('expansion') then
    ComposeValueSetExpansion(this, 'ValueSet', 'expansion', elem.expansionElement, false, -1);{x.2f}
end;

{$ENDIF FHIR_VALUESET}
{$IFDEF FHIR_VERIFICATIONRESULT}
function TFHIRTurtleParser.ParseVerificationResultPrimarySource(obj : TTurtleComplex) : TFhirVerificationResultPrimarySource;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirVerificationResultPrimarySource.create;
  try
    ParseVerificationResultPrimarySourceProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseVerificationResultPrimarySourceProperties(obj : TTurtleComplex; result : TFhirVerificationResultPrimarySource);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.who := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/VerificationResult.primarySource.who'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/VerificationResult.primarySource.type') do
      result.type_List.Add(parseCodeableConcept(item));
    for item in obj.complexes('http://hl7.org/fhir/VerificationResult.primarySource.communicationMethod') do
      result.communicationMethodList.Add(parseCodeableConcept(item));
    result.validationStatus := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/VerificationResult.primarySource.validationStatus'));{q3b}
    result.validationDateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/VerificationResult.primarySource.validationDate'));{q1}
    result.canPushUpdates := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/VerificationResult.primarySource.canPushUpdates'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/VerificationResult.primarySource.pushTypeAvailable') do
      result.pushTypeAvailableList.Add(parseCodeableConcept(item));
end;

procedure TFHIRTurtleComposer.ComposeVerificationResultPrimarySource(parent :  TTurtleComplex; parentType, name : String; elem : TFhirVerificationResultPrimarySource; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:VerificationResultPrimarySource'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(this, 'VerificationResult.primarySource', 'who', elem.whoElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(this, 'VerificationResult.primarySource', 'type', elem.type_List[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.communicationMethodList.Count - 1 do
      ComposeCodeableConcept(this, 'VerificationResult.primarySource', 'communicationMethod', elem.communicationMethodList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(this, 'VerificationResult.primarySource', 'validationStatus', elem.validationStatusElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(this, 'VerificationResult.primarySource', 'validationDate', elem.validationDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'VerificationResult.primarySource', 'canPushUpdates', elem.canPushUpdatesElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.pushTypeAvailableList.Count - 1 do
      ComposeCodeableConcept(this, 'VerificationResult.primarySource', 'pushTypeAvailable', elem.pushTypeAvailableList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseVerificationResultAttestation(obj : TTurtleComplex) : TFhirVerificationResultAttestation;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirVerificationResultAttestation.create;
  try
    ParseVerificationResultAttestationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseVerificationResultAttestationProperties(obj : TTurtleComplex; result : TFhirVerificationResultAttestation);
begin
    ParseBackboneElementProperties(obj, result);
    result.who := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/VerificationResult.attestation.who'));{q3b}
    result.onBehalfOf := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/VerificationResult.attestation.onBehalfOf'));{q3b}
    result.communicationMethod := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/VerificationResult.attestation.communicationMethod'));{q3b}
    result.dateElement := ParseDate(obj.complex('http://hl7.org/fhir/VerificationResult.attestation.date'));{q1}
    result.sourceIdentityCertificateElement := ParseString(obj.complex('http://hl7.org/fhir/VerificationResult.attestation.sourceIdentityCertificate'));{q1}
    result.proxyIdentityCertificateElement := ParseString(obj.complex('http://hl7.org/fhir/VerificationResult.attestation.proxyIdentityCertificate'));{q1}
    result.proxySignature := ParseSignature(obj.complex('http://hl7.org/fhir/VerificationResult.attestation.proxySignature'));{q3b}
    result.sourceSignature := ParseSignature(obj.complex('http://hl7.org/fhir/VerificationResult.attestation.sourceSignature'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeVerificationResultAttestation(parent :  TTurtleComplex; parentType, name : String; elem : TFhirVerificationResultAttestation; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:VerificationResultAttestation'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(this, 'VerificationResult.attestation', 'who', elem.whoElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(this, 'VerificationResult.attestation', 'onBehalfOf', elem.onBehalfOfElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(this, 'VerificationResult.attestation', 'communicationMethod', elem.communicationMethodElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDate(this, 'VerificationResult.attestation', 'date', elem.dateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'VerificationResult.attestation', 'sourceIdentityCertificate', elem.sourceIdentityCertificateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'VerificationResult.attestation', 'proxyIdentityCertificate', elem.proxyIdentityCertificateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeSignature(this, 'VerificationResult.attestation', 'proxySignature', elem.proxySignatureElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeSignature(this, 'VerificationResult.attestation', 'sourceSignature', elem.sourceSignatureElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseVerificationResultValidator(obj : TTurtleComplex) : TFhirVerificationResultValidator;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirVerificationResultValidator.create;
  try
    ParseVerificationResultValidatorProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseVerificationResultValidatorProperties(obj : TTurtleComplex; result : TFhirVerificationResultValidator);
begin
    ParseBackboneElementProperties(obj, result);
    result.organization := ParseReference{TFhirOrganization}(obj.complex('http://hl7.org/fhir/VerificationResult.validator.organization'));{q3b}
    result.identityCertificateElement := ParseString(obj.complex('http://hl7.org/fhir/VerificationResult.validator.identityCertificate'));{q1}
    result.attestationSignature := ParseSignature(obj.complex('http://hl7.org/fhir/VerificationResult.validator.attestationSignature'));{q3b}
end;

procedure TFHIRTurtleComposer.ComposeVerificationResultValidator(parent :  TTurtleComplex; parentType, name : String; elem : TFhirVerificationResultValidator; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:VerificationResultValidator'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeReference{TFhirOrganization}(this, 'VerificationResult.validator', 'organization', elem.organizationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'VerificationResult.validator', 'identityCertificate', elem.identityCertificateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeSignature(this, 'VerificationResult.validator', 'attestationSignature', elem.attestationSignatureElement, false, -1);{x.2f}
end;

function TFHIRTurtleParser.ParseVerificationResult(obj : TTurtleComplex) : TFhirVerificationResult;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirVerificationResult.create;
  try
    ParseVerificationResultProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseVerificationResultProperties(obj : TTurtleComplex; result : TFhirVerificationResult);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/VerificationResult.target') do
      result.targetList.Add(parseReference{TFhirReference}(item));
    for item in obj.complexes('http://hl7.org/fhir/VerificationResult.targetLocation') do
      result.targetLocationList.Add(parseString(item));
    result.need := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/VerificationResult.need'));{q3b}
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/VerificationResult.status'), CODES_TFhirVerificationresultStatusEnum, SYSTEMS_TFhirVerificationresultStatusEnum);
    result.statusDateElement := ParseDateTime(obj.complex('http://hl7.org/fhir/VerificationResult.statusDate'));{q1}
    result.validationType := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/VerificationResult.validationType'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/VerificationResult.validationProcess') do
      result.validationProcessList.Add(parseCodeableConcept(item));
    result.frequency := ParseTiming(obj.complex('http://hl7.org/fhir/VerificationResult.frequency'));{q3b}
    result.lastPerformedElement := ParseDateTime(obj.complex('http://hl7.org/fhir/VerificationResult.lastPerformed'));{q1}
    result.nextScheduledElement := ParseDate(obj.complex('http://hl7.org/fhir/VerificationResult.nextScheduled'));{q1}
    result.failureAction := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/VerificationResult.failureAction'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/VerificationResult.primarySource') do
      result.primarySourceList.Add(parseVerificationResultPrimarySource(item));
    result.attestation := ParseVerificationResultAttestation(obj.complex('http://hl7.org/fhir/VerificationResult.attestation'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/VerificationResult.validator') do
      result.validatorList.Add(parseVerificationResultValidator(item));
end;

procedure TFHIRTurtleComposer.ComposeVerificationResult(parent :  TTurtleComplex; parentType, name : String; elem : TFhirVerificationResult; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:VerificationResult'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('target') then
    for i := 0 to elem.targetList.Count - 1 do
      ComposeReference{TFhirReference}(this, 'VerificationResult', 'target', elem.targetList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('targetLocation') then
    for i := 0 to elem.targetLocationList.Count - 1 do
      ComposeString(this, 'VerificationResult', 'targetLocation', elem.targetLocationList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('need') then
    ComposeCodeableConcept(this, 'VerificationResult', 'need', elem.needElement, false, -1);{x.2f}
  ComposeEnum(this, 'VerificationResult', 'status', elem.StatusElement, CODES_TFhirVerificationresultStatusEnum, SYSTEMS_TFhirVerificationresultStatusEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('statusDate') then
    ComposeDateTime(this, 'VerificationResult', 'statusDate', elem.statusDateElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('validationType') then
    ComposeCodeableConcept(this, 'VerificationResult', 'validationType', elem.validationTypeElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('validationProcess') then
    for i := 0 to elem.validationProcessList.Count - 1 do
      ComposeCodeableConcept(this, 'VerificationResult', 'validationProcess', elem.validationProcessList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('frequency') then
    ComposeTiming(this, 'VerificationResult', 'frequency', elem.frequencyElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('lastPerformed') then
    ComposeDateTime(this, 'VerificationResult', 'lastPerformed', elem.lastPerformedElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) and doCompose('nextScheduled') then
    ComposeDate(this, 'VerificationResult', 'nextScheduled', elem.nextScheduledElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('failureAction') then
    ComposeCodeableConcept(this, 'VerificationResult', 'failureAction', elem.failureActionElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('primarySource') then
    for i := 0 to elem.primarySourceList.Count - 1 do
      ComposeVerificationResultPrimarySource(this, 'VerificationResult', 'primarySource', elem.primarySourceList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) and doCompose('attestation') then
    ComposeVerificationResultAttestation(this, 'VerificationResult', 'attestation', elem.attestationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('validator') then
    for i := 0 to elem.validatorList.Count - 1 do
      ComposeVerificationResultValidator(this, 'VerificationResult', 'validator', elem.validatorList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_VERIFICATIONRESULT}
{$IFDEF FHIR_VISIONPRESCRIPTION}
function TFHIRTurtleParser.ParseVisionPrescriptionLensSpecification(obj : TTurtleComplex) : TFhirVisionPrescriptionLensSpecification;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirVisionPrescriptionLensSpecification.create;
  try
    ParseVisionPrescriptionLensSpecificationProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseVisionPrescriptionLensSpecificationProperties(obj : TTurtleComplex; result : TFhirVisionPrescriptionLensSpecification);
var
  item : TTurtleComplex;
begin
    ParseBackboneElementProperties(obj, result);
    result.product := ParseCodeableConcept(obj.complex('http://hl7.org/fhir/VisionPrescription.lensSpecification.product'));{q3b}
    result.eyeElement := ParseEnum(obj.complex('http://hl7.org/fhir/VisionPrescription.lensSpecification.eye'), CODES_TFhirVisionEyeCodesEnum, SYSTEMS_TFhirVisionEyeCodesEnum);
    result.sphereElement := ParseDecimal(obj.complex('http://hl7.org/fhir/VisionPrescription.lensSpecification.sphere'));{q1}
    result.cylinderElement := ParseDecimal(obj.complex('http://hl7.org/fhir/VisionPrescription.lensSpecification.cylinder'));{q1}
    result.axisElement := ParseInteger(obj.complex('http://hl7.org/fhir/VisionPrescription.lensSpecification.axis'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/VisionPrescription.lensSpecification.prism') do
      result.prismList.Add(parseVisionPrescriptionLensSpecificationPrism(item));
    result.addElement := ParseDecimal(obj.complex('http://hl7.org/fhir/VisionPrescription.lensSpecification.add'));{q1}
    result.powerElement := ParseDecimal(obj.complex('http://hl7.org/fhir/VisionPrescription.lensSpecification.power'));{q1}
    result.backCurveElement := ParseDecimal(obj.complex('http://hl7.org/fhir/VisionPrescription.lensSpecification.backCurve'));{q1}
    result.diameterElement := ParseDecimal(obj.complex('http://hl7.org/fhir/VisionPrescription.lensSpecification.diameter'));{q1}
    result.duration := ParseQuantity(obj.complex('http://hl7.org/fhir/VisionPrescription.lensSpecification.duration'));{q3b}
    result.colorElement := ParseString(obj.complex('http://hl7.org/fhir/VisionPrescription.lensSpecification.color'));{q1}
    result.brandElement := ParseString(obj.complex('http://hl7.org/fhir/VisionPrescription.lensSpecification.brand'));{q1}
    for item in obj.complexes('http://hl7.org/fhir/VisionPrescription.lensSpecification.note') do
      result.noteList.Add(parseAnnotation(item));
end;

procedure TFHIRTurtleComposer.ComposeVisionPrescriptionLensSpecification(parent :  TTurtleComplex; parentType, name : String; elem : TFhirVisionPrescriptionLensSpecification; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:VisionPrescriptionLensSpecification'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeCodeableConcept(this, 'VisionPrescription.lensSpecification', 'product', elem.productElement, false, -1);{x.2f}
  ComposeEnum(this, 'VisionPrescription.lensSpecification', 'eye', elem.EyeElement, CODES_TFhirVisionEyeCodesEnum, SYSTEMS_TFhirVisionEyeCodesEnum, false, -1);{x.d4}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'VisionPrescription.lensSpecification', 'sphere', elem.sphereElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'VisionPrescription.lensSpecification', 'cylinder', elem.cylinderElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(this, 'VisionPrescription.lensSpecification', 'axis', elem.axisElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.prismList.Count - 1 do
      ComposeVisionPrescriptionLensSpecificationPrism(this, 'VisionPrescription.lensSpecification', 'prism', elem.prismList[i], false, i);{x.d3}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'VisionPrescription.lensSpecification', 'add', elem.addElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'VisionPrescription.lensSpecification', 'power', elem.powerElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'VisionPrescription.lensSpecification', 'backCurve', elem.backCurveElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(this, 'VisionPrescription.lensSpecification', 'diameter', elem.diameterElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(this, 'VisionPrescription.lensSpecification', 'duration', elem.durationElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'VisionPrescription.lensSpecification', 'color', elem.colorElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(this, 'VisionPrescription.lensSpecification', 'brand', elem.brandElement, false, -1);{x.2ea}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(this, 'VisionPrescription.lensSpecification', 'note', elem.noteList[i], false, i);{x.d3}
end;

function TFHIRTurtleParser.ParseVisionPrescriptionLensSpecificationPrism(obj : TTurtleComplex) : TFhirVisionPrescriptionLensSpecificationPrism;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirVisionPrescriptionLensSpecificationPrism.create;
  try
    ParseVisionPrescriptionLensSpecificationPrismProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseVisionPrescriptionLensSpecificationPrismProperties(obj : TTurtleComplex; result : TFhirVisionPrescriptionLensSpecificationPrism);
begin
    ParseBackboneElementProperties(obj, result);
    result.amountElement := ParseDecimal(obj.complex('http://hl7.org/fhir/VisionPrescription.lensSpecification.prism.amount'));{q1}
    result.baseElement := ParseEnum(obj.complex('http://hl7.org/fhir/VisionPrescription.lensSpecification.prism.base'), CODES_TFhirVisionBaseCodesEnum, SYSTEMS_TFhirVisionBaseCodesEnum);
end;

procedure TFHIRTurtleComposer.ComposeVisionPrescriptionLensSpecificationPrism(parent :  TTurtleComplex; parentType, name : String; elem : TFhirVisionPrescriptionLensSpecificationPrism; useType : boolean; index : integer);
var
  this : TTurtleComplex;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:VisionPrescriptionLensSpecificationPrism'); {z}
  end;
  composeBackboneElement(this, '', name, elem, false, index);
  ComposeDecimal(this, 'VisionPrescription.lensSpecification.prism', 'amount', elem.amountElement, false, -1);{x.2ea}
  ComposeEnum(this, 'VisionPrescription.lensSpecification.prism', 'base', elem.BaseElement, CODES_TFhirVisionBaseCodesEnum, SYSTEMS_TFhirVisionBaseCodesEnum, false, -1);{x.d4}
end;

function TFHIRTurtleParser.ParseVisionPrescription(obj : TTurtleComplex) : TFhirVisionPrescription;
begin
  if (obj = nil) then
    exit(nil);
  result := TFhirVisionPrescription.create;
  try
    ParseVisionPrescriptionProperties(obj, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRTurtleParser.ParseVisionPrescriptionProperties(obj : TTurtleComplex; result : TFhirVisionPrescription);
var
  item : TTurtleComplex;
begin
    ParseDomainResourceProperties(obj, result);
    for item in obj.complexes('http://hl7.org/fhir/VisionPrescription.identifier') do
      result.identifierList.Add(parseIdentifier(item));
    result.statusElement := ParseEnum(obj.complex('http://hl7.org/fhir/VisionPrescription.status'), CODES_TFhirFmStatusEnum, SYSTEMS_TFhirFmStatusEnum);
    result.createdElement := ParseDateTime(obj.complex('http://hl7.org/fhir/VisionPrescription.created'));{q1}
    result.patient := ParseReference{TFhirPatient}(obj.complex('http://hl7.org/fhir/VisionPrescription.patient'));{q3b}
    result.encounter := ParseReference{TFhirEncounter}(obj.complex('http://hl7.org/fhir/VisionPrescription.encounter'));{q3b}
    result.dateWrittenElement := ParseDateTime(obj.complex('http://hl7.org/fhir/VisionPrescription.dateWritten'));{q1}
    result.prescriber := ParseReference{TFhirPractitioner}(obj.complex('http://hl7.org/fhir/VisionPrescription.prescriber'));{q3b}
    for item in obj.complexes('http://hl7.org/fhir/VisionPrescription.lensSpecification') do
      result.lensSpecificationList.Add(parseVisionPrescriptionLensSpecification(item));
end;

procedure TFHIRTurtleComposer.ComposeVisionPrescription(parent :  TTurtleComplex; parentType, name : String; elem : TFhirVisionPrescription; useType : boolean; index : integer);
var
  this : TTurtleComplex;
  i : integer;
begin
  if (elem = nil) then
    exit;
  if (parentType = '') then
    this := parent
  else
  begin
    this := parent.addPredicate('fhir:'+parentType+'.'+name);
    if (useType) then
      this.addPredicate('a', 'fhir:VisionPrescription'); {z}
  end;
  composeDomainResource(this, '', name, elem, false, index);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(this, 'VisionPrescription', 'identifier', elem.identifierList[i], false, i);{x.d3}
  ComposeEnum(this, 'VisionPrescription', 'status', elem.StatusElement, CODES_TFhirFmStatusEnum, SYSTEMS_TFhirFmStatusEnum, false, -1);{x.d4}
  ComposeDateTime(this, 'VisionPrescription', 'created', elem.createdElement, false, -1);{x.2ea}
  ComposeReference{TFhirPatient}(this, 'VisionPrescription', 'patient', elem.patientElement, false, -1);{x.2f}
  if (SummaryOption in [soFull, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(this, 'VisionPrescription', 'encounter', elem.encounterElement, false, -1);{x.2f}
  ComposeDateTime(this, 'VisionPrescription', 'dateWritten', elem.dateWrittenElement, false, -1);{x.2ea}
  ComposeReference{TFhirPractitioner}(this, 'VisionPrescription', 'prescriber', elem.prescriberElement, false, -1);{x.2f}
  for i := 0 to elem.lensSpecificationList.Count - 1 do
      ComposeVisionPrescriptionLensSpecification(this, 'VisionPrescription', 'lensSpecification', elem.lensSpecificationList[i], false, i);{x.d3}
end;

{$ENDIF FHIR_VISIONPRESCRIPTION}
function TFHIRTurtleParser.ParseFragment(obj : TTurtleComplex; type_ : String) : TFHIRObject;
begin
   if SameText(type_, 'Element') then
    result := parseElement(obj)
  else if SameText(type_, 'BackboneElement') then
    result := parseBackboneElement(obj)
  else if SameText(type_, 'BackboneType') then
    result := parseBackboneType(obj)
{$IFDEF FHIR_PARAMETERS}
  else if SameText(type_, 'Parameters') then
    result := parseParameters(obj)
{$ENDIF FHIR_PARAMETERS}
  else if SameText(type_, 'Extension') then
    result := parseExtension(obj)
  else if SameText(type_, 'Narrative') then
    result := parseNarrative(obj)
  else if SameText(type_, 'Contributor') then
    result := parseContributor(obj)
  else if SameText(type_, 'Attachment') then
    result := parseAttachment(obj)
  else if SameText(type_, 'DataRequirement') then
    result := parseDataRequirement(obj)
  else if SameText(type_, 'Dosage') then
    result := parseDosage(obj)
  else if SameText(type_, 'Money') then
    result := parseMoney(obj)
  else if SameText(type_, 'MarketingStatus') then
    result := parseMarketingStatus(obj)
  else if SameText(type_, 'Identifier') then
    result := parseIdentifier(obj)
  else if SameText(type_, 'SubstanceAmount') then
    result := parseSubstanceAmount(obj)
  else if SameText(type_, 'Coding') then
    result := parseCoding(obj)
  else if SameText(type_, 'SampledData') then
    result := parseSampledData(obj)
  else if SameText(type_, 'Population') then
    result := parsePopulation(obj)
  else if SameText(type_, 'Ratio') then
    result := parseRatio(obj)
  else if SameText(type_, 'Reference') then
    result := parseReference(obj)
  else if SameText(type_, 'TriggerDefinition') then
    result := parseTriggerDefinition(obj)
  else if SameText(type_, 'Period') then
    result := parsePeriod(obj)
  else if SameText(type_, 'Quantity') then
    result := parseQuantity(obj)
  else if SameText(type_, 'Range') then
    result := parseRange(obj)
  else if SameText(type_, 'RelatedArtifact') then
    result := parseRelatedArtifact(obj)
  else if SameText(type_, 'Annotation') then
    result := parseAnnotation(obj)
  else if SameText(type_, 'ProductShelfLife') then
    result := parseProductShelfLife(obj)
  else if SameText(type_, 'ContactDetail') then
    result := parseContactDetail(obj)
  else if SameText(type_, 'Expression') then
    result := parseExpression(obj)
  else if SameText(type_, 'UsageContext') then
    result := parseUsageContext(obj)
  else if SameText(type_, 'Signature') then
    result := parseSignature(obj)
  else if SameText(type_, 'ProdCharacteristic') then
    result := parseProdCharacteristic(obj)
  else if SameText(type_, 'CodeableConcept') then
    result := parseCodeableConcept(obj)
  else if SameText(type_, 'ParameterDefinition') then
    result := parseParameterDefinition(obj)
  else if SameText(type_, 'ContactPoint') then
    result := parseContactPoint(obj)
  else if SameText(type_, 'HumanName') then
    result := parseHumanName(obj)
  else if SameText(type_, 'Meta') then
    result := parseMeta(obj)
  else if SameText(type_, 'Address') then
    result := parseAddress(obj)
  else if SameText(type_, 'ElementDefinition') then
    result := parseElementDefinition(obj)
  else if SameText(type_, 'Timing') then
    result := parseTiming(obj)
  else if SameText(type_, 'Count') then
    result := parseCount(obj)
  else if SameText(type_, 'Age') then
    result := parseAge(obj)
  else if SameText(type_, 'Distance') then
    result := parseDistance(obj)
  else if SameText(type_, 'Duration') then
    result := parseDuration(obj)
{$IFDEF FHIR_ACCOUNT}
  else if SameText(type_, 'Account') then
    result := parseAccount(obj)
{$ENDIF FHIR_ACCOUNT}
{$IFDEF FHIR_ACTIVITYDEFINITION}
  else if SameText(type_, 'ActivityDefinition') then
    result := parseActivityDefinition(obj)
{$ENDIF FHIR_ACTIVITYDEFINITION}
{$IFDEF FHIR_ADVERSEEVENT}
  else if SameText(type_, 'AdverseEvent') then
    result := parseAdverseEvent(obj)
{$ENDIF FHIR_ADVERSEEVENT}
{$IFDEF FHIR_ALLERGYINTOLERANCE}
  else if SameText(type_, 'AllergyIntolerance') then
    result := parseAllergyIntolerance(obj)
{$ENDIF FHIR_ALLERGYINTOLERANCE}
{$IFDEF FHIR_APPOINTMENT}
  else if SameText(type_, 'Appointment') then
    result := parseAppointment(obj)
{$ENDIF FHIR_APPOINTMENT}
{$IFDEF FHIR_APPOINTMENTRESPONSE}
  else if SameText(type_, 'AppointmentResponse') then
    result := parseAppointmentResponse(obj)
{$ENDIF FHIR_APPOINTMENTRESPONSE}
{$IFDEF FHIR_AUDITEVENT}
  else if SameText(type_, 'AuditEvent') then
    result := parseAuditEvent(obj)
{$ENDIF FHIR_AUDITEVENT}
{$IFDEF FHIR_BASIC}
  else if SameText(type_, 'Basic') then
    result := parseBasic(obj)
{$ENDIF FHIR_BASIC}
{$IFDEF FHIR_BINARY}
  else if SameText(type_, 'Binary') then
    result := parseBinary(obj)
{$ENDIF FHIR_BINARY}
{$IFDEF FHIR_BIOLOGICALLYDERIVEDPRODUCT}
  else if SameText(type_, 'BiologicallyDerivedProduct') then
    result := parseBiologicallyDerivedProduct(obj)
{$ENDIF FHIR_BIOLOGICALLYDERIVEDPRODUCT}
{$IFDEF FHIR_BODYSTRUCTURE}
  else if SameText(type_, 'BodyStructure') then
    result := parseBodyStructure(obj)
{$ENDIF FHIR_BODYSTRUCTURE}
{$IFDEF FHIR_BUNDLE}
  else if SameText(type_, 'Bundle') then
    result := parseBundle(obj)
{$ENDIF FHIR_BUNDLE}
{$IFDEF FHIR_CAPABILITYSTATEMENT}
  else if SameText(type_, 'CapabilityStatement') then
    result := parseCapabilityStatement(obj)
{$ENDIF FHIR_CAPABILITYSTATEMENT}
{$IFDEF FHIR_CAREPLAN}
  else if SameText(type_, 'CarePlan') then
    result := parseCarePlan(obj)
{$ENDIF FHIR_CAREPLAN}
{$IFDEF FHIR_CARETEAM}
  else if SameText(type_, 'CareTeam') then
    result := parseCareTeam(obj)
{$ENDIF FHIR_CARETEAM}
{$IFDEF FHIR_CATALOGENTRY}
  else if SameText(type_, 'CatalogEntry') then
    result := parseCatalogEntry(obj)
{$ENDIF FHIR_CATALOGENTRY}
{$IFDEF FHIR_CHARGEITEM}
  else if SameText(type_, 'ChargeItem') then
    result := parseChargeItem(obj)
{$ENDIF FHIR_CHARGEITEM}
{$IFDEF FHIR_CHARGEITEMDEFINITION}
  else if SameText(type_, 'ChargeItemDefinition') then
    result := parseChargeItemDefinition(obj)
{$ENDIF FHIR_CHARGEITEMDEFINITION}
{$IFDEF FHIR_CLAIM}
  else if SameText(type_, 'Claim') then
    result := parseClaim(obj)
{$ENDIF FHIR_CLAIM}
{$IFDEF FHIR_CLAIMRESPONSE}
  else if SameText(type_, 'ClaimResponse') then
    result := parseClaimResponse(obj)
{$ENDIF FHIR_CLAIMRESPONSE}
{$IFDEF FHIR_CLINICALIMPRESSION}
  else if SameText(type_, 'ClinicalImpression') then
    result := parseClinicalImpression(obj)
{$ENDIF FHIR_CLINICALIMPRESSION}
{$IFDEF FHIR_CODESYSTEM}
  else if SameText(type_, 'CodeSystem') then
    result := parseCodeSystem(obj)
{$ENDIF FHIR_CODESYSTEM}
{$IFDEF FHIR_COMMUNICATION}
  else if SameText(type_, 'Communication') then
    result := parseCommunication(obj)
{$ENDIF FHIR_COMMUNICATION}
{$IFDEF FHIR_COMMUNICATIONREQUEST}
  else if SameText(type_, 'CommunicationRequest') then
    result := parseCommunicationRequest(obj)
{$ENDIF FHIR_COMMUNICATIONREQUEST}
{$IFDEF FHIR_COMPARTMENTDEFINITION}
  else if SameText(type_, 'CompartmentDefinition') then
    result := parseCompartmentDefinition(obj)
{$ENDIF FHIR_COMPARTMENTDEFINITION}
{$IFDEF FHIR_COMPOSITION}
  else if SameText(type_, 'Composition') then
    result := parseComposition(obj)
{$ENDIF FHIR_COMPOSITION}
{$IFDEF FHIR_CONCEPTMAP}
  else if SameText(type_, 'ConceptMap') then
    result := parseConceptMap(obj)
{$ENDIF FHIR_CONCEPTMAP}
{$IFDEF FHIR_CONDITION}
  else if SameText(type_, 'Condition') then
    result := parseCondition(obj)
{$ENDIF FHIR_CONDITION}
{$IFDEF FHIR_CONSENT}
  else if SameText(type_, 'Consent') then
    result := parseConsent(obj)
{$ENDIF FHIR_CONSENT}
{$IFDEF FHIR_CONTRACT}
  else if SameText(type_, 'Contract') then
    result := parseContract(obj)
{$ENDIF FHIR_CONTRACT}
{$IFDEF FHIR_COVERAGE}
  else if SameText(type_, 'Coverage') then
    result := parseCoverage(obj)
{$ENDIF FHIR_COVERAGE}
{$IFDEF FHIR_COVERAGEELIGIBILITYREQUEST}
  else if SameText(type_, 'CoverageEligibilityRequest') then
    result := parseCoverageEligibilityRequest(obj)
{$ENDIF FHIR_COVERAGEELIGIBILITYREQUEST}
{$IFDEF FHIR_COVERAGEELIGIBILITYRESPONSE}
  else if SameText(type_, 'CoverageEligibilityResponse') then
    result := parseCoverageEligibilityResponse(obj)
{$ENDIF FHIR_COVERAGEELIGIBILITYRESPONSE}
{$IFDEF FHIR_DETECTEDISSUE}
  else if SameText(type_, 'DetectedIssue') then
    result := parseDetectedIssue(obj)
{$ENDIF FHIR_DETECTEDISSUE}
{$IFDEF FHIR_DEVICE}
  else if SameText(type_, 'Device') then
    result := parseDevice(obj)
{$ENDIF FHIR_DEVICE}
{$IFDEF FHIR_DEVICEDEFINITION}
  else if SameText(type_, 'DeviceDefinition') then
    result := parseDeviceDefinition(obj)
{$ENDIF FHIR_DEVICEDEFINITION}
{$IFDEF FHIR_DEVICEMETRIC}
  else if SameText(type_, 'DeviceMetric') then
    result := parseDeviceMetric(obj)
{$ENDIF FHIR_DEVICEMETRIC}
{$IFDEF FHIR_DEVICEREQUEST}
  else if SameText(type_, 'DeviceRequest') then
    result := parseDeviceRequest(obj)
{$ENDIF FHIR_DEVICEREQUEST}
{$IFDEF FHIR_DEVICEUSESTATEMENT}
  else if SameText(type_, 'DeviceUseStatement') then
    result := parseDeviceUseStatement(obj)
{$ENDIF FHIR_DEVICEUSESTATEMENT}
{$IFDEF FHIR_DIAGNOSTICREPORT}
  else if SameText(type_, 'DiagnosticReport') then
    result := parseDiagnosticReport(obj)
{$ENDIF FHIR_DIAGNOSTICREPORT}
{$IFDEF FHIR_DOCUMENTMANIFEST}
  else if SameText(type_, 'DocumentManifest') then
    result := parseDocumentManifest(obj)
{$ENDIF FHIR_DOCUMENTMANIFEST}
{$IFDEF FHIR_DOCUMENTREFERENCE}
  else if SameText(type_, 'DocumentReference') then
    result := parseDocumentReference(obj)
{$ENDIF FHIR_DOCUMENTREFERENCE}
{$IFDEF FHIR_EFFECTEVIDENCESYNTHESIS}
  else if SameText(type_, 'EffectEvidenceSynthesis') then
    result := parseEffectEvidenceSynthesis(obj)
{$ENDIF FHIR_EFFECTEVIDENCESYNTHESIS}
{$IFDEF FHIR_ENCOUNTER}
  else if SameText(type_, 'Encounter') then
    result := parseEncounter(obj)
{$ENDIF FHIR_ENCOUNTER}
{$IFDEF FHIR_ENDPOINT}
  else if SameText(type_, 'Endpoint') then
    result := parseEndpoint(obj)
{$ENDIF FHIR_ENDPOINT}
{$IFDEF FHIR_ENROLLMENTREQUEST}
  else if SameText(type_, 'EnrollmentRequest') then
    result := parseEnrollmentRequest(obj)
{$ENDIF FHIR_ENROLLMENTREQUEST}
{$IFDEF FHIR_ENROLLMENTRESPONSE}
  else if SameText(type_, 'EnrollmentResponse') then
    result := parseEnrollmentResponse(obj)
{$ENDIF FHIR_ENROLLMENTRESPONSE}
{$IFDEF FHIR_EPISODEOFCARE}
  else if SameText(type_, 'EpisodeOfCare') then
    result := parseEpisodeOfCare(obj)
{$ENDIF FHIR_EPISODEOFCARE}
{$IFDEF FHIR_EVENTDEFINITION}
  else if SameText(type_, 'EventDefinition') then
    result := parseEventDefinition(obj)
{$ENDIF FHIR_EVENTDEFINITION}
{$IFDEF FHIR_EVIDENCE}
  else if SameText(type_, 'Evidence') then
    result := parseEvidence(obj)
{$ENDIF FHIR_EVIDENCE}
{$IFDEF FHIR_EVIDENCEVARIABLE}
  else if SameText(type_, 'EvidenceVariable') then
    result := parseEvidenceVariable(obj)
{$ENDIF FHIR_EVIDENCEVARIABLE}
{$IFDEF FHIR_EXAMPLESCENARIO}
  else if SameText(type_, 'ExampleScenario') then
    result := parseExampleScenario(obj)
{$ENDIF FHIR_EXAMPLESCENARIO}
{$IFDEF FHIR_EXPLANATIONOFBENEFIT}
  else if SameText(type_, 'ExplanationOfBenefit') then
    result := parseExplanationOfBenefit(obj)
{$ENDIF FHIR_EXPLANATIONOFBENEFIT}
{$IFDEF FHIR_FAMILYMEMBERHISTORY}
  else if SameText(type_, 'FamilyMemberHistory') then
    result := parseFamilyMemberHistory(obj)
{$ENDIF FHIR_FAMILYMEMBERHISTORY}
{$IFDEF FHIR_FLAG}
  else if SameText(type_, 'Flag') then
    result := parseFlag(obj)
{$ENDIF FHIR_FLAG}
{$IFDEF FHIR_GOAL}
  else if SameText(type_, 'Goal') then
    result := parseGoal(obj)
{$ENDIF FHIR_GOAL}
{$IFDEF FHIR_GRAPHDEFINITION}
  else if SameText(type_, 'GraphDefinition') then
    result := parseGraphDefinition(obj)
{$ENDIF FHIR_GRAPHDEFINITION}
{$IFDEF FHIR_GROUP}
  else if SameText(type_, 'Group') then
    result := parseGroup(obj)
{$ENDIF FHIR_GROUP}
{$IFDEF FHIR_GUIDANCERESPONSE}
  else if SameText(type_, 'GuidanceResponse') then
    result := parseGuidanceResponse(obj)
{$ENDIF FHIR_GUIDANCERESPONSE}
{$IFDEF FHIR_HEALTHCARESERVICE}
  else if SameText(type_, 'HealthcareService') then
    result := parseHealthcareService(obj)
{$ENDIF FHIR_HEALTHCARESERVICE}
{$IFDEF FHIR_IMAGINGSTUDY}
  else if SameText(type_, 'ImagingStudy') then
    result := parseImagingStudy(obj)
{$ENDIF FHIR_IMAGINGSTUDY}
{$IFDEF FHIR_IMMUNIZATION}
  else if SameText(type_, 'Immunization') then
    result := parseImmunization(obj)
{$ENDIF FHIR_IMMUNIZATION}
{$IFDEF FHIR_IMMUNIZATIONEVALUATION}
  else if SameText(type_, 'ImmunizationEvaluation') then
    result := parseImmunizationEvaluation(obj)
{$ENDIF FHIR_IMMUNIZATIONEVALUATION}
{$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
  else if SameText(type_, 'ImmunizationRecommendation') then
    result := parseImmunizationRecommendation(obj)
{$ENDIF FHIR_IMMUNIZATIONRECOMMENDATION}
{$IFDEF FHIR_IMPLEMENTATIONGUIDE}
  else if SameText(type_, 'ImplementationGuide') then
    result := parseImplementationGuide(obj)
{$ENDIF FHIR_IMPLEMENTATIONGUIDE}
{$IFDEF FHIR_INSURANCEPLAN}
  else if SameText(type_, 'InsurancePlan') then
    result := parseInsurancePlan(obj)
{$ENDIF FHIR_INSURANCEPLAN}
{$IFDEF FHIR_INVOICE}
  else if SameText(type_, 'Invoice') then
    result := parseInvoice(obj)
{$ENDIF FHIR_INVOICE}
{$IFDEF FHIR_LIBRARY}
  else if SameText(type_, 'Library') then
    result := parseLibrary(obj)
{$ENDIF FHIR_LIBRARY}
{$IFDEF FHIR_LINKAGE}
  else if SameText(type_, 'Linkage') then
    result := parseLinkage(obj)
{$ENDIF FHIR_LINKAGE}
{$IFDEF FHIR_LIST}
  else if SameText(type_, 'List') then
    result := parseList(obj)
{$ENDIF FHIR_LIST}
{$IFDEF FHIR_LOCATION}
  else if SameText(type_, 'Location') then
    result := parseLocation(obj)
{$ENDIF FHIR_LOCATION}
{$IFDEF FHIR_MEASURE}
  else if SameText(type_, 'Measure') then
    result := parseMeasure(obj)
{$ENDIF FHIR_MEASURE}
{$IFDEF FHIR_MEASUREREPORT}
  else if SameText(type_, 'MeasureReport') then
    result := parseMeasureReport(obj)
{$ENDIF FHIR_MEASUREREPORT}
{$IFDEF FHIR_MEDIA}
  else if SameText(type_, 'Media') then
    result := parseMedia(obj)
{$ENDIF FHIR_MEDIA}
{$IFDEF FHIR_MEDICATION}
  else if SameText(type_, 'Medication') then
    result := parseMedication(obj)
{$ENDIF FHIR_MEDICATION}
{$IFDEF FHIR_MEDICATIONADMINISTRATION}
  else if SameText(type_, 'MedicationAdministration') then
    result := parseMedicationAdministration(obj)
{$ENDIF FHIR_MEDICATIONADMINISTRATION}
{$IFDEF FHIR_MEDICATIONDISPENSE}
  else if SameText(type_, 'MedicationDispense') then
    result := parseMedicationDispense(obj)
{$ENDIF FHIR_MEDICATIONDISPENSE}
{$IFDEF FHIR_MEDICATIONKNOWLEDGE}
  else if SameText(type_, 'MedicationKnowledge') then
    result := parseMedicationKnowledge(obj)
{$ENDIF FHIR_MEDICATIONKNOWLEDGE}
{$IFDEF FHIR_MEDICATIONREQUEST}
  else if SameText(type_, 'MedicationRequest') then
    result := parseMedicationRequest(obj)
{$ENDIF FHIR_MEDICATIONREQUEST}
{$IFDEF FHIR_MEDICATIONSTATEMENT}
  else if SameText(type_, 'MedicationStatement') then
    result := parseMedicationStatement(obj)
{$ENDIF FHIR_MEDICATIONSTATEMENT}
{$IFDEF FHIR_MEDICINALPRODUCT}
  else if SameText(type_, 'MedicinalProduct') then
    result := parseMedicinalProduct(obj)
{$ENDIF FHIR_MEDICINALPRODUCT}
{$IFDEF FHIR_MEDICINALPRODUCTAUTHORIZATION}
  else if SameText(type_, 'MedicinalProductAuthorization') then
    result := parseMedicinalProductAuthorization(obj)
{$ENDIF FHIR_MEDICINALPRODUCTAUTHORIZATION}
{$IFDEF FHIR_MEDICINALPRODUCTCONTRAINDICATION}
  else if SameText(type_, 'MedicinalProductContraindication') then
    result := parseMedicinalProductContraindication(obj)
{$ENDIF FHIR_MEDICINALPRODUCTCONTRAINDICATION}
{$IFDEF FHIR_MEDICINALPRODUCTINDICATION}
  else if SameText(type_, 'MedicinalProductIndication') then
    result := parseMedicinalProductIndication(obj)
{$ENDIF FHIR_MEDICINALPRODUCTINDICATION}
{$IFDEF FHIR_MEDICINALPRODUCTINGREDIENT}
  else if SameText(type_, 'MedicinalProductIngredient') then
    result := parseMedicinalProductIngredient(obj)
{$ENDIF FHIR_MEDICINALPRODUCTINGREDIENT}
{$IFDEF FHIR_MEDICINALPRODUCTINTERACTION}
  else if SameText(type_, 'MedicinalProductInteraction') then
    result := parseMedicinalProductInteraction(obj)
{$ENDIF FHIR_MEDICINALPRODUCTINTERACTION}
{$IFDEF FHIR_MEDICINALPRODUCTMANUFACTURED}
  else if SameText(type_, 'MedicinalProductManufactured') then
    result := parseMedicinalProductManufactured(obj)
{$ENDIF FHIR_MEDICINALPRODUCTMANUFACTURED}
{$IFDEF FHIR_MEDICINALPRODUCTPACKAGED}
  else if SameText(type_, 'MedicinalProductPackaged') then
    result := parseMedicinalProductPackaged(obj)
{$ENDIF FHIR_MEDICINALPRODUCTPACKAGED}
{$IFDEF FHIR_MEDICINALPRODUCTPHARMACEUTICAL}
  else if SameText(type_, 'MedicinalProductPharmaceutical') then
    result := parseMedicinalProductPharmaceutical(obj)
{$ENDIF FHIR_MEDICINALPRODUCTPHARMACEUTICAL}
{$IFDEF FHIR_MEDICINALPRODUCTUNDESIRABLEEFFECT}
  else if SameText(type_, 'MedicinalProductUndesirableEffect') then
    result := parseMedicinalProductUndesirableEffect(obj)
{$ENDIF FHIR_MEDICINALPRODUCTUNDESIRABLEEFFECT}
{$IFDEF FHIR_MESSAGEDEFINITION}
  else if SameText(type_, 'MessageDefinition') then
    result := parseMessageDefinition(obj)
{$ENDIF FHIR_MESSAGEDEFINITION}
{$IFDEF FHIR_MESSAGEHEADER}
  else if SameText(type_, 'MessageHeader') then
    result := parseMessageHeader(obj)
{$ENDIF FHIR_MESSAGEHEADER}
{$IFDEF FHIR_MOLECULARSEQUENCE}
  else if SameText(type_, 'MolecularSequence') then
    result := parseMolecularSequence(obj)
{$ENDIF FHIR_MOLECULARSEQUENCE}
{$IFDEF FHIR_NAMINGSYSTEM}
  else if SameText(type_, 'NamingSystem') then
    result := parseNamingSystem(obj)
{$ENDIF FHIR_NAMINGSYSTEM}
{$IFDEF FHIR_NUTRITIONORDER}
  else if SameText(type_, 'NutritionOrder') then
    result := parseNutritionOrder(obj)
{$ENDIF FHIR_NUTRITIONORDER}
{$IFDEF FHIR_OBSERVATION}
  else if SameText(type_, 'Observation') then
    result := parseObservation(obj)
{$ENDIF FHIR_OBSERVATION}
{$IFDEF FHIR_OBSERVATIONDEFINITION}
  else if SameText(type_, 'ObservationDefinition') then
    result := parseObservationDefinition(obj)
{$ENDIF FHIR_OBSERVATIONDEFINITION}
{$IFDEF FHIR_OPERATIONDEFINITION}
  else if SameText(type_, 'OperationDefinition') then
    result := parseOperationDefinition(obj)
{$ENDIF FHIR_OPERATIONDEFINITION}
{$IFDEF FHIR_OPERATIONOUTCOME}
  else if SameText(type_, 'OperationOutcome') then
    result := parseOperationOutcome(obj)
{$ENDIF FHIR_OPERATIONOUTCOME}
{$IFDEF FHIR_ORGANIZATION}
  else if SameText(type_, 'Organization') then
    result := parseOrganization(obj)
{$ENDIF FHIR_ORGANIZATION}
{$IFDEF FHIR_ORGANIZATIONAFFILIATION}
  else if SameText(type_, 'OrganizationAffiliation') then
    result := parseOrganizationAffiliation(obj)
{$ENDIF FHIR_ORGANIZATIONAFFILIATION}
{$IFDEF FHIR_PATIENT}
  else if SameText(type_, 'Patient') then
    result := parsePatient(obj)
{$ENDIF FHIR_PATIENT}
{$IFDEF FHIR_PAYMENTNOTICE}
  else if SameText(type_, 'PaymentNotice') then
    result := parsePaymentNotice(obj)
{$ENDIF FHIR_PAYMENTNOTICE}
{$IFDEF FHIR_PAYMENTRECONCILIATION}
  else if SameText(type_, 'PaymentReconciliation') then
    result := parsePaymentReconciliation(obj)
{$ENDIF FHIR_PAYMENTRECONCILIATION}
{$IFDEF FHIR_PERSON}
  else if SameText(type_, 'Person') then
    result := parsePerson(obj)
{$ENDIF FHIR_PERSON}
{$IFDEF FHIR_PLANDEFINITION}
  else if SameText(type_, 'PlanDefinition') then
    result := parsePlanDefinition(obj)
{$ENDIF FHIR_PLANDEFINITION}
{$IFDEF FHIR_PRACTITIONER}
  else if SameText(type_, 'Practitioner') then
    result := parsePractitioner(obj)
{$ENDIF FHIR_PRACTITIONER}
{$IFDEF FHIR_PRACTITIONERROLE}
  else if SameText(type_, 'PractitionerRole') then
    result := parsePractitionerRole(obj)
{$ENDIF FHIR_PRACTITIONERROLE}
{$IFDEF FHIR_PROCEDURE}
  else if SameText(type_, 'Procedure') then
    result := parseProcedure(obj)
{$ENDIF FHIR_PROCEDURE}
{$IFDEF FHIR_PROVENANCE}
  else if SameText(type_, 'Provenance') then
    result := parseProvenance(obj)
{$ENDIF FHIR_PROVENANCE}
{$IFDEF FHIR_QUESTIONNAIRE}
  else if SameText(type_, 'Questionnaire') then
    result := parseQuestionnaire(obj)
{$ENDIF FHIR_QUESTIONNAIRE}
{$IFDEF FHIR_QUESTIONNAIRERESPONSE}
  else if SameText(type_, 'QuestionnaireResponse') then
    result := parseQuestionnaireResponse(obj)
{$ENDIF FHIR_QUESTIONNAIRERESPONSE}
{$IFDEF FHIR_RELATEDPERSON}
  else if SameText(type_, 'RelatedPerson') then
    result := parseRelatedPerson(obj)
{$ENDIF FHIR_RELATEDPERSON}
{$IFDEF FHIR_REQUESTGROUP}
  else if SameText(type_, 'RequestGroup') then
    result := parseRequestGroup(obj)
{$ENDIF FHIR_REQUESTGROUP}
{$IFDEF FHIR_RESEARCHDEFINITION}
  else if SameText(type_, 'ResearchDefinition') then
    result := parseResearchDefinition(obj)
{$ENDIF FHIR_RESEARCHDEFINITION}
{$IFDEF FHIR_RESEARCHELEMENTDEFINITION}
  else if SameText(type_, 'ResearchElementDefinition') then
    result := parseResearchElementDefinition(obj)
{$ENDIF FHIR_RESEARCHELEMENTDEFINITION}
{$IFDEF FHIR_RESEARCHSTUDY}
  else if SameText(type_, 'ResearchStudy') then
    result := parseResearchStudy(obj)
{$ENDIF FHIR_RESEARCHSTUDY}
{$IFDEF FHIR_RESEARCHSUBJECT}
  else if SameText(type_, 'ResearchSubject') then
    result := parseResearchSubject(obj)
{$ENDIF FHIR_RESEARCHSUBJECT}
{$IFDEF FHIR_RISKASSESSMENT}
  else if SameText(type_, 'RiskAssessment') then
    result := parseRiskAssessment(obj)
{$ENDIF FHIR_RISKASSESSMENT}
{$IFDEF FHIR_RISKEVIDENCESYNTHESIS}
  else if SameText(type_, 'RiskEvidenceSynthesis') then
    result := parseRiskEvidenceSynthesis(obj)
{$ENDIF FHIR_RISKEVIDENCESYNTHESIS}
{$IFDEF FHIR_SCHEDULE}
  else if SameText(type_, 'Schedule') then
    result := parseSchedule(obj)
{$ENDIF FHIR_SCHEDULE}
{$IFDEF FHIR_SEARCHPARAMETER}
  else if SameText(type_, 'SearchParameter') then
    result := parseSearchParameter(obj)
{$ENDIF FHIR_SEARCHPARAMETER}
{$IFDEF FHIR_SERVICEREQUEST}
  else if SameText(type_, 'ServiceRequest') then
    result := parseServiceRequest(obj)
{$ENDIF FHIR_SERVICEREQUEST}
{$IFDEF FHIR_SLOT}
  else if SameText(type_, 'Slot') then
    result := parseSlot(obj)
{$ENDIF FHIR_SLOT}
{$IFDEF FHIR_SPECIMEN}
  else if SameText(type_, 'Specimen') then
    result := parseSpecimen(obj)
{$ENDIF FHIR_SPECIMEN}
{$IFDEF FHIR_SPECIMENDEFINITION}
  else if SameText(type_, 'SpecimenDefinition') then
    result := parseSpecimenDefinition(obj)
{$ENDIF FHIR_SPECIMENDEFINITION}
{$IFDEF FHIR_STRUCTUREDEFINITION}
  else if SameText(type_, 'StructureDefinition') then
    result := parseStructureDefinition(obj)
{$ENDIF FHIR_STRUCTUREDEFINITION}
{$IFDEF FHIR_STRUCTUREMAP}
  else if SameText(type_, 'StructureMap') then
    result := parseStructureMap(obj)
{$ENDIF FHIR_STRUCTUREMAP}
{$IFDEF FHIR_SUBSCRIPTION}
  else if SameText(type_, 'Subscription') then
    result := parseSubscription(obj)
{$ENDIF FHIR_SUBSCRIPTION}
{$IFDEF FHIR_SUBSTANCE}
  else if SameText(type_, 'Substance') then
    result := parseSubstance(obj)
{$ENDIF FHIR_SUBSTANCE}
{$IFDEF FHIR_SUBSTANCENUCLEICACID}
  else if SameText(type_, 'SubstanceNucleicAcid') then
    result := parseSubstanceNucleicAcid(obj)
{$ENDIF FHIR_SUBSTANCENUCLEICACID}
{$IFDEF FHIR_SUBSTANCEPOLYMER}
  else if SameText(type_, 'SubstancePolymer') then
    result := parseSubstancePolymer(obj)
{$ENDIF FHIR_SUBSTANCEPOLYMER}
{$IFDEF FHIR_SUBSTANCEPROTEIN}
  else if SameText(type_, 'SubstanceProtein') then
    result := parseSubstanceProtein(obj)
{$ENDIF FHIR_SUBSTANCEPROTEIN}
{$IFDEF FHIR_SUBSTANCEREFERENCEINFORMATION}
  else if SameText(type_, 'SubstanceReferenceInformation') then
    result := parseSubstanceReferenceInformation(obj)
{$ENDIF FHIR_SUBSTANCEREFERENCEINFORMATION}
{$IFDEF FHIR_SUBSTANCESOURCEMATERIAL}
  else if SameText(type_, 'SubstanceSourceMaterial') then
    result := parseSubstanceSourceMaterial(obj)
{$ENDIF FHIR_SUBSTANCESOURCEMATERIAL}
{$IFDEF FHIR_SUBSTANCESPECIFICATION}
  else if SameText(type_, 'SubstanceSpecification') then
    result := parseSubstanceSpecification(obj)
{$ENDIF FHIR_SUBSTANCESPECIFICATION}
{$IFDEF FHIR_SUPPLYDELIVERY}
  else if SameText(type_, 'SupplyDelivery') then
    result := parseSupplyDelivery(obj)
{$ENDIF FHIR_SUPPLYDELIVERY}
{$IFDEF FHIR_SUPPLYREQUEST}
  else if SameText(type_, 'SupplyRequest') then
    result := parseSupplyRequest(obj)
{$ENDIF FHIR_SUPPLYREQUEST}
{$IFDEF FHIR_TASK}
  else if SameText(type_, 'Task') then
    result := parseTask(obj)
{$ENDIF FHIR_TASK}
{$IFDEF FHIR_TERMINOLOGYCAPABILITIES}
  else if SameText(type_, 'TerminologyCapabilities') then
    result := parseTerminologyCapabilities(obj)
{$ENDIF FHIR_TERMINOLOGYCAPABILITIES}
{$IFDEF FHIR_TESTREPORT}
  else if SameText(type_, 'TestReport') then
    result := parseTestReport(obj)
{$ENDIF FHIR_TESTREPORT}
{$IFDEF FHIR_TESTSCRIPT}
  else if SameText(type_, 'TestScript') then
    result := parseTestScript(obj)
{$ENDIF FHIR_TESTSCRIPT}
{$IFDEF FHIR_VALUESET}
  else if SameText(type_, 'ValueSet') then
    result := parseValueSet(obj)
{$ENDIF FHIR_VALUESET}
{$IFDEF FHIR_VERIFICATIONRESULT}
  else if SameText(type_, 'VerificationResult') then
    result := parseVerificationResult(obj)
{$ENDIF FHIR_VERIFICATIONRESULT}
{$IFDEF FHIR_VISIONPRESCRIPTION}
  else if SameText(type_, 'VisionPrescription') then
    result := parseVisionPrescription(obj)
{$ENDIF FHIR_VISIONPRESCRIPTION}
  else
    raise ERdfException.create('error: the element '+type_+' is not a valid fragment name');
end;

function TFHIRTurtleParser.ParseDataType(obj : TTurtleComplex; name : String; type_ : TFHIRTypeClass) : TFHIRType;
begin
   if (type_ = TFhirExtension) then
    result := parseExtension(obj)
  else if (type_ = TFhirNarrative) then
    result := parseNarrative(obj)
  else if (type_ = TFhirContributor) then
    result := parseContributor(obj)
  else if (type_ = TFhirAttachment) then
    result := parseAttachment(obj)
  else if (type_ = TFhirDataRequirement) then
    result := parseDataRequirement(obj)
  else if (type_ = TFhirDosage) then
    result := parseDosage(obj)
  else if (type_ = TFhirMoney) then
    result := parseMoney(obj)
  else if (type_ = TFhirMarketingStatus) then
    result := parseMarketingStatus(obj)
  else if (type_ = TFhirIdentifier) then
    result := parseIdentifier(obj)
  else if (type_ = TFhirSubstanceAmount) then
    result := parseSubstanceAmount(obj)
  else if (type_ = TFhirCoding) then
    result := parseCoding(obj)
  else if (type_ = TFhirSampledData) then
    result := parseSampledData(obj)
  else if (type_ = TFhirPopulation) then
    result := parsePopulation(obj)
  else if (type_ = TFhirRatio) then
    result := parseRatio(obj)
  else if (type_ = TFhirReference) then
    result := parseReference(obj)
  else if (type_ = TFhirTriggerDefinition) then
    result := parseTriggerDefinition(obj)
  else if (type_ = TFhirPeriod) then
    result := parsePeriod(obj)
  else if (type_ = TFhirQuantity) then
    result := parseQuantity(obj)
  else if (type_ = TFhirRange) then
    result := parseRange(obj)
  else if (type_ = TFhirRelatedArtifact) then
    result := parseRelatedArtifact(obj)
  else if (type_ = TFhirAnnotation) then
    result := parseAnnotation(obj)
  else if (type_ = TFhirProductShelfLife) then
    result := parseProductShelfLife(obj)
  else if (type_ = TFhirContactDetail) then
    result := parseContactDetail(obj)
  else if (type_ = TFhirExpression) then
    result := parseExpression(obj)
  else if (type_ = TFhirUsageContext) then
    result := parseUsageContext(obj)
  else if (type_ = TFhirSignature) then
    result := parseSignature(obj)
  else if (type_ = TFhirProdCharacteristic) then
    result := parseProdCharacteristic(obj)
  else if (type_ = TFhirCodeableConcept) then
    result := parseCodeableConcept(obj)
  else if (type_ = TFhirParameterDefinition) then
    result := parseParameterDefinition(obj)
  else if (type_ = TFhirContactPoint) then
    result := parseContactPoint(obj)
  else if (type_ = TFhirHumanName) then
    result := parseHumanName(obj)
  else if (type_ = TFhirMeta) then
    result := parseMeta(obj)
  else if (type_ = TFhirAddress) then
    result := parseAddress(obj)
  else if (type_ = TFhirElementDefinition) then
    result := parseElementDefinition(obj)
  else if (type_ = TFhirTiming) then
    result := parseTiming(obj)
  else if (type_ = TFhirCount) then
    result := parseCount(obj)
  else if (type_ = TFhirAge) then
    result := parseAge(obj)
  else if (type_ = TFhirDistance) then
    result := parseDistance(obj)
  else if (type_ = TFhirDuration) then
    result := parseDuration(obj)
  else
    raise ERdfException.create('Unknown Type');
end;

procedure TFHIRTurtleComposer.ComposeResource(parent : TTurtleComplex; resource : TFhirResource);
var
  this : TTurtleComplex;
begin
  if (resource = nil) Then
    Raise ERdfException.Create('error - resource is nil');
  this := parent;
  Case resource.ResourceType of
{$IFDEF FHIR_PARAMETERS}
    frtParameters: ComposeParameters(this, '', 'Parameters', TFhirParameters(resource), true, -1);
{$ENDIF FHIR_PARAMETERS}
{$IFDEF FHIR_ACCOUNT}
  {$IFDEF FHIR_ACCOUNT}
     frtAccount: ComposeAccount(this, '', 'Account', TFhirAccount(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_ACCOUNT}
{$IFDEF FHIR_ACTIVITYDEFINITION}
  {$IFDEF FHIR_ACTIVITYDEFINITION}
     frtActivityDefinition: ComposeActivityDefinition(this, '', 'ActivityDefinition', TFhirActivityDefinition(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_ACTIVITYDEFINITION}
{$IFDEF FHIR_ADVERSEEVENT}
  {$IFDEF FHIR_ADVERSEEVENT}
     frtAdverseEvent: ComposeAdverseEvent(this, '', 'AdverseEvent', TFhirAdverseEvent(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_ADVERSEEVENT}
{$IFDEF FHIR_ALLERGYINTOLERANCE}
  {$IFDEF FHIR_ALLERGYINTOLERANCE}
     frtAllergyIntolerance: ComposeAllergyIntolerance(this, '', 'AllergyIntolerance', TFhirAllergyIntolerance(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_ALLERGYINTOLERANCE}
{$IFDEF FHIR_APPOINTMENT}
  {$IFDEF FHIR_APPOINTMENT}
     frtAppointment: ComposeAppointment(this, '', 'Appointment', TFhirAppointment(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_APPOINTMENT}
{$IFDEF FHIR_APPOINTMENTRESPONSE}
  {$IFDEF FHIR_APPOINTMENTRESPONSE}
     frtAppointmentResponse: ComposeAppointmentResponse(this, '', 'AppointmentResponse', TFhirAppointmentResponse(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_APPOINTMENTRESPONSE}
{$IFDEF FHIR_AUDITEVENT}
  {$IFDEF FHIR_AUDITEVENT}
     frtAuditEvent: ComposeAuditEvent(this, '', 'AuditEvent', TFhirAuditEvent(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_AUDITEVENT}
{$IFDEF FHIR_BASIC}
  {$IFDEF FHIR_BASIC}
     frtBasic: ComposeBasic(this, '', 'Basic', TFhirBasic(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_BASIC}
{$IFDEF FHIR_BINARY}
  {$IFDEF FHIR_BINARY}
     frtBinary: ComposeBinary(this, '', 'Binary', TFhirBinary(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_BINARY}
{$IFDEF FHIR_BIOLOGICALLYDERIVEDPRODUCT}
  {$IFDEF FHIR_BIOLOGICALLYDERIVEDPRODUCT}
     frtBiologicallyDerivedProduct: ComposeBiologicallyDerivedProduct(this, '', 'BiologicallyDerivedProduct', TFhirBiologicallyDerivedProduct(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_BIOLOGICALLYDERIVEDPRODUCT}
{$IFDEF FHIR_BODYSTRUCTURE}
  {$IFDEF FHIR_BODYSTRUCTURE}
     frtBodyStructure: ComposeBodyStructure(this, '', 'BodyStructure', TFhirBodyStructure(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_BODYSTRUCTURE}
{$IFDEF FHIR_BUNDLE}
  {$IFDEF FHIR_BUNDLE}
     frtBundle: ComposeBundle(this, '', 'Bundle', TFhirBundle(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_BUNDLE}
{$IFDEF FHIR_CAPABILITYSTATEMENT}
  {$IFDEF FHIR_CAPABILITYSTATEMENT}
     frtCapabilityStatement: ComposeCapabilityStatement(this, '', 'CapabilityStatement', TFhirCapabilityStatement(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_CAPABILITYSTATEMENT}
{$IFDEF FHIR_CAREPLAN}
  {$IFDEF FHIR_CAREPLAN}
     frtCarePlan: ComposeCarePlan(this, '', 'CarePlan', TFhirCarePlan(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_CAREPLAN}
{$IFDEF FHIR_CARETEAM}
  {$IFDEF FHIR_CARETEAM}
     frtCareTeam: ComposeCareTeam(this, '', 'CareTeam', TFhirCareTeam(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_CARETEAM}
{$IFDEF FHIR_CATALOGENTRY}
  {$IFDEF FHIR_CATALOGENTRY}
     frtCatalogEntry: ComposeCatalogEntry(this, '', 'CatalogEntry', TFhirCatalogEntry(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_CATALOGENTRY}
{$IFDEF FHIR_CHARGEITEM}
  {$IFDEF FHIR_CHARGEITEM}
     frtChargeItem: ComposeChargeItem(this, '', 'ChargeItem', TFhirChargeItem(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_CHARGEITEM}
{$IFDEF FHIR_CHARGEITEMDEFINITION}
  {$IFDEF FHIR_CHARGEITEMDEFINITION}
     frtChargeItemDefinition: ComposeChargeItemDefinition(this, '', 'ChargeItemDefinition', TFhirChargeItemDefinition(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_CHARGEITEMDEFINITION}
{$IFDEF FHIR_CLAIM}
  {$IFDEF FHIR_CLAIM}
     frtClaim: ComposeClaim(this, '', 'Claim', TFhirClaim(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_CLAIM}
{$IFDEF FHIR_CLAIMRESPONSE}
  {$IFDEF FHIR_CLAIMRESPONSE}
     frtClaimResponse: ComposeClaimResponse(this, '', 'ClaimResponse', TFhirClaimResponse(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_CLAIMRESPONSE}
{$IFDEF FHIR_CLINICALIMPRESSION}
  {$IFDEF FHIR_CLINICALIMPRESSION}
     frtClinicalImpression: ComposeClinicalImpression(this, '', 'ClinicalImpression', TFhirClinicalImpression(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_CLINICALIMPRESSION}
{$IFDEF FHIR_CODESYSTEM}
  {$IFDEF FHIR_CODESYSTEM}
     frtCodeSystem: ComposeCodeSystem(this, '', 'CodeSystem', TFhirCodeSystem(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_CODESYSTEM}
{$IFDEF FHIR_COMMUNICATION}
  {$IFDEF FHIR_COMMUNICATION}
     frtCommunication: ComposeCommunication(this, '', 'Communication', TFhirCommunication(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_COMMUNICATION}
{$IFDEF FHIR_COMMUNICATIONREQUEST}
  {$IFDEF FHIR_COMMUNICATIONREQUEST}
     frtCommunicationRequest: ComposeCommunicationRequest(this, '', 'CommunicationRequest', TFhirCommunicationRequest(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_COMMUNICATIONREQUEST}
{$IFDEF FHIR_COMPARTMENTDEFINITION}
  {$IFDEF FHIR_COMPARTMENTDEFINITION}
     frtCompartmentDefinition: ComposeCompartmentDefinition(this, '', 'CompartmentDefinition', TFhirCompartmentDefinition(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_COMPARTMENTDEFINITION}
{$IFDEF FHIR_COMPOSITION}
  {$IFDEF FHIR_COMPOSITION}
     frtComposition: ComposeComposition(this, '', 'Composition', TFhirComposition(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_COMPOSITION}
{$IFDEF FHIR_CONCEPTMAP}
  {$IFDEF FHIR_CONCEPTMAP}
     frtConceptMap: ComposeConceptMap(this, '', 'ConceptMap', TFhirConceptMap(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_CONCEPTMAP}
{$IFDEF FHIR_CONDITION}
  {$IFDEF FHIR_CONDITION}
     frtCondition: ComposeCondition(this, '', 'Condition', TFhirCondition(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_CONDITION}
{$IFDEF FHIR_CONSENT}
  {$IFDEF FHIR_CONSENT}
     frtConsent: ComposeConsent(this, '', 'Consent', TFhirConsent(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_CONSENT}
{$IFDEF FHIR_CONTRACT}
  {$IFDEF FHIR_CONTRACT}
     frtContract: ComposeContract(this, '', 'Contract', TFhirContract(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_CONTRACT}
{$IFDEF FHIR_COVERAGE}
  {$IFDEF FHIR_COVERAGE}
     frtCoverage: ComposeCoverage(this, '', 'Coverage', TFhirCoverage(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_COVERAGE}
{$IFDEF FHIR_COVERAGEELIGIBILITYREQUEST}
  {$IFDEF FHIR_COVERAGEELIGIBILITYREQUEST}
     frtCoverageEligibilityRequest: ComposeCoverageEligibilityRequest(this, '', 'CoverageEligibilityRequest', TFhirCoverageEligibilityRequest(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_COVERAGEELIGIBILITYREQUEST}
{$IFDEF FHIR_COVERAGEELIGIBILITYRESPONSE}
  {$IFDEF FHIR_COVERAGEELIGIBILITYRESPONSE}
     frtCoverageEligibilityResponse: ComposeCoverageEligibilityResponse(this, '', 'CoverageEligibilityResponse', TFhirCoverageEligibilityResponse(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_COVERAGEELIGIBILITYRESPONSE}
{$IFDEF FHIR_DETECTEDISSUE}
  {$IFDEF FHIR_DETECTEDISSUE}
     frtDetectedIssue: ComposeDetectedIssue(this, '', 'DetectedIssue', TFhirDetectedIssue(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_DETECTEDISSUE}
{$IFDEF FHIR_DEVICE}
  {$IFDEF FHIR_DEVICE}
     frtDevice: ComposeDevice(this, '', 'Device', TFhirDevice(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_DEVICE}
{$IFDEF FHIR_DEVICEDEFINITION}
  {$IFDEF FHIR_DEVICEDEFINITION}
     frtDeviceDefinition: ComposeDeviceDefinition(this, '', 'DeviceDefinition', TFhirDeviceDefinition(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_DEVICEDEFINITION}
{$IFDEF FHIR_DEVICEMETRIC}
  {$IFDEF FHIR_DEVICEMETRIC}
     frtDeviceMetric: ComposeDeviceMetric(this, '', 'DeviceMetric', TFhirDeviceMetric(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_DEVICEMETRIC}
{$IFDEF FHIR_DEVICEREQUEST}
  {$IFDEF FHIR_DEVICEREQUEST}
     frtDeviceRequest: ComposeDeviceRequest(this, '', 'DeviceRequest', TFhirDeviceRequest(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_DEVICEREQUEST}
{$IFDEF FHIR_DEVICEUSESTATEMENT}
  {$IFDEF FHIR_DEVICEUSESTATEMENT}
     frtDeviceUseStatement: ComposeDeviceUseStatement(this, '', 'DeviceUseStatement', TFhirDeviceUseStatement(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_DEVICEUSESTATEMENT}
{$IFDEF FHIR_DIAGNOSTICREPORT}
  {$IFDEF FHIR_DIAGNOSTICREPORT}
     frtDiagnosticReport: ComposeDiagnosticReport(this, '', 'DiagnosticReport', TFhirDiagnosticReport(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_DIAGNOSTICREPORT}
{$IFDEF FHIR_DOCUMENTMANIFEST}
  {$IFDEF FHIR_DOCUMENTMANIFEST}
     frtDocumentManifest: ComposeDocumentManifest(this, '', 'DocumentManifest', TFhirDocumentManifest(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_DOCUMENTMANIFEST}
{$IFDEF FHIR_DOCUMENTREFERENCE}
  {$IFDEF FHIR_DOCUMENTREFERENCE}
     frtDocumentReference: ComposeDocumentReference(this, '', 'DocumentReference', TFhirDocumentReference(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_DOCUMENTREFERENCE}
{$IFDEF FHIR_EFFECTEVIDENCESYNTHESIS}
  {$IFDEF FHIR_EFFECTEVIDENCESYNTHESIS}
     frtEffectEvidenceSynthesis: ComposeEffectEvidenceSynthesis(this, '', 'EffectEvidenceSynthesis', TFhirEffectEvidenceSynthesis(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_EFFECTEVIDENCESYNTHESIS}
{$IFDEF FHIR_ENCOUNTER}
  {$IFDEF FHIR_ENCOUNTER}
     frtEncounter: ComposeEncounter(this, '', 'Encounter', TFhirEncounter(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_ENCOUNTER}
{$IFDEF FHIR_ENDPOINT}
  {$IFDEF FHIR_ENDPOINT}
     frtEndpoint: ComposeEndpoint(this, '', 'Endpoint', TFhirEndpoint(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_ENDPOINT}
{$IFDEF FHIR_ENROLLMENTREQUEST}
  {$IFDEF FHIR_ENROLLMENTREQUEST}
     frtEnrollmentRequest: ComposeEnrollmentRequest(this, '', 'EnrollmentRequest', TFhirEnrollmentRequest(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_ENROLLMENTREQUEST}
{$IFDEF FHIR_ENROLLMENTRESPONSE}
  {$IFDEF FHIR_ENROLLMENTRESPONSE}
     frtEnrollmentResponse: ComposeEnrollmentResponse(this, '', 'EnrollmentResponse', TFhirEnrollmentResponse(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_ENROLLMENTRESPONSE}
{$IFDEF FHIR_EPISODEOFCARE}
  {$IFDEF FHIR_EPISODEOFCARE}
     frtEpisodeOfCare: ComposeEpisodeOfCare(this, '', 'EpisodeOfCare', TFhirEpisodeOfCare(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_EPISODEOFCARE}
{$IFDEF FHIR_EVENTDEFINITION}
  {$IFDEF FHIR_EVENTDEFINITION}
     frtEventDefinition: ComposeEventDefinition(this, '', 'EventDefinition', TFhirEventDefinition(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_EVENTDEFINITION}
{$IFDEF FHIR_EVIDENCE}
  {$IFDEF FHIR_EVIDENCE}
     frtEvidence: ComposeEvidence(this, '', 'Evidence', TFhirEvidence(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_EVIDENCE}
{$IFDEF FHIR_EVIDENCEVARIABLE}
  {$IFDEF FHIR_EVIDENCEVARIABLE}
     frtEvidenceVariable: ComposeEvidenceVariable(this, '', 'EvidenceVariable', TFhirEvidenceVariable(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_EVIDENCEVARIABLE}
{$IFDEF FHIR_EXAMPLESCENARIO}
  {$IFDEF FHIR_EXAMPLESCENARIO}
     frtExampleScenario: ComposeExampleScenario(this, '', 'ExampleScenario', TFhirExampleScenario(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_EXAMPLESCENARIO}
{$IFDEF FHIR_EXPLANATIONOFBENEFIT}
  {$IFDEF FHIR_EXPLANATIONOFBENEFIT}
     frtExplanationOfBenefit: ComposeExplanationOfBenefit(this, '', 'ExplanationOfBenefit', TFhirExplanationOfBenefit(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_EXPLANATIONOFBENEFIT}
{$IFDEF FHIR_FAMILYMEMBERHISTORY}
  {$IFDEF FHIR_FAMILYMEMBERHISTORY}
     frtFamilyMemberHistory: ComposeFamilyMemberHistory(this, '', 'FamilyMemberHistory', TFhirFamilyMemberHistory(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_FAMILYMEMBERHISTORY}
{$IFDEF FHIR_FLAG}
  {$IFDEF FHIR_FLAG}
     frtFlag: ComposeFlag(this, '', 'Flag', TFhirFlag(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_FLAG}
{$IFDEF FHIR_GOAL}
  {$IFDEF FHIR_GOAL}
     frtGoal: ComposeGoal(this, '', 'Goal', TFhirGoal(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_GOAL}
{$IFDEF FHIR_GRAPHDEFINITION}
  {$IFDEF FHIR_GRAPHDEFINITION}
     frtGraphDefinition: ComposeGraphDefinition(this, '', 'GraphDefinition', TFhirGraphDefinition(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_GRAPHDEFINITION}
{$IFDEF FHIR_GROUP}
  {$IFDEF FHIR_GROUP}
     frtGroup: ComposeGroup(this, '', 'Group', TFhirGroup(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_GROUP}
{$IFDEF FHIR_GUIDANCERESPONSE}
  {$IFDEF FHIR_GUIDANCERESPONSE}
     frtGuidanceResponse: ComposeGuidanceResponse(this, '', 'GuidanceResponse', TFhirGuidanceResponse(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_GUIDANCERESPONSE}
{$IFDEF FHIR_HEALTHCARESERVICE}
  {$IFDEF FHIR_HEALTHCARESERVICE}
     frtHealthcareService: ComposeHealthcareService(this, '', 'HealthcareService', TFhirHealthcareService(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_HEALTHCARESERVICE}
{$IFDEF FHIR_IMAGINGSTUDY}
  {$IFDEF FHIR_IMAGINGSTUDY}
     frtImagingStudy: ComposeImagingStudy(this, '', 'ImagingStudy', TFhirImagingStudy(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_IMAGINGSTUDY}
{$IFDEF FHIR_IMMUNIZATION}
  {$IFDEF FHIR_IMMUNIZATION}
     frtImmunization: ComposeImmunization(this, '', 'Immunization', TFhirImmunization(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_IMMUNIZATION}
{$IFDEF FHIR_IMMUNIZATIONEVALUATION}
  {$IFDEF FHIR_IMMUNIZATIONEVALUATION}
     frtImmunizationEvaluation: ComposeImmunizationEvaluation(this, '', 'ImmunizationEvaluation', TFhirImmunizationEvaluation(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_IMMUNIZATIONEVALUATION}
{$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
  {$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
     frtImmunizationRecommendation: ComposeImmunizationRecommendation(this, '', 'ImmunizationRecommendation', TFhirImmunizationRecommendation(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_IMMUNIZATIONRECOMMENDATION}
{$IFDEF FHIR_IMPLEMENTATIONGUIDE}
  {$IFDEF FHIR_IMPLEMENTATIONGUIDE}
     frtImplementationGuide: ComposeImplementationGuide(this, '', 'ImplementationGuide', TFhirImplementationGuide(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_IMPLEMENTATIONGUIDE}
{$IFDEF FHIR_INSURANCEPLAN}
  {$IFDEF FHIR_INSURANCEPLAN}
     frtInsurancePlan: ComposeInsurancePlan(this, '', 'InsurancePlan', TFhirInsurancePlan(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_INSURANCEPLAN}
{$IFDEF FHIR_INVOICE}
  {$IFDEF FHIR_INVOICE}
     frtInvoice: ComposeInvoice(this, '', 'Invoice', TFhirInvoice(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_INVOICE}
{$IFDEF FHIR_LIBRARY}
  {$IFDEF FHIR_LIBRARY}
     frtLibrary: ComposeLibrary(this, '', 'Library', TFhirLibrary(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_LIBRARY}
{$IFDEF FHIR_LINKAGE}
  {$IFDEF FHIR_LINKAGE}
     frtLinkage: ComposeLinkage(this, '', 'Linkage', TFhirLinkage(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_LINKAGE}
{$IFDEF FHIR_LIST}
  {$IFDEF FHIR_LIST}
     frtList: ComposeList(this, '', 'List', TFhirList(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_LIST}
{$IFDEF FHIR_LOCATION}
  {$IFDEF FHIR_LOCATION}
     frtLocation: ComposeLocation(this, '', 'Location', TFhirLocation(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_LOCATION}
{$IFDEF FHIR_MEASURE}
  {$IFDEF FHIR_MEASURE}
     frtMeasure: ComposeMeasure(this, '', 'Measure', TFhirMeasure(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_MEASURE}
{$IFDEF FHIR_MEASUREREPORT}
  {$IFDEF FHIR_MEASUREREPORT}
     frtMeasureReport: ComposeMeasureReport(this, '', 'MeasureReport', TFhirMeasureReport(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_MEASUREREPORT}
{$IFDEF FHIR_MEDIA}
  {$IFDEF FHIR_MEDIA}
     frtMedia: ComposeMedia(this, '', 'Media', TFhirMedia(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_MEDIA}
{$IFDEF FHIR_MEDICATION}
  {$IFDEF FHIR_MEDICATION}
     frtMedication: ComposeMedication(this, '', 'Medication', TFhirMedication(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_MEDICATION}
{$IFDEF FHIR_MEDICATIONADMINISTRATION}
  {$IFDEF FHIR_MEDICATIONADMINISTRATION}
     frtMedicationAdministration: ComposeMedicationAdministration(this, '', 'MedicationAdministration', TFhirMedicationAdministration(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_MEDICATIONADMINISTRATION}
{$IFDEF FHIR_MEDICATIONDISPENSE}
  {$IFDEF FHIR_MEDICATIONDISPENSE}
     frtMedicationDispense: ComposeMedicationDispense(this, '', 'MedicationDispense', TFhirMedicationDispense(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_MEDICATIONDISPENSE}
{$IFDEF FHIR_MEDICATIONKNOWLEDGE}
  {$IFDEF FHIR_MEDICATIONKNOWLEDGE}
     frtMedicationKnowledge: ComposeMedicationKnowledge(this, '', 'MedicationKnowledge', TFhirMedicationKnowledge(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_MEDICATIONKNOWLEDGE}
{$IFDEF FHIR_MEDICATIONREQUEST}
  {$IFDEF FHIR_MEDICATIONREQUEST}
     frtMedicationRequest: ComposeMedicationRequest(this, '', 'MedicationRequest', TFhirMedicationRequest(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_MEDICATIONREQUEST}
{$IFDEF FHIR_MEDICATIONSTATEMENT}
  {$IFDEF FHIR_MEDICATIONSTATEMENT}
     frtMedicationStatement: ComposeMedicationStatement(this, '', 'MedicationStatement', TFhirMedicationStatement(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_MEDICATIONSTATEMENT}
{$IFDEF FHIR_MEDICINALPRODUCT}
  {$IFDEF FHIR_MEDICINALPRODUCT}
     frtMedicinalProduct: ComposeMedicinalProduct(this, '', 'MedicinalProduct', TFhirMedicinalProduct(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_MEDICINALPRODUCT}
{$IFDEF FHIR_MEDICINALPRODUCTAUTHORIZATION}
  {$IFDEF FHIR_MEDICINALPRODUCTAUTHORIZATION}
     frtMedicinalProductAuthorization: ComposeMedicinalProductAuthorization(this, '', 'MedicinalProductAuthorization', TFhirMedicinalProductAuthorization(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_MEDICINALPRODUCTAUTHORIZATION}
{$IFDEF FHIR_MEDICINALPRODUCTCONTRAINDICATION}
  {$IFDEF FHIR_MEDICINALPRODUCTCONTRAINDICATION}
     frtMedicinalProductContraindication: ComposeMedicinalProductContraindication(this, '', 'MedicinalProductContraindication', TFhirMedicinalProductContraindication(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_MEDICINALPRODUCTCONTRAINDICATION}
{$IFDEF FHIR_MEDICINALPRODUCTINDICATION}
  {$IFDEF FHIR_MEDICINALPRODUCTINDICATION}
     frtMedicinalProductIndication: ComposeMedicinalProductIndication(this, '', 'MedicinalProductIndication', TFhirMedicinalProductIndication(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_MEDICINALPRODUCTINDICATION}
{$IFDEF FHIR_MEDICINALPRODUCTINGREDIENT}
  {$IFDEF FHIR_MEDICINALPRODUCTINGREDIENT}
     frtMedicinalProductIngredient: ComposeMedicinalProductIngredient(this, '', 'MedicinalProductIngredient', TFhirMedicinalProductIngredient(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_MEDICINALPRODUCTINGREDIENT}
{$IFDEF FHIR_MEDICINALPRODUCTINTERACTION}
  {$IFDEF FHIR_MEDICINALPRODUCTINTERACTION}
     frtMedicinalProductInteraction: ComposeMedicinalProductInteraction(this, '', 'MedicinalProductInteraction', TFhirMedicinalProductInteraction(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_MEDICINALPRODUCTINTERACTION}
{$IFDEF FHIR_MEDICINALPRODUCTMANUFACTURED}
  {$IFDEF FHIR_MEDICINALPRODUCTMANUFACTURED}
     frtMedicinalProductManufactured: ComposeMedicinalProductManufactured(this, '', 'MedicinalProductManufactured', TFhirMedicinalProductManufactured(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_MEDICINALPRODUCTMANUFACTURED}
{$IFDEF FHIR_MEDICINALPRODUCTPACKAGED}
  {$IFDEF FHIR_MEDICINALPRODUCTPACKAGED}
     frtMedicinalProductPackaged: ComposeMedicinalProductPackaged(this, '', 'MedicinalProductPackaged', TFhirMedicinalProductPackaged(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_MEDICINALPRODUCTPACKAGED}
{$IFDEF FHIR_MEDICINALPRODUCTPHARMACEUTICAL}
  {$IFDEF FHIR_MEDICINALPRODUCTPHARMACEUTICAL}
     frtMedicinalProductPharmaceutical: ComposeMedicinalProductPharmaceutical(this, '', 'MedicinalProductPharmaceutical', TFhirMedicinalProductPharmaceutical(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_MEDICINALPRODUCTPHARMACEUTICAL}
{$IFDEF FHIR_MEDICINALPRODUCTUNDESIRABLEEFFECT}
  {$IFDEF FHIR_MEDICINALPRODUCTUNDESIRABLEEFFECT}
     frtMedicinalProductUndesirableEffect: ComposeMedicinalProductUndesirableEffect(this, '', 'MedicinalProductUndesirableEffect', TFhirMedicinalProductUndesirableEffect(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_MEDICINALPRODUCTUNDESIRABLEEFFECT}
{$IFDEF FHIR_MESSAGEDEFINITION}
  {$IFDEF FHIR_MESSAGEDEFINITION}
     frtMessageDefinition: ComposeMessageDefinition(this, '', 'MessageDefinition', TFhirMessageDefinition(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_MESSAGEDEFINITION}
{$IFDEF FHIR_MESSAGEHEADER}
  {$IFDEF FHIR_MESSAGEHEADER}
     frtMessageHeader: ComposeMessageHeader(this, '', 'MessageHeader', TFhirMessageHeader(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_MESSAGEHEADER}
{$IFDEF FHIR_MOLECULARSEQUENCE}
  {$IFDEF FHIR_MOLECULARSEQUENCE}
     frtMolecularSequence: ComposeMolecularSequence(this, '', 'MolecularSequence', TFhirMolecularSequence(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_MOLECULARSEQUENCE}
{$IFDEF FHIR_NAMINGSYSTEM}
  {$IFDEF FHIR_NAMINGSYSTEM}
     frtNamingSystem: ComposeNamingSystem(this, '', 'NamingSystem', TFhirNamingSystem(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_NAMINGSYSTEM}
{$IFDEF FHIR_NUTRITIONORDER}
  {$IFDEF FHIR_NUTRITIONORDER}
     frtNutritionOrder: ComposeNutritionOrder(this, '', 'NutritionOrder', TFhirNutritionOrder(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_NUTRITIONORDER}
{$IFDEF FHIR_OBSERVATION}
  {$IFDEF FHIR_OBSERVATION}
     frtObservation: ComposeObservation(this, '', 'Observation', TFhirObservation(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_OBSERVATION}
{$IFDEF FHIR_OBSERVATIONDEFINITION}
  {$IFDEF FHIR_OBSERVATIONDEFINITION}
     frtObservationDefinition: ComposeObservationDefinition(this, '', 'ObservationDefinition', TFhirObservationDefinition(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_OBSERVATIONDEFINITION}
{$IFDEF FHIR_OPERATIONDEFINITION}
  {$IFDEF FHIR_OPERATIONDEFINITION}
     frtOperationDefinition: ComposeOperationDefinition(this, '', 'OperationDefinition', TFhirOperationDefinition(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_OPERATIONDEFINITION}
{$IFDEF FHIR_OPERATIONOUTCOME}
  {$IFDEF FHIR_OPERATIONOUTCOME}
     frtOperationOutcome: ComposeOperationOutcome(this, '', 'OperationOutcome', TFhirOperationOutcome(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_OPERATIONOUTCOME}
{$IFDEF FHIR_ORGANIZATION}
  {$IFDEF FHIR_ORGANIZATION}
     frtOrganization: ComposeOrganization(this, '', 'Organization', TFhirOrganization(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_ORGANIZATION}
{$IFDEF FHIR_ORGANIZATIONAFFILIATION}
  {$IFDEF FHIR_ORGANIZATIONAFFILIATION}
     frtOrganizationAffiliation: ComposeOrganizationAffiliation(this, '', 'OrganizationAffiliation', TFhirOrganizationAffiliation(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_ORGANIZATIONAFFILIATION}
{$IFDEF FHIR_PATIENT}
  {$IFDEF FHIR_PATIENT}
     frtPatient: ComposePatient(this, '', 'Patient', TFhirPatient(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_PATIENT}
{$IFDEF FHIR_PAYMENTNOTICE}
  {$IFDEF FHIR_PAYMENTNOTICE}
     frtPaymentNotice: ComposePaymentNotice(this, '', 'PaymentNotice', TFhirPaymentNotice(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_PAYMENTNOTICE}
{$IFDEF FHIR_PAYMENTRECONCILIATION}
  {$IFDEF FHIR_PAYMENTRECONCILIATION}
     frtPaymentReconciliation: ComposePaymentReconciliation(this, '', 'PaymentReconciliation', TFhirPaymentReconciliation(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_PAYMENTRECONCILIATION}
{$IFDEF FHIR_PERSON}
  {$IFDEF FHIR_PERSON}
     frtPerson: ComposePerson(this, '', 'Person', TFhirPerson(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_PERSON}
{$IFDEF FHIR_PLANDEFINITION}
  {$IFDEF FHIR_PLANDEFINITION}
     frtPlanDefinition: ComposePlanDefinition(this, '', 'PlanDefinition', TFhirPlanDefinition(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_PLANDEFINITION}
{$IFDEF FHIR_PRACTITIONER}
  {$IFDEF FHIR_PRACTITIONER}
     frtPractitioner: ComposePractitioner(this, '', 'Practitioner', TFhirPractitioner(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_PRACTITIONER}
{$IFDEF FHIR_PRACTITIONERROLE}
  {$IFDEF FHIR_PRACTITIONERROLE}
     frtPractitionerRole: ComposePractitionerRole(this, '', 'PractitionerRole', TFhirPractitionerRole(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_PRACTITIONERROLE}
{$IFDEF FHIR_PROCEDURE}
  {$IFDEF FHIR_PROCEDURE}
     frtProcedure: ComposeProcedure(this, '', 'Procedure', TFhirProcedure(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_PROCEDURE}
{$IFDEF FHIR_PROVENANCE}
  {$IFDEF FHIR_PROVENANCE}
     frtProvenance: ComposeProvenance(this, '', 'Provenance', TFhirProvenance(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_PROVENANCE}
{$IFDEF FHIR_QUESTIONNAIRE}
  {$IFDEF FHIR_QUESTIONNAIRE}
     frtQuestionnaire: ComposeQuestionnaire(this, '', 'Questionnaire', TFhirQuestionnaire(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_QUESTIONNAIRE}
{$IFDEF FHIR_QUESTIONNAIRERESPONSE}
  {$IFDEF FHIR_QUESTIONNAIRERESPONSE}
     frtQuestionnaireResponse: ComposeQuestionnaireResponse(this, '', 'QuestionnaireResponse', TFhirQuestionnaireResponse(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_QUESTIONNAIRERESPONSE}
{$IFDEF FHIR_RELATEDPERSON}
  {$IFDEF FHIR_RELATEDPERSON}
     frtRelatedPerson: ComposeRelatedPerson(this, '', 'RelatedPerson', TFhirRelatedPerson(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_RELATEDPERSON}
{$IFDEF FHIR_REQUESTGROUP}
  {$IFDEF FHIR_REQUESTGROUP}
     frtRequestGroup: ComposeRequestGroup(this, '', 'RequestGroup', TFhirRequestGroup(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_REQUESTGROUP}
{$IFDEF FHIR_RESEARCHDEFINITION}
  {$IFDEF FHIR_RESEARCHDEFINITION}
     frtResearchDefinition: ComposeResearchDefinition(this, '', 'ResearchDefinition', TFhirResearchDefinition(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_RESEARCHDEFINITION}
{$IFDEF FHIR_RESEARCHELEMENTDEFINITION}
  {$IFDEF FHIR_RESEARCHELEMENTDEFINITION}
     frtResearchElementDefinition: ComposeResearchElementDefinition(this, '', 'ResearchElementDefinition', TFhirResearchElementDefinition(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_RESEARCHELEMENTDEFINITION}
{$IFDEF FHIR_RESEARCHSTUDY}
  {$IFDEF FHIR_RESEARCHSTUDY}
     frtResearchStudy: ComposeResearchStudy(this, '', 'ResearchStudy', TFhirResearchStudy(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_RESEARCHSTUDY}
{$IFDEF FHIR_RESEARCHSUBJECT}
  {$IFDEF FHIR_RESEARCHSUBJECT}
     frtResearchSubject: ComposeResearchSubject(this, '', 'ResearchSubject', TFhirResearchSubject(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_RESEARCHSUBJECT}
{$IFDEF FHIR_RISKASSESSMENT}
  {$IFDEF FHIR_RISKASSESSMENT}
     frtRiskAssessment: ComposeRiskAssessment(this, '', 'RiskAssessment', TFhirRiskAssessment(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_RISKASSESSMENT}
{$IFDEF FHIR_RISKEVIDENCESYNTHESIS}
  {$IFDEF FHIR_RISKEVIDENCESYNTHESIS}
     frtRiskEvidenceSynthesis: ComposeRiskEvidenceSynthesis(this, '', 'RiskEvidenceSynthesis', TFhirRiskEvidenceSynthesis(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_RISKEVIDENCESYNTHESIS}
{$IFDEF FHIR_SCHEDULE}
  {$IFDEF FHIR_SCHEDULE}
     frtSchedule: ComposeSchedule(this, '', 'Schedule', TFhirSchedule(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_SCHEDULE}
{$IFDEF FHIR_SEARCHPARAMETER}
  {$IFDEF FHIR_SEARCHPARAMETER}
     frtSearchParameter: ComposeSearchParameter(this, '', 'SearchParameter', TFhirSearchParameter(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_SEARCHPARAMETER}
{$IFDEF FHIR_SERVICEREQUEST}
  {$IFDEF FHIR_SERVICEREQUEST}
     frtServiceRequest: ComposeServiceRequest(this, '', 'ServiceRequest', TFhirServiceRequest(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_SERVICEREQUEST}
{$IFDEF FHIR_SLOT}
  {$IFDEF FHIR_SLOT}
     frtSlot: ComposeSlot(this, '', 'Slot', TFhirSlot(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_SLOT}
{$IFDEF FHIR_SPECIMEN}
  {$IFDEF FHIR_SPECIMEN}
     frtSpecimen: ComposeSpecimen(this, '', 'Specimen', TFhirSpecimen(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_SPECIMEN}
{$IFDEF FHIR_SPECIMENDEFINITION}
  {$IFDEF FHIR_SPECIMENDEFINITION}
     frtSpecimenDefinition: ComposeSpecimenDefinition(this, '', 'SpecimenDefinition', TFhirSpecimenDefinition(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_SPECIMENDEFINITION}
{$IFDEF FHIR_STRUCTUREDEFINITION}
  {$IFDEF FHIR_STRUCTUREDEFINITION}
     frtStructureDefinition: ComposeStructureDefinition(this, '', 'StructureDefinition', TFhirStructureDefinition(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_STRUCTUREDEFINITION}
{$IFDEF FHIR_STRUCTUREMAP}
  {$IFDEF FHIR_STRUCTUREMAP}
     frtStructureMap: ComposeStructureMap(this, '', 'StructureMap', TFhirStructureMap(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_STRUCTUREMAP}
{$IFDEF FHIR_SUBSCRIPTION}
  {$IFDEF FHIR_SUBSCRIPTION}
     frtSubscription: ComposeSubscription(this, '', 'Subscription', TFhirSubscription(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_SUBSCRIPTION}
{$IFDEF FHIR_SUBSTANCE}
  {$IFDEF FHIR_SUBSTANCE}
     frtSubstance: ComposeSubstance(this, '', 'Substance', TFhirSubstance(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_SUBSTANCE}
{$IFDEF FHIR_SUBSTANCENUCLEICACID}
  {$IFDEF FHIR_SUBSTANCENUCLEICACID}
     frtSubstanceNucleicAcid: ComposeSubstanceNucleicAcid(this, '', 'SubstanceNucleicAcid', TFhirSubstanceNucleicAcid(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_SUBSTANCENUCLEICACID}
{$IFDEF FHIR_SUBSTANCEPOLYMER}
  {$IFDEF FHIR_SUBSTANCEPOLYMER}
     frtSubstancePolymer: ComposeSubstancePolymer(this, '', 'SubstancePolymer', TFhirSubstancePolymer(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_SUBSTANCEPOLYMER}
{$IFDEF FHIR_SUBSTANCEPROTEIN}
  {$IFDEF FHIR_SUBSTANCEPROTEIN}
     frtSubstanceProtein: ComposeSubstanceProtein(this, '', 'SubstanceProtein', TFhirSubstanceProtein(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_SUBSTANCEPROTEIN}
{$IFDEF FHIR_SUBSTANCEREFERENCEINFORMATION}
  {$IFDEF FHIR_SUBSTANCEREFERENCEINFORMATION}
     frtSubstanceReferenceInformation: ComposeSubstanceReferenceInformation(this, '', 'SubstanceReferenceInformation', TFhirSubstanceReferenceInformation(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_SUBSTANCEREFERENCEINFORMATION}
{$IFDEF FHIR_SUBSTANCESOURCEMATERIAL}
  {$IFDEF FHIR_SUBSTANCESOURCEMATERIAL}
     frtSubstanceSourceMaterial: ComposeSubstanceSourceMaterial(this, '', 'SubstanceSourceMaterial', TFhirSubstanceSourceMaterial(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_SUBSTANCESOURCEMATERIAL}
{$IFDEF FHIR_SUBSTANCESPECIFICATION}
  {$IFDEF FHIR_SUBSTANCESPECIFICATION}
     frtSubstanceSpecification: ComposeSubstanceSpecification(this, '', 'SubstanceSpecification', TFhirSubstanceSpecification(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_SUBSTANCESPECIFICATION}
{$IFDEF FHIR_SUPPLYDELIVERY}
  {$IFDEF FHIR_SUPPLYDELIVERY}
     frtSupplyDelivery: ComposeSupplyDelivery(this, '', 'SupplyDelivery', TFhirSupplyDelivery(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_SUPPLYDELIVERY}
{$IFDEF FHIR_SUPPLYREQUEST}
  {$IFDEF FHIR_SUPPLYREQUEST}
     frtSupplyRequest: ComposeSupplyRequest(this, '', 'SupplyRequest', TFhirSupplyRequest(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_SUPPLYREQUEST}
{$IFDEF FHIR_TASK}
  {$IFDEF FHIR_TASK}
     frtTask: ComposeTask(this, '', 'Task', TFhirTask(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_TASK}
{$IFDEF FHIR_TERMINOLOGYCAPABILITIES}
  {$IFDEF FHIR_TERMINOLOGYCAPABILITIES}
     frtTerminologyCapabilities: ComposeTerminologyCapabilities(this, '', 'TerminologyCapabilities', TFhirTerminologyCapabilities(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_TERMINOLOGYCAPABILITIES}
{$IFDEF FHIR_TESTREPORT}
  {$IFDEF FHIR_TESTREPORT}
     frtTestReport: ComposeTestReport(this, '', 'TestReport', TFhirTestReport(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_TESTREPORT}
{$IFDEF FHIR_TESTSCRIPT}
  {$IFDEF FHIR_TESTSCRIPT}
     frtTestScript: ComposeTestScript(this, '', 'TestScript', TFhirTestScript(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_TESTSCRIPT}
{$IFDEF FHIR_VALUESET}
  {$IFDEF FHIR_VALUESET}
     frtValueSet: ComposeValueSet(this, '', 'ValueSet', TFhirValueSet(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_VALUESET}
{$IFDEF FHIR_VERIFICATIONRESULT}
  {$IFDEF FHIR_VERIFICATIONRESULT}
     frtVerificationResult: ComposeVerificationResult(this, '', 'VerificationResult', TFhirVerificationResult(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_VERIFICATIONRESULT}
{$IFDEF FHIR_VISIONPRESCRIPTION}
  {$IFDEF FHIR_VISIONPRESCRIPTION}
     frtVisionPrescription: ComposeVisionPrescription(this, '', 'VisionPrescription', TFhirVisionPrescription(resource), true, -1); 
  {$ENDIF}
{$ENDIF FHIR_VISIONPRESCRIPTION}
  else
    raise ERdfException.create('Internal error: the resource type '+CODES_TFhirResourceType[resource.ResourceType]+' is not a valid resource type');
  end;
end;

function TFHIRTurtleParser.ParseResource(obj : TTurtleComplex) : TFhirResource;
var
  s : String;
begin
  s := rdfsType(obj);
 {$IFDEF FHIR_PARAMETERS}
  if s = 'Parameters' Then
    result := ParseParameters(obj)
{$ENDIF FHIR_PARAMETERS}
{$IFDEF FHIR_ACCOUNT}
  {$IFDEF FHIR_ACCOUNT}
   else if s = 'Account' Then
    result := ParseAccount(obj) 
  {$ENDIF}
{$ENDIF FHIR_ACCOUNT}
{$IFDEF FHIR_ACTIVITYDEFINITION}
  {$IFDEF FHIR_ACTIVITYDEFINITION}
   else if s = 'ActivityDefinition' Then
    result := ParseActivityDefinition(obj) 
  {$ENDIF}
{$ENDIF FHIR_ACTIVITYDEFINITION}
{$IFDEF FHIR_ADVERSEEVENT}
  {$IFDEF FHIR_ADVERSEEVENT}
   else if s = 'AdverseEvent' Then
    result := ParseAdverseEvent(obj) 
  {$ENDIF}
{$ENDIF FHIR_ADVERSEEVENT}
{$IFDEF FHIR_ALLERGYINTOLERANCE}
  {$IFDEF FHIR_ALLERGYINTOLERANCE}
   else if s = 'AllergyIntolerance' Then
    result := ParseAllergyIntolerance(obj) 
  {$ENDIF}
{$ENDIF FHIR_ALLERGYINTOLERANCE}
{$IFDEF FHIR_APPOINTMENT}
  {$IFDEF FHIR_APPOINTMENT}
   else if s = 'Appointment' Then
    result := ParseAppointment(obj) 
  {$ENDIF}
{$ENDIF FHIR_APPOINTMENT}
{$IFDEF FHIR_APPOINTMENTRESPONSE}
  {$IFDEF FHIR_APPOINTMENTRESPONSE}
   else if s = 'AppointmentResponse' Then
    result := ParseAppointmentResponse(obj) 
  {$ENDIF}
{$ENDIF FHIR_APPOINTMENTRESPONSE}
{$IFDEF FHIR_AUDITEVENT}
  {$IFDEF FHIR_AUDITEVENT}
   else if s = 'AuditEvent' Then
    result := ParseAuditEvent(obj) 
  {$ENDIF}
{$ENDIF FHIR_AUDITEVENT}
{$IFDEF FHIR_BASIC}
  {$IFDEF FHIR_BASIC}
   else if s = 'Basic' Then
    result := ParseBasic(obj) 
  {$ENDIF}
{$ENDIF FHIR_BASIC}
{$IFDEF FHIR_BINARY}
  {$IFDEF FHIR_BINARY}
   else if s = 'Binary' Then
    result := ParseBinary(obj) 
  {$ENDIF}
{$ENDIF FHIR_BINARY}
{$IFDEF FHIR_BIOLOGICALLYDERIVEDPRODUCT}
  {$IFDEF FHIR_BIOLOGICALLYDERIVEDPRODUCT}
   else if s = 'BiologicallyDerivedProduct' Then
    result := ParseBiologicallyDerivedProduct(obj) 
  {$ENDIF}
{$ENDIF FHIR_BIOLOGICALLYDERIVEDPRODUCT}
{$IFDEF FHIR_BODYSTRUCTURE}
  {$IFDEF FHIR_BODYSTRUCTURE}
   else if s = 'BodyStructure' Then
    result := ParseBodyStructure(obj) 
  {$ENDIF}
{$ENDIF FHIR_BODYSTRUCTURE}
{$IFDEF FHIR_BUNDLE}
  {$IFDEF FHIR_BUNDLE}
   else if s = 'Bundle' Then
    result := ParseBundle(obj) 
  {$ENDIF}
{$ENDIF FHIR_BUNDLE}
{$IFDEF FHIR_CAPABILITYSTATEMENT}
  {$IFDEF FHIR_CAPABILITYSTATEMENT}
   else if s = 'CapabilityStatement' Then
    result := ParseCapabilityStatement(obj) 
  {$ENDIF}
{$ENDIF FHIR_CAPABILITYSTATEMENT}
{$IFDEF FHIR_CAREPLAN}
  {$IFDEF FHIR_CAREPLAN}
   else if s = 'CarePlan' Then
    result := ParseCarePlan(obj) 
  {$ENDIF}
{$ENDIF FHIR_CAREPLAN}
{$IFDEF FHIR_CARETEAM}
  {$IFDEF FHIR_CARETEAM}
   else if s = 'CareTeam' Then
    result := ParseCareTeam(obj) 
  {$ENDIF}
{$ENDIF FHIR_CARETEAM}
{$IFDEF FHIR_CATALOGENTRY}
  {$IFDEF FHIR_CATALOGENTRY}
   else if s = 'CatalogEntry' Then
    result := ParseCatalogEntry(obj) 
  {$ENDIF}
{$ENDIF FHIR_CATALOGENTRY}
{$IFDEF FHIR_CHARGEITEM}
  {$IFDEF FHIR_CHARGEITEM}
   else if s = 'ChargeItem' Then
    result := ParseChargeItem(obj) 
  {$ENDIF}
{$ENDIF FHIR_CHARGEITEM}
{$IFDEF FHIR_CHARGEITEMDEFINITION}
  {$IFDEF FHIR_CHARGEITEMDEFINITION}
   else if s = 'ChargeItemDefinition' Then
    result := ParseChargeItemDefinition(obj) 
  {$ENDIF}
{$ENDIF FHIR_CHARGEITEMDEFINITION}
{$IFDEF FHIR_CLAIM}
  {$IFDEF FHIR_CLAIM}
   else if s = 'Claim' Then
    result := ParseClaim(obj) 
  {$ENDIF}
{$ENDIF FHIR_CLAIM}
{$IFDEF FHIR_CLAIMRESPONSE}
  {$IFDEF FHIR_CLAIMRESPONSE}
   else if s = 'ClaimResponse' Then
    result := ParseClaimResponse(obj) 
  {$ENDIF}
{$ENDIF FHIR_CLAIMRESPONSE}
{$IFDEF FHIR_CLINICALIMPRESSION}
  {$IFDEF FHIR_CLINICALIMPRESSION}
   else if s = 'ClinicalImpression' Then
    result := ParseClinicalImpression(obj) 
  {$ENDIF}
{$ENDIF FHIR_CLINICALIMPRESSION}
{$IFDEF FHIR_CODESYSTEM}
  {$IFDEF FHIR_CODESYSTEM}
   else if s = 'CodeSystem' Then
    result := ParseCodeSystem(obj) 
  {$ENDIF}
{$ENDIF FHIR_CODESYSTEM}
{$IFDEF FHIR_COMMUNICATION}
  {$IFDEF FHIR_COMMUNICATION}
   else if s = 'Communication' Then
    result := ParseCommunication(obj) 
  {$ENDIF}
{$ENDIF FHIR_COMMUNICATION}
{$IFDEF FHIR_COMMUNICATIONREQUEST}
  {$IFDEF FHIR_COMMUNICATIONREQUEST}
   else if s = 'CommunicationRequest' Then
    result := ParseCommunicationRequest(obj) 
  {$ENDIF}
{$ENDIF FHIR_COMMUNICATIONREQUEST}
{$IFDEF FHIR_COMPARTMENTDEFINITION}
  {$IFDEF FHIR_COMPARTMENTDEFINITION}
   else if s = 'CompartmentDefinition' Then
    result := ParseCompartmentDefinition(obj) 
  {$ENDIF}
{$ENDIF FHIR_COMPARTMENTDEFINITION}
{$IFDEF FHIR_COMPOSITION}
  {$IFDEF FHIR_COMPOSITION}
   else if s = 'Composition' Then
    result := ParseComposition(obj) 
  {$ENDIF}
{$ENDIF FHIR_COMPOSITION}
{$IFDEF FHIR_CONCEPTMAP}
  {$IFDEF FHIR_CONCEPTMAP}
   else if s = 'ConceptMap' Then
    result := ParseConceptMap(obj) 
  {$ENDIF}
{$ENDIF FHIR_CONCEPTMAP}
{$IFDEF FHIR_CONDITION}
  {$IFDEF FHIR_CONDITION}
   else if s = 'Condition' Then
    result := ParseCondition(obj) 
  {$ENDIF}
{$ENDIF FHIR_CONDITION}
{$IFDEF FHIR_CONSENT}
  {$IFDEF FHIR_CONSENT}
   else if s = 'Consent' Then
    result := ParseConsent(obj) 
  {$ENDIF}
{$ENDIF FHIR_CONSENT}
{$IFDEF FHIR_CONTRACT}
  {$IFDEF FHIR_CONTRACT}
   else if s = 'Contract' Then
    result := ParseContract(obj) 
  {$ENDIF}
{$ENDIF FHIR_CONTRACT}
{$IFDEF FHIR_COVERAGE}
  {$IFDEF FHIR_COVERAGE}
   else if s = 'Coverage' Then
    result := ParseCoverage(obj) 
  {$ENDIF}
{$ENDIF FHIR_COVERAGE}
{$IFDEF FHIR_COVERAGEELIGIBILITYREQUEST}
  {$IFDEF FHIR_COVERAGEELIGIBILITYREQUEST}
   else if s = 'CoverageEligibilityRequest' Then
    result := ParseCoverageEligibilityRequest(obj) 
  {$ENDIF}
{$ENDIF FHIR_COVERAGEELIGIBILITYREQUEST}
{$IFDEF FHIR_COVERAGEELIGIBILITYRESPONSE}
  {$IFDEF FHIR_COVERAGEELIGIBILITYRESPONSE}
   else if s = 'CoverageEligibilityResponse' Then
    result := ParseCoverageEligibilityResponse(obj) 
  {$ENDIF}
{$ENDIF FHIR_COVERAGEELIGIBILITYRESPONSE}
{$IFDEF FHIR_DETECTEDISSUE}
  {$IFDEF FHIR_DETECTEDISSUE}
   else if s = 'DetectedIssue' Then
    result := ParseDetectedIssue(obj) 
  {$ENDIF}
{$ENDIF FHIR_DETECTEDISSUE}
{$IFDEF FHIR_DEVICE}
  {$IFDEF FHIR_DEVICE}
   else if s = 'Device' Then
    result := ParseDevice(obj) 
  {$ENDIF}
{$ENDIF FHIR_DEVICE}
{$IFDEF FHIR_DEVICEDEFINITION}
  {$IFDEF FHIR_DEVICEDEFINITION}
   else if s = 'DeviceDefinition' Then
    result := ParseDeviceDefinition(obj) 
  {$ENDIF}
{$ENDIF FHIR_DEVICEDEFINITION}
{$IFDEF FHIR_DEVICEMETRIC}
  {$IFDEF FHIR_DEVICEMETRIC}
   else if s = 'DeviceMetric' Then
    result := ParseDeviceMetric(obj) 
  {$ENDIF}
{$ENDIF FHIR_DEVICEMETRIC}
{$IFDEF FHIR_DEVICEREQUEST}
  {$IFDEF FHIR_DEVICEREQUEST}
   else if s = 'DeviceRequest' Then
    result := ParseDeviceRequest(obj) 
  {$ENDIF}
{$ENDIF FHIR_DEVICEREQUEST}
{$IFDEF FHIR_DEVICEUSESTATEMENT}
  {$IFDEF FHIR_DEVICEUSESTATEMENT}
   else if s = 'DeviceUseStatement' Then
    result := ParseDeviceUseStatement(obj) 
  {$ENDIF}
{$ENDIF FHIR_DEVICEUSESTATEMENT}
{$IFDEF FHIR_DIAGNOSTICREPORT}
  {$IFDEF FHIR_DIAGNOSTICREPORT}
   else if s = 'DiagnosticReport' Then
    result := ParseDiagnosticReport(obj) 
  {$ENDIF}
{$ENDIF FHIR_DIAGNOSTICREPORT}
{$IFDEF FHIR_DOCUMENTMANIFEST}
  {$IFDEF FHIR_DOCUMENTMANIFEST}
   else if s = 'DocumentManifest' Then
    result := ParseDocumentManifest(obj) 
  {$ENDIF}
{$ENDIF FHIR_DOCUMENTMANIFEST}
{$IFDEF FHIR_DOCUMENTREFERENCE}
  {$IFDEF FHIR_DOCUMENTREFERENCE}
   else if s = 'DocumentReference' Then
    result := ParseDocumentReference(obj) 
  {$ENDIF}
{$ENDIF FHIR_DOCUMENTREFERENCE}
{$IFDEF FHIR_EFFECTEVIDENCESYNTHESIS}
  {$IFDEF FHIR_EFFECTEVIDENCESYNTHESIS}
   else if s = 'EffectEvidenceSynthesis' Then
    result := ParseEffectEvidenceSynthesis(obj) 
  {$ENDIF}
{$ENDIF FHIR_EFFECTEVIDENCESYNTHESIS}
{$IFDEF FHIR_ENCOUNTER}
  {$IFDEF FHIR_ENCOUNTER}
   else if s = 'Encounter' Then
    result := ParseEncounter(obj) 
  {$ENDIF}
{$ENDIF FHIR_ENCOUNTER}
{$IFDEF FHIR_ENDPOINT}
  {$IFDEF FHIR_ENDPOINT}
   else if s = 'Endpoint' Then
    result := ParseEndpoint(obj) 
  {$ENDIF}
{$ENDIF FHIR_ENDPOINT}
{$IFDEF FHIR_ENROLLMENTREQUEST}
  {$IFDEF FHIR_ENROLLMENTREQUEST}
   else if s = 'EnrollmentRequest' Then
    result := ParseEnrollmentRequest(obj) 
  {$ENDIF}
{$ENDIF FHIR_ENROLLMENTREQUEST}
{$IFDEF FHIR_ENROLLMENTRESPONSE}
  {$IFDEF FHIR_ENROLLMENTRESPONSE}
   else if s = 'EnrollmentResponse' Then
    result := ParseEnrollmentResponse(obj) 
  {$ENDIF}
{$ENDIF FHIR_ENROLLMENTRESPONSE}
{$IFDEF FHIR_EPISODEOFCARE}
  {$IFDEF FHIR_EPISODEOFCARE}
   else if s = 'EpisodeOfCare' Then
    result := ParseEpisodeOfCare(obj) 
  {$ENDIF}
{$ENDIF FHIR_EPISODEOFCARE}
{$IFDEF FHIR_EVENTDEFINITION}
  {$IFDEF FHIR_EVENTDEFINITION}
   else if s = 'EventDefinition' Then
    result := ParseEventDefinition(obj) 
  {$ENDIF}
{$ENDIF FHIR_EVENTDEFINITION}
{$IFDEF FHIR_EVIDENCE}
  {$IFDEF FHIR_EVIDENCE}
   else if s = 'Evidence' Then
    result := ParseEvidence(obj) 
  {$ENDIF}
{$ENDIF FHIR_EVIDENCE}
{$IFDEF FHIR_EVIDENCEVARIABLE}
  {$IFDEF FHIR_EVIDENCEVARIABLE}
   else if s = 'EvidenceVariable' Then
    result := ParseEvidenceVariable(obj) 
  {$ENDIF}
{$ENDIF FHIR_EVIDENCEVARIABLE}
{$IFDEF FHIR_EXAMPLESCENARIO}
  {$IFDEF FHIR_EXAMPLESCENARIO}
   else if s = 'ExampleScenario' Then
    result := ParseExampleScenario(obj) 
  {$ENDIF}
{$ENDIF FHIR_EXAMPLESCENARIO}
{$IFDEF FHIR_EXPLANATIONOFBENEFIT}
  {$IFDEF FHIR_EXPLANATIONOFBENEFIT}
   else if s = 'ExplanationOfBenefit' Then
    result := ParseExplanationOfBenefit(obj) 
  {$ENDIF}
{$ENDIF FHIR_EXPLANATIONOFBENEFIT}
{$IFDEF FHIR_FAMILYMEMBERHISTORY}
  {$IFDEF FHIR_FAMILYMEMBERHISTORY}
   else if s = 'FamilyMemberHistory' Then
    result := ParseFamilyMemberHistory(obj) 
  {$ENDIF}
{$ENDIF FHIR_FAMILYMEMBERHISTORY}
{$IFDEF FHIR_FLAG}
  {$IFDEF FHIR_FLAG}
   else if s = 'Flag' Then
    result := ParseFlag(obj) 
  {$ENDIF}
{$ENDIF FHIR_FLAG}
{$IFDEF FHIR_GOAL}
  {$IFDEF FHIR_GOAL}
   else if s = 'Goal' Then
    result := ParseGoal(obj) 
  {$ENDIF}
{$ENDIF FHIR_GOAL}
{$IFDEF FHIR_GRAPHDEFINITION}
  {$IFDEF FHIR_GRAPHDEFINITION}
   else if s = 'GraphDefinition' Then
    result := ParseGraphDefinition(obj) 
  {$ENDIF}
{$ENDIF FHIR_GRAPHDEFINITION}
{$IFDEF FHIR_GROUP}
  {$IFDEF FHIR_GROUP}
   else if s = 'Group' Then
    result := ParseGroup(obj) 
  {$ENDIF}
{$ENDIF FHIR_GROUP}
{$IFDEF FHIR_GUIDANCERESPONSE}
  {$IFDEF FHIR_GUIDANCERESPONSE}
   else if s = 'GuidanceResponse' Then
    result := ParseGuidanceResponse(obj) 
  {$ENDIF}
{$ENDIF FHIR_GUIDANCERESPONSE}
{$IFDEF FHIR_HEALTHCARESERVICE}
  {$IFDEF FHIR_HEALTHCARESERVICE}
   else if s = 'HealthcareService' Then
    result := ParseHealthcareService(obj) 
  {$ENDIF}
{$ENDIF FHIR_HEALTHCARESERVICE}
{$IFDEF FHIR_IMAGINGSTUDY}
  {$IFDEF FHIR_IMAGINGSTUDY}
   else if s = 'ImagingStudy' Then
    result := ParseImagingStudy(obj) 
  {$ENDIF}
{$ENDIF FHIR_IMAGINGSTUDY}
{$IFDEF FHIR_IMMUNIZATION}
  {$IFDEF FHIR_IMMUNIZATION}
   else if s = 'Immunization' Then
    result := ParseImmunization(obj) 
  {$ENDIF}
{$ENDIF FHIR_IMMUNIZATION}
{$IFDEF FHIR_IMMUNIZATIONEVALUATION}
  {$IFDEF FHIR_IMMUNIZATIONEVALUATION}
   else if s = 'ImmunizationEvaluation' Then
    result := ParseImmunizationEvaluation(obj) 
  {$ENDIF}
{$ENDIF FHIR_IMMUNIZATIONEVALUATION}
{$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
  {$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
   else if s = 'ImmunizationRecommendation' Then
    result := ParseImmunizationRecommendation(obj) 
  {$ENDIF}
{$ENDIF FHIR_IMMUNIZATIONRECOMMENDATION}
{$IFDEF FHIR_IMPLEMENTATIONGUIDE}
  {$IFDEF FHIR_IMPLEMENTATIONGUIDE}
   else if s = 'ImplementationGuide' Then
    result := ParseImplementationGuide(obj) 
  {$ENDIF}
{$ENDIF FHIR_IMPLEMENTATIONGUIDE}
{$IFDEF FHIR_INSURANCEPLAN}
  {$IFDEF FHIR_INSURANCEPLAN}
   else if s = 'InsurancePlan' Then
    result := ParseInsurancePlan(obj) 
  {$ENDIF}
{$ENDIF FHIR_INSURANCEPLAN}
{$IFDEF FHIR_INVOICE}
  {$IFDEF FHIR_INVOICE}
   else if s = 'Invoice' Then
    result := ParseInvoice(obj) 
  {$ENDIF}
{$ENDIF FHIR_INVOICE}
{$IFDEF FHIR_LIBRARY}
  {$IFDEF FHIR_LIBRARY}
   else if s = 'Library' Then
    result := ParseLibrary(obj) 
  {$ENDIF}
{$ENDIF FHIR_LIBRARY}
{$IFDEF FHIR_LINKAGE}
  {$IFDEF FHIR_LINKAGE}
   else if s = 'Linkage' Then
    result := ParseLinkage(obj) 
  {$ENDIF}
{$ENDIF FHIR_LINKAGE}
{$IFDEF FHIR_LIST}
  {$IFDEF FHIR_LIST}
   else if s = 'List' Then
    result := ParseList(obj) 
  {$ENDIF}
{$ENDIF FHIR_LIST}
{$IFDEF FHIR_LOCATION}
  {$IFDEF FHIR_LOCATION}
   else if s = 'Location' Then
    result := ParseLocation(obj) 
  {$ENDIF}
{$ENDIF FHIR_LOCATION}
{$IFDEF FHIR_MEASURE}
  {$IFDEF FHIR_MEASURE}
   else if s = 'Measure' Then
    result := ParseMeasure(obj) 
  {$ENDIF}
{$ENDIF FHIR_MEASURE}
{$IFDEF FHIR_MEASUREREPORT}
  {$IFDEF FHIR_MEASUREREPORT}
   else if s = 'MeasureReport' Then
    result := ParseMeasureReport(obj) 
  {$ENDIF}
{$ENDIF FHIR_MEASUREREPORT}
{$IFDEF FHIR_MEDIA}
  {$IFDEF FHIR_MEDIA}
   else if s = 'Media' Then
    result := ParseMedia(obj) 
  {$ENDIF}
{$ENDIF FHIR_MEDIA}
{$IFDEF FHIR_MEDICATION}
  {$IFDEF FHIR_MEDICATION}
   else if s = 'Medication' Then
    result := ParseMedication(obj) 
  {$ENDIF}
{$ENDIF FHIR_MEDICATION}
{$IFDEF FHIR_MEDICATIONADMINISTRATION}
  {$IFDEF FHIR_MEDICATIONADMINISTRATION}
   else if s = 'MedicationAdministration' Then
    result := ParseMedicationAdministration(obj) 
  {$ENDIF}
{$ENDIF FHIR_MEDICATIONADMINISTRATION}
{$IFDEF FHIR_MEDICATIONDISPENSE}
  {$IFDEF FHIR_MEDICATIONDISPENSE}
   else if s = 'MedicationDispense' Then
    result := ParseMedicationDispense(obj) 
  {$ENDIF}
{$ENDIF FHIR_MEDICATIONDISPENSE}
{$IFDEF FHIR_MEDICATIONKNOWLEDGE}
  {$IFDEF FHIR_MEDICATIONKNOWLEDGE}
   else if s = 'MedicationKnowledge' Then
    result := ParseMedicationKnowledge(obj) 
  {$ENDIF}
{$ENDIF FHIR_MEDICATIONKNOWLEDGE}
{$IFDEF FHIR_MEDICATIONREQUEST}
  {$IFDEF FHIR_MEDICATIONREQUEST}
   else if s = 'MedicationRequest' Then
    result := ParseMedicationRequest(obj) 
  {$ENDIF}
{$ENDIF FHIR_MEDICATIONREQUEST}
{$IFDEF FHIR_MEDICATIONSTATEMENT}
  {$IFDEF FHIR_MEDICATIONSTATEMENT}
   else if s = 'MedicationStatement' Then
    result := ParseMedicationStatement(obj) 
  {$ENDIF}
{$ENDIF FHIR_MEDICATIONSTATEMENT}
{$IFDEF FHIR_MEDICINALPRODUCT}
  {$IFDEF FHIR_MEDICINALPRODUCT}
   else if s = 'MedicinalProduct' Then
    result := ParseMedicinalProduct(obj) 
  {$ENDIF}
{$ENDIF FHIR_MEDICINALPRODUCT}
{$IFDEF FHIR_MEDICINALPRODUCTAUTHORIZATION}
  {$IFDEF FHIR_MEDICINALPRODUCTAUTHORIZATION}
   else if s = 'MedicinalProductAuthorization' Then
    result := ParseMedicinalProductAuthorization(obj) 
  {$ENDIF}
{$ENDIF FHIR_MEDICINALPRODUCTAUTHORIZATION}
{$IFDEF FHIR_MEDICINALPRODUCTCONTRAINDICATION}
  {$IFDEF FHIR_MEDICINALPRODUCTCONTRAINDICATION}
   else if s = 'MedicinalProductContraindication' Then
    result := ParseMedicinalProductContraindication(obj) 
  {$ENDIF}
{$ENDIF FHIR_MEDICINALPRODUCTCONTRAINDICATION}
{$IFDEF FHIR_MEDICINALPRODUCTINDICATION}
  {$IFDEF FHIR_MEDICINALPRODUCTINDICATION}
   else if s = 'MedicinalProductIndication' Then
    result := ParseMedicinalProductIndication(obj) 
  {$ENDIF}
{$ENDIF FHIR_MEDICINALPRODUCTINDICATION}
{$IFDEF FHIR_MEDICINALPRODUCTINGREDIENT}
  {$IFDEF FHIR_MEDICINALPRODUCTINGREDIENT}
   else if s = 'MedicinalProductIngredient' Then
    result := ParseMedicinalProductIngredient(obj) 
  {$ENDIF}
{$ENDIF FHIR_MEDICINALPRODUCTINGREDIENT}
{$IFDEF FHIR_MEDICINALPRODUCTINTERACTION}
  {$IFDEF FHIR_MEDICINALPRODUCTINTERACTION}
   else if s = 'MedicinalProductInteraction' Then
    result := ParseMedicinalProductInteraction(obj) 
  {$ENDIF}
{$ENDIF FHIR_MEDICINALPRODUCTINTERACTION}
{$IFDEF FHIR_MEDICINALPRODUCTMANUFACTURED}
  {$IFDEF FHIR_MEDICINALPRODUCTMANUFACTURED}
   else if s = 'MedicinalProductManufactured' Then
    result := ParseMedicinalProductManufactured(obj) 
  {$ENDIF}
{$ENDIF FHIR_MEDICINALPRODUCTMANUFACTURED}
{$IFDEF FHIR_MEDICINALPRODUCTPACKAGED}
  {$IFDEF FHIR_MEDICINALPRODUCTPACKAGED}
   else if s = 'MedicinalProductPackaged' Then
    result := ParseMedicinalProductPackaged(obj) 
  {$ENDIF}
{$ENDIF FHIR_MEDICINALPRODUCTPACKAGED}
{$IFDEF FHIR_MEDICINALPRODUCTPHARMACEUTICAL}
  {$IFDEF FHIR_MEDICINALPRODUCTPHARMACEUTICAL}
   else if s = 'MedicinalProductPharmaceutical' Then
    result := ParseMedicinalProductPharmaceutical(obj) 
  {$ENDIF}
{$ENDIF FHIR_MEDICINALPRODUCTPHARMACEUTICAL}
{$IFDEF FHIR_MEDICINALPRODUCTUNDESIRABLEEFFECT}
  {$IFDEF FHIR_MEDICINALPRODUCTUNDESIRABLEEFFECT}
   else if s = 'MedicinalProductUndesirableEffect' Then
    result := ParseMedicinalProductUndesirableEffect(obj) 
  {$ENDIF}
{$ENDIF FHIR_MEDICINALPRODUCTUNDESIRABLEEFFECT}
{$IFDEF FHIR_MESSAGEDEFINITION}
  {$IFDEF FHIR_MESSAGEDEFINITION}
   else if s = 'MessageDefinition' Then
    result := ParseMessageDefinition(obj) 
  {$ENDIF}
{$ENDIF FHIR_MESSAGEDEFINITION}
{$IFDEF FHIR_MESSAGEHEADER}
  {$IFDEF FHIR_MESSAGEHEADER}
   else if s = 'MessageHeader' Then
    result := ParseMessageHeader(obj) 
  {$ENDIF}
{$ENDIF FHIR_MESSAGEHEADER}
{$IFDEF FHIR_MOLECULARSEQUENCE}
  {$IFDEF FHIR_MOLECULARSEQUENCE}
   else if s = 'MolecularSequence' Then
    result := ParseMolecularSequence(obj) 
  {$ENDIF}
{$ENDIF FHIR_MOLECULARSEQUENCE}
{$IFDEF FHIR_NAMINGSYSTEM}
  {$IFDEF FHIR_NAMINGSYSTEM}
   else if s = 'NamingSystem' Then
    result := ParseNamingSystem(obj) 
  {$ENDIF}
{$ENDIF FHIR_NAMINGSYSTEM}
{$IFDEF FHIR_NUTRITIONORDER}
  {$IFDEF FHIR_NUTRITIONORDER}
   else if s = 'NutritionOrder' Then
    result := ParseNutritionOrder(obj) 
  {$ENDIF}
{$ENDIF FHIR_NUTRITIONORDER}
{$IFDEF FHIR_OBSERVATION}
  {$IFDEF FHIR_OBSERVATION}
   else if s = 'Observation' Then
    result := ParseObservation(obj) 
  {$ENDIF}
{$ENDIF FHIR_OBSERVATION}
{$IFDEF FHIR_OBSERVATIONDEFINITION}
  {$IFDEF FHIR_OBSERVATIONDEFINITION}
   else if s = 'ObservationDefinition' Then
    result := ParseObservationDefinition(obj) 
  {$ENDIF}
{$ENDIF FHIR_OBSERVATIONDEFINITION}
{$IFDEF FHIR_OPERATIONDEFINITION}
  {$IFDEF FHIR_OPERATIONDEFINITION}
   else if s = 'OperationDefinition' Then
    result := ParseOperationDefinition(obj) 
  {$ENDIF}
{$ENDIF FHIR_OPERATIONDEFINITION}
{$IFDEF FHIR_OPERATIONOUTCOME}
  {$IFDEF FHIR_OPERATIONOUTCOME}
   else if s = 'OperationOutcome' Then
    result := ParseOperationOutcome(obj) 
  {$ENDIF}
{$ENDIF FHIR_OPERATIONOUTCOME}
{$IFDEF FHIR_ORGANIZATION}
  {$IFDEF FHIR_ORGANIZATION}
   else if s = 'Organization' Then
    result := ParseOrganization(obj) 
  {$ENDIF}
{$ENDIF FHIR_ORGANIZATION}
{$IFDEF FHIR_ORGANIZATIONAFFILIATION}
  {$IFDEF FHIR_ORGANIZATIONAFFILIATION}
   else if s = 'OrganizationAffiliation' Then
    result := ParseOrganizationAffiliation(obj) 
  {$ENDIF}
{$ENDIF FHIR_ORGANIZATIONAFFILIATION}
{$IFDEF FHIR_PATIENT}
  {$IFDEF FHIR_PATIENT}
   else if s = 'Patient' Then
    result := ParsePatient(obj) 
  {$ENDIF}
{$ENDIF FHIR_PATIENT}
{$IFDEF FHIR_PAYMENTNOTICE}
  {$IFDEF FHIR_PAYMENTNOTICE}
   else if s = 'PaymentNotice' Then
    result := ParsePaymentNotice(obj) 
  {$ENDIF}
{$ENDIF FHIR_PAYMENTNOTICE}
{$IFDEF FHIR_PAYMENTRECONCILIATION}
  {$IFDEF FHIR_PAYMENTRECONCILIATION}
   else if s = 'PaymentReconciliation' Then
    result := ParsePaymentReconciliation(obj) 
  {$ENDIF}
{$ENDIF FHIR_PAYMENTRECONCILIATION}
{$IFDEF FHIR_PERSON}
  {$IFDEF FHIR_PERSON}
   else if s = 'Person' Then
    result := ParsePerson(obj) 
  {$ENDIF}
{$ENDIF FHIR_PERSON}
{$IFDEF FHIR_PLANDEFINITION}
  {$IFDEF FHIR_PLANDEFINITION}
   else if s = 'PlanDefinition' Then
    result := ParsePlanDefinition(obj) 
  {$ENDIF}
{$ENDIF FHIR_PLANDEFINITION}
{$IFDEF FHIR_PRACTITIONER}
  {$IFDEF FHIR_PRACTITIONER}
   else if s = 'Practitioner' Then
    result := ParsePractitioner(obj) 
  {$ENDIF}
{$ENDIF FHIR_PRACTITIONER}
{$IFDEF FHIR_PRACTITIONERROLE}
  {$IFDEF FHIR_PRACTITIONERROLE}
   else if s = 'PractitionerRole' Then
    result := ParsePractitionerRole(obj) 
  {$ENDIF}
{$ENDIF FHIR_PRACTITIONERROLE}
{$IFDEF FHIR_PROCEDURE}
  {$IFDEF FHIR_PROCEDURE}
   else if s = 'Procedure' Then
    result := ParseProcedure(obj) 
  {$ENDIF}
{$ENDIF FHIR_PROCEDURE}
{$IFDEF FHIR_PROVENANCE}
  {$IFDEF FHIR_PROVENANCE}
   else if s = 'Provenance' Then
    result := ParseProvenance(obj) 
  {$ENDIF}
{$ENDIF FHIR_PROVENANCE}
{$IFDEF FHIR_QUESTIONNAIRE}
  {$IFDEF FHIR_QUESTIONNAIRE}
   else if s = 'Questionnaire' Then
    result := ParseQuestionnaire(obj) 
  {$ENDIF}
{$ENDIF FHIR_QUESTIONNAIRE}
{$IFDEF FHIR_QUESTIONNAIRERESPONSE}
  {$IFDEF FHIR_QUESTIONNAIRERESPONSE}
   else if s = 'QuestionnaireResponse' Then
    result := ParseQuestionnaireResponse(obj) 
  {$ENDIF}
{$ENDIF FHIR_QUESTIONNAIRERESPONSE}
{$IFDEF FHIR_RELATEDPERSON}
  {$IFDEF FHIR_RELATEDPERSON}
   else if s = 'RelatedPerson' Then
    result := ParseRelatedPerson(obj) 
  {$ENDIF}
{$ENDIF FHIR_RELATEDPERSON}
{$IFDEF FHIR_REQUESTGROUP}
  {$IFDEF FHIR_REQUESTGROUP}
   else if s = 'RequestGroup' Then
    result := ParseRequestGroup(obj) 
  {$ENDIF}
{$ENDIF FHIR_REQUESTGROUP}
{$IFDEF FHIR_RESEARCHDEFINITION}
  {$IFDEF FHIR_RESEARCHDEFINITION}
   else if s = 'ResearchDefinition' Then
    result := ParseResearchDefinition(obj) 
  {$ENDIF}
{$ENDIF FHIR_RESEARCHDEFINITION}
{$IFDEF FHIR_RESEARCHELEMENTDEFINITION}
  {$IFDEF FHIR_RESEARCHELEMENTDEFINITION}
   else if s = 'ResearchElementDefinition' Then
    result := ParseResearchElementDefinition(obj) 
  {$ENDIF}
{$ENDIF FHIR_RESEARCHELEMENTDEFINITION}
{$IFDEF FHIR_RESEARCHSTUDY}
  {$IFDEF FHIR_RESEARCHSTUDY}
   else if s = 'ResearchStudy' Then
    result := ParseResearchStudy(obj) 
  {$ENDIF}
{$ENDIF FHIR_RESEARCHSTUDY}
{$IFDEF FHIR_RESEARCHSUBJECT}
  {$IFDEF FHIR_RESEARCHSUBJECT}
   else if s = 'ResearchSubject' Then
    result := ParseResearchSubject(obj) 
  {$ENDIF}
{$ENDIF FHIR_RESEARCHSUBJECT}
{$IFDEF FHIR_RISKASSESSMENT}
  {$IFDEF FHIR_RISKASSESSMENT}
   else if s = 'RiskAssessment' Then
    result := ParseRiskAssessment(obj) 
  {$ENDIF}
{$ENDIF FHIR_RISKASSESSMENT}
{$IFDEF FHIR_RISKEVIDENCESYNTHESIS}
  {$IFDEF FHIR_RISKEVIDENCESYNTHESIS}
   else if s = 'RiskEvidenceSynthesis' Then
    result := ParseRiskEvidenceSynthesis(obj) 
  {$ENDIF}
{$ENDIF FHIR_RISKEVIDENCESYNTHESIS}
{$IFDEF FHIR_SCHEDULE}
  {$IFDEF FHIR_SCHEDULE}
   else if s = 'Schedule' Then
    result := ParseSchedule(obj) 
  {$ENDIF}
{$ENDIF FHIR_SCHEDULE}
{$IFDEF FHIR_SEARCHPARAMETER}
  {$IFDEF FHIR_SEARCHPARAMETER}
   else if s = 'SearchParameter' Then
    result := ParseSearchParameter(obj) 
  {$ENDIF}
{$ENDIF FHIR_SEARCHPARAMETER}
{$IFDEF FHIR_SERVICEREQUEST}
  {$IFDEF FHIR_SERVICEREQUEST}
   else if s = 'ServiceRequest' Then
    result := ParseServiceRequest(obj) 
  {$ENDIF}
{$ENDIF FHIR_SERVICEREQUEST}
{$IFDEF FHIR_SLOT}
  {$IFDEF FHIR_SLOT}
   else if s = 'Slot' Then
    result := ParseSlot(obj) 
  {$ENDIF}
{$ENDIF FHIR_SLOT}
{$IFDEF FHIR_SPECIMEN}
  {$IFDEF FHIR_SPECIMEN}
   else if s = 'Specimen' Then
    result := ParseSpecimen(obj) 
  {$ENDIF}
{$ENDIF FHIR_SPECIMEN}
{$IFDEF FHIR_SPECIMENDEFINITION}
  {$IFDEF FHIR_SPECIMENDEFINITION}
   else if s = 'SpecimenDefinition' Then
    result := ParseSpecimenDefinition(obj) 
  {$ENDIF}
{$ENDIF FHIR_SPECIMENDEFINITION}
{$IFDEF FHIR_STRUCTUREDEFINITION}
  {$IFDEF FHIR_STRUCTUREDEFINITION}
   else if s = 'StructureDefinition' Then
    result := ParseStructureDefinition(obj) 
  {$ENDIF}
{$ENDIF FHIR_STRUCTUREDEFINITION}
{$IFDEF FHIR_STRUCTUREMAP}
  {$IFDEF FHIR_STRUCTUREMAP}
   else if s = 'StructureMap' Then
    result := ParseStructureMap(obj) 
  {$ENDIF}
{$ENDIF FHIR_STRUCTUREMAP}
{$IFDEF FHIR_SUBSCRIPTION}
  {$IFDEF FHIR_SUBSCRIPTION}
   else if s = 'Subscription' Then
    result := ParseSubscription(obj) 
  {$ENDIF}
{$ENDIF FHIR_SUBSCRIPTION}
{$IFDEF FHIR_SUBSTANCE}
  {$IFDEF FHIR_SUBSTANCE}
   else if s = 'Substance' Then
    result := ParseSubstance(obj) 
  {$ENDIF}
{$ENDIF FHIR_SUBSTANCE}
{$IFDEF FHIR_SUBSTANCENUCLEICACID}
  {$IFDEF FHIR_SUBSTANCENUCLEICACID}
   else if s = 'SubstanceNucleicAcid' Then
    result := ParseSubstanceNucleicAcid(obj) 
  {$ENDIF}
{$ENDIF FHIR_SUBSTANCENUCLEICACID}
{$IFDEF FHIR_SUBSTANCEPOLYMER}
  {$IFDEF FHIR_SUBSTANCEPOLYMER}
   else if s = 'SubstancePolymer' Then
    result := ParseSubstancePolymer(obj) 
  {$ENDIF}
{$ENDIF FHIR_SUBSTANCEPOLYMER}
{$IFDEF FHIR_SUBSTANCEPROTEIN}
  {$IFDEF FHIR_SUBSTANCEPROTEIN}
   else if s = 'SubstanceProtein' Then
    result := ParseSubstanceProtein(obj) 
  {$ENDIF}
{$ENDIF FHIR_SUBSTANCEPROTEIN}
{$IFDEF FHIR_SUBSTANCEREFERENCEINFORMATION}
  {$IFDEF FHIR_SUBSTANCEREFERENCEINFORMATION}
   else if s = 'SubstanceReferenceInformation' Then
    result := ParseSubstanceReferenceInformation(obj) 
  {$ENDIF}
{$ENDIF FHIR_SUBSTANCEREFERENCEINFORMATION}
{$IFDEF FHIR_SUBSTANCESOURCEMATERIAL}
  {$IFDEF FHIR_SUBSTANCESOURCEMATERIAL}
   else if s = 'SubstanceSourceMaterial' Then
    result := ParseSubstanceSourceMaterial(obj) 
  {$ENDIF}
{$ENDIF FHIR_SUBSTANCESOURCEMATERIAL}
{$IFDEF FHIR_SUBSTANCESPECIFICATION}
  {$IFDEF FHIR_SUBSTANCESPECIFICATION}
   else if s = 'SubstanceSpecification' Then
    result := ParseSubstanceSpecification(obj) 
  {$ENDIF}
{$ENDIF FHIR_SUBSTANCESPECIFICATION}
{$IFDEF FHIR_SUPPLYDELIVERY}
  {$IFDEF FHIR_SUPPLYDELIVERY}
   else if s = 'SupplyDelivery' Then
    result := ParseSupplyDelivery(obj) 
  {$ENDIF}
{$ENDIF FHIR_SUPPLYDELIVERY}
{$IFDEF FHIR_SUPPLYREQUEST}
  {$IFDEF FHIR_SUPPLYREQUEST}
   else if s = 'SupplyRequest' Then
    result := ParseSupplyRequest(obj) 
  {$ENDIF}
{$ENDIF FHIR_SUPPLYREQUEST}
{$IFDEF FHIR_TASK}
  {$IFDEF FHIR_TASK}
   else if s = 'Task' Then
    result := ParseTask(obj) 
  {$ENDIF}
{$ENDIF FHIR_TASK}
{$IFDEF FHIR_TERMINOLOGYCAPABILITIES}
  {$IFDEF FHIR_TERMINOLOGYCAPABILITIES}
   else if s = 'TerminologyCapabilities' Then
    result := ParseTerminologyCapabilities(obj) 
  {$ENDIF}
{$ENDIF FHIR_TERMINOLOGYCAPABILITIES}
{$IFDEF FHIR_TESTREPORT}
  {$IFDEF FHIR_TESTREPORT}
   else if s = 'TestReport' Then
    result := ParseTestReport(obj) 
  {$ENDIF}
{$ENDIF FHIR_TESTREPORT}
{$IFDEF FHIR_TESTSCRIPT}
  {$IFDEF FHIR_TESTSCRIPT}
   else if s = 'TestScript' Then
    result := ParseTestScript(obj) 
  {$ENDIF}
{$ENDIF FHIR_TESTSCRIPT}
{$IFDEF FHIR_VALUESET}
  {$IFDEF FHIR_VALUESET}
   else if s = 'ValueSet' Then
    result := ParseValueSet(obj) 
  {$ENDIF}
{$ENDIF FHIR_VALUESET}
{$IFDEF FHIR_VERIFICATIONRESULT}
  {$IFDEF FHIR_VERIFICATIONRESULT}
   else if s = 'VerificationResult' Then
    result := ParseVerificationResult(obj) 
  {$ENDIF}
{$ENDIF FHIR_VERIFICATIONRESULT}
{$IFDEF FHIR_VISIONPRESCRIPTION}
  {$IFDEF FHIR_VISIONPRESCRIPTION}
   else if s = 'VisionPrescription' Then
    result := ParseVisionPrescription(obj) 
  {$ENDIF}
{$ENDIF FHIR_VISIONPRESCRIPTION}
  else
    raise ERdfException.create('error: the element '+s+' is not a valid resource name');
end;


end.

