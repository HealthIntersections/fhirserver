unit FHIR.R4.Json;

{$I fhir.r4.inc}

{
  Copyright (c) 2011+, HL7 and Health Intersections Pty Ltd (http://www.healthintersections.com.au)
  All rights reserved.
  
  Redistribution and use in source and binary forms, with or without modification, 
  are permitted provided that the following conditions are met:
  
   * Redistributions of source code must retain the above copyright notice, this 
     list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above copyright notice, 
     this list of conditions and the following disclaimer in the documentation 
     and/or other materials provided with the distribution.
   * Neither the name of HL7 nor the names of its contributors may be used to 
     endorse or promote products derived from this software without specific 
     prior written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
  POSSIBILITY OF SUCH DAMAGE.
  
}

interface

// FHIR v4.0.0 generated 2018-12-15T16:22:09+11:00

uses
  SysUtils, Classes, 
  FHIR.Support.Base, FHIR.Support.Utilities, FHIR.Support.Collections, FHIR.Support.Json, 
  FHIR.Base.Parser, FHIR.Base.Objects, 
  FHIR.R4.ParserBase, FHIR.R4.Resources, FHIR.R4.Constants, FHIR.R4.Types;

Type

  TFHIRJsonParser = class (TFHIRJsonParserBase4)
  protected
    function ParseElement(jsn : TJsonObject) : TFhirElement; overload;
    procedure ParseElement(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}

    procedure ParseElementProperties(jsn : TJsonObject; element : TFhirElement);
    procedure ParseBackboneElementProperties(jsn : TJsonObject; element : TFhirBackboneElement); overload;
    procedure ParseBackboneElementProperties(jsn : TJsonObject; element : TFhirBackboneType); overload;
    function ParseBackboneElement(jsn : TJsonObject) : TFhirBackboneElement; overload;
    procedure ParseBackboneElement(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseBackboneType(jsn : TJsonObject) : TFhirBackboneType; overload;
    procedure ParseBackboneTypeProperties(jsn : TJsonObject; result : TFhirBackboneType); overload;
    procedure ParseBackboneType(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}

    procedure ParseEnum(path :String; value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList; Const aNames, aSystems : Array Of String); overload;
    function ParseEnum(path : String; value : TJsonNode; jsn : TJsonObject; Const aNames, aSystems : Array Of String) : TFHIREnum; overload;
    procedure ParseDate(value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseDate(value : TJsonNode; jsn : TJsonObject) : TFHIRDate; overload;
    procedure ParseDateTime(value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseDateTime(value : TJsonNode; jsn : TJsonObject) : TFHIRDateTime; overload;
    procedure ParseString(value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseString(value : TJsonNode; jsn : TJsonObject) : TFHIRString; overload;
    procedure ParseInteger(value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseInteger(value : TJsonNode; jsn : TJsonObject) : TFHIRInteger; overload;
    procedure ParseUri(value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseUri(value : TJsonNode; jsn : TJsonObject) : TFHIRUri; overload;
    procedure ParseInstant(value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseInstant(value : TJsonNode; jsn : TJsonObject) : TFHIRInstant; overload;
    procedure ParseXhtml(value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseXhtml(value : TJsonNode; jsn : TJsonObject) : TFHIRXhtml; overload;
    procedure ParseBoolean(value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseBoolean(value : TJsonNode; jsn : TJsonObject) : TFHIRBoolean; overload;
    procedure ParseBase64Binary(value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseBase64Binary(value : TJsonNode; jsn : TJsonObject) : TFHIRBase64Binary; overload;
    procedure ParseTime(value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseTime(value : TJsonNode; jsn : TJsonObject) : TFHIRTime; overload;
    procedure ParseDecimal(value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseDecimal(value : TJsonNode; jsn : TJsonObject) : TFHIRDecimal; overload;
    procedure ParseCode(value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseCode(value : TJsonNode; jsn : TJsonObject) : TFHIRCode; overload;
    procedure ParseCanonical(value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseCanonical(value : TJsonNode; jsn : TJsonObject) : TFHIRCanonical; overload;
    procedure ParseOid(value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseOid(value : TJsonNode; jsn : TJsonObject) : TFHIROid; overload;
    procedure ParseUuid(value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseUuid(value : TJsonNode; jsn : TJsonObject) : TFHIRUuid; overload;
    procedure ParseUrl(value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseUrl(value : TJsonNode; jsn : TJsonObject) : TFHIRUrl; overload;
    procedure ParseMarkdown(value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseMarkdown(value : TJsonNode; jsn : TJsonObject) : TFHIRMarkdown; overload;
    procedure ParseUnsignedInt(value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseUnsignedInt(value : TJsonNode; jsn : TJsonObject) : TFHIRUnsignedInt; overload;
    procedure ParseId(value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseId(value : TJsonNode; jsn : TJsonObject) : TFHIRId; overload;
    procedure ParsePositiveInt(value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParsePositiveInt(value : TJsonNode; jsn : TJsonObject) : TFHIRPositiveInt; overload;

    procedure ParseResourceProperties(jsn : TJsonObject; resource : TFhirResource);
    procedure ParseDomainResourceProperties(jsn : TJsonObject; resource : TFhirDomainResource);
{$IFDEF FHIR_PARAMETERS}
    function ParseParametersParameter(jsn : TJsonObject) : TFhirParametersParameter; overload; {b\}
    procedure ParseParametersParameterProperties(jsn : TJsonObject; result : TFhirParametersParameter); overload; {b\}
    procedure ParseParametersParameter(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseParameters(jsn : TJsonObject) : TFhirParameters; overload;
    procedure ParseParametersProperties(jsn : TJsonObject; result : TFhirParameters); overload;
    procedure ParseParameters(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_PARAMETERS}

    function ParseExtension(jsn : TJsonObject) : TFhirExtension; overload;
    procedure ParseExtensionProperties(jsn : TJsonObject; result : TFhirExtension); overload;
    procedure ParseExtension(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseNarrative(jsn : TJsonObject) : TFhirNarrative; overload;
    procedure ParseNarrativeProperties(jsn : TJsonObject; result : TFhirNarrative); overload;
    procedure ParseNarrative(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseContributor(jsn : TJsonObject) : TFhirContributor; overload;
    procedure ParseContributorProperties(jsn : TJsonObject; result : TFhirContributor); overload;
    procedure ParseContributor(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseAttachment(jsn : TJsonObject) : TFhirAttachment; overload;
    procedure ParseAttachmentProperties(jsn : TJsonObject; result : TFhirAttachment); overload;
    procedure ParseAttachment(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDataRequirementCodeFilter(jsn : TJsonObject) : TFhirDataRequirementCodeFilter; overload; {b\}
    procedure ParseDataRequirementCodeFilterProperties(jsn : TJsonObject; result : TFhirDataRequirementCodeFilter); overload; {b\}
    procedure ParseDataRequirementCodeFilter(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDataRequirementDateFilter(jsn : TJsonObject) : TFhirDataRequirementDateFilter; overload; {b\}
    procedure ParseDataRequirementDateFilterProperties(jsn : TJsonObject; result : TFhirDataRequirementDateFilter); overload; {b\}
    procedure ParseDataRequirementDateFilter(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDataRequirementSort(jsn : TJsonObject) : TFhirDataRequirementSort; overload; {b\}
    procedure ParseDataRequirementSortProperties(jsn : TJsonObject; result : TFhirDataRequirementSort); overload; {b\}
    procedure ParseDataRequirementSort(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDataRequirement(jsn : TJsonObject) : TFhirDataRequirement; overload;
    procedure ParseDataRequirementProperties(jsn : TJsonObject; result : TFhirDataRequirement); overload;
    procedure ParseDataRequirement(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDosageDoseAndRate(jsn : TJsonObject) : TFhirDosageDoseAndRate; overload; {b\}
    procedure ParseDosageDoseAndRateProperties(jsn : TJsonObject; result : TFhirDosageDoseAndRate); overload; {b\}
    procedure ParseDosageDoseAndRate(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDosage(jsn : TJsonObject) : TFhirDosage; overload;
    procedure ParseDosageProperties(jsn : TJsonObject; result : TFhirDosage); overload;
    procedure ParseDosage(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMoney(jsn : TJsonObject) : TFhirMoney; overload;
    procedure ParseMoneyProperties(jsn : TJsonObject; result : TFhirMoney); overload;
    procedure ParseMoney(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMarketingStatus(jsn : TJsonObject) : TFhirMarketingStatus; overload;
    procedure ParseMarketingStatusProperties(jsn : TJsonObject; result : TFhirMarketingStatus); overload;
    procedure ParseMarketingStatus(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseIdentifier(jsn : TJsonObject) : TFhirIdentifier; overload;
    procedure ParseIdentifierProperties(jsn : TJsonObject; result : TFhirIdentifier); overload;
    procedure ParseIdentifier(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSubstanceAmountReferenceRange(jsn : TJsonObject) : TFhirSubstanceAmountReferenceRange; overload; {b\}
    procedure ParseSubstanceAmountReferenceRangeProperties(jsn : TJsonObject; result : TFhirSubstanceAmountReferenceRange); overload; {b\}
    procedure ParseSubstanceAmountReferenceRange(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSubstanceAmount(jsn : TJsonObject) : TFhirSubstanceAmount; overload;
    procedure ParseSubstanceAmountProperties(jsn : TJsonObject; result : TFhirSubstanceAmount); overload;
    procedure ParseSubstanceAmount(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCoding(jsn : TJsonObject) : TFhirCoding; overload;
    procedure ParseCodingProperties(jsn : TJsonObject; result : TFhirCoding); overload;
    procedure ParseCoding(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSampledData(jsn : TJsonObject) : TFhirSampledData; overload;
    procedure ParseSampledDataProperties(jsn : TJsonObject; result : TFhirSampledData); overload;
    procedure ParseSampledData(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParsePopulation(jsn : TJsonObject) : TFhirPopulation; overload;
    procedure ParsePopulationProperties(jsn : TJsonObject; result : TFhirPopulation); overload;
    procedure ParsePopulation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseRatio(jsn : TJsonObject) : TFhirRatio; overload;
    procedure ParseRatioProperties(jsn : TJsonObject; result : TFhirRatio); overload;
    procedure ParseRatio(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseReference(jsn : TJsonObject) : TFhirReference; overload;
    procedure ParseReferenceProperties(jsn : TJsonObject; result : TFhirReference); overload;
    procedure ParseReference(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTriggerDefinition(jsn : TJsonObject) : TFhirTriggerDefinition; overload;
    procedure ParseTriggerDefinitionProperties(jsn : TJsonObject; result : TFhirTriggerDefinition); overload;
    procedure ParseTriggerDefinition(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParsePeriod(jsn : TJsonObject) : TFhirPeriod; overload;
    procedure ParsePeriodProperties(jsn : TJsonObject; result : TFhirPeriod); overload;
    procedure ParsePeriod(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseQuantity(jsn : TJsonObject) : TFhirQuantity; overload;
    procedure ParseQuantityProperties(jsn : TJsonObject; result : TFhirQuantity); overload;
    procedure ParseQuantity(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseRange(jsn : TJsonObject) : TFhirRange; overload;
    procedure ParseRangeProperties(jsn : TJsonObject; result : TFhirRange); overload;
    procedure ParseRange(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseRelatedArtifact(jsn : TJsonObject) : TFhirRelatedArtifact; overload;
    procedure ParseRelatedArtifactProperties(jsn : TJsonObject; result : TFhirRelatedArtifact); overload;
    procedure ParseRelatedArtifact(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseAnnotation(jsn : TJsonObject) : TFhirAnnotation; overload;
    procedure ParseAnnotationProperties(jsn : TJsonObject; result : TFhirAnnotation); overload;
    procedure ParseAnnotation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProductShelfLife(jsn : TJsonObject) : TFhirProductShelfLife; overload;
    procedure ParseProductShelfLifeProperties(jsn : TJsonObject; result : TFhirProductShelfLife); overload;
    procedure ParseProductShelfLife(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseContactDetail(jsn : TJsonObject) : TFhirContactDetail; overload;
    procedure ParseContactDetailProperties(jsn : TJsonObject; result : TFhirContactDetail); overload;
    procedure ParseContactDetail(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseExpression(jsn : TJsonObject) : TFhirExpression; overload;
    procedure ParseExpressionProperties(jsn : TJsonObject; result : TFhirExpression); overload;
    procedure ParseExpression(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseUsageContext(jsn : TJsonObject) : TFhirUsageContext; overload;
    procedure ParseUsageContextProperties(jsn : TJsonObject; result : TFhirUsageContext); overload;
    procedure ParseUsageContext(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSignature(jsn : TJsonObject) : TFhirSignature; overload;
    procedure ParseSignatureProperties(jsn : TJsonObject; result : TFhirSignature); overload;
    procedure ParseSignature(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProdCharacteristic(jsn : TJsonObject) : TFhirProdCharacteristic; overload;
    procedure ParseProdCharacteristicProperties(jsn : TJsonObject; result : TFhirProdCharacteristic); overload;
    procedure ParseProdCharacteristic(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCodeableConcept(jsn : TJsonObject) : TFhirCodeableConcept; overload;
    procedure ParseCodeableConceptProperties(jsn : TJsonObject; result : TFhirCodeableConcept); overload;
    procedure ParseCodeableConcept(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseParameterDefinition(jsn : TJsonObject) : TFhirParameterDefinition; overload;
    procedure ParseParameterDefinitionProperties(jsn : TJsonObject; result : TFhirParameterDefinition); overload;
    procedure ParseParameterDefinition(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseContactPoint(jsn : TJsonObject) : TFhirContactPoint; overload;
    procedure ParseContactPointProperties(jsn : TJsonObject; result : TFhirContactPoint); overload;
    procedure ParseContactPoint(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseHumanName(jsn : TJsonObject) : TFhirHumanName; overload;
    procedure ParseHumanNameProperties(jsn : TJsonObject; result : TFhirHumanName); overload;
    procedure ParseHumanName(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMeta(jsn : TJsonObject) : TFhirMeta; overload;
    procedure ParseMetaProperties(jsn : TJsonObject; result : TFhirMeta); overload;
    procedure ParseMeta(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseAddress(jsn : TJsonObject) : TFhirAddress; overload;
    procedure ParseAddressProperties(jsn : TJsonObject; result : TFhirAddress); overload;
    procedure ParseAddress(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseElementDefinitionSlicing(jsn : TJsonObject) : TFhirElementDefinitionSlicing; overload; {b\}
    procedure ParseElementDefinitionSlicingProperties(jsn : TJsonObject; result : TFhirElementDefinitionSlicing); overload; {b\}
    procedure ParseElementDefinitionSlicing(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseElementDefinitionSlicingDiscriminator(jsn : TJsonObject) : TFhirElementDefinitionSlicingDiscriminator; overload; {b\}
    procedure ParseElementDefinitionSlicingDiscriminatorProperties(jsn : TJsonObject; result : TFhirElementDefinitionSlicingDiscriminator); overload; {b\}
    procedure ParseElementDefinitionSlicingDiscriminator(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseElementDefinitionBase(jsn : TJsonObject) : TFhirElementDefinitionBase; overload; {b\}
    procedure ParseElementDefinitionBaseProperties(jsn : TJsonObject; result : TFhirElementDefinitionBase); overload; {b\}
    procedure ParseElementDefinitionBase(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseElementDefinitionType(jsn : TJsonObject) : TFhirElementDefinitionType; overload; {b\}
    procedure ParseElementDefinitionTypeProperties(jsn : TJsonObject; result : TFhirElementDefinitionType); overload; {b\}
    procedure ParseElementDefinitionType(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseElementDefinitionExample(jsn : TJsonObject) : TFhirElementDefinitionExample; overload; {b\}
    procedure ParseElementDefinitionExampleProperties(jsn : TJsonObject; result : TFhirElementDefinitionExample); overload; {b\}
    procedure ParseElementDefinitionExample(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseElementDefinitionConstraint(jsn : TJsonObject) : TFhirElementDefinitionConstraint; overload; {b\}
    procedure ParseElementDefinitionConstraintProperties(jsn : TJsonObject; result : TFhirElementDefinitionConstraint); overload; {b\}
    procedure ParseElementDefinitionConstraint(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseElementDefinitionBinding(jsn : TJsonObject) : TFhirElementDefinitionBinding; overload; {b\}
    procedure ParseElementDefinitionBindingProperties(jsn : TJsonObject; result : TFhirElementDefinitionBinding); overload; {b\}
    procedure ParseElementDefinitionBinding(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseElementDefinitionMapping(jsn : TJsonObject) : TFhirElementDefinitionMapping; overload; {b\}
    procedure ParseElementDefinitionMappingProperties(jsn : TJsonObject; result : TFhirElementDefinitionMapping); overload; {b\}
    procedure ParseElementDefinitionMapping(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseElementDefinition(jsn : TJsonObject) : TFhirElementDefinition; overload;
    procedure ParseElementDefinitionProperties(jsn : TJsonObject; result : TFhirElementDefinition); overload;
    procedure ParseElementDefinition(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTimingRepeat(jsn : TJsonObject) : TFhirTimingRepeat; overload; {b\}
    procedure ParseTimingRepeatProperties(jsn : TJsonObject; result : TFhirTimingRepeat); overload; {b\}
    procedure ParseTimingRepeat(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTiming(jsn : TJsonObject) : TFhirTiming; overload;
    procedure ParseTimingProperties(jsn : TJsonObject; result : TFhirTiming); overload;
    procedure ParseTiming(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCount(jsn : TJsonObject) : TFhirCount; overload;
    procedure ParseCountProperties(jsn : TJsonObject; result : TFhirCount); overload;
    procedure ParseCount(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseAge(jsn : TJsonObject) : TFhirAge; overload;
    procedure ParseAgeProperties(jsn : TJsonObject; result : TFhirAge); overload;
    procedure ParseAge(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDistance(jsn : TJsonObject) : TFhirDistance; overload;
    procedure ParseDistanceProperties(jsn : TJsonObject; result : TFhirDistance); overload;
    procedure ParseDistance(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDuration(jsn : TJsonObject) : TFhirDuration; overload;
    procedure ParseDurationProperties(jsn : TJsonObject; result : TFhirDuration); overload;
    procedure ParseDuration(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}

{$IFDEF FHIR_ACCOUNT}
    function ParseAccountCoverage(jsn : TJsonObject) : TFhirAccountCoverage; overload; {b\}
    procedure ParseAccountCoverageProperties(jsn : TJsonObject; result : TFhirAccountCoverage); overload; {b\}
    procedure ParseAccountCoverage(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseAccountGuarantor(jsn : TJsonObject) : TFhirAccountGuarantor; overload; {b\}
    procedure ParseAccountGuarantorProperties(jsn : TJsonObject; result : TFhirAccountGuarantor); overload; {b\}
    procedure ParseAccountGuarantor(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseAccount(jsn : TJsonObject) : TFhirAccount; overload;
    procedure ParseAccountProperties(jsn : TJsonObject; result : TFhirAccount); overload;
    procedure ParseAccount(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_ACCOUNT}
{$IFDEF FHIR_ACTIVITYDEFINITION}
    function ParseActivityDefinitionParticipant(jsn : TJsonObject) : TFhirActivityDefinitionParticipant; overload; {b\}
    procedure ParseActivityDefinitionParticipantProperties(jsn : TJsonObject; result : TFhirActivityDefinitionParticipant); overload; {b\}
    procedure ParseActivityDefinitionParticipant(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseActivityDefinitionDynamicValue(jsn : TJsonObject) : TFhirActivityDefinitionDynamicValue; overload; {b\}
    procedure ParseActivityDefinitionDynamicValueProperties(jsn : TJsonObject; result : TFhirActivityDefinitionDynamicValue); overload; {b\}
    procedure ParseActivityDefinitionDynamicValue(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseActivityDefinition(jsn : TJsonObject) : TFhirActivityDefinition; overload;
    procedure ParseActivityDefinitionProperties(jsn : TJsonObject; result : TFhirActivityDefinition); overload;
    procedure ParseActivityDefinition(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_ACTIVITYDEFINITION}
{$IFDEF FHIR_ADVERSEEVENT}
    function ParseAdverseEventSuspectEntity(jsn : TJsonObject) : TFhirAdverseEventSuspectEntity; overload; {b\}
    procedure ParseAdverseEventSuspectEntityProperties(jsn : TJsonObject; result : TFhirAdverseEventSuspectEntity); overload; {b\}
    procedure ParseAdverseEventSuspectEntity(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseAdverseEventSuspectEntityCausality(jsn : TJsonObject) : TFhirAdverseEventSuspectEntityCausality; overload; {b\}
    procedure ParseAdverseEventSuspectEntityCausalityProperties(jsn : TJsonObject; result : TFhirAdverseEventSuspectEntityCausality); overload; {b\}
    procedure ParseAdverseEventSuspectEntityCausality(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseAdverseEvent(jsn : TJsonObject) : TFhirAdverseEvent; overload;
    procedure ParseAdverseEventProperties(jsn : TJsonObject; result : TFhirAdverseEvent); overload;
    procedure ParseAdverseEvent(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_ADVERSEEVENT}
{$IFDEF FHIR_ALLERGYINTOLERANCE}
    function ParseAllergyIntoleranceReaction(jsn : TJsonObject) : TFhirAllergyIntoleranceReaction; overload; {b\}
    procedure ParseAllergyIntoleranceReactionProperties(jsn : TJsonObject; result : TFhirAllergyIntoleranceReaction); overload; {b\}
    procedure ParseAllergyIntoleranceReaction(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseAllergyIntolerance(jsn : TJsonObject) : TFhirAllergyIntolerance; overload;
    procedure ParseAllergyIntoleranceProperties(jsn : TJsonObject; result : TFhirAllergyIntolerance); overload;
    procedure ParseAllergyIntolerance(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_ALLERGYINTOLERANCE}
{$IFDEF FHIR_APPOINTMENT}
    function ParseAppointmentParticipant(jsn : TJsonObject) : TFhirAppointmentParticipant; overload; {b\}
    procedure ParseAppointmentParticipantProperties(jsn : TJsonObject; result : TFhirAppointmentParticipant); overload; {b\}
    procedure ParseAppointmentParticipant(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseAppointment(jsn : TJsonObject) : TFhirAppointment; overload;
    procedure ParseAppointmentProperties(jsn : TJsonObject; result : TFhirAppointment); overload;
    procedure ParseAppointment(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_APPOINTMENT}
{$IFDEF FHIR_APPOINTMENTRESPONSE}
    function ParseAppointmentResponse(jsn : TJsonObject) : TFhirAppointmentResponse; overload;
    procedure ParseAppointmentResponseProperties(jsn : TJsonObject; result : TFhirAppointmentResponse); overload;
    procedure ParseAppointmentResponse(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_APPOINTMENTRESPONSE}
{$IFDEF FHIR_AUDITEVENT}
    function ParseAuditEventAgent(jsn : TJsonObject) : TFhirAuditEventAgent; overload; {b\}
    procedure ParseAuditEventAgentProperties(jsn : TJsonObject; result : TFhirAuditEventAgent); overload; {b\}
    procedure ParseAuditEventAgent(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseAuditEventAgentNetwork(jsn : TJsonObject) : TFhirAuditEventAgentNetwork; overload; {b\}
    procedure ParseAuditEventAgentNetworkProperties(jsn : TJsonObject; result : TFhirAuditEventAgentNetwork); overload; {b\}
    procedure ParseAuditEventAgentNetwork(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseAuditEventSource(jsn : TJsonObject) : TFhirAuditEventSource; overload; {b\}
    procedure ParseAuditEventSourceProperties(jsn : TJsonObject; result : TFhirAuditEventSource); overload; {b\}
    procedure ParseAuditEventSource(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseAuditEventEntity(jsn : TJsonObject) : TFhirAuditEventEntity; overload; {b\}
    procedure ParseAuditEventEntityProperties(jsn : TJsonObject; result : TFhirAuditEventEntity); overload; {b\}
    procedure ParseAuditEventEntity(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseAuditEventEntityDetail(jsn : TJsonObject) : TFhirAuditEventEntityDetail; overload; {b\}
    procedure ParseAuditEventEntityDetailProperties(jsn : TJsonObject; result : TFhirAuditEventEntityDetail); overload; {b\}
    procedure ParseAuditEventEntityDetail(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseAuditEvent(jsn : TJsonObject) : TFhirAuditEvent; overload;
    procedure ParseAuditEventProperties(jsn : TJsonObject; result : TFhirAuditEvent); overload;
    procedure ParseAuditEvent(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_AUDITEVENT}
{$IFDEF FHIR_BASIC}
    function ParseBasic(jsn : TJsonObject) : TFhirBasic; overload;
    procedure ParseBasicProperties(jsn : TJsonObject; result : TFhirBasic); overload;
    procedure ParseBasic(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_BASIC}
{$IFDEF FHIR_BINARY}
    function ParseBinary(jsn : TJsonObject) : TFhirBinary; overload;
    procedure ParseBinaryProperties(jsn : TJsonObject; result : TFhirBinary); overload;
    procedure ParseBinary(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_BINARY}
{$IFDEF FHIR_BIOLOGICALLYDERIVEDPRODUCT}
    function ParseBiologicallyDerivedProductCollection(jsn : TJsonObject) : TFhirBiologicallyDerivedProductCollection; overload; {b\}
    procedure ParseBiologicallyDerivedProductCollectionProperties(jsn : TJsonObject; result : TFhirBiologicallyDerivedProductCollection); overload; {b\}
    procedure ParseBiologicallyDerivedProductCollection(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseBiologicallyDerivedProductProcessing(jsn : TJsonObject) : TFhirBiologicallyDerivedProductProcessing; overload; {b\}
    procedure ParseBiologicallyDerivedProductProcessingProperties(jsn : TJsonObject; result : TFhirBiologicallyDerivedProductProcessing); overload; {b\}
    procedure ParseBiologicallyDerivedProductProcessing(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseBiologicallyDerivedProductManipulation(jsn : TJsonObject) : TFhirBiologicallyDerivedProductManipulation; overload; {b\}
    procedure ParseBiologicallyDerivedProductManipulationProperties(jsn : TJsonObject; result : TFhirBiologicallyDerivedProductManipulation); overload; {b\}
    procedure ParseBiologicallyDerivedProductManipulation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseBiologicallyDerivedProductStorage(jsn : TJsonObject) : TFhirBiologicallyDerivedProductStorage; overload; {b\}
    procedure ParseBiologicallyDerivedProductStorageProperties(jsn : TJsonObject; result : TFhirBiologicallyDerivedProductStorage); overload; {b\}
    procedure ParseBiologicallyDerivedProductStorage(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseBiologicallyDerivedProduct(jsn : TJsonObject) : TFhirBiologicallyDerivedProduct; overload;
    procedure ParseBiologicallyDerivedProductProperties(jsn : TJsonObject; result : TFhirBiologicallyDerivedProduct); overload;
    procedure ParseBiologicallyDerivedProduct(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_BIOLOGICALLYDERIVEDPRODUCT}
{$IFDEF FHIR_BODYSTRUCTURE}
    function ParseBodyStructure(jsn : TJsonObject) : TFhirBodyStructure; overload;
    procedure ParseBodyStructureProperties(jsn : TJsonObject; result : TFhirBodyStructure); overload;
    procedure ParseBodyStructure(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_BODYSTRUCTURE}
{$IFDEF FHIR_BUNDLE}
    function ParseBundleLink(jsn : TJsonObject) : TFhirBundleLink; overload; {b\}
    procedure ParseBundleLinkProperties(jsn : TJsonObject; result : TFhirBundleLink); overload; {b\}
    procedure ParseBundleLink(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseBundleEntry(jsn : TJsonObject) : TFhirBundleEntry; overload; {b\}
    procedure ParseBundleEntryProperties(jsn : TJsonObject; result : TFhirBundleEntry); overload; {b\}
    procedure ParseBundleEntry(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseBundleEntrySearch(jsn : TJsonObject) : TFhirBundleEntrySearch; overload; {b\}
    procedure ParseBundleEntrySearchProperties(jsn : TJsonObject; result : TFhirBundleEntrySearch); overload; {b\}
    procedure ParseBundleEntrySearch(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseBundleEntryRequest(jsn : TJsonObject) : TFhirBundleEntryRequest; overload; {b\}
    procedure ParseBundleEntryRequestProperties(jsn : TJsonObject; result : TFhirBundleEntryRequest); overload; {b\}
    procedure ParseBundleEntryRequest(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseBundleEntryResponse(jsn : TJsonObject) : TFhirBundleEntryResponse; overload; {b\}
    procedure ParseBundleEntryResponseProperties(jsn : TJsonObject; result : TFhirBundleEntryResponse); overload; {b\}
    procedure ParseBundleEntryResponse(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseBundle(jsn : TJsonObject) : TFhirBundle; overload;
    procedure ParseBundleProperties(jsn : TJsonObject; result : TFhirBundle); overload;
    procedure ParseBundle(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_BUNDLE}
{$IFDEF FHIR_CAPABILITYSTATEMENT}
    function ParseCapabilityStatementSoftware(jsn : TJsonObject) : TFhirCapabilityStatementSoftware; overload; {b\}
    procedure ParseCapabilityStatementSoftwareProperties(jsn : TJsonObject; result : TFhirCapabilityStatementSoftware); overload; {b\}
    procedure ParseCapabilityStatementSoftware(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCapabilityStatementImplementation(jsn : TJsonObject) : TFhirCapabilityStatementImplementation; overload; {b\}
    procedure ParseCapabilityStatementImplementationProperties(jsn : TJsonObject; result : TFhirCapabilityStatementImplementation); overload; {b\}
    procedure ParseCapabilityStatementImplementation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCapabilityStatementRest(jsn : TJsonObject) : TFhirCapabilityStatementRest; overload; {b\}
    procedure ParseCapabilityStatementRestProperties(jsn : TJsonObject; result : TFhirCapabilityStatementRest); overload; {b\}
    procedure ParseCapabilityStatementRest(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCapabilityStatementRestSecurity(jsn : TJsonObject) : TFhirCapabilityStatementRestSecurity; overload; {b\}
    procedure ParseCapabilityStatementRestSecurityProperties(jsn : TJsonObject; result : TFhirCapabilityStatementRestSecurity); overload; {b\}
    procedure ParseCapabilityStatementRestSecurity(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCapabilityStatementRestResource(jsn : TJsonObject) : TFhirCapabilityStatementRestResource; overload; {b\}
    procedure ParseCapabilityStatementRestResourceProperties(jsn : TJsonObject; result : TFhirCapabilityStatementRestResource); overload; {b\}
    procedure ParseCapabilityStatementRestResource(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCapabilityStatementRestResourceInteraction(jsn : TJsonObject) : TFhirCapabilityStatementRestResourceInteraction; overload; {b\}
    procedure ParseCapabilityStatementRestResourceInteractionProperties(jsn : TJsonObject; result : TFhirCapabilityStatementRestResourceInteraction); overload; {b\}
    procedure ParseCapabilityStatementRestResourceInteraction(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCapabilityStatementRestResourceSearchParam(jsn : TJsonObject) : TFhirCapabilityStatementRestResourceSearchParam; overload; {b\}
    procedure ParseCapabilityStatementRestResourceSearchParamProperties(jsn : TJsonObject; result : TFhirCapabilityStatementRestResourceSearchParam); overload; {b\}
    procedure ParseCapabilityStatementRestResourceSearchParam(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCapabilityStatementRestResourceOperation(jsn : TJsonObject) : TFhirCapabilityStatementRestResourceOperation; overload; {b\}
    procedure ParseCapabilityStatementRestResourceOperationProperties(jsn : TJsonObject; result : TFhirCapabilityStatementRestResourceOperation); overload; {b\}
    procedure ParseCapabilityStatementRestResourceOperation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCapabilityStatementRestInteraction(jsn : TJsonObject) : TFhirCapabilityStatementRestInteraction; overload; {b\}
    procedure ParseCapabilityStatementRestInteractionProperties(jsn : TJsonObject; result : TFhirCapabilityStatementRestInteraction); overload; {b\}
    procedure ParseCapabilityStatementRestInteraction(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCapabilityStatementMessaging(jsn : TJsonObject) : TFhirCapabilityStatementMessaging; overload; {b\}
    procedure ParseCapabilityStatementMessagingProperties(jsn : TJsonObject; result : TFhirCapabilityStatementMessaging); overload; {b\}
    procedure ParseCapabilityStatementMessaging(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCapabilityStatementMessagingEndpoint(jsn : TJsonObject) : TFhirCapabilityStatementMessagingEndpoint; overload; {b\}
    procedure ParseCapabilityStatementMessagingEndpointProperties(jsn : TJsonObject; result : TFhirCapabilityStatementMessagingEndpoint); overload; {b\}
    procedure ParseCapabilityStatementMessagingEndpoint(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCapabilityStatementMessagingSupportedMessage(jsn : TJsonObject) : TFhirCapabilityStatementMessagingSupportedMessage; overload; {b\}
    procedure ParseCapabilityStatementMessagingSupportedMessageProperties(jsn : TJsonObject; result : TFhirCapabilityStatementMessagingSupportedMessage); overload; {b\}
    procedure ParseCapabilityStatementMessagingSupportedMessage(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCapabilityStatementDocument(jsn : TJsonObject) : TFhirCapabilityStatementDocument; overload; {b\}
    procedure ParseCapabilityStatementDocumentProperties(jsn : TJsonObject; result : TFhirCapabilityStatementDocument); overload; {b\}
    procedure ParseCapabilityStatementDocument(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCapabilityStatement(jsn : TJsonObject) : TFhirCapabilityStatement; overload;
    procedure ParseCapabilityStatementProperties(jsn : TJsonObject; result : TFhirCapabilityStatement); overload;
    procedure ParseCapabilityStatement(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_CAPABILITYSTATEMENT}
{$IFDEF FHIR_CAREPLAN}
    function ParseCarePlanActivity(jsn : TJsonObject) : TFhirCarePlanActivity; overload; {b\}
    procedure ParseCarePlanActivityProperties(jsn : TJsonObject; result : TFhirCarePlanActivity); overload; {b\}
    procedure ParseCarePlanActivity(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCarePlanActivityDetail(jsn : TJsonObject) : TFhirCarePlanActivityDetail; overload; {b\}
    procedure ParseCarePlanActivityDetailProperties(jsn : TJsonObject; result : TFhirCarePlanActivityDetail); overload; {b\}
    procedure ParseCarePlanActivityDetail(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCarePlan(jsn : TJsonObject) : TFhirCarePlan; overload;
    procedure ParseCarePlanProperties(jsn : TJsonObject; result : TFhirCarePlan); overload;
    procedure ParseCarePlan(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_CAREPLAN}
{$IFDEF FHIR_CARETEAM}
    function ParseCareTeamParticipant(jsn : TJsonObject) : TFhirCareTeamParticipant; overload; {b\}
    procedure ParseCareTeamParticipantProperties(jsn : TJsonObject; result : TFhirCareTeamParticipant); overload; {b\}
    procedure ParseCareTeamParticipant(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCareTeam(jsn : TJsonObject) : TFhirCareTeam; overload;
    procedure ParseCareTeamProperties(jsn : TJsonObject; result : TFhirCareTeam); overload;
    procedure ParseCareTeam(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_CARETEAM}
{$IFDEF FHIR_CATALOGENTRY}
    function ParseCatalogEntryRelatedEntry(jsn : TJsonObject) : TFhirCatalogEntryRelatedEntry; overload; {b\}
    procedure ParseCatalogEntryRelatedEntryProperties(jsn : TJsonObject; result : TFhirCatalogEntryRelatedEntry); overload; {b\}
    procedure ParseCatalogEntryRelatedEntry(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCatalogEntry(jsn : TJsonObject) : TFhirCatalogEntry; overload;
    procedure ParseCatalogEntryProperties(jsn : TJsonObject; result : TFhirCatalogEntry); overload;
    procedure ParseCatalogEntry(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_CATALOGENTRY}
{$IFDEF FHIR_CHARGEITEM}
    function ParseChargeItemPerformer(jsn : TJsonObject) : TFhirChargeItemPerformer; overload; {b\}
    procedure ParseChargeItemPerformerProperties(jsn : TJsonObject; result : TFhirChargeItemPerformer); overload; {b\}
    procedure ParseChargeItemPerformer(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseChargeItem(jsn : TJsonObject) : TFhirChargeItem; overload;
    procedure ParseChargeItemProperties(jsn : TJsonObject; result : TFhirChargeItem); overload;
    procedure ParseChargeItem(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_CHARGEITEM}
{$IFDEF FHIR_CHARGEITEMDEFINITION}
    function ParseChargeItemDefinitionApplicability(jsn : TJsonObject) : TFhirChargeItemDefinitionApplicability; overload; {b\}
    procedure ParseChargeItemDefinitionApplicabilityProperties(jsn : TJsonObject; result : TFhirChargeItemDefinitionApplicability); overload; {b\}
    procedure ParseChargeItemDefinitionApplicability(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseChargeItemDefinitionPropertyGroup(jsn : TJsonObject) : TFhirChargeItemDefinitionPropertyGroup; overload; {b\}
    procedure ParseChargeItemDefinitionPropertyGroupProperties(jsn : TJsonObject; result : TFhirChargeItemDefinitionPropertyGroup); overload; {b\}
    procedure ParseChargeItemDefinitionPropertyGroup(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseChargeItemDefinitionPropertyGroupPriceComponent(jsn : TJsonObject) : TFhirChargeItemDefinitionPropertyGroupPriceComponent; overload; {b\}
    procedure ParseChargeItemDefinitionPropertyGroupPriceComponentProperties(jsn : TJsonObject; result : TFhirChargeItemDefinitionPropertyGroupPriceComponent); overload; {b\}
    procedure ParseChargeItemDefinitionPropertyGroupPriceComponent(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseChargeItemDefinition(jsn : TJsonObject) : TFhirChargeItemDefinition; overload;
    procedure ParseChargeItemDefinitionProperties(jsn : TJsonObject; result : TFhirChargeItemDefinition); overload;
    procedure ParseChargeItemDefinition(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_CHARGEITEMDEFINITION}
{$IFDEF FHIR_CLAIM}
    function ParseClaimRelated(jsn : TJsonObject) : TFhirClaimRelated; overload; {b\}
    procedure ParseClaimRelatedProperties(jsn : TJsonObject; result : TFhirClaimRelated); overload; {b\}
    procedure ParseClaimRelated(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimPayee(jsn : TJsonObject) : TFhirClaimPayee; overload; {b\}
    procedure ParseClaimPayeeProperties(jsn : TJsonObject; result : TFhirClaimPayee); overload; {b\}
    procedure ParseClaimPayee(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimCareTeam(jsn : TJsonObject) : TFhirClaimCareTeam; overload; {b\}
    procedure ParseClaimCareTeamProperties(jsn : TJsonObject; result : TFhirClaimCareTeam); overload; {b\}
    procedure ParseClaimCareTeam(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimSupportingInfo(jsn : TJsonObject) : TFhirClaimSupportingInfo; overload; {b\}
    procedure ParseClaimSupportingInfoProperties(jsn : TJsonObject; result : TFhirClaimSupportingInfo); overload; {b\}
    procedure ParseClaimSupportingInfo(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimDiagnosis(jsn : TJsonObject) : TFhirClaimDiagnosis; overload; {b\}
    procedure ParseClaimDiagnosisProperties(jsn : TJsonObject; result : TFhirClaimDiagnosis); overload; {b\}
    procedure ParseClaimDiagnosis(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimProcedure(jsn : TJsonObject) : TFhirClaimProcedure; overload; {b\}
    procedure ParseClaimProcedureProperties(jsn : TJsonObject; result : TFhirClaimProcedure); overload; {b\}
    procedure ParseClaimProcedure(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimInsurance(jsn : TJsonObject) : TFhirClaimInsurance; overload; {b\}
    procedure ParseClaimInsuranceProperties(jsn : TJsonObject; result : TFhirClaimInsurance); overload; {b\}
    procedure ParseClaimInsurance(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimAccident(jsn : TJsonObject) : TFhirClaimAccident; overload; {b\}
    procedure ParseClaimAccidentProperties(jsn : TJsonObject; result : TFhirClaimAccident); overload; {b\}
    procedure ParseClaimAccident(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimItem(jsn : TJsonObject) : TFhirClaimItem; overload; {b\}
    procedure ParseClaimItemProperties(jsn : TJsonObject; result : TFhirClaimItem); overload; {b\}
    procedure ParseClaimItem(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimItemDetail(jsn : TJsonObject) : TFhirClaimItemDetail; overload; {b\}
    procedure ParseClaimItemDetailProperties(jsn : TJsonObject; result : TFhirClaimItemDetail); overload; {b\}
    procedure ParseClaimItemDetail(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimItemDetailSubDetail(jsn : TJsonObject) : TFhirClaimItemDetailSubDetail; overload; {b\}
    procedure ParseClaimItemDetailSubDetailProperties(jsn : TJsonObject; result : TFhirClaimItemDetailSubDetail); overload; {b\}
    procedure ParseClaimItemDetailSubDetail(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaim(jsn : TJsonObject) : TFhirClaim; overload;
    procedure ParseClaimProperties(jsn : TJsonObject; result : TFhirClaim); overload;
    procedure ParseClaim(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_CLAIM}
{$IFDEF FHIR_CLAIMRESPONSE}
    function ParseClaimResponseItem(jsn : TJsonObject) : TFhirClaimResponseItem; overload; {b\}
    procedure ParseClaimResponseItemProperties(jsn : TJsonObject; result : TFhirClaimResponseItem); overload; {b\}
    procedure ParseClaimResponseItem(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimResponseItemAdjudication(jsn : TJsonObject) : TFhirClaimResponseItemAdjudication; overload; {b\}
    procedure ParseClaimResponseItemAdjudicationProperties(jsn : TJsonObject; result : TFhirClaimResponseItemAdjudication); overload; {b\}
    procedure ParseClaimResponseItemAdjudication(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimResponseItemDetail(jsn : TJsonObject) : TFhirClaimResponseItemDetail; overload; {b\}
    procedure ParseClaimResponseItemDetailProperties(jsn : TJsonObject; result : TFhirClaimResponseItemDetail); overload; {b\}
    procedure ParseClaimResponseItemDetail(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimResponseItemDetailSubDetail(jsn : TJsonObject) : TFhirClaimResponseItemDetailSubDetail; overload; {b\}
    procedure ParseClaimResponseItemDetailSubDetailProperties(jsn : TJsonObject; result : TFhirClaimResponseItemDetailSubDetail); overload; {b\}
    procedure ParseClaimResponseItemDetailSubDetail(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimResponseAddItem(jsn : TJsonObject) : TFhirClaimResponseAddItem; overload; {b\}
    procedure ParseClaimResponseAddItemProperties(jsn : TJsonObject; result : TFhirClaimResponseAddItem); overload; {b\}
    procedure ParseClaimResponseAddItem(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimResponseAddItemDetail(jsn : TJsonObject) : TFhirClaimResponseAddItemDetail; overload; {b\}
    procedure ParseClaimResponseAddItemDetailProperties(jsn : TJsonObject; result : TFhirClaimResponseAddItemDetail); overload; {b\}
    procedure ParseClaimResponseAddItemDetail(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimResponseAddItemDetailSubDetail(jsn : TJsonObject) : TFhirClaimResponseAddItemDetailSubDetail; overload; {b\}
    procedure ParseClaimResponseAddItemDetailSubDetailProperties(jsn : TJsonObject; result : TFhirClaimResponseAddItemDetailSubDetail); overload; {b\}
    procedure ParseClaimResponseAddItemDetailSubDetail(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimResponseTotal(jsn : TJsonObject) : TFhirClaimResponseTotal; overload; {b\}
    procedure ParseClaimResponseTotalProperties(jsn : TJsonObject; result : TFhirClaimResponseTotal); overload; {b\}
    procedure ParseClaimResponseTotal(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimResponsePayment(jsn : TJsonObject) : TFhirClaimResponsePayment; overload; {b\}
    procedure ParseClaimResponsePaymentProperties(jsn : TJsonObject; result : TFhirClaimResponsePayment); overload; {b\}
    procedure ParseClaimResponsePayment(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimResponseProcessNote(jsn : TJsonObject) : TFhirClaimResponseProcessNote; overload; {b\}
    procedure ParseClaimResponseProcessNoteProperties(jsn : TJsonObject; result : TFhirClaimResponseProcessNote); overload; {b\}
    procedure ParseClaimResponseProcessNote(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimResponseInsurance(jsn : TJsonObject) : TFhirClaimResponseInsurance; overload; {b\}
    procedure ParseClaimResponseInsuranceProperties(jsn : TJsonObject; result : TFhirClaimResponseInsurance); overload; {b\}
    procedure ParseClaimResponseInsurance(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimResponseError(jsn : TJsonObject) : TFhirClaimResponseError; overload; {b\}
    procedure ParseClaimResponseErrorProperties(jsn : TJsonObject; result : TFhirClaimResponseError); overload; {b\}
    procedure ParseClaimResponseError(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimResponse(jsn : TJsonObject) : TFhirClaimResponse; overload;
    procedure ParseClaimResponseProperties(jsn : TJsonObject; result : TFhirClaimResponse); overload;
    procedure ParseClaimResponse(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_CLAIMRESPONSE}
{$IFDEF FHIR_CLINICALIMPRESSION}
    function ParseClinicalImpressionInvestigation(jsn : TJsonObject) : TFhirClinicalImpressionInvestigation; overload; {b\}
    procedure ParseClinicalImpressionInvestigationProperties(jsn : TJsonObject; result : TFhirClinicalImpressionInvestigation); overload; {b\}
    procedure ParseClinicalImpressionInvestigation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClinicalImpressionFinding(jsn : TJsonObject) : TFhirClinicalImpressionFinding; overload; {b\}
    procedure ParseClinicalImpressionFindingProperties(jsn : TJsonObject; result : TFhirClinicalImpressionFinding); overload; {b\}
    procedure ParseClinicalImpressionFinding(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClinicalImpression(jsn : TJsonObject) : TFhirClinicalImpression; overload;
    procedure ParseClinicalImpressionProperties(jsn : TJsonObject; result : TFhirClinicalImpression); overload;
    procedure ParseClinicalImpression(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_CLINICALIMPRESSION}
{$IFDEF FHIR_CODESYSTEM}
    function ParseCodeSystemFilter(jsn : TJsonObject) : TFhirCodeSystemFilter; overload; {b\}
    procedure ParseCodeSystemFilterProperties(jsn : TJsonObject; result : TFhirCodeSystemFilter); overload; {b\}
    procedure ParseCodeSystemFilter(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCodeSystemProperty(jsn : TJsonObject) : TFhirCodeSystemProperty; overload; {b\}
    procedure ParseCodeSystemPropertyProperties(jsn : TJsonObject; result : TFhirCodeSystemProperty); overload; {b\}
    procedure ParseCodeSystemProperty(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCodeSystemConcept(jsn : TJsonObject) : TFhirCodeSystemConcept; overload; {b\}
    procedure ParseCodeSystemConceptProperties(jsn : TJsonObject; result : TFhirCodeSystemConcept); overload; {b\}
    procedure ParseCodeSystemConcept(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCodeSystemConceptDesignation(jsn : TJsonObject) : TFhirCodeSystemConceptDesignation; overload; {b\}
    procedure ParseCodeSystemConceptDesignationProperties(jsn : TJsonObject; result : TFhirCodeSystemConceptDesignation); overload; {b\}
    procedure ParseCodeSystemConceptDesignation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCodeSystemConceptProperty(jsn : TJsonObject) : TFhirCodeSystemConceptProperty; overload; {b\}
    procedure ParseCodeSystemConceptPropertyProperties(jsn : TJsonObject; result : TFhirCodeSystemConceptProperty); overload; {b\}
    procedure ParseCodeSystemConceptProperty(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCodeSystem(jsn : TJsonObject) : TFhirCodeSystem; overload;
    procedure ParseCodeSystemProperties(jsn : TJsonObject; result : TFhirCodeSystem); overload;
    procedure ParseCodeSystem(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_CODESYSTEM}
{$IFDEF FHIR_COMMUNICATION}
    function ParseCommunicationPayload(jsn : TJsonObject) : TFhirCommunicationPayload; overload; {b\}
    procedure ParseCommunicationPayloadProperties(jsn : TJsonObject; result : TFhirCommunicationPayload); overload; {b\}
    procedure ParseCommunicationPayload(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCommunication(jsn : TJsonObject) : TFhirCommunication; overload;
    procedure ParseCommunicationProperties(jsn : TJsonObject; result : TFhirCommunication); overload;
    procedure ParseCommunication(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_COMMUNICATION}
{$IFDEF FHIR_COMMUNICATIONREQUEST}
    function ParseCommunicationRequestPayload(jsn : TJsonObject) : TFhirCommunicationRequestPayload; overload; {b\}
    procedure ParseCommunicationRequestPayloadProperties(jsn : TJsonObject; result : TFhirCommunicationRequestPayload); overload; {b\}
    procedure ParseCommunicationRequestPayload(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCommunicationRequest(jsn : TJsonObject) : TFhirCommunicationRequest; overload;
    procedure ParseCommunicationRequestProperties(jsn : TJsonObject; result : TFhirCommunicationRequest); overload;
    procedure ParseCommunicationRequest(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_COMMUNICATIONREQUEST}
{$IFDEF FHIR_COMPARTMENTDEFINITION}
    function ParseCompartmentDefinitionResource(jsn : TJsonObject) : TFhirCompartmentDefinitionResource; overload; {b\}
    procedure ParseCompartmentDefinitionResourceProperties(jsn : TJsonObject; result : TFhirCompartmentDefinitionResource); overload; {b\}
    procedure ParseCompartmentDefinitionResource(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCompartmentDefinition(jsn : TJsonObject) : TFhirCompartmentDefinition; overload;
    procedure ParseCompartmentDefinitionProperties(jsn : TJsonObject; result : TFhirCompartmentDefinition); overload;
    procedure ParseCompartmentDefinition(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_COMPARTMENTDEFINITION}
{$IFDEF FHIR_COMPOSITION}
    function ParseCompositionAttester(jsn : TJsonObject) : TFhirCompositionAttester; overload; {b\}
    procedure ParseCompositionAttesterProperties(jsn : TJsonObject; result : TFhirCompositionAttester); overload; {b\}
    procedure ParseCompositionAttester(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCompositionRelatesTo(jsn : TJsonObject) : TFhirCompositionRelatesTo; overload; {b\}
    procedure ParseCompositionRelatesToProperties(jsn : TJsonObject; result : TFhirCompositionRelatesTo); overload; {b\}
    procedure ParseCompositionRelatesTo(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCompositionEvent(jsn : TJsonObject) : TFhirCompositionEvent; overload; {b\}
    procedure ParseCompositionEventProperties(jsn : TJsonObject; result : TFhirCompositionEvent); overload; {b\}
    procedure ParseCompositionEvent(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCompositionSection(jsn : TJsonObject) : TFhirCompositionSection; overload; {b\}
    procedure ParseCompositionSectionProperties(jsn : TJsonObject; result : TFhirCompositionSection); overload; {b\}
    procedure ParseCompositionSection(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseComposition(jsn : TJsonObject) : TFhirComposition; overload;
    procedure ParseCompositionProperties(jsn : TJsonObject; result : TFhirComposition); overload;
    procedure ParseComposition(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_COMPOSITION}
{$IFDEF FHIR_CONCEPTMAP}
    function ParseConceptMapGroup(jsn : TJsonObject) : TFhirConceptMapGroup; overload; {b\}
    procedure ParseConceptMapGroupProperties(jsn : TJsonObject; result : TFhirConceptMapGroup); overload; {b\}
    procedure ParseConceptMapGroup(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConceptMapGroupElement(jsn : TJsonObject) : TFhirConceptMapGroupElement; overload; {b\}
    procedure ParseConceptMapGroupElementProperties(jsn : TJsonObject; result : TFhirConceptMapGroupElement); overload; {b\}
    procedure ParseConceptMapGroupElement(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConceptMapGroupElementTarget(jsn : TJsonObject) : TFhirConceptMapGroupElementTarget; overload; {b\}
    procedure ParseConceptMapGroupElementTargetProperties(jsn : TJsonObject; result : TFhirConceptMapGroupElementTarget); overload; {b\}
    procedure ParseConceptMapGroupElementTarget(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConceptMapGroupElementTargetDependsOn(jsn : TJsonObject) : TFhirConceptMapGroupElementTargetDependsOn; overload; {b\}
    procedure ParseConceptMapGroupElementTargetDependsOnProperties(jsn : TJsonObject; result : TFhirConceptMapGroupElementTargetDependsOn); overload; {b\}
    procedure ParseConceptMapGroupElementTargetDependsOn(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConceptMapGroupUnmapped(jsn : TJsonObject) : TFhirConceptMapGroupUnmapped; overload; {b\}
    procedure ParseConceptMapGroupUnmappedProperties(jsn : TJsonObject; result : TFhirConceptMapGroupUnmapped); overload; {b\}
    procedure ParseConceptMapGroupUnmapped(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConceptMap(jsn : TJsonObject) : TFhirConceptMap; overload;
    procedure ParseConceptMapProperties(jsn : TJsonObject; result : TFhirConceptMap); overload;
    procedure ParseConceptMap(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_CONCEPTMAP}
{$IFDEF FHIR_CONDITION}
    function ParseConditionStage(jsn : TJsonObject) : TFhirConditionStage; overload; {b\}
    procedure ParseConditionStageProperties(jsn : TJsonObject; result : TFhirConditionStage); overload; {b\}
    procedure ParseConditionStage(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConditionEvidence(jsn : TJsonObject) : TFhirConditionEvidence; overload; {b\}
    procedure ParseConditionEvidenceProperties(jsn : TJsonObject; result : TFhirConditionEvidence); overload; {b\}
    procedure ParseConditionEvidence(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCondition(jsn : TJsonObject) : TFhirCondition; overload;
    procedure ParseConditionProperties(jsn : TJsonObject; result : TFhirCondition); overload;
    procedure ParseCondition(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_CONDITION}
{$IFDEF FHIR_CONSENT}
    function ParseConsentPolicy(jsn : TJsonObject) : TFhirConsentPolicy; overload; {b\}
    procedure ParseConsentPolicyProperties(jsn : TJsonObject; result : TFhirConsentPolicy); overload; {b\}
    procedure ParseConsentPolicy(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConsentVerification(jsn : TJsonObject) : TFhirConsentVerification; overload; {b\}
    procedure ParseConsentVerificationProperties(jsn : TJsonObject; result : TFhirConsentVerification); overload; {b\}
    procedure ParseConsentVerification(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConsentProvision(jsn : TJsonObject) : TFhirConsentProvision; overload; {b\}
    procedure ParseConsentProvisionProperties(jsn : TJsonObject; result : TFhirConsentProvision); overload; {b\}
    procedure ParseConsentProvision(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConsentProvisionActor(jsn : TJsonObject) : TFhirConsentProvisionActor; overload; {b\}
    procedure ParseConsentProvisionActorProperties(jsn : TJsonObject; result : TFhirConsentProvisionActor); overload; {b\}
    procedure ParseConsentProvisionActor(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConsentProvisionData(jsn : TJsonObject) : TFhirConsentProvisionData; overload; {b\}
    procedure ParseConsentProvisionDataProperties(jsn : TJsonObject; result : TFhirConsentProvisionData); overload; {b\}
    procedure ParseConsentProvisionData(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConsent(jsn : TJsonObject) : TFhirConsent; overload;
    procedure ParseConsentProperties(jsn : TJsonObject; result : TFhirConsent); overload;
    procedure ParseConsent(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_CONSENT}
{$IFDEF FHIR_CONTRACT}
    function ParseContractContentDefinition(jsn : TJsonObject) : TFhirContractContentDefinition; overload; {b\}
    procedure ParseContractContentDefinitionProperties(jsn : TJsonObject; result : TFhirContractContentDefinition); overload; {b\}
    procedure ParseContractContentDefinition(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseContractTerm(jsn : TJsonObject) : TFhirContractTerm; overload; {b\}
    procedure ParseContractTermProperties(jsn : TJsonObject; result : TFhirContractTerm); overload; {b\}
    procedure ParseContractTerm(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseContractTermSecurityLabel(jsn : TJsonObject) : TFhirContractTermSecurityLabel; overload; {b\}
    procedure ParseContractTermSecurityLabelProperties(jsn : TJsonObject; result : TFhirContractTermSecurityLabel); overload; {b\}
    procedure ParseContractTermSecurityLabel(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseContractTermOffer(jsn : TJsonObject) : TFhirContractTermOffer; overload; {b\}
    procedure ParseContractTermOfferProperties(jsn : TJsonObject; result : TFhirContractTermOffer); overload; {b\}
    procedure ParseContractTermOffer(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseContractTermOfferParty(jsn : TJsonObject) : TFhirContractTermOfferParty; overload; {b\}
    procedure ParseContractTermOfferPartyProperties(jsn : TJsonObject; result : TFhirContractTermOfferParty); overload; {b\}
    procedure ParseContractTermOfferParty(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseContractTermOfferAnswer(jsn : TJsonObject) : TFhirContractTermOfferAnswer; overload; {b\}
    procedure ParseContractTermOfferAnswerProperties(jsn : TJsonObject; result : TFhirContractTermOfferAnswer); overload; {b\}
    procedure ParseContractTermOfferAnswer(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseContractTermAsset(jsn : TJsonObject) : TFhirContractTermAsset; overload; {b\}
    procedure ParseContractTermAssetProperties(jsn : TJsonObject; result : TFhirContractTermAsset); overload; {b\}
    procedure ParseContractTermAsset(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseContractTermAssetContext(jsn : TJsonObject) : TFhirContractTermAssetContext; overload; {b\}
    procedure ParseContractTermAssetContextProperties(jsn : TJsonObject; result : TFhirContractTermAssetContext); overload; {b\}
    procedure ParseContractTermAssetContext(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseContractTermAssetValuedItem(jsn : TJsonObject) : TFhirContractTermAssetValuedItem; overload; {b\}
    procedure ParseContractTermAssetValuedItemProperties(jsn : TJsonObject; result : TFhirContractTermAssetValuedItem); overload; {b\}
    procedure ParseContractTermAssetValuedItem(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseContractTermAction(jsn : TJsonObject) : TFhirContractTermAction; overload; {b\}
    procedure ParseContractTermActionProperties(jsn : TJsonObject; result : TFhirContractTermAction); overload; {b\}
    procedure ParseContractTermAction(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseContractTermActionSubject(jsn : TJsonObject) : TFhirContractTermActionSubject; overload; {b\}
    procedure ParseContractTermActionSubjectProperties(jsn : TJsonObject; result : TFhirContractTermActionSubject); overload; {b\}
    procedure ParseContractTermActionSubject(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseContractSigner(jsn : TJsonObject) : TFhirContractSigner; overload; {b\}
    procedure ParseContractSignerProperties(jsn : TJsonObject; result : TFhirContractSigner); overload; {b\}
    procedure ParseContractSigner(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseContractFriendly(jsn : TJsonObject) : TFhirContractFriendly; overload; {b\}
    procedure ParseContractFriendlyProperties(jsn : TJsonObject; result : TFhirContractFriendly); overload; {b\}
    procedure ParseContractFriendly(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseContractLegal(jsn : TJsonObject) : TFhirContractLegal; overload; {b\}
    procedure ParseContractLegalProperties(jsn : TJsonObject; result : TFhirContractLegal); overload; {b\}
    procedure ParseContractLegal(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseContractRule(jsn : TJsonObject) : TFhirContractRule; overload; {b\}
    procedure ParseContractRuleProperties(jsn : TJsonObject; result : TFhirContractRule); overload; {b\}
    procedure ParseContractRule(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseContract(jsn : TJsonObject) : TFhirContract; overload;
    procedure ParseContractProperties(jsn : TJsonObject; result : TFhirContract); overload;
    procedure ParseContract(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_CONTRACT}
{$IFDEF FHIR_COVERAGE}
    function ParseCoverageClass(jsn : TJsonObject) : TFhirCoverageClass; overload; {b\}
    procedure ParseCoverageClassProperties(jsn : TJsonObject; result : TFhirCoverageClass); overload; {b\}
    procedure ParseCoverageClass(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCoverageCostToBeneficiary(jsn : TJsonObject) : TFhirCoverageCostToBeneficiary; overload; {b\}
    procedure ParseCoverageCostToBeneficiaryProperties(jsn : TJsonObject; result : TFhirCoverageCostToBeneficiary); overload; {b\}
    procedure ParseCoverageCostToBeneficiary(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCoverageCostToBeneficiaryException(jsn : TJsonObject) : TFhirCoverageCostToBeneficiaryException; overload; {b\}
    procedure ParseCoverageCostToBeneficiaryExceptionProperties(jsn : TJsonObject; result : TFhirCoverageCostToBeneficiaryException); overload; {b\}
    procedure ParseCoverageCostToBeneficiaryException(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCoverage(jsn : TJsonObject) : TFhirCoverage; overload;
    procedure ParseCoverageProperties(jsn : TJsonObject; result : TFhirCoverage); overload;
    procedure ParseCoverage(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_COVERAGE}
{$IFDEF FHIR_COVERAGEELIGIBILITYREQUEST}
    function ParseCoverageEligibilityRequestSupportingInfo(jsn : TJsonObject) : TFhirCoverageEligibilityRequestSupportingInfo; overload; {b\}
    procedure ParseCoverageEligibilityRequestSupportingInfoProperties(jsn : TJsonObject; result : TFhirCoverageEligibilityRequestSupportingInfo); overload; {b\}
    procedure ParseCoverageEligibilityRequestSupportingInfo(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCoverageEligibilityRequestInsurance(jsn : TJsonObject) : TFhirCoverageEligibilityRequestInsurance; overload; {b\}
    procedure ParseCoverageEligibilityRequestInsuranceProperties(jsn : TJsonObject; result : TFhirCoverageEligibilityRequestInsurance); overload; {b\}
    procedure ParseCoverageEligibilityRequestInsurance(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCoverageEligibilityRequestItem(jsn : TJsonObject) : TFhirCoverageEligibilityRequestItem; overload; {b\}
    procedure ParseCoverageEligibilityRequestItemProperties(jsn : TJsonObject; result : TFhirCoverageEligibilityRequestItem); overload; {b\}
    procedure ParseCoverageEligibilityRequestItem(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCoverageEligibilityRequestItemDiagnosis(jsn : TJsonObject) : TFhirCoverageEligibilityRequestItemDiagnosis; overload; {b\}
    procedure ParseCoverageEligibilityRequestItemDiagnosisProperties(jsn : TJsonObject; result : TFhirCoverageEligibilityRequestItemDiagnosis); overload; {b\}
    procedure ParseCoverageEligibilityRequestItemDiagnosis(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCoverageEligibilityRequest(jsn : TJsonObject) : TFhirCoverageEligibilityRequest; overload;
    procedure ParseCoverageEligibilityRequestProperties(jsn : TJsonObject; result : TFhirCoverageEligibilityRequest); overload;
    procedure ParseCoverageEligibilityRequest(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_COVERAGEELIGIBILITYREQUEST}
{$IFDEF FHIR_COVERAGEELIGIBILITYRESPONSE}
    function ParseCoverageEligibilityResponseInsurance(jsn : TJsonObject) : TFhirCoverageEligibilityResponseInsurance; overload; {b\}
    procedure ParseCoverageEligibilityResponseInsuranceProperties(jsn : TJsonObject; result : TFhirCoverageEligibilityResponseInsurance); overload; {b\}
    procedure ParseCoverageEligibilityResponseInsurance(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCoverageEligibilityResponseInsuranceItem(jsn : TJsonObject) : TFhirCoverageEligibilityResponseInsuranceItem; overload; {b\}
    procedure ParseCoverageEligibilityResponseInsuranceItemProperties(jsn : TJsonObject; result : TFhirCoverageEligibilityResponseInsuranceItem); overload; {b\}
    procedure ParseCoverageEligibilityResponseInsuranceItem(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCoverageEligibilityResponseInsuranceItemBenefit(jsn : TJsonObject) : TFhirCoverageEligibilityResponseInsuranceItemBenefit; overload; {b\}
    procedure ParseCoverageEligibilityResponseInsuranceItemBenefitProperties(jsn : TJsonObject; result : TFhirCoverageEligibilityResponseInsuranceItemBenefit); overload; {b\}
    procedure ParseCoverageEligibilityResponseInsuranceItemBenefit(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCoverageEligibilityResponseError(jsn : TJsonObject) : TFhirCoverageEligibilityResponseError; overload; {b\}
    procedure ParseCoverageEligibilityResponseErrorProperties(jsn : TJsonObject; result : TFhirCoverageEligibilityResponseError); overload; {b\}
    procedure ParseCoverageEligibilityResponseError(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCoverageEligibilityResponse(jsn : TJsonObject) : TFhirCoverageEligibilityResponse; overload;
    procedure ParseCoverageEligibilityResponseProperties(jsn : TJsonObject; result : TFhirCoverageEligibilityResponse); overload;
    procedure ParseCoverageEligibilityResponse(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_COVERAGEELIGIBILITYRESPONSE}
{$IFDEF FHIR_DETECTEDISSUE}
    function ParseDetectedIssueEvidence(jsn : TJsonObject) : TFhirDetectedIssueEvidence; overload; {b\}
    procedure ParseDetectedIssueEvidenceProperties(jsn : TJsonObject; result : TFhirDetectedIssueEvidence); overload; {b\}
    procedure ParseDetectedIssueEvidence(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDetectedIssueMitigation(jsn : TJsonObject) : TFhirDetectedIssueMitigation; overload; {b\}
    procedure ParseDetectedIssueMitigationProperties(jsn : TJsonObject; result : TFhirDetectedIssueMitigation); overload; {b\}
    procedure ParseDetectedIssueMitigation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDetectedIssue(jsn : TJsonObject) : TFhirDetectedIssue; overload;
    procedure ParseDetectedIssueProperties(jsn : TJsonObject; result : TFhirDetectedIssue); overload;
    procedure ParseDetectedIssue(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_DETECTEDISSUE}
{$IFDEF FHIR_DEVICE}
    function ParseDeviceUdiCarrier(jsn : TJsonObject) : TFhirDeviceUdiCarrier; overload; {b\}
    procedure ParseDeviceUdiCarrierProperties(jsn : TJsonObject; result : TFhirDeviceUdiCarrier); overload; {b\}
    procedure ParseDeviceUdiCarrier(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDeviceDeviceName(jsn : TJsonObject) : TFhirDeviceDeviceName; overload; {b\}
    procedure ParseDeviceDeviceNameProperties(jsn : TJsonObject; result : TFhirDeviceDeviceName); overload; {b\}
    procedure ParseDeviceDeviceName(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDeviceSpecialization(jsn : TJsonObject) : TFhirDeviceSpecialization; overload; {b\}
    procedure ParseDeviceSpecializationProperties(jsn : TJsonObject; result : TFhirDeviceSpecialization); overload; {b\}
    procedure ParseDeviceSpecialization(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDeviceVersion(jsn : TJsonObject) : TFhirDeviceVersion; overload; {b\}
    procedure ParseDeviceVersionProperties(jsn : TJsonObject; result : TFhirDeviceVersion); overload; {b\}
    procedure ParseDeviceVersion(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDeviceProperty(jsn : TJsonObject) : TFhirDeviceProperty; overload; {b\}
    procedure ParseDevicePropertyProperties(jsn : TJsonObject; result : TFhirDeviceProperty); overload; {b\}
    procedure ParseDeviceProperty(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDevice(jsn : TJsonObject) : TFhirDevice; overload;
    procedure ParseDeviceProperties(jsn : TJsonObject; result : TFhirDevice); overload;
    procedure ParseDevice(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_DEVICE}
{$IFDEF FHIR_DEVICEDEFINITION}
    function ParseDeviceDefinitionUdiDeviceIdentifier(jsn : TJsonObject) : TFhirDeviceDefinitionUdiDeviceIdentifier; overload; {b\}
    procedure ParseDeviceDefinitionUdiDeviceIdentifierProperties(jsn : TJsonObject; result : TFhirDeviceDefinitionUdiDeviceIdentifier); overload; {b\}
    procedure ParseDeviceDefinitionUdiDeviceIdentifier(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDeviceDefinitionDeviceName(jsn : TJsonObject) : TFhirDeviceDefinitionDeviceName; overload; {b\}
    procedure ParseDeviceDefinitionDeviceNameProperties(jsn : TJsonObject; result : TFhirDeviceDefinitionDeviceName); overload; {b\}
    procedure ParseDeviceDefinitionDeviceName(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDeviceDefinitionSpecialization(jsn : TJsonObject) : TFhirDeviceDefinitionSpecialization; overload; {b\}
    procedure ParseDeviceDefinitionSpecializationProperties(jsn : TJsonObject; result : TFhirDeviceDefinitionSpecialization); overload; {b\}
    procedure ParseDeviceDefinitionSpecialization(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDeviceDefinitionCapability(jsn : TJsonObject) : TFhirDeviceDefinitionCapability; overload; {b\}
    procedure ParseDeviceDefinitionCapabilityProperties(jsn : TJsonObject; result : TFhirDeviceDefinitionCapability); overload; {b\}
    procedure ParseDeviceDefinitionCapability(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDeviceDefinitionProperty(jsn : TJsonObject) : TFhirDeviceDefinitionProperty; overload; {b\}
    procedure ParseDeviceDefinitionPropertyProperties(jsn : TJsonObject; result : TFhirDeviceDefinitionProperty); overload; {b\}
    procedure ParseDeviceDefinitionProperty(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDeviceDefinitionMaterial(jsn : TJsonObject) : TFhirDeviceDefinitionMaterial; overload; {b\}
    procedure ParseDeviceDefinitionMaterialProperties(jsn : TJsonObject; result : TFhirDeviceDefinitionMaterial); overload; {b\}
    procedure ParseDeviceDefinitionMaterial(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDeviceDefinition(jsn : TJsonObject) : TFhirDeviceDefinition; overload;
    procedure ParseDeviceDefinitionProperties(jsn : TJsonObject; result : TFhirDeviceDefinition); overload;
    procedure ParseDeviceDefinition(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_DEVICEDEFINITION}
{$IFDEF FHIR_DEVICEMETRIC}
    function ParseDeviceMetricCalibration(jsn : TJsonObject) : TFhirDeviceMetricCalibration; overload; {b\}
    procedure ParseDeviceMetricCalibrationProperties(jsn : TJsonObject; result : TFhirDeviceMetricCalibration); overload; {b\}
    procedure ParseDeviceMetricCalibration(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDeviceMetric(jsn : TJsonObject) : TFhirDeviceMetric; overload;
    procedure ParseDeviceMetricProperties(jsn : TJsonObject; result : TFhirDeviceMetric); overload;
    procedure ParseDeviceMetric(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_DEVICEMETRIC}
{$IFDEF FHIR_DEVICEREQUEST}
    function ParseDeviceRequestParameter(jsn : TJsonObject) : TFhirDeviceRequestParameter; overload; {b\}
    procedure ParseDeviceRequestParameterProperties(jsn : TJsonObject; result : TFhirDeviceRequestParameter); overload; {b\}
    procedure ParseDeviceRequestParameter(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDeviceRequest(jsn : TJsonObject) : TFhirDeviceRequest; overload;
    procedure ParseDeviceRequestProperties(jsn : TJsonObject; result : TFhirDeviceRequest); overload;
    procedure ParseDeviceRequest(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_DEVICEREQUEST}
{$IFDEF FHIR_DEVICEUSESTATEMENT}
    function ParseDeviceUseStatement(jsn : TJsonObject) : TFhirDeviceUseStatement; overload;
    procedure ParseDeviceUseStatementProperties(jsn : TJsonObject; result : TFhirDeviceUseStatement); overload;
    procedure ParseDeviceUseStatement(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_DEVICEUSESTATEMENT}
{$IFDEF FHIR_DIAGNOSTICREPORT}
    function ParseDiagnosticReportMedia(jsn : TJsonObject) : TFhirDiagnosticReportMedia; overload; {b\}
    procedure ParseDiagnosticReportMediaProperties(jsn : TJsonObject; result : TFhirDiagnosticReportMedia); overload; {b\}
    procedure ParseDiagnosticReportMedia(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDiagnosticReport(jsn : TJsonObject) : TFhirDiagnosticReport; overload;
    procedure ParseDiagnosticReportProperties(jsn : TJsonObject; result : TFhirDiagnosticReport); overload;
    procedure ParseDiagnosticReport(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_DIAGNOSTICREPORT}
{$IFDEF FHIR_DOCUMENTMANIFEST}
    function ParseDocumentManifestRelated(jsn : TJsonObject) : TFhirDocumentManifestRelated; overload; {b\}
    procedure ParseDocumentManifestRelatedProperties(jsn : TJsonObject; result : TFhirDocumentManifestRelated); overload; {b\}
    procedure ParseDocumentManifestRelated(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDocumentManifest(jsn : TJsonObject) : TFhirDocumentManifest; overload;
    procedure ParseDocumentManifestProperties(jsn : TJsonObject; result : TFhirDocumentManifest); overload;
    procedure ParseDocumentManifest(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_DOCUMENTMANIFEST}
{$IFDEF FHIR_DOCUMENTREFERENCE}
    function ParseDocumentReferenceRelatesTo(jsn : TJsonObject) : TFhirDocumentReferenceRelatesTo; overload; {b\}
    procedure ParseDocumentReferenceRelatesToProperties(jsn : TJsonObject; result : TFhirDocumentReferenceRelatesTo); overload; {b\}
    procedure ParseDocumentReferenceRelatesTo(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDocumentReferenceContent(jsn : TJsonObject) : TFhirDocumentReferenceContent; overload; {b\}
    procedure ParseDocumentReferenceContentProperties(jsn : TJsonObject; result : TFhirDocumentReferenceContent); overload; {b\}
    procedure ParseDocumentReferenceContent(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDocumentReferenceContext(jsn : TJsonObject) : TFhirDocumentReferenceContext; overload; {b\}
    procedure ParseDocumentReferenceContextProperties(jsn : TJsonObject; result : TFhirDocumentReferenceContext); overload; {b\}
    procedure ParseDocumentReferenceContext(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDocumentReference(jsn : TJsonObject) : TFhirDocumentReference; overload;
    procedure ParseDocumentReferenceProperties(jsn : TJsonObject; result : TFhirDocumentReference); overload;
    procedure ParseDocumentReference(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_DOCUMENTREFERENCE}
{$IFDEF FHIR_EFFECTEVIDENCESYNTHESIS}
    function ParseEffectEvidenceSynthesisSampleSize(jsn : TJsonObject) : TFhirEffectEvidenceSynthesisSampleSize; overload; {b\}
    procedure ParseEffectEvidenceSynthesisSampleSizeProperties(jsn : TJsonObject; result : TFhirEffectEvidenceSynthesisSampleSize); overload; {b\}
    procedure ParseEffectEvidenceSynthesisSampleSize(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseEffectEvidenceSynthesisResultsByExposure(jsn : TJsonObject) : TFhirEffectEvidenceSynthesisResultsByExposure; overload; {b\}
    procedure ParseEffectEvidenceSynthesisResultsByExposureProperties(jsn : TJsonObject; result : TFhirEffectEvidenceSynthesisResultsByExposure); overload; {b\}
    procedure ParseEffectEvidenceSynthesisResultsByExposure(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseEffectEvidenceSynthesisEffectEstimate(jsn : TJsonObject) : TFhirEffectEvidenceSynthesisEffectEstimate; overload; {b\}
    procedure ParseEffectEvidenceSynthesisEffectEstimateProperties(jsn : TJsonObject; result : TFhirEffectEvidenceSynthesisEffectEstimate); overload; {b\}
    procedure ParseEffectEvidenceSynthesisEffectEstimate(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseEffectEvidenceSynthesisEffectEstimatePrecisionEstimate(jsn : TJsonObject) : TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate; overload; {b\}
    procedure ParseEffectEvidenceSynthesisEffectEstimatePrecisionEstimateProperties(jsn : TJsonObject; result : TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate); overload; {b\}
    procedure ParseEffectEvidenceSynthesisEffectEstimatePrecisionEstimate(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseEffectEvidenceSynthesisCertainty(jsn : TJsonObject) : TFhirEffectEvidenceSynthesisCertainty; overload; {b\}
    procedure ParseEffectEvidenceSynthesisCertaintyProperties(jsn : TJsonObject; result : TFhirEffectEvidenceSynthesisCertainty); overload; {b\}
    procedure ParseEffectEvidenceSynthesisCertainty(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseEffectEvidenceSynthesisCertaintyCertaintySubcomponent(jsn : TJsonObject) : TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent; overload; {b\}
    procedure ParseEffectEvidenceSynthesisCertaintyCertaintySubcomponentProperties(jsn : TJsonObject; result : TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent); overload; {b\}
    procedure ParseEffectEvidenceSynthesisCertaintyCertaintySubcomponent(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseEffectEvidenceSynthesis(jsn : TJsonObject) : TFhirEffectEvidenceSynthesis; overload;
    procedure ParseEffectEvidenceSynthesisProperties(jsn : TJsonObject; result : TFhirEffectEvidenceSynthesis); overload;
    procedure ParseEffectEvidenceSynthesis(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_EFFECTEVIDENCESYNTHESIS}
{$IFDEF FHIR_ENCOUNTER}
    function ParseEncounterStatusHistory(jsn : TJsonObject) : TFhirEncounterStatusHistory; overload; {b\}
    procedure ParseEncounterStatusHistoryProperties(jsn : TJsonObject; result : TFhirEncounterStatusHistory); overload; {b\}
    procedure ParseEncounterStatusHistory(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseEncounterClassHistory(jsn : TJsonObject) : TFhirEncounterClassHistory; overload; {b\}
    procedure ParseEncounterClassHistoryProperties(jsn : TJsonObject; result : TFhirEncounterClassHistory); overload; {b\}
    procedure ParseEncounterClassHistory(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseEncounterParticipant(jsn : TJsonObject) : TFhirEncounterParticipant; overload; {b\}
    procedure ParseEncounterParticipantProperties(jsn : TJsonObject; result : TFhirEncounterParticipant); overload; {b\}
    procedure ParseEncounterParticipant(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseEncounterDiagnosis(jsn : TJsonObject) : TFhirEncounterDiagnosis; overload; {b\}
    procedure ParseEncounterDiagnosisProperties(jsn : TJsonObject; result : TFhirEncounterDiagnosis); overload; {b\}
    procedure ParseEncounterDiagnosis(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseEncounterHospitalization(jsn : TJsonObject) : TFhirEncounterHospitalization; overload; {b\}
    procedure ParseEncounterHospitalizationProperties(jsn : TJsonObject; result : TFhirEncounterHospitalization); overload; {b\}
    procedure ParseEncounterHospitalization(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseEncounterLocation(jsn : TJsonObject) : TFhirEncounterLocation; overload; {b\}
    procedure ParseEncounterLocationProperties(jsn : TJsonObject; result : TFhirEncounterLocation); overload; {b\}
    procedure ParseEncounterLocation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseEncounter(jsn : TJsonObject) : TFhirEncounter; overload;
    procedure ParseEncounterProperties(jsn : TJsonObject; result : TFhirEncounter); overload;
    procedure ParseEncounter(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_ENCOUNTER}
{$IFDEF FHIR_ENDPOINT}
    function ParseEndpoint(jsn : TJsonObject) : TFhirEndpoint; overload;
    procedure ParseEndpointProperties(jsn : TJsonObject; result : TFhirEndpoint); overload;
    procedure ParseEndpoint(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_ENDPOINT}
{$IFDEF FHIR_ENROLLMENTREQUEST}
    function ParseEnrollmentRequest(jsn : TJsonObject) : TFhirEnrollmentRequest; overload;
    procedure ParseEnrollmentRequestProperties(jsn : TJsonObject; result : TFhirEnrollmentRequest); overload;
    procedure ParseEnrollmentRequest(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_ENROLLMENTREQUEST}
{$IFDEF FHIR_ENROLLMENTRESPONSE}
    function ParseEnrollmentResponse(jsn : TJsonObject) : TFhirEnrollmentResponse; overload;
    procedure ParseEnrollmentResponseProperties(jsn : TJsonObject; result : TFhirEnrollmentResponse); overload;
    procedure ParseEnrollmentResponse(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_ENROLLMENTRESPONSE}
{$IFDEF FHIR_EPISODEOFCARE}
    function ParseEpisodeOfCareStatusHistory(jsn : TJsonObject) : TFhirEpisodeOfCareStatusHistory; overload; {b\}
    procedure ParseEpisodeOfCareStatusHistoryProperties(jsn : TJsonObject; result : TFhirEpisodeOfCareStatusHistory); overload; {b\}
    procedure ParseEpisodeOfCareStatusHistory(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseEpisodeOfCareDiagnosis(jsn : TJsonObject) : TFhirEpisodeOfCareDiagnosis; overload; {b\}
    procedure ParseEpisodeOfCareDiagnosisProperties(jsn : TJsonObject; result : TFhirEpisodeOfCareDiagnosis); overload; {b\}
    procedure ParseEpisodeOfCareDiagnosis(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseEpisodeOfCare(jsn : TJsonObject) : TFhirEpisodeOfCare; overload;
    procedure ParseEpisodeOfCareProperties(jsn : TJsonObject; result : TFhirEpisodeOfCare); overload;
    procedure ParseEpisodeOfCare(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_EPISODEOFCARE}
{$IFDEF FHIR_EVENTDEFINITION}
    function ParseEventDefinition(jsn : TJsonObject) : TFhirEventDefinition; overload;
    procedure ParseEventDefinitionProperties(jsn : TJsonObject; result : TFhirEventDefinition); overload;
    procedure ParseEventDefinition(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_EVENTDEFINITION}
{$IFDEF FHIR_EVIDENCE}
    function ParseEvidence(jsn : TJsonObject) : TFhirEvidence; overload;
    procedure ParseEvidenceProperties(jsn : TJsonObject; result : TFhirEvidence); overload;
    procedure ParseEvidence(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_EVIDENCE}
{$IFDEF FHIR_EVIDENCEVARIABLE}
    function ParseEvidenceVariableCharacteristic(jsn : TJsonObject) : TFhirEvidenceVariableCharacteristic; overload; {b\}
    procedure ParseEvidenceVariableCharacteristicProperties(jsn : TJsonObject; result : TFhirEvidenceVariableCharacteristic); overload; {b\}
    procedure ParseEvidenceVariableCharacteristic(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseEvidenceVariable(jsn : TJsonObject) : TFhirEvidenceVariable; overload;
    procedure ParseEvidenceVariableProperties(jsn : TJsonObject; result : TFhirEvidenceVariable); overload;
    procedure ParseEvidenceVariable(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_EVIDENCEVARIABLE}
{$IFDEF FHIR_EXAMPLESCENARIO}
    function ParseExampleScenarioActor(jsn : TJsonObject) : TFhirExampleScenarioActor; overload; {b\}
    procedure ParseExampleScenarioActorProperties(jsn : TJsonObject; result : TFhirExampleScenarioActor); overload; {b\}
    procedure ParseExampleScenarioActor(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseExampleScenarioInstance(jsn : TJsonObject) : TFhirExampleScenarioInstance; overload; {b\}
    procedure ParseExampleScenarioInstanceProperties(jsn : TJsonObject; result : TFhirExampleScenarioInstance); overload; {b\}
    procedure ParseExampleScenarioInstance(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseExampleScenarioInstanceVersion(jsn : TJsonObject) : TFhirExampleScenarioInstanceVersion; overload; {b\}
    procedure ParseExampleScenarioInstanceVersionProperties(jsn : TJsonObject; result : TFhirExampleScenarioInstanceVersion); overload; {b\}
    procedure ParseExampleScenarioInstanceVersion(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseExampleScenarioInstanceContainedInstance(jsn : TJsonObject) : TFhirExampleScenarioInstanceContainedInstance; overload; {b\}
    procedure ParseExampleScenarioInstanceContainedInstanceProperties(jsn : TJsonObject; result : TFhirExampleScenarioInstanceContainedInstance); overload; {b\}
    procedure ParseExampleScenarioInstanceContainedInstance(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseExampleScenarioProcess(jsn : TJsonObject) : TFhirExampleScenarioProcess; overload; {b\}
    procedure ParseExampleScenarioProcessProperties(jsn : TJsonObject; result : TFhirExampleScenarioProcess); overload; {b\}
    procedure ParseExampleScenarioProcess(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseExampleScenarioProcessStep(jsn : TJsonObject) : TFhirExampleScenarioProcessStep; overload; {b\}
    procedure ParseExampleScenarioProcessStepProperties(jsn : TJsonObject; result : TFhirExampleScenarioProcessStep); overload; {b\}
    procedure ParseExampleScenarioProcessStep(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseExampleScenarioProcessStepOperation(jsn : TJsonObject) : TFhirExampleScenarioProcessStepOperation; overload; {b\}
    procedure ParseExampleScenarioProcessStepOperationProperties(jsn : TJsonObject; result : TFhirExampleScenarioProcessStepOperation); overload; {b\}
    procedure ParseExampleScenarioProcessStepOperation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseExampleScenarioProcessStepAlternative(jsn : TJsonObject) : TFhirExampleScenarioProcessStepAlternative; overload; {b\}
    procedure ParseExampleScenarioProcessStepAlternativeProperties(jsn : TJsonObject; result : TFhirExampleScenarioProcessStepAlternative); overload; {b\}
    procedure ParseExampleScenarioProcessStepAlternative(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseExampleScenario(jsn : TJsonObject) : TFhirExampleScenario; overload;
    procedure ParseExampleScenarioProperties(jsn : TJsonObject; result : TFhirExampleScenario); overload;
    procedure ParseExampleScenario(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_EXAMPLESCENARIO}
{$IFDEF FHIR_EXPLANATIONOFBENEFIT}
    function ParseExplanationOfBenefitRelated(jsn : TJsonObject) : TFhirExplanationOfBenefitRelated; overload; {b\}
    procedure ParseExplanationOfBenefitRelatedProperties(jsn : TJsonObject; result : TFhirExplanationOfBenefitRelated); overload; {b\}
    procedure ParseExplanationOfBenefitRelated(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseExplanationOfBenefitPayee(jsn : TJsonObject) : TFhirExplanationOfBenefitPayee; overload; {b\}
    procedure ParseExplanationOfBenefitPayeeProperties(jsn : TJsonObject; result : TFhirExplanationOfBenefitPayee); overload; {b\}
    procedure ParseExplanationOfBenefitPayee(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseExplanationOfBenefitCareTeam(jsn : TJsonObject) : TFhirExplanationOfBenefitCareTeam; overload; {b\}
    procedure ParseExplanationOfBenefitCareTeamProperties(jsn : TJsonObject; result : TFhirExplanationOfBenefitCareTeam); overload; {b\}
    procedure ParseExplanationOfBenefitCareTeam(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseExplanationOfBenefitSupportingInfo(jsn : TJsonObject) : TFhirExplanationOfBenefitSupportingInfo; overload; {b\}
    procedure ParseExplanationOfBenefitSupportingInfoProperties(jsn : TJsonObject; result : TFhirExplanationOfBenefitSupportingInfo); overload; {b\}
    procedure ParseExplanationOfBenefitSupportingInfo(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseExplanationOfBenefitDiagnosis(jsn : TJsonObject) : TFhirExplanationOfBenefitDiagnosis; overload; {b\}
    procedure ParseExplanationOfBenefitDiagnosisProperties(jsn : TJsonObject; result : TFhirExplanationOfBenefitDiagnosis); overload; {b\}
    procedure ParseExplanationOfBenefitDiagnosis(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseExplanationOfBenefitProcedure(jsn : TJsonObject) : TFhirExplanationOfBenefitProcedure; overload; {b\}
    procedure ParseExplanationOfBenefitProcedureProperties(jsn : TJsonObject; result : TFhirExplanationOfBenefitProcedure); overload; {b\}
    procedure ParseExplanationOfBenefitProcedure(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseExplanationOfBenefitInsurance(jsn : TJsonObject) : TFhirExplanationOfBenefitInsurance; overload; {b\}
    procedure ParseExplanationOfBenefitInsuranceProperties(jsn : TJsonObject; result : TFhirExplanationOfBenefitInsurance); overload; {b\}
    procedure ParseExplanationOfBenefitInsurance(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseExplanationOfBenefitAccident(jsn : TJsonObject) : TFhirExplanationOfBenefitAccident; overload; {b\}
    procedure ParseExplanationOfBenefitAccidentProperties(jsn : TJsonObject; result : TFhirExplanationOfBenefitAccident); overload; {b\}
    procedure ParseExplanationOfBenefitAccident(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseExplanationOfBenefitItem(jsn : TJsonObject) : TFhirExplanationOfBenefitItem; overload; {b\}
    procedure ParseExplanationOfBenefitItemProperties(jsn : TJsonObject; result : TFhirExplanationOfBenefitItem); overload; {b\}
    procedure ParseExplanationOfBenefitItem(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseExplanationOfBenefitItemAdjudication(jsn : TJsonObject) : TFhirExplanationOfBenefitItemAdjudication; overload; {b\}
    procedure ParseExplanationOfBenefitItemAdjudicationProperties(jsn : TJsonObject; result : TFhirExplanationOfBenefitItemAdjudication); overload; {b\}
    procedure ParseExplanationOfBenefitItemAdjudication(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseExplanationOfBenefitItemDetail(jsn : TJsonObject) : TFhirExplanationOfBenefitItemDetail; overload; {b\}
    procedure ParseExplanationOfBenefitItemDetailProperties(jsn : TJsonObject; result : TFhirExplanationOfBenefitItemDetail); overload; {b\}
    procedure ParseExplanationOfBenefitItemDetail(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseExplanationOfBenefitItemDetailSubDetail(jsn : TJsonObject) : TFhirExplanationOfBenefitItemDetailSubDetail; overload; {b\}
    procedure ParseExplanationOfBenefitItemDetailSubDetailProperties(jsn : TJsonObject; result : TFhirExplanationOfBenefitItemDetailSubDetail); overload; {b\}
    procedure ParseExplanationOfBenefitItemDetailSubDetail(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseExplanationOfBenefitAddItem(jsn : TJsonObject) : TFhirExplanationOfBenefitAddItem; overload; {b\}
    procedure ParseExplanationOfBenefitAddItemProperties(jsn : TJsonObject; result : TFhirExplanationOfBenefitAddItem); overload; {b\}
    procedure ParseExplanationOfBenefitAddItem(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseExplanationOfBenefitAddItemDetail(jsn : TJsonObject) : TFhirExplanationOfBenefitAddItemDetail; overload; {b\}
    procedure ParseExplanationOfBenefitAddItemDetailProperties(jsn : TJsonObject; result : TFhirExplanationOfBenefitAddItemDetail); overload; {b\}
    procedure ParseExplanationOfBenefitAddItemDetail(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseExplanationOfBenefitAddItemDetailSubDetail(jsn : TJsonObject) : TFhirExplanationOfBenefitAddItemDetailSubDetail; overload; {b\}
    procedure ParseExplanationOfBenefitAddItemDetailSubDetailProperties(jsn : TJsonObject; result : TFhirExplanationOfBenefitAddItemDetailSubDetail); overload; {b\}
    procedure ParseExplanationOfBenefitAddItemDetailSubDetail(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseExplanationOfBenefitTotal(jsn : TJsonObject) : TFhirExplanationOfBenefitTotal; overload; {b\}
    procedure ParseExplanationOfBenefitTotalProperties(jsn : TJsonObject; result : TFhirExplanationOfBenefitTotal); overload; {b\}
    procedure ParseExplanationOfBenefitTotal(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseExplanationOfBenefitPayment(jsn : TJsonObject) : TFhirExplanationOfBenefitPayment; overload; {b\}
    procedure ParseExplanationOfBenefitPaymentProperties(jsn : TJsonObject; result : TFhirExplanationOfBenefitPayment); overload; {b\}
    procedure ParseExplanationOfBenefitPayment(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseExplanationOfBenefitProcessNote(jsn : TJsonObject) : TFhirExplanationOfBenefitProcessNote; overload; {b\}
    procedure ParseExplanationOfBenefitProcessNoteProperties(jsn : TJsonObject; result : TFhirExplanationOfBenefitProcessNote); overload; {b\}
    procedure ParseExplanationOfBenefitProcessNote(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseExplanationOfBenefitBenefitBalance(jsn : TJsonObject) : TFhirExplanationOfBenefitBenefitBalance; overload; {b\}
    procedure ParseExplanationOfBenefitBenefitBalanceProperties(jsn : TJsonObject; result : TFhirExplanationOfBenefitBenefitBalance); overload; {b\}
    procedure ParseExplanationOfBenefitBenefitBalance(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseExplanationOfBenefitBenefitBalanceFinancial(jsn : TJsonObject) : TFhirExplanationOfBenefitBenefitBalanceFinancial; overload; {b\}
    procedure ParseExplanationOfBenefitBenefitBalanceFinancialProperties(jsn : TJsonObject; result : TFhirExplanationOfBenefitBenefitBalanceFinancial); overload; {b\}
    procedure ParseExplanationOfBenefitBenefitBalanceFinancial(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseExplanationOfBenefit(jsn : TJsonObject) : TFhirExplanationOfBenefit; overload;
    procedure ParseExplanationOfBenefitProperties(jsn : TJsonObject; result : TFhirExplanationOfBenefit); overload;
    procedure ParseExplanationOfBenefit(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_EXPLANATIONOFBENEFIT}
{$IFDEF FHIR_FAMILYMEMBERHISTORY}
    function ParseFamilyMemberHistoryCondition(jsn : TJsonObject) : TFhirFamilyMemberHistoryCondition; overload; {b\}
    procedure ParseFamilyMemberHistoryConditionProperties(jsn : TJsonObject; result : TFhirFamilyMemberHistoryCondition); overload; {b\}
    procedure ParseFamilyMemberHistoryCondition(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseFamilyMemberHistory(jsn : TJsonObject) : TFhirFamilyMemberHistory; overload;
    procedure ParseFamilyMemberHistoryProperties(jsn : TJsonObject; result : TFhirFamilyMemberHistory); overload;
    procedure ParseFamilyMemberHistory(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_FAMILYMEMBERHISTORY}
{$IFDEF FHIR_FLAG}
    function ParseFlag(jsn : TJsonObject) : TFhirFlag; overload;
    procedure ParseFlagProperties(jsn : TJsonObject; result : TFhirFlag); overload;
    procedure ParseFlag(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_FLAG}
{$IFDEF FHIR_GOAL}
    function ParseGoalTarget(jsn : TJsonObject) : TFhirGoalTarget; overload; {b\}
    procedure ParseGoalTargetProperties(jsn : TJsonObject; result : TFhirGoalTarget); overload; {b\}
    procedure ParseGoalTarget(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseGoal(jsn : TJsonObject) : TFhirGoal; overload;
    procedure ParseGoalProperties(jsn : TJsonObject; result : TFhirGoal); overload;
    procedure ParseGoal(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_GOAL}
{$IFDEF FHIR_GRAPHDEFINITION}
    function ParseGraphDefinitionLink(jsn : TJsonObject) : TFhirGraphDefinitionLink; overload; {b\}
    procedure ParseGraphDefinitionLinkProperties(jsn : TJsonObject; result : TFhirGraphDefinitionLink); overload; {b\}
    procedure ParseGraphDefinitionLink(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseGraphDefinitionLinkTarget(jsn : TJsonObject) : TFhirGraphDefinitionLinkTarget; overload; {b\}
    procedure ParseGraphDefinitionLinkTargetProperties(jsn : TJsonObject; result : TFhirGraphDefinitionLinkTarget); overload; {b\}
    procedure ParseGraphDefinitionLinkTarget(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseGraphDefinitionLinkTargetCompartment(jsn : TJsonObject) : TFhirGraphDefinitionLinkTargetCompartment; overload; {b\}
    procedure ParseGraphDefinitionLinkTargetCompartmentProperties(jsn : TJsonObject; result : TFhirGraphDefinitionLinkTargetCompartment); overload; {b\}
    procedure ParseGraphDefinitionLinkTargetCompartment(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseGraphDefinition(jsn : TJsonObject) : TFhirGraphDefinition; overload;
    procedure ParseGraphDefinitionProperties(jsn : TJsonObject; result : TFhirGraphDefinition); overload;
    procedure ParseGraphDefinition(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_GRAPHDEFINITION}
{$IFDEF FHIR_GROUP}
    function ParseGroupCharacteristic(jsn : TJsonObject) : TFhirGroupCharacteristic; overload; {b\}
    procedure ParseGroupCharacteristicProperties(jsn : TJsonObject; result : TFhirGroupCharacteristic); overload; {b\}
    procedure ParseGroupCharacteristic(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseGroupMember(jsn : TJsonObject) : TFhirGroupMember; overload; {b\}
    procedure ParseGroupMemberProperties(jsn : TJsonObject; result : TFhirGroupMember); overload; {b\}
    procedure ParseGroupMember(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseGroup(jsn : TJsonObject) : TFhirGroup; overload;
    procedure ParseGroupProperties(jsn : TJsonObject; result : TFhirGroup); overload;
    procedure ParseGroup(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_GROUP}
{$IFDEF FHIR_GUIDANCERESPONSE}
    function ParseGuidanceResponse(jsn : TJsonObject) : TFhirGuidanceResponse; overload;
    procedure ParseGuidanceResponseProperties(jsn : TJsonObject; result : TFhirGuidanceResponse); overload;
    procedure ParseGuidanceResponse(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_GUIDANCERESPONSE}
{$IFDEF FHIR_HEALTHCARESERVICE}
    function ParseHealthcareServiceEligibility(jsn : TJsonObject) : TFhirHealthcareServiceEligibility; overload; {b\}
    procedure ParseHealthcareServiceEligibilityProperties(jsn : TJsonObject; result : TFhirHealthcareServiceEligibility); overload; {b\}
    procedure ParseHealthcareServiceEligibility(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseHealthcareServiceAvailableTime(jsn : TJsonObject) : TFhirHealthcareServiceAvailableTime; overload; {b\}
    procedure ParseHealthcareServiceAvailableTimeProperties(jsn : TJsonObject; result : TFhirHealthcareServiceAvailableTime); overload; {b\}
    procedure ParseHealthcareServiceAvailableTime(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseHealthcareServiceNotAvailable(jsn : TJsonObject) : TFhirHealthcareServiceNotAvailable; overload; {b\}
    procedure ParseHealthcareServiceNotAvailableProperties(jsn : TJsonObject; result : TFhirHealthcareServiceNotAvailable); overload; {b\}
    procedure ParseHealthcareServiceNotAvailable(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseHealthcareService(jsn : TJsonObject) : TFhirHealthcareService; overload;
    procedure ParseHealthcareServiceProperties(jsn : TJsonObject; result : TFhirHealthcareService); overload;
    procedure ParseHealthcareService(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_HEALTHCARESERVICE}
{$IFDEF FHIR_IMAGINGSTUDY}
    function ParseImagingStudySeries(jsn : TJsonObject) : TFhirImagingStudySeries; overload; {b\}
    procedure ParseImagingStudySeriesProperties(jsn : TJsonObject; result : TFhirImagingStudySeries); overload; {b\}
    procedure ParseImagingStudySeries(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImagingStudySeriesPerformer(jsn : TJsonObject) : TFhirImagingStudySeriesPerformer; overload; {b\}
    procedure ParseImagingStudySeriesPerformerProperties(jsn : TJsonObject; result : TFhirImagingStudySeriesPerformer); overload; {b\}
    procedure ParseImagingStudySeriesPerformer(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImagingStudySeriesInstance(jsn : TJsonObject) : TFhirImagingStudySeriesInstance; overload; {b\}
    procedure ParseImagingStudySeriesInstanceProperties(jsn : TJsonObject; result : TFhirImagingStudySeriesInstance); overload; {b\}
    procedure ParseImagingStudySeriesInstance(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImagingStudy(jsn : TJsonObject) : TFhirImagingStudy; overload;
    procedure ParseImagingStudyProperties(jsn : TJsonObject; result : TFhirImagingStudy); overload;
    procedure ParseImagingStudy(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_IMAGINGSTUDY}
{$IFDEF FHIR_IMMUNIZATION}
    function ParseImmunizationPerformer(jsn : TJsonObject) : TFhirImmunizationPerformer; overload; {b\}
    procedure ParseImmunizationPerformerProperties(jsn : TJsonObject; result : TFhirImmunizationPerformer); overload; {b\}
    procedure ParseImmunizationPerformer(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImmunizationEducation(jsn : TJsonObject) : TFhirImmunizationEducation; overload; {b\}
    procedure ParseImmunizationEducationProperties(jsn : TJsonObject; result : TFhirImmunizationEducation); overload; {b\}
    procedure ParseImmunizationEducation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImmunizationReaction(jsn : TJsonObject) : TFhirImmunizationReaction; overload; {b\}
    procedure ParseImmunizationReactionProperties(jsn : TJsonObject; result : TFhirImmunizationReaction); overload; {b\}
    procedure ParseImmunizationReaction(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImmunizationProtocolApplied(jsn : TJsonObject) : TFhirImmunizationProtocolApplied; overload; {b\}
    procedure ParseImmunizationProtocolAppliedProperties(jsn : TJsonObject; result : TFhirImmunizationProtocolApplied); overload; {b\}
    procedure ParseImmunizationProtocolApplied(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImmunization(jsn : TJsonObject) : TFhirImmunization; overload;
    procedure ParseImmunizationProperties(jsn : TJsonObject; result : TFhirImmunization); overload;
    procedure ParseImmunization(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_IMMUNIZATION}
{$IFDEF FHIR_IMMUNIZATIONEVALUATION}
    function ParseImmunizationEvaluation(jsn : TJsonObject) : TFhirImmunizationEvaluation; overload;
    procedure ParseImmunizationEvaluationProperties(jsn : TJsonObject; result : TFhirImmunizationEvaluation); overload;
    procedure ParseImmunizationEvaluation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_IMMUNIZATIONEVALUATION}
{$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
    function ParseImmunizationRecommendationRecommendation(jsn : TJsonObject) : TFhirImmunizationRecommendationRecommendation; overload; {b\}
    procedure ParseImmunizationRecommendationRecommendationProperties(jsn : TJsonObject; result : TFhirImmunizationRecommendationRecommendation); overload; {b\}
    procedure ParseImmunizationRecommendationRecommendation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImmunizationRecommendationRecommendationDateCriterion(jsn : TJsonObject) : TFhirImmunizationRecommendationRecommendationDateCriterion; overload; {b\}
    procedure ParseImmunizationRecommendationRecommendationDateCriterionProperties(jsn : TJsonObject; result : TFhirImmunizationRecommendationRecommendationDateCriterion); overload; {b\}
    procedure ParseImmunizationRecommendationRecommendationDateCriterion(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImmunizationRecommendation(jsn : TJsonObject) : TFhirImmunizationRecommendation; overload;
    procedure ParseImmunizationRecommendationProperties(jsn : TJsonObject; result : TFhirImmunizationRecommendation); overload;
    procedure ParseImmunizationRecommendation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_IMMUNIZATIONRECOMMENDATION}
{$IFDEF FHIR_IMPLEMENTATIONGUIDE}
    function ParseImplementationGuideDependsOn(jsn : TJsonObject) : TFhirImplementationGuideDependsOn; overload; {b\}
    procedure ParseImplementationGuideDependsOnProperties(jsn : TJsonObject; result : TFhirImplementationGuideDependsOn); overload; {b\}
    procedure ParseImplementationGuideDependsOn(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImplementationGuideGlobal(jsn : TJsonObject) : TFhirImplementationGuideGlobal; overload; {b\}
    procedure ParseImplementationGuideGlobalProperties(jsn : TJsonObject; result : TFhirImplementationGuideGlobal); overload; {b\}
    procedure ParseImplementationGuideGlobal(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImplementationGuideDefinition(jsn : TJsonObject) : TFhirImplementationGuideDefinition; overload; {b\}
    procedure ParseImplementationGuideDefinitionProperties(jsn : TJsonObject; result : TFhirImplementationGuideDefinition); overload; {b\}
    procedure ParseImplementationGuideDefinition(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImplementationGuideDefinitionGrouping(jsn : TJsonObject) : TFhirImplementationGuideDefinitionGrouping; overload; {b\}
    procedure ParseImplementationGuideDefinitionGroupingProperties(jsn : TJsonObject; result : TFhirImplementationGuideDefinitionGrouping); overload; {b\}
    procedure ParseImplementationGuideDefinitionGrouping(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImplementationGuideDefinitionResource(jsn : TJsonObject) : TFhirImplementationGuideDefinitionResource; overload; {b\}
    procedure ParseImplementationGuideDefinitionResourceProperties(jsn : TJsonObject; result : TFhirImplementationGuideDefinitionResource); overload; {b\}
    procedure ParseImplementationGuideDefinitionResource(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImplementationGuideDefinitionPage(jsn : TJsonObject) : TFhirImplementationGuideDefinitionPage; overload; {b\}
    procedure ParseImplementationGuideDefinitionPageProperties(jsn : TJsonObject; result : TFhirImplementationGuideDefinitionPage); overload; {b\}
    procedure ParseImplementationGuideDefinitionPage(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImplementationGuideDefinitionParameter(jsn : TJsonObject) : TFhirImplementationGuideDefinitionParameter; overload; {b\}
    procedure ParseImplementationGuideDefinitionParameterProperties(jsn : TJsonObject; result : TFhirImplementationGuideDefinitionParameter); overload; {b\}
    procedure ParseImplementationGuideDefinitionParameter(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImplementationGuideDefinitionTemplate(jsn : TJsonObject) : TFhirImplementationGuideDefinitionTemplate; overload; {b\}
    procedure ParseImplementationGuideDefinitionTemplateProperties(jsn : TJsonObject; result : TFhirImplementationGuideDefinitionTemplate); overload; {b\}
    procedure ParseImplementationGuideDefinitionTemplate(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImplementationGuideManifest(jsn : TJsonObject) : TFhirImplementationGuideManifest; overload; {b\}
    procedure ParseImplementationGuideManifestProperties(jsn : TJsonObject; result : TFhirImplementationGuideManifest); overload; {b\}
    procedure ParseImplementationGuideManifest(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImplementationGuideManifestResource(jsn : TJsonObject) : TFhirImplementationGuideManifestResource; overload; {b\}
    procedure ParseImplementationGuideManifestResourceProperties(jsn : TJsonObject; result : TFhirImplementationGuideManifestResource); overload; {b\}
    procedure ParseImplementationGuideManifestResource(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImplementationGuideManifestPage(jsn : TJsonObject) : TFhirImplementationGuideManifestPage; overload; {b\}
    procedure ParseImplementationGuideManifestPageProperties(jsn : TJsonObject; result : TFhirImplementationGuideManifestPage); overload; {b\}
    procedure ParseImplementationGuideManifestPage(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImplementationGuide(jsn : TJsonObject) : TFhirImplementationGuide; overload;
    procedure ParseImplementationGuideProperties(jsn : TJsonObject; result : TFhirImplementationGuide); overload;
    procedure ParseImplementationGuide(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_IMPLEMENTATIONGUIDE}
{$IFDEF FHIR_INSURANCEPLAN}
    function ParseInsurancePlanContact(jsn : TJsonObject) : TFhirInsurancePlanContact; overload; {b\}
    procedure ParseInsurancePlanContactProperties(jsn : TJsonObject; result : TFhirInsurancePlanContact); overload; {b\}
    procedure ParseInsurancePlanContact(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseInsurancePlanCoverage(jsn : TJsonObject) : TFhirInsurancePlanCoverage; overload; {b\}
    procedure ParseInsurancePlanCoverageProperties(jsn : TJsonObject; result : TFhirInsurancePlanCoverage); overload; {b\}
    procedure ParseInsurancePlanCoverage(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseInsurancePlanCoverageBenefit(jsn : TJsonObject) : TFhirInsurancePlanCoverageBenefit; overload; {b\}
    procedure ParseInsurancePlanCoverageBenefitProperties(jsn : TJsonObject; result : TFhirInsurancePlanCoverageBenefit); overload; {b\}
    procedure ParseInsurancePlanCoverageBenefit(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseInsurancePlanCoverageBenefitLimit(jsn : TJsonObject) : TFhirInsurancePlanCoverageBenefitLimit; overload; {b\}
    procedure ParseInsurancePlanCoverageBenefitLimitProperties(jsn : TJsonObject; result : TFhirInsurancePlanCoverageBenefitLimit); overload; {b\}
    procedure ParseInsurancePlanCoverageBenefitLimit(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseInsurancePlanPlan(jsn : TJsonObject) : TFhirInsurancePlanPlan; overload; {b\}
    procedure ParseInsurancePlanPlanProperties(jsn : TJsonObject; result : TFhirInsurancePlanPlan); overload; {b\}
    procedure ParseInsurancePlanPlan(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseInsurancePlanPlanGeneralCost(jsn : TJsonObject) : TFhirInsurancePlanPlanGeneralCost; overload; {b\}
    procedure ParseInsurancePlanPlanGeneralCostProperties(jsn : TJsonObject; result : TFhirInsurancePlanPlanGeneralCost); overload; {b\}
    procedure ParseInsurancePlanPlanGeneralCost(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseInsurancePlanPlanSpecificCost(jsn : TJsonObject) : TFhirInsurancePlanPlanSpecificCost; overload; {b\}
    procedure ParseInsurancePlanPlanSpecificCostProperties(jsn : TJsonObject; result : TFhirInsurancePlanPlanSpecificCost); overload; {b\}
    procedure ParseInsurancePlanPlanSpecificCost(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseInsurancePlanPlanSpecificCostBenefit(jsn : TJsonObject) : TFhirInsurancePlanPlanSpecificCostBenefit; overload; {b\}
    procedure ParseInsurancePlanPlanSpecificCostBenefitProperties(jsn : TJsonObject; result : TFhirInsurancePlanPlanSpecificCostBenefit); overload; {b\}
    procedure ParseInsurancePlanPlanSpecificCostBenefit(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseInsurancePlanPlanSpecificCostBenefitCost(jsn : TJsonObject) : TFhirInsurancePlanPlanSpecificCostBenefitCost; overload; {b\}
    procedure ParseInsurancePlanPlanSpecificCostBenefitCostProperties(jsn : TJsonObject; result : TFhirInsurancePlanPlanSpecificCostBenefitCost); overload; {b\}
    procedure ParseInsurancePlanPlanSpecificCostBenefitCost(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseInsurancePlan(jsn : TJsonObject) : TFhirInsurancePlan; overload;
    procedure ParseInsurancePlanProperties(jsn : TJsonObject; result : TFhirInsurancePlan); overload;
    procedure ParseInsurancePlan(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_INSURANCEPLAN}
{$IFDEF FHIR_INVOICE}
    function ParseInvoiceParticipant(jsn : TJsonObject) : TFhirInvoiceParticipant; overload; {b\}
    procedure ParseInvoiceParticipantProperties(jsn : TJsonObject; result : TFhirInvoiceParticipant); overload; {b\}
    procedure ParseInvoiceParticipant(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseInvoiceLineItem(jsn : TJsonObject) : TFhirInvoiceLineItem; overload; {b\}
    procedure ParseInvoiceLineItemProperties(jsn : TJsonObject; result : TFhirInvoiceLineItem); overload; {b\}
    procedure ParseInvoiceLineItem(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseInvoiceLineItemPriceComponent(jsn : TJsonObject) : TFhirInvoiceLineItemPriceComponent; overload; {b\}
    procedure ParseInvoiceLineItemPriceComponentProperties(jsn : TJsonObject; result : TFhirInvoiceLineItemPriceComponent); overload; {b\}
    procedure ParseInvoiceLineItemPriceComponent(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseInvoice(jsn : TJsonObject) : TFhirInvoice; overload;
    procedure ParseInvoiceProperties(jsn : TJsonObject; result : TFhirInvoice); overload;
    procedure ParseInvoice(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_INVOICE}
{$IFDEF FHIR_LIBRARY}
    function ParseLibrary(jsn : TJsonObject) : TFhirLibrary; overload;
    procedure ParseLibraryProperties(jsn : TJsonObject; result : TFhirLibrary); overload;
    procedure ParseLibrary(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_LIBRARY}
{$IFDEF FHIR_LINKAGE}
    function ParseLinkageItem(jsn : TJsonObject) : TFhirLinkageItem; overload; {b\}
    procedure ParseLinkageItemProperties(jsn : TJsonObject; result : TFhirLinkageItem); overload; {b\}
    procedure ParseLinkageItem(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseLinkage(jsn : TJsonObject) : TFhirLinkage; overload;
    procedure ParseLinkageProperties(jsn : TJsonObject; result : TFhirLinkage); overload;
    procedure ParseLinkage(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_LINKAGE}
{$IFDEF FHIR_LIST}
    function ParseListEntry(jsn : TJsonObject) : TFhirListEntry; overload; {b\}
    procedure ParseListEntryProperties(jsn : TJsonObject; result : TFhirListEntry); overload; {b\}
    procedure ParseListEntry(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseList(jsn : TJsonObject) : TFhirList; overload;
    procedure ParseListProperties(jsn : TJsonObject; result : TFhirList); overload;
    procedure ParseList(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_LIST}
{$IFDEF FHIR_LOCATION}
    function ParseLocationPosition(jsn : TJsonObject) : TFhirLocationPosition; overload; {b\}
    procedure ParseLocationPositionProperties(jsn : TJsonObject; result : TFhirLocationPosition); overload; {b\}
    procedure ParseLocationPosition(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseLocationHoursOfOperation(jsn : TJsonObject) : TFhirLocationHoursOfOperation; overload; {b\}
    procedure ParseLocationHoursOfOperationProperties(jsn : TJsonObject; result : TFhirLocationHoursOfOperation); overload; {b\}
    procedure ParseLocationHoursOfOperation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseLocation(jsn : TJsonObject) : TFhirLocation; overload;
    procedure ParseLocationProperties(jsn : TJsonObject; result : TFhirLocation); overload;
    procedure ParseLocation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_LOCATION}
{$IFDEF FHIR_MEASURE}
    function ParseMeasureGroup(jsn : TJsonObject) : TFhirMeasureGroup; overload; {b\}
    procedure ParseMeasureGroupProperties(jsn : TJsonObject; result : TFhirMeasureGroup); overload; {b\}
    procedure ParseMeasureGroup(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMeasureGroupPopulation(jsn : TJsonObject) : TFhirMeasureGroupPopulation; overload; {b\}
    procedure ParseMeasureGroupPopulationProperties(jsn : TJsonObject; result : TFhirMeasureGroupPopulation); overload; {b\}
    procedure ParseMeasureGroupPopulation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMeasureGroupStratifier(jsn : TJsonObject) : TFhirMeasureGroupStratifier; overload; {b\}
    procedure ParseMeasureGroupStratifierProperties(jsn : TJsonObject; result : TFhirMeasureGroupStratifier); overload; {b\}
    procedure ParseMeasureGroupStratifier(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMeasureGroupStratifierComponent(jsn : TJsonObject) : TFhirMeasureGroupStratifierComponent; overload; {b\}
    procedure ParseMeasureGroupStratifierComponentProperties(jsn : TJsonObject; result : TFhirMeasureGroupStratifierComponent); overload; {b\}
    procedure ParseMeasureGroupStratifierComponent(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMeasureSupplementalData(jsn : TJsonObject) : TFhirMeasureSupplementalData; overload; {b\}
    procedure ParseMeasureSupplementalDataProperties(jsn : TJsonObject; result : TFhirMeasureSupplementalData); overload; {b\}
    procedure ParseMeasureSupplementalData(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMeasure(jsn : TJsonObject) : TFhirMeasure; overload;
    procedure ParseMeasureProperties(jsn : TJsonObject; result : TFhirMeasure); overload;
    procedure ParseMeasure(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_MEASURE}
{$IFDEF FHIR_MEASUREREPORT}
    function ParseMeasureReportGroup(jsn : TJsonObject) : TFhirMeasureReportGroup; overload; {b\}
    procedure ParseMeasureReportGroupProperties(jsn : TJsonObject; result : TFhirMeasureReportGroup); overload; {b\}
    procedure ParseMeasureReportGroup(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMeasureReportGroupPopulation(jsn : TJsonObject) : TFhirMeasureReportGroupPopulation; overload; {b\}
    procedure ParseMeasureReportGroupPopulationProperties(jsn : TJsonObject; result : TFhirMeasureReportGroupPopulation); overload; {b\}
    procedure ParseMeasureReportGroupPopulation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMeasureReportGroupStratifier(jsn : TJsonObject) : TFhirMeasureReportGroupStratifier; overload; {b\}
    procedure ParseMeasureReportGroupStratifierProperties(jsn : TJsonObject; result : TFhirMeasureReportGroupStratifier); overload; {b\}
    procedure ParseMeasureReportGroupStratifier(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMeasureReportGroupStratifierStratum(jsn : TJsonObject) : TFhirMeasureReportGroupStratifierStratum; overload; {b\}
    procedure ParseMeasureReportGroupStratifierStratumProperties(jsn : TJsonObject; result : TFhirMeasureReportGroupStratifierStratum); overload; {b\}
    procedure ParseMeasureReportGroupStratifierStratum(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMeasureReportGroupStratifierStratumComponent(jsn : TJsonObject) : TFhirMeasureReportGroupStratifierStratumComponent; overload; {b\}
    procedure ParseMeasureReportGroupStratifierStratumComponentProperties(jsn : TJsonObject; result : TFhirMeasureReportGroupStratifierStratumComponent); overload; {b\}
    procedure ParseMeasureReportGroupStratifierStratumComponent(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMeasureReportGroupStratifierStratumPopulation(jsn : TJsonObject) : TFhirMeasureReportGroupStratifierStratumPopulation; overload; {b\}
    procedure ParseMeasureReportGroupStratifierStratumPopulationProperties(jsn : TJsonObject; result : TFhirMeasureReportGroupStratifierStratumPopulation); overload; {b\}
    procedure ParseMeasureReportGroupStratifierStratumPopulation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMeasureReport(jsn : TJsonObject) : TFhirMeasureReport; overload;
    procedure ParseMeasureReportProperties(jsn : TJsonObject; result : TFhirMeasureReport); overload;
    procedure ParseMeasureReport(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_MEASUREREPORT}
{$IFDEF FHIR_MEDIA}
    function ParseMedia(jsn : TJsonObject) : TFhirMedia; overload;
    procedure ParseMediaProperties(jsn : TJsonObject; result : TFhirMedia); overload;
    procedure ParseMedia(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_MEDIA}
{$IFDEF FHIR_MEDICATION}
    function ParseMedicationIngredient(jsn : TJsonObject) : TFhirMedicationIngredient; overload; {b\}
    procedure ParseMedicationIngredientProperties(jsn : TJsonObject; result : TFhirMedicationIngredient); overload; {b\}
    procedure ParseMedicationIngredient(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationBatch(jsn : TJsonObject) : TFhirMedicationBatch; overload; {b\}
    procedure ParseMedicationBatchProperties(jsn : TJsonObject; result : TFhirMedicationBatch); overload; {b\}
    procedure ParseMedicationBatch(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedication(jsn : TJsonObject) : TFhirMedication; overload;
    procedure ParseMedicationProperties(jsn : TJsonObject; result : TFhirMedication); overload;
    procedure ParseMedication(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_MEDICATION}
{$IFDEF FHIR_MEDICATIONADMINISTRATION}
    function ParseMedicationAdministrationPerformer(jsn : TJsonObject) : TFhirMedicationAdministrationPerformer; overload; {b\}
    procedure ParseMedicationAdministrationPerformerProperties(jsn : TJsonObject; result : TFhirMedicationAdministrationPerformer); overload; {b\}
    procedure ParseMedicationAdministrationPerformer(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationAdministrationDosage(jsn : TJsonObject) : TFhirMedicationAdministrationDosage; overload; {b\}
    procedure ParseMedicationAdministrationDosageProperties(jsn : TJsonObject; result : TFhirMedicationAdministrationDosage); overload; {b\}
    procedure ParseMedicationAdministrationDosage(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationAdministration(jsn : TJsonObject) : TFhirMedicationAdministration; overload;
    procedure ParseMedicationAdministrationProperties(jsn : TJsonObject; result : TFhirMedicationAdministration); overload;
    procedure ParseMedicationAdministration(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_MEDICATIONADMINISTRATION}
{$IFDEF FHIR_MEDICATIONDISPENSE}
    function ParseMedicationDispensePerformer(jsn : TJsonObject) : TFhirMedicationDispensePerformer; overload; {b\}
    procedure ParseMedicationDispensePerformerProperties(jsn : TJsonObject; result : TFhirMedicationDispensePerformer); overload; {b\}
    procedure ParseMedicationDispensePerformer(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationDispenseSubstitution(jsn : TJsonObject) : TFhirMedicationDispenseSubstitution; overload; {b\}
    procedure ParseMedicationDispenseSubstitutionProperties(jsn : TJsonObject; result : TFhirMedicationDispenseSubstitution); overload; {b\}
    procedure ParseMedicationDispenseSubstitution(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationDispense(jsn : TJsonObject) : TFhirMedicationDispense; overload;
    procedure ParseMedicationDispenseProperties(jsn : TJsonObject; result : TFhirMedicationDispense); overload;
    procedure ParseMedicationDispense(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_MEDICATIONDISPENSE}
{$IFDEF FHIR_MEDICATIONKNOWLEDGE}
    function ParseMedicationKnowledgeRelatedMedicationKnowledge(jsn : TJsonObject) : TFhirMedicationKnowledgeRelatedMedicationKnowledge; overload; {b\}
    procedure ParseMedicationKnowledgeRelatedMedicationKnowledgeProperties(jsn : TJsonObject; result : TFhirMedicationKnowledgeRelatedMedicationKnowledge); overload; {b\}
    procedure ParseMedicationKnowledgeRelatedMedicationKnowledge(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationKnowledgeMonograph(jsn : TJsonObject) : TFhirMedicationKnowledgeMonograph; overload; {b\}
    procedure ParseMedicationKnowledgeMonographProperties(jsn : TJsonObject; result : TFhirMedicationKnowledgeMonograph); overload; {b\}
    procedure ParseMedicationKnowledgeMonograph(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationKnowledgeIngredient(jsn : TJsonObject) : TFhirMedicationKnowledgeIngredient; overload; {b\}
    procedure ParseMedicationKnowledgeIngredientProperties(jsn : TJsonObject; result : TFhirMedicationKnowledgeIngredient); overload; {b\}
    procedure ParseMedicationKnowledgeIngredient(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationKnowledgeCost(jsn : TJsonObject) : TFhirMedicationKnowledgeCost; overload; {b\}
    procedure ParseMedicationKnowledgeCostProperties(jsn : TJsonObject; result : TFhirMedicationKnowledgeCost); overload; {b\}
    procedure ParseMedicationKnowledgeCost(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationKnowledgeMonitoringProgram(jsn : TJsonObject) : TFhirMedicationKnowledgeMonitoringProgram; overload; {b\}
    procedure ParseMedicationKnowledgeMonitoringProgramProperties(jsn : TJsonObject; result : TFhirMedicationKnowledgeMonitoringProgram); overload; {b\}
    procedure ParseMedicationKnowledgeMonitoringProgram(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationKnowledgeAdministrationGuidelines(jsn : TJsonObject) : TFhirMedicationKnowledgeAdministrationGuidelines; overload; {b\}
    procedure ParseMedicationKnowledgeAdministrationGuidelinesProperties(jsn : TJsonObject; result : TFhirMedicationKnowledgeAdministrationGuidelines); overload; {b\}
    procedure ParseMedicationKnowledgeAdministrationGuidelines(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationKnowledgeAdministrationGuidelinesDosage(jsn : TJsonObject) : TFhirMedicationKnowledgeAdministrationGuidelinesDosage; overload; {b\}
    procedure ParseMedicationKnowledgeAdministrationGuidelinesDosageProperties(jsn : TJsonObject; result : TFhirMedicationKnowledgeAdministrationGuidelinesDosage); overload; {b\}
    procedure ParseMedicationKnowledgeAdministrationGuidelinesDosage(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics(jsn : TJsonObject) : TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics; overload; {b\}
    procedure ParseMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsProperties(jsn : TJsonObject; result : TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics); overload; {b\}
    procedure ParseMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationKnowledgeMedicineClassification(jsn : TJsonObject) : TFhirMedicationKnowledgeMedicineClassification; overload; {b\}
    procedure ParseMedicationKnowledgeMedicineClassificationProperties(jsn : TJsonObject; result : TFhirMedicationKnowledgeMedicineClassification); overload; {b\}
    procedure ParseMedicationKnowledgeMedicineClassification(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationKnowledgePackaging(jsn : TJsonObject) : TFhirMedicationKnowledgePackaging; overload; {b\}
    procedure ParseMedicationKnowledgePackagingProperties(jsn : TJsonObject; result : TFhirMedicationKnowledgePackaging); overload; {b\}
    procedure ParseMedicationKnowledgePackaging(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationKnowledgeDrugCharacteristic(jsn : TJsonObject) : TFhirMedicationKnowledgeDrugCharacteristic; overload; {b\}
    procedure ParseMedicationKnowledgeDrugCharacteristicProperties(jsn : TJsonObject; result : TFhirMedicationKnowledgeDrugCharacteristic); overload; {b\}
    procedure ParseMedicationKnowledgeDrugCharacteristic(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationKnowledgeRegulatory(jsn : TJsonObject) : TFhirMedicationKnowledgeRegulatory; overload; {b\}
    procedure ParseMedicationKnowledgeRegulatoryProperties(jsn : TJsonObject; result : TFhirMedicationKnowledgeRegulatory); overload; {b\}
    procedure ParseMedicationKnowledgeRegulatory(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationKnowledgeRegulatorySubstitution(jsn : TJsonObject) : TFhirMedicationKnowledgeRegulatorySubstitution; overload; {b\}
    procedure ParseMedicationKnowledgeRegulatorySubstitutionProperties(jsn : TJsonObject; result : TFhirMedicationKnowledgeRegulatorySubstitution); overload; {b\}
    procedure ParseMedicationKnowledgeRegulatorySubstitution(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationKnowledgeRegulatorySchedule(jsn : TJsonObject) : TFhirMedicationKnowledgeRegulatorySchedule; overload; {b\}
    procedure ParseMedicationKnowledgeRegulatoryScheduleProperties(jsn : TJsonObject; result : TFhirMedicationKnowledgeRegulatorySchedule); overload; {b\}
    procedure ParseMedicationKnowledgeRegulatorySchedule(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationKnowledgeRegulatoryMaxDispense(jsn : TJsonObject) : TFhirMedicationKnowledgeRegulatoryMaxDispense; overload; {b\}
    procedure ParseMedicationKnowledgeRegulatoryMaxDispenseProperties(jsn : TJsonObject; result : TFhirMedicationKnowledgeRegulatoryMaxDispense); overload; {b\}
    procedure ParseMedicationKnowledgeRegulatoryMaxDispense(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationKnowledgeKinetics(jsn : TJsonObject) : TFhirMedicationKnowledgeKinetics; overload; {b\}
    procedure ParseMedicationKnowledgeKineticsProperties(jsn : TJsonObject; result : TFhirMedicationKnowledgeKinetics); overload; {b\}
    procedure ParseMedicationKnowledgeKinetics(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationKnowledge(jsn : TJsonObject) : TFhirMedicationKnowledge; overload;
    procedure ParseMedicationKnowledgeProperties(jsn : TJsonObject; result : TFhirMedicationKnowledge); overload;
    procedure ParseMedicationKnowledge(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_MEDICATIONKNOWLEDGE}
{$IFDEF FHIR_MEDICATIONREQUEST}
    function ParseMedicationRequestDispenseRequest(jsn : TJsonObject) : TFhirMedicationRequestDispenseRequest; overload; {b\}
    procedure ParseMedicationRequestDispenseRequestProperties(jsn : TJsonObject; result : TFhirMedicationRequestDispenseRequest); overload; {b\}
    procedure ParseMedicationRequestDispenseRequest(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationRequestDispenseRequestInitialFill(jsn : TJsonObject) : TFhirMedicationRequestDispenseRequestInitialFill; overload; {b\}
    procedure ParseMedicationRequestDispenseRequestInitialFillProperties(jsn : TJsonObject; result : TFhirMedicationRequestDispenseRequestInitialFill); overload; {b\}
    procedure ParseMedicationRequestDispenseRequestInitialFill(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationRequestSubstitution(jsn : TJsonObject) : TFhirMedicationRequestSubstitution; overload; {b\}
    procedure ParseMedicationRequestSubstitutionProperties(jsn : TJsonObject; result : TFhirMedicationRequestSubstitution); overload; {b\}
    procedure ParseMedicationRequestSubstitution(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationRequest(jsn : TJsonObject) : TFhirMedicationRequest; overload;
    procedure ParseMedicationRequestProperties(jsn : TJsonObject; result : TFhirMedicationRequest); overload;
    procedure ParseMedicationRequest(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_MEDICATIONREQUEST}
{$IFDEF FHIR_MEDICATIONSTATEMENT}
    function ParseMedicationStatement(jsn : TJsonObject) : TFhirMedicationStatement; overload;
    procedure ParseMedicationStatementProperties(jsn : TJsonObject; result : TFhirMedicationStatement); overload;
    procedure ParseMedicationStatement(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_MEDICATIONSTATEMENT}
{$IFDEF FHIR_MEDICINALPRODUCT}
    function ParseMedicinalProductName(jsn : TJsonObject) : TFhirMedicinalProductName; overload; {b\}
    procedure ParseMedicinalProductNameProperties(jsn : TJsonObject; result : TFhirMedicinalProductName); overload; {b\}
    procedure ParseMedicinalProductName(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicinalProductNameNamePart(jsn : TJsonObject) : TFhirMedicinalProductNameNamePart; overload; {b\}
    procedure ParseMedicinalProductNameNamePartProperties(jsn : TJsonObject; result : TFhirMedicinalProductNameNamePart); overload; {b\}
    procedure ParseMedicinalProductNameNamePart(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicinalProductNameCountryLanguage(jsn : TJsonObject) : TFhirMedicinalProductNameCountryLanguage; overload; {b\}
    procedure ParseMedicinalProductNameCountryLanguageProperties(jsn : TJsonObject; result : TFhirMedicinalProductNameCountryLanguage); overload; {b\}
    procedure ParseMedicinalProductNameCountryLanguage(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicinalProductManufacturingBusinessOperation(jsn : TJsonObject) : TFhirMedicinalProductManufacturingBusinessOperation; overload; {b\}
    procedure ParseMedicinalProductManufacturingBusinessOperationProperties(jsn : TJsonObject; result : TFhirMedicinalProductManufacturingBusinessOperation); overload; {b\}
    procedure ParseMedicinalProductManufacturingBusinessOperation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicinalProductSpecialDesignation(jsn : TJsonObject) : TFhirMedicinalProductSpecialDesignation; overload; {b\}
    procedure ParseMedicinalProductSpecialDesignationProperties(jsn : TJsonObject; result : TFhirMedicinalProductSpecialDesignation); overload; {b\}
    procedure ParseMedicinalProductSpecialDesignation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicinalProduct(jsn : TJsonObject) : TFhirMedicinalProduct; overload;
    procedure ParseMedicinalProductProperties(jsn : TJsonObject; result : TFhirMedicinalProduct); overload;
    procedure ParseMedicinalProduct(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_MEDICINALPRODUCT}
{$IFDEF FHIR_MEDICINALPRODUCTAUTHORIZATION}
    function ParseMedicinalProductAuthorizationJurisdictionalAuthorization(jsn : TJsonObject) : TFhirMedicinalProductAuthorizationJurisdictionalAuthorization; overload; {b\}
    procedure ParseMedicinalProductAuthorizationJurisdictionalAuthorizationProperties(jsn : TJsonObject; result : TFhirMedicinalProductAuthorizationJurisdictionalAuthorization); overload; {b\}
    procedure ParseMedicinalProductAuthorizationJurisdictionalAuthorization(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicinalProductAuthorizationProcedure(jsn : TJsonObject) : TFhirMedicinalProductAuthorizationProcedure; overload; {b\}
    procedure ParseMedicinalProductAuthorizationProcedureProperties(jsn : TJsonObject; result : TFhirMedicinalProductAuthorizationProcedure); overload; {b\}
    procedure ParseMedicinalProductAuthorizationProcedure(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicinalProductAuthorization(jsn : TJsonObject) : TFhirMedicinalProductAuthorization; overload;
    procedure ParseMedicinalProductAuthorizationProperties(jsn : TJsonObject; result : TFhirMedicinalProductAuthorization); overload;
    procedure ParseMedicinalProductAuthorization(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_MEDICINALPRODUCTAUTHORIZATION}
{$IFDEF FHIR_MEDICINALPRODUCTCONTRAINDICATION}
    function ParseMedicinalProductContraindicationOtherTherapy(jsn : TJsonObject) : TFhirMedicinalProductContraindicationOtherTherapy; overload; {b\}
    procedure ParseMedicinalProductContraindicationOtherTherapyProperties(jsn : TJsonObject; result : TFhirMedicinalProductContraindicationOtherTherapy); overload; {b\}
    procedure ParseMedicinalProductContraindicationOtherTherapy(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicinalProductContraindication(jsn : TJsonObject) : TFhirMedicinalProductContraindication; overload;
    procedure ParseMedicinalProductContraindicationProperties(jsn : TJsonObject; result : TFhirMedicinalProductContraindication); overload;
    procedure ParseMedicinalProductContraindication(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_MEDICINALPRODUCTCONTRAINDICATION}
{$IFDEF FHIR_MEDICINALPRODUCTINDICATION}
    function ParseMedicinalProductIndicationOtherTherapy(jsn : TJsonObject) : TFhirMedicinalProductIndicationOtherTherapy; overload; {b\}
    procedure ParseMedicinalProductIndicationOtherTherapyProperties(jsn : TJsonObject; result : TFhirMedicinalProductIndicationOtherTherapy); overload; {b\}
    procedure ParseMedicinalProductIndicationOtherTherapy(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicinalProductIndication(jsn : TJsonObject) : TFhirMedicinalProductIndication; overload;
    procedure ParseMedicinalProductIndicationProperties(jsn : TJsonObject; result : TFhirMedicinalProductIndication); overload;
    procedure ParseMedicinalProductIndication(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_MEDICINALPRODUCTINDICATION}
{$IFDEF FHIR_MEDICINALPRODUCTINGREDIENT}
    function ParseMedicinalProductIngredientSpecifiedSubstance(jsn : TJsonObject) : TFhirMedicinalProductIngredientSpecifiedSubstance; overload; {b\}
    procedure ParseMedicinalProductIngredientSpecifiedSubstanceProperties(jsn : TJsonObject; result : TFhirMedicinalProductIngredientSpecifiedSubstance); overload; {b\}
    procedure ParseMedicinalProductIngredientSpecifiedSubstance(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicinalProductIngredientSpecifiedSubstanceStrength(jsn : TJsonObject) : TFhirMedicinalProductIngredientSpecifiedSubstanceStrength; overload; {b\}
    procedure ParseMedicinalProductIngredientSpecifiedSubstanceStrengthProperties(jsn : TJsonObject; result : TFhirMedicinalProductIngredientSpecifiedSubstanceStrength); overload; {b\}
    procedure ParseMedicinalProductIngredientSpecifiedSubstanceStrength(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength(jsn : TJsonObject) : TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength; overload; {b\}
    procedure ParseMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrengthProperties(jsn : TJsonObject; result : TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength); overload; {b\}
    procedure ParseMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicinalProductIngredientSubstance(jsn : TJsonObject) : TFhirMedicinalProductIngredientSubstance; overload; {b\}
    procedure ParseMedicinalProductIngredientSubstanceProperties(jsn : TJsonObject; result : TFhirMedicinalProductIngredientSubstance); overload; {b\}
    procedure ParseMedicinalProductIngredientSubstance(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicinalProductIngredient(jsn : TJsonObject) : TFhirMedicinalProductIngredient; overload;
    procedure ParseMedicinalProductIngredientProperties(jsn : TJsonObject; result : TFhirMedicinalProductIngredient); overload;
    procedure ParseMedicinalProductIngredient(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_MEDICINALPRODUCTINGREDIENT}
{$IFDEF FHIR_MEDICINALPRODUCTINTERACTION}
    function ParseMedicinalProductInteractionInteractant(jsn : TJsonObject) : TFhirMedicinalProductInteractionInteractant; overload; {b\}
    procedure ParseMedicinalProductInteractionInteractantProperties(jsn : TJsonObject; result : TFhirMedicinalProductInteractionInteractant); overload; {b\}
    procedure ParseMedicinalProductInteractionInteractant(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicinalProductInteraction(jsn : TJsonObject) : TFhirMedicinalProductInteraction; overload;
    procedure ParseMedicinalProductInteractionProperties(jsn : TJsonObject; result : TFhirMedicinalProductInteraction); overload;
    procedure ParseMedicinalProductInteraction(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_MEDICINALPRODUCTINTERACTION}
{$IFDEF FHIR_MEDICINALPRODUCTMANUFACTURED}
    function ParseMedicinalProductManufactured(jsn : TJsonObject) : TFhirMedicinalProductManufactured; overload;
    procedure ParseMedicinalProductManufacturedProperties(jsn : TJsonObject; result : TFhirMedicinalProductManufactured); overload;
    procedure ParseMedicinalProductManufactured(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_MEDICINALPRODUCTMANUFACTURED}
{$IFDEF FHIR_MEDICINALPRODUCTPACKAGED}
    function ParseMedicinalProductPackagedBatchIdentifier(jsn : TJsonObject) : TFhirMedicinalProductPackagedBatchIdentifier; overload; {b\}
    procedure ParseMedicinalProductPackagedBatchIdentifierProperties(jsn : TJsonObject; result : TFhirMedicinalProductPackagedBatchIdentifier); overload; {b\}
    procedure ParseMedicinalProductPackagedBatchIdentifier(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicinalProductPackagedPackageItem(jsn : TJsonObject) : TFhirMedicinalProductPackagedPackageItem; overload; {b\}
    procedure ParseMedicinalProductPackagedPackageItemProperties(jsn : TJsonObject; result : TFhirMedicinalProductPackagedPackageItem); overload; {b\}
    procedure ParseMedicinalProductPackagedPackageItem(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicinalProductPackaged(jsn : TJsonObject) : TFhirMedicinalProductPackaged; overload;
    procedure ParseMedicinalProductPackagedProperties(jsn : TJsonObject; result : TFhirMedicinalProductPackaged); overload;
    procedure ParseMedicinalProductPackaged(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_MEDICINALPRODUCTPACKAGED}
{$IFDEF FHIR_MEDICINALPRODUCTPHARMACEUTICAL}
    function ParseMedicinalProductPharmaceuticalCharacteristics(jsn : TJsonObject) : TFhirMedicinalProductPharmaceuticalCharacteristics; overload; {b\}
    procedure ParseMedicinalProductPharmaceuticalCharacteristicsProperties(jsn : TJsonObject; result : TFhirMedicinalProductPharmaceuticalCharacteristics); overload; {b\}
    procedure ParseMedicinalProductPharmaceuticalCharacteristics(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicinalProductPharmaceuticalRouteOfAdministration(jsn : TJsonObject) : TFhirMedicinalProductPharmaceuticalRouteOfAdministration; overload; {b\}
    procedure ParseMedicinalProductPharmaceuticalRouteOfAdministrationProperties(jsn : TJsonObject; result : TFhirMedicinalProductPharmaceuticalRouteOfAdministration); overload; {b\}
    procedure ParseMedicinalProductPharmaceuticalRouteOfAdministration(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies(jsn : TJsonObject) : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies; overload; {b\}
    procedure ParseMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesProperties(jsn : TJsonObject; result : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies); overload; {b\}
    procedure ParseMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod(jsn : TJsonObject) : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod; overload; {b\}
    procedure ParseMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriodProperties(jsn : TJsonObject; result : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod); overload; {b\}
    procedure ParseMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicinalProductPharmaceutical(jsn : TJsonObject) : TFhirMedicinalProductPharmaceutical; overload;
    procedure ParseMedicinalProductPharmaceuticalProperties(jsn : TJsonObject; result : TFhirMedicinalProductPharmaceutical); overload;
    procedure ParseMedicinalProductPharmaceutical(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_MEDICINALPRODUCTPHARMACEUTICAL}
{$IFDEF FHIR_MEDICINALPRODUCTUNDESIRABLEEFFECT}
    function ParseMedicinalProductUndesirableEffect(jsn : TJsonObject) : TFhirMedicinalProductUndesirableEffect; overload;
    procedure ParseMedicinalProductUndesirableEffectProperties(jsn : TJsonObject; result : TFhirMedicinalProductUndesirableEffect); overload;
    procedure ParseMedicinalProductUndesirableEffect(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_MEDICINALPRODUCTUNDESIRABLEEFFECT}
{$IFDEF FHIR_MESSAGEDEFINITION}
    function ParseMessageDefinitionFocus(jsn : TJsonObject) : TFhirMessageDefinitionFocus; overload; {b\}
    procedure ParseMessageDefinitionFocusProperties(jsn : TJsonObject; result : TFhirMessageDefinitionFocus); overload; {b\}
    procedure ParseMessageDefinitionFocus(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMessageDefinitionAllowedResponse(jsn : TJsonObject) : TFhirMessageDefinitionAllowedResponse; overload; {b\}
    procedure ParseMessageDefinitionAllowedResponseProperties(jsn : TJsonObject; result : TFhirMessageDefinitionAllowedResponse); overload; {b\}
    procedure ParseMessageDefinitionAllowedResponse(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMessageDefinition(jsn : TJsonObject) : TFhirMessageDefinition; overload;
    procedure ParseMessageDefinitionProperties(jsn : TJsonObject; result : TFhirMessageDefinition); overload;
    procedure ParseMessageDefinition(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_MESSAGEDEFINITION}
{$IFDEF FHIR_MESSAGEHEADER}
    function ParseMessageHeaderDestination(jsn : TJsonObject) : TFhirMessageHeaderDestination; overload; {b\}
    procedure ParseMessageHeaderDestinationProperties(jsn : TJsonObject; result : TFhirMessageHeaderDestination); overload; {b\}
    procedure ParseMessageHeaderDestination(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMessageHeaderSource(jsn : TJsonObject) : TFhirMessageHeaderSource; overload; {b\}
    procedure ParseMessageHeaderSourceProperties(jsn : TJsonObject; result : TFhirMessageHeaderSource); overload; {b\}
    procedure ParseMessageHeaderSource(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMessageHeaderResponse(jsn : TJsonObject) : TFhirMessageHeaderResponse; overload; {b\}
    procedure ParseMessageHeaderResponseProperties(jsn : TJsonObject; result : TFhirMessageHeaderResponse); overload; {b\}
    procedure ParseMessageHeaderResponse(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMessageHeader(jsn : TJsonObject) : TFhirMessageHeader; overload;
    procedure ParseMessageHeaderProperties(jsn : TJsonObject; result : TFhirMessageHeader); overload;
    procedure ParseMessageHeader(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_MESSAGEHEADER}
{$IFDEF FHIR_MOLECULARSEQUENCE}
    function ParseMolecularSequenceReferenceSeq(jsn : TJsonObject) : TFhirMolecularSequenceReferenceSeq; overload; {b\}
    procedure ParseMolecularSequenceReferenceSeqProperties(jsn : TJsonObject; result : TFhirMolecularSequenceReferenceSeq); overload; {b\}
    procedure ParseMolecularSequenceReferenceSeq(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMolecularSequenceVariant(jsn : TJsonObject) : TFhirMolecularSequenceVariant; overload; {b\}
    procedure ParseMolecularSequenceVariantProperties(jsn : TJsonObject; result : TFhirMolecularSequenceVariant); overload; {b\}
    procedure ParseMolecularSequenceVariant(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMolecularSequenceQuality(jsn : TJsonObject) : TFhirMolecularSequenceQuality; overload; {b\}
    procedure ParseMolecularSequenceQualityProperties(jsn : TJsonObject; result : TFhirMolecularSequenceQuality); overload; {b\}
    procedure ParseMolecularSequenceQuality(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMolecularSequenceQualityRoc(jsn : TJsonObject) : TFhirMolecularSequenceQualityRoc; overload; {b\}
    procedure ParseMolecularSequenceQualityRocProperties(jsn : TJsonObject; result : TFhirMolecularSequenceQualityRoc); overload; {b\}
    procedure ParseMolecularSequenceQualityRoc(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMolecularSequenceRepository(jsn : TJsonObject) : TFhirMolecularSequenceRepository; overload; {b\}
    procedure ParseMolecularSequenceRepositoryProperties(jsn : TJsonObject; result : TFhirMolecularSequenceRepository); overload; {b\}
    procedure ParseMolecularSequenceRepository(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMolecularSequenceStructureVariant(jsn : TJsonObject) : TFhirMolecularSequenceStructureVariant; overload; {b\}
    procedure ParseMolecularSequenceStructureVariantProperties(jsn : TJsonObject; result : TFhirMolecularSequenceStructureVariant); overload; {b\}
    procedure ParseMolecularSequenceStructureVariant(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMolecularSequenceStructureVariantOuter(jsn : TJsonObject) : TFhirMolecularSequenceStructureVariantOuter; overload; {b\}
    procedure ParseMolecularSequenceStructureVariantOuterProperties(jsn : TJsonObject; result : TFhirMolecularSequenceStructureVariantOuter); overload; {b\}
    procedure ParseMolecularSequenceStructureVariantOuter(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMolecularSequenceStructureVariantInner(jsn : TJsonObject) : TFhirMolecularSequenceStructureVariantInner; overload; {b\}
    procedure ParseMolecularSequenceStructureVariantInnerProperties(jsn : TJsonObject; result : TFhirMolecularSequenceStructureVariantInner); overload; {b\}
    procedure ParseMolecularSequenceStructureVariantInner(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMolecularSequence(jsn : TJsonObject) : TFhirMolecularSequence; overload;
    procedure ParseMolecularSequenceProperties(jsn : TJsonObject; result : TFhirMolecularSequence); overload;
    procedure ParseMolecularSequence(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_MOLECULARSEQUENCE}
{$IFDEF FHIR_NAMINGSYSTEM}
    function ParseNamingSystemUniqueId(jsn : TJsonObject) : TFhirNamingSystemUniqueId; overload; {b\}
    procedure ParseNamingSystemUniqueIdProperties(jsn : TJsonObject; result : TFhirNamingSystemUniqueId); overload; {b\}
    procedure ParseNamingSystemUniqueId(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseNamingSystem(jsn : TJsonObject) : TFhirNamingSystem; overload;
    procedure ParseNamingSystemProperties(jsn : TJsonObject; result : TFhirNamingSystem); overload;
    procedure ParseNamingSystem(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_NAMINGSYSTEM}
{$IFDEF FHIR_NUTRITIONORDER}
    function ParseNutritionOrderOralDiet(jsn : TJsonObject) : TFhirNutritionOrderOralDiet; overload; {b\}
    procedure ParseNutritionOrderOralDietProperties(jsn : TJsonObject; result : TFhirNutritionOrderOralDiet); overload; {b\}
    procedure ParseNutritionOrderOralDiet(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseNutritionOrderOralDietNutrient(jsn : TJsonObject) : TFhirNutritionOrderOralDietNutrient; overload; {b\}
    procedure ParseNutritionOrderOralDietNutrientProperties(jsn : TJsonObject; result : TFhirNutritionOrderOralDietNutrient); overload; {b\}
    procedure ParseNutritionOrderOralDietNutrient(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseNutritionOrderOralDietTexture(jsn : TJsonObject) : TFhirNutritionOrderOralDietTexture; overload; {b\}
    procedure ParseNutritionOrderOralDietTextureProperties(jsn : TJsonObject; result : TFhirNutritionOrderOralDietTexture); overload; {b\}
    procedure ParseNutritionOrderOralDietTexture(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseNutritionOrderSupplement(jsn : TJsonObject) : TFhirNutritionOrderSupplement; overload; {b\}
    procedure ParseNutritionOrderSupplementProperties(jsn : TJsonObject; result : TFhirNutritionOrderSupplement); overload; {b\}
    procedure ParseNutritionOrderSupplement(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseNutritionOrderEnteralFormula(jsn : TJsonObject) : TFhirNutritionOrderEnteralFormula; overload; {b\}
    procedure ParseNutritionOrderEnteralFormulaProperties(jsn : TJsonObject; result : TFhirNutritionOrderEnteralFormula); overload; {b\}
    procedure ParseNutritionOrderEnteralFormula(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseNutritionOrderEnteralFormulaAdministration(jsn : TJsonObject) : TFhirNutritionOrderEnteralFormulaAdministration; overload; {b\}
    procedure ParseNutritionOrderEnteralFormulaAdministrationProperties(jsn : TJsonObject; result : TFhirNutritionOrderEnteralFormulaAdministration); overload; {b\}
    procedure ParseNutritionOrderEnteralFormulaAdministration(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseNutritionOrder(jsn : TJsonObject) : TFhirNutritionOrder; overload;
    procedure ParseNutritionOrderProperties(jsn : TJsonObject; result : TFhirNutritionOrder); overload;
    procedure ParseNutritionOrder(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_NUTRITIONORDER}
{$IFDEF FHIR_OBSERVATION}
    function ParseObservationReferenceRange(jsn : TJsonObject) : TFhirObservationReferenceRange; overload; {b\}
    procedure ParseObservationReferenceRangeProperties(jsn : TJsonObject; result : TFhirObservationReferenceRange); overload; {b\}
    procedure ParseObservationReferenceRange(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseObservationComponent(jsn : TJsonObject) : TFhirObservationComponent; overload; {b\}
    procedure ParseObservationComponentProperties(jsn : TJsonObject; result : TFhirObservationComponent); overload; {b\}
    procedure ParseObservationComponent(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseObservation(jsn : TJsonObject) : TFhirObservation; overload;
    procedure ParseObservationProperties(jsn : TJsonObject; result : TFhirObservation); overload;
    procedure ParseObservation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_OBSERVATION}
{$IFDEF FHIR_OBSERVATIONDEFINITION}
    function ParseObservationDefinitionQuantitativeDetails(jsn : TJsonObject) : TFhirObservationDefinitionQuantitativeDetails; overload; {b\}
    procedure ParseObservationDefinitionQuantitativeDetailsProperties(jsn : TJsonObject; result : TFhirObservationDefinitionQuantitativeDetails); overload; {b\}
    procedure ParseObservationDefinitionQuantitativeDetails(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseObservationDefinitionQualifiedInterval(jsn : TJsonObject) : TFhirObservationDefinitionQualifiedInterval; overload; {b\}
    procedure ParseObservationDefinitionQualifiedIntervalProperties(jsn : TJsonObject; result : TFhirObservationDefinitionQualifiedInterval); overload; {b\}
    procedure ParseObservationDefinitionQualifiedInterval(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseObservationDefinition(jsn : TJsonObject) : TFhirObservationDefinition; overload;
    procedure ParseObservationDefinitionProperties(jsn : TJsonObject; result : TFhirObservationDefinition); overload;
    procedure ParseObservationDefinition(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_OBSERVATIONDEFINITION}
{$IFDEF FHIR_OPERATIONDEFINITION}
    function ParseOperationDefinitionParameter(jsn : TJsonObject) : TFhirOperationDefinitionParameter; overload; {b\}
    procedure ParseOperationDefinitionParameterProperties(jsn : TJsonObject; result : TFhirOperationDefinitionParameter); overload; {b\}
    procedure ParseOperationDefinitionParameter(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseOperationDefinitionParameterBinding(jsn : TJsonObject) : TFhirOperationDefinitionParameterBinding; overload; {b\}
    procedure ParseOperationDefinitionParameterBindingProperties(jsn : TJsonObject; result : TFhirOperationDefinitionParameterBinding); overload; {b\}
    procedure ParseOperationDefinitionParameterBinding(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseOperationDefinitionParameterReferencedFrom(jsn : TJsonObject) : TFhirOperationDefinitionParameterReferencedFrom; overload; {b\}
    procedure ParseOperationDefinitionParameterReferencedFromProperties(jsn : TJsonObject; result : TFhirOperationDefinitionParameterReferencedFrom); overload; {b\}
    procedure ParseOperationDefinitionParameterReferencedFrom(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseOperationDefinitionOverload(jsn : TJsonObject) : TFhirOperationDefinitionOverload; overload; {b\}
    procedure ParseOperationDefinitionOverloadProperties(jsn : TJsonObject; result : TFhirOperationDefinitionOverload); overload; {b\}
    procedure ParseOperationDefinitionOverload(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseOperationDefinition(jsn : TJsonObject) : TFhirOperationDefinition; overload;
    procedure ParseOperationDefinitionProperties(jsn : TJsonObject; result : TFhirOperationDefinition); overload;
    procedure ParseOperationDefinition(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_OPERATIONDEFINITION}
{$IFDEF FHIR_OPERATIONOUTCOME}
    function ParseOperationOutcomeIssue(jsn : TJsonObject) : TFhirOperationOutcomeIssue; overload; {b\}
    procedure ParseOperationOutcomeIssueProperties(jsn : TJsonObject; result : TFhirOperationOutcomeIssue); overload; {b\}
    procedure ParseOperationOutcomeIssue(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseOperationOutcome(jsn : TJsonObject) : TFhirOperationOutcome; overload;
    procedure ParseOperationOutcomeProperties(jsn : TJsonObject; result : TFhirOperationOutcome); overload;
    procedure ParseOperationOutcome(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_OPERATIONOUTCOME}
{$IFDEF FHIR_ORGANIZATION}
    function ParseOrganizationContact(jsn : TJsonObject) : TFhirOrganizationContact; overload; {b\}
    procedure ParseOrganizationContactProperties(jsn : TJsonObject; result : TFhirOrganizationContact); overload; {b\}
    procedure ParseOrganizationContact(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseOrganization(jsn : TJsonObject) : TFhirOrganization; overload;
    procedure ParseOrganizationProperties(jsn : TJsonObject; result : TFhirOrganization); overload;
    procedure ParseOrganization(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_ORGANIZATION}
{$IFDEF FHIR_ORGANIZATIONAFFILIATION}
    function ParseOrganizationAffiliation(jsn : TJsonObject) : TFhirOrganizationAffiliation; overload;
    procedure ParseOrganizationAffiliationProperties(jsn : TJsonObject; result : TFhirOrganizationAffiliation); overload;
    procedure ParseOrganizationAffiliation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_ORGANIZATIONAFFILIATION}
{$IFDEF FHIR_PATIENT}
    function ParsePatientContact(jsn : TJsonObject) : TFhirPatientContact; overload; {b\}
    procedure ParsePatientContactProperties(jsn : TJsonObject; result : TFhirPatientContact); overload; {b\}
    procedure ParsePatientContact(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParsePatientCommunication(jsn : TJsonObject) : TFhirPatientCommunication; overload; {b\}
    procedure ParsePatientCommunicationProperties(jsn : TJsonObject; result : TFhirPatientCommunication); overload; {b\}
    procedure ParsePatientCommunication(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParsePatientLink(jsn : TJsonObject) : TFhirPatientLink; overload; {b\}
    procedure ParsePatientLinkProperties(jsn : TJsonObject; result : TFhirPatientLink); overload; {b\}
    procedure ParsePatientLink(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParsePatient(jsn : TJsonObject) : TFhirPatient; overload;
    procedure ParsePatientProperties(jsn : TJsonObject; result : TFhirPatient); overload;
    procedure ParsePatient(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_PATIENT}
{$IFDEF FHIR_PAYMENTNOTICE}
    function ParsePaymentNotice(jsn : TJsonObject) : TFhirPaymentNotice; overload;
    procedure ParsePaymentNoticeProperties(jsn : TJsonObject; result : TFhirPaymentNotice); overload;
    procedure ParsePaymentNotice(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_PAYMENTNOTICE}
{$IFDEF FHIR_PAYMENTRECONCILIATION}
    function ParsePaymentReconciliationDetail(jsn : TJsonObject) : TFhirPaymentReconciliationDetail; overload; {b\}
    procedure ParsePaymentReconciliationDetailProperties(jsn : TJsonObject; result : TFhirPaymentReconciliationDetail); overload; {b\}
    procedure ParsePaymentReconciliationDetail(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParsePaymentReconciliationProcessNote(jsn : TJsonObject) : TFhirPaymentReconciliationProcessNote; overload; {b\}
    procedure ParsePaymentReconciliationProcessNoteProperties(jsn : TJsonObject; result : TFhirPaymentReconciliationProcessNote); overload; {b\}
    procedure ParsePaymentReconciliationProcessNote(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParsePaymentReconciliation(jsn : TJsonObject) : TFhirPaymentReconciliation; overload;
    procedure ParsePaymentReconciliationProperties(jsn : TJsonObject; result : TFhirPaymentReconciliation); overload;
    procedure ParsePaymentReconciliation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_PAYMENTRECONCILIATION}
{$IFDEF FHIR_PERSON}
    function ParsePersonLink(jsn : TJsonObject) : TFhirPersonLink; overload; {b\}
    procedure ParsePersonLinkProperties(jsn : TJsonObject; result : TFhirPersonLink); overload; {b\}
    procedure ParsePersonLink(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParsePerson(jsn : TJsonObject) : TFhirPerson; overload;
    procedure ParsePersonProperties(jsn : TJsonObject; result : TFhirPerson); overload;
    procedure ParsePerson(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_PERSON}
{$IFDEF FHIR_PLANDEFINITION}
    function ParsePlanDefinitionGoal(jsn : TJsonObject) : TFhirPlanDefinitionGoal; overload; {b\}
    procedure ParsePlanDefinitionGoalProperties(jsn : TJsonObject; result : TFhirPlanDefinitionGoal); overload; {b\}
    procedure ParsePlanDefinitionGoal(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParsePlanDefinitionGoalTarget(jsn : TJsonObject) : TFhirPlanDefinitionGoalTarget; overload; {b\}
    procedure ParsePlanDefinitionGoalTargetProperties(jsn : TJsonObject; result : TFhirPlanDefinitionGoalTarget); overload; {b\}
    procedure ParsePlanDefinitionGoalTarget(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParsePlanDefinitionAction(jsn : TJsonObject) : TFhirPlanDefinitionAction; overload; {b\}
    procedure ParsePlanDefinitionActionProperties(jsn : TJsonObject; result : TFhirPlanDefinitionAction); overload; {b\}
    procedure ParsePlanDefinitionAction(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParsePlanDefinitionActionCondition(jsn : TJsonObject) : TFhirPlanDefinitionActionCondition; overload; {b\}
    procedure ParsePlanDefinitionActionConditionProperties(jsn : TJsonObject; result : TFhirPlanDefinitionActionCondition); overload; {b\}
    procedure ParsePlanDefinitionActionCondition(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParsePlanDefinitionActionRelatedAction(jsn : TJsonObject) : TFhirPlanDefinitionActionRelatedAction; overload; {b\}
    procedure ParsePlanDefinitionActionRelatedActionProperties(jsn : TJsonObject; result : TFhirPlanDefinitionActionRelatedAction); overload; {b\}
    procedure ParsePlanDefinitionActionRelatedAction(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParsePlanDefinitionActionParticipant(jsn : TJsonObject) : TFhirPlanDefinitionActionParticipant; overload; {b\}
    procedure ParsePlanDefinitionActionParticipantProperties(jsn : TJsonObject; result : TFhirPlanDefinitionActionParticipant); overload; {b\}
    procedure ParsePlanDefinitionActionParticipant(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParsePlanDefinitionActionDynamicValue(jsn : TJsonObject) : TFhirPlanDefinitionActionDynamicValue; overload; {b\}
    procedure ParsePlanDefinitionActionDynamicValueProperties(jsn : TJsonObject; result : TFhirPlanDefinitionActionDynamicValue); overload; {b\}
    procedure ParsePlanDefinitionActionDynamicValue(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParsePlanDefinition(jsn : TJsonObject) : TFhirPlanDefinition; overload;
    procedure ParsePlanDefinitionProperties(jsn : TJsonObject; result : TFhirPlanDefinition); overload;
    procedure ParsePlanDefinition(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_PLANDEFINITION}
{$IFDEF FHIR_PRACTITIONER}
    function ParsePractitionerQualification(jsn : TJsonObject) : TFhirPractitionerQualification; overload; {b\}
    procedure ParsePractitionerQualificationProperties(jsn : TJsonObject; result : TFhirPractitionerQualification); overload; {b\}
    procedure ParsePractitionerQualification(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParsePractitioner(jsn : TJsonObject) : TFhirPractitioner; overload;
    procedure ParsePractitionerProperties(jsn : TJsonObject; result : TFhirPractitioner); overload;
    procedure ParsePractitioner(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_PRACTITIONER}
{$IFDEF FHIR_PRACTITIONERROLE}
    function ParsePractitionerRoleAvailableTime(jsn : TJsonObject) : TFhirPractitionerRoleAvailableTime; overload; {b\}
    procedure ParsePractitionerRoleAvailableTimeProperties(jsn : TJsonObject; result : TFhirPractitionerRoleAvailableTime); overload; {b\}
    procedure ParsePractitionerRoleAvailableTime(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParsePractitionerRoleNotAvailable(jsn : TJsonObject) : TFhirPractitionerRoleNotAvailable; overload; {b\}
    procedure ParsePractitionerRoleNotAvailableProperties(jsn : TJsonObject; result : TFhirPractitionerRoleNotAvailable); overload; {b\}
    procedure ParsePractitionerRoleNotAvailable(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParsePractitionerRole(jsn : TJsonObject) : TFhirPractitionerRole; overload;
    procedure ParsePractitionerRoleProperties(jsn : TJsonObject; result : TFhirPractitionerRole); overload;
    procedure ParsePractitionerRole(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_PRACTITIONERROLE}
{$IFDEF FHIR_PROCEDURE}
    function ParseProcedurePerformer(jsn : TJsonObject) : TFhirProcedurePerformer; overload; {b\}
    procedure ParseProcedurePerformerProperties(jsn : TJsonObject; result : TFhirProcedurePerformer); overload; {b\}
    procedure ParseProcedurePerformer(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProcedureFocalDevice(jsn : TJsonObject) : TFhirProcedureFocalDevice; overload; {b\}
    procedure ParseProcedureFocalDeviceProperties(jsn : TJsonObject; result : TFhirProcedureFocalDevice); overload; {b\}
    procedure ParseProcedureFocalDevice(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProcedure(jsn : TJsonObject) : TFhirProcedure; overload;
    procedure ParseProcedureProperties(jsn : TJsonObject; result : TFhirProcedure); overload;
    procedure ParseProcedure(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_PROCEDURE}
{$IFDEF FHIR_PROVENANCE}
    function ParseProvenanceAgent(jsn : TJsonObject) : TFhirProvenanceAgent; overload; {b\}
    procedure ParseProvenanceAgentProperties(jsn : TJsonObject; result : TFhirProvenanceAgent); overload; {b\}
    procedure ParseProvenanceAgent(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProvenanceEntity(jsn : TJsonObject) : TFhirProvenanceEntity; overload; {b\}
    procedure ParseProvenanceEntityProperties(jsn : TJsonObject; result : TFhirProvenanceEntity); overload; {b\}
    procedure ParseProvenanceEntity(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProvenance(jsn : TJsonObject) : TFhirProvenance; overload;
    procedure ParseProvenanceProperties(jsn : TJsonObject; result : TFhirProvenance); overload;
    procedure ParseProvenance(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_PROVENANCE}
{$IFDEF FHIR_QUESTIONNAIRE}
    function ParseQuestionnaireItem(jsn : TJsonObject) : TFhirQuestionnaireItem; overload; {b\}
    procedure ParseQuestionnaireItemProperties(jsn : TJsonObject; result : TFhirQuestionnaireItem); overload; {b\}
    procedure ParseQuestionnaireItem(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseQuestionnaireItemEnableWhen(jsn : TJsonObject) : TFhirQuestionnaireItemEnableWhen; overload; {b\}
    procedure ParseQuestionnaireItemEnableWhenProperties(jsn : TJsonObject; result : TFhirQuestionnaireItemEnableWhen); overload; {b\}
    procedure ParseQuestionnaireItemEnableWhen(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseQuestionnaireItemAnswerOption(jsn : TJsonObject) : TFhirQuestionnaireItemAnswerOption; overload; {b\}
    procedure ParseQuestionnaireItemAnswerOptionProperties(jsn : TJsonObject; result : TFhirQuestionnaireItemAnswerOption); overload; {b\}
    procedure ParseQuestionnaireItemAnswerOption(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseQuestionnaireItemInitial(jsn : TJsonObject) : TFhirQuestionnaireItemInitial; overload; {b\}
    procedure ParseQuestionnaireItemInitialProperties(jsn : TJsonObject; result : TFhirQuestionnaireItemInitial); overload; {b\}
    procedure ParseQuestionnaireItemInitial(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseQuestionnaire(jsn : TJsonObject) : TFhirQuestionnaire; overload;
    procedure ParseQuestionnaireProperties(jsn : TJsonObject; result : TFhirQuestionnaire); overload;
    procedure ParseQuestionnaire(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_QUESTIONNAIRE}
{$IFDEF FHIR_QUESTIONNAIRERESPONSE}
    function ParseQuestionnaireResponseItem(jsn : TJsonObject) : TFhirQuestionnaireResponseItem; overload; {b\}
    procedure ParseQuestionnaireResponseItemProperties(jsn : TJsonObject; result : TFhirQuestionnaireResponseItem); overload; {b\}
    procedure ParseQuestionnaireResponseItem(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseQuestionnaireResponseItemAnswer(jsn : TJsonObject) : TFhirQuestionnaireResponseItemAnswer; overload; {b\}
    procedure ParseQuestionnaireResponseItemAnswerProperties(jsn : TJsonObject; result : TFhirQuestionnaireResponseItemAnswer); overload; {b\}
    procedure ParseQuestionnaireResponseItemAnswer(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseQuestionnaireResponse(jsn : TJsonObject) : TFhirQuestionnaireResponse; overload;
    procedure ParseQuestionnaireResponseProperties(jsn : TJsonObject; result : TFhirQuestionnaireResponse); overload;
    procedure ParseQuestionnaireResponse(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_QUESTIONNAIRERESPONSE}
{$IFDEF FHIR_RELATEDPERSON}
    function ParseRelatedPersonCommunication(jsn : TJsonObject) : TFhirRelatedPersonCommunication; overload; {b\}
    procedure ParseRelatedPersonCommunicationProperties(jsn : TJsonObject; result : TFhirRelatedPersonCommunication); overload; {b\}
    procedure ParseRelatedPersonCommunication(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseRelatedPerson(jsn : TJsonObject) : TFhirRelatedPerson; overload;
    procedure ParseRelatedPersonProperties(jsn : TJsonObject; result : TFhirRelatedPerson); overload;
    procedure ParseRelatedPerson(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_RELATEDPERSON}
{$IFDEF FHIR_REQUESTGROUP}
    function ParseRequestGroupAction(jsn : TJsonObject) : TFhirRequestGroupAction; overload; {b\}
    procedure ParseRequestGroupActionProperties(jsn : TJsonObject; result : TFhirRequestGroupAction); overload; {b\}
    procedure ParseRequestGroupAction(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseRequestGroupActionCondition(jsn : TJsonObject) : TFhirRequestGroupActionCondition; overload; {b\}
    procedure ParseRequestGroupActionConditionProperties(jsn : TJsonObject; result : TFhirRequestGroupActionCondition); overload; {b\}
    procedure ParseRequestGroupActionCondition(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseRequestGroupActionRelatedAction(jsn : TJsonObject) : TFhirRequestGroupActionRelatedAction; overload; {b\}
    procedure ParseRequestGroupActionRelatedActionProperties(jsn : TJsonObject; result : TFhirRequestGroupActionRelatedAction); overload; {b\}
    procedure ParseRequestGroupActionRelatedAction(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseRequestGroup(jsn : TJsonObject) : TFhirRequestGroup; overload;
    procedure ParseRequestGroupProperties(jsn : TJsonObject; result : TFhirRequestGroup); overload;
    procedure ParseRequestGroup(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_REQUESTGROUP}
{$IFDEF FHIR_RESEARCHDEFINITION}
    function ParseResearchDefinition(jsn : TJsonObject) : TFhirResearchDefinition; overload;
    procedure ParseResearchDefinitionProperties(jsn : TJsonObject; result : TFhirResearchDefinition); overload;
    procedure ParseResearchDefinition(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_RESEARCHDEFINITION}
{$IFDEF FHIR_RESEARCHELEMENTDEFINITION}
    function ParseResearchElementDefinitionCharacteristic(jsn : TJsonObject) : TFhirResearchElementDefinitionCharacteristic; overload; {b\}
    procedure ParseResearchElementDefinitionCharacteristicProperties(jsn : TJsonObject; result : TFhirResearchElementDefinitionCharacteristic); overload; {b\}
    procedure ParseResearchElementDefinitionCharacteristic(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseResearchElementDefinition(jsn : TJsonObject) : TFhirResearchElementDefinition; overload;
    procedure ParseResearchElementDefinitionProperties(jsn : TJsonObject; result : TFhirResearchElementDefinition); overload;
    procedure ParseResearchElementDefinition(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_RESEARCHELEMENTDEFINITION}
{$IFDEF FHIR_RESEARCHSTUDY}
    function ParseResearchStudyArm(jsn : TJsonObject) : TFhirResearchStudyArm; overload; {b\}
    procedure ParseResearchStudyArmProperties(jsn : TJsonObject; result : TFhirResearchStudyArm); overload; {b\}
    procedure ParseResearchStudyArm(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseResearchStudyObjective(jsn : TJsonObject) : TFhirResearchStudyObjective; overload; {b\}
    procedure ParseResearchStudyObjectiveProperties(jsn : TJsonObject; result : TFhirResearchStudyObjective); overload; {b\}
    procedure ParseResearchStudyObjective(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseResearchStudy(jsn : TJsonObject) : TFhirResearchStudy; overload;
    procedure ParseResearchStudyProperties(jsn : TJsonObject; result : TFhirResearchStudy); overload;
    procedure ParseResearchStudy(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_RESEARCHSTUDY}
{$IFDEF FHIR_RESEARCHSUBJECT}
    function ParseResearchSubject(jsn : TJsonObject) : TFhirResearchSubject; overload;
    procedure ParseResearchSubjectProperties(jsn : TJsonObject; result : TFhirResearchSubject); overload;
    procedure ParseResearchSubject(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_RESEARCHSUBJECT}
{$IFDEF FHIR_RISKASSESSMENT}
    function ParseRiskAssessmentPrediction(jsn : TJsonObject) : TFhirRiskAssessmentPrediction; overload; {b\}
    procedure ParseRiskAssessmentPredictionProperties(jsn : TJsonObject; result : TFhirRiskAssessmentPrediction); overload; {b\}
    procedure ParseRiskAssessmentPrediction(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseRiskAssessment(jsn : TJsonObject) : TFhirRiskAssessment; overload;
    procedure ParseRiskAssessmentProperties(jsn : TJsonObject; result : TFhirRiskAssessment); overload;
    procedure ParseRiskAssessment(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_RISKASSESSMENT}
{$IFDEF FHIR_RISKEVIDENCESYNTHESIS}
    function ParseRiskEvidenceSynthesisSampleSize(jsn : TJsonObject) : TFhirRiskEvidenceSynthesisSampleSize; overload; {b\}
    procedure ParseRiskEvidenceSynthesisSampleSizeProperties(jsn : TJsonObject; result : TFhirRiskEvidenceSynthesisSampleSize); overload; {b\}
    procedure ParseRiskEvidenceSynthesisSampleSize(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseRiskEvidenceSynthesisRiskEstimate(jsn : TJsonObject) : TFhirRiskEvidenceSynthesisRiskEstimate; overload; {b\}
    procedure ParseRiskEvidenceSynthesisRiskEstimateProperties(jsn : TJsonObject; result : TFhirRiskEvidenceSynthesisRiskEstimate); overload; {b\}
    procedure ParseRiskEvidenceSynthesisRiskEstimate(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseRiskEvidenceSynthesisRiskEstimatePrecisionEstimate(jsn : TJsonObject) : TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate; overload; {b\}
    procedure ParseRiskEvidenceSynthesisRiskEstimatePrecisionEstimateProperties(jsn : TJsonObject; result : TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate); overload; {b\}
    procedure ParseRiskEvidenceSynthesisRiskEstimatePrecisionEstimate(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseRiskEvidenceSynthesisCertainty(jsn : TJsonObject) : TFhirRiskEvidenceSynthesisCertainty; overload; {b\}
    procedure ParseRiskEvidenceSynthesisCertaintyProperties(jsn : TJsonObject; result : TFhirRiskEvidenceSynthesisCertainty); overload; {b\}
    procedure ParseRiskEvidenceSynthesisCertainty(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseRiskEvidenceSynthesisCertaintyCertaintySubcomponent(jsn : TJsonObject) : TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent; overload; {b\}
    procedure ParseRiskEvidenceSynthesisCertaintyCertaintySubcomponentProperties(jsn : TJsonObject; result : TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent); overload; {b\}
    procedure ParseRiskEvidenceSynthesisCertaintyCertaintySubcomponent(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseRiskEvidenceSynthesis(jsn : TJsonObject) : TFhirRiskEvidenceSynthesis; overload;
    procedure ParseRiskEvidenceSynthesisProperties(jsn : TJsonObject; result : TFhirRiskEvidenceSynthesis); overload;
    procedure ParseRiskEvidenceSynthesis(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_RISKEVIDENCESYNTHESIS}
{$IFDEF FHIR_SCHEDULE}
    function ParseSchedule(jsn : TJsonObject) : TFhirSchedule; overload;
    procedure ParseScheduleProperties(jsn : TJsonObject; result : TFhirSchedule); overload;
    procedure ParseSchedule(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_SCHEDULE}
{$IFDEF FHIR_SEARCHPARAMETER}
    function ParseSearchParameterComponent(jsn : TJsonObject) : TFhirSearchParameterComponent; overload; {b\}
    procedure ParseSearchParameterComponentProperties(jsn : TJsonObject; result : TFhirSearchParameterComponent); overload; {b\}
    procedure ParseSearchParameterComponent(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSearchParameter(jsn : TJsonObject) : TFhirSearchParameter; overload;
    procedure ParseSearchParameterProperties(jsn : TJsonObject; result : TFhirSearchParameter); overload;
    procedure ParseSearchParameter(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_SEARCHPARAMETER}
{$IFDEF FHIR_SERVICEREQUEST}
    function ParseServiceRequest(jsn : TJsonObject) : TFhirServiceRequest; overload;
    procedure ParseServiceRequestProperties(jsn : TJsonObject; result : TFhirServiceRequest); overload;
    procedure ParseServiceRequest(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_SERVICEREQUEST}
{$IFDEF FHIR_SLOT}
    function ParseSlot(jsn : TJsonObject) : TFhirSlot; overload;
    procedure ParseSlotProperties(jsn : TJsonObject; result : TFhirSlot); overload;
    procedure ParseSlot(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_SLOT}
{$IFDEF FHIR_SPECIMEN}
    function ParseSpecimenCollection(jsn : TJsonObject) : TFhirSpecimenCollection; overload; {b\}
    procedure ParseSpecimenCollectionProperties(jsn : TJsonObject; result : TFhirSpecimenCollection); overload; {b\}
    procedure ParseSpecimenCollection(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSpecimenProcessing(jsn : TJsonObject) : TFhirSpecimenProcessing; overload; {b\}
    procedure ParseSpecimenProcessingProperties(jsn : TJsonObject; result : TFhirSpecimenProcessing); overload; {b\}
    procedure ParseSpecimenProcessing(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSpecimenContainer(jsn : TJsonObject) : TFhirSpecimenContainer; overload; {b\}
    procedure ParseSpecimenContainerProperties(jsn : TJsonObject; result : TFhirSpecimenContainer); overload; {b\}
    procedure ParseSpecimenContainer(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSpecimen(jsn : TJsonObject) : TFhirSpecimen; overload;
    procedure ParseSpecimenProperties(jsn : TJsonObject; result : TFhirSpecimen); overload;
    procedure ParseSpecimen(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_SPECIMEN}
{$IFDEF FHIR_SPECIMENDEFINITION}
    function ParseSpecimenDefinitionTypeTested(jsn : TJsonObject) : TFhirSpecimenDefinitionTypeTested; overload; {b\}
    procedure ParseSpecimenDefinitionTypeTestedProperties(jsn : TJsonObject; result : TFhirSpecimenDefinitionTypeTested); overload; {b\}
    procedure ParseSpecimenDefinitionTypeTested(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSpecimenDefinitionTypeTestedContainer(jsn : TJsonObject) : TFhirSpecimenDefinitionTypeTestedContainer; overload; {b\}
    procedure ParseSpecimenDefinitionTypeTestedContainerProperties(jsn : TJsonObject; result : TFhirSpecimenDefinitionTypeTestedContainer); overload; {b\}
    procedure ParseSpecimenDefinitionTypeTestedContainer(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSpecimenDefinitionTypeTestedContainerAdditive(jsn : TJsonObject) : TFhirSpecimenDefinitionTypeTestedContainerAdditive; overload; {b\}
    procedure ParseSpecimenDefinitionTypeTestedContainerAdditiveProperties(jsn : TJsonObject; result : TFhirSpecimenDefinitionTypeTestedContainerAdditive); overload; {b\}
    procedure ParseSpecimenDefinitionTypeTestedContainerAdditive(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSpecimenDefinitionTypeTestedHandling(jsn : TJsonObject) : TFhirSpecimenDefinitionTypeTestedHandling; overload; {b\}
    procedure ParseSpecimenDefinitionTypeTestedHandlingProperties(jsn : TJsonObject; result : TFhirSpecimenDefinitionTypeTestedHandling); overload; {b\}
    procedure ParseSpecimenDefinitionTypeTestedHandling(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSpecimenDefinition(jsn : TJsonObject) : TFhirSpecimenDefinition; overload;
    procedure ParseSpecimenDefinitionProperties(jsn : TJsonObject; result : TFhirSpecimenDefinition); overload;
    procedure ParseSpecimenDefinition(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_SPECIMENDEFINITION}
{$IFDEF FHIR_STRUCTUREDEFINITION}
    function ParseStructureDefinitionMapping(jsn : TJsonObject) : TFhirStructureDefinitionMapping; overload; {b\}
    procedure ParseStructureDefinitionMappingProperties(jsn : TJsonObject; result : TFhirStructureDefinitionMapping); overload; {b\}
    procedure ParseStructureDefinitionMapping(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseStructureDefinitionContext(jsn : TJsonObject) : TFhirStructureDefinitionContext; overload; {b\}
    procedure ParseStructureDefinitionContextProperties(jsn : TJsonObject; result : TFhirStructureDefinitionContext); overload; {b\}
    procedure ParseStructureDefinitionContext(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseStructureDefinitionSnapshot(jsn : TJsonObject) : TFhirStructureDefinitionSnapshot; overload; {b\}
    procedure ParseStructureDefinitionSnapshotProperties(jsn : TJsonObject; result : TFhirStructureDefinitionSnapshot); overload; {b\}
    procedure ParseStructureDefinitionSnapshot(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseStructureDefinitionDifferential(jsn : TJsonObject) : TFhirStructureDefinitionDifferential; overload; {b\}
    procedure ParseStructureDefinitionDifferentialProperties(jsn : TJsonObject; result : TFhirStructureDefinitionDifferential); overload; {b\}
    procedure ParseStructureDefinitionDifferential(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseStructureDefinition(jsn : TJsonObject) : TFhirStructureDefinition; overload;
    procedure ParseStructureDefinitionProperties(jsn : TJsonObject; result : TFhirStructureDefinition); overload;
    procedure ParseStructureDefinition(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_STRUCTUREDEFINITION}
{$IFDEF FHIR_STRUCTUREMAP}
    function ParseStructureMapStructure(jsn : TJsonObject) : TFhirStructureMapStructure; overload; {b\}
    procedure ParseStructureMapStructureProperties(jsn : TJsonObject; result : TFhirStructureMapStructure); overload; {b\}
    procedure ParseStructureMapStructure(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseStructureMapGroup(jsn : TJsonObject) : TFhirStructureMapGroup; overload; {b\}
    procedure ParseStructureMapGroupProperties(jsn : TJsonObject; result : TFhirStructureMapGroup); overload; {b\}
    procedure ParseStructureMapGroup(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseStructureMapGroupInput(jsn : TJsonObject) : TFhirStructureMapGroupInput; overload; {b\}
    procedure ParseStructureMapGroupInputProperties(jsn : TJsonObject; result : TFhirStructureMapGroupInput); overload; {b\}
    procedure ParseStructureMapGroupInput(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseStructureMapGroupRule(jsn : TJsonObject) : TFhirStructureMapGroupRule; overload; {b\}
    procedure ParseStructureMapGroupRuleProperties(jsn : TJsonObject; result : TFhirStructureMapGroupRule); overload; {b\}
    procedure ParseStructureMapGroupRule(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseStructureMapGroupRuleSource(jsn : TJsonObject) : TFhirStructureMapGroupRuleSource; overload; {b\}
    procedure ParseStructureMapGroupRuleSourceProperties(jsn : TJsonObject; result : TFhirStructureMapGroupRuleSource); overload; {b\}
    procedure ParseStructureMapGroupRuleSource(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseStructureMapGroupRuleTarget(jsn : TJsonObject) : TFhirStructureMapGroupRuleTarget; overload; {b\}
    procedure ParseStructureMapGroupRuleTargetProperties(jsn : TJsonObject; result : TFhirStructureMapGroupRuleTarget); overload; {b\}
    procedure ParseStructureMapGroupRuleTarget(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseStructureMapGroupRuleTargetParameter(jsn : TJsonObject) : TFhirStructureMapGroupRuleTargetParameter; overload; {b\}
    procedure ParseStructureMapGroupRuleTargetParameterProperties(jsn : TJsonObject; result : TFhirStructureMapGroupRuleTargetParameter); overload; {b\}
    procedure ParseStructureMapGroupRuleTargetParameter(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseStructureMapGroupRuleDependent(jsn : TJsonObject) : TFhirStructureMapGroupRuleDependent; overload; {b\}
    procedure ParseStructureMapGroupRuleDependentProperties(jsn : TJsonObject; result : TFhirStructureMapGroupRuleDependent); overload; {b\}
    procedure ParseStructureMapGroupRuleDependent(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseStructureMap(jsn : TJsonObject) : TFhirStructureMap; overload;
    procedure ParseStructureMapProperties(jsn : TJsonObject; result : TFhirStructureMap); overload;
    procedure ParseStructureMap(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_STRUCTUREMAP}
{$IFDEF FHIR_SUBSCRIPTION}
    function ParseSubscriptionChannel(jsn : TJsonObject) : TFhirSubscriptionChannel; overload; {b\}
    procedure ParseSubscriptionChannelProperties(jsn : TJsonObject; result : TFhirSubscriptionChannel); overload; {b\}
    procedure ParseSubscriptionChannel(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSubscription(jsn : TJsonObject) : TFhirSubscription; overload;
    procedure ParseSubscriptionProperties(jsn : TJsonObject; result : TFhirSubscription); overload;
    procedure ParseSubscription(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_SUBSCRIPTION}
{$IFDEF FHIR_SUBSTANCE}
    function ParseSubstanceInstance(jsn : TJsonObject) : TFhirSubstanceInstance; overload; {b\}
    procedure ParseSubstanceInstanceProperties(jsn : TJsonObject; result : TFhirSubstanceInstance); overload; {b\}
    procedure ParseSubstanceInstance(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSubstanceIngredient(jsn : TJsonObject) : TFhirSubstanceIngredient; overload; {b\}
    procedure ParseSubstanceIngredientProperties(jsn : TJsonObject; result : TFhirSubstanceIngredient); overload; {b\}
    procedure ParseSubstanceIngredient(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSubstance(jsn : TJsonObject) : TFhirSubstance; overload;
    procedure ParseSubstanceProperties(jsn : TJsonObject; result : TFhirSubstance); overload;
    procedure ParseSubstance(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_SUBSTANCE}
{$IFDEF FHIR_SUBSTANCENUCLEICACID}
    function ParseSubstanceNucleicAcidSubunit(jsn : TJsonObject) : TFhirSubstanceNucleicAcidSubunit; overload; {b\}
    procedure ParseSubstanceNucleicAcidSubunitProperties(jsn : TJsonObject; result : TFhirSubstanceNucleicAcidSubunit); overload; {b\}
    procedure ParseSubstanceNucleicAcidSubunit(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSubstanceNucleicAcidSubunitLinkage(jsn : TJsonObject) : TFhirSubstanceNucleicAcidSubunitLinkage; overload; {b\}
    procedure ParseSubstanceNucleicAcidSubunitLinkageProperties(jsn : TJsonObject; result : TFhirSubstanceNucleicAcidSubunitLinkage); overload; {b\}
    procedure ParseSubstanceNucleicAcidSubunitLinkage(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSubstanceNucleicAcidSubunitSugar(jsn : TJsonObject) : TFhirSubstanceNucleicAcidSubunitSugar; overload; {b\}
    procedure ParseSubstanceNucleicAcidSubunitSugarProperties(jsn : TJsonObject; result : TFhirSubstanceNucleicAcidSubunitSugar); overload; {b\}
    procedure ParseSubstanceNucleicAcidSubunitSugar(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSubstanceNucleicAcid(jsn : TJsonObject) : TFhirSubstanceNucleicAcid; overload;
    procedure ParseSubstanceNucleicAcidProperties(jsn : TJsonObject; result : TFhirSubstanceNucleicAcid); overload;
    procedure ParseSubstanceNucleicAcid(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_SUBSTANCENUCLEICACID}
{$IFDEF FHIR_SUBSTANCEPOLYMER}
    function ParseSubstancePolymerMonomerSet(jsn : TJsonObject) : TFhirSubstancePolymerMonomerSet; overload; {b\}
    procedure ParseSubstancePolymerMonomerSetProperties(jsn : TJsonObject; result : TFhirSubstancePolymerMonomerSet); overload; {b\}
    procedure ParseSubstancePolymerMonomerSet(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSubstancePolymerMonomerSetStartingMaterial(jsn : TJsonObject) : TFhirSubstancePolymerMonomerSetStartingMaterial; overload; {b\}
    procedure ParseSubstancePolymerMonomerSetStartingMaterialProperties(jsn : TJsonObject; result : TFhirSubstancePolymerMonomerSetStartingMaterial); overload; {b\}
    procedure ParseSubstancePolymerMonomerSetStartingMaterial(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSubstancePolymerRepeat(jsn : TJsonObject) : TFhirSubstancePolymerRepeat; overload; {b\}
    procedure ParseSubstancePolymerRepeatProperties(jsn : TJsonObject; result : TFhirSubstancePolymerRepeat); overload; {b\}
    procedure ParseSubstancePolymerRepeat(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSubstancePolymerRepeatRepeatUnit(jsn : TJsonObject) : TFhirSubstancePolymerRepeatRepeatUnit; overload; {b\}
    procedure ParseSubstancePolymerRepeatRepeatUnitProperties(jsn : TJsonObject; result : TFhirSubstancePolymerRepeatRepeatUnit); overload; {b\}
    procedure ParseSubstancePolymerRepeatRepeatUnit(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation(jsn : TJsonObject) : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation; overload; {b\}
    procedure ParseSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationProperties(jsn : TJsonObject; result : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation); overload; {b\}
    procedure ParseSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSubstancePolymerRepeatRepeatUnitStructuralRepresentation(jsn : TJsonObject) : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation; overload; {b\}
    procedure ParseSubstancePolymerRepeatRepeatUnitStructuralRepresentationProperties(jsn : TJsonObject; result : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation); overload; {b\}
    procedure ParseSubstancePolymerRepeatRepeatUnitStructuralRepresentation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSubstancePolymer(jsn : TJsonObject) : TFhirSubstancePolymer; overload;
    procedure ParseSubstancePolymerProperties(jsn : TJsonObject; result : TFhirSubstancePolymer); overload;
    procedure ParseSubstancePolymer(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_SUBSTANCEPOLYMER}
{$IFDEF FHIR_SUBSTANCEPROTEIN}
    function ParseSubstanceProteinSubunit(jsn : TJsonObject) : TFhirSubstanceProteinSubunit; overload; {b\}
    procedure ParseSubstanceProteinSubunitProperties(jsn : TJsonObject; result : TFhirSubstanceProteinSubunit); overload; {b\}
    procedure ParseSubstanceProteinSubunit(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSubstanceProtein(jsn : TJsonObject) : TFhirSubstanceProtein; overload;
    procedure ParseSubstanceProteinProperties(jsn : TJsonObject; result : TFhirSubstanceProtein); overload;
    procedure ParseSubstanceProtein(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_SUBSTANCEPROTEIN}
{$IFDEF FHIR_SUBSTANCEREFERENCEINFORMATION}
    function ParseSubstanceReferenceInformationGene(jsn : TJsonObject) : TFhirSubstanceReferenceInformationGene; overload; {b\}
    procedure ParseSubstanceReferenceInformationGeneProperties(jsn : TJsonObject; result : TFhirSubstanceReferenceInformationGene); overload; {b\}
    procedure ParseSubstanceReferenceInformationGene(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSubstanceReferenceInformationGeneElement(jsn : TJsonObject) : TFhirSubstanceReferenceInformationGeneElement; overload; {b\}
    procedure ParseSubstanceReferenceInformationGeneElementProperties(jsn : TJsonObject; result : TFhirSubstanceReferenceInformationGeneElement); overload; {b\}
    procedure ParseSubstanceReferenceInformationGeneElement(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSubstanceReferenceInformationClassification(jsn : TJsonObject) : TFhirSubstanceReferenceInformationClassification; overload; {b\}
    procedure ParseSubstanceReferenceInformationClassificationProperties(jsn : TJsonObject; result : TFhirSubstanceReferenceInformationClassification); overload; {b\}
    procedure ParseSubstanceReferenceInformationClassification(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSubstanceReferenceInformationTarget(jsn : TJsonObject) : TFhirSubstanceReferenceInformationTarget; overload; {b\}
    procedure ParseSubstanceReferenceInformationTargetProperties(jsn : TJsonObject; result : TFhirSubstanceReferenceInformationTarget); overload; {b\}
    procedure ParseSubstanceReferenceInformationTarget(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSubstanceReferenceInformation(jsn : TJsonObject) : TFhirSubstanceReferenceInformation; overload;
    procedure ParseSubstanceReferenceInformationProperties(jsn : TJsonObject; result : TFhirSubstanceReferenceInformation); overload;
    procedure ParseSubstanceReferenceInformation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_SUBSTANCEREFERENCEINFORMATION}
{$IFDEF FHIR_SUBSTANCESOURCEMATERIAL}
    function ParseSubstanceSourceMaterialFractionDescription(jsn : TJsonObject) : TFhirSubstanceSourceMaterialFractionDescription; overload; {b\}
    procedure ParseSubstanceSourceMaterialFractionDescriptionProperties(jsn : TJsonObject; result : TFhirSubstanceSourceMaterialFractionDescription); overload; {b\}
    procedure ParseSubstanceSourceMaterialFractionDescription(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSubstanceSourceMaterialOrganism(jsn : TJsonObject) : TFhirSubstanceSourceMaterialOrganism; overload; {b\}
    procedure ParseSubstanceSourceMaterialOrganismProperties(jsn : TJsonObject; result : TFhirSubstanceSourceMaterialOrganism); overload; {b\}
    procedure ParseSubstanceSourceMaterialOrganism(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSubstanceSourceMaterialOrganismAuthor(jsn : TJsonObject) : TFhirSubstanceSourceMaterialOrganismAuthor; overload; {b\}
    procedure ParseSubstanceSourceMaterialOrganismAuthorProperties(jsn : TJsonObject; result : TFhirSubstanceSourceMaterialOrganismAuthor); overload; {b\}
    procedure ParseSubstanceSourceMaterialOrganismAuthor(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSubstanceSourceMaterialOrganismHybrid(jsn : TJsonObject) : TFhirSubstanceSourceMaterialOrganismHybrid; overload; {b\}
    procedure ParseSubstanceSourceMaterialOrganismHybridProperties(jsn : TJsonObject; result : TFhirSubstanceSourceMaterialOrganismHybrid); overload; {b\}
    procedure ParseSubstanceSourceMaterialOrganismHybrid(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSubstanceSourceMaterialOrganismOrganismGeneral(jsn : TJsonObject) : TFhirSubstanceSourceMaterialOrganismOrganismGeneral; overload; {b\}
    procedure ParseSubstanceSourceMaterialOrganismOrganismGeneralProperties(jsn : TJsonObject; result : TFhirSubstanceSourceMaterialOrganismOrganismGeneral); overload; {b\}
    procedure ParseSubstanceSourceMaterialOrganismOrganismGeneral(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSubstanceSourceMaterialPartDescription(jsn : TJsonObject) : TFhirSubstanceSourceMaterialPartDescription; overload; {b\}
    procedure ParseSubstanceSourceMaterialPartDescriptionProperties(jsn : TJsonObject; result : TFhirSubstanceSourceMaterialPartDescription); overload; {b\}
    procedure ParseSubstanceSourceMaterialPartDescription(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSubstanceSourceMaterial(jsn : TJsonObject) : TFhirSubstanceSourceMaterial; overload;
    procedure ParseSubstanceSourceMaterialProperties(jsn : TJsonObject; result : TFhirSubstanceSourceMaterial); overload;
    procedure ParseSubstanceSourceMaterial(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_SUBSTANCESOURCEMATERIAL}
{$IFDEF FHIR_SUBSTANCESPECIFICATION}
    function ParseSubstanceSpecificationMoiety(jsn : TJsonObject) : TFhirSubstanceSpecificationMoiety; overload; {b\}
    procedure ParseSubstanceSpecificationMoietyProperties(jsn : TJsonObject; result : TFhirSubstanceSpecificationMoiety); overload; {b\}
    procedure ParseSubstanceSpecificationMoiety(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSubstanceSpecificationProperty(jsn : TJsonObject) : TFhirSubstanceSpecificationProperty; overload; {b\}
    procedure ParseSubstanceSpecificationPropertyProperties(jsn : TJsonObject; result : TFhirSubstanceSpecificationProperty); overload; {b\}
    procedure ParseSubstanceSpecificationProperty(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSubstanceSpecificationStructure(jsn : TJsonObject) : TFhirSubstanceSpecificationStructure; overload; {b\}
    procedure ParseSubstanceSpecificationStructureProperties(jsn : TJsonObject; result : TFhirSubstanceSpecificationStructure); overload; {b\}
    procedure ParseSubstanceSpecificationStructure(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSubstanceSpecificationStructureIsotope(jsn : TJsonObject) : TFhirSubstanceSpecificationStructureIsotope; overload; {b\}
    procedure ParseSubstanceSpecificationStructureIsotopeProperties(jsn : TJsonObject; result : TFhirSubstanceSpecificationStructureIsotope); overload; {b\}
    procedure ParseSubstanceSpecificationStructureIsotope(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSubstanceSpecificationStructureIsotopeMolecularWeight(jsn : TJsonObject) : TFhirSubstanceSpecificationStructureIsotopeMolecularWeight; overload; {b\}
    procedure ParseSubstanceSpecificationStructureIsotopeMolecularWeightProperties(jsn : TJsonObject; result : TFhirSubstanceSpecificationStructureIsotopeMolecularWeight); overload; {b\}
    procedure ParseSubstanceSpecificationStructureIsotopeMolecularWeight(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSubstanceSpecificationStructureRepresentation(jsn : TJsonObject) : TFhirSubstanceSpecificationStructureRepresentation; overload; {b\}
    procedure ParseSubstanceSpecificationStructureRepresentationProperties(jsn : TJsonObject; result : TFhirSubstanceSpecificationStructureRepresentation); overload; {b\}
    procedure ParseSubstanceSpecificationStructureRepresentation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSubstanceSpecificationCode(jsn : TJsonObject) : TFhirSubstanceSpecificationCode; overload; {b\}
    procedure ParseSubstanceSpecificationCodeProperties(jsn : TJsonObject; result : TFhirSubstanceSpecificationCode); overload; {b\}
    procedure ParseSubstanceSpecificationCode(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSubstanceSpecificationName(jsn : TJsonObject) : TFhirSubstanceSpecificationName; overload; {b\}
    procedure ParseSubstanceSpecificationNameProperties(jsn : TJsonObject; result : TFhirSubstanceSpecificationName); overload; {b\}
    procedure ParseSubstanceSpecificationName(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSubstanceSpecificationNameOfficial(jsn : TJsonObject) : TFhirSubstanceSpecificationNameOfficial; overload; {b\}
    procedure ParseSubstanceSpecificationNameOfficialProperties(jsn : TJsonObject; result : TFhirSubstanceSpecificationNameOfficial); overload; {b\}
    procedure ParseSubstanceSpecificationNameOfficial(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSubstanceSpecificationRelationship(jsn : TJsonObject) : TFhirSubstanceSpecificationRelationship; overload; {b\}
    procedure ParseSubstanceSpecificationRelationshipProperties(jsn : TJsonObject; result : TFhirSubstanceSpecificationRelationship); overload; {b\}
    procedure ParseSubstanceSpecificationRelationship(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSubstanceSpecification(jsn : TJsonObject) : TFhirSubstanceSpecification; overload;
    procedure ParseSubstanceSpecificationProperties(jsn : TJsonObject; result : TFhirSubstanceSpecification); overload;
    procedure ParseSubstanceSpecification(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_SUBSTANCESPECIFICATION}
{$IFDEF FHIR_SUPPLYDELIVERY}
    function ParseSupplyDeliverySuppliedItem(jsn : TJsonObject) : TFhirSupplyDeliverySuppliedItem; overload; {b\}
    procedure ParseSupplyDeliverySuppliedItemProperties(jsn : TJsonObject; result : TFhirSupplyDeliverySuppliedItem); overload; {b\}
    procedure ParseSupplyDeliverySuppliedItem(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSupplyDelivery(jsn : TJsonObject) : TFhirSupplyDelivery; overload;
    procedure ParseSupplyDeliveryProperties(jsn : TJsonObject; result : TFhirSupplyDelivery); overload;
    procedure ParseSupplyDelivery(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_SUPPLYDELIVERY}
{$IFDEF FHIR_SUPPLYREQUEST}
    function ParseSupplyRequestParameter(jsn : TJsonObject) : TFhirSupplyRequestParameter; overload; {b\}
    procedure ParseSupplyRequestParameterProperties(jsn : TJsonObject; result : TFhirSupplyRequestParameter); overload; {b\}
    procedure ParseSupplyRequestParameter(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSupplyRequest(jsn : TJsonObject) : TFhirSupplyRequest; overload;
    procedure ParseSupplyRequestProperties(jsn : TJsonObject; result : TFhirSupplyRequest); overload;
    procedure ParseSupplyRequest(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_SUPPLYREQUEST}
{$IFDEF FHIR_TASK}
    function ParseTaskRestriction(jsn : TJsonObject) : TFhirTaskRestriction; overload; {b\}
    procedure ParseTaskRestrictionProperties(jsn : TJsonObject; result : TFhirTaskRestriction); overload; {b\}
    procedure ParseTaskRestriction(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTaskInput(jsn : TJsonObject) : TFhirTaskInput; overload; {b\}
    procedure ParseTaskInputProperties(jsn : TJsonObject; result : TFhirTaskInput); overload; {b\}
    procedure ParseTaskInput(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTaskOutput(jsn : TJsonObject) : TFhirTaskOutput; overload; {b\}
    procedure ParseTaskOutputProperties(jsn : TJsonObject; result : TFhirTaskOutput); overload; {b\}
    procedure ParseTaskOutput(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTask(jsn : TJsonObject) : TFhirTask; overload;
    procedure ParseTaskProperties(jsn : TJsonObject; result : TFhirTask); overload;
    procedure ParseTask(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_TASK}
{$IFDEF FHIR_TERMINOLOGYCAPABILITIES}
    function ParseTerminologyCapabilitiesSoftware(jsn : TJsonObject) : TFhirTerminologyCapabilitiesSoftware; overload; {b\}
    procedure ParseTerminologyCapabilitiesSoftwareProperties(jsn : TJsonObject; result : TFhirTerminologyCapabilitiesSoftware); overload; {b\}
    procedure ParseTerminologyCapabilitiesSoftware(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTerminologyCapabilitiesImplementation(jsn : TJsonObject) : TFhirTerminologyCapabilitiesImplementation; overload; {b\}
    procedure ParseTerminologyCapabilitiesImplementationProperties(jsn : TJsonObject; result : TFhirTerminologyCapabilitiesImplementation); overload; {b\}
    procedure ParseTerminologyCapabilitiesImplementation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTerminologyCapabilitiesCodeSystem(jsn : TJsonObject) : TFhirTerminologyCapabilitiesCodeSystem; overload; {b\}
    procedure ParseTerminologyCapabilitiesCodeSystemProperties(jsn : TJsonObject; result : TFhirTerminologyCapabilitiesCodeSystem); overload; {b\}
    procedure ParseTerminologyCapabilitiesCodeSystem(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTerminologyCapabilitiesCodeSystemVersion(jsn : TJsonObject) : TFhirTerminologyCapabilitiesCodeSystemVersion; overload; {b\}
    procedure ParseTerminologyCapabilitiesCodeSystemVersionProperties(jsn : TJsonObject; result : TFhirTerminologyCapabilitiesCodeSystemVersion); overload; {b\}
    procedure ParseTerminologyCapabilitiesCodeSystemVersion(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTerminologyCapabilitiesCodeSystemVersionFilter(jsn : TJsonObject) : TFhirTerminologyCapabilitiesCodeSystemVersionFilter; overload; {b\}
    procedure ParseTerminologyCapabilitiesCodeSystemVersionFilterProperties(jsn : TJsonObject; result : TFhirTerminologyCapabilitiesCodeSystemVersionFilter); overload; {b\}
    procedure ParseTerminologyCapabilitiesCodeSystemVersionFilter(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTerminologyCapabilitiesExpansion(jsn : TJsonObject) : TFhirTerminologyCapabilitiesExpansion; overload; {b\}
    procedure ParseTerminologyCapabilitiesExpansionProperties(jsn : TJsonObject; result : TFhirTerminologyCapabilitiesExpansion); overload; {b\}
    procedure ParseTerminologyCapabilitiesExpansion(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTerminologyCapabilitiesExpansionParameter(jsn : TJsonObject) : TFhirTerminologyCapabilitiesExpansionParameter; overload; {b\}
    procedure ParseTerminologyCapabilitiesExpansionParameterProperties(jsn : TJsonObject; result : TFhirTerminologyCapabilitiesExpansionParameter); overload; {b\}
    procedure ParseTerminologyCapabilitiesExpansionParameter(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTerminologyCapabilitiesValidateCode(jsn : TJsonObject) : TFhirTerminologyCapabilitiesValidateCode; overload; {b\}
    procedure ParseTerminologyCapabilitiesValidateCodeProperties(jsn : TJsonObject; result : TFhirTerminologyCapabilitiesValidateCode); overload; {b\}
    procedure ParseTerminologyCapabilitiesValidateCode(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTerminologyCapabilitiesTranslation(jsn : TJsonObject) : TFhirTerminologyCapabilitiesTranslation; overload; {b\}
    procedure ParseTerminologyCapabilitiesTranslationProperties(jsn : TJsonObject; result : TFhirTerminologyCapabilitiesTranslation); overload; {b\}
    procedure ParseTerminologyCapabilitiesTranslation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTerminologyCapabilitiesClosure(jsn : TJsonObject) : TFhirTerminologyCapabilitiesClosure; overload; {b\}
    procedure ParseTerminologyCapabilitiesClosureProperties(jsn : TJsonObject; result : TFhirTerminologyCapabilitiesClosure); overload; {b\}
    procedure ParseTerminologyCapabilitiesClosure(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTerminologyCapabilities(jsn : TJsonObject) : TFhirTerminologyCapabilities; overload;
    procedure ParseTerminologyCapabilitiesProperties(jsn : TJsonObject; result : TFhirTerminologyCapabilities); overload;
    procedure ParseTerminologyCapabilities(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_TERMINOLOGYCAPABILITIES}
{$IFDEF FHIR_TESTREPORT}
    function ParseTestReportParticipant(jsn : TJsonObject) : TFhirTestReportParticipant; overload; {b\}
    procedure ParseTestReportParticipantProperties(jsn : TJsonObject; result : TFhirTestReportParticipant); overload; {b\}
    procedure ParseTestReportParticipant(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTestReportSetup(jsn : TJsonObject) : TFhirTestReportSetup; overload; {b\}
    procedure ParseTestReportSetupProperties(jsn : TJsonObject; result : TFhirTestReportSetup); overload; {b\}
    procedure ParseTestReportSetup(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTestReportSetupAction(jsn : TJsonObject) : TFhirTestReportSetupAction; overload; {b\}
    procedure ParseTestReportSetupActionProperties(jsn : TJsonObject; result : TFhirTestReportSetupAction); overload; {b\}
    procedure ParseTestReportSetupAction(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTestReportSetupActionOperation(jsn : TJsonObject) : TFhirTestReportSetupActionOperation; overload; {b\}
    procedure ParseTestReportSetupActionOperationProperties(jsn : TJsonObject; result : TFhirTestReportSetupActionOperation); overload; {b\}
    procedure ParseTestReportSetupActionOperation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTestReportSetupActionAssert(jsn : TJsonObject) : TFhirTestReportSetupActionAssert; overload; {b\}
    procedure ParseTestReportSetupActionAssertProperties(jsn : TJsonObject; result : TFhirTestReportSetupActionAssert); overload; {b\}
    procedure ParseTestReportSetupActionAssert(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTestReportTest(jsn : TJsonObject) : TFhirTestReportTest; overload; {b\}
    procedure ParseTestReportTestProperties(jsn : TJsonObject; result : TFhirTestReportTest); overload; {b\}
    procedure ParseTestReportTest(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTestReportTestAction(jsn : TJsonObject) : TFhirTestReportTestAction; overload; {b\}
    procedure ParseTestReportTestActionProperties(jsn : TJsonObject; result : TFhirTestReportTestAction); overload; {b\}
    procedure ParseTestReportTestAction(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTestReportTeardown(jsn : TJsonObject) : TFhirTestReportTeardown; overload; {b\}
    procedure ParseTestReportTeardownProperties(jsn : TJsonObject; result : TFhirTestReportTeardown); overload; {b\}
    procedure ParseTestReportTeardown(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTestReportTeardownAction(jsn : TJsonObject) : TFhirTestReportTeardownAction; overload; {b\}
    procedure ParseTestReportTeardownActionProperties(jsn : TJsonObject; result : TFhirTestReportTeardownAction); overload; {b\}
    procedure ParseTestReportTeardownAction(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTestReport(jsn : TJsonObject) : TFhirTestReport; overload;
    procedure ParseTestReportProperties(jsn : TJsonObject; result : TFhirTestReport); overload;
    procedure ParseTestReport(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_TESTREPORT}
{$IFDEF FHIR_TESTSCRIPT}
    function ParseTestScriptOrigin(jsn : TJsonObject) : TFhirTestScriptOrigin; overload; {b\}
    procedure ParseTestScriptOriginProperties(jsn : TJsonObject; result : TFhirTestScriptOrigin); overload; {b\}
    procedure ParseTestScriptOrigin(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTestScriptDestination(jsn : TJsonObject) : TFhirTestScriptDestination; overload; {b\}
    procedure ParseTestScriptDestinationProperties(jsn : TJsonObject; result : TFhirTestScriptDestination); overload; {b\}
    procedure ParseTestScriptDestination(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTestScriptMetadata(jsn : TJsonObject) : TFhirTestScriptMetadata; overload; {b\}
    procedure ParseTestScriptMetadataProperties(jsn : TJsonObject; result : TFhirTestScriptMetadata); overload; {b\}
    procedure ParseTestScriptMetadata(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTestScriptMetadataLink(jsn : TJsonObject) : TFhirTestScriptMetadataLink; overload; {b\}
    procedure ParseTestScriptMetadataLinkProperties(jsn : TJsonObject; result : TFhirTestScriptMetadataLink); overload; {b\}
    procedure ParseTestScriptMetadataLink(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTestScriptMetadataCapability(jsn : TJsonObject) : TFhirTestScriptMetadataCapability; overload; {b\}
    procedure ParseTestScriptMetadataCapabilityProperties(jsn : TJsonObject; result : TFhirTestScriptMetadataCapability); overload; {b\}
    procedure ParseTestScriptMetadataCapability(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTestScriptFixture(jsn : TJsonObject) : TFhirTestScriptFixture; overload; {b\}
    procedure ParseTestScriptFixtureProperties(jsn : TJsonObject; result : TFhirTestScriptFixture); overload; {b\}
    procedure ParseTestScriptFixture(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTestScriptVariable(jsn : TJsonObject) : TFhirTestScriptVariable; overload; {b\}
    procedure ParseTestScriptVariableProperties(jsn : TJsonObject; result : TFhirTestScriptVariable); overload; {b\}
    procedure ParseTestScriptVariable(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTestScriptSetup(jsn : TJsonObject) : TFhirTestScriptSetup; overload; {b\}
    procedure ParseTestScriptSetupProperties(jsn : TJsonObject; result : TFhirTestScriptSetup); overload; {b\}
    procedure ParseTestScriptSetup(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTestScriptSetupAction(jsn : TJsonObject) : TFhirTestScriptSetupAction; overload; {b\}
    procedure ParseTestScriptSetupActionProperties(jsn : TJsonObject; result : TFhirTestScriptSetupAction); overload; {b\}
    procedure ParseTestScriptSetupAction(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTestScriptSetupActionOperation(jsn : TJsonObject) : TFhirTestScriptSetupActionOperation; overload; {b\}
    procedure ParseTestScriptSetupActionOperationProperties(jsn : TJsonObject; result : TFhirTestScriptSetupActionOperation); overload; {b\}
    procedure ParseTestScriptSetupActionOperation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTestScriptSetupActionOperationRequestHeader(jsn : TJsonObject) : TFhirTestScriptSetupActionOperationRequestHeader; overload; {b\}
    procedure ParseTestScriptSetupActionOperationRequestHeaderProperties(jsn : TJsonObject; result : TFhirTestScriptSetupActionOperationRequestHeader); overload; {b\}
    procedure ParseTestScriptSetupActionOperationRequestHeader(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTestScriptSetupActionAssert(jsn : TJsonObject) : TFhirTestScriptSetupActionAssert; overload; {b\}
    procedure ParseTestScriptSetupActionAssertProperties(jsn : TJsonObject; result : TFhirTestScriptSetupActionAssert); overload; {b\}
    procedure ParseTestScriptSetupActionAssert(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTestScriptTest(jsn : TJsonObject) : TFhirTestScriptTest; overload; {b\}
    procedure ParseTestScriptTestProperties(jsn : TJsonObject; result : TFhirTestScriptTest); overload; {b\}
    procedure ParseTestScriptTest(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTestScriptTestAction(jsn : TJsonObject) : TFhirTestScriptTestAction; overload; {b\}
    procedure ParseTestScriptTestActionProperties(jsn : TJsonObject; result : TFhirTestScriptTestAction); overload; {b\}
    procedure ParseTestScriptTestAction(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTestScriptTeardown(jsn : TJsonObject) : TFhirTestScriptTeardown; overload; {b\}
    procedure ParseTestScriptTeardownProperties(jsn : TJsonObject; result : TFhirTestScriptTeardown); overload; {b\}
    procedure ParseTestScriptTeardown(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTestScriptTeardownAction(jsn : TJsonObject) : TFhirTestScriptTeardownAction; overload; {b\}
    procedure ParseTestScriptTeardownActionProperties(jsn : TJsonObject; result : TFhirTestScriptTeardownAction); overload; {b\}
    procedure ParseTestScriptTeardownAction(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTestScript(jsn : TJsonObject) : TFhirTestScript; overload;
    procedure ParseTestScriptProperties(jsn : TJsonObject; result : TFhirTestScript); overload;
    procedure ParseTestScript(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_TESTSCRIPT}
{$IFDEF FHIR_VALUESET}
    function ParseValueSetCompose(jsn : TJsonObject) : TFhirValueSetCompose; overload; {b\}
    procedure ParseValueSetComposeProperties(jsn : TJsonObject; result : TFhirValueSetCompose); overload; {b\}
    procedure ParseValueSetCompose(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseValueSetComposeInclude(jsn : TJsonObject) : TFhirValueSetComposeInclude; overload; {b\}
    procedure ParseValueSetComposeIncludeProperties(jsn : TJsonObject; result : TFhirValueSetComposeInclude); overload; {b\}
    procedure ParseValueSetComposeInclude(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseValueSetComposeIncludeConcept(jsn : TJsonObject) : TFhirValueSetComposeIncludeConcept; overload; {b\}
    procedure ParseValueSetComposeIncludeConceptProperties(jsn : TJsonObject; result : TFhirValueSetComposeIncludeConcept); overload; {b\}
    procedure ParseValueSetComposeIncludeConcept(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseValueSetComposeIncludeConceptDesignation(jsn : TJsonObject) : TFhirValueSetComposeIncludeConceptDesignation; overload; {b\}
    procedure ParseValueSetComposeIncludeConceptDesignationProperties(jsn : TJsonObject; result : TFhirValueSetComposeIncludeConceptDesignation); overload; {b\}
    procedure ParseValueSetComposeIncludeConceptDesignation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseValueSetComposeIncludeFilter(jsn : TJsonObject) : TFhirValueSetComposeIncludeFilter; overload; {b\}
    procedure ParseValueSetComposeIncludeFilterProperties(jsn : TJsonObject; result : TFhirValueSetComposeIncludeFilter); overload; {b\}
    procedure ParseValueSetComposeIncludeFilter(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseValueSetExpansion(jsn : TJsonObject) : TFhirValueSetExpansion; overload; {b\}
    procedure ParseValueSetExpansionProperties(jsn : TJsonObject; result : TFhirValueSetExpansion); overload; {b\}
    procedure ParseValueSetExpansion(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseValueSetExpansionParameter(jsn : TJsonObject) : TFhirValueSetExpansionParameter; overload; {b\}
    procedure ParseValueSetExpansionParameterProperties(jsn : TJsonObject; result : TFhirValueSetExpansionParameter); overload; {b\}
    procedure ParseValueSetExpansionParameter(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseValueSetExpansionContains(jsn : TJsonObject) : TFhirValueSetExpansionContains; overload; {b\}
    procedure ParseValueSetExpansionContainsProperties(jsn : TJsonObject; result : TFhirValueSetExpansionContains); overload; {b\}
    procedure ParseValueSetExpansionContains(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseValueSet(jsn : TJsonObject) : TFhirValueSet; overload;
    procedure ParseValueSetProperties(jsn : TJsonObject; result : TFhirValueSet); overload;
    procedure ParseValueSet(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_VALUESET}
{$IFDEF FHIR_VERIFICATIONRESULT}
    function ParseVerificationResultPrimarySource(jsn : TJsonObject) : TFhirVerificationResultPrimarySource; overload; {b\}
    procedure ParseVerificationResultPrimarySourceProperties(jsn : TJsonObject; result : TFhirVerificationResultPrimarySource); overload; {b\}
    procedure ParseVerificationResultPrimarySource(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseVerificationResultAttestation(jsn : TJsonObject) : TFhirVerificationResultAttestation; overload; {b\}
    procedure ParseVerificationResultAttestationProperties(jsn : TJsonObject; result : TFhirVerificationResultAttestation); overload; {b\}
    procedure ParseVerificationResultAttestation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseVerificationResultValidator(jsn : TJsonObject) : TFhirVerificationResultValidator; overload; {b\}
    procedure ParseVerificationResultValidatorProperties(jsn : TJsonObject; result : TFhirVerificationResultValidator); overload; {b\}
    procedure ParseVerificationResultValidator(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseVerificationResult(jsn : TJsonObject) : TFhirVerificationResult; overload;
    procedure ParseVerificationResultProperties(jsn : TJsonObject; result : TFhirVerificationResult); overload;
    procedure ParseVerificationResult(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_VERIFICATIONRESULT}
{$IFDEF FHIR_VISIONPRESCRIPTION}
    function ParseVisionPrescriptionLensSpecification(jsn : TJsonObject) : TFhirVisionPrescriptionLensSpecification; overload; {b\}
    procedure ParseVisionPrescriptionLensSpecificationProperties(jsn : TJsonObject; result : TFhirVisionPrescriptionLensSpecification); overload; {b\}
    procedure ParseVisionPrescriptionLensSpecification(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseVisionPrescriptionLensSpecificationPrism(jsn : TJsonObject) : TFhirVisionPrescriptionLensSpecificationPrism; overload; {b\}
    procedure ParseVisionPrescriptionLensSpecificationPrismProperties(jsn : TJsonObject; result : TFhirVisionPrescriptionLensSpecificationPrism); overload; {b\}
    procedure ParseVisionPrescriptionLensSpecificationPrism(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseVisionPrescription(jsn : TJsonObject) : TFhirVisionPrescription; overload;
    procedure ParseVisionPrescriptionProperties(jsn : TJsonObject; result : TFhirVisionPrescription); overload;
    procedure ParseVisionPrescription(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_VISIONPRESCRIPTION}
    function ParseResource(jsn : TJsonObject) : TFhirResource; override;
    function ParseDataType(jsn : TJsonObject; name : String; type_ : TFHIRTypeClass) : TFHIRType; override;
  public
    function ParseFragment(jsn : TJsonObject; type_ : String) : TFHIRObject;  overload;
  end;

  TFHIRJsonComposer = class (TFHIRJsonComposerBase4)
  protected
    procedure ComposeElement(json : TJSONWriter; name : string; elem : TFhirElement; noObj : boolean = false);

    Procedure ComposeElementProperties(json : TJSONWriter; elem : TFhirElement);
    Procedure ComposeBackboneElementProperties(json : TJSONWriter; elem : TFhirBackboneElement); overload;
    Procedure ComposeBackboneTypeProperties(json : TJSONWriter; elem : TFhirBackboneType); overload;
    procedure ComposeBackboneElement(json : TJSONWriter; name : string; elem : TFhirBackboneElement; noObj : boolean = false);
    procedure ComposeBackboneType(json : TJSONWriter; name : string; elem : TFhirBackboneType; noObj : boolean = false);

    Procedure ComposeEnumValue(json : TJSONWriter; name : String; value : TFhirEnum; Const aNames : Array Of String; inArray : boolean);
    Procedure ComposeEnumProps(json : TJSONWriter; name : String; value : TFhirEnum; Const aNames : Array Of String; inArray : boolean);
    Procedure ComposeDateValue(json : TJSONWriter; name : String; value : TFhirDate; inArray : boolean);
    Procedure ComposeDateProps(json : TJSONWriter; name : String; value : TFhirDate; inArray : boolean);
    Procedure ComposeDateTimeValue(json : TJSONWriter; name : String; value : TFhirDateTime; inArray : boolean);
    Procedure ComposeDateTimeProps(json : TJSONWriter; name : String; value : TFhirDateTime; inArray : boolean);
    Procedure ComposeStringValue(json : TJSONWriter; name : String; value : TFhirString; inArray : boolean);
    Procedure ComposeStringProps(json : TJSONWriter; name : String; value : TFhirString; inArray : boolean);
    Procedure ComposeIntegerValue(json : TJSONWriter; name : String; value : TFhirInteger; inArray : boolean);
    Procedure ComposeIntegerProps(json : TJSONWriter; name : String; value : TFhirInteger; inArray : boolean);
    Procedure ComposeUriValue(json : TJSONWriter; name : String; value : TFhirUri; inArray : boolean);
    Procedure ComposeUriProps(json : TJSONWriter; name : String; value : TFhirUri; inArray : boolean);
    Procedure ComposeInstantValue(json : TJSONWriter; name : String; value : TFhirInstant; inArray : boolean);
    Procedure ComposeInstantProps(json : TJSONWriter; name : String; value : TFhirInstant; inArray : boolean);
    Procedure ComposeXhtmlValue(json : TJSONWriter; name : String; value : TFhirXhtml; inArray : boolean);
    Procedure ComposeXhtmlProps(json : TJSONWriter; name : String; value : TFhirXhtml; inArray : boolean);
    Procedure ComposeBooleanValue(json : TJSONWriter; name : String; value : TFhirBoolean; inArray : boolean);
    Procedure ComposeBooleanProps(json : TJSONWriter; name : String; value : TFhirBoolean; inArray : boolean);
    Procedure ComposeBase64BinaryValue(json : TJSONWriter; name : String; value : TFhirBase64Binary; inArray : boolean);
    Procedure ComposeBase64BinaryProps(json : TJSONWriter; name : String; value : TFhirBase64Binary; inArray : boolean);
    Procedure ComposeTimeValue(json : TJSONWriter; name : String; value : TFhirTime; inArray : boolean);
    Procedure ComposeTimeProps(json : TJSONWriter; name : String; value : TFhirTime; inArray : boolean);
    Procedure ComposeDecimalValue(json : TJSONWriter; name : String; value : TFhirDecimal; inArray : boolean);
    Procedure ComposeDecimalProps(json : TJSONWriter; name : String; value : TFhirDecimal; inArray : boolean);
    Procedure ComposeCodeValue(json : TJSONWriter; name : String; value : TFhirCode; inArray : boolean);
    Procedure ComposeCodeProps(json : TJSONWriter; name : String; value : TFhirCode; inArray : boolean);
    Procedure ComposeCanonicalValue(json : TJSONWriter; name : String; value : TFhirCanonical; inArray : boolean);
    Procedure ComposeCanonicalProps(json : TJSONWriter; name : String; value : TFhirCanonical; inArray : boolean);
    Procedure ComposeOidValue(json : TJSONWriter; name : String; value : TFhirOid; inArray : boolean);
    Procedure ComposeOidProps(json : TJSONWriter; name : String; value : TFhirOid; inArray : boolean);
    Procedure ComposeUuidValue(json : TJSONWriter; name : String; value : TFhirUuid; inArray : boolean);
    Procedure ComposeUuidProps(json : TJSONWriter; name : String; value : TFhirUuid; inArray : boolean);
    Procedure ComposeUrlValue(json : TJSONWriter; name : String; value : TFhirUrl; inArray : boolean);
    Procedure ComposeUrlProps(json : TJSONWriter; name : String; value : TFhirUrl; inArray : boolean);
    Procedure ComposeMarkdownValue(json : TJSONWriter; name : String; value : TFhirMarkdown; inArray : boolean);
    Procedure ComposeMarkdownProps(json : TJSONWriter; name : String; value : TFhirMarkdown; inArray : boolean);
    Procedure ComposeUnsignedIntValue(json : TJSONWriter; name : String; value : TFhirUnsignedInt; inArray : boolean);
    Procedure ComposeUnsignedIntProps(json : TJSONWriter; name : String; value : TFhirUnsignedInt; inArray : boolean);
    Procedure ComposeIdValue(json : TJSONWriter; name : String; value : TFhirId; inArray : boolean);
    Procedure ComposeIdProps(json : TJSONWriter; name : String; value : TFhirId; inArray : boolean);
    Procedure ComposePositiveIntValue(json : TJSONWriter; name : String; value : TFhirPositiveInt; inArray : boolean);
    Procedure ComposePositiveIntProps(json : TJSONWriter; name : String; value : TFhirPositiveInt; inArray : boolean);

    Procedure ComposeResourceProperties(json : TJSONWriter; elem : TFhirResource);
    Procedure ComposeDomainResourceProperties(json : TJSONWriter; elem : TFhirDomainResource);
{$IFDEF FHIR_PARAMETERS}
    procedure ComposeParametersParameter(json : TJSONWriter; name : string; elem : TFhirParametersParameter; noObj : boolean = false);
    procedure ComposeParameters(json : TJSONWriter; name : string; elem : TFhirParameters; noObj : boolean = false);
{$ENDIF FHIR_PARAMETERS}

    procedure ComposeExtension(json : TJSONWriter; name : string; elem : TFhirExtension; noObj : boolean = false);
    procedure ComposeNarrative(json : TJSONWriter; name : string; elem : TFhirNarrative; noObj : boolean = false);
    procedure ComposeContributor(json : TJSONWriter; name : string; elem : TFhirContributor; noObj : boolean = false);
    procedure ComposeAttachment(json : TJSONWriter; name : string; elem : TFhirAttachment; noObj : boolean = false);
    procedure ComposeDataRequirementCodeFilter(json : TJSONWriter; name : string; elem : TFhirDataRequirementCodeFilter; noObj : boolean = false);
    procedure ComposeDataRequirementDateFilter(json : TJSONWriter; name : string; elem : TFhirDataRequirementDateFilter; noObj : boolean = false);
    procedure ComposeDataRequirementSort(json : TJSONWriter; name : string; elem : TFhirDataRequirementSort; noObj : boolean = false);
    procedure ComposeDataRequirement(json : TJSONWriter; name : string; elem : TFhirDataRequirement; noObj : boolean = false);
    procedure ComposeDosageDoseAndRate(json : TJSONWriter; name : string; elem : TFhirDosageDoseAndRate; noObj : boolean = false);
    procedure ComposeDosage(json : TJSONWriter; name : string; elem : TFhirDosage; noObj : boolean = false);
    procedure ComposeMoney(json : TJSONWriter; name : string; elem : TFhirMoney; noObj : boolean = false);
    procedure ComposeMarketingStatus(json : TJSONWriter; name : string; elem : TFhirMarketingStatus; noObj : boolean = false);
    procedure ComposeIdentifier(json : TJSONWriter; name : string; elem : TFhirIdentifier; noObj : boolean = false);
    procedure ComposeSubstanceAmountReferenceRange(json : TJSONWriter; name : string; elem : TFhirSubstanceAmountReferenceRange; noObj : boolean = false);
    procedure ComposeSubstanceAmount(json : TJSONWriter; name : string; elem : TFhirSubstanceAmount; noObj : boolean = false);
    procedure ComposeCoding(json : TJSONWriter; name : string; elem : TFhirCoding; noObj : boolean = false);
    procedure ComposeSampledData(json : TJSONWriter; name : string; elem : TFhirSampledData; noObj : boolean = false);
    procedure ComposePopulation(json : TJSONWriter; name : string; elem : TFhirPopulation; noObj : boolean = false);
    procedure ComposeRatio(json : TJSONWriter; name : string; elem : TFhirRatio; noObj : boolean = false);
    procedure ComposeReference(json : TJSONWriter; name : string; elem : TFhirReference; noObj : boolean = false);
    procedure ComposeTriggerDefinition(json : TJSONWriter; name : string; elem : TFhirTriggerDefinition; noObj : boolean = false);
    procedure ComposePeriod(json : TJSONWriter; name : string; elem : TFhirPeriod; noObj : boolean = false);
    procedure ComposeQuantity(json : TJSONWriter; name : string; elem : TFhirQuantity; noObj : boolean = false);
    procedure ComposeRange(json : TJSONWriter; name : string; elem : TFhirRange; noObj : boolean = false);
    procedure ComposeRelatedArtifact(json : TJSONWriter; name : string; elem : TFhirRelatedArtifact; noObj : boolean = false);
    procedure ComposeAnnotation(json : TJSONWriter; name : string; elem : TFhirAnnotation; noObj : boolean = false);
    procedure ComposeProductShelfLife(json : TJSONWriter; name : string; elem : TFhirProductShelfLife; noObj : boolean = false);
    procedure ComposeContactDetail(json : TJSONWriter; name : string; elem : TFhirContactDetail; noObj : boolean = false);
    procedure ComposeExpression(json : TJSONWriter; name : string; elem : TFhirExpression; noObj : boolean = false);
    procedure ComposeUsageContext(json : TJSONWriter; name : string; elem : TFhirUsageContext; noObj : boolean = false);
    procedure ComposeSignature(json : TJSONWriter; name : string; elem : TFhirSignature; noObj : boolean = false);
    procedure ComposeProdCharacteristic(json : TJSONWriter; name : string; elem : TFhirProdCharacteristic; noObj : boolean = false);
    procedure ComposeCodeableConcept(json : TJSONWriter; name : string; elem : TFhirCodeableConcept; noObj : boolean = false);
    procedure ComposeParameterDefinition(json : TJSONWriter; name : string; elem : TFhirParameterDefinition; noObj : boolean = false);
    procedure ComposeContactPoint(json : TJSONWriter; name : string; elem : TFhirContactPoint; noObj : boolean = false);
    procedure ComposeHumanName(json : TJSONWriter; name : string; elem : TFhirHumanName; noObj : boolean = false);
    procedure ComposeMeta(json : TJSONWriter; name : string; elem : TFhirMeta; noObj : boolean = false);
    procedure ComposeAddress(json : TJSONWriter; name : string; elem : TFhirAddress; noObj : boolean = false);
    procedure ComposeElementDefinitionSlicing(json : TJSONWriter; name : string; elem : TFhirElementDefinitionSlicing; noObj : boolean = false);
    procedure ComposeElementDefinitionSlicingDiscriminator(json : TJSONWriter; name : string; elem : TFhirElementDefinitionSlicingDiscriminator; noObj : boolean = false);
    procedure ComposeElementDefinitionBase(json : TJSONWriter; name : string; elem : TFhirElementDefinitionBase; noObj : boolean = false);
    procedure ComposeElementDefinitionType(json : TJSONWriter; name : string; elem : TFhirElementDefinitionType; noObj : boolean = false);
    procedure ComposeElementDefinitionExample(json : TJSONWriter; name : string; elem : TFhirElementDefinitionExample; noObj : boolean = false);
    procedure ComposeElementDefinitionConstraint(json : TJSONWriter; name : string; elem : TFhirElementDefinitionConstraint; noObj : boolean = false);
    procedure ComposeElementDefinitionBinding(json : TJSONWriter; name : string; elem : TFhirElementDefinitionBinding; noObj : boolean = false);
    procedure ComposeElementDefinitionMapping(json : TJSONWriter; name : string; elem : TFhirElementDefinitionMapping; noObj : boolean = false);
    procedure ComposeElementDefinition(json : TJSONWriter; name : string; elem : TFhirElementDefinition; noObj : boolean = false);
    procedure ComposeTimingRepeat(json : TJSONWriter; name : string; elem : TFhirTimingRepeat; noObj : boolean = false);
    procedure ComposeTiming(json : TJSONWriter; name : string; elem : TFhirTiming; noObj : boolean = false);
    procedure ComposeCount(json : TJSONWriter; name : string; elem : TFhirCount; noObj : boolean = false);
    procedure ComposeAge(json : TJSONWriter; name : string; elem : TFhirAge; noObj : boolean = false);
    procedure ComposeDistance(json : TJSONWriter; name : string; elem : TFhirDistance; noObj : boolean = false);
    procedure ComposeDuration(json : TJSONWriter; name : string; elem : TFhirDuration; noObj : boolean = false);

{$IFDEF FHIR_ACCOUNT}
    procedure ComposeAccountCoverage(json : TJSONWriter; name : string; elem : TFhirAccountCoverage; noObj : boolean = false);
    procedure ComposeAccountGuarantor(json : TJSONWriter; name : string; elem : TFhirAccountGuarantor; noObj : boolean = false);
    procedure ComposeAccount(json : TJSONWriter; name : string; elem : TFhirAccount; noObj : boolean = false);
{$ENDIF FHIR_ACCOUNT}
{$IFDEF FHIR_ACTIVITYDEFINITION}
    procedure ComposeActivityDefinitionParticipant(json : TJSONWriter; name : string; elem : TFhirActivityDefinitionParticipant; noObj : boolean = false);
    procedure ComposeActivityDefinitionDynamicValue(json : TJSONWriter; name : string; elem : TFhirActivityDefinitionDynamicValue; noObj : boolean = false);
    procedure ComposeActivityDefinition(json : TJSONWriter; name : string; elem : TFhirActivityDefinition; noObj : boolean = false);
{$ENDIF FHIR_ACTIVITYDEFINITION}
{$IFDEF FHIR_ADVERSEEVENT}
    procedure ComposeAdverseEventSuspectEntity(json : TJSONWriter; name : string; elem : TFhirAdverseEventSuspectEntity; noObj : boolean = false);
    procedure ComposeAdverseEventSuspectEntityCausality(json : TJSONWriter; name : string; elem : TFhirAdverseEventSuspectEntityCausality; noObj : boolean = false);
    procedure ComposeAdverseEvent(json : TJSONWriter; name : string; elem : TFhirAdverseEvent; noObj : boolean = false);
{$ENDIF FHIR_ADVERSEEVENT}
{$IFDEF FHIR_ALLERGYINTOLERANCE}
    procedure ComposeAllergyIntoleranceReaction(json : TJSONWriter; name : string; elem : TFhirAllergyIntoleranceReaction; noObj : boolean = false);
    procedure ComposeAllergyIntolerance(json : TJSONWriter; name : string; elem : TFhirAllergyIntolerance; noObj : boolean = false);
{$ENDIF FHIR_ALLERGYINTOLERANCE}
{$IFDEF FHIR_APPOINTMENT}
    procedure ComposeAppointmentParticipant(json : TJSONWriter; name : string; elem : TFhirAppointmentParticipant; noObj : boolean = false);
    procedure ComposeAppointment(json : TJSONWriter; name : string; elem : TFhirAppointment; noObj : boolean = false);
{$ENDIF FHIR_APPOINTMENT}
{$IFDEF FHIR_APPOINTMENTRESPONSE}
    procedure ComposeAppointmentResponse(json : TJSONWriter; name : string; elem : TFhirAppointmentResponse; noObj : boolean = false);
{$ENDIF FHIR_APPOINTMENTRESPONSE}
{$IFDEF FHIR_AUDITEVENT}
    procedure ComposeAuditEventAgent(json : TJSONWriter; name : string; elem : TFhirAuditEventAgent; noObj : boolean = false);
    procedure ComposeAuditEventAgentNetwork(json : TJSONWriter; name : string; elem : TFhirAuditEventAgentNetwork; noObj : boolean = false);
    procedure ComposeAuditEventSource(json : TJSONWriter; name : string; elem : TFhirAuditEventSource; noObj : boolean = false);
    procedure ComposeAuditEventEntity(json : TJSONWriter; name : string; elem : TFhirAuditEventEntity; noObj : boolean = false);
    procedure ComposeAuditEventEntityDetail(json : TJSONWriter; name : string; elem : TFhirAuditEventEntityDetail; noObj : boolean = false);
    procedure ComposeAuditEvent(json : TJSONWriter; name : string; elem : TFhirAuditEvent; noObj : boolean = false);
{$ENDIF FHIR_AUDITEVENT}
{$IFDEF FHIR_BASIC}
    procedure ComposeBasic(json : TJSONWriter; name : string; elem : TFhirBasic; noObj : boolean = false);
{$ENDIF FHIR_BASIC}
{$IFDEF FHIR_BINARY}
    procedure ComposeBinary(json : TJSONWriter; name : string; elem : TFhirBinary; noObj : boolean = false);
{$ENDIF FHIR_BINARY}
{$IFDEF FHIR_BIOLOGICALLYDERIVEDPRODUCT}
    procedure ComposeBiologicallyDerivedProductCollection(json : TJSONWriter; name : string; elem : TFhirBiologicallyDerivedProductCollection; noObj : boolean = false);
    procedure ComposeBiologicallyDerivedProductProcessing(json : TJSONWriter; name : string; elem : TFhirBiologicallyDerivedProductProcessing; noObj : boolean = false);
    procedure ComposeBiologicallyDerivedProductManipulation(json : TJSONWriter; name : string; elem : TFhirBiologicallyDerivedProductManipulation; noObj : boolean = false);
    procedure ComposeBiologicallyDerivedProductStorage(json : TJSONWriter; name : string; elem : TFhirBiologicallyDerivedProductStorage; noObj : boolean = false);
    procedure ComposeBiologicallyDerivedProduct(json : TJSONWriter; name : string; elem : TFhirBiologicallyDerivedProduct; noObj : boolean = false);
{$ENDIF FHIR_BIOLOGICALLYDERIVEDPRODUCT}
{$IFDEF FHIR_BODYSTRUCTURE}
    procedure ComposeBodyStructure(json : TJSONWriter; name : string; elem : TFhirBodyStructure; noObj : boolean = false);
{$ENDIF FHIR_BODYSTRUCTURE}
{$IFDEF FHIR_BUNDLE}
    procedure ComposeBundleLink(json : TJSONWriter; name : string; elem : TFhirBundleLink; noObj : boolean = false);
    procedure ComposeBundleEntry(json : TJSONWriter; name : string; elem : TFhirBundleEntry; noObj : boolean = false);
    procedure ComposeBundleEntrySearch(json : TJSONWriter; name : string; elem : TFhirBundleEntrySearch; noObj : boolean = false);
    procedure ComposeBundleEntryRequest(json : TJSONWriter; name : string; elem : TFhirBundleEntryRequest; noObj : boolean = false);
    procedure ComposeBundleEntryResponse(json : TJSONWriter; name : string; elem : TFhirBundleEntryResponse; noObj : boolean = false);
    procedure ComposeBundle(json : TJSONWriter; name : string; elem : TFhirBundle; noObj : boolean = false);
{$ENDIF FHIR_BUNDLE}
{$IFDEF FHIR_CAPABILITYSTATEMENT}
    procedure ComposeCapabilityStatementSoftware(json : TJSONWriter; name : string; elem : TFhirCapabilityStatementSoftware; noObj : boolean = false);
    procedure ComposeCapabilityStatementImplementation(json : TJSONWriter; name : string; elem : TFhirCapabilityStatementImplementation; noObj : boolean = false);
    procedure ComposeCapabilityStatementRest(json : TJSONWriter; name : string; elem : TFhirCapabilityStatementRest; noObj : boolean = false);
    procedure ComposeCapabilityStatementRestSecurity(json : TJSONWriter; name : string; elem : TFhirCapabilityStatementRestSecurity; noObj : boolean = false);
    procedure ComposeCapabilityStatementRestResource(json : TJSONWriter; name : string; elem : TFhirCapabilityStatementRestResource; noObj : boolean = false);
    procedure ComposeCapabilityStatementRestResourceInteraction(json : TJSONWriter; name : string; elem : TFhirCapabilityStatementRestResourceInteraction; noObj : boolean = false);
    procedure ComposeCapabilityStatementRestResourceSearchParam(json : TJSONWriter; name : string; elem : TFhirCapabilityStatementRestResourceSearchParam; noObj : boolean = false);
    procedure ComposeCapabilityStatementRestResourceOperation(json : TJSONWriter; name : string; elem : TFhirCapabilityStatementRestResourceOperation; noObj : boolean = false);
    procedure ComposeCapabilityStatementRestInteraction(json : TJSONWriter; name : string; elem : TFhirCapabilityStatementRestInteraction; noObj : boolean = false);
    procedure ComposeCapabilityStatementMessaging(json : TJSONWriter; name : string; elem : TFhirCapabilityStatementMessaging; noObj : boolean = false);
    procedure ComposeCapabilityStatementMessagingEndpoint(json : TJSONWriter; name : string; elem : TFhirCapabilityStatementMessagingEndpoint; noObj : boolean = false);
    procedure ComposeCapabilityStatementMessagingSupportedMessage(json : TJSONWriter; name : string; elem : TFhirCapabilityStatementMessagingSupportedMessage; noObj : boolean = false);
    procedure ComposeCapabilityStatementDocument(json : TJSONWriter; name : string; elem : TFhirCapabilityStatementDocument; noObj : boolean = false);
    procedure ComposeCapabilityStatement(json : TJSONWriter; name : string; elem : TFhirCapabilityStatement; noObj : boolean = false);
{$ENDIF FHIR_CAPABILITYSTATEMENT}
{$IFDEF FHIR_CAREPLAN}
    procedure ComposeCarePlanActivity(json : TJSONWriter; name : string; elem : TFhirCarePlanActivity; noObj : boolean = false);
    procedure ComposeCarePlanActivityDetail(json : TJSONWriter; name : string; elem : TFhirCarePlanActivityDetail; noObj : boolean = false);
    procedure ComposeCarePlan(json : TJSONWriter; name : string; elem : TFhirCarePlan; noObj : boolean = false);
{$ENDIF FHIR_CAREPLAN}
{$IFDEF FHIR_CARETEAM}
    procedure ComposeCareTeamParticipant(json : TJSONWriter; name : string; elem : TFhirCareTeamParticipant; noObj : boolean = false);
    procedure ComposeCareTeam(json : TJSONWriter; name : string; elem : TFhirCareTeam; noObj : boolean = false);
{$ENDIF FHIR_CARETEAM}
{$IFDEF FHIR_CATALOGENTRY}
    procedure ComposeCatalogEntryRelatedEntry(json : TJSONWriter; name : string; elem : TFhirCatalogEntryRelatedEntry; noObj : boolean = false);
    procedure ComposeCatalogEntry(json : TJSONWriter; name : string; elem : TFhirCatalogEntry; noObj : boolean = false);
{$ENDIF FHIR_CATALOGENTRY}
{$IFDEF FHIR_CHARGEITEM}
    procedure ComposeChargeItemPerformer(json : TJSONWriter; name : string; elem : TFhirChargeItemPerformer; noObj : boolean = false);
    procedure ComposeChargeItem(json : TJSONWriter; name : string; elem : TFhirChargeItem; noObj : boolean = false);
{$ENDIF FHIR_CHARGEITEM}
{$IFDEF FHIR_CHARGEITEMDEFINITION}
    procedure ComposeChargeItemDefinitionApplicability(json : TJSONWriter; name : string; elem : TFhirChargeItemDefinitionApplicability; noObj : boolean = false);
    procedure ComposeChargeItemDefinitionPropertyGroup(json : TJSONWriter; name : string; elem : TFhirChargeItemDefinitionPropertyGroup; noObj : boolean = false);
    procedure ComposeChargeItemDefinitionPropertyGroupPriceComponent(json : TJSONWriter; name : string; elem : TFhirChargeItemDefinitionPropertyGroupPriceComponent; noObj : boolean = false);
    procedure ComposeChargeItemDefinition(json : TJSONWriter; name : string; elem : TFhirChargeItemDefinition; noObj : boolean = false);
{$ENDIF FHIR_CHARGEITEMDEFINITION}
{$IFDEF FHIR_CLAIM}
    procedure ComposeClaimRelated(json : TJSONWriter; name : string; elem : TFhirClaimRelated; noObj : boolean = false);
    procedure ComposeClaimPayee(json : TJSONWriter; name : string; elem : TFhirClaimPayee; noObj : boolean = false);
    procedure ComposeClaimCareTeam(json : TJSONWriter; name : string; elem : TFhirClaimCareTeam; noObj : boolean = false);
    procedure ComposeClaimSupportingInfo(json : TJSONWriter; name : string; elem : TFhirClaimSupportingInfo; noObj : boolean = false);
    procedure ComposeClaimDiagnosis(json : TJSONWriter; name : string; elem : TFhirClaimDiagnosis; noObj : boolean = false);
    procedure ComposeClaimProcedure(json : TJSONWriter; name : string; elem : TFhirClaimProcedure; noObj : boolean = false);
    procedure ComposeClaimInsurance(json : TJSONWriter; name : string; elem : TFhirClaimInsurance; noObj : boolean = false);
    procedure ComposeClaimAccident(json : TJSONWriter; name : string; elem : TFhirClaimAccident; noObj : boolean = false);
    procedure ComposeClaimItem(json : TJSONWriter; name : string; elem : TFhirClaimItem; noObj : boolean = false);
    procedure ComposeClaimItemDetail(json : TJSONWriter; name : string; elem : TFhirClaimItemDetail; noObj : boolean = false);
    procedure ComposeClaimItemDetailSubDetail(json : TJSONWriter; name : string; elem : TFhirClaimItemDetailSubDetail; noObj : boolean = false);
    procedure ComposeClaim(json : TJSONWriter; name : string; elem : TFhirClaim; noObj : boolean = false);
{$ENDIF FHIR_CLAIM}
{$IFDEF FHIR_CLAIMRESPONSE}
    procedure ComposeClaimResponseItem(json : TJSONWriter; name : string; elem : TFhirClaimResponseItem; noObj : boolean = false);
    procedure ComposeClaimResponseItemAdjudication(json : TJSONWriter; name : string; elem : TFhirClaimResponseItemAdjudication; noObj : boolean = false);
    procedure ComposeClaimResponseItemDetail(json : TJSONWriter; name : string; elem : TFhirClaimResponseItemDetail; noObj : boolean = false);
    procedure ComposeClaimResponseItemDetailSubDetail(json : TJSONWriter; name : string; elem : TFhirClaimResponseItemDetailSubDetail; noObj : boolean = false);
    procedure ComposeClaimResponseAddItem(json : TJSONWriter; name : string; elem : TFhirClaimResponseAddItem; noObj : boolean = false);
    procedure ComposeClaimResponseAddItemDetail(json : TJSONWriter; name : string; elem : TFhirClaimResponseAddItemDetail; noObj : boolean = false);
    procedure ComposeClaimResponseAddItemDetailSubDetail(json : TJSONWriter; name : string; elem : TFhirClaimResponseAddItemDetailSubDetail; noObj : boolean = false);
    procedure ComposeClaimResponseTotal(json : TJSONWriter; name : string; elem : TFhirClaimResponseTotal; noObj : boolean = false);
    procedure ComposeClaimResponsePayment(json : TJSONWriter; name : string; elem : TFhirClaimResponsePayment; noObj : boolean = false);
    procedure ComposeClaimResponseProcessNote(json : TJSONWriter; name : string; elem : TFhirClaimResponseProcessNote; noObj : boolean = false);
    procedure ComposeClaimResponseInsurance(json : TJSONWriter; name : string; elem : TFhirClaimResponseInsurance; noObj : boolean = false);
    procedure ComposeClaimResponseError(json : TJSONWriter; name : string; elem : TFhirClaimResponseError; noObj : boolean = false);
    procedure ComposeClaimResponse(json : TJSONWriter; name : string; elem : TFhirClaimResponse; noObj : boolean = false);
{$ENDIF FHIR_CLAIMRESPONSE}
{$IFDEF FHIR_CLINICALIMPRESSION}
    procedure ComposeClinicalImpressionInvestigation(json : TJSONWriter; name : string; elem : TFhirClinicalImpressionInvestigation; noObj : boolean = false);
    procedure ComposeClinicalImpressionFinding(json : TJSONWriter; name : string; elem : TFhirClinicalImpressionFinding; noObj : boolean = false);
    procedure ComposeClinicalImpression(json : TJSONWriter; name : string; elem : TFhirClinicalImpression; noObj : boolean = false);
{$ENDIF FHIR_CLINICALIMPRESSION}
{$IFDEF FHIR_CODESYSTEM}
    procedure ComposeCodeSystemFilter(json : TJSONWriter; name : string; elem : TFhirCodeSystemFilter; noObj : boolean = false);
    procedure ComposeCodeSystemProperty(json : TJSONWriter; name : string; elem : TFhirCodeSystemProperty; noObj : boolean = false);
    procedure ComposeCodeSystemConcept(json : TJSONWriter; name : string; elem : TFhirCodeSystemConcept; noObj : boolean = false);
    procedure ComposeCodeSystemConceptDesignation(json : TJSONWriter; name : string; elem : TFhirCodeSystemConceptDesignation; noObj : boolean = false);
    procedure ComposeCodeSystemConceptProperty(json : TJSONWriter; name : string; elem : TFhirCodeSystemConceptProperty; noObj : boolean = false);
    procedure ComposeCodeSystem(json : TJSONWriter; name : string; elem : TFhirCodeSystem; noObj : boolean = false);
{$ENDIF FHIR_CODESYSTEM}
{$IFDEF FHIR_COMMUNICATION}
    procedure ComposeCommunicationPayload(json : TJSONWriter; name : string; elem : TFhirCommunicationPayload; noObj : boolean = false);
    procedure ComposeCommunication(json : TJSONWriter; name : string; elem : TFhirCommunication; noObj : boolean = false);
{$ENDIF FHIR_COMMUNICATION}
{$IFDEF FHIR_COMMUNICATIONREQUEST}
    procedure ComposeCommunicationRequestPayload(json : TJSONWriter; name : string; elem : TFhirCommunicationRequestPayload; noObj : boolean = false);
    procedure ComposeCommunicationRequest(json : TJSONWriter; name : string; elem : TFhirCommunicationRequest; noObj : boolean = false);
{$ENDIF FHIR_COMMUNICATIONREQUEST}
{$IFDEF FHIR_COMPARTMENTDEFINITION}
    procedure ComposeCompartmentDefinitionResource(json : TJSONWriter; name : string; elem : TFhirCompartmentDefinitionResource; noObj : boolean = false);
    procedure ComposeCompartmentDefinition(json : TJSONWriter; name : string; elem : TFhirCompartmentDefinition; noObj : boolean = false);
{$ENDIF FHIR_COMPARTMENTDEFINITION}
{$IFDEF FHIR_COMPOSITION}
    procedure ComposeCompositionAttester(json : TJSONWriter; name : string; elem : TFhirCompositionAttester; noObj : boolean = false);
    procedure ComposeCompositionRelatesTo(json : TJSONWriter; name : string; elem : TFhirCompositionRelatesTo; noObj : boolean = false);
    procedure ComposeCompositionEvent(json : TJSONWriter; name : string; elem : TFhirCompositionEvent; noObj : boolean = false);
    procedure ComposeCompositionSection(json : TJSONWriter; name : string; elem : TFhirCompositionSection; noObj : boolean = false);
    procedure ComposeComposition(json : TJSONWriter; name : string; elem : TFhirComposition; noObj : boolean = false);
{$ENDIF FHIR_COMPOSITION}
{$IFDEF FHIR_CONCEPTMAP}
    procedure ComposeConceptMapGroup(json : TJSONWriter; name : string; elem : TFhirConceptMapGroup; noObj : boolean = false);
    procedure ComposeConceptMapGroupElement(json : TJSONWriter; name : string; elem : TFhirConceptMapGroupElement; noObj : boolean = false);
    procedure ComposeConceptMapGroupElementTarget(json : TJSONWriter; name : string; elem : TFhirConceptMapGroupElementTarget; noObj : boolean = false);
    procedure ComposeConceptMapGroupElementTargetDependsOn(json : TJSONWriter; name : string; elem : TFhirConceptMapGroupElementTargetDependsOn; noObj : boolean = false);
    procedure ComposeConceptMapGroupUnmapped(json : TJSONWriter; name : string; elem : TFhirConceptMapGroupUnmapped; noObj : boolean = false);
    procedure ComposeConceptMap(json : TJSONWriter; name : string; elem : TFhirConceptMap; noObj : boolean = false);
{$ENDIF FHIR_CONCEPTMAP}
{$IFDEF FHIR_CONDITION}
    procedure ComposeConditionStage(json : TJSONWriter; name : string; elem : TFhirConditionStage; noObj : boolean = false);
    procedure ComposeConditionEvidence(json : TJSONWriter; name : string; elem : TFhirConditionEvidence; noObj : boolean = false);
    procedure ComposeCondition(json : TJSONWriter; name : string; elem : TFhirCondition; noObj : boolean = false);
{$ENDIF FHIR_CONDITION}
{$IFDEF FHIR_CONSENT}
    procedure ComposeConsentPolicy(json : TJSONWriter; name : string; elem : TFhirConsentPolicy; noObj : boolean = false);
    procedure ComposeConsentVerification(json : TJSONWriter; name : string; elem : TFhirConsentVerification; noObj : boolean = false);
    procedure ComposeConsentProvision(json : TJSONWriter; name : string; elem : TFhirConsentProvision; noObj : boolean = false);
    procedure ComposeConsentProvisionActor(json : TJSONWriter; name : string; elem : TFhirConsentProvisionActor; noObj : boolean = false);
    procedure ComposeConsentProvisionData(json : TJSONWriter; name : string; elem : TFhirConsentProvisionData; noObj : boolean = false);
    procedure ComposeConsent(json : TJSONWriter; name : string; elem : TFhirConsent; noObj : boolean = false);
{$ENDIF FHIR_CONSENT}
{$IFDEF FHIR_CONTRACT}
    procedure ComposeContractContentDefinition(json : TJSONWriter; name : string; elem : TFhirContractContentDefinition; noObj : boolean = false);
    procedure ComposeContractTerm(json : TJSONWriter; name : string; elem : TFhirContractTerm; noObj : boolean = false);
    procedure ComposeContractTermSecurityLabel(json : TJSONWriter; name : string; elem : TFhirContractTermSecurityLabel; noObj : boolean = false);
    procedure ComposeContractTermOffer(json : TJSONWriter; name : string; elem : TFhirContractTermOffer; noObj : boolean = false);
    procedure ComposeContractTermOfferParty(json : TJSONWriter; name : string; elem : TFhirContractTermOfferParty; noObj : boolean = false);
    procedure ComposeContractTermOfferAnswer(json : TJSONWriter; name : string; elem : TFhirContractTermOfferAnswer; noObj : boolean = false);
    procedure ComposeContractTermAsset(json : TJSONWriter; name : string; elem : TFhirContractTermAsset; noObj : boolean = false);
    procedure ComposeContractTermAssetContext(json : TJSONWriter; name : string; elem : TFhirContractTermAssetContext; noObj : boolean = false);
    procedure ComposeContractTermAssetValuedItem(json : TJSONWriter; name : string; elem : TFhirContractTermAssetValuedItem; noObj : boolean = false);
    procedure ComposeContractTermAction(json : TJSONWriter; name : string; elem : TFhirContractTermAction; noObj : boolean = false);
    procedure ComposeContractTermActionSubject(json : TJSONWriter; name : string; elem : TFhirContractTermActionSubject; noObj : boolean = false);
    procedure ComposeContractSigner(json : TJSONWriter; name : string; elem : TFhirContractSigner; noObj : boolean = false);
    procedure ComposeContractFriendly(json : TJSONWriter; name : string; elem : TFhirContractFriendly; noObj : boolean = false);
    procedure ComposeContractLegal(json : TJSONWriter; name : string; elem : TFhirContractLegal; noObj : boolean = false);
    procedure ComposeContractRule(json : TJSONWriter; name : string; elem : TFhirContractRule; noObj : boolean = false);
    procedure ComposeContract(json : TJSONWriter; name : string; elem : TFhirContract; noObj : boolean = false);
{$ENDIF FHIR_CONTRACT}
{$IFDEF FHIR_COVERAGE}
    procedure ComposeCoverageClass(json : TJSONWriter; name : string; elem : TFhirCoverageClass; noObj : boolean = false);
    procedure ComposeCoverageCostToBeneficiary(json : TJSONWriter; name : string; elem : TFhirCoverageCostToBeneficiary; noObj : boolean = false);
    procedure ComposeCoverageCostToBeneficiaryException(json : TJSONWriter; name : string; elem : TFhirCoverageCostToBeneficiaryException; noObj : boolean = false);
    procedure ComposeCoverage(json : TJSONWriter; name : string; elem : TFhirCoverage; noObj : boolean = false);
{$ENDIF FHIR_COVERAGE}
{$IFDEF FHIR_COVERAGEELIGIBILITYREQUEST}
    procedure ComposeCoverageEligibilityRequestSupportingInfo(json : TJSONWriter; name : string; elem : TFhirCoverageEligibilityRequestSupportingInfo; noObj : boolean = false);
    procedure ComposeCoverageEligibilityRequestInsurance(json : TJSONWriter; name : string; elem : TFhirCoverageEligibilityRequestInsurance; noObj : boolean = false);
    procedure ComposeCoverageEligibilityRequestItem(json : TJSONWriter; name : string; elem : TFhirCoverageEligibilityRequestItem; noObj : boolean = false);
    procedure ComposeCoverageEligibilityRequestItemDiagnosis(json : TJSONWriter; name : string; elem : TFhirCoverageEligibilityRequestItemDiagnosis; noObj : boolean = false);
    procedure ComposeCoverageEligibilityRequest(json : TJSONWriter; name : string; elem : TFhirCoverageEligibilityRequest; noObj : boolean = false);
{$ENDIF FHIR_COVERAGEELIGIBILITYREQUEST}
{$IFDEF FHIR_COVERAGEELIGIBILITYRESPONSE}
    procedure ComposeCoverageEligibilityResponseInsurance(json : TJSONWriter; name : string; elem : TFhirCoverageEligibilityResponseInsurance; noObj : boolean = false);
    procedure ComposeCoverageEligibilityResponseInsuranceItem(json : TJSONWriter; name : string; elem : TFhirCoverageEligibilityResponseInsuranceItem; noObj : boolean = false);
    procedure ComposeCoverageEligibilityResponseInsuranceItemBenefit(json : TJSONWriter; name : string; elem : TFhirCoverageEligibilityResponseInsuranceItemBenefit; noObj : boolean = false);
    procedure ComposeCoverageEligibilityResponseError(json : TJSONWriter; name : string; elem : TFhirCoverageEligibilityResponseError; noObj : boolean = false);
    procedure ComposeCoverageEligibilityResponse(json : TJSONWriter; name : string; elem : TFhirCoverageEligibilityResponse; noObj : boolean = false);
{$ENDIF FHIR_COVERAGEELIGIBILITYRESPONSE}
{$IFDEF FHIR_DETECTEDISSUE}
    procedure ComposeDetectedIssueEvidence(json : TJSONWriter; name : string; elem : TFhirDetectedIssueEvidence; noObj : boolean = false);
    procedure ComposeDetectedIssueMitigation(json : TJSONWriter; name : string; elem : TFhirDetectedIssueMitigation; noObj : boolean = false);
    procedure ComposeDetectedIssue(json : TJSONWriter; name : string; elem : TFhirDetectedIssue; noObj : boolean = false);
{$ENDIF FHIR_DETECTEDISSUE}
{$IFDEF FHIR_DEVICE}
    procedure ComposeDeviceUdiCarrier(json : TJSONWriter; name : string; elem : TFhirDeviceUdiCarrier; noObj : boolean = false);
    procedure ComposeDeviceDeviceName(json : TJSONWriter; name : string; elem : TFhirDeviceDeviceName; noObj : boolean = false);
    procedure ComposeDeviceSpecialization(json : TJSONWriter; name : string; elem : TFhirDeviceSpecialization; noObj : boolean = false);
    procedure ComposeDeviceVersion(json : TJSONWriter; name : string; elem : TFhirDeviceVersion; noObj : boolean = false);
    procedure ComposeDeviceProperty(json : TJSONWriter; name : string; elem : TFhirDeviceProperty; noObj : boolean = false);
    procedure ComposeDevice(json : TJSONWriter; name : string; elem : TFhirDevice; noObj : boolean = false);
{$ENDIF FHIR_DEVICE}
{$IFDEF FHIR_DEVICEDEFINITION}
    procedure ComposeDeviceDefinitionUdiDeviceIdentifier(json : TJSONWriter; name : string; elem : TFhirDeviceDefinitionUdiDeviceIdentifier; noObj : boolean = false);
    procedure ComposeDeviceDefinitionDeviceName(json : TJSONWriter; name : string; elem : TFhirDeviceDefinitionDeviceName; noObj : boolean = false);
    procedure ComposeDeviceDefinitionSpecialization(json : TJSONWriter; name : string; elem : TFhirDeviceDefinitionSpecialization; noObj : boolean = false);
    procedure ComposeDeviceDefinitionCapability(json : TJSONWriter; name : string; elem : TFhirDeviceDefinitionCapability; noObj : boolean = false);
    procedure ComposeDeviceDefinitionProperty(json : TJSONWriter; name : string; elem : TFhirDeviceDefinitionProperty; noObj : boolean = false);
    procedure ComposeDeviceDefinitionMaterial(json : TJSONWriter; name : string; elem : TFhirDeviceDefinitionMaterial; noObj : boolean = false);
    procedure ComposeDeviceDefinition(json : TJSONWriter; name : string; elem : TFhirDeviceDefinition; noObj : boolean = false);
{$ENDIF FHIR_DEVICEDEFINITION}
{$IFDEF FHIR_DEVICEMETRIC}
    procedure ComposeDeviceMetricCalibration(json : TJSONWriter; name : string; elem : TFhirDeviceMetricCalibration; noObj : boolean = false);
    procedure ComposeDeviceMetric(json : TJSONWriter; name : string; elem : TFhirDeviceMetric; noObj : boolean = false);
{$ENDIF FHIR_DEVICEMETRIC}
{$IFDEF FHIR_DEVICEREQUEST}
    procedure ComposeDeviceRequestParameter(json : TJSONWriter; name : string; elem : TFhirDeviceRequestParameter; noObj : boolean = false);
    procedure ComposeDeviceRequest(json : TJSONWriter; name : string; elem : TFhirDeviceRequest; noObj : boolean = false);
{$ENDIF FHIR_DEVICEREQUEST}
{$IFDEF FHIR_DEVICEUSESTATEMENT}
    procedure ComposeDeviceUseStatement(json : TJSONWriter; name : string; elem : TFhirDeviceUseStatement; noObj : boolean = false);
{$ENDIF FHIR_DEVICEUSESTATEMENT}
{$IFDEF FHIR_DIAGNOSTICREPORT}
    procedure ComposeDiagnosticReportMedia(json : TJSONWriter; name : string; elem : TFhirDiagnosticReportMedia; noObj : boolean = false);
    procedure ComposeDiagnosticReport(json : TJSONWriter; name : string; elem : TFhirDiagnosticReport; noObj : boolean = false);
{$ENDIF FHIR_DIAGNOSTICREPORT}
{$IFDEF FHIR_DOCUMENTMANIFEST}
    procedure ComposeDocumentManifestRelated(json : TJSONWriter; name : string; elem : TFhirDocumentManifestRelated; noObj : boolean = false);
    procedure ComposeDocumentManifest(json : TJSONWriter; name : string; elem : TFhirDocumentManifest; noObj : boolean = false);
{$ENDIF FHIR_DOCUMENTMANIFEST}
{$IFDEF FHIR_DOCUMENTREFERENCE}
    procedure ComposeDocumentReferenceRelatesTo(json : TJSONWriter; name : string; elem : TFhirDocumentReferenceRelatesTo; noObj : boolean = false);
    procedure ComposeDocumentReferenceContent(json : TJSONWriter; name : string; elem : TFhirDocumentReferenceContent; noObj : boolean = false);
    procedure ComposeDocumentReferenceContext(json : TJSONWriter; name : string; elem : TFhirDocumentReferenceContext; noObj : boolean = false);
    procedure ComposeDocumentReference(json : TJSONWriter; name : string; elem : TFhirDocumentReference; noObj : boolean = false);
{$ENDIF FHIR_DOCUMENTREFERENCE}
{$IFDEF FHIR_EFFECTEVIDENCESYNTHESIS}
    procedure ComposeEffectEvidenceSynthesisSampleSize(json : TJSONWriter; name : string; elem : TFhirEffectEvidenceSynthesisSampleSize; noObj : boolean = false);
    procedure ComposeEffectEvidenceSynthesisResultsByExposure(json : TJSONWriter; name : string; elem : TFhirEffectEvidenceSynthesisResultsByExposure; noObj : boolean = false);
    procedure ComposeEffectEvidenceSynthesisEffectEstimate(json : TJSONWriter; name : string; elem : TFhirEffectEvidenceSynthesisEffectEstimate; noObj : boolean = false);
    procedure ComposeEffectEvidenceSynthesisEffectEstimatePrecisionEstimate(json : TJSONWriter; name : string; elem : TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate; noObj : boolean = false);
    procedure ComposeEffectEvidenceSynthesisCertainty(json : TJSONWriter; name : string; elem : TFhirEffectEvidenceSynthesisCertainty; noObj : boolean = false);
    procedure ComposeEffectEvidenceSynthesisCertaintyCertaintySubcomponent(json : TJSONWriter; name : string; elem : TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent; noObj : boolean = false);
    procedure ComposeEffectEvidenceSynthesis(json : TJSONWriter; name : string; elem : TFhirEffectEvidenceSynthesis; noObj : boolean = false);
{$ENDIF FHIR_EFFECTEVIDENCESYNTHESIS}
{$IFDEF FHIR_ENCOUNTER}
    procedure ComposeEncounterStatusHistory(json : TJSONWriter; name : string; elem : TFhirEncounterStatusHistory; noObj : boolean = false);
    procedure ComposeEncounterClassHistory(json : TJSONWriter; name : string; elem : TFhirEncounterClassHistory; noObj : boolean = false);
    procedure ComposeEncounterParticipant(json : TJSONWriter; name : string; elem : TFhirEncounterParticipant; noObj : boolean = false);
    procedure ComposeEncounterDiagnosis(json : TJSONWriter; name : string; elem : TFhirEncounterDiagnosis; noObj : boolean = false);
    procedure ComposeEncounterHospitalization(json : TJSONWriter; name : string; elem : TFhirEncounterHospitalization; noObj : boolean = false);
    procedure ComposeEncounterLocation(json : TJSONWriter; name : string; elem : TFhirEncounterLocation; noObj : boolean = false);
    procedure ComposeEncounter(json : TJSONWriter; name : string; elem : TFhirEncounter; noObj : boolean = false);
{$ENDIF FHIR_ENCOUNTER}
{$IFDEF FHIR_ENDPOINT}
    procedure ComposeEndpoint(json : TJSONWriter; name : string; elem : TFhirEndpoint; noObj : boolean = false);
{$ENDIF FHIR_ENDPOINT}
{$IFDEF FHIR_ENROLLMENTREQUEST}
    procedure ComposeEnrollmentRequest(json : TJSONWriter; name : string; elem : TFhirEnrollmentRequest; noObj : boolean = false);
{$ENDIF FHIR_ENROLLMENTREQUEST}
{$IFDEF FHIR_ENROLLMENTRESPONSE}
    procedure ComposeEnrollmentResponse(json : TJSONWriter; name : string; elem : TFhirEnrollmentResponse; noObj : boolean = false);
{$ENDIF FHIR_ENROLLMENTRESPONSE}
{$IFDEF FHIR_EPISODEOFCARE}
    procedure ComposeEpisodeOfCareStatusHistory(json : TJSONWriter; name : string; elem : TFhirEpisodeOfCareStatusHistory; noObj : boolean = false);
    procedure ComposeEpisodeOfCareDiagnosis(json : TJSONWriter; name : string; elem : TFhirEpisodeOfCareDiagnosis; noObj : boolean = false);
    procedure ComposeEpisodeOfCare(json : TJSONWriter; name : string; elem : TFhirEpisodeOfCare; noObj : boolean = false);
{$ENDIF FHIR_EPISODEOFCARE}
{$IFDEF FHIR_EVENTDEFINITION}
    procedure ComposeEventDefinition(json : TJSONWriter; name : string; elem : TFhirEventDefinition; noObj : boolean = false);
{$ENDIF FHIR_EVENTDEFINITION}
{$IFDEF FHIR_EVIDENCE}
    procedure ComposeEvidence(json : TJSONWriter; name : string; elem : TFhirEvidence; noObj : boolean = false);
{$ENDIF FHIR_EVIDENCE}
{$IFDEF FHIR_EVIDENCEVARIABLE}
    procedure ComposeEvidenceVariableCharacteristic(json : TJSONWriter; name : string; elem : TFhirEvidenceVariableCharacteristic; noObj : boolean = false);
    procedure ComposeEvidenceVariable(json : TJSONWriter; name : string; elem : TFhirEvidenceVariable; noObj : boolean = false);
{$ENDIF FHIR_EVIDENCEVARIABLE}
{$IFDEF FHIR_EXAMPLESCENARIO}
    procedure ComposeExampleScenarioActor(json : TJSONWriter; name : string; elem : TFhirExampleScenarioActor; noObj : boolean = false);
    procedure ComposeExampleScenarioInstance(json : TJSONWriter; name : string; elem : TFhirExampleScenarioInstance; noObj : boolean = false);
    procedure ComposeExampleScenarioInstanceVersion(json : TJSONWriter; name : string; elem : TFhirExampleScenarioInstanceVersion; noObj : boolean = false);
    procedure ComposeExampleScenarioInstanceContainedInstance(json : TJSONWriter; name : string; elem : TFhirExampleScenarioInstanceContainedInstance; noObj : boolean = false);
    procedure ComposeExampleScenarioProcess(json : TJSONWriter; name : string; elem : TFhirExampleScenarioProcess; noObj : boolean = false);
    procedure ComposeExampleScenarioProcessStep(json : TJSONWriter; name : string; elem : TFhirExampleScenarioProcessStep; noObj : boolean = false);
    procedure ComposeExampleScenarioProcessStepOperation(json : TJSONWriter; name : string; elem : TFhirExampleScenarioProcessStepOperation; noObj : boolean = false);
    procedure ComposeExampleScenarioProcessStepAlternative(json : TJSONWriter; name : string; elem : TFhirExampleScenarioProcessStepAlternative; noObj : boolean = false);
    procedure ComposeExampleScenario(json : TJSONWriter; name : string; elem : TFhirExampleScenario; noObj : boolean = false);
{$ENDIF FHIR_EXAMPLESCENARIO}
{$IFDEF FHIR_EXPLANATIONOFBENEFIT}
    procedure ComposeExplanationOfBenefitRelated(json : TJSONWriter; name : string; elem : TFhirExplanationOfBenefitRelated; noObj : boolean = false);
    procedure ComposeExplanationOfBenefitPayee(json : TJSONWriter; name : string; elem : TFhirExplanationOfBenefitPayee; noObj : boolean = false);
    procedure ComposeExplanationOfBenefitCareTeam(json : TJSONWriter; name : string; elem : TFhirExplanationOfBenefitCareTeam; noObj : boolean = false);
    procedure ComposeExplanationOfBenefitSupportingInfo(json : TJSONWriter; name : string; elem : TFhirExplanationOfBenefitSupportingInfo; noObj : boolean = false);
    procedure ComposeExplanationOfBenefitDiagnosis(json : TJSONWriter; name : string; elem : TFhirExplanationOfBenefitDiagnosis; noObj : boolean = false);
    procedure ComposeExplanationOfBenefitProcedure(json : TJSONWriter; name : string; elem : TFhirExplanationOfBenefitProcedure; noObj : boolean = false);
    procedure ComposeExplanationOfBenefitInsurance(json : TJSONWriter; name : string; elem : TFhirExplanationOfBenefitInsurance; noObj : boolean = false);
    procedure ComposeExplanationOfBenefitAccident(json : TJSONWriter; name : string; elem : TFhirExplanationOfBenefitAccident; noObj : boolean = false);
    procedure ComposeExplanationOfBenefitItem(json : TJSONWriter; name : string; elem : TFhirExplanationOfBenefitItem; noObj : boolean = false);
    procedure ComposeExplanationOfBenefitItemAdjudication(json : TJSONWriter; name : string; elem : TFhirExplanationOfBenefitItemAdjudication; noObj : boolean = false);
    procedure ComposeExplanationOfBenefitItemDetail(json : TJSONWriter; name : string; elem : TFhirExplanationOfBenefitItemDetail; noObj : boolean = false);
    procedure ComposeExplanationOfBenefitItemDetailSubDetail(json : TJSONWriter; name : string; elem : TFhirExplanationOfBenefitItemDetailSubDetail; noObj : boolean = false);
    procedure ComposeExplanationOfBenefitAddItem(json : TJSONWriter; name : string; elem : TFhirExplanationOfBenefitAddItem; noObj : boolean = false);
    procedure ComposeExplanationOfBenefitAddItemDetail(json : TJSONWriter; name : string; elem : TFhirExplanationOfBenefitAddItemDetail; noObj : boolean = false);
    procedure ComposeExplanationOfBenefitAddItemDetailSubDetail(json : TJSONWriter; name : string; elem : TFhirExplanationOfBenefitAddItemDetailSubDetail; noObj : boolean = false);
    procedure ComposeExplanationOfBenefitTotal(json : TJSONWriter; name : string; elem : TFhirExplanationOfBenefitTotal; noObj : boolean = false);
    procedure ComposeExplanationOfBenefitPayment(json : TJSONWriter; name : string; elem : TFhirExplanationOfBenefitPayment; noObj : boolean = false);
    procedure ComposeExplanationOfBenefitProcessNote(json : TJSONWriter; name : string; elem : TFhirExplanationOfBenefitProcessNote; noObj : boolean = false);
    procedure ComposeExplanationOfBenefitBenefitBalance(json : TJSONWriter; name : string; elem : TFhirExplanationOfBenefitBenefitBalance; noObj : boolean = false);
    procedure ComposeExplanationOfBenefitBenefitBalanceFinancial(json : TJSONWriter; name : string; elem : TFhirExplanationOfBenefitBenefitBalanceFinancial; noObj : boolean = false);
    procedure ComposeExplanationOfBenefit(json : TJSONWriter; name : string; elem : TFhirExplanationOfBenefit; noObj : boolean = false);
{$ENDIF FHIR_EXPLANATIONOFBENEFIT}
{$IFDEF FHIR_FAMILYMEMBERHISTORY}
    procedure ComposeFamilyMemberHistoryCondition(json : TJSONWriter; name : string; elem : TFhirFamilyMemberHistoryCondition; noObj : boolean = false);
    procedure ComposeFamilyMemberHistory(json : TJSONWriter; name : string; elem : TFhirFamilyMemberHistory; noObj : boolean = false);
{$ENDIF FHIR_FAMILYMEMBERHISTORY}
{$IFDEF FHIR_FLAG}
    procedure ComposeFlag(json : TJSONWriter; name : string; elem : TFhirFlag; noObj : boolean = false);
{$ENDIF FHIR_FLAG}
{$IFDEF FHIR_GOAL}
    procedure ComposeGoalTarget(json : TJSONWriter; name : string; elem : TFhirGoalTarget; noObj : boolean = false);
    procedure ComposeGoal(json : TJSONWriter; name : string; elem : TFhirGoal; noObj : boolean = false);
{$ENDIF FHIR_GOAL}
{$IFDEF FHIR_GRAPHDEFINITION}
    procedure ComposeGraphDefinitionLink(json : TJSONWriter; name : string; elem : TFhirGraphDefinitionLink; noObj : boolean = false);
    procedure ComposeGraphDefinitionLinkTarget(json : TJSONWriter; name : string; elem : TFhirGraphDefinitionLinkTarget; noObj : boolean = false);
    procedure ComposeGraphDefinitionLinkTargetCompartment(json : TJSONWriter; name : string; elem : TFhirGraphDefinitionLinkTargetCompartment; noObj : boolean = false);
    procedure ComposeGraphDefinition(json : TJSONWriter; name : string; elem : TFhirGraphDefinition; noObj : boolean = false);
{$ENDIF FHIR_GRAPHDEFINITION}
{$IFDEF FHIR_GROUP}
    procedure ComposeGroupCharacteristic(json : TJSONWriter; name : string; elem : TFhirGroupCharacteristic; noObj : boolean = false);
    procedure ComposeGroupMember(json : TJSONWriter; name : string; elem : TFhirGroupMember; noObj : boolean = false);
    procedure ComposeGroup(json : TJSONWriter; name : string; elem : TFhirGroup; noObj : boolean = false);
{$ENDIF FHIR_GROUP}
{$IFDEF FHIR_GUIDANCERESPONSE}
    procedure ComposeGuidanceResponse(json : TJSONWriter; name : string; elem : TFhirGuidanceResponse; noObj : boolean = false);
{$ENDIF FHIR_GUIDANCERESPONSE}
{$IFDEF FHIR_HEALTHCARESERVICE}
    procedure ComposeHealthcareServiceEligibility(json : TJSONWriter; name : string; elem : TFhirHealthcareServiceEligibility; noObj : boolean = false);
    procedure ComposeHealthcareServiceAvailableTime(json : TJSONWriter; name : string; elem : TFhirHealthcareServiceAvailableTime; noObj : boolean = false);
    procedure ComposeHealthcareServiceNotAvailable(json : TJSONWriter; name : string; elem : TFhirHealthcareServiceNotAvailable; noObj : boolean = false);
    procedure ComposeHealthcareService(json : TJSONWriter; name : string; elem : TFhirHealthcareService; noObj : boolean = false);
{$ENDIF FHIR_HEALTHCARESERVICE}
{$IFDEF FHIR_IMAGINGSTUDY}
    procedure ComposeImagingStudySeries(json : TJSONWriter; name : string; elem : TFhirImagingStudySeries; noObj : boolean = false);
    procedure ComposeImagingStudySeriesPerformer(json : TJSONWriter; name : string; elem : TFhirImagingStudySeriesPerformer; noObj : boolean = false);
    procedure ComposeImagingStudySeriesInstance(json : TJSONWriter; name : string; elem : TFhirImagingStudySeriesInstance; noObj : boolean = false);
    procedure ComposeImagingStudy(json : TJSONWriter; name : string; elem : TFhirImagingStudy; noObj : boolean = false);
{$ENDIF FHIR_IMAGINGSTUDY}
{$IFDEF FHIR_IMMUNIZATION}
    procedure ComposeImmunizationPerformer(json : TJSONWriter; name : string; elem : TFhirImmunizationPerformer; noObj : boolean = false);
    procedure ComposeImmunizationEducation(json : TJSONWriter; name : string; elem : TFhirImmunizationEducation; noObj : boolean = false);
    procedure ComposeImmunizationReaction(json : TJSONWriter; name : string; elem : TFhirImmunizationReaction; noObj : boolean = false);
    procedure ComposeImmunizationProtocolApplied(json : TJSONWriter; name : string; elem : TFhirImmunizationProtocolApplied; noObj : boolean = false);
    procedure ComposeImmunization(json : TJSONWriter; name : string; elem : TFhirImmunization; noObj : boolean = false);
{$ENDIF FHIR_IMMUNIZATION}
{$IFDEF FHIR_IMMUNIZATIONEVALUATION}
    procedure ComposeImmunizationEvaluation(json : TJSONWriter; name : string; elem : TFhirImmunizationEvaluation; noObj : boolean = false);
{$ENDIF FHIR_IMMUNIZATIONEVALUATION}
{$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
    procedure ComposeImmunizationRecommendationRecommendation(json : TJSONWriter; name : string; elem : TFhirImmunizationRecommendationRecommendation; noObj : boolean = false);
    procedure ComposeImmunizationRecommendationRecommendationDateCriterion(json : TJSONWriter; name : string; elem : TFhirImmunizationRecommendationRecommendationDateCriterion; noObj : boolean = false);
    procedure ComposeImmunizationRecommendation(json : TJSONWriter; name : string; elem : TFhirImmunizationRecommendation; noObj : boolean = false);
{$ENDIF FHIR_IMMUNIZATIONRECOMMENDATION}
{$IFDEF FHIR_IMPLEMENTATIONGUIDE}
    procedure ComposeImplementationGuideDependsOn(json : TJSONWriter; name : string; elem : TFhirImplementationGuideDependsOn; noObj : boolean = false);
    procedure ComposeImplementationGuideGlobal(json : TJSONWriter; name : string; elem : TFhirImplementationGuideGlobal; noObj : boolean = false);
    procedure ComposeImplementationGuideDefinition(json : TJSONWriter; name : string; elem : TFhirImplementationGuideDefinition; noObj : boolean = false);
    procedure ComposeImplementationGuideDefinitionGrouping(json : TJSONWriter; name : string; elem : TFhirImplementationGuideDefinitionGrouping; noObj : boolean = false);
    procedure ComposeImplementationGuideDefinitionResource(json : TJSONWriter; name : string; elem : TFhirImplementationGuideDefinitionResource; noObj : boolean = false);
    procedure ComposeImplementationGuideDefinitionPage(json : TJSONWriter; name : string; elem : TFhirImplementationGuideDefinitionPage; noObj : boolean = false);
    procedure ComposeImplementationGuideDefinitionParameter(json : TJSONWriter; name : string; elem : TFhirImplementationGuideDefinitionParameter; noObj : boolean = false);
    procedure ComposeImplementationGuideDefinitionTemplate(json : TJSONWriter; name : string; elem : TFhirImplementationGuideDefinitionTemplate; noObj : boolean = false);
    procedure ComposeImplementationGuideManifest(json : TJSONWriter; name : string; elem : TFhirImplementationGuideManifest; noObj : boolean = false);
    procedure ComposeImplementationGuideManifestResource(json : TJSONWriter; name : string; elem : TFhirImplementationGuideManifestResource; noObj : boolean = false);
    procedure ComposeImplementationGuideManifestPage(json : TJSONWriter; name : string; elem : TFhirImplementationGuideManifestPage; noObj : boolean = false);
    procedure ComposeImplementationGuide(json : TJSONWriter; name : string; elem : TFhirImplementationGuide; noObj : boolean = false);
{$ENDIF FHIR_IMPLEMENTATIONGUIDE}
{$IFDEF FHIR_INSURANCEPLAN}
    procedure ComposeInsurancePlanContact(json : TJSONWriter; name : string; elem : TFhirInsurancePlanContact; noObj : boolean = false);
    procedure ComposeInsurancePlanCoverage(json : TJSONWriter; name : string; elem : TFhirInsurancePlanCoverage; noObj : boolean = false);
    procedure ComposeInsurancePlanCoverageBenefit(json : TJSONWriter; name : string; elem : TFhirInsurancePlanCoverageBenefit; noObj : boolean = false);
    procedure ComposeInsurancePlanCoverageBenefitLimit(json : TJSONWriter; name : string; elem : TFhirInsurancePlanCoverageBenefitLimit; noObj : boolean = false);
    procedure ComposeInsurancePlanPlan(json : TJSONWriter; name : string; elem : TFhirInsurancePlanPlan; noObj : boolean = false);
    procedure ComposeInsurancePlanPlanGeneralCost(json : TJSONWriter; name : string; elem : TFhirInsurancePlanPlanGeneralCost; noObj : boolean = false);
    procedure ComposeInsurancePlanPlanSpecificCost(json : TJSONWriter; name : string; elem : TFhirInsurancePlanPlanSpecificCost; noObj : boolean = false);
    procedure ComposeInsurancePlanPlanSpecificCostBenefit(json : TJSONWriter; name : string; elem : TFhirInsurancePlanPlanSpecificCostBenefit; noObj : boolean = false);
    procedure ComposeInsurancePlanPlanSpecificCostBenefitCost(json : TJSONWriter; name : string; elem : TFhirInsurancePlanPlanSpecificCostBenefitCost; noObj : boolean = false);
    procedure ComposeInsurancePlan(json : TJSONWriter; name : string; elem : TFhirInsurancePlan; noObj : boolean = false);
{$ENDIF FHIR_INSURANCEPLAN}
{$IFDEF FHIR_INVOICE}
    procedure ComposeInvoiceParticipant(json : TJSONWriter; name : string; elem : TFhirInvoiceParticipant; noObj : boolean = false);
    procedure ComposeInvoiceLineItem(json : TJSONWriter; name : string; elem : TFhirInvoiceLineItem; noObj : boolean = false);
    procedure ComposeInvoiceLineItemPriceComponent(json : TJSONWriter; name : string; elem : TFhirInvoiceLineItemPriceComponent; noObj : boolean = false);
    procedure ComposeInvoice(json : TJSONWriter; name : string; elem : TFhirInvoice; noObj : boolean = false);
{$ENDIF FHIR_INVOICE}
{$IFDEF FHIR_LIBRARY}
    procedure ComposeLibrary(json : TJSONWriter; name : string; elem : TFhirLibrary; noObj : boolean = false);
{$ENDIF FHIR_LIBRARY}
{$IFDEF FHIR_LINKAGE}
    procedure ComposeLinkageItem(json : TJSONWriter; name : string; elem : TFhirLinkageItem; noObj : boolean = false);
    procedure ComposeLinkage(json : TJSONWriter; name : string; elem : TFhirLinkage; noObj : boolean = false);
{$ENDIF FHIR_LINKAGE}
{$IFDEF FHIR_LIST}
    procedure ComposeListEntry(json : TJSONWriter; name : string; elem : TFhirListEntry; noObj : boolean = false);
    procedure ComposeList(json : TJSONWriter; name : string; elem : TFhirList; noObj : boolean = false);
{$ENDIF FHIR_LIST}
{$IFDEF FHIR_LOCATION}
    procedure ComposeLocationPosition(json : TJSONWriter; name : string; elem : TFhirLocationPosition; noObj : boolean = false);
    procedure ComposeLocationHoursOfOperation(json : TJSONWriter; name : string; elem : TFhirLocationHoursOfOperation; noObj : boolean = false);
    procedure ComposeLocation(json : TJSONWriter; name : string; elem : TFhirLocation; noObj : boolean = false);
{$ENDIF FHIR_LOCATION}
{$IFDEF FHIR_MEASURE}
    procedure ComposeMeasureGroup(json : TJSONWriter; name : string; elem : TFhirMeasureGroup; noObj : boolean = false);
    procedure ComposeMeasureGroupPopulation(json : TJSONWriter; name : string; elem : TFhirMeasureGroupPopulation; noObj : boolean = false);
    procedure ComposeMeasureGroupStratifier(json : TJSONWriter; name : string; elem : TFhirMeasureGroupStratifier; noObj : boolean = false);
    procedure ComposeMeasureGroupStratifierComponent(json : TJSONWriter; name : string; elem : TFhirMeasureGroupStratifierComponent; noObj : boolean = false);
    procedure ComposeMeasureSupplementalData(json : TJSONWriter; name : string; elem : TFhirMeasureSupplementalData; noObj : boolean = false);
    procedure ComposeMeasure(json : TJSONWriter; name : string; elem : TFhirMeasure; noObj : boolean = false);
{$ENDIF FHIR_MEASURE}
{$IFDEF FHIR_MEASUREREPORT}
    procedure ComposeMeasureReportGroup(json : TJSONWriter; name : string; elem : TFhirMeasureReportGroup; noObj : boolean = false);
    procedure ComposeMeasureReportGroupPopulation(json : TJSONWriter; name : string; elem : TFhirMeasureReportGroupPopulation; noObj : boolean = false);
    procedure ComposeMeasureReportGroupStratifier(json : TJSONWriter; name : string; elem : TFhirMeasureReportGroupStratifier; noObj : boolean = false);
    procedure ComposeMeasureReportGroupStratifierStratum(json : TJSONWriter; name : string; elem : TFhirMeasureReportGroupStratifierStratum; noObj : boolean = false);
    procedure ComposeMeasureReportGroupStratifierStratumComponent(json : TJSONWriter; name : string; elem : TFhirMeasureReportGroupStratifierStratumComponent; noObj : boolean = false);
    procedure ComposeMeasureReportGroupStratifierStratumPopulation(json : TJSONWriter; name : string; elem : TFhirMeasureReportGroupStratifierStratumPopulation; noObj : boolean = false);
    procedure ComposeMeasureReport(json : TJSONWriter; name : string; elem : TFhirMeasureReport; noObj : boolean = false);
{$ENDIF FHIR_MEASUREREPORT}
{$IFDEF FHIR_MEDIA}
    procedure ComposeMedia(json : TJSONWriter; name : string; elem : TFhirMedia; noObj : boolean = false);
{$ENDIF FHIR_MEDIA}
{$IFDEF FHIR_MEDICATION}
    procedure ComposeMedicationIngredient(json : TJSONWriter; name : string; elem : TFhirMedicationIngredient; noObj : boolean = false);
    procedure ComposeMedicationBatch(json : TJSONWriter; name : string; elem : TFhirMedicationBatch; noObj : boolean = false);
    procedure ComposeMedication(json : TJSONWriter; name : string; elem : TFhirMedication; noObj : boolean = false);
{$ENDIF FHIR_MEDICATION}
{$IFDEF FHIR_MEDICATIONADMINISTRATION}
    procedure ComposeMedicationAdministrationPerformer(json : TJSONWriter; name : string; elem : TFhirMedicationAdministrationPerformer; noObj : boolean = false);
    procedure ComposeMedicationAdministrationDosage(json : TJSONWriter; name : string; elem : TFhirMedicationAdministrationDosage; noObj : boolean = false);
    procedure ComposeMedicationAdministration(json : TJSONWriter; name : string; elem : TFhirMedicationAdministration; noObj : boolean = false);
{$ENDIF FHIR_MEDICATIONADMINISTRATION}
{$IFDEF FHIR_MEDICATIONDISPENSE}
    procedure ComposeMedicationDispensePerformer(json : TJSONWriter; name : string; elem : TFhirMedicationDispensePerformer; noObj : boolean = false);
    procedure ComposeMedicationDispenseSubstitution(json : TJSONWriter; name : string; elem : TFhirMedicationDispenseSubstitution; noObj : boolean = false);
    procedure ComposeMedicationDispense(json : TJSONWriter; name : string; elem : TFhirMedicationDispense; noObj : boolean = false);
{$ENDIF FHIR_MEDICATIONDISPENSE}
{$IFDEF FHIR_MEDICATIONKNOWLEDGE}
    procedure ComposeMedicationKnowledgeRelatedMedicationKnowledge(json : TJSONWriter; name : string; elem : TFhirMedicationKnowledgeRelatedMedicationKnowledge; noObj : boolean = false);
    procedure ComposeMedicationKnowledgeMonograph(json : TJSONWriter; name : string; elem : TFhirMedicationKnowledgeMonograph; noObj : boolean = false);
    procedure ComposeMedicationKnowledgeIngredient(json : TJSONWriter; name : string; elem : TFhirMedicationKnowledgeIngredient; noObj : boolean = false);
    procedure ComposeMedicationKnowledgeCost(json : TJSONWriter; name : string; elem : TFhirMedicationKnowledgeCost; noObj : boolean = false);
    procedure ComposeMedicationKnowledgeMonitoringProgram(json : TJSONWriter; name : string; elem : TFhirMedicationKnowledgeMonitoringProgram; noObj : boolean = false);
    procedure ComposeMedicationKnowledgeAdministrationGuidelines(json : TJSONWriter; name : string; elem : TFhirMedicationKnowledgeAdministrationGuidelines; noObj : boolean = false);
    procedure ComposeMedicationKnowledgeAdministrationGuidelinesDosage(json : TJSONWriter; name : string; elem : TFhirMedicationKnowledgeAdministrationGuidelinesDosage; noObj : boolean = false);
    procedure ComposeMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics(json : TJSONWriter; name : string; elem : TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics; noObj : boolean = false);
    procedure ComposeMedicationKnowledgeMedicineClassification(json : TJSONWriter; name : string; elem : TFhirMedicationKnowledgeMedicineClassification; noObj : boolean = false);
    procedure ComposeMedicationKnowledgePackaging(json : TJSONWriter; name : string; elem : TFhirMedicationKnowledgePackaging; noObj : boolean = false);
    procedure ComposeMedicationKnowledgeDrugCharacteristic(json : TJSONWriter; name : string; elem : TFhirMedicationKnowledgeDrugCharacteristic; noObj : boolean = false);
    procedure ComposeMedicationKnowledgeRegulatory(json : TJSONWriter; name : string; elem : TFhirMedicationKnowledgeRegulatory; noObj : boolean = false);
    procedure ComposeMedicationKnowledgeRegulatorySubstitution(json : TJSONWriter; name : string; elem : TFhirMedicationKnowledgeRegulatorySubstitution; noObj : boolean = false);
    procedure ComposeMedicationKnowledgeRegulatorySchedule(json : TJSONWriter; name : string; elem : TFhirMedicationKnowledgeRegulatorySchedule; noObj : boolean = false);
    procedure ComposeMedicationKnowledgeRegulatoryMaxDispense(json : TJSONWriter; name : string; elem : TFhirMedicationKnowledgeRegulatoryMaxDispense; noObj : boolean = false);
    procedure ComposeMedicationKnowledgeKinetics(json : TJSONWriter; name : string; elem : TFhirMedicationKnowledgeKinetics; noObj : boolean = false);
    procedure ComposeMedicationKnowledge(json : TJSONWriter; name : string; elem : TFhirMedicationKnowledge; noObj : boolean = false);
{$ENDIF FHIR_MEDICATIONKNOWLEDGE}
{$IFDEF FHIR_MEDICATIONREQUEST}
    procedure ComposeMedicationRequestDispenseRequest(json : TJSONWriter; name : string; elem : TFhirMedicationRequestDispenseRequest; noObj : boolean = false);
    procedure ComposeMedicationRequestDispenseRequestInitialFill(json : TJSONWriter; name : string; elem : TFhirMedicationRequestDispenseRequestInitialFill; noObj : boolean = false);
    procedure ComposeMedicationRequestSubstitution(json : TJSONWriter; name : string; elem : TFhirMedicationRequestSubstitution; noObj : boolean = false);
    procedure ComposeMedicationRequest(json : TJSONWriter; name : string; elem : TFhirMedicationRequest; noObj : boolean = false);
{$ENDIF FHIR_MEDICATIONREQUEST}
{$IFDEF FHIR_MEDICATIONSTATEMENT}
    procedure ComposeMedicationStatement(json : TJSONWriter; name : string; elem : TFhirMedicationStatement; noObj : boolean = false);
{$ENDIF FHIR_MEDICATIONSTATEMENT}
{$IFDEF FHIR_MEDICINALPRODUCT}
    procedure ComposeMedicinalProductName(json : TJSONWriter; name : string; elem : TFhirMedicinalProductName; noObj : boolean = false);
    procedure ComposeMedicinalProductNameNamePart(json : TJSONWriter; name : string; elem : TFhirMedicinalProductNameNamePart; noObj : boolean = false);
    procedure ComposeMedicinalProductNameCountryLanguage(json : TJSONWriter; name : string; elem : TFhirMedicinalProductNameCountryLanguage; noObj : boolean = false);
    procedure ComposeMedicinalProductManufacturingBusinessOperation(json : TJSONWriter; name : string; elem : TFhirMedicinalProductManufacturingBusinessOperation; noObj : boolean = false);
    procedure ComposeMedicinalProductSpecialDesignation(json : TJSONWriter; name : string; elem : TFhirMedicinalProductSpecialDesignation; noObj : boolean = false);
    procedure ComposeMedicinalProduct(json : TJSONWriter; name : string; elem : TFhirMedicinalProduct; noObj : boolean = false);
{$ENDIF FHIR_MEDICINALPRODUCT}
{$IFDEF FHIR_MEDICINALPRODUCTAUTHORIZATION}
    procedure ComposeMedicinalProductAuthorizationJurisdictionalAuthorization(json : TJSONWriter; name : string; elem : TFhirMedicinalProductAuthorizationJurisdictionalAuthorization; noObj : boolean = false);
    procedure ComposeMedicinalProductAuthorizationProcedure(json : TJSONWriter; name : string; elem : TFhirMedicinalProductAuthorizationProcedure; noObj : boolean = false);
    procedure ComposeMedicinalProductAuthorization(json : TJSONWriter; name : string; elem : TFhirMedicinalProductAuthorization; noObj : boolean = false);
{$ENDIF FHIR_MEDICINALPRODUCTAUTHORIZATION}
{$IFDEF FHIR_MEDICINALPRODUCTCONTRAINDICATION}
    procedure ComposeMedicinalProductContraindicationOtherTherapy(json : TJSONWriter; name : string; elem : TFhirMedicinalProductContraindicationOtherTherapy; noObj : boolean = false);
    procedure ComposeMedicinalProductContraindication(json : TJSONWriter; name : string; elem : TFhirMedicinalProductContraindication; noObj : boolean = false);
{$ENDIF FHIR_MEDICINALPRODUCTCONTRAINDICATION}
{$IFDEF FHIR_MEDICINALPRODUCTINDICATION}
    procedure ComposeMedicinalProductIndicationOtherTherapy(json : TJSONWriter; name : string; elem : TFhirMedicinalProductIndicationOtherTherapy; noObj : boolean = false);
    procedure ComposeMedicinalProductIndication(json : TJSONWriter; name : string; elem : TFhirMedicinalProductIndication; noObj : boolean = false);
{$ENDIF FHIR_MEDICINALPRODUCTINDICATION}
{$IFDEF FHIR_MEDICINALPRODUCTINGREDIENT}
    procedure ComposeMedicinalProductIngredientSpecifiedSubstance(json : TJSONWriter; name : string; elem : TFhirMedicinalProductIngredientSpecifiedSubstance; noObj : boolean = false);
    procedure ComposeMedicinalProductIngredientSpecifiedSubstanceStrength(json : TJSONWriter; name : string; elem : TFhirMedicinalProductIngredientSpecifiedSubstanceStrength; noObj : boolean = false);
    procedure ComposeMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength(json : TJSONWriter; name : string; elem : TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength; noObj : boolean = false);
    procedure ComposeMedicinalProductIngredientSubstance(json : TJSONWriter; name : string; elem : TFhirMedicinalProductIngredientSubstance; noObj : boolean = false);
    procedure ComposeMedicinalProductIngredient(json : TJSONWriter; name : string; elem : TFhirMedicinalProductIngredient; noObj : boolean = false);
{$ENDIF FHIR_MEDICINALPRODUCTINGREDIENT}
{$IFDEF FHIR_MEDICINALPRODUCTINTERACTION}
    procedure ComposeMedicinalProductInteractionInteractant(json : TJSONWriter; name : string; elem : TFhirMedicinalProductInteractionInteractant; noObj : boolean = false);
    procedure ComposeMedicinalProductInteraction(json : TJSONWriter; name : string; elem : TFhirMedicinalProductInteraction; noObj : boolean = false);
{$ENDIF FHIR_MEDICINALPRODUCTINTERACTION}
{$IFDEF FHIR_MEDICINALPRODUCTMANUFACTURED}
    procedure ComposeMedicinalProductManufactured(json : TJSONWriter; name : string; elem : TFhirMedicinalProductManufactured; noObj : boolean = false);
{$ENDIF FHIR_MEDICINALPRODUCTMANUFACTURED}
{$IFDEF FHIR_MEDICINALPRODUCTPACKAGED}
    procedure ComposeMedicinalProductPackagedBatchIdentifier(json : TJSONWriter; name : string; elem : TFhirMedicinalProductPackagedBatchIdentifier; noObj : boolean = false);
    procedure ComposeMedicinalProductPackagedPackageItem(json : TJSONWriter; name : string; elem : TFhirMedicinalProductPackagedPackageItem; noObj : boolean = false);
    procedure ComposeMedicinalProductPackaged(json : TJSONWriter; name : string; elem : TFhirMedicinalProductPackaged; noObj : boolean = false);
{$ENDIF FHIR_MEDICINALPRODUCTPACKAGED}
{$IFDEF FHIR_MEDICINALPRODUCTPHARMACEUTICAL}
    procedure ComposeMedicinalProductPharmaceuticalCharacteristics(json : TJSONWriter; name : string; elem : TFhirMedicinalProductPharmaceuticalCharacteristics; noObj : boolean = false);
    procedure ComposeMedicinalProductPharmaceuticalRouteOfAdministration(json : TJSONWriter; name : string; elem : TFhirMedicinalProductPharmaceuticalRouteOfAdministration; noObj : boolean = false);
    procedure ComposeMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies(json : TJSONWriter; name : string; elem : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies; noObj : boolean = false);
    procedure ComposeMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod(json : TJSONWriter; name : string; elem : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod; noObj : boolean = false);
    procedure ComposeMedicinalProductPharmaceutical(json : TJSONWriter; name : string; elem : TFhirMedicinalProductPharmaceutical; noObj : boolean = false);
{$ENDIF FHIR_MEDICINALPRODUCTPHARMACEUTICAL}
{$IFDEF FHIR_MEDICINALPRODUCTUNDESIRABLEEFFECT}
    procedure ComposeMedicinalProductUndesirableEffect(json : TJSONWriter; name : string; elem : TFhirMedicinalProductUndesirableEffect; noObj : boolean = false);
{$ENDIF FHIR_MEDICINALPRODUCTUNDESIRABLEEFFECT}
{$IFDEF FHIR_MESSAGEDEFINITION}
    procedure ComposeMessageDefinitionFocus(json : TJSONWriter; name : string; elem : TFhirMessageDefinitionFocus; noObj : boolean = false);
    procedure ComposeMessageDefinitionAllowedResponse(json : TJSONWriter; name : string; elem : TFhirMessageDefinitionAllowedResponse; noObj : boolean = false);
    procedure ComposeMessageDefinition(json : TJSONWriter; name : string; elem : TFhirMessageDefinition; noObj : boolean = false);
{$ENDIF FHIR_MESSAGEDEFINITION}
{$IFDEF FHIR_MESSAGEHEADER}
    procedure ComposeMessageHeaderDestination(json : TJSONWriter; name : string; elem : TFhirMessageHeaderDestination; noObj : boolean = false);
    procedure ComposeMessageHeaderSource(json : TJSONWriter; name : string; elem : TFhirMessageHeaderSource; noObj : boolean = false);
    procedure ComposeMessageHeaderResponse(json : TJSONWriter; name : string; elem : TFhirMessageHeaderResponse; noObj : boolean = false);
    procedure ComposeMessageHeader(json : TJSONWriter; name : string; elem : TFhirMessageHeader; noObj : boolean = false);
{$ENDIF FHIR_MESSAGEHEADER}
{$IFDEF FHIR_MOLECULARSEQUENCE}
    procedure ComposeMolecularSequenceReferenceSeq(json : TJSONWriter; name : string; elem : TFhirMolecularSequenceReferenceSeq; noObj : boolean = false);
    procedure ComposeMolecularSequenceVariant(json : TJSONWriter; name : string; elem : TFhirMolecularSequenceVariant; noObj : boolean = false);
    procedure ComposeMolecularSequenceQuality(json : TJSONWriter; name : string; elem : TFhirMolecularSequenceQuality; noObj : boolean = false);
    procedure ComposeMolecularSequenceQualityRoc(json : TJSONWriter; name : string; elem : TFhirMolecularSequenceQualityRoc; noObj : boolean = false);
    procedure ComposeMolecularSequenceRepository(json : TJSONWriter; name : string; elem : TFhirMolecularSequenceRepository; noObj : boolean = false);
    procedure ComposeMolecularSequenceStructureVariant(json : TJSONWriter; name : string; elem : TFhirMolecularSequenceStructureVariant; noObj : boolean = false);
    procedure ComposeMolecularSequenceStructureVariantOuter(json : TJSONWriter; name : string; elem : TFhirMolecularSequenceStructureVariantOuter; noObj : boolean = false);
    procedure ComposeMolecularSequenceStructureVariantInner(json : TJSONWriter; name : string; elem : TFhirMolecularSequenceStructureVariantInner; noObj : boolean = false);
    procedure ComposeMolecularSequence(json : TJSONWriter; name : string; elem : TFhirMolecularSequence; noObj : boolean = false);
{$ENDIF FHIR_MOLECULARSEQUENCE}
{$IFDEF FHIR_NAMINGSYSTEM}
    procedure ComposeNamingSystemUniqueId(json : TJSONWriter; name : string; elem : TFhirNamingSystemUniqueId; noObj : boolean = false);
    procedure ComposeNamingSystem(json : TJSONWriter; name : string; elem : TFhirNamingSystem; noObj : boolean = false);
{$ENDIF FHIR_NAMINGSYSTEM}
{$IFDEF FHIR_NUTRITIONORDER}
    procedure ComposeNutritionOrderOralDiet(json : TJSONWriter; name : string; elem : TFhirNutritionOrderOralDiet; noObj : boolean = false);
    procedure ComposeNutritionOrderOralDietNutrient(json : TJSONWriter; name : string; elem : TFhirNutritionOrderOralDietNutrient; noObj : boolean = false);
    procedure ComposeNutritionOrderOralDietTexture(json : TJSONWriter; name : string; elem : TFhirNutritionOrderOralDietTexture; noObj : boolean = false);
    procedure ComposeNutritionOrderSupplement(json : TJSONWriter; name : string; elem : TFhirNutritionOrderSupplement; noObj : boolean = false);
    procedure ComposeNutritionOrderEnteralFormula(json : TJSONWriter; name : string; elem : TFhirNutritionOrderEnteralFormula; noObj : boolean = false);
    procedure ComposeNutritionOrderEnteralFormulaAdministration(json : TJSONWriter; name : string; elem : TFhirNutritionOrderEnteralFormulaAdministration; noObj : boolean = false);
    procedure ComposeNutritionOrder(json : TJSONWriter; name : string; elem : TFhirNutritionOrder; noObj : boolean = false);
{$ENDIF FHIR_NUTRITIONORDER}
{$IFDEF FHIR_OBSERVATION}
    procedure ComposeObservationReferenceRange(json : TJSONWriter; name : string; elem : TFhirObservationReferenceRange; noObj : boolean = false);
    procedure ComposeObservationComponent(json : TJSONWriter; name : string; elem : TFhirObservationComponent; noObj : boolean = false);
    procedure ComposeObservation(json : TJSONWriter; name : string; elem : TFhirObservation; noObj : boolean = false);
{$ENDIF FHIR_OBSERVATION}
{$IFDEF FHIR_OBSERVATIONDEFINITION}
    procedure ComposeObservationDefinitionQuantitativeDetails(json : TJSONWriter; name : string; elem : TFhirObservationDefinitionQuantitativeDetails; noObj : boolean = false);
    procedure ComposeObservationDefinitionQualifiedInterval(json : TJSONWriter; name : string; elem : TFhirObservationDefinitionQualifiedInterval; noObj : boolean = false);
    procedure ComposeObservationDefinition(json : TJSONWriter; name : string; elem : TFhirObservationDefinition; noObj : boolean = false);
{$ENDIF FHIR_OBSERVATIONDEFINITION}
{$IFDEF FHIR_OPERATIONDEFINITION}
    procedure ComposeOperationDefinitionParameter(json : TJSONWriter; name : string; elem : TFhirOperationDefinitionParameter; noObj : boolean = false);
    procedure ComposeOperationDefinitionParameterBinding(json : TJSONWriter; name : string; elem : TFhirOperationDefinitionParameterBinding; noObj : boolean = false);
    procedure ComposeOperationDefinitionParameterReferencedFrom(json : TJSONWriter; name : string; elem : TFhirOperationDefinitionParameterReferencedFrom; noObj : boolean = false);
    procedure ComposeOperationDefinitionOverload(json : TJSONWriter; name : string; elem : TFhirOperationDefinitionOverload; noObj : boolean = false);
    procedure ComposeOperationDefinition(json : TJSONWriter; name : string; elem : TFhirOperationDefinition; noObj : boolean = false);
{$ENDIF FHIR_OPERATIONDEFINITION}
{$IFDEF FHIR_OPERATIONOUTCOME}
    procedure ComposeOperationOutcomeIssue(json : TJSONWriter; name : string; elem : TFhirOperationOutcomeIssue; noObj : boolean = false);
    procedure ComposeOperationOutcome(json : TJSONWriter; name : string; elem : TFhirOperationOutcome; noObj : boolean = false);
{$ENDIF FHIR_OPERATIONOUTCOME}
{$IFDEF FHIR_ORGANIZATION}
    procedure ComposeOrganizationContact(json : TJSONWriter; name : string; elem : TFhirOrganizationContact; noObj : boolean = false);
    procedure ComposeOrganization(json : TJSONWriter; name : string; elem : TFhirOrganization; noObj : boolean = false);
{$ENDIF FHIR_ORGANIZATION}
{$IFDEF FHIR_ORGANIZATIONAFFILIATION}
    procedure ComposeOrganizationAffiliation(json : TJSONWriter; name : string; elem : TFhirOrganizationAffiliation; noObj : boolean = false);
{$ENDIF FHIR_ORGANIZATIONAFFILIATION}
{$IFDEF FHIR_PATIENT}
    procedure ComposePatientContact(json : TJSONWriter; name : string; elem : TFhirPatientContact; noObj : boolean = false);
    procedure ComposePatientCommunication(json : TJSONWriter; name : string; elem : TFhirPatientCommunication; noObj : boolean = false);
    procedure ComposePatientLink(json : TJSONWriter; name : string; elem : TFhirPatientLink; noObj : boolean = false);
    procedure ComposePatient(json : TJSONWriter; name : string; elem : TFhirPatient; noObj : boolean = false);
{$ENDIF FHIR_PATIENT}
{$IFDEF FHIR_PAYMENTNOTICE}
    procedure ComposePaymentNotice(json : TJSONWriter; name : string; elem : TFhirPaymentNotice; noObj : boolean = false);
{$ENDIF FHIR_PAYMENTNOTICE}
{$IFDEF FHIR_PAYMENTRECONCILIATION}
    procedure ComposePaymentReconciliationDetail(json : TJSONWriter; name : string; elem : TFhirPaymentReconciliationDetail; noObj : boolean = false);
    procedure ComposePaymentReconciliationProcessNote(json : TJSONWriter; name : string; elem : TFhirPaymentReconciliationProcessNote; noObj : boolean = false);
    procedure ComposePaymentReconciliation(json : TJSONWriter; name : string; elem : TFhirPaymentReconciliation; noObj : boolean = false);
{$ENDIF FHIR_PAYMENTRECONCILIATION}
{$IFDEF FHIR_PERSON}
    procedure ComposePersonLink(json : TJSONWriter; name : string; elem : TFhirPersonLink; noObj : boolean = false);
    procedure ComposePerson(json : TJSONWriter; name : string; elem : TFhirPerson; noObj : boolean = false);
{$ENDIF FHIR_PERSON}
{$IFDEF FHIR_PLANDEFINITION}
    procedure ComposePlanDefinitionGoal(json : TJSONWriter; name : string; elem : TFhirPlanDefinitionGoal; noObj : boolean = false);
    procedure ComposePlanDefinitionGoalTarget(json : TJSONWriter; name : string; elem : TFhirPlanDefinitionGoalTarget; noObj : boolean = false);
    procedure ComposePlanDefinitionAction(json : TJSONWriter; name : string; elem : TFhirPlanDefinitionAction; noObj : boolean = false);
    procedure ComposePlanDefinitionActionCondition(json : TJSONWriter; name : string; elem : TFhirPlanDefinitionActionCondition; noObj : boolean = false);
    procedure ComposePlanDefinitionActionRelatedAction(json : TJSONWriter; name : string; elem : TFhirPlanDefinitionActionRelatedAction; noObj : boolean = false);
    procedure ComposePlanDefinitionActionParticipant(json : TJSONWriter; name : string; elem : TFhirPlanDefinitionActionParticipant; noObj : boolean = false);
    procedure ComposePlanDefinitionActionDynamicValue(json : TJSONWriter; name : string; elem : TFhirPlanDefinitionActionDynamicValue; noObj : boolean = false);
    procedure ComposePlanDefinition(json : TJSONWriter; name : string; elem : TFhirPlanDefinition; noObj : boolean = false);
{$ENDIF FHIR_PLANDEFINITION}
{$IFDEF FHIR_PRACTITIONER}
    procedure ComposePractitionerQualification(json : TJSONWriter; name : string; elem : TFhirPractitionerQualification; noObj : boolean = false);
    procedure ComposePractitioner(json : TJSONWriter; name : string; elem : TFhirPractitioner; noObj : boolean = false);
{$ENDIF FHIR_PRACTITIONER}
{$IFDEF FHIR_PRACTITIONERROLE}
    procedure ComposePractitionerRoleAvailableTime(json : TJSONWriter; name : string; elem : TFhirPractitionerRoleAvailableTime; noObj : boolean = false);
    procedure ComposePractitionerRoleNotAvailable(json : TJSONWriter; name : string; elem : TFhirPractitionerRoleNotAvailable; noObj : boolean = false);
    procedure ComposePractitionerRole(json : TJSONWriter; name : string; elem : TFhirPractitionerRole; noObj : boolean = false);
{$ENDIF FHIR_PRACTITIONERROLE}
{$IFDEF FHIR_PROCEDURE}
    procedure ComposeProcedurePerformer(json : TJSONWriter; name : string; elem : TFhirProcedurePerformer; noObj : boolean = false);
    procedure ComposeProcedureFocalDevice(json : TJSONWriter; name : string; elem : TFhirProcedureFocalDevice; noObj : boolean = false);
    procedure ComposeProcedure(json : TJSONWriter; name : string; elem : TFhirProcedure; noObj : boolean = false);
{$ENDIF FHIR_PROCEDURE}
{$IFDEF FHIR_PROVENANCE}
    procedure ComposeProvenanceAgent(json : TJSONWriter; name : string; elem : TFhirProvenanceAgent; noObj : boolean = false);
    procedure ComposeProvenanceEntity(json : TJSONWriter; name : string; elem : TFhirProvenanceEntity; noObj : boolean = false);
    procedure ComposeProvenance(json : TJSONWriter; name : string; elem : TFhirProvenance; noObj : boolean = false);
{$ENDIF FHIR_PROVENANCE}
{$IFDEF FHIR_QUESTIONNAIRE}
    procedure ComposeQuestionnaireItem(json : TJSONWriter; name : string; elem : TFhirQuestionnaireItem; noObj : boolean = false);
    procedure ComposeQuestionnaireItemEnableWhen(json : TJSONWriter; name : string; elem : TFhirQuestionnaireItemEnableWhen; noObj : boolean = false);
    procedure ComposeQuestionnaireItemAnswerOption(json : TJSONWriter; name : string; elem : TFhirQuestionnaireItemAnswerOption; noObj : boolean = false);
    procedure ComposeQuestionnaireItemInitial(json : TJSONWriter; name : string; elem : TFhirQuestionnaireItemInitial; noObj : boolean = false);
    procedure ComposeQuestionnaire(json : TJSONWriter; name : string; elem : TFhirQuestionnaire; noObj : boolean = false);
{$ENDIF FHIR_QUESTIONNAIRE}
{$IFDEF FHIR_QUESTIONNAIRERESPONSE}
    procedure ComposeQuestionnaireResponseItem(json : TJSONWriter; name : string; elem : TFhirQuestionnaireResponseItem; noObj : boolean = false);
    procedure ComposeQuestionnaireResponseItemAnswer(json : TJSONWriter; name : string; elem : TFhirQuestionnaireResponseItemAnswer; noObj : boolean = false);
    procedure ComposeQuestionnaireResponse(json : TJSONWriter; name : string; elem : TFhirQuestionnaireResponse; noObj : boolean = false);
{$ENDIF FHIR_QUESTIONNAIRERESPONSE}
{$IFDEF FHIR_RELATEDPERSON}
    procedure ComposeRelatedPersonCommunication(json : TJSONWriter; name : string; elem : TFhirRelatedPersonCommunication; noObj : boolean = false);
    procedure ComposeRelatedPerson(json : TJSONWriter; name : string; elem : TFhirRelatedPerson; noObj : boolean = false);
{$ENDIF FHIR_RELATEDPERSON}
{$IFDEF FHIR_REQUESTGROUP}
    procedure ComposeRequestGroupAction(json : TJSONWriter; name : string; elem : TFhirRequestGroupAction; noObj : boolean = false);
    procedure ComposeRequestGroupActionCondition(json : TJSONWriter; name : string; elem : TFhirRequestGroupActionCondition; noObj : boolean = false);
    procedure ComposeRequestGroupActionRelatedAction(json : TJSONWriter; name : string; elem : TFhirRequestGroupActionRelatedAction; noObj : boolean = false);
    procedure ComposeRequestGroup(json : TJSONWriter; name : string; elem : TFhirRequestGroup; noObj : boolean = false);
{$ENDIF FHIR_REQUESTGROUP}
{$IFDEF FHIR_RESEARCHDEFINITION}
    procedure ComposeResearchDefinition(json : TJSONWriter; name : string; elem : TFhirResearchDefinition; noObj : boolean = false);
{$ENDIF FHIR_RESEARCHDEFINITION}
{$IFDEF FHIR_RESEARCHELEMENTDEFINITION}
    procedure ComposeResearchElementDefinitionCharacteristic(json : TJSONWriter; name : string; elem : TFhirResearchElementDefinitionCharacteristic; noObj : boolean = false);
    procedure ComposeResearchElementDefinition(json : TJSONWriter; name : string; elem : TFhirResearchElementDefinition; noObj : boolean = false);
{$ENDIF FHIR_RESEARCHELEMENTDEFINITION}
{$IFDEF FHIR_RESEARCHSTUDY}
    procedure ComposeResearchStudyArm(json : TJSONWriter; name : string; elem : TFhirResearchStudyArm; noObj : boolean = false);
    procedure ComposeResearchStudyObjective(json : TJSONWriter; name : string; elem : TFhirResearchStudyObjective; noObj : boolean = false);
    procedure ComposeResearchStudy(json : TJSONWriter; name : string; elem : TFhirResearchStudy; noObj : boolean = false);
{$ENDIF FHIR_RESEARCHSTUDY}
{$IFDEF FHIR_RESEARCHSUBJECT}
    procedure ComposeResearchSubject(json : TJSONWriter; name : string; elem : TFhirResearchSubject; noObj : boolean = false);
{$ENDIF FHIR_RESEARCHSUBJECT}
{$IFDEF FHIR_RISKASSESSMENT}
    procedure ComposeRiskAssessmentPrediction(json : TJSONWriter; name : string; elem : TFhirRiskAssessmentPrediction; noObj : boolean = false);
    procedure ComposeRiskAssessment(json : TJSONWriter; name : string; elem : TFhirRiskAssessment; noObj : boolean = false);
{$ENDIF FHIR_RISKASSESSMENT}
{$IFDEF FHIR_RISKEVIDENCESYNTHESIS}
    procedure ComposeRiskEvidenceSynthesisSampleSize(json : TJSONWriter; name : string; elem : TFhirRiskEvidenceSynthesisSampleSize; noObj : boolean = false);
    procedure ComposeRiskEvidenceSynthesisRiskEstimate(json : TJSONWriter; name : string; elem : TFhirRiskEvidenceSynthesisRiskEstimate; noObj : boolean = false);
    procedure ComposeRiskEvidenceSynthesisRiskEstimatePrecisionEstimate(json : TJSONWriter; name : string; elem : TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate; noObj : boolean = false);
    procedure ComposeRiskEvidenceSynthesisCertainty(json : TJSONWriter; name : string; elem : TFhirRiskEvidenceSynthesisCertainty; noObj : boolean = false);
    procedure ComposeRiskEvidenceSynthesisCertaintyCertaintySubcomponent(json : TJSONWriter; name : string; elem : TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent; noObj : boolean = false);
    procedure ComposeRiskEvidenceSynthesis(json : TJSONWriter; name : string; elem : TFhirRiskEvidenceSynthesis; noObj : boolean = false);
{$ENDIF FHIR_RISKEVIDENCESYNTHESIS}
{$IFDEF FHIR_SCHEDULE}
    procedure ComposeSchedule(json : TJSONWriter; name : string; elem : TFhirSchedule; noObj : boolean = false);
{$ENDIF FHIR_SCHEDULE}
{$IFDEF FHIR_SEARCHPARAMETER}
    procedure ComposeSearchParameterComponent(json : TJSONWriter; name : string; elem : TFhirSearchParameterComponent; noObj : boolean = false);
    procedure ComposeSearchParameter(json : TJSONWriter; name : string; elem : TFhirSearchParameter; noObj : boolean = false);
{$ENDIF FHIR_SEARCHPARAMETER}
{$IFDEF FHIR_SERVICEREQUEST}
    procedure ComposeServiceRequest(json : TJSONWriter; name : string; elem : TFhirServiceRequest; noObj : boolean = false);
{$ENDIF FHIR_SERVICEREQUEST}
{$IFDEF FHIR_SLOT}
    procedure ComposeSlot(json : TJSONWriter; name : string; elem : TFhirSlot; noObj : boolean = false);
{$ENDIF FHIR_SLOT}
{$IFDEF FHIR_SPECIMEN}
    procedure ComposeSpecimenCollection(json : TJSONWriter; name : string; elem : TFhirSpecimenCollection; noObj : boolean = false);
    procedure ComposeSpecimenProcessing(json : TJSONWriter; name : string; elem : TFhirSpecimenProcessing; noObj : boolean = false);
    procedure ComposeSpecimenContainer(json : TJSONWriter; name : string; elem : TFhirSpecimenContainer; noObj : boolean = false);
    procedure ComposeSpecimen(json : TJSONWriter; name : string; elem : TFhirSpecimen; noObj : boolean = false);
{$ENDIF FHIR_SPECIMEN}
{$IFDEF FHIR_SPECIMENDEFINITION}
    procedure ComposeSpecimenDefinitionTypeTested(json : TJSONWriter; name : string; elem : TFhirSpecimenDefinitionTypeTested; noObj : boolean = false);
    procedure ComposeSpecimenDefinitionTypeTestedContainer(json : TJSONWriter; name : string; elem : TFhirSpecimenDefinitionTypeTestedContainer; noObj : boolean = false);
    procedure ComposeSpecimenDefinitionTypeTestedContainerAdditive(json : TJSONWriter; name : string; elem : TFhirSpecimenDefinitionTypeTestedContainerAdditive; noObj : boolean = false);
    procedure ComposeSpecimenDefinitionTypeTestedHandling(json : TJSONWriter; name : string; elem : TFhirSpecimenDefinitionTypeTestedHandling; noObj : boolean = false);
    procedure ComposeSpecimenDefinition(json : TJSONWriter; name : string; elem : TFhirSpecimenDefinition; noObj : boolean = false);
{$ENDIF FHIR_SPECIMENDEFINITION}
{$IFDEF FHIR_STRUCTUREDEFINITION}
    procedure ComposeStructureDefinitionMapping(json : TJSONWriter; name : string; elem : TFhirStructureDefinitionMapping; noObj : boolean = false);
    procedure ComposeStructureDefinitionContext(json : TJSONWriter; name : string; elem : TFhirStructureDefinitionContext; noObj : boolean = false);
    procedure ComposeStructureDefinitionSnapshot(json : TJSONWriter; name : string; elem : TFhirStructureDefinitionSnapshot; noObj : boolean = false);
    procedure ComposeStructureDefinitionDifferential(json : TJSONWriter; name : string; elem : TFhirStructureDefinitionDifferential; noObj : boolean = false);
    procedure ComposeStructureDefinition(json : TJSONWriter; name : string; elem : TFhirStructureDefinition; noObj : boolean = false);
{$ENDIF FHIR_STRUCTUREDEFINITION}
{$IFDEF FHIR_STRUCTUREMAP}
    procedure ComposeStructureMapStructure(json : TJSONWriter; name : string; elem : TFhirStructureMapStructure; noObj : boolean = false);
    procedure ComposeStructureMapGroup(json : TJSONWriter; name : string; elem : TFhirStructureMapGroup; noObj : boolean = false);
    procedure ComposeStructureMapGroupInput(json : TJSONWriter; name : string; elem : TFhirStructureMapGroupInput; noObj : boolean = false);
    procedure ComposeStructureMapGroupRule(json : TJSONWriter; name : string; elem : TFhirStructureMapGroupRule; noObj : boolean = false);
    procedure ComposeStructureMapGroupRuleSource(json : TJSONWriter; name : string; elem : TFhirStructureMapGroupRuleSource; noObj : boolean = false);
    procedure ComposeStructureMapGroupRuleTarget(json : TJSONWriter; name : string; elem : TFhirStructureMapGroupRuleTarget; noObj : boolean = false);
    procedure ComposeStructureMapGroupRuleTargetParameter(json : TJSONWriter; name : string; elem : TFhirStructureMapGroupRuleTargetParameter; noObj : boolean = false);
    procedure ComposeStructureMapGroupRuleDependent(json : TJSONWriter; name : string; elem : TFhirStructureMapGroupRuleDependent; noObj : boolean = false);
    procedure ComposeStructureMap(json : TJSONWriter; name : string; elem : TFhirStructureMap; noObj : boolean = false);
{$ENDIF FHIR_STRUCTUREMAP}
{$IFDEF FHIR_SUBSCRIPTION}
    procedure ComposeSubscriptionChannel(json : TJSONWriter; name : string; elem : TFhirSubscriptionChannel; noObj : boolean = false);
    procedure ComposeSubscription(json : TJSONWriter; name : string; elem : TFhirSubscription; noObj : boolean = false);
{$ENDIF FHIR_SUBSCRIPTION}
{$IFDEF FHIR_SUBSTANCE}
    procedure ComposeSubstanceInstance(json : TJSONWriter; name : string; elem : TFhirSubstanceInstance; noObj : boolean = false);
    procedure ComposeSubstanceIngredient(json : TJSONWriter; name : string; elem : TFhirSubstanceIngredient; noObj : boolean = false);
    procedure ComposeSubstance(json : TJSONWriter; name : string; elem : TFhirSubstance; noObj : boolean = false);
{$ENDIF FHIR_SUBSTANCE}
{$IFDEF FHIR_SUBSTANCENUCLEICACID}
    procedure ComposeSubstanceNucleicAcidSubunit(json : TJSONWriter; name : string; elem : TFhirSubstanceNucleicAcidSubunit; noObj : boolean = false);
    procedure ComposeSubstanceNucleicAcidSubunitLinkage(json : TJSONWriter; name : string; elem : TFhirSubstanceNucleicAcidSubunitLinkage; noObj : boolean = false);
    procedure ComposeSubstanceNucleicAcidSubunitSugar(json : TJSONWriter; name : string; elem : TFhirSubstanceNucleicAcidSubunitSugar; noObj : boolean = false);
    procedure ComposeSubstanceNucleicAcid(json : TJSONWriter; name : string; elem : TFhirSubstanceNucleicAcid; noObj : boolean = false);
{$ENDIF FHIR_SUBSTANCENUCLEICACID}
{$IFDEF FHIR_SUBSTANCEPOLYMER}
    procedure ComposeSubstancePolymerMonomerSet(json : TJSONWriter; name : string; elem : TFhirSubstancePolymerMonomerSet; noObj : boolean = false);
    procedure ComposeSubstancePolymerMonomerSetStartingMaterial(json : TJSONWriter; name : string; elem : TFhirSubstancePolymerMonomerSetStartingMaterial; noObj : boolean = false);
    procedure ComposeSubstancePolymerRepeat(json : TJSONWriter; name : string; elem : TFhirSubstancePolymerRepeat; noObj : boolean = false);
    procedure ComposeSubstancePolymerRepeatRepeatUnit(json : TJSONWriter; name : string; elem : TFhirSubstancePolymerRepeatRepeatUnit; noObj : boolean = false);
    procedure ComposeSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation(json : TJSONWriter; name : string; elem : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation; noObj : boolean = false);
    procedure ComposeSubstancePolymerRepeatRepeatUnitStructuralRepresentation(json : TJSONWriter; name : string; elem : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation; noObj : boolean = false);
    procedure ComposeSubstancePolymer(json : TJSONWriter; name : string; elem : TFhirSubstancePolymer; noObj : boolean = false);
{$ENDIF FHIR_SUBSTANCEPOLYMER}
{$IFDEF FHIR_SUBSTANCEPROTEIN}
    procedure ComposeSubstanceProteinSubunit(json : TJSONWriter; name : string; elem : TFhirSubstanceProteinSubunit; noObj : boolean = false);
    procedure ComposeSubstanceProtein(json : TJSONWriter; name : string; elem : TFhirSubstanceProtein; noObj : boolean = false);
{$ENDIF FHIR_SUBSTANCEPROTEIN}
{$IFDEF FHIR_SUBSTANCEREFERENCEINFORMATION}
    procedure ComposeSubstanceReferenceInformationGene(json : TJSONWriter; name : string; elem : TFhirSubstanceReferenceInformationGene; noObj : boolean = false);
    procedure ComposeSubstanceReferenceInformationGeneElement(json : TJSONWriter; name : string; elem : TFhirSubstanceReferenceInformationGeneElement; noObj : boolean = false);
    procedure ComposeSubstanceReferenceInformationClassification(json : TJSONWriter; name : string; elem : TFhirSubstanceReferenceInformationClassification; noObj : boolean = false);
    procedure ComposeSubstanceReferenceInformationTarget(json : TJSONWriter; name : string; elem : TFhirSubstanceReferenceInformationTarget; noObj : boolean = false);
    procedure ComposeSubstanceReferenceInformation(json : TJSONWriter; name : string; elem : TFhirSubstanceReferenceInformation; noObj : boolean = false);
{$ENDIF FHIR_SUBSTANCEREFERENCEINFORMATION}
{$IFDEF FHIR_SUBSTANCESOURCEMATERIAL}
    procedure ComposeSubstanceSourceMaterialFractionDescription(json : TJSONWriter; name : string; elem : TFhirSubstanceSourceMaterialFractionDescription; noObj : boolean = false);
    procedure ComposeSubstanceSourceMaterialOrganism(json : TJSONWriter; name : string; elem : TFhirSubstanceSourceMaterialOrganism; noObj : boolean = false);
    procedure ComposeSubstanceSourceMaterialOrganismAuthor(json : TJSONWriter; name : string; elem : TFhirSubstanceSourceMaterialOrganismAuthor; noObj : boolean = false);
    procedure ComposeSubstanceSourceMaterialOrganismHybrid(json : TJSONWriter; name : string; elem : TFhirSubstanceSourceMaterialOrganismHybrid; noObj : boolean = false);
    procedure ComposeSubstanceSourceMaterialOrganismOrganismGeneral(json : TJSONWriter; name : string; elem : TFhirSubstanceSourceMaterialOrganismOrganismGeneral; noObj : boolean = false);
    procedure ComposeSubstanceSourceMaterialPartDescription(json : TJSONWriter; name : string; elem : TFhirSubstanceSourceMaterialPartDescription; noObj : boolean = false);
    procedure ComposeSubstanceSourceMaterial(json : TJSONWriter; name : string; elem : TFhirSubstanceSourceMaterial; noObj : boolean = false);
{$ENDIF FHIR_SUBSTANCESOURCEMATERIAL}
{$IFDEF FHIR_SUBSTANCESPECIFICATION}
    procedure ComposeSubstanceSpecificationMoiety(json : TJSONWriter; name : string; elem : TFhirSubstanceSpecificationMoiety; noObj : boolean = false);
    procedure ComposeSubstanceSpecificationProperty(json : TJSONWriter; name : string; elem : TFhirSubstanceSpecificationProperty; noObj : boolean = false);
    procedure ComposeSubstanceSpecificationStructure(json : TJSONWriter; name : string; elem : TFhirSubstanceSpecificationStructure; noObj : boolean = false);
    procedure ComposeSubstanceSpecificationStructureIsotope(json : TJSONWriter; name : string; elem : TFhirSubstanceSpecificationStructureIsotope; noObj : boolean = false);
    procedure ComposeSubstanceSpecificationStructureIsotopeMolecularWeight(json : TJSONWriter; name : string; elem : TFhirSubstanceSpecificationStructureIsotopeMolecularWeight; noObj : boolean = false);
    procedure ComposeSubstanceSpecificationStructureRepresentation(json : TJSONWriter; name : string; elem : TFhirSubstanceSpecificationStructureRepresentation; noObj : boolean = false);
    procedure ComposeSubstanceSpecificationCode(json : TJSONWriter; name : string; elem : TFhirSubstanceSpecificationCode; noObj : boolean = false);
    procedure ComposeSubstanceSpecificationName(json : TJSONWriter; name : string; elem : TFhirSubstanceSpecificationName; noObj : boolean = false);
    procedure ComposeSubstanceSpecificationNameOfficial(json : TJSONWriter; name : string; elem : TFhirSubstanceSpecificationNameOfficial; noObj : boolean = false);
    procedure ComposeSubstanceSpecificationRelationship(json : TJSONWriter; name : string; elem : TFhirSubstanceSpecificationRelationship; noObj : boolean = false);
    procedure ComposeSubstanceSpecification(json : TJSONWriter; name : string; elem : TFhirSubstanceSpecification; noObj : boolean = false);
{$ENDIF FHIR_SUBSTANCESPECIFICATION}
{$IFDEF FHIR_SUPPLYDELIVERY}
    procedure ComposeSupplyDeliverySuppliedItem(json : TJSONWriter; name : string; elem : TFhirSupplyDeliverySuppliedItem; noObj : boolean = false);
    procedure ComposeSupplyDelivery(json : TJSONWriter; name : string; elem : TFhirSupplyDelivery; noObj : boolean = false);
{$ENDIF FHIR_SUPPLYDELIVERY}
{$IFDEF FHIR_SUPPLYREQUEST}
    procedure ComposeSupplyRequestParameter(json : TJSONWriter; name : string; elem : TFhirSupplyRequestParameter; noObj : boolean = false);
    procedure ComposeSupplyRequest(json : TJSONWriter; name : string; elem : TFhirSupplyRequest; noObj : boolean = false);
{$ENDIF FHIR_SUPPLYREQUEST}
{$IFDEF FHIR_TASK}
    procedure ComposeTaskRestriction(json : TJSONWriter; name : string; elem : TFhirTaskRestriction; noObj : boolean = false);
    procedure ComposeTaskInput(json : TJSONWriter; name : string; elem : TFhirTaskInput; noObj : boolean = false);
    procedure ComposeTaskOutput(json : TJSONWriter; name : string; elem : TFhirTaskOutput; noObj : boolean = false);
    procedure ComposeTask(json : TJSONWriter; name : string; elem : TFhirTask; noObj : boolean = false);
{$ENDIF FHIR_TASK}
{$IFDEF FHIR_TERMINOLOGYCAPABILITIES}
    procedure ComposeTerminologyCapabilitiesSoftware(json : TJSONWriter; name : string; elem : TFhirTerminologyCapabilitiesSoftware; noObj : boolean = false);
    procedure ComposeTerminologyCapabilitiesImplementation(json : TJSONWriter; name : string; elem : TFhirTerminologyCapabilitiesImplementation; noObj : boolean = false);
    procedure ComposeTerminologyCapabilitiesCodeSystem(json : TJSONWriter; name : string; elem : TFhirTerminologyCapabilitiesCodeSystem; noObj : boolean = false);
    procedure ComposeTerminologyCapabilitiesCodeSystemVersion(json : TJSONWriter; name : string; elem : TFhirTerminologyCapabilitiesCodeSystemVersion; noObj : boolean = false);
    procedure ComposeTerminologyCapabilitiesCodeSystemVersionFilter(json : TJSONWriter; name : string; elem : TFhirTerminologyCapabilitiesCodeSystemVersionFilter; noObj : boolean = false);
    procedure ComposeTerminologyCapabilitiesExpansion(json : TJSONWriter; name : string; elem : TFhirTerminologyCapabilitiesExpansion; noObj : boolean = false);
    procedure ComposeTerminologyCapabilitiesExpansionParameter(json : TJSONWriter; name : string; elem : TFhirTerminologyCapabilitiesExpansionParameter; noObj : boolean = false);
    procedure ComposeTerminologyCapabilitiesValidateCode(json : TJSONWriter; name : string; elem : TFhirTerminologyCapabilitiesValidateCode; noObj : boolean = false);
    procedure ComposeTerminologyCapabilitiesTranslation(json : TJSONWriter; name : string; elem : TFhirTerminologyCapabilitiesTranslation; noObj : boolean = false);
    procedure ComposeTerminologyCapabilitiesClosure(json : TJSONWriter; name : string; elem : TFhirTerminologyCapabilitiesClosure; noObj : boolean = false);
    procedure ComposeTerminologyCapabilities(json : TJSONWriter; name : string; elem : TFhirTerminologyCapabilities; noObj : boolean = false);
{$ENDIF FHIR_TERMINOLOGYCAPABILITIES}
{$IFDEF FHIR_TESTREPORT}
    procedure ComposeTestReportParticipant(json : TJSONWriter; name : string; elem : TFhirTestReportParticipant; noObj : boolean = false);
    procedure ComposeTestReportSetup(json : TJSONWriter; name : string; elem : TFhirTestReportSetup; noObj : boolean = false);
    procedure ComposeTestReportSetupAction(json : TJSONWriter; name : string; elem : TFhirTestReportSetupAction; noObj : boolean = false);
    procedure ComposeTestReportSetupActionOperation(json : TJSONWriter; name : string; elem : TFhirTestReportSetupActionOperation; noObj : boolean = false);
    procedure ComposeTestReportSetupActionAssert(json : TJSONWriter; name : string; elem : TFhirTestReportSetupActionAssert; noObj : boolean = false);
    procedure ComposeTestReportTest(json : TJSONWriter; name : string; elem : TFhirTestReportTest; noObj : boolean = false);
    procedure ComposeTestReportTestAction(json : TJSONWriter; name : string; elem : TFhirTestReportTestAction; noObj : boolean = false);
    procedure ComposeTestReportTeardown(json : TJSONWriter; name : string; elem : TFhirTestReportTeardown; noObj : boolean = false);
    procedure ComposeTestReportTeardownAction(json : TJSONWriter; name : string; elem : TFhirTestReportTeardownAction; noObj : boolean = false);
    procedure ComposeTestReport(json : TJSONWriter; name : string; elem : TFhirTestReport; noObj : boolean = false);
{$ENDIF FHIR_TESTREPORT}
{$IFDEF FHIR_TESTSCRIPT}
    procedure ComposeTestScriptOrigin(json : TJSONWriter; name : string; elem : TFhirTestScriptOrigin; noObj : boolean = false);
    procedure ComposeTestScriptDestination(json : TJSONWriter; name : string; elem : TFhirTestScriptDestination; noObj : boolean = false);
    procedure ComposeTestScriptMetadata(json : TJSONWriter; name : string; elem : TFhirTestScriptMetadata; noObj : boolean = false);
    procedure ComposeTestScriptMetadataLink(json : TJSONWriter; name : string; elem : TFhirTestScriptMetadataLink; noObj : boolean = false);
    procedure ComposeTestScriptMetadataCapability(json : TJSONWriter; name : string; elem : TFhirTestScriptMetadataCapability; noObj : boolean = false);
    procedure ComposeTestScriptFixture(json : TJSONWriter; name : string; elem : TFhirTestScriptFixture; noObj : boolean = false);
    procedure ComposeTestScriptVariable(json : TJSONWriter; name : string; elem : TFhirTestScriptVariable; noObj : boolean = false);
    procedure ComposeTestScriptSetup(json : TJSONWriter; name : string; elem : TFhirTestScriptSetup; noObj : boolean = false);
    procedure ComposeTestScriptSetupAction(json : TJSONWriter; name : string; elem : TFhirTestScriptSetupAction; noObj : boolean = false);
    procedure ComposeTestScriptSetupActionOperation(json : TJSONWriter; name : string; elem : TFhirTestScriptSetupActionOperation; noObj : boolean = false);
    procedure ComposeTestScriptSetupActionOperationRequestHeader(json : TJSONWriter; name : string; elem : TFhirTestScriptSetupActionOperationRequestHeader; noObj : boolean = false);
    procedure ComposeTestScriptSetupActionAssert(json : TJSONWriter; name : string; elem : TFhirTestScriptSetupActionAssert; noObj : boolean = false);
    procedure ComposeTestScriptTest(json : TJSONWriter; name : string; elem : TFhirTestScriptTest; noObj : boolean = false);
    procedure ComposeTestScriptTestAction(json : TJSONWriter; name : string; elem : TFhirTestScriptTestAction; noObj : boolean = false);
    procedure ComposeTestScriptTeardown(json : TJSONWriter; name : string; elem : TFhirTestScriptTeardown; noObj : boolean = false);
    procedure ComposeTestScriptTeardownAction(json : TJSONWriter; name : string; elem : TFhirTestScriptTeardownAction; noObj : boolean = false);
    procedure ComposeTestScript(json : TJSONWriter; name : string; elem : TFhirTestScript; noObj : boolean = false);
{$ENDIF FHIR_TESTSCRIPT}
{$IFDEF FHIR_VALUESET}
    procedure ComposeValueSetCompose(json : TJSONWriter; name : string; elem : TFhirValueSetCompose; noObj : boolean = false);
    procedure ComposeValueSetComposeInclude(json : TJSONWriter; name : string; elem : TFhirValueSetComposeInclude; noObj : boolean = false);
    procedure ComposeValueSetComposeIncludeConcept(json : TJSONWriter; name : string; elem : TFhirValueSetComposeIncludeConcept; noObj : boolean = false);
    procedure ComposeValueSetComposeIncludeConceptDesignation(json : TJSONWriter; name : string; elem : TFhirValueSetComposeIncludeConceptDesignation; noObj : boolean = false);
    procedure ComposeValueSetComposeIncludeFilter(json : TJSONWriter; name : string; elem : TFhirValueSetComposeIncludeFilter; noObj : boolean = false);
    procedure ComposeValueSetExpansion(json : TJSONWriter; name : string; elem : TFhirValueSetExpansion; noObj : boolean = false);
    procedure ComposeValueSetExpansionParameter(json : TJSONWriter; name : string; elem : TFhirValueSetExpansionParameter; noObj : boolean = false);
    procedure ComposeValueSetExpansionContains(json : TJSONWriter; name : string; elem : TFhirValueSetExpansionContains; noObj : boolean = false);
    procedure ComposeValueSet(json : TJSONWriter; name : string; elem : TFhirValueSet; noObj : boolean = false);
{$ENDIF FHIR_VALUESET}
{$IFDEF FHIR_VERIFICATIONRESULT}
    procedure ComposeVerificationResultPrimarySource(json : TJSONWriter; name : string; elem : TFhirVerificationResultPrimarySource; noObj : boolean = false);
    procedure ComposeVerificationResultAttestation(json : TJSONWriter; name : string; elem : TFhirVerificationResultAttestation; noObj : boolean = false);
    procedure ComposeVerificationResultValidator(json : TJSONWriter; name : string; elem : TFhirVerificationResultValidator; noObj : boolean = false);
    procedure ComposeVerificationResult(json : TJSONWriter; name : string; elem : TFhirVerificationResult; noObj : boolean = false);
{$ENDIF FHIR_VERIFICATIONRESULT}
{$IFDEF FHIR_VISIONPRESCRIPTION}
    procedure ComposeVisionPrescriptionLensSpecification(json : TJSONWriter; name : string; elem : TFhirVisionPrescriptionLensSpecification; noObj : boolean = false);
    procedure ComposeVisionPrescriptionLensSpecificationPrism(json : TJSONWriter; name : string; elem : TFhirVisionPrescriptionLensSpecificationPrism; noObj : boolean = false);
    procedure ComposeVisionPrescription(json : TJSONWriter; name : string; elem : TFhirVisionPrescription; noObj : boolean = false);
{$ENDIF FHIR_VISIONPRESCRIPTION}
    procedure ComposeResource(json : TJSONWriter; resource : TFhirResource); override;
    procedure ComposeBase(json : TJSONWriter; name : String; base : TFHIRObject); override;
  end;


implementation

{ TFHIRJsonParser }

procedure TFHIRJsonParser.ParseElement(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseElement(jsn)); {2}
end;

function TFHIRJsonParser.ParseElement(jsn : TJsonObject) : TFhirElement;
begin
  result := TFhirElement.create;
  try
    ParseElementProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeElement(json : TJSONWriter; name : string; elem : TFhirElement; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeIdValue(json, 'id', elem.idElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeIdProps(json, 'id', elem.idElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.extensionList.Count > 0) then
  begin
    json.valueArray('extension');
    for i := 0 to elem.extensionList.Count - 1 do
      ComposeExtension(json, '', elem.extensionList[i]); {z - Extension}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseElementProperties(jsn : TJsonObject; element : TFhirElement);
begin
  parseComments(element, jsn);

  element.LocationStart := jsn.LocationStart;
  element.LocationEnd := jsn.LocationEnd;
  if jsn.has('id') then
    element.Id := jsn.str['id'];
  if jsn.has('extension') then
    iterateArray(jsn.vArr['extension'], element.extensionList, parseExtension);
end;

procedure TFHIRJsonParser.ParseBackboneElementProperties(jsn : TJsonObject; element : TFhirBackboneElement);
begin
  parseElementProperties(jsn, element);

  if jsn.has('modifierExtension') then
    iterateArray(jsn.vArr['modifierExtension'], element.modifierExtensionList, parseExtension);
end;

procedure TFHIRJsonParser.ParseBackboneElementProperties(jsn : TJsonObject; element : TFhirBackboneType);
begin
  parseElementProperties(jsn, element);

  if jsn.has('modifierExtension') then
    iterateArray(jsn.vArr['modifierExtension'], element.modifierExtensionList, parseExtension);
end;

Procedure TFHIRJsonComposer.ComposeElementProperties(json : TJSONWriter; elem : TFhirElement);
var
  i : integer;
begin
  {no-comments composeComments(json, elem);}
  Prop(json, 'id', elem.Id);
  if elem.hasExtensionList then
  begin
    json.valueArray('extension');
    for i := 0 to elem.extensionList.Count - 1 do
      ComposeExtension(json, '',elem.extensionList[i]);
    json.FinishArray;
  end;
end;

Procedure TFHIRJsonComposer.ComposeBackboneElementProperties(json : TJSONWriter; elem : TFhirBackboneElement);
var
  i : integer;
begin
  ComposeElementProperties(json, elem);
  if elem.hasModifierExtensionList then
  begin
    json.valueArray('modifierExtension');
    for i := 0 to elem.modifierExtensionList.Count - 1 do
      ComposeExtension(json, '', elem.modifierExtensionList[i]);
    json.FinishArray;
  end;
end;

Procedure TFHIRJsonComposer.ComposeBackboneTypeProperties(json : TJSONWriter; elem : TFhirBackboneType);
var
  i : integer;
begin
  ComposeElementProperties(json, elem);
  if elem.hasModifierExtensionList then
  begin
    json.valueArray('modifierExtension');
    for i := 0 to elem.modifierExtensionList.Count - 1 do
      ComposeExtension(json, '', elem.modifierExtensionList[i]);
    json.FinishArray;
  end;
end;

procedure TFHIRJsonParser.ParseBackboneElement(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseBackboneElement(jsn)); {2}
end;

function TFHIRJsonParser.ParseBackboneElement(jsn : TJsonObject) : TFhirBackboneElement;
begin
  result := TFhirBackboneElement.create;
  try
    ParseBackboneElementProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeBackboneElement(json : TJSONWriter; name : string; elem : TFhirBackboneElement; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElement(json, '', elem, true);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.modifierExtensionList.Count > 0) then
  begin
    json.valueArray('modifierExtension');
    for i := 0 to elem.modifierExtensionList.Count - 1 do
      ComposeExtension(json, '', elem.modifierExtensionList[i]); {z - Extension}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseBackboneType(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseBackboneType(jsn)); {2}
end;

function TFHIRJsonParser.ParseBackboneType(jsn : TJsonObject) : TFhirBackboneType;
begin
  result := TFhirBackboneType.create;
  try
    ParseBackboneTypeProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseBackboneTypeProperties(jsn : TJsonObject; result : TFhirBackboneType);
begin
    ParseElementProperties(jsn, result);
    if jsn.has('modifierExtension') then
      iterateArray(jsn.vArr['modifierExtension'], result.modifierExtensionList, parseExtension);
end;

procedure TFHIRJsonComposer.ComposeBackboneType(json : TJSONWriter; name : string; elem : TFhirBackboneType; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElement(json, '', elem, true);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.modifierExtensionList.Count > 0) then
  begin
    json.valueArray('modifierExtension');
    for i := 0 to elem.modifierExtensionList.Count - 1 do
      ComposeExtension(json, '', elem.modifierExtensionList[i]); {z - Extension}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseEnum(path : String; value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList; Const aNames, aSystems : Array Of String);
begin
  ctxt.add(ParseEnum(path, value, jsn, aNames, aSystems));
end;

function TFHIRJsonParser.ParseEnum(path : String; value : TJsonNode; jsn : TJsonObject; Const aNames, aSystems : Array Of String) : TFHIREnum;
var
  i : integer;
begin
  i := StringArrayIndexOfSensitive(aNames, JsonToString(value));
  if (value <> nil) and (i < 0) then
    raise EJsonException.Create('unknown code: '+JsonToString(value)+' from a set of choices of '+StringArrayToCommaString(aNames)+' for "'+path+'"');
  result := TFHIREnum.create;
  try
    if (value <> nil) then
    begin
      result.LocationStart := value.LocationStart;
      result.LocationEnd := value.LocationEnd;
    end;
    result.value := JsonToString(value);
    result.system := aSystems[i];
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

Procedure TFHIRJsonComposer.ComposeEnumValue(json : TJSONWriter; name : String; value : TFhirEnum; Const aNames : Array Of String; inArray : boolean);
begin
  if (value = nil) or (value.Value = '') then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    prop(json, name, value.value);
end;

Procedure TFHIRJsonComposer.ComposeEnumProps(json : TJSONWriter; name : String; value : TFhirEnum; Const aNames : Array Of String; inArray : boolean);
begin
  if (value = nil) or ((value.Id = '') and (not value.hasExtensionList) {no-comments and (not value.hasComments) }) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

procedure TFHIRJsonParser.ParseDate(value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDate(value, jsn)) {1};
end;

function TFHIRJsonParser.ParseDate(value : TJsonNode; jsn : TJsonObject) : TFHIRDate;
begin
  result := TFhirDate.Create;
  try
    if (value <> nil) then
    begin
      result.LocationStart := value.LocationStart;
      result.LocationEnd := value.LocationEnd;
    end;
     result.value := toTDateTimeEx(JsonToString(value));
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRJsonComposer.ComposeDateValue(json : TJSONWriter; name : String; value : TFhirDate; inArray : boolean);
begin
  if (value = nil) or (value.value.null) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    prop(json, name, asString(value.value));
end;

Procedure TFHIRJsonComposer.ComposeDateProps(json : TJSONWriter; name : String; value : TFhirDate; inArray : boolean);
begin
  if (value = nil) or ((value.Id = '') and (not value.hasExtensionList) {no-comments and (not value.hasComments)}) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

procedure TFHIRJsonParser.ParseDateTime(value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDateTime(value, jsn)) {1};
end;

function TFHIRJsonParser.ParseDateTime(value : TJsonNode; jsn : TJsonObject) : TFHIRDateTime;
begin
  result := TFhirDateTime.Create;
  try
    if (value <> nil) then
    begin
      result.LocationStart := value.LocationStart;
      result.LocationEnd := value.LocationEnd;
    end;
     result.value := toTDateTimeEx(JsonToString(value));
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRJsonComposer.ComposeDateTimeValue(json : TJSONWriter; name : String; value : TFhirDateTime; inArray : boolean);
begin
  if (value = nil) or (value.value.null) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    prop(json, name, asString(value.value));
end;

Procedure TFHIRJsonComposer.ComposeDateTimeProps(json : TJSONWriter; name : String; value : TFhirDateTime; inArray : boolean);
begin
  if (value = nil) or ((value.Id = '') and (not value.hasExtensionList) {no-comments and (not value.hasComments)}) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

procedure TFHIRJsonParser.ParseString(value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseString(value, jsn)) {1};
end;

function TFHIRJsonParser.ParseString(value : TJsonNode; jsn : TJsonObject) : TFHIRString;
begin
  result := TFhirString.Create;
  try
    if (value <> nil) then
    begin
      result.LocationStart := value.LocationStart;
      result.LocationEnd := value.LocationEnd;
    end;
    result.value := JsonToString(value);
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRJsonComposer.ComposeStringValue(json : TJSONWriter; name : String; value : TFhirString; inArray : boolean);
begin
  if (value = nil) or (value.value = '') then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    prop(json, name, value.value);
end;

Procedure TFHIRJsonComposer.ComposeStringProps(json : TJSONWriter; name : String; value : TFhirString; inArray : boolean);
begin
  if (value = nil) or ((value.Id = '') and (not value.hasExtensionList) {no-comments and (not value.hasComments)}) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

procedure TFHIRJsonParser.ParseInteger(value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseInteger(value, jsn)) {1};
end;

function TFHIRJsonParser.ParseInteger(value : TJsonNode; jsn : TJsonObject) : TFHIRInteger;
begin
  result := TFhirInteger.Create;
  try
    if (value <> nil) then
    begin
      result.LocationStart := value.LocationStart;
      result.LocationEnd := value.LocationEnd;
    end;
    result.value := JsonToString(value);
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRJsonComposer.ComposeIntegerValue(json : TJSONWriter; name : String; value : TFhirInteger; inArray : boolean);
begin
  if (value = nil) or (value.value = '') then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    propNumber(json, name, value.value);
end;

Procedure TFHIRJsonComposer.ComposeIntegerProps(json : TJSONWriter; name : String; value : TFhirInteger; inArray : boolean);
begin
  if (value = nil) or ((value.Id = '') and (not value.hasExtensionList) {no-comments and (not value.hasComments)}) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

procedure TFHIRJsonParser.ParseUri(value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseUri(value, jsn)) {1};
end;

function TFHIRJsonParser.ParseUri(value : TJsonNode; jsn : TJsonObject) : TFHIRUri;
begin
  result := TFhirUri.Create;
  try
    if (value <> nil) then
    begin
      result.LocationStart := value.LocationStart;
      result.LocationEnd := value.LocationEnd;
    end;
    result.value := JsonToString(value);
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRJsonComposer.ComposeUriValue(json : TJSONWriter; name : String; value : TFhirUri; inArray : boolean);
begin
  if (value = nil) or (value.value = '') then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    prop(json, name, value.value);
end;

Procedure TFHIRJsonComposer.ComposeUriProps(json : TJSONWriter; name : String; value : TFhirUri; inArray : boolean);
begin
  if (value = nil) or ((value.Id = '') and (not value.hasExtensionList) {no-comments and (not value.hasComments)}) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

procedure TFHIRJsonParser.ParseInstant(value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseInstant(value, jsn)) {1};
end;

function TFHIRJsonParser.ParseInstant(value : TJsonNode; jsn : TJsonObject) : TFHIRInstant;
begin
  result := TFhirInstant.Create;
  try
    if (value <> nil) then
    begin
      result.LocationStart := value.LocationStart;
      result.LocationEnd := value.LocationEnd;
    end;
     result.value := toTDateTimeEx(JsonToString(value));
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRJsonComposer.ComposeInstantValue(json : TJSONWriter; name : String; value : TFhirInstant; inArray : boolean);
begin
  if (value = nil) or (value.value.null) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    prop(json, name, asString(value.value));
end;

Procedure TFHIRJsonComposer.ComposeInstantProps(json : TJSONWriter; name : String; value : TFhirInstant; inArray : boolean);
begin
  if (value = nil) or ((value.Id = '') and (not value.hasExtensionList) {no-comments and (not value.hasComments)}) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

procedure TFHIRJsonParser.ParseXhtml(value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseXhtml(value, jsn)) {1};
end;

function TFHIRJsonParser.ParseXhtml(value : TJsonNode; jsn : TJsonObject) : TFHIRXhtml;
begin
  result := TFhirXhtml.Create;
  try
    if (value <> nil) then
    begin
      result.LocationStart := value.LocationStart;
      result.LocationEnd := value.LocationEnd;
    end;
    result.value := JsonToString(value);
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRJsonComposer.ComposeXhtmlValue(json : TJSONWriter; name : String; value : TFhirXhtml; inArray : boolean);
begin
  if (value = nil) or (value.value = '') then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    prop(json, name, value.value);
end;

Procedure TFHIRJsonComposer.ComposeXhtmlProps(json : TJSONWriter; name : String; value : TFhirXhtml; inArray : boolean);
begin
  if (value = nil) or ((value.Id = '') and (not value.hasExtensionList) {no-comments and (not value.hasComments)}) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

procedure TFHIRJsonParser.ParseBoolean(value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseBoolean(value, jsn)) {1};
end;

function TFHIRJsonParser.ParseBoolean(value : TJsonNode; jsn : TJsonObject) : TFHIRBoolean;
begin
  result := TFhirBoolean.Create;
  try
    if (value <> nil) then
    begin
      result.LocationStart := value.LocationStart;
      result.LocationEnd := value.LocationEnd;
    end;
    result.value := StringToBoolean(JsonToString(value));
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRJsonComposer.ComposeBooleanValue(json : TJSONWriter; name : String; value : TFhirBoolean; inArray : boolean);
begin
  if (value = nil) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    prop(json, name, value.value);
end;

Procedure TFHIRJsonComposer.ComposeBooleanProps(json : TJSONWriter; name : String; value : TFhirBoolean; inArray : boolean);
begin
  if (value = nil) or ((value.Id = '') and (not value.hasExtensionList) {no-comments and (not value.hasComments)}) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

procedure TFHIRJsonParser.ParseBase64Binary(value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseBase64Binary(value, jsn)) {1};
end;

function TFHIRJsonParser.ParseBase64Binary(value : TJsonNode; jsn : TJsonObject) : TFHIRBase64Binary;
begin
  result := TFhirBase64Binary.Create;
  try
    if (value <> nil) then
    begin
      result.LocationStart := value.LocationStart;
      result.LocationEnd := value.LocationEnd;
    end;
     result.value := toTBytes(JsonToString(value));
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRJsonComposer.ComposeBase64BinaryValue(json : TJSONWriter; name : String; value : TFhirBase64Binary; inArray : boolean);
begin
  if (value = nil) or (value.value = nil) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    prop(json, name, asString(value.value));
end;

Procedure TFHIRJsonComposer.ComposeBase64BinaryProps(json : TJSONWriter; name : String; value : TFhirBase64Binary; inArray : boolean);
begin
  if (value = nil) or ((value.Id = '') and (not value.hasExtensionList) {no-comments and (not value.hasComments)}) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

procedure TFHIRJsonParser.ParseTime(value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTime(value, jsn)) {1};
end;

function TFHIRJsonParser.ParseTime(value : TJsonNode; jsn : TJsonObject) : TFHIRTime;
begin
  result := TFhirTime.Create;
  try
    if (value <> nil) then
    begin
      result.LocationStart := value.LocationStart;
      result.LocationEnd := value.LocationEnd;
    end;
    result.value := JsonToString(value);
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRJsonComposer.ComposeTimeValue(json : TJSONWriter; name : String; value : TFhirTime; inArray : boolean);
begin
  if (value = nil) or (value.value = '') then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    prop(json, name, value.value);
end;

Procedure TFHIRJsonComposer.ComposeTimeProps(json : TJSONWriter; name : String; value : TFhirTime; inArray : boolean);
begin
  if (value = nil) or ((value.Id = '') and (not value.hasExtensionList) {no-comments and (not value.hasComments)}) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

procedure TFHIRJsonParser.ParseDecimal(value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDecimal(value, jsn)) {1};
end;

function TFHIRJsonParser.ParseDecimal(value : TJsonNode; jsn : TJsonObject) : TFHIRDecimal;
begin
  result := TFhirDecimal.Create;
  try
    if (value <> nil) then
    begin
      result.LocationStart := value.LocationStart;
      result.LocationEnd := value.LocationEnd;
    end;
    result.value := JsonToString(value);
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRJsonComposer.ComposeDecimalValue(json : TJSONWriter; name : String; value : TFhirDecimal; inArray : boolean);
begin
  if (value = nil) or (value.value = '') then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    propNumber(json, name, value.value);
end;

Procedure TFHIRJsonComposer.ComposeDecimalProps(json : TJSONWriter; name : String; value : TFhirDecimal; inArray : boolean);
begin
  if (value = nil) or ((value.Id = '') and (not value.hasExtensionList) {no-comments and (not value.hasComments)}) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

procedure TFHIRJsonParser.ParseCode(value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCode(value, jsn)) {1};
end;

function TFHIRJsonParser.ParseCode(value : TJsonNode; jsn : TJsonObject) : TFHIRCode;
begin
  result := TFhirCode.Create;
  try
    if (value <> nil) then
    begin
      result.LocationStart := value.LocationStart;
      result.LocationEnd := value.LocationEnd;
    end;
    result.value := JsonToString(value);
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRJsonComposer.ComposeCodeValue(json : TJSONWriter; name : String; value : TFhirCode; inArray : boolean);
begin
  if (value = nil) or (value.value = '') then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    prop(json, name, value.value);
end;

Procedure TFHIRJsonComposer.ComposeCodeProps(json : TJSONWriter; name : String; value : TFhirCode; inArray : boolean);
begin
  if (value = nil) or ((value.Id = '') and (not value.hasExtensionList) {no-comments and (not value.hasComments)}) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

procedure TFHIRJsonParser.ParseCanonical(value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCanonical(value, jsn)) {1};
end;

function TFHIRJsonParser.ParseCanonical(value : TJsonNode; jsn : TJsonObject) : TFHIRCanonical;
begin
  result := TFhirCanonical.Create;
  try
    if (value <> nil) then
    begin
      result.LocationStart := value.LocationStart;
      result.LocationEnd := value.LocationEnd;
    end;
    result.value := JsonToString(value);
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRJsonComposer.ComposeCanonicalValue(json : TJSONWriter; name : String; value : TFhirCanonical; inArray : boolean);
begin
  if (value = nil) or (value.value = '') then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    prop(json, name, value.value);
end;

Procedure TFHIRJsonComposer.ComposeCanonicalProps(json : TJSONWriter; name : String; value : TFhirCanonical; inArray : boolean);
begin
  if (value = nil) or ((value.Id = '') and (not value.hasExtensionList) {no-comments and (not value.hasComments)}) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

procedure TFHIRJsonParser.ParseOid(value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseOid(value, jsn)) {1};
end;

function TFHIRJsonParser.ParseOid(value : TJsonNode; jsn : TJsonObject) : TFHIROid;
begin
  result := TFhirOid.Create;
  try
    if (value <> nil) then
    begin
      result.LocationStart := value.LocationStart;
      result.LocationEnd := value.LocationEnd;
    end;
    result.value := JsonToString(value);
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRJsonComposer.ComposeOidValue(json : TJSONWriter; name : String; value : TFhirOid; inArray : boolean);
begin
  if (value = nil) or (value.value = '') then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    prop(json, name, value.value);
end;

Procedure TFHIRJsonComposer.ComposeOidProps(json : TJSONWriter; name : String; value : TFhirOid; inArray : boolean);
begin
  if (value = nil) or ((value.Id = '') and (not value.hasExtensionList) {no-comments and (not value.hasComments)}) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

procedure TFHIRJsonParser.ParseUuid(value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseUuid(value, jsn)) {1};
end;

function TFHIRJsonParser.ParseUuid(value : TJsonNode; jsn : TJsonObject) : TFHIRUuid;
begin
  result := TFhirUuid.Create;
  try
    if (value <> nil) then
    begin
      result.LocationStart := value.LocationStart;
      result.LocationEnd := value.LocationEnd;
    end;
    result.value := JsonToString(value);
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRJsonComposer.ComposeUuidValue(json : TJSONWriter; name : String; value : TFhirUuid; inArray : boolean);
begin
  if (value = nil) or (value.value = '') then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    prop(json, name, value.value);
end;

Procedure TFHIRJsonComposer.ComposeUuidProps(json : TJSONWriter; name : String; value : TFhirUuid; inArray : boolean);
begin
  if (value = nil) or ((value.Id = '') and (not value.hasExtensionList) {no-comments and (not value.hasComments)}) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

procedure TFHIRJsonParser.ParseUrl(value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseUrl(value, jsn)) {1};
end;

function TFHIRJsonParser.ParseUrl(value : TJsonNode; jsn : TJsonObject) : TFHIRUrl;
begin
  result := TFhirUrl.Create;
  try
    if (value <> nil) then
    begin
      result.LocationStart := value.LocationStart;
      result.LocationEnd := value.LocationEnd;
    end;
    result.value := JsonToString(value);
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRJsonComposer.ComposeUrlValue(json : TJSONWriter; name : String; value : TFhirUrl; inArray : boolean);
begin
  if (value = nil) or (value.value = '') then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    prop(json, name, value.value);
end;

Procedure TFHIRJsonComposer.ComposeUrlProps(json : TJSONWriter; name : String; value : TFhirUrl; inArray : boolean);
begin
  if (value = nil) or ((value.Id = '') and (not value.hasExtensionList) {no-comments and (not value.hasComments)}) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

procedure TFHIRJsonParser.ParseMarkdown(value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMarkdown(value, jsn)) {1};
end;

function TFHIRJsonParser.ParseMarkdown(value : TJsonNode; jsn : TJsonObject) : TFHIRMarkdown;
begin
  result := TFhirMarkdown.Create;
  try
    if (value <> nil) then
    begin
      result.LocationStart := value.LocationStart;
      result.LocationEnd := value.LocationEnd;
    end;
    result.value := JsonToString(value);
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRJsonComposer.ComposeMarkdownValue(json : TJSONWriter; name : String; value : TFhirMarkdown; inArray : boolean);
begin
  if (value = nil) or (value.value = '') then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    prop(json, name, value.value);
end;

Procedure TFHIRJsonComposer.ComposeMarkdownProps(json : TJSONWriter; name : String; value : TFhirMarkdown; inArray : boolean);
begin
  if (value = nil) or ((value.Id = '') and (not value.hasExtensionList) {no-comments and (not value.hasComments)}) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

procedure TFHIRJsonParser.ParseUnsignedInt(value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseUnsignedInt(value, jsn)) {1};
end;

function TFHIRJsonParser.ParseUnsignedInt(value : TJsonNode; jsn : TJsonObject) : TFHIRUnsignedInt;
begin
  result := TFhirUnsignedInt.Create;
  try
    if (value <> nil) then
    begin
      result.LocationStart := value.LocationStart;
      result.LocationEnd := value.LocationEnd;
    end;
    result.value := JsonToString(value);
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRJsonComposer.ComposeUnsignedIntValue(json : TJSONWriter; name : String; value : TFhirUnsignedInt; inArray : boolean);
begin
  if (value = nil) or (value.value = '') then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    propNumber(json, name, value.value);
end;

Procedure TFHIRJsonComposer.ComposeUnsignedIntProps(json : TJSONWriter; name : String; value : TFhirUnsignedInt; inArray : boolean);
begin
  if (value = nil) or ((value.Id = '') and (not value.hasExtensionList) {no-comments and (not value.hasComments)}) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

procedure TFHIRJsonParser.ParseId(value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseId(value, jsn)) {1};
end;

function TFHIRJsonParser.ParseId(value : TJsonNode; jsn : TJsonObject) : TFHIRId;
begin
  result := TFhirId.Create;
  try
    if (value <> nil) then
    begin
      result.LocationStart := value.LocationStart;
      result.LocationEnd := value.LocationEnd;
    end;
    result.value := JsonToString(value);
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRJsonComposer.ComposeIdValue(json : TJSONWriter; name : String; value : TFhirId; inArray : boolean);
begin
  if (value = nil) or (value.value = '') then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    prop(json, name, value.value);
end;

Procedure TFHIRJsonComposer.ComposeIdProps(json : TJSONWriter; name : String; value : TFhirId; inArray : boolean);
begin
  if (value = nil) or ((value.Id = '') and (not value.hasExtensionList) {no-comments and (not value.hasComments)}) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

procedure TFHIRJsonParser.ParsePositiveInt(value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePositiveInt(value, jsn)) {1};
end;

function TFHIRJsonParser.ParsePositiveInt(value : TJsonNode; jsn : TJsonObject) : TFHIRPositiveInt;
begin
  result := TFhirPositiveInt.Create;
  try
    if (value <> nil) then
    begin
      result.LocationStart := value.LocationStart;
      result.LocationEnd := value.LocationEnd;
    end;
    result.value := JsonToString(value);
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRJsonComposer.ComposePositiveIntValue(json : TJSONWriter; name : String; value : TFhirPositiveInt; inArray : boolean);
begin
  if (value = nil) or (value.value = '') then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
    propNumber(json, name, value.value);
end;

Procedure TFHIRJsonComposer.ComposePositiveIntProps(json : TJSONWriter; name : String; value : TFhirPositiveInt; inArray : boolean);
begin
  if (value = nil) or ((value.Id = '') and (not value.hasExtensionList) {no-comments and (not value.hasComments)}) then
  begin
    if inArray then
      propNull(json, name);
    exit;
  end
  else
  begin
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
  end;
end;

procedure TFHIRJsonParser.ParseResourceProperties(jsn : TJsonObject; resource : TFhirResource);
begin
  resource.LocationStart := jsn.LocationStart;
  resource.LocationEnd := jsn.LocationEnd;
  if jsn.has('id') or jsn.has('_id') then
    resource.idElement := parseId(jsn.node['id'], jsn.vObj['_id']);{q}
  if jsn.has('meta') then
    resource.meta := ParseMeta(jsn.vObj['meta']);{q3}
  if jsn.has('implicitRules') or jsn.has('_implicitRules') then
    resource.implicitRulesElement := parseUri(jsn.node['implicitRules'], jsn.vObj['_implicitRules']);{q}
  if jsn.has('language') or jsn.has('_language') then
    resource.languageElement := parseCode(jsn.node['language'], jsn.vObj['_language']);{q}
end;

Procedure TFHIRJsonComposer.ComposeResourceProperties(json : TJSONWriter; elem : TFhirResource);
begin
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeIdValue(json, 'id', elem.idElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeIdProps(json, 'id', elem.idElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('meta') then
    ComposeMeta(json, 'meta', elem.meta); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('implicitRules') then
    ComposeUriValue(json, 'implicitRules', elem.implicitRulesElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('implicitRules') then
    ComposeUriProps(json, 'implicitRules', elem.implicitRulesElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('language') then
    ComposeCodeValue(json, 'language', elem.languageElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('language') then
    ComposeCodeProps(json, 'language', elem.languageElement, false);
end;

procedure TFHIRJsonParser.ParseDomainResourceProperties(jsn : TJsonObject; resource : TFhirDomainResource);
begin
  ParseResourceProperties(jsn, resource);
  if jsn.has('text') then
    resource.text := ParseNarrative(jsn.vObj['text']);{q3}
  if jsn.has('contained') then
    iterateArray(jsn.vArr['contained'], resource.containedList, parseInnerResource);
  if jsn.has('extension') then
    iterateArray(jsn.vArr['extension'], resource.extensionList, parseExtension);
  if jsn.has('modifierExtension') then
    iterateArray(jsn.vArr['modifierExtension'], resource.modifierExtensionList, parseExtension);
end;

Procedure TFHIRJsonComposer.ComposeDomainResourceProperties(json : TJSONWriter; elem : TFhirDomainResource);
var
  i : integer{z.b};
begin
  ComposeResourceProperties(json, elem);
  if (SummaryOption in [soFull, soText]) and doCompose('text') then
    ComposeNarrative(json, 'text', elem.text); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('contained') and (elem.containedList.Count > 0) then
  begin
    json.valueArray('contained');
    for i := 0 to elem.containedList.Count - 1 do
      ComposeInnerResource(json, '', elem, elem.containedList[i]); {z - Resource}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('extension') and (elem.extensionList.Count > 0) then
  begin
    json.valueArray('extension');
    for i := 0 to elem.extensionList.Count - 1 do
      ComposeExtension(json, '', elem.extensionList[i]); {z - Extension}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('modifierExtension') and (elem.modifierExtensionList.Count > 0) then
  begin
    json.valueArray('modifierExtension');
    for i := 0 to elem.modifierExtensionList.Count - 1 do
      ComposeExtension(json, '', elem.modifierExtensionList[i]); {z - Extension}
    json.FinishArray;
  end;
end;

{$IFDEF FHIR_PARAMETERS}
procedure TFHIRJsonParser.ParseParametersParameter(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseParametersParameter(jsn)); {2}
end;

function TFHIRJsonParser.ParseParametersParameter(jsn : TJsonObject) : TFhirParametersParameter;
begin
  result := TFhirParametersParameter.create;
  try
    ParseParametersParameterProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseParametersParameterProperties(jsn : TJsonObject; result : TFhirParametersParameter);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('valueCanonical') or jsn.has('_valueCanonical') then
      result.value := parseCanonical(jsn.node['valueCanonical'], jsn.vObj['_valueCanonical']);
    if jsn.has('valueCode') or jsn.has('_valueCode') then
      result.value := parseCode(jsn.node['valueCode'], jsn.vObj['_valueCode']);
    if jsn.has('valueId') or jsn.has('_valueId') then
      result.value := parseId(jsn.node['valueId'], jsn.vObj['_valueId']);
    if jsn.has('valueMarkdown') or jsn.has('_valueMarkdown') then
      result.value := parseMarkdown(jsn.node['valueMarkdown'], jsn.vObj['_valueMarkdown']);
    if jsn.has('valueOid') or jsn.has('_valueOid') then
      result.value := parseOid(jsn.node['valueOid'], jsn.vObj['_valueOid']);
    if jsn.has('valuePositiveInt') or jsn.has('_valuePositiveInt') then
      result.value := parsePositiveInt(jsn.node['valuePositiveInt'], jsn.vObj['_valuePositiveInt']);
    if jsn.has('valueUnsignedInt') or jsn.has('_valueUnsignedInt') then
      result.value := parseUnsignedInt(jsn.node['valueUnsignedInt'], jsn.vObj['_valueUnsignedInt']);
    if jsn.has('valueUrl') or jsn.has('_valueUrl') then
      result.value := parseUrl(jsn.node['valueUrl'], jsn.vObj['_valueUrl']);
    if jsn.has('valueUuid') or jsn.has('_valueUuid') then
      result.value := parseUuid(jsn.node['valueUuid'], jsn.vObj['_valueUuid']);
    if jsn.has('valueAddress') {a4} then
      result.value := ParseAddress(jsn.vObj['valueAddress']);
    if jsn.has('valueAge') {a4} then
      result.value := ParseAge(jsn.vObj['valueAge']);
    if jsn.has('valueAnnotation') {a4} then
      result.value := ParseAnnotation(jsn.vObj['valueAnnotation']);
    if jsn.has('valueAttachment') {a4} then
      result.value := ParseAttachment(jsn.vObj['valueAttachment']);
    if jsn.has('valueCodeableConcept') {a4} then
      result.value := ParseCodeableConcept(jsn.vObj['valueCodeableConcept']);
    if jsn.has('valueCoding') {a4} then
      result.value := ParseCoding(jsn.vObj['valueCoding']);
    if jsn.has('valueContactPoint') {a4} then
      result.value := ParseContactPoint(jsn.vObj['valueContactPoint']);
    if jsn.has('valueCount') {a4} then
      result.value := ParseCount(jsn.vObj['valueCount']);
    if jsn.has('valueDistance') {a4} then
      result.value := ParseDistance(jsn.vObj['valueDistance']);
    if jsn.has('valueDuration') {a4} then
      result.value := ParseDuration(jsn.vObj['valueDuration']);
    if jsn.has('valueHumanName') {a4} then
      result.value := ParseHumanName(jsn.vObj['valueHumanName']);
    if jsn.has('valueIdentifier') {a4} then
      result.value := ParseIdentifier(jsn.vObj['valueIdentifier']);
    if jsn.has('valueMoney') {a4} then
      result.value := ParseMoney(jsn.vObj['valueMoney']);
    if jsn.has('valuePeriod') {a4} then
      result.value := ParsePeriod(jsn.vObj['valuePeriod']);
    if jsn.has('valueQuantity') {a4} then
      result.value := ParseQuantity(jsn.vObj['valueQuantity']);
    if jsn.has('valueRange') {a4} then
      result.value := ParseRange(jsn.vObj['valueRange']);
    if jsn.has('valueRatio') {a4} then
      result.value := ParseRatio(jsn.vObj['valueRatio']);
    if jsn.has('valueReference') {a4} then
      result.value := ParseReference(jsn.vObj['valueReference']);
    if jsn.has('valueSampledData') {a4} then
      result.value := ParseSampledData(jsn.vObj['valueSampledData']);
    if jsn.has('valueSignature') {a4} then
      result.value := ParseSignature(jsn.vObj['valueSignature']);
    if jsn.has('valueTiming') {a4} then
      result.value := ParseTiming(jsn.vObj['valueTiming']);
    if jsn.has('valueContactDetail') {a4} then
      result.value := ParseContactDetail(jsn.vObj['valueContactDetail']);
    if jsn.has('valueContributor') {a4} then
      result.value := ParseContributor(jsn.vObj['valueContributor']);
    if jsn.has('valueDataRequirement') {a4} then
      result.value := ParseDataRequirement(jsn.vObj['valueDataRequirement']);
    if jsn.has('valueExpression') {a4} then
      result.value := ParseExpression(jsn.vObj['valueExpression']);
    if jsn.has('valueParameterDefinition') {a4} then
      result.value := ParseParameterDefinition(jsn.vObj['valueParameterDefinition']);
    if jsn.has('valueRelatedArtifact') {a4} then
      result.value := ParseRelatedArtifact(jsn.vObj['valueRelatedArtifact']);
    if jsn.has('valueTriggerDefinition') {a4} then
      result.value := ParseTriggerDefinition(jsn.vObj['valueTriggerDefinition']);
    if jsn.has('valueUsageContext') {a4} then
      result.value := ParseUsageContext(jsn.vObj['valueUsageContext']);
    if jsn.has('valueDosage') {a4} then
      result.value := ParseDosage(jsn.vObj['valueDosage']);
    if jsn.has('valueBase64Binary') or jsn.has('_valueBase64Binary') then
      result.value := parseBase64Binary(jsn.node['valueBase64Binary'], jsn.vObj['_valueBase64Binary']);
    if jsn.has('valueBoolean') or jsn.has('_valueBoolean') then
      result.value := parseBoolean(jsn.node['valueBoolean'], jsn.vObj['_valueBoolean']);
    if jsn.has('valueDate') or jsn.has('_valueDate') then
      result.value := parseDate(jsn.node['valueDate'], jsn.vObj['_valueDate']);
    if jsn.has('valueDateTime') or jsn.has('_valueDateTime') then
      result.value := parseDateTime(jsn.node['valueDateTime'], jsn.vObj['_valueDateTime']);
    if jsn.has('valueDecimal') or jsn.has('_valueDecimal') then
      result.value := parseDecimal(jsn.node['valueDecimal'], jsn.vObj['_valueDecimal']);
    if jsn.has('valueInstant') or jsn.has('_valueInstant') then
      result.value := parseInstant(jsn.node['valueInstant'], jsn.vObj['_valueInstant']);
    if jsn.has('valueInteger') or jsn.has('_valueInteger') then
      result.value := parseInteger(jsn.node['valueInteger'], jsn.vObj['_valueInteger']);
    if jsn.has('valueString') or jsn.has('_valueString') then
      result.value := parseString(jsn.node['valueString'], jsn.vObj['_valueString']);
    if jsn.has('valueTime') or jsn.has('_valueTime') then
      result.value := parseTime(jsn.node['valueTime'], jsn.vObj['_valueTime']);
    if jsn.has('valueUri') or jsn.has('_valueUri') then
      result.value := parseUri(jsn.node['valueUri'], jsn.vObj['_valueUri']);
    if jsn.has('resource') then
        result.resource := ParseInnerResource(jsn.vObj['resource']);{q3}
    if jsn.has('part') then
      iterateArray(jsn.vArr['part'], result.partList, parseParametersParameter);
end;

procedure TFHIRJsonComposer.ComposeParametersParameter(json : TJSONWriter; name : string; elem : TFhirParametersParameter; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'name', elem.nameElement, false);
  ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirCanonical) then 
  begin
    ComposeCanonicalValue(json, 'valueCanonical', TFhirCanonical(elem.value), false);
    ComposeCanonicalProps(json, 'valueCanonical', TFhirCanonical(elem.value), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirCode) then 
  begin
    ComposeCodeValue(json, 'valueCode', TFhirCode(elem.value), false);
    ComposeCodeProps(json, 'valueCode', TFhirCode(elem.value), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirId) then 
  begin
    ComposeIdValue(json, 'valueId', TFhirId(elem.value), false);
    ComposeIdProps(json, 'valueId', TFhirId(elem.value), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirMarkdown) then 
  begin
    ComposeMarkdownValue(json, 'valueMarkdown', TFhirMarkdown(elem.value), false);
    ComposeMarkdownProps(json, 'valueMarkdown', TFhirMarkdown(elem.value), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirOid) then 
  begin
    ComposeOidValue(json, 'valueOid', TFhirOid(elem.value), false);
    ComposeOidProps(json, 'valueOid', TFhirOid(elem.value), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirPositiveInt) then 
  begin
    ComposePositiveIntValue(json, 'valuePositiveInt', TFhirPositiveInt(elem.value), false);
    ComposePositiveIntProps(json, 'valuePositiveInt', TFhirPositiveInt(elem.value), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirUnsignedInt) then 
  begin
    ComposeUnsignedIntValue(json, 'valueUnsignedInt', TFhirUnsignedInt(elem.value), false);
    ComposeUnsignedIntProps(json, 'valueUnsignedInt', TFhirUnsignedInt(elem.value), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirUrl) then 
  begin
    ComposeUrlValue(json, 'valueUrl', TFhirUrl(elem.value), false);
    ComposeUrlProps(json, 'valueUrl', TFhirUrl(elem.value), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirUuid) then 
  begin
    ComposeUuidValue(json, 'valueUuid', TFhirUuid(elem.value), false);
    ComposeUuidProps(json, 'valueUuid', TFhirUuid(elem.value), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirAddress) then 
    ComposeAddress(json, 'valueAddress', TFhirAddress(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirAge) then 
    ComposeAge(json, 'valueAge', TFhirAge(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirAnnotation) then 
    ComposeAnnotation(json, 'valueAnnotation', TFhirAnnotation(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirAttachment) then 
    ComposeAttachment(json, 'valueAttachment', TFhirAttachment(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'valueCodeableConcept', TFhirCodeableConcept(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirCoding) then 
    ComposeCoding(json, 'valueCoding', TFhirCoding(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirContactPoint) then 
    ComposeContactPoint(json, 'valueContactPoint', TFhirContactPoint(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirCount) then 
    ComposeCount(json, 'valueCount', TFhirCount(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDistance) then 
    ComposeDistance(json, 'valueDistance', TFhirDistance(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDuration) then 
    ComposeDuration(json, 'valueDuration', TFhirDuration(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirHumanName) then 
    ComposeHumanName(json, 'valueHumanName', TFhirHumanName(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirIdentifier) then 
    ComposeIdentifier(json, 'valueIdentifier', TFhirIdentifier(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirMoney) then 
    ComposeMoney(json, 'valueMoney', TFhirMoney(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirPeriod) then 
    ComposePeriod(json, 'valuePeriod', TFhirPeriod(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirQuantity) then 
    ComposeQuantity(json, 'valueQuantity', TFhirQuantity(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirRange) then 
    ComposeRange(json, 'valueRange', TFhirRange(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirRatio) then 
    ComposeRatio(json, 'valueRatio', TFhirRatio(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirReference) then 
    ComposeReference(json, 'valueReference', TFhirReference(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirSampledData) then 
    ComposeSampledData(json, 'valueSampledData', TFhirSampledData(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirSignature) then 
    ComposeSignature(json, 'valueSignature', TFhirSignature(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirTiming) then 
    ComposeTiming(json, 'valueTiming', TFhirTiming(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirContactDetail) then 
    ComposeContactDetail(json, 'valueContactDetail', TFhirContactDetail(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirContributor) then 
    ComposeContributor(json, 'valueContributor', TFhirContributor(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDataRequirement) then 
    ComposeDataRequirement(json, 'valueDataRequirement', TFhirDataRequirement(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirExpression) then 
    ComposeExpression(json, 'valueExpression', TFhirExpression(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirParameterDefinition) then 
    ComposeParameterDefinition(json, 'valueParameterDefinition', TFhirParameterDefinition(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirRelatedArtifact) then 
    ComposeRelatedArtifact(json, 'valueRelatedArtifact', TFhirRelatedArtifact(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirTriggerDefinition) then 
    ComposeTriggerDefinition(json, 'valueTriggerDefinition', TFhirTriggerDefinition(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirUsageContext) then 
    ComposeUsageContext(json, 'valueUsageContext', TFhirUsageContext(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDosage) then 
    ComposeDosage(json, 'valueDosage', TFhirDosage(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirBase64Binary) then 
  begin
    ComposeBase64BinaryValue(json, 'valueBase64Binary', TFhirBase64Binary(elem.value), false);
    ComposeBase64BinaryProps(json, 'valueBase64Binary', TFhirBase64Binary(elem.value), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'valueBoolean', TFhirBoolean(elem.value), false);
    ComposeBooleanProps(json, 'valueBoolean', TFhirBoolean(elem.value), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDate) then 
  begin
    ComposeDateValue(json, 'valueDate', TFhirDate(elem.value), false);
    ComposeDateProps(json, 'valueDate', TFhirDate(elem.value), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'valueDateTime', TFhirDateTime(elem.value), false);
    ComposeDateTimeProps(json, 'valueDateTime', TFhirDateTime(elem.value), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDecimal) then 
  begin
    ComposeDecimalValue(json, 'valueDecimal', TFhirDecimal(elem.value), false);
    ComposeDecimalProps(json, 'valueDecimal', TFhirDecimal(elem.value), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirInstant) then 
  begin
    ComposeInstantValue(json, 'valueInstant', TFhirInstant(elem.value), false);
    ComposeInstantProps(json, 'valueInstant', TFhirInstant(elem.value), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirInteger) then 
  begin
    ComposeIntegerValue(json, 'valueInteger', TFhirInteger(elem.value), false);
    ComposeIntegerProps(json, 'valueInteger', TFhirInteger(elem.value), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirString) then 
  begin
    ComposeStringValue(json, 'valueString', TFhirString(elem.value), false);
    ComposeStringProps(json, 'valueString', TFhirString(elem.value), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirTime) then 
  begin
    ComposeTimeValue(json, 'valueTime', TFhirTime(elem.value), false);
    ComposeTimeProps(json, 'valueTime', TFhirTime(elem.value), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirUri) then 
  begin
    ComposeUriValue(json, 'valueUri', TFhirUri(elem.value), false);
    ComposeUriProps(json, 'valueUri', TFhirUri(elem.value), false);
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInnerResource(json, 'resource', elem, elem.resource); {a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.partList.Count > 0) then
  begin
    json.valueArray('part');
    for i := 0 to elem.partList.Count - 1 do
      ComposeParametersParameter(json, '', elem.partList[i]); {z - @Parameters.parameter}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseParameters(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseParameters(jsn)); {2}
end;

function TFHIRJsonParser.ParseParameters(jsn : TJsonObject) : TFhirParameters;
begin
  result := TFhirParameters.create;
  try
    ParseParametersProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseParametersProperties(jsn : TJsonObject; result : TFhirParameters);
begin
    ParseResourceProperties(jsn, result);
    if jsn.has('parameter') then
      iterateArray(jsn.vArr['parameter'], result.parameterList, parseParametersParameter);
end;

procedure TFHIRJsonComposer.ComposeParameters(json : TJSONWriter; name : string; elem : TFhirParameters; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and doCompose('parameter') and (elem.parameterList.Count > 0) then
  begin
    json.valueArray('parameter');
    for i := 0 to elem.parameterList.Count - 1 do
      ComposeParametersParameter(json, '', elem.parameterList[i]); {z - }
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_PARAMETERS}
procedure TFHIRJsonParser.ParseExtension(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseExtension(jsn)); {2}
end;

function TFHIRJsonParser.ParseExtension(jsn : TJsonObject) : TFhirExtension;
begin
  result := TFhirExtension.create;
  try
    ParseExtensionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseExtensionProperties(jsn : TJsonObject; result : TFhirExtension);
begin
    ParseElementProperties(jsn, result);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := parseString(jsn.node['url'], jsn.vObj['_url']);{q}
    if jsn.has('valueCanonical') or jsn.has('_valueCanonical') then
      result.value := parseCanonical(jsn.node['valueCanonical'], jsn.vObj['_valueCanonical']);
    if jsn.has('valueCode') or jsn.has('_valueCode') then
      result.value := parseCode(jsn.node['valueCode'], jsn.vObj['_valueCode']);
    if jsn.has('valueId') or jsn.has('_valueId') then
      result.value := parseId(jsn.node['valueId'], jsn.vObj['_valueId']);
    if jsn.has('valueMarkdown') or jsn.has('_valueMarkdown') then
      result.value := parseMarkdown(jsn.node['valueMarkdown'], jsn.vObj['_valueMarkdown']);
    if jsn.has('valueOid') or jsn.has('_valueOid') then
      result.value := parseOid(jsn.node['valueOid'], jsn.vObj['_valueOid']);
    if jsn.has('valuePositiveInt') or jsn.has('_valuePositiveInt') then
      result.value := parsePositiveInt(jsn.node['valuePositiveInt'], jsn.vObj['_valuePositiveInt']);
    if jsn.has('valueUnsignedInt') or jsn.has('_valueUnsignedInt') then
      result.value := parseUnsignedInt(jsn.node['valueUnsignedInt'], jsn.vObj['_valueUnsignedInt']);
    if jsn.has('valueUrl') or jsn.has('_valueUrl') then
      result.value := parseUrl(jsn.node['valueUrl'], jsn.vObj['_valueUrl']);
    if jsn.has('valueUuid') or jsn.has('_valueUuid') then
      result.value := parseUuid(jsn.node['valueUuid'], jsn.vObj['_valueUuid']);
    if jsn.has('valueAddress') {a4} then
      result.value := ParseAddress(jsn.vObj['valueAddress']);
    if jsn.has('valueAge') {a4} then
      result.value := ParseAge(jsn.vObj['valueAge']);
    if jsn.has('valueAnnotation') {a4} then
      result.value := ParseAnnotation(jsn.vObj['valueAnnotation']);
    if jsn.has('valueAttachment') {a4} then
      result.value := ParseAttachment(jsn.vObj['valueAttachment']);
    if jsn.has('valueCodeableConcept') {a4} then
      result.value := ParseCodeableConcept(jsn.vObj['valueCodeableConcept']);
    if jsn.has('valueCoding') {a4} then
      result.value := ParseCoding(jsn.vObj['valueCoding']);
    if jsn.has('valueContactPoint') {a4} then
      result.value := ParseContactPoint(jsn.vObj['valueContactPoint']);
    if jsn.has('valueCount') {a4} then
      result.value := ParseCount(jsn.vObj['valueCount']);
    if jsn.has('valueDistance') {a4} then
      result.value := ParseDistance(jsn.vObj['valueDistance']);
    if jsn.has('valueDuration') {a4} then
      result.value := ParseDuration(jsn.vObj['valueDuration']);
    if jsn.has('valueHumanName') {a4} then
      result.value := ParseHumanName(jsn.vObj['valueHumanName']);
    if jsn.has('valueIdentifier') {a4} then
      result.value := ParseIdentifier(jsn.vObj['valueIdentifier']);
    if jsn.has('valueMoney') {a4} then
      result.value := ParseMoney(jsn.vObj['valueMoney']);
    if jsn.has('valuePeriod') {a4} then
      result.value := ParsePeriod(jsn.vObj['valuePeriod']);
    if jsn.has('valueQuantity') {a4} then
      result.value := ParseQuantity(jsn.vObj['valueQuantity']);
    if jsn.has('valueRange') {a4} then
      result.value := ParseRange(jsn.vObj['valueRange']);
    if jsn.has('valueRatio') {a4} then
      result.value := ParseRatio(jsn.vObj['valueRatio']);
    if jsn.has('valueReference') {a4} then
      result.value := ParseReference(jsn.vObj['valueReference']);
    if jsn.has('valueSampledData') {a4} then
      result.value := ParseSampledData(jsn.vObj['valueSampledData']);
    if jsn.has('valueSignature') {a4} then
      result.value := ParseSignature(jsn.vObj['valueSignature']);
    if jsn.has('valueTiming') {a4} then
      result.value := ParseTiming(jsn.vObj['valueTiming']);
    if jsn.has('valueContactDetail') {a4} then
      result.value := ParseContactDetail(jsn.vObj['valueContactDetail']);
    if jsn.has('valueContributor') {a4} then
      result.value := ParseContributor(jsn.vObj['valueContributor']);
    if jsn.has('valueDataRequirement') {a4} then
      result.value := ParseDataRequirement(jsn.vObj['valueDataRequirement']);
    if jsn.has('valueExpression') {a4} then
      result.value := ParseExpression(jsn.vObj['valueExpression']);
    if jsn.has('valueParameterDefinition') {a4} then
      result.value := ParseParameterDefinition(jsn.vObj['valueParameterDefinition']);
    if jsn.has('valueRelatedArtifact') {a4} then
      result.value := ParseRelatedArtifact(jsn.vObj['valueRelatedArtifact']);
    if jsn.has('valueTriggerDefinition') {a4} then
      result.value := ParseTriggerDefinition(jsn.vObj['valueTriggerDefinition']);
    if jsn.has('valueUsageContext') {a4} then
      result.value := ParseUsageContext(jsn.vObj['valueUsageContext']);
    if jsn.has('valueDosage') {a4} then
      result.value := ParseDosage(jsn.vObj['valueDosage']);
    if jsn.has('valueBase64Binary') or jsn.has('_valueBase64Binary') then
      result.value := parseBase64Binary(jsn.node['valueBase64Binary'], jsn.vObj['_valueBase64Binary']);
    if jsn.has('valueBoolean') or jsn.has('_valueBoolean') then
      result.value := parseBoolean(jsn.node['valueBoolean'], jsn.vObj['_valueBoolean']);
    if jsn.has('valueDate') or jsn.has('_valueDate') then
      result.value := parseDate(jsn.node['valueDate'], jsn.vObj['_valueDate']);
    if jsn.has('valueDateTime') or jsn.has('_valueDateTime') then
      result.value := parseDateTime(jsn.node['valueDateTime'], jsn.vObj['_valueDateTime']);
    if jsn.has('valueDecimal') or jsn.has('_valueDecimal') then
      result.value := parseDecimal(jsn.node['valueDecimal'], jsn.vObj['_valueDecimal']);
    if jsn.has('valueInstant') or jsn.has('_valueInstant') then
      result.value := parseInstant(jsn.node['valueInstant'], jsn.vObj['_valueInstant']);
    if jsn.has('valueInteger') or jsn.has('_valueInteger') then
      result.value := parseInteger(jsn.node['valueInteger'], jsn.vObj['_valueInteger']);
    if jsn.has('valueString') or jsn.has('_valueString') then
      result.value := parseString(jsn.node['valueString'], jsn.vObj['_valueString']);
    if jsn.has('valueTime') or jsn.has('_valueTime') then
      result.value := parseTime(jsn.node['valueTime'], jsn.vObj['_valueTime']);
    if jsn.has('valueUri') or jsn.has('_valueUri') then
      result.value := parseUri(jsn.node['valueUri'], jsn.vObj['_valueUri']);
end;

procedure TFHIRJsonComposer.ComposeExtension(json : TJSONWriter; name : string; elem : TFhirExtension; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElement(json, '', elem, true);
  ComposeStringValue(json, 'url', elem.urlElement, false);
  ComposeStringProps(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirCanonical) then 
  begin
    ComposeCanonicalValue(json, 'valueCanonical', TFhirCanonical(elem.value), false);
    ComposeCanonicalProps(json, 'valueCanonical', TFhirCanonical(elem.value), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirCode) then 
  begin
    ComposeCodeValue(json, 'valueCode', TFhirCode(elem.value), false);
    ComposeCodeProps(json, 'valueCode', TFhirCode(elem.value), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirId) then 
  begin
    ComposeIdValue(json, 'valueId', TFhirId(elem.value), false);
    ComposeIdProps(json, 'valueId', TFhirId(elem.value), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirMarkdown) then 
  begin
    ComposeMarkdownValue(json, 'valueMarkdown', TFhirMarkdown(elem.value), false);
    ComposeMarkdownProps(json, 'valueMarkdown', TFhirMarkdown(elem.value), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirOid) then 
  begin
    ComposeOidValue(json, 'valueOid', TFhirOid(elem.value), false);
    ComposeOidProps(json, 'valueOid', TFhirOid(elem.value), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirPositiveInt) then 
  begin
    ComposePositiveIntValue(json, 'valuePositiveInt', TFhirPositiveInt(elem.value), false);
    ComposePositiveIntProps(json, 'valuePositiveInt', TFhirPositiveInt(elem.value), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirUnsignedInt) then 
  begin
    ComposeUnsignedIntValue(json, 'valueUnsignedInt', TFhirUnsignedInt(elem.value), false);
    ComposeUnsignedIntProps(json, 'valueUnsignedInt', TFhirUnsignedInt(elem.value), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirUrl) then 
  begin
    ComposeUrlValue(json, 'valueUrl', TFhirUrl(elem.value), false);
    ComposeUrlProps(json, 'valueUrl', TFhirUrl(elem.value), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirUuid) then 
  begin
    ComposeUuidValue(json, 'valueUuid', TFhirUuid(elem.value), false);
    ComposeUuidProps(json, 'valueUuid', TFhirUuid(elem.value), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirAddress) then 
    ComposeAddress(json, 'valueAddress', TFhirAddress(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirAge) then 
    ComposeAge(json, 'valueAge', TFhirAge(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirAnnotation) then 
    ComposeAnnotation(json, 'valueAnnotation', TFhirAnnotation(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirAttachment) then 
    ComposeAttachment(json, 'valueAttachment', TFhirAttachment(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'valueCodeableConcept', TFhirCodeableConcept(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirCoding) then 
    ComposeCoding(json, 'valueCoding', TFhirCoding(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirContactPoint) then 
    ComposeContactPoint(json, 'valueContactPoint', TFhirContactPoint(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirCount) then 
    ComposeCount(json, 'valueCount', TFhirCount(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDistance) then 
    ComposeDistance(json, 'valueDistance', TFhirDistance(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDuration) then 
    ComposeDuration(json, 'valueDuration', TFhirDuration(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirHumanName) then 
    ComposeHumanName(json, 'valueHumanName', TFhirHumanName(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirIdentifier) then 
    ComposeIdentifier(json, 'valueIdentifier', TFhirIdentifier(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirMoney) then 
    ComposeMoney(json, 'valueMoney', TFhirMoney(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirPeriod) then 
    ComposePeriod(json, 'valuePeriod', TFhirPeriod(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirQuantity) then 
    ComposeQuantity(json, 'valueQuantity', TFhirQuantity(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirRange) then 
    ComposeRange(json, 'valueRange', TFhirRange(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirRatio) then 
    ComposeRatio(json, 'valueRatio', TFhirRatio(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirReference) then 
    ComposeReference(json, 'valueReference', TFhirReference(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirSampledData) then 
    ComposeSampledData(json, 'valueSampledData', TFhirSampledData(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirSignature) then 
    ComposeSignature(json, 'valueSignature', TFhirSignature(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirTiming) then 
    ComposeTiming(json, 'valueTiming', TFhirTiming(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirContactDetail) then 
    ComposeContactDetail(json, 'valueContactDetail', TFhirContactDetail(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirContributor) then 
    ComposeContributor(json, 'valueContributor', TFhirContributor(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDataRequirement) then 
    ComposeDataRequirement(json, 'valueDataRequirement', TFhirDataRequirement(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirExpression) then 
    ComposeExpression(json, 'valueExpression', TFhirExpression(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirParameterDefinition) then 
    ComposeParameterDefinition(json, 'valueParameterDefinition', TFhirParameterDefinition(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirRelatedArtifact) then 
    ComposeRelatedArtifact(json, 'valueRelatedArtifact', TFhirRelatedArtifact(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirTriggerDefinition) then 
    ComposeTriggerDefinition(json, 'valueTriggerDefinition', TFhirTriggerDefinition(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirUsageContext) then 
    ComposeUsageContext(json, 'valueUsageContext', TFhirUsageContext(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDosage) then 
    ComposeDosage(json, 'valueDosage', TFhirDosage(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirBase64Binary) then 
  begin
    ComposeBase64BinaryValue(json, 'valueBase64Binary', TFhirBase64Binary(elem.value), false);
    ComposeBase64BinaryProps(json, 'valueBase64Binary', TFhirBase64Binary(elem.value), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'valueBoolean', TFhirBoolean(elem.value), false);
    ComposeBooleanProps(json, 'valueBoolean', TFhirBoolean(elem.value), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDate) then 
  begin
    ComposeDateValue(json, 'valueDate', TFhirDate(elem.value), false);
    ComposeDateProps(json, 'valueDate', TFhirDate(elem.value), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'valueDateTime', TFhirDateTime(elem.value), false);
    ComposeDateTimeProps(json, 'valueDateTime', TFhirDateTime(elem.value), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDecimal) then 
  begin
    ComposeDecimalValue(json, 'valueDecimal', TFhirDecimal(elem.value), false);
    ComposeDecimalProps(json, 'valueDecimal', TFhirDecimal(elem.value), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirInstant) then 
  begin
    ComposeInstantValue(json, 'valueInstant', TFhirInstant(elem.value), false);
    ComposeInstantProps(json, 'valueInstant', TFhirInstant(elem.value), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirInteger) then 
  begin
    ComposeIntegerValue(json, 'valueInteger', TFhirInteger(elem.value), false);
    ComposeIntegerProps(json, 'valueInteger', TFhirInteger(elem.value), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirString) then 
  begin
    ComposeStringValue(json, 'valueString', TFhirString(elem.value), false);
    ComposeStringProps(json, 'valueString', TFhirString(elem.value), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirTime) then 
  begin
    ComposeTimeValue(json, 'valueTime', TFhirTime(elem.value), false);
    ComposeTimeProps(json, 'valueTime', TFhirTime(elem.value), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirUri) then 
  begin
    ComposeUriValue(json, 'valueUri', TFhirUri(elem.value), false);
    ComposeUriProps(json, 'valueUri', TFhirUri(elem.value), false);
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseNarrative(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseNarrative(jsn)); {2}
end;

function TFHIRJsonParser.ParseNarrative(jsn : TJsonObject) : TFhirNarrative;
begin
  result := TFhirNarrative.create;
  try
    ParseNarrativeProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseNarrativeProperties(jsn : TJsonObject; result : TFhirNarrative);
begin
    ParseElementProperties(jsn, result);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirNarrativeStatusEnum, SYSTEMS_TFhirNarrativeStatusEnum);
    if jsn.has('div') then
        result.div_ := parseXHtmlNode(jsn.path+'.div', jsn.node['div']);{q2}
end;

procedure TFHIRJsonComposer.ComposeNarrative(json : TJSONWriter; name : string; elem : TFhirNarrative; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElement(json, '', elem, true);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirNarrativeStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirNarrativeStatusEnum, false);
  ComposeXHtmlNode(json, 'div', elem.div_); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseContributor(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseContributor(jsn)); {2}
end;

function TFHIRJsonParser.ParseContributor(jsn : TJsonObject) : TFhirContributor;
begin
  result := TFhirContributor.create;
  try
    ParseContributorProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseContributorProperties(jsn : TJsonObject; result : TFhirContributor);
begin
    ParseElementProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn.node['type'], jsn.vObj['_type'], CODES_TFhirContributorTypeEnum, SYSTEMS_TFhirContributorTypeEnum);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseContactDetail);
end;

procedure TFHIRJsonComposer.ComposeContributor(json : TJSONWriter; name : string; elem : TFhirContributor; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElement(json, '', elem, true);
  ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirContributorTypeEnum, false);
  ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirContributorTypeEnum, false);
  ComposeStringValue(json, 'name', elem.nameElement, false);
  ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.contactList.Count > 0) then
  begin
    json.valueArray('contact');
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(json, '', elem.contactList[i]); {z - ContactDetail}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseAttachment(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAttachment(jsn)); {2}
end;

function TFHIRJsonParser.ParseAttachment(jsn : TJsonObject) : TFhirAttachment;
begin
  result := TFhirAttachment.create;
  try
    ParseAttachmentProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseAttachmentProperties(jsn : TJsonObject; result : TFhirAttachment);
begin
    ParseElementProperties(jsn, result);
    if jsn.has('contentType') or jsn.has('_contentType') then
        result.contentTypeElement := parseCode(jsn.node['contentType'], jsn.vObj['_contentType']);{q}
    if jsn.has('language') or jsn.has('_language') then
        result.languageElement := parseCode(jsn.node['language'], jsn.vObj['_language']);{q}
    if jsn.has('data') or jsn.has('_data') then
        result.dataElement := parseBase64Binary(jsn.node['data'], jsn.vObj['_data']);{q}
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := parseUrl(jsn.node['url'], jsn.vObj['_url']);{q}
    if jsn.has('size') or jsn.has('_size') then
        result.sizeElement := parseUnsignedInt(jsn.node['size'], jsn.vObj['_size']);{q}
    if jsn.has('hash') or jsn.has('_hash') then
        result.hashElement := parseBase64Binary(jsn.node['hash'], jsn.vObj['_hash']);{q}
    if jsn.has('title') or jsn.has('_title') then
        result.titleElement := parseString(jsn.node['title'], jsn.vObj['_title']);{q}
    if jsn.has('creation') or jsn.has('_creation') then
        result.creationElement := parseDateTime(jsn.node['creation'], jsn.vObj['_creation']);{q}
end;

procedure TFHIRJsonComposer.ComposeAttachment(json : TJSONWriter; name : string; elem : TFhirAttachment; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElement(json, '', elem, true);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeValue(json, 'contentType', elem.contentTypeElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeProps(json, 'contentType', elem.contentTypeElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeValue(json, 'language', elem.languageElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeProps(json, 'language', elem.languageElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBase64BinaryValue(json, 'data', elem.dataElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBase64BinaryProps(json, 'data', elem.dataElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUrlValue(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUrlProps(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUnsignedIntValue(json, 'size', elem.sizeElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUnsignedIntProps(json, 'size', elem.sizeElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBase64BinaryValue(json, 'hash', elem.hashElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBase64BinaryProps(json, 'hash', elem.hashElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDateTimeValue(json, 'creation', elem.creationElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDateTimeProps(json, 'creation', elem.creationElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseDataRequirementCodeFilter(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDataRequirementCodeFilter(jsn)); {2}
end;

function TFHIRJsonParser.ParseDataRequirementCodeFilter(jsn : TJsonObject) : TFhirDataRequirementCodeFilter;
begin
  result := TFhirDataRequirementCodeFilter.create;
  try
    ParseDataRequirementCodeFilterProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseDataRequirementCodeFilterProperties(jsn : TJsonObject; result : TFhirDataRequirementCodeFilter);
begin
    ParseElementProperties(jsn, result);
    if jsn.has('path') or jsn.has('_path') then
        result.pathElement := parseString(jsn.node['path'], jsn.vObj['_path']);{q}
    if jsn.has('searchParam') or jsn.has('_searchParam') then
        result.searchParamElement := parseString(jsn.node['searchParam'], jsn.vObj['_searchParam']);{q}
    if jsn.has('valueSet') or jsn.has('_valueSet') then
        result.valueSetElement := parseCanonical(jsn.node['valueSet'], jsn.vObj['_valueSet']);{q}
    if jsn.has('code') then
      iterateArray(jsn.vArr['code'], result.codeList, parseCoding);
end;

procedure TFHIRJsonComposer.ComposeDataRequirementCodeFilter(json : TJSONWriter; name : string; elem : TFhirDataRequirementCodeFilter; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'path', elem.pathElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'path', elem.pathElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'searchParam', elem.searchParamElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'searchParam', elem.searchParamElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCanonicalValue(json, 'valueSet', elem.valueSetElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCanonicalProps(json, 'valueSet', elem.valueSetElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.codeList.Count > 0) then
  begin
    json.valueArray('code');
    for i := 0 to elem.codeList.Count - 1 do
      ComposeCoding(json, '', elem.codeList[i]); {z - Coding}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseDataRequirementDateFilter(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDataRequirementDateFilter(jsn)); {2}
end;

function TFHIRJsonParser.ParseDataRequirementDateFilter(jsn : TJsonObject) : TFhirDataRequirementDateFilter;
begin
  result := TFhirDataRequirementDateFilter.create;
  try
    ParseDataRequirementDateFilterProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseDataRequirementDateFilterProperties(jsn : TJsonObject; result : TFhirDataRequirementDateFilter);
begin
    ParseElementProperties(jsn, result);
    if jsn.has('path') or jsn.has('_path') then
        result.pathElement := parseString(jsn.node['path'], jsn.vObj['_path']);{q}
    if jsn.has('searchParam') or jsn.has('_searchParam') then
        result.searchParamElement := parseString(jsn.node['searchParam'], jsn.vObj['_searchParam']);{q}
    if jsn.has('valuePeriod') {a4} then
      result.value := ParsePeriod(jsn.vObj['valuePeriod']);
    if jsn.has('valueDuration') {a4} then
      result.value := ParseDuration(jsn.vObj['valueDuration']);
    if jsn.has('valueDateTime') or jsn.has('_valueDateTime') then
      result.value := parseDateTime(jsn.node['valueDateTime'], jsn.vObj['_valueDateTime']);
end;

procedure TFHIRJsonComposer.ComposeDataRequirementDateFilter(json : TJSONWriter; name : string; elem : TFhirDataRequirementDateFilter; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'path', elem.pathElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'path', elem.pathElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'searchParam', elem.searchParamElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'searchParam', elem.searchParamElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirPeriod) then 
    ComposePeriod(json, 'valuePeriod', TFhirPeriod(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirDuration) then 
    ComposeDuration(json, 'valueDuration', TFhirDuration(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'valueDateTime', TFhirDateTime(elem.value), false);
    ComposeDateTimeProps(json, 'valueDateTime', TFhirDateTime(elem.value), false);
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseDataRequirementSort(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDataRequirementSort(jsn)); {2}
end;

function TFHIRJsonParser.ParseDataRequirementSort(jsn : TJsonObject) : TFhirDataRequirementSort;
begin
  result := TFhirDataRequirementSort.create;
  try
    ParseDataRequirementSortProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseDataRequirementSortProperties(jsn : TJsonObject; result : TFhirDataRequirementSort);
begin
    ParseElementProperties(jsn, result);
    if jsn.has('path') or jsn.has('_path') then
        result.pathElement := parseString(jsn.node['path'], jsn.vObj['_path']);{q}
    if jsn.has('direction') or jsn.has('_direction')  then
      result.directionElement := parseEnum(jsn.path+'/direction', jsn.node['direction'], jsn.vObj['_direction'], CODES_TFhirSortDirectionEnum, SYSTEMS_TFhirSortDirectionEnum);
end;

procedure TFHIRJsonComposer.ComposeDataRequirementSort(json : TJSONWriter; name : string; elem : TFhirDataRequirementSort; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElementProperties(json, elem);
  ComposeStringValue(json, 'path', elem.pathElement, false);
  ComposeStringProps(json, 'path', elem.pathElement, false);
  ComposeEnumValue(json, 'direction', elem.DirectionElement, CODES_TFhirSortDirectionEnum, false);
  ComposeEnumProps(json, 'direction', elem.DirectionElement, CODES_TFhirSortDirectionEnum, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseDataRequirement(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDataRequirement(jsn)); {2}
end;

function TFHIRJsonParser.ParseDataRequirement(jsn : TJsonObject) : TFhirDataRequirement;
begin
  result := TFhirDataRequirement.create;
  try
    ParseDataRequirementProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseDataRequirementProperties(jsn : TJsonObject; result : TFhirDataRequirement);
begin
    ParseElementProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn.node['type'], jsn.vObj['_type'], CODES_TFhirAllTypesEnum, SYSTEMS_TFhirAllTypesEnum);
      if jsn.has('profile') or jsn.has('_profile') then
      iteratePrimitiveArray(jsn.vArr['profile'], jsn.vArr['_profile'], result.profileList, parseCanonical);
    if jsn.has('subjectCodeableConcept') {a4} then
      result.subject := ParseCodeableConcept(jsn.vObj['subjectCodeableConcept']);
    if jsn.has('subjectReference') {a3} then
      result.subject := ParseReference(jsn.vObj['subjectReference']);
      if jsn.has('mustSupport') or jsn.has('_mustSupport') then
      iteratePrimitiveArray(jsn.vArr['mustSupport'], jsn.vArr['_mustSupport'], result.mustSupportList, parseString);
    if jsn.has('codeFilter') then
      iterateArray(jsn.vArr['codeFilter'], result.codeFilterList, parseDataRequirementCodeFilter);
    if jsn.has('dateFilter') then
      iterateArray(jsn.vArr['dateFilter'], result.dateFilterList, parseDataRequirementDateFilter);
    if jsn.has('limit') or jsn.has('_limit') then
        result.limitElement := parsePositiveInt(jsn.node['limit'], jsn.vObj['_limit']);{q}
    if jsn.has('sort') then
      iterateArray(jsn.vArr['sort'], result.sortList, parseDataRequirementSort);
end;

procedure TFHIRJsonComposer.ComposeDataRequirement(json : TJSONWriter; name : string; elem : TFhirDataRequirement; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElement(json, '', elem, true);
  ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirAllTypesEnum, false);
  ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirAllTypesEnum, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.profileList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.profileList.Count - 1 do
    begin
      ext := ext or ((elem.profileList[i].id <> '') or (elem.profileList[i].hasExtensionList) {no-comments or (elem.profileList[i].hasComments)});
      val := val or (elem.profileList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('profile');
      for i := 0 to elem.profileList.Count - 1 do
        ComposeCanonicalValue(json, '',elem.profileList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_profile');
      for i := 0 to elem.profileList.Count - 1 do
        ComposeCanonicalProps(json, '',elem.profileList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.subject is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'subjectCodeableConcept', TFhirCodeableConcept(elem.subject)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.subject is TFhirReference) then
    ComposeReference(json, 'subjectReference', TFhirReference(elem.subject));
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.mustSupportList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.mustSupportList.Count - 1 do
    begin
      ext := ext or ((elem.mustSupportList[i].id <> '') or (elem.mustSupportList[i].hasExtensionList) {no-comments or (elem.mustSupportList[i].hasComments)});
      val := val or (elem.mustSupportList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('mustSupport');
      for i := 0 to elem.mustSupportList.Count - 1 do
        ComposeStringValue(json, '',elem.mustSupportList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_mustSupport');
      for i := 0 to elem.mustSupportList.Count - 1 do
        ComposeStringProps(json, '',elem.mustSupportList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.codeFilterList.Count > 0) then
  begin
    json.valueArray('codeFilter');
    for i := 0 to elem.codeFilterList.Count - 1 do
      ComposeDataRequirementCodeFilter(json, '', elem.codeFilterList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.dateFilterList.Count > 0) then
  begin
    json.valueArray('dateFilter');
    for i := 0 to elem.dateFilterList.Count - 1 do
      ComposeDataRequirementDateFilter(json, '', elem.dateFilterList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposePositiveIntValue(json, 'limit', elem.limitElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposePositiveIntProps(json, 'limit', elem.limitElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.sortList.Count > 0) then
  begin
    json.valueArray('sort');
    for i := 0 to elem.sortList.Count - 1 do
      ComposeDataRequirementSort(json, '', elem.sortList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseDosageDoseAndRate(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDosageDoseAndRate(jsn)); {2}
end;

function TFHIRJsonParser.ParseDosageDoseAndRate(jsn : TJsonObject) : TFhirDosageDoseAndRate;
begin
  result := TFhirDosageDoseAndRate.create;
  try
    ParseDosageDoseAndRateProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseDosageDoseAndRateProperties(jsn : TJsonObject; result : TFhirDosageDoseAndRate);
begin
    ParseElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('doseRange') {a4} then
      result.dose := ParseRange(jsn.vObj['doseRange']);
    if jsn.has('doseQuantity') {a4} then
      result.dose := ParseQuantity(jsn.vObj['doseQuantity']);
    if jsn.has('rateRatio') {a4} then
      result.rate := ParseRatio(jsn.vObj['rateRatio']);
    if jsn.has('rateRange') {a4} then
      result.rate := ParseRange(jsn.vObj['rateRange']);
    if jsn.has('rateQuantity') {a4} then
      result.rate := ParseQuantity(jsn.vObj['rateQuantity']);
end;

procedure TFHIRJsonComposer.ComposeDosageDoseAndRate(json : TJSONWriter; name : string; elem : TFhirDosageDoseAndRate; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.dose is TFhirRange) then 
    ComposeRange(json, 'doseRange', TFhirRange(elem.dose)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.dose is TFhirQuantity) then 
    ComposeQuantity(json, 'doseQuantity', TFhirQuantity(elem.dose)) ;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.rate is TFhirRatio) then 
    ComposeRatio(json, 'rateRatio', TFhirRatio(elem.rate)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.rate is TFhirRange) then 
    ComposeRange(json, 'rateRange', TFhirRange(elem.rate)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.rate is TFhirQuantity) then 
    ComposeQuantity(json, 'rateQuantity', TFhirQuantity(elem.rate)) ;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseDosage(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDosage(jsn)); {2}
end;

function TFHIRJsonParser.ParseDosage(jsn : TJsonObject) : TFhirDosage;
begin
  result := TFhirDosage.create;
  try
    ParseDosageProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseDosageProperties(jsn : TJsonObject; result : TFhirDosage);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('sequence') or jsn.has('_sequence') then
        result.sequenceElement := parseInteger(jsn.node['sequence'], jsn.vObj['_sequence']);{q}
    if jsn.has('text') or jsn.has('_text') then
        result.textElement := parseString(jsn.node['text'], jsn.vObj['_text']);{q}
    if jsn.has('additionalInstruction') then
      iterateArray(jsn.vArr['additionalInstruction'], result.additionalInstructionList, parseCodeableConcept);
    if jsn.has('patientInstruction') or jsn.has('_patientInstruction') then
        result.patientInstructionElement := parseString(jsn.node['patientInstruction'], jsn.vObj['_patientInstruction']);{q}
    if jsn.has('timing') then
        result.timing := ParseTiming(jsn.vObj['timing']);{q3}
    if jsn.has('asNeededCodeableConcept') {a4} then
      result.asNeeded := ParseCodeableConcept(jsn.vObj['asNeededCodeableConcept']);
    if jsn.has('asNeededBoolean') or jsn.has('_asNeededBoolean') then
      result.asNeeded := parseBoolean(jsn.node['asNeededBoolean'], jsn.vObj['_asNeededBoolean']);
    if jsn.has('site') then
        result.site := ParseCodeableConcept(jsn.vObj['site']);{q3}
    if jsn.has('route') then
        result.route := ParseCodeableConcept(jsn.vObj['route']);{q3}
    if jsn.has('method') then
        result.method := ParseCodeableConcept(jsn.vObj['method']);{q3}
    if jsn.has('doseAndRate') then
      iterateArray(jsn.vArr['doseAndRate'], result.doseAndRateList, parseDosageDoseAndRate);
    if jsn.has('maxDosePerPeriod') then
        result.maxDosePerPeriod := ParseRatio(jsn.vObj['maxDosePerPeriod']);{q3}
    if jsn.has('maxDosePerAdministration') then
        result.maxDosePerAdministration := ParseQuantity(jsn.vObj['maxDosePerAdministration']);{q3}
    if jsn.has('maxDosePerLifetime') then
        result.maxDosePerLifetime := ParseQuantity(jsn.vObj['maxDosePerLifetime']);{q3}
end;

procedure TFHIRJsonComposer.ComposeDosage(json : TJSONWriter; name : string; elem : TFhirDosage; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneType(json, '', elem, true);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeIntegerValue(json, 'sequence', elem.sequenceElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeIntegerProps(json, 'sequence', elem.sequenceElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.additionalInstructionList.Count > 0) then
  begin
    json.valueArray('additionalInstruction');
    for i := 0 to elem.additionalInstructionList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.additionalInstructionList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'patientInstruction', elem.patientInstructionElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'patientInstruction', elem.patientInstructionElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeTiming(json, 'timing', elem.timing); {a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.asNeeded is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'asNeededCodeableConcept', TFhirCodeableConcept(elem.asNeeded)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.asNeeded is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'asNeededBoolean', TFhirBoolean(elem.asNeeded), false);
    ComposeBooleanProps(json, 'asNeededBoolean', TFhirBoolean(elem.asNeeded), false);
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeableConcept(json, 'site', elem.site); {a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeableConcept(json, 'route', elem.route); {a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeableConcept(json, 'method', elem.method); {a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.doseAndRateList.Count > 0) then
  begin
    json.valueArray('doseAndRate');
    for i := 0 to elem.doseAndRateList.Count - 1 do
      ComposeDosageDoseAndRate(json, '', elem.doseAndRateList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeRatio(json, 'maxDosePerPeriod', elem.maxDosePerPeriod); {a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeQuantity(json, 'maxDosePerAdministration', elem.maxDosePerAdministration); {a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeQuantity(json, 'maxDosePerLifetime', elem.maxDosePerLifetime); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseMoney(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMoney(jsn)); {2}
end;

function TFHIRJsonParser.ParseMoney(jsn : TJsonObject) : TFhirMoney;
begin
  result := TFhirMoney.create;
  try
    ParseMoneyProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMoneyProperties(jsn : TJsonObject; result : TFhirMoney);
begin
    ParseElementProperties(jsn, result);
    if jsn.has('value') or jsn.has('_value') then
        result.valueElement := parseDecimal(jsn.node['value'], jsn.vObj['_value']);{q}
    if jsn.has('currency') or jsn.has('_currency') then
        result.currencyElement := parseCode(jsn.node['currency'], jsn.vObj['_currency']);{q}
end;

procedure TFHIRJsonComposer.ComposeMoney(json : TJSONWriter; name : string; elem : TFhirMoney; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElement(json, '', elem, true);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDecimalValue(json, 'value', elem.valueElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDecimalProps(json, 'value', elem.valueElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeValue(json, 'currency', elem.currencyElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeProps(json, 'currency', elem.currencyElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseMarketingStatus(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMarketingStatus(jsn)); {2}
end;

function TFHIRJsonParser.ParseMarketingStatus(jsn : TJsonObject) : TFhirMarketingStatus;
begin
  result := TFhirMarketingStatus.create;
  try
    ParseMarketingStatusProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMarketingStatusProperties(jsn : TJsonObject; result : TFhirMarketingStatus);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('country') then
        result.country := ParseCodeableConcept(jsn.vObj['country']);{q3}
    if jsn.has('jurisdiction') then
        result.jurisdiction := ParseCodeableConcept(jsn.vObj['jurisdiction']);{q3}
    if jsn.has('status') then
        result.status := ParseCodeableConcept(jsn.vObj['status']);{q3}
    if jsn.has('dateRange') then
        result.dateRange := ParsePeriod(jsn.vObj['dateRange']);{q3}
    if jsn.has('restoreDate') or jsn.has('_restoreDate') then
        result.restoreDateElement := parseDateTime(jsn.node['restoreDate'], jsn.vObj['_restoreDate']);{q}
end;

procedure TFHIRJsonComposer.ComposeMarketingStatus(json : TJSONWriter; name : string; elem : TFhirMarketingStatus; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneType(json, '', elem, true);
  ComposeCodeableConcept(json, 'country', elem.country); {a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeableConcept(json, 'jurisdiction', elem.jurisdiction); {a}
  ComposeCodeableConcept(json, 'status', elem.status); {a}
  ComposePeriod(json, 'dateRange', elem.dateRange); {a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDateTimeValue(json, 'restoreDate', elem.restoreDateElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDateTimeProps(json, 'restoreDate', elem.restoreDateElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseIdentifier(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseIdentifier(jsn)); {2}
end;

function TFHIRJsonParser.ParseIdentifier(jsn : TJsonObject) : TFhirIdentifier;
begin
  result := TFhirIdentifier.create;
  try
    ParseIdentifierProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseIdentifierProperties(jsn : TJsonObject; result : TFhirIdentifier);
begin
    ParseElementProperties(jsn, result);
    if jsn.has('use') or jsn.has('_use')  then
      result.useElement := parseEnum(jsn.path+'/use', jsn.node['use'], jsn.vObj['_use'], CODES_TFhirIdentifierUseEnum, SYSTEMS_TFhirIdentifierUseEnum);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('system') or jsn.has('_system') then
        result.systemElement := parseUri(jsn.node['system'], jsn.vObj['_system']);{q}
    if jsn.has('value') or jsn.has('_value') then
        result.valueElement := parseString(jsn.node['value'], jsn.vObj['_value']);{q}
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q3}
    if jsn.has('assigner') then
        result.assigner := ParseReference{TFhirOrganization}(jsn.vObj['assigner']);{q3}
end;

procedure TFHIRJsonComposer.ComposeIdentifier(json : TJSONWriter; name : string; elem : TFhirIdentifier; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElement(json, '', elem, true);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeEnumValue(json, 'use', elem.UseElement, CODES_TFhirIdentifierUseEnum, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeEnumProps(json, 'use', elem.UseElement, CODES_TFhirIdentifierUseEnum, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUriValue(json, 'system', elem.systemElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUriProps(json, 'system', elem.systemElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'value', elem.valueElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'value', elem.valueElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposePeriod(json, 'period', elem.period); {a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeReference{TFhirOrganization}(json, 'assigner', elem.assigner); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseSubstanceAmountReferenceRange(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSubstanceAmountReferenceRange(jsn)); {2}
end;

function TFHIRJsonParser.ParseSubstanceAmountReferenceRange(jsn : TJsonObject) : TFhirSubstanceAmountReferenceRange;
begin
  result := TFhirSubstanceAmountReferenceRange.create;
  try
    ParseSubstanceAmountReferenceRangeProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSubstanceAmountReferenceRangeProperties(jsn : TJsonObject; result : TFhirSubstanceAmountReferenceRange);
begin
    ParseElementProperties(jsn, result);
    if jsn.has('lowLimit') then
        result.lowLimit := ParseQuantity(jsn.vObj['lowLimit']);{q3}
    if jsn.has('highLimit') then
        result.highLimit := ParseQuantity(jsn.vObj['highLimit']);{q3}
end;

procedure TFHIRJsonComposer.ComposeSubstanceAmountReferenceRange(json : TJSONWriter; name : string; elem : TFhirSubstanceAmountReferenceRange; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(json, 'lowLimit', elem.lowLimit); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(json, 'highLimit', elem.highLimit); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseSubstanceAmount(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSubstanceAmount(jsn)); {2}
end;

function TFHIRJsonParser.ParseSubstanceAmount(jsn : TJsonObject) : TFhirSubstanceAmount;
begin
  result := TFhirSubstanceAmount.create;
  try
    ParseSubstanceAmountProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSubstanceAmountProperties(jsn : TJsonObject; result : TFhirSubstanceAmount);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('amountQuantity') {a4} then
      result.amount := ParseQuantity(jsn.vObj['amountQuantity']);
    if jsn.has('amountRange') {a4} then
      result.amount := ParseRange(jsn.vObj['amountRange']);
    if jsn.has('amountString') or jsn.has('_amountString') then
      result.amount := parseString(jsn.node['amountString'], jsn.vObj['_amountString']);
    if jsn.has('amountType') then
        result.amountType := ParseCodeableConcept(jsn.vObj['amountType']);{q3}
    if jsn.has('amountText') or jsn.has('_amountText') then
        result.amountTextElement := parseString(jsn.node['amountText'], jsn.vObj['_amountText']);{q}
    if jsn.has('referenceRange') then
        result.referenceRange := ParseSubstanceAmountReferenceRange(jsn.vObj['referenceRange']);{q3}
end;

procedure TFHIRJsonComposer.ComposeSubstanceAmount(json : TJSONWriter; name : string; elem : TFhirSubstanceAmount; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneType(json, '', elem, true);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.amount is TFhirQuantity) then 
    ComposeQuantity(json, 'amountQuantity', TFhirQuantity(elem.amount)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.amount is TFhirRange) then 
    ComposeRange(json, 'amountRange', TFhirRange(elem.amount)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.amount is TFhirString) then 
  begin
    ComposeStringValue(json, 'amountString', TFhirString(elem.amount), false);
    ComposeStringProps(json, 'amountString', TFhirString(elem.amount), false);
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeableConcept(json, 'amountType', elem.amountType); {a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'amountText', elem.amountTextElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'amountText', elem.amountTextElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeSubstanceAmountReferenceRange(json, 'referenceRange', elem.referenceRange); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseCoding(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCoding(jsn)); {2}
end;

function TFHIRJsonParser.ParseCoding(jsn : TJsonObject) : TFhirCoding;
begin
  result := TFhirCoding.create;
  try
    ParseCodingProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCodingProperties(jsn : TJsonObject; result : TFhirCoding);
begin
    ParseElementProperties(jsn, result);
    if jsn.has('system') or jsn.has('_system') then
        result.systemElement := parseUri(jsn.node['system'], jsn.vObj['_system']);{q}
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := parseString(jsn.node['version'], jsn.vObj['_version']);{q}
    if jsn.has('code') or jsn.has('_code') then
        result.codeElement := parseCode(jsn.node['code'], jsn.vObj['_code']);{q}
    if jsn.has('display') or jsn.has('_display') then
        result.displayElement := parseString(jsn.node['display'], jsn.vObj['_display']);{q}
    if jsn.has('userSelected') or jsn.has('_userSelected') then
        result.userSelectedElement := parseBoolean(jsn.node['userSelected'], jsn.vObj['_userSelected']);{q}
end;

procedure TFHIRJsonComposer.ComposeCoding(json : TJSONWriter; name : string; elem : TFhirCoding; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElement(json, '', elem, true);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUriValue(json, 'system', elem.systemElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUriProps(json, 'system', elem.systemElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeValue(json, 'code', elem.codeElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeProps(json, 'code', elem.codeElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'display', elem.displayElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'display', elem.displayElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBooleanValue(json, 'userSelected', elem.userSelectedElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBooleanProps(json, 'userSelected', elem.userSelectedElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseSampledData(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSampledData(jsn)); {2}
end;

function TFHIRJsonParser.ParseSampledData(jsn : TJsonObject) : TFhirSampledData;
begin
  result := TFhirSampledData.create;
  try
    ParseSampledDataProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSampledDataProperties(jsn : TJsonObject; result : TFhirSampledData);
begin
    ParseElementProperties(jsn, result);
    if jsn.has('origin') then
        result.origin := ParseQuantity(jsn.vObj['origin']);{q3}
    if jsn.has('period') or jsn.has('_period') then
        result.periodElement := parseDecimal(jsn.node['period'], jsn.vObj['_period']);{q}
    if jsn.has('factor') or jsn.has('_factor') then
        result.factorElement := parseDecimal(jsn.node['factor'], jsn.vObj['_factor']);{q}
    if jsn.has('lowerLimit') or jsn.has('_lowerLimit') then
        result.lowerLimitElement := parseDecimal(jsn.node['lowerLimit'], jsn.vObj['_lowerLimit']);{q}
    if jsn.has('upperLimit') or jsn.has('_upperLimit') then
        result.upperLimitElement := parseDecimal(jsn.node['upperLimit'], jsn.vObj['_upperLimit']);{q}
    if jsn.has('dimensions') or jsn.has('_dimensions') then
        result.dimensionsElement := parsePositiveInt(jsn.node['dimensions'], jsn.vObj['_dimensions']);{q}
    if jsn.has('data') or jsn.has('_data') then
        result.dataElement := parseString(jsn.node['data'], jsn.vObj['_data']);{q}
end;

procedure TFHIRJsonComposer.ComposeSampledData(json : TJSONWriter; name : string; elem : TFhirSampledData; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElement(json, '', elem, true);
  ComposeQuantity(json, 'origin', elem.origin); {a}
  ComposeDecimalValue(json, 'period', elem.periodElement, false);
  ComposeDecimalProps(json, 'period', elem.periodElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDecimalValue(json, 'factor', elem.factorElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDecimalProps(json, 'factor', elem.factorElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDecimalValue(json, 'lowerLimit', elem.lowerLimitElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDecimalProps(json, 'lowerLimit', elem.lowerLimitElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDecimalValue(json, 'upperLimit', elem.upperLimitElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDecimalProps(json, 'upperLimit', elem.upperLimitElement, false);
  ComposePositiveIntValue(json, 'dimensions', elem.dimensionsElement, false);
  ComposePositiveIntProps(json, 'dimensions', elem.dimensionsElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'data', elem.dataElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'data', elem.dataElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParsePopulation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePopulation(jsn)); {2}
end;

function TFHIRJsonParser.ParsePopulation(jsn : TJsonObject) : TFhirPopulation;
begin
  result := TFhirPopulation.create;
  try
    ParsePopulationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParsePopulationProperties(jsn : TJsonObject; result : TFhirPopulation);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('ageRange') {a4} then
      result.age := ParseRange(jsn.vObj['ageRange']);
    if jsn.has('ageCodeableConcept') {a4} then
      result.age := ParseCodeableConcept(jsn.vObj['ageCodeableConcept']);
    if jsn.has('gender') then
        result.gender := ParseCodeableConcept(jsn.vObj['gender']);{q3}
    if jsn.has('race') then
        result.race := ParseCodeableConcept(jsn.vObj['race']);{q3}
    if jsn.has('physiologicalCondition') then
        result.physiologicalCondition := ParseCodeableConcept(jsn.vObj['physiologicalCondition']);{q3}
end;

procedure TFHIRJsonComposer.ComposePopulation(json : TJSONWriter; name : string; elem : TFhirPopulation; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneType(json, '', elem, true);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.age is TFhirRange) then 
    ComposeRange(json, 'ageRange', TFhirRange(elem.age)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.age is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'ageCodeableConcept', TFhirCodeableConcept(elem.age)) ;
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeableConcept(json, 'gender', elem.gender); {a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeableConcept(json, 'race', elem.race); {a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeableConcept(json, 'physiologicalCondition', elem.physiologicalCondition); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseRatio(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseRatio(jsn)); {2}
end;

function TFHIRJsonParser.ParseRatio(jsn : TJsonObject) : TFhirRatio;
begin
  result := TFhirRatio.create;
  try
    ParseRatioProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseRatioProperties(jsn : TJsonObject; result : TFhirRatio);
begin
    ParseElementProperties(jsn, result);
    if jsn.has('numerator') then
        result.numerator := ParseQuantity(jsn.vObj['numerator']);{q3}
    if jsn.has('denominator') then
        result.denominator := ParseQuantity(jsn.vObj['denominator']);{q3}
end;

procedure TFHIRJsonComposer.ComposeRatio(json : TJSONWriter; name : string; elem : TFhirRatio; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElement(json, '', elem, true);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeQuantity(json, 'numerator', elem.numerator); {a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeQuantity(json, 'denominator', elem.denominator); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseReference(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseReference(jsn)); {2}
end;

function TFHIRJsonParser.ParseReference(jsn : TJsonObject) : TFhirReference;
begin
  result := TFhirReference.create;
  try
    ParseReferenceProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseReferenceProperties(jsn : TJsonObject; result : TFhirReference);
begin
    ParseElementProperties(jsn, result);
    if jsn.has('reference') or jsn.has('_reference') then
        result.referenceElement := parseString(jsn.node['reference'], jsn.vObj['_reference']);{q}
    if jsn.has('type') or jsn.has('_type') then
        result.type_Element := parseUri(jsn.node['type'], jsn.vObj['_type']);{q}
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q3}
    if jsn.has('display') or jsn.has('_display') then
        result.displayElement := parseString(jsn.node['display'], jsn.vObj['_display']);{q}
end;

procedure TFHIRJsonComposer.ComposeReference(json : TJSONWriter; name : string; elem : TFhirReference; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElement(json, '', elem, true);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'reference', elem.referenceElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'reference', elem.referenceElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUriValue(json, 'type', elem.type_Element, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUriProps(json, 'type', elem.type_Element, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'display', elem.displayElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'display', elem.displayElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseTriggerDefinition(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTriggerDefinition(jsn)); {2}
end;

function TFHIRJsonParser.ParseTriggerDefinition(jsn : TJsonObject) : TFhirTriggerDefinition;
begin
  result := TFhirTriggerDefinition.create;
  try
    ParseTriggerDefinitionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseTriggerDefinitionProperties(jsn : TJsonObject; result : TFhirTriggerDefinition);
begin
    ParseElementProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn.node['type'], jsn.vObj['_type'], CODES_TFhirTriggerTypeEnum, SYSTEMS_TFhirTriggerTypeEnum);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('timingTiming') {a4} then
      result.timing := ParseTiming(jsn.vObj['timingTiming']);
    if jsn.has('timingReference') {a3} then
      result.timing := ParseReference(jsn.vObj['timingReference']);
    if jsn.has('timingDate') or jsn.has('_timingDate') then
      result.timing := parseDate(jsn.node['timingDate'], jsn.vObj['_timingDate']);
    if jsn.has('timingDateTime') or jsn.has('_timingDateTime') then
      result.timing := parseDateTime(jsn.node['timingDateTime'], jsn.vObj['_timingDateTime']);
    if jsn.has('data') then
      iterateArray(jsn.vArr['data'], result.dataList, parseDataRequirement);
    if jsn.has('condition') then
        result.condition := ParseExpression(jsn.vObj['condition']);{q3}
end;

procedure TFHIRJsonComposer.ComposeTriggerDefinition(json : TJSONWriter; name : string; elem : TFhirTriggerDefinition; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElement(json, '', elem, true);
  ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirTriggerTypeEnum, false);
  ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirTriggerTypeEnum, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.timing is TFhirTiming) then 
    ComposeTiming(json, 'timingTiming', TFhirTiming(elem.timing)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.timing is TFhirReference) then
    ComposeReference(json, 'timingReference', TFhirReference(elem.timing))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.timing is TFhirDate) then 
  begin
    ComposeDateValue(json, 'timingDate', TFhirDate(elem.timing), false);
    ComposeDateProps(json, 'timingDate', TFhirDate(elem.timing), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.timing is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'timingDateTime', TFhirDateTime(elem.timing), false);
    ComposeDateTimeProps(json, 'timingDateTime', TFhirDateTime(elem.timing), false);
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.dataList.Count > 0) then
  begin
    json.valueArray('data');
    for i := 0 to elem.dataList.Count - 1 do
      ComposeDataRequirement(json, '', elem.dataList[i]); {z - DataRequirement}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeExpression(json, 'condition', elem.condition); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParsePeriod(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePeriod(jsn)); {2}
end;

function TFHIRJsonParser.ParsePeriod(jsn : TJsonObject) : TFhirPeriod;
begin
  result := TFhirPeriod.create;
  try
    ParsePeriodProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParsePeriodProperties(jsn : TJsonObject; result : TFhirPeriod);
begin
    ParseElementProperties(jsn, result);
    if jsn.has('start') or jsn.has('_start') then
        result.startElement := parseDateTime(jsn.node['start'], jsn.vObj['_start']);{q}
    if jsn.has('end') or jsn.has('_end') then
        result.end_Element := parseDateTime(jsn.node['end'], jsn.vObj['_end']);{q}
end;

procedure TFHIRJsonComposer.ComposePeriod(json : TJSONWriter; name : string; elem : TFhirPeriod; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElement(json, '', elem, true);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDateTimeValue(json, 'start', elem.startElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDateTimeProps(json, 'start', elem.startElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDateTimeValue(json, 'end', elem.end_Element, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDateTimeProps(json, 'end', elem.end_Element, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseQuantity(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseQuantity(jsn)); {2}
end;

function TFHIRJsonParser.ParseQuantity(jsn : TJsonObject) : TFhirQuantity;
begin
  result := TFhirQuantity.create;
  try
    ParseQuantityProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseQuantityProperties(jsn : TJsonObject; result : TFhirQuantity);
begin
    ParseElementProperties(jsn, result);
    if jsn.has('value') or jsn.has('_value') then
        result.valueElement := parseDecimal(jsn.node['value'], jsn.vObj['_value']);{q}
    if jsn.has('comparator') or jsn.has('_comparator')  then
      result.comparatorElement := parseEnum(jsn.path+'/comparator', jsn.node['comparator'], jsn.vObj['_comparator'], CODES_TFhirQuantityComparatorEnum, SYSTEMS_TFhirQuantityComparatorEnum);
    if jsn.has('unit') or jsn.has('_unit') then
        result.unit_Element := parseString(jsn.node['unit'], jsn.vObj['_unit']);{q}
    if jsn.has('system') or jsn.has('_system') then
        result.systemElement := parseUri(jsn.node['system'], jsn.vObj['_system']);{q}
    if jsn.has('code') or jsn.has('_code') then
        result.codeElement := parseCode(jsn.node['code'], jsn.vObj['_code']);{q}
end;

procedure TFHIRJsonComposer.ComposeQuantity(json : TJSONWriter; name : string; elem : TFhirQuantity; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElement(json, '', elem, true);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDecimalValue(json, 'value', elem.valueElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDecimalProps(json, 'value', elem.valueElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeEnumValue(json, 'comparator', elem.ComparatorElement, CODES_TFhirQuantityComparatorEnum, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeEnumProps(json, 'comparator', elem.ComparatorElement, CODES_TFhirQuantityComparatorEnum, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'unit', elem.unit_Element, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'unit', elem.unit_Element, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUriValue(json, 'system', elem.systemElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUriProps(json, 'system', elem.systemElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeValue(json, 'code', elem.codeElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeProps(json, 'code', elem.codeElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseRange(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseRange(jsn)); {2}
end;

function TFHIRJsonParser.ParseRange(jsn : TJsonObject) : TFhirRange;
begin
  result := TFhirRange.create;
  try
    ParseRangeProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseRangeProperties(jsn : TJsonObject; result : TFhirRange);
begin
    ParseElementProperties(jsn, result);
    if jsn.has('low') then
        result.low := ParseQuantity(jsn.vObj['low']);{q3}
    if jsn.has('high') then
        result.high := ParseQuantity(jsn.vObj['high']);{q3}
end;

procedure TFHIRJsonComposer.ComposeRange(json : TJSONWriter; name : string; elem : TFhirRange; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElement(json, '', elem, true);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeQuantity(json, 'low', elem.low); {a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeQuantity(json, 'high', elem.high); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseRelatedArtifact(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseRelatedArtifact(jsn)); {2}
end;

function TFHIRJsonParser.ParseRelatedArtifact(jsn : TJsonObject) : TFhirRelatedArtifact;
begin
  result := TFhirRelatedArtifact.create;
  try
    ParseRelatedArtifactProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseRelatedArtifactProperties(jsn : TJsonObject; result : TFhirRelatedArtifact);
begin
    ParseElementProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn.node['type'], jsn.vObj['_type'], CODES_TFhirRelatedArtifactTypeEnum, SYSTEMS_TFhirRelatedArtifactTypeEnum);
    if jsn.has('label') or jsn.has('_label') then
        result.label_Element := parseString(jsn.node['label'], jsn.vObj['_label']);{q}
    if jsn.has('display') or jsn.has('_display') then
        result.displayElement := parseString(jsn.node['display'], jsn.vObj['_display']);{q}
    if jsn.has('citation') or jsn.has('_citation') then
        result.citationElement := parseMarkdown(jsn.node['citation'], jsn.vObj['_citation']);{q}
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := parseUrl(jsn.node['url'], jsn.vObj['_url']);{q}
    if jsn.has('document') then
        result.document := ParseAttachment(jsn.vObj['document']);{q3}
    if jsn.has('resource') or jsn.has('_resource') then
        result.resourceElement := parseCanonical(jsn.node['resource'], jsn.vObj['_resource']);{q}
end;

procedure TFHIRJsonComposer.ComposeRelatedArtifact(json : TJSONWriter; name : string; elem : TFhirRelatedArtifact; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElement(json, '', elem, true);
  ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirRelatedArtifactTypeEnum, false);
  ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirRelatedArtifactTypeEnum, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'label', elem.label_Element, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'label', elem.label_Element, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'display', elem.displayElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'display', elem.displayElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeMarkdownValue(json, 'citation', elem.citationElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeMarkdownProps(json, 'citation', elem.citationElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUrlValue(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUrlProps(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeAttachment(json, 'document', elem.document); {a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCanonicalValue(json, 'resource', elem.resourceElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCanonicalProps(json, 'resource', elem.resourceElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseAnnotation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAnnotation(jsn)); {2}
end;

function TFHIRJsonParser.ParseAnnotation(jsn : TJsonObject) : TFhirAnnotation;
begin
  result := TFhirAnnotation.create;
  try
    ParseAnnotationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseAnnotationProperties(jsn : TJsonObject; result : TFhirAnnotation);
begin
    ParseElementProperties(jsn, result);
    if jsn.has('authorReference') {a3} then
      result.author := ParseReference(jsn.vObj['authorReference']);
    if jsn.has('authorString') or jsn.has('_authorString') then
      result.author := parseString(jsn.node['authorString'], jsn.vObj['_authorString']);
    if jsn.has('time') or jsn.has('_time') then
        result.timeElement := parseDateTime(jsn.node['time'], jsn.vObj['_time']);{q}
    if jsn.has('text') or jsn.has('_text') then
        result.textElement := parseMarkdown(jsn.node['text'], jsn.vObj['_text']);{q}
end;

procedure TFHIRJsonComposer.ComposeAnnotation(json : TJSONWriter; name : string; elem : TFhirAnnotation; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElement(json, '', elem, true);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.author is TFhirReference) then
    ComposeReference(json, 'authorReference', TFhirReference(elem.author))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.author is TFhirString) then 
  begin
    ComposeStringValue(json, 'authorString', TFhirString(elem.author), false);
    ComposeStringProps(json, 'authorString', TFhirString(elem.author), false);
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDateTimeValue(json, 'time', elem.timeElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDateTimeProps(json, 'time', elem.timeElement, false);
  ComposeMarkdownValue(json, 'text', elem.textElement, false);
  ComposeMarkdownProps(json, 'text', elem.textElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseProductShelfLife(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProductShelfLife(jsn)); {2}
end;

function TFHIRJsonParser.ParseProductShelfLife(jsn : TJsonObject) : TFhirProductShelfLife;
begin
  result := TFhirProductShelfLife.create;
  try
    ParseProductShelfLifeProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseProductShelfLifeProperties(jsn : TJsonObject; result : TFhirProductShelfLife);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q3}
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('period') then
        result.period := ParseQuantity(jsn.vObj['period']);{q3}
    if jsn.has('specialPrecautionsForStorage') then
      iterateArray(jsn.vArr['specialPrecautionsForStorage'], result.specialPrecautionsForStorageList, parseCodeableConcept);
end;

procedure TFHIRJsonComposer.ComposeProductShelfLife(json : TJSONWriter; name : string; elem : TFhirProductShelfLife; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneType(json, '', elem, true);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  ComposeQuantity(json, 'period', elem.period); {a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.specialPrecautionsForStorageList.Count > 0) then
  begin
    json.valueArray('specialPrecautionsForStorage');
    for i := 0 to elem.specialPrecautionsForStorageList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.specialPrecautionsForStorageList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseContactDetail(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseContactDetail(jsn)); {2}
end;

function TFHIRJsonParser.ParseContactDetail(jsn : TJsonObject) : TFhirContactDetail;
begin
  result := TFhirContactDetail.create;
  try
    ParseContactDetailProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseContactDetailProperties(jsn : TJsonObject; result : TFhirContactDetail);
begin
    ParseElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
end;

procedure TFHIRJsonComposer.ComposeContactDetail(json : TJSONWriter; name : string; elem : TFhirContactDetail; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElement(json, '', elem, true);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.telecomList.Count > 0) then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '', elem.telecomList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseExpression(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseExpression(jsn)); {2}
end;

function TFHIRJsonParser.ParseExpression(jsn : TJsonObject) : TFhirExpression;
begin
  result := TFhirExpression.create;
  try
    ParseExpressionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseExpressionProperties(jsn : TJsonObject; result : TFhirExpression);
begin
    ParseElementProperties(jsn, result);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseId(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('language') or jsn.has('_language') then
        result.languageElement := parseCode(jsn.node['language'], jsn.vObj['_language']);{q}
    if jsn.has('expression') or jsn.has('_expression') then
        result.expressionElement := parseString(jsn.node['expression'], jsn.vObj['_expression']);{q}
    if jsn.has('reference') or jsn.has('_reference') then
        result.referenceElement := parseUri(jsn.node['reference'], jsn.vObj['_reference']);{q}
end;

procedure TFHIRJsonComposer.ComposeExpression(json : TJSONWriter; name : string; elem : TFhirExpression; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElement(json, '', elem, true);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeIdValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeIdProps(json, 'name', elem.nameElement, false);
  ComposeCodeValue(json, 'language', elem.languageElement, false);
  ComposeCodeProps(json, 'language', elem.languageElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'expression', elem.expressionElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'expression', elem.expressionElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUriValue(json, 'reference', elem.referenceElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUriProps(json, 'reference', elem.referenceElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseUsageContext(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseUsageContext(jsn)); {2}
end;

function TFHIRJsonParser.ParseUsageContext(jsn : TJsonObject) : TFhirUsageContext;
begin
  result := TFhirUsageContext.create;
  try
    ParseUsageContextProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseUsageContextProperties(jsn : TJsonObject; result : TFhirUsageContext);
begin
    ParseElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCoding(jsn.vObj['code']);{q3}
    if jsn.has('valueCodeableConcept') {a4} then
      result.value := ParseCodeableConcept(jsn.vObj['valueCodeableConcept']);
    if jsn.has('valueQuantity') {a4} then
      result.value := ParseQuantity(jsn.vObj['valueQuantity']);
    if jsn.has('valueRange') {a4} then
      result.value := ParseRange(jsn.vObj['valueRange']);
    if jsn.has('valueReference') {a3} then
      result.value := ParseReference(jsn.vObj['valueReference']);
end;

procedure TFHIRJsonComposer.ComposeUsageContext(json : TJSONWriter; name : string; elem : TFhirUsageContext; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElement(json, '', elem, true);
  ComposeCoding(json, 'code', elem.code); {a}
  if (elem.value is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'valueCodeableConcept', TFhirCodeableConcept(elem.value)) 
  else if (elem.value is TFhirQuantity) then 
    ComposeQuantity(json, 'valueQuantity', TFhirQuantity(elem.value)) 
  else if (elem.value is TFhirRange) then 
    ComposeRange(json, 'valueRange', TFhirRange(elem.value)) 
  else if (elem.value is TFhirReference) then
    ComposeReference(json, 'valueReference', TFhirReference(elem.value));
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseSignature(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSignature(jsn)); {2}
end;

function TFHIRJsonParser.ParseSignature(jsn : TJsonObject) : TFhirSignature;
begin
  result := TFhirSignature.create;
  try
    ParseSignatureProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSignatureProperties(jsn : TJsonObject; result : TFhirSignature);
begin
    ParseElementProperties(jsn, result);
    if jsn.has('type') then
      iterateArray(jsn.vArr['type'], result.type_List, parseCoding);
    if jsn.has('when') or jsn.has('_when') then
        result.whenElement := parseInstant(jsn.node['when'], jsn.vObj['_when']);{q}
    if jsn.has('who') then
        result.who := ParseReference{TFhirPractitioner}(jsn.vObj['who']);{q3}
    if jsn.has('onBehalfOf') then
        result.onBehalfOf := ParseReference{TFhirPractitioner}(jsn.vObj['onBehalfOf']);{q3}
    if jsn.has('targetFormat') or jsn.has('_targetFormat') then
        result.targetFormatElement := parseCode(jsn.node['targetFormat'], jsn.vObj['_targetFormat']);{q}
    if jsn.has('sigFormat') or jsn.has('_sigFormat') then
        result.sigFormatElement := parseCode(jsn.node['sigFormat'], jsn.vObj['_sigFormat']);{q}
    if jsn.has('data') or jsn.has('_data') then
        result.dataElement := parseBase64Binary(jsn.node['data'], jsn.vObj['_data']);{q}
end;

procedure TFHIRJsonComposer.ComposeSignature(json : TJSONWriter; name : string; elem : TFhirSignature; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElement(json, '', elem, true);
  if (elem.type_List.Count > 0) then
  begin
    json.valueArray('type');
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCoding(json, '', elem.type_List[i]); {z - Coding}
    json.FinishArray;
  end;
  ComposeInstantValue(json, 'when', elem.whenElement, false);
  ComposeInstantProps(json, 'when', elem.whenElement, false);
  ComposeReference{TFhirPractitioner}(json, 'who', elem.who); {a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeReference{TFhirPractitioner}(json, 'onBehalfOf', elem.onBehalfOf); {a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeValue(json, 'targetFormat', elem.targetFormatElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeProps(json, 'targetFormat', elem.targetFormatElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeValue(json, 'sigFormat', elem.sigFormatElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeProps(json, 'sigFormat', elem.sigFormatElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBase64BinaryValue(json, 'data', elem.dataElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBase64BinaryProps(json, 'data', elem.dataElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseProdCharacteristic(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProdCharacteristic(jsn)); {2}
end;

function TFHIRJsonParser.ParseProdCharacteristic(jsn : TJsonObject) : TFhirProdCharacteristic;
begin
  result := TFhirProdCharacteristic.create;
  try
    ParseProdCharacteristicProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseProdCharacteristicProperties(jsn : TJsonObject; result : TFhirProdCharacteristic);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('height') then
        result.height := ParseQuantity(jsn.vObj['height']);{q3}
    if jsn.has('width') then
        result.width := ParseQuantity(jsn.vObj['width']);{q3}
    if jsn.has('depth') then
        result.depth := ParseQuantity(jsn.vObj['depth']);{q3}
    if jsn.has('weight') then
        result.weight := ParseQuantity(jsn.vObj['weight']);{q3}
    if jsn.has('nominalVolume') then
        result.nominalVolume := ParseQuantity(jsn.vObj['nominalVolume']);{q3}
    if jsn.has('externalDiameter') then
        result.externalDiameter := ParseQuantity(jsn.vObj['externalDiameter']);{q3}
    if jsn.has('shape') or jsn.has('_shape') then
        result.shapeElement := parseString(jsn.node['shape'], jsn.vObj['_shape']);{q}
      if jsn.has('color') or jsn.has('_color') then
      iteratePrimitiveArray(jsn.vArr['color'], jsn.vArr['_color'], result.colorList, parseString);
      if jsn.has('imprint') or jsn.has('_imprint') then
      iteratePrimitiveArray(jsn.vArr['imprint'], jsn.vArr['_imprint'], result.imprintList, parseString);
    if jsn.has('image') then
      iterateArray(jsn.vArr['image'], result.imageList, parseAttachment);
    if jsn.has('scoring') then
        result.scoring := ParseCodeableConcept(jsn.vObj['scoring']);{q3}
end;

procedure TFHIRJsonComposer.ComposeProdCharacteristic(json : TJSONWriter; name : string; elem : TFhirProdCharacteristic; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneType(json, '', elem, true);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeQuantity(json, 'height', elem.height); {a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeQuantity(json, 'width', elem.width); {a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeQuantity(json, 'depth', elem.depth); {a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeQuantity(json, 'weight', elem.weight); {a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeQuantity(json, 'nominalVolume', elem.nominalVolume); {a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeQuantity(json, 'externalDiameter', elem.externalDiameter); {a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'shape', elem.shapeElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'shape', elem.shapeElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.colorList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.colorList.Count - 1 do
    begin
      ext := ext or ((elem.colorList[i].id <> '') or (elem.colorList[i].hasExtensionList) {no-comments or (elem.colorList[i].hasComments)});
      val := val or (elem.colorList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('color');
      for i := 0 to elem.colorList.Count - 1 do
        ComposeStringValue(json, '',elem.colorList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_color');
      for i := 0 to elem.colorList.Count - 1 do
        ComposeStringProps(json, '',elem.colorList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.imprintList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.imprintList.Count - 1 do
    begin
      ext := ext or ((elem.imprintList[i].id <> '') or (elem.imprintList[i].hasExtensionList) {no-comments or (elem.imprintList[i].hasComments)});
      val := val or (elem.imprintList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('imprint');
      for i := 0 to elem.imprintList.Count - 1 do
        ComposeStringValue(json, '',elem.imprintList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_imprint');
      for i := 0 to elem.imprintList.Count - 1 do
        ComposeStringProps(json, '',elem.imprintList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.imageList.Count > 0) then
  begin
    json.valueArray('image');
    for i := 0 to elem.imageList.Count - 1 do
      ComposeAttachment(json, '', elem.imageList[i]); {z - Attachment}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeableConcept(json, 'scoring', elem.scoring); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseCodeableConcept(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCodeableConcept(jsn)); {2}
end;

function TFHIRJsonParser.ParseCodeableConcept(jsn : TJsonObject) : TFhirCodeableConcept;
begin
  result := TFhirCodeableConcept.create;
  try
    ParseCodeableConceptProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCodeableConceptProperties(jsn : TJsonObject; result : TFhirCodeableConcept);
begin
    ParseElementProperties(jsn, result);
    if jsn.has('coding') then
      iterateArray(jsn.vArr['coding'], result.codingList, parseCoding);
    if jsn.has('text') or jsn.has('_text') then
        result.textElement := parseString(jsn.node['text'], jsn.vObj['_text']);{q}
end;

procedure TFHIRJsonComposer.ComposeCodeableConcept(json : TJSONWriter; name : string; elem : TFhirCodeableConcept; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElement(json, '', elem, true);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.codingList.Count > 0) then
  begin
    json.valueArray('coding');
    for i := 0 to elem.codingList.Count - 1 do
      ComposeCoding(json, '', elem.codingList[i]); {z - Coding}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'text', elem.textElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseParameterDefinition(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseParameterDefinition(jsn)); {2}
end;

function TFHIRJsonParser.ParseParameterDefinition(jsn : TJsonObject) : TFhirParameterDefinition;
begin
  result := TFhirParameterDefinition.create;
  try
    ParseParameterDefinitionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseParameterDefinitionProperties(jsn : TJsonObject; result : TFhirParameterDefinition);
begin
    ParseElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseCode(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('use') or jsn.has('_use')  then
      result.useElement := parseEnum(jsn.path+'/use', jsn.node['use'], jsn.vObj['_use'], CODES_TFhirOperationParameterUseEnum, SYSTEMS_TFhirOperationParameterUseEnum);
    if jsn.has('min') or jsn.has('_min') then
        result.minElement := parseInteger(jsn.node['min'], jsn.vObj['_min']);{q}
    if jsn.has('max') or jsn.has('_max') then
        result.maxElement := parseString(jsn.node['max'], jsn.vObj['_max']);{q}
    if jsn.has('documentation') or jsn.has('_documentation') then
        result.documentationElement := parseString(jsn.node['documentation'], jsn.vObj['_documentation']);{q}
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn.node['type'], jsn.vObj['_type'], CODES_TFhirAllTypesEnum, SYSTEMS_TFhirAllTypesEnum);
    if jsn.has('profile') or jsn.has('_profile') then
        result.profileElement := parseCanonical(jsn.node['profile'], jsn.vObj['_profile']);{q}
end;

procedure TFHIRJsonComposer.ComposeParameterDefinition(json : TJSONWriter; name : string; elem : TFhirParameterDefinition; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElement(json, '', elem, true);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeProps(json, 'name', elem.nameElement, false);
  ComposeEnumValue(json, 'use', elem.UseElement, CODES_TFhirOperationParameterUseEnum, false);
  ComposeEnumProps(json, 'use', elem.UseElement, CODES_TFhirOperationParameterUseEnum, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeIntegerValue(json, 'min', elem.minElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeIntegerProps(json, 'min', elem.minElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'max', elem.maxElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'max', elem.maxElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'documentation', elem.documentationElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'documentation', elem.documentationElement, false);
  ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirAllTypesEnum, false);
  ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirAllTypesEnum, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCanonicalValue(json, 'profile', elem.profileElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCanonicalProps(json, 'profile', elem.profileElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseContactPoint(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseContactPoint(jsn)); {2}
end;

function TFHIRJsonParser.ParseContactPoint(jsn : TJsonObject) : TFhirContactPoint;
begin
  result := TFhirContactPoint.create;
  try
    ParseContactPointProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseContactPointProperties(jsn : TJsonObject; result : TFhirContactPoint);
begin
    ParseElementProperties(jsn, result);
    if jsn.has('system') or jsn.has('_system')  then
      result.systemElement := parseEnum(jsn.path+'/system', jsn.node['system'], jsn.vObj['_system'], CODES_TFhirContactPointSystemEnum, SYSTEMS_TFhirContactPointSystemEnum);
    if jsn.has('value') or jsn.has('_value') then
        result.valueElement := parseString(jsn.node['value'], jsn.vObj['_value']);{q}
    if jsn.has('use') or jsn.has('_use')  then
      result.useElement := parseEnum(jsn.path+'/use', jsn.node['use'], jsn.vObj['_use'], CODES_TFhirContactPointUseEnum, SYSTEMS_TFhirContactPointUseEnum);
    if jsn.has('rank') or jsn.has('_rank') then
        result.rankElement := parsePositiveInt(jsn.node['rank'], jsn.vObj['_rank']);{q}
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q3}
end;

procedure TFHIRJsonComposer.ComposeContactPoint(json : TJSONWriter; name : string; elem : TFhirContactPoint; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElement(json, '', elem, true);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeEnumValue(json, 'system', elem.SystemElement, CODES_TFhirContactPointSystemEnum, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeEnumProps(json, 'system', elem.SystemElement, CODES_TFhirContactPointSystemEnum, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'value', elem.valueElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'value', elem.valueElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeEnumValue(json, 'use', elem.UseElement, CODES_TFhirContactPointUseEnum, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeEnumProps(json, 'use', elem.UseElement, CODES_TFhirContactPointUseEnum, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposePositiveIntValue(json, 'rank', elem.rankElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposePositiveIntProps(json, 'rank', elem.rankElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposePeriod(json, 'period', elem.period); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseHumanName(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseHumanName(jsn)); {2}
end;

function TFHIRJsonParser.ParseHumanName(jsn : TJsonObject) : TFhirHumanName;
begin
  result := TFhirHumanName.create;
  try
    ParseHumanNameProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseHumanNameProperties(jsn : TJsonObject; result : TFhirHumanName);
begin
    ParseElementProperties(jsn, result);
    if jsn.has('use') or jsn.has('_use')  then
      result.useElement := parseEnum(jsn.path+'/use', jsn.node['use'], jsn.vObj['_use'], CODES_TFhirNameUseEnum, SYSTEMS_TFhirNameUseEnum);
    if jsn.has('text') or jsn.has('_text') then
        result.textElement := parseString(jsn.node['text'], jsn.vObj['_text']);{q}
    if jsn.has('family') or jsn.has('_family') then
        result.familyElement := parseString(jsn.node['family'], jsn.vObj['_family']);{q}
      if jsn.has('given') or jsn.has('_given') then
      iteratePrimitiveArray(jsn.vArr['given'], jsn.vArr['_given'], result.givenList, parseString);
      if jsn.has('prefix') or jsn.has('_prefix') then
      iteratePrimitiveArray(jsn.vArr['prefix'], jsn.vArr['_prefix'], result.prefixList, parseString);
      if jsn.has('suffix') or jsn.has('_suffix') then
      iteratePrimitiveArray(jsn.vArr['suffix'], jsn.vArr['_suffix'], result.suffixList, parseString);
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q3}
end;

procedure TFHIRJsonComposer.ComposeHumanName(json : TJSONWriter; name : string; elem : TFhirHumanName; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElement(json, '', elem, true);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeEnumValue(json, 'use', elem.UseElement, CODES_TFhirNameUseEnum, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeEnumProps(json, 'use', elem.UseElement, CODES_TFhirNameUseEnum, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'family', elem.familyElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'family', elem.familyElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.givenList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.givenList.Count - 1 do
    begin
      ext := ext or ((elem.givenList[i].id <> '') or (elem.givenList[i].hasExtensionList) {no-comments or (elem.givenList[i].hasComments)});
      val := val or (elem.givenList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('given');
      for i := 0 to elem.givenList.Count - 1 do
        ComposeStringValue(json, '',elem.givenList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_given');
      for i := 0 to elem.givenList.Count - 1 do
        ComposeStringProps(json, '',elem.givenList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.prefixList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.prefixList.Count - 1 do
    begin
      ext := ext or ((elem.prefixList[i].id <> '') or (elem.prefixList[i].hasExtensionList) {no-comments or (elem.prefixList[i].hasComments)});
      val := val or (elem.prefixList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('prefix');
      for i := 0 to elem.prefixList.Count - 1 do
        ComposeStringValue(json, '',elem.prefixList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_prefix');
      for i := 0 to elem.prefixList.Count - 1 do
        ComposeStringProps(json, '',elem.prefixList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.suffixList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.suffixList.Count - 1 do
    begin
      ext := ext or ((elem.suffixList[i].id <> '') or (elem.suffixList[i].hasExtensionList) {no-comments or (elem.suffixList[i].hasComments)});
      val := val or (elem.suffixList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('suffix');
      for i := 0 to elem.suffixList.Count - 1 do
        ComposeStringValue(json, '',elem.suffixList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_suffix');
      for i := 0 to elem.suffixList.Count - 1 do
        ComposeStringProps(json, '',elem.suffixList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposePeriod(json, 'period', elem.period); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseMeta(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMeta(jsn)); {2}
end;

function TFHIRJsonParser.ParseMeta(jsn : TJsonObject) : TFhirMeta;
begin
  result := TFhirMeta.create;
  try
    ParseMetaProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMetaProperties(jsn : TJsonObject; result : TFhirMeta);
begin
    ParseElementProperties(jsn, result);
    if jsn.has('versionId') or jsn.has('_versionId') then
        result.versionIdElement := parseId(jsn.node['versionId'], jsn.vObj['_versionId']);{q}
    if jsn.has('lastUpdated') or jsn.has('_lastUpdated') then
        result.lastUpdatedElement := parseInstant(jsn.node['lastUpdated'], jsn.vObj['_lastUpdated']);{q}
    if jsn.has('source') or jsn.has('_source') then
        result.sourceElement := parseUri(jsn.node['source'], jsn.vObj['_source']);{q}
      if jsn.has('profile') or jsn.has('_profile') then
      iteratePrimitiveArray(jsn.vArr['profile'], jsn.vArr['_profile'], result.profileList, parseCanonical);
    if jsn.has('security') then
      iterateArray(jsn.vArr['security'], result.securityList, parseCoding);
    if jsn.has('tag') then
      iterateArray(jsn.vArr['tag'], result.tagList, parseCoding);
end;

procedure TFHIRJsonComposer.ComposeMeta(json : TJSONWriter; name : string; elem : TFhirMeta; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElement(json, '', elem, true);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeIdValue(json, 'versionId', elem.versionIdElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeIdProps(json, 'versionId', elem.versionIdElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInstantValue(json, 'lastUpdated', elem.lastUpdatedElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInstantProps(json, 'lastUpdated', elem.lastUpdatedElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUriValue(json, 'source', elem.sourceElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUriProps(json, 'source', elem.sourceElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.profileList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.profileList.Count - 1 do
    begin
      ext := ext or ((elem.profileList[i].id <> '') or (elem.profileList[i].hasExtensionList) {no-comments or (elem.profileList[i].hasComments)});
      val := val or (elem.profileList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('profile');
      for i := 0 to elem.profileList.Count - 1 do
        ComposeCanonicalValue(json, '',elem.profileList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_profile');
      for i := 0 to elem.profileList.Count - 1 do
        ComposeCanonicalProps(json, '',elem.profileList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.securityList.Count > 0) then
  begin
    json.valueArray('security');
    for i := 0 to elem.securityList.Count - 1 do
      ComposeCoding(json, '', elem.securityList[i]); {z - Coding}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.tagList.Count > 0) then
  begin
    json.valueArray('tag');
    for i := 0 to elem.tagList.Count - 1 do
      ComposeCoding(json, '', elem.tagList[i]); {z - Coding}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseAddress(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAddress(jsn)); {2}
end;

function TFHIRJsonParser.ParseAddress(jsn : TJsonObject) : TFhirAddress;
begin
  result := TFhirAddress.create;
  try
    ParseAddressProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseAddressProperties(jsn : TJsonObject; result : TFhirAddress);
begin
    ParseElementProperties(jsn, result);
    if jsn.has('use') or jsn.has('_use')  then
      result.useElement := parseEnum(jsn.path+'/use', jsn.node['use'], jsn.vObj['_use'], CODES_TFhirAddressUseEnum, SYSTEMS_TFhirAddressUseEnum);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn.node['type'], jsn.vObj['_type'], CODES_TFhirAddressTypeEnum, SYSTEMS_TFhirAddressTypeEnum);
    if jsn.has('text') or jsn.has('_text') then
        result.textElement := parseString(jsn.node['text'], jsn.vObj['_text']);{q}
      if jsn.has('line') or jsn.has('_line') then
      iteratePrimitiveArray(jsn.vArr['line'], jsn.vArr['_line'], result.lineList, parseString);
    if jsn.has('city') or jsn.has('_city') then
        result.cityElement := parseString(jsn.node['city'], jsn.vObj['_city']);{q}
    if jsn.has('district') or jsn.has('_district') then
        result.districtElement := parseString(jsn.node['district'], jsn.vObj['_district']);{q}
    if jsn.has('state') or jsn.has('_state') then
        result.stateElement := parseString(jsn.node['state'], jsn.vObj['_state']);{q}
    if jsn.has('postalCode') or jsn.has('_postalCode') then
        result.postalCodeElement := parseString(jsn.node['postalCode'], jsn.vObj['_postalCode']);{q}
    if jsn.has('country') or jsn.has('_country') then
        result.countryElement := parseString(jsn.node['country'], jsn.vObj['_country']);{q}
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q3}
end;

procedure TFHIRJsonComposer.ComposeAddress(json : TJSONWriter; name : string; elem : TFhirAddress; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElement(json, '', elem, true);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeEnumValue(json, 'use', elem.UseElement, CODES_TFhirAddressUseEnum, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeEnumProps(json, 'use', elem.UseElement, CODES_TFhirAddressUseEnum, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirAddressTypeEnum, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirAddressTypeEnum, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.lineList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.lineList.Count - 1 do
    begin
      ext := ext or ((elem.lineList[i].id <> '') or (elem.lineList[i].hasExtensionList) {no-comments or (elem.lineList[i].hasComments)});
      val := val or (elem.lineList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('line');
      for i := 0 to elem.lineList.Count - 1 do
        ComposeStringValue(json, '',elem.lineList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_line');
      for i := 0 to elem.lineList.Count - 1 do
        ComposeStringProps(json, '',elem.lineList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'city', elem.cityElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'city', elem.cityElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'district', elem.districtElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'district', elem.districtElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'state', elem.stateElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'state', elem.stateElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'postalCode', elem.postalCodeElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'postalCode', elem.postalCodeElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'country', elem.countryElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'country', elem.countryElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposePeriod(json, 'period', elem.period); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseElementDefinitionSlicing(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseElementDefinitionSlicing(jsn)); {2}
end;

function TFHIRJsonParser.ParseElementDefinitionSlicing(jsn : TJsonObject) : TFhirElementDefinitionSlicing;
begin
  result := TFhirElementDefinitionSlicing.create;
  try
    ParseElementDefinitionSlicingProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseElementDefinitionSlicingProperties(jsn : TJsonObject; result : TFhirElementDefinitionSlicing);
begin
    ParseElementProperties(jsn, result);
    if jsn.has('discriminator') then
      iterateArray(jsn.vArr['discriminator'], result.discriminatorList, parseElementDefinitionSlicingDiscriminator);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('ordered') or jsn.has('_ordered') then
        result.orderedElement := parseBoolean(jsn.node['ordered'], jsn.vObj['_ordered']);{q}
    if jsn.has('rules') or jsn.has('_rules')  then
      result.rulesElement := parseEnum(jsn.path+'/rules', jsn.node['rules'], jsn.vObj['_rules'], CODES_TFhirResourceSlicingRulesEnum, SYSTEMS_TFhirResourceSlicingRulesEnum);
end;

procedure TFHIRJsonComposer.ComposeElementDefinitionSlicing(json : TJSONWriter; name : string; elem : TFhirElementDefinitionSlicing; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.discriminatorList.Count > 0) then
  begin
    json.valueArray('discriminator');
    for i := 0 to elem.discriminatorList.Count - 1 do
      ComposeElementDefinitionSlicingDiscriminator(json, '', elem.discriminatorList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBooleanValue(json, 'ordered', elem.orderedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBooleanProps(json, 'ordered', elem.orderedElement, false);
  ComposeEnumValue(json, 'rules', elem.RulesElement, CODES_TFhirResourceSlicingRulesEnum, false);
  ComposeEnumProps(json, 'rules', elem.RulesElement, CODES_TFhirResourceSlicingRulesEnum, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseElementDefinitionSlicingDiscriminator(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseElementDefinitionSlicingDiscriminator(jsn)); {2}
end;

function TFHIRJsonParser.ParseElementDefinitionSlicingDiscriminator(jsn : TJsonObject) : TFhirElementDefinitionSlicingDiscriminator;
begin
  result := TFhirElementDefinitionSlicingDiscriminator.create;
  try
    ParseElementDefinitionSlicingDiscriminatorProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseElementDefinitionSlicingDiscriminatorProperties(jsn : TJsonObject; result : TFhirElementDefinitionSlicingDiscriminator);
begin
    ParseElementProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn.node['type'], jsn.vObj['_type'], CODES_TFhirDiscriminatorTypeEnum, SYSTEMS_TFhirDiscriminatorTypeEnum);
    if jsn.has('path') or jsn.has('_path') then
        result.pathElement := parseString(jsn.node['path'], jsn.vObj['_path']);{q}
end;

procedure TFHIRJsonComposer.ComposeElementDefinitionSlicingDiscriminator(json : TJSONWriter; name : string; elem : TFhirElementDefinitionSlicingDiscriminator; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElementProperties(json, elem);
  ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirDiscriminatorTypeEnum, false);
  ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirDiscriminatorTypeEnum, false);
  ComposeStringValue(json, 'path', elem.pathElement, false);
  ComposeStringProps(json, 'path', elem.pathElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseElementDefinitionBase(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseElementDefinitionBase(jsn)); {2}
end;

function TFHIRJsonParser.ParseElementDefinitionBase(jsn : TJsonObject) : TFhirElementDefinitionBase;
begin
  result := TFhirElementDefinitionBase.create;
  try
    ParseElementDefinitionBaseProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseElementDefinitionBaseProperties(jsn : TJsonObject; result : TFhirElementDefinitionBase);
begin
    ParseElementProperties(jsn, result);
    if jsn.has('path') or jsn.has('_path') then
        result.pathElement := parseString(jsn.node['path'], jsn.vObj['_path']);{q}
    if jsn.has('min') or jsn.has('_min') then
        result.minElement := parseUnsignedInt(jsn.node['min'], jsn.vObj['_min']);{q}
    if jsn.has('max') or jsn.has('_max') then
        result.maxElement := parseString(jsn.node['max'], jsn.vObj['_max']);{q}
end;

procedure TFHIRJsonComposer.ComposeElementDefinitionBase(json : TJSONWriter; name : string; elem : TFhirElementDefinitionBase; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElementProperties(json, elem);
  ComposeStringValue(json, 'path', elem.pathElement, false);
  ComposeStringProps(json, 'path', elem.pathElement, false);
  ComposeUnsignedIntValue(json, 'min', elem.minElement, false);
  ComposeUnsignedIntProps(json, 'min', elem.minElement, false);
  ComposeStringValue(json, 'max', elem.maxElement, false);
  ComposeStringProps(json, 'max', elem.maxElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseElementDefinitionType(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseElementDefinitionType(jsn)); {2}
end;

function TFHIRJsonParser.ParseElementDefinitionType(jsn : TJsonObject) : TFhirElementDefinitionType;
begin
  result := TFhirElementDefinitionType.create;
  try
    ParseElementDefinitionTypeProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseElementDefinitionTypeProperties(jsn : TJsonObject; result : TFhirElementDefinitionType);
begin
    ParseElementProperties(jsn, result);
    if jsn.has('code') or jsn.has('_code') then
        result.codeElement := parseUri(jsn.node['code'], jsn.vObj['_code']);{q}
      if jsn.has('profile') or jsn.has('_profile') then
      iteratePrimitiveArray(jsn.vArr['profile'], jsn.vArr['_profile'], result.profileList, parseCanonical);
      if jsn.has('targetProfile') or jsn.has('_targetProfile') then
      iteratePrimitiveArray(jsn.vArr['targetProfile'], jsn.vArr['_targetProfile'], result.targetProfileList, parseCanonical);
    if jsn.has('aggregation') or jsn.has('_aggregation') then
      iterateEnumArray(jsn.vArr['aggregation'], jsn.vArr['_aggregation'], jsn.path+'/aggregation', result.aggregationList, parseEnum, CODES_TFhirResourceAggregationModeEnum, SYSTEMS_TFhirResourceAggregationModeEnum);
    if jsn.has('versioning') or jsn.has('_versioning')  then
      result.versioningElement := parseEnum(jsn.path+'/versioning', jsn.node['versioning'], jsn.vObj['_versioning'], CODES_TFhirReferenceVersionRulesEnum, SYSTEMS_TFhirReferenceVersionRulesEnum);
end;

procedure TFHIRJsonComposer.ComposeElementDefinitionType(json : TJSONWriter; name : string; elem : TFhirElementDefinitionType; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElementProperties(json, elem);
  ComposeUriValue(json, 'code', elem.codeElement, false);
  ComposeUriProps(json, 'code', elem.codeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.profileList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.profileList.Count - 1 do
    begin
      ext := ext or ((elem.profileList[i].id <> '') or (elem.profileList[i].hasExtensionList) {no-comments or (elem.profileList[i].hasComments)});
      val := val or (elem.profileList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('profile');
      for i := 0 to elem.profileList.Count - 1 do
        ComposeCanonicalValue(json, '',elem.profileList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_profile');
      for i := 0 to elem.profileList.Count - 1 do
        ComposeCanonicalProps(json, '',elem.profileList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.targetProfileList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.targetProfileList.Count - 1 do
    begin
      ext := ext or ((elem.targetProfileList[i].id <> '') or (elem.targetProfileList[i].hasExtensionList) {no-comments or (elem.targetProfileList[i].hasComments)});
      val := val or (elem.targetProfileList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('targetProfile');
      for i := 0 to elem.targetProfileList.Count - 1 do
        ComposeCanonicalValue(json, '',elem.targetProfileList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_targetProfile');
      for i := 0 to elem.targetProfileList.Count - 1 do
        ComposeCanonicalProps(json, '',elem.targetProfileList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.aggregationList.Count > 0) then
  begin
    val := false;
    ext := false;
    for i := 0 to elem.aggregationList.Count - 1 do
    begin
      val := val or (elem.aggregationList[i].hasPrimitiveValue);
      ext := ext or ((elem.aggregationList[i].id <> '') or (elem.aggregationList[i].hasExtensionList));
    end;
    if val then
    begin
      json.valueArray('aggregation');
      for i := 0 to elem.aggregationList.Count - 1 do
        ComposeEnumValue(json, '', elem.aggregationList[i], CODES_TFhirResourceAggregationModeEnum, true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_aggregation');
      for i := 0 to elem.aggregationList.Count - 1 do
        ComposeEnumProps(json, '', elem.aggregationList[i], CODES_TFhirResourceAggregationModeEnum, true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnumValue(json, 'versioning', elem.VersioningElement, CODES_TFhirReferenceVersionRulesEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnumProps(json, 'versioning', elem.VersioningElement, CODES_TFhirReferenceVersionRulesEnum, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseElementDefinitionExample(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseElementDefinitionExample(jsn)); {2}
end;

function TFHIRJsonParser.ParseElementDefinitionExample(jsn : TJsonObject) : TFhirElementDefinitionExample;
begin
  result := TFhirElementDefinitionExample.create;
  try
    ParseElementDefinitionExampleProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseElementDefinitionExampleProperties(jsn : TJsonObject; result : TFhirElementDefinitionExample);
begin
    ParseElementProperties(jsn, result);
    if jsn.has('label') or jsn.has('_label') then
        result.label_Element := parseString(jsn.node['label'], jsn.vObj['_label']);{q}
    if jsn.has('valueCanonical') or jsn.has('_valueCanonical') then
      result.value := parseCanonical(jsn.node['valueCanonical'], jsn.vObj['_valueCanonical']);
    if jsn.has('valueCode') or jsn.has('_valueCode') then
      result.value := parseCode(jsn.node['valueCode'], jsn.vObj['_valueCode']);
    if jsn.has('valueId') or jsn.has('_valueId') then
      result.value := parseId(jsn.node['valueId'], jsn.vObj['_valueId']);
    if jsn.has('valueMarkdown') or jsn.has('_valueMarkdown') then
      result.value := parseMarkdown(jsn.node['valueMarkdown'], jsn.vObj['_valueMarkdown']);
    if jsn.has('valueOid') or jsn.has('_valueOid') then
      result.value := parseOid(jsn.node['valueOid'], jsn.vObj['_valueOid']);
    if jsn.has('valuePositiveInt') or jsn.has('_valuePositiveInt') then
      result.value := parsePositiveInt(jsn.node['valuePositiveInt'], jsn.vObj['_valuePositiveInt']);
    if jsn.has('valueUnsignedInt') or jsn.has('_valueUnsignedInt') then
      result.value := parseUnsignedInt(jsn.node['valueUnsignedInt'], jsn.vObj['_valueUnsignedInt']);
    if jsn.has('valueUrl') or jsn.has('_valueUrl') then
      result.value := parseUrl(jsn.node['valueUrl'], jsn.vObj['_valueUrl']);
    if jsn.has('valueUuid') or jsn.has('_valueUuid') then
      result.value := parseUuid(jsn.node['valueUuid'], jsn.vObj['_valueUuid']);
    if jsn.has('valueAddress') {a4} then
      result.value := ParseAddress(jsn.vObj['valueAddress']);
    if jsn.has('valueAge') {a4} then
      result.value := ParseAge(jsn.vObj['valueAge']);
    if jsn.has('valueAnnotation') {a4} then
      result.value := ParseAnnotation(jsn.vObj['valueAnnotation']);
    if jsn.has('valueAttachment') {a4} then
      result.value := ParseAttachment(jsn.vObj['valueAttachment']);
    if jsn.has('valueCodeableConcept') {a4} then
      result.value := ParseCodeableConcept(jsn.vObj['valueCodeableConcept']);
    if jsn.has('valueCoding') {a4} then
      result.value := ParseCoding(jsn.vObj['valueCoding']);
    if jsn.has('valueContactPoint') {a4} then
      result.value := ParseContactPoint(jsn.vObj['valueContactPoint']);
    if jsn.has('valueCount') {a4} then
      result.value := ParseCount(jsn.vObj['valueCount']);
    if jsn.has('valueDistance') {a4} then
      result.value := ParseDistance(jsn.vObj['valueDistance']);
    if jsn.has('valueDuration') {a4} then
      result.value := ParseDuration(jsn.vObj['valueDuration']);
    if jsn.has('valueHumanName') {a4} then
      result.value := ParseHumanName(jsn.vObj['valueHumanName']);
    if jsn.has('valueIdentifier') {a4} then
      result.value := ParseIdentifier(jsn.vObj['valueIdentifier']);
    if jsn.has('valueMoney') {a4} then
      result.value := ParseMoney(jsn.vObj['valueMoney']);
    if jsn.has('valuePeriod') {a4} then
      result.value := ParsePeriod(jsn.vObj['valuePeriod']);
    if jsn.has('valueQuantity') {a4} then
      result.value := ParseQuantity(jsn.vObj['valueQuantity']);
    if jsn.has('valueRange') {a4} then
      result.value := ParseRange(jsn.vObj['valueRange']);
    if jsn.has('valueRatio') {a4} then
      result.value := ParseRatio(jsn.vObj['valueRatio']);
    if jsn.has('valueReference') {a4} then
      result.value := ParseReference(jsn.vObj['valueReference']);
    if jsn.has('valueSampledData') {a4} then
      result.value := ParseSampledData(jsn.vObj['valueSampledData']);
    if jsn.has('valueSignature') {a4} then
      result.value := ParseSignature(jsn.vObj['valueSignature']);
    if jsn.has('valueTiming') {a4} then
      result.value := ParseTiming(jsn.vObj['valueTiming']);
    if jsn.has('valueContactDetail') {a4} then
      result.value := ParseContactDetail(jsn.vObj['valueContactDetail']);
    if jsn.has('valueContributor') {a4} then
      result.value := ParseContributor(jsn.vObj['valueContributor']);
    if jsn.has('valueDataRequirement') {a4} then
      result.value := ParseDataRequirement(jsn.vObj['valueDataRequirement']);
    if jsn.has('valueExpression') {a4} then
      result.value := ParseExpression(jsn.vObj['valueExpression']);
    if jsn.has('valueParameterDefinition') {a4} then
      result.value := ParseParameterDefinition(jsn.vObj['valueParameterDefinition']);
    if jsn.has('valueRelatedArtifact') {a4} then
      result.value := ParseRelatedArtifact(jsn.vObj['valueRelatedArtifact']);
    if jsn.has('valueTriggerDefinition') {a4} then
      result.value := ParseTriggerDefinition(jsn.vObj['valueTriggerDefinition']);
    if jsn.has('valueUsageContext') {a4} then
      result.value := ParseUsageContext(jsn.vObj['valueUsageContext']);
    if jsn.has('valueDosage') {a4} then
      result.value := ParseDosage(jsn.vObj['valueDosage']);
    if jsn.has('valueBase64Binary') or jsn.has('_valueBase64Binary') then
      result.value := parseBase64Binary(jsn.node['valueBase64Binary'], jsn.vObj['_valueBase64Binary']);
    if jsn.has('valueBoolean') or jsn.has('_valueBoolean') then
      result.value := parseBoolean(jsn.node['valueBoolean'], jsn.vObj['_valueBoolean']);
    if jsn.has('valueDate') or jsn.has('_valueDate') then
      result.value := parseDate(jsn.node['valueDate'], jsn.vObj['_valueDate']);
    if jsn.has('valueDateTime') or jsn.has('_valueDateTime') then
      result.value := parseDateTime(jsn.node['valueDateTime'], jsn.vObj['_valueDateTime']);
    if jsn.has('valueDecimal') or jsn.has('_valueDecimal') then
      result.value := parseDecimal(jsn.node['valueDecimal'], jsn.vObj['_valueDecimal']);
    if jsn.has('valueInstant') or jsn.has('_valueInstant') then
      result.value := parseInstant(jsn.node['valueInstant'], jsn.vObj['_valueInstant']);
    if jsn.has('valueInteger') or jsn.has('_valueInteger') then
      result.value := parseInteger(jsn.node['valueInteger'], jsn.vObj['_valueInteger']);
    if jsn.has('valueString') or jsn.has('_valueString') then
      result.value := parseString(jsn.node['valueString'], jsn.vObj['_valueString']);
    if jsn.has('valueTime') or jsn.has('_valueTime') then
      result.value := parseTime(jsn.node['valueTime'], jsn.vObj['_valueTime']);
    if jsn.has('valueUri') or jsn.has('_valueUri') then
      result.value := parseUri(jsn.node['valueUri'], jsn.vObj['_valueUri']);
end;

procedure TFHIRJsonComposer.ComposeElementDefinitionExample(json : TJSONWriter; name : string; elem : TFhirElementDefinitionExample; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElementProperties(json, elem);
  ComposeStringValue(json, 'label', elem.label_Element, false);
  ComposeStringProps(json, 'label', elem.label_Element, false);
  if (elem.value is TFhirCanonical) then 
  begin
    ComposeCanonicalValue(json, 'valueCanonical', TFhirCanonical(elem.value), false);
    ComposeCanonicalProps(json, 'valueCanonical', TFhirCanonical(elem.value), false);
  end
  else if (elem.value is TFhirCode) then 
  begin
    ComposeCodeValue(json, 'valueCode', TFhirCode(elem.value), false);
    ComposeCodeProps(json, 'valueCode', TFhirCode(elem.value), false);
  end
  else if (elem.value is TFhirId) then 
  begin
    ComposeIdValue(json, 'valueId', TFhirId(elem.value), false);
    ComposeIdProps(json, 'valueId', TFhirId(elem.value), false);
  end
  else if (elem.value is TFhirMarkdown) then 
  begin
    ComposeMarkdownValue(json, 'valueMarkdown', TFhirMarkdown(elem.value), false);
    ComposeMarkdownProps(json, 'valueMarkdown', TFhirMarkdown(elem.value), false);
  end
  else if (elem.value is TFhirOid) then 
  begin
    ComposeOidValue(json, 'valueOid', TFhirOid(elem.value), false);
    ComposeOidProps(json, 'valueOid', TFhirOid(elem.value), false);
  end
  else if (elem.value is TFhirPositiveInt) then 
  begin
    ComposePositiveIntValue(json, 'valuePositiveInt', TFhirPositiveInt(elem.value), false);
    ComposePositiveIntProps(json, 'valuePositiveInt', TFhirPositiveInt(elem.value), false);
  end
  else if (elem.value is TFhirUnsignedInt) then 
  begin
    ComposeUnsignedIntValue(json, 'valueUnsignedInt', TFhirUnsignedInt(elem.value), false);
    ComposeUnsignedIntProps(json, 'valueUnsignedInt', TFhirUnsignedInt(elem.value), false);
  end
  else if (elem.value is TFhirUrl) then 
  begin
    ComposeUrlValue(json, 'valueUrl', TFhirUrl(elem.value), false);
    ComposeUrlProps(json, 'valueUrl', TFhirUrl(elem.value), false);
  end
  else if (elem.value is TFhirUuid) then 
  begin
    ComposeUuidValue(json, 'valueUuid', TFhirUuid(elem.value), false);
    ComposeUuidProps(json, 'valueUuid', TFhirUuid(elem.value), false);
  end
  else if (elem.value is TFhirAddress) then 
    ComposeAddress(json, 'valueAddress', TFhirAddress(elem.value)) 
  else if (elem.value is TFhirAge) then 
    ComposeAge(json, 'valueAge', TFhirAge(elem.value)) 
  else if (elem.value is TFhirAnnotation) then 
    ComposeAnnotation(json, 'valueAnnotation', TFhirAnnotation(elem.value)) 
  else if (elem.value is TFhirAttachment) then 
    ComposeAttachment(json, 'valueAttachment', TFhirAttachment(elem.value)) 
  else if (elem.value is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'valueCodeableConcept', TFhirCodeableConcept(elem.value)) 
  else if (elem.value is TFhirCoding) then 
    ComposeCoding(json, 'valueCoding', TFhirCoding(elem.value)) 
  else if (elem.value is TFhirContactPoint) then 
    ComposeContactPoint(json, 'valueContactPoint', TFhirContactPoint(elem.value)) 
  else if (elem.value is TFhirCount) then 
    ComposeCount(json, 'valueCount', TFhirCount(elem.value)) 
  else if (elem.value is TFhirDistance) then 
    ComposeDistance(json, 'valueDistance', TFhirDistance(elem.value)) 
  else if (elem.value is TFhirDuration) then 
    ComposeDuration(json, 'valueDuration', TFhirDuration(elem.value)) 
  else if (elem.value is TFhirHumanName) then 
    ComposeHumanName(json, 'valueHumanName', TFhirHumanName(elem.value)) 
  else if (elem.value is TFhirIdentifier) then 
    ComposeIdentifier(json, 'valueIdentifier', TFhirIdentifier(elem.value)) 
  else if (elem.value is TFhirMoney) then 
    ComposeMoney(json, 'valueMoney', TFhirMoney(elem.value)) 
  else if (elem.value is TFhirPeriod) then 
    ComposePeriod(json, 'valuePeriod', TFhirPeriod(elem.value)) 
  else if (elem.value is TFhirQuantity) then 
    ComposeQuantity(json, 'valueQuantity', TFhirQuantity(elem.value)) 
  else if (elem.value is TFhirRange) then 
    ComposeRange(json, 'valueRange', TFhirRange(elem.value)) 
  else if (elem.value is TFhirRatio) then 
    ComposeRatio(json, 'valueRatio', TFhirRatio(elem.value)) 
  else if (elem.value is TFhirReference) then 
    ComposeReference(json, 'valueReference', TFhirReference(elem.value)) 
  else if (elem.value is TFhirSampledData) then 
    ComposeSampledData(json, 'valueSampledData', TFhirSampledData(elem.value)) 
  else if (elem.value is TFhirSignature) then 
    ComposeSignature(json, 'valueSignature', TFhirSignature(elem.value)) 
  else if (elem.value is TFhirTiming) then 
    ComposeTiming(json, 'valueTiming', TFhirTiming(elem.value)) 
  else if (elem.value is TFhirContactDetail) then 
    ComposeContactDetail(json, 'valueContactDetail', TFhirContactDetail(elem.value)) 
  else if (elem.value is TFhirContributor) then 
    ComposeContributor(json, 'valueContributor', TFhirContributor(elem.value)) 
  else if (elem.value is TFhirDataRequirement) then 
    ComposeDataRequirement(json, 'valueDataRequirement', TFhirDataRequirement(elem.value)) 
  else if (elem.value is TFhirExpression) then 
    ComposeExpression(json, 'valueExpression', TFhirExpression(elem.value)) 
  else if (elem.value is TFhirParameterDefinition) then 
    ComposeParameterDefinition(json, 'valueParameterDefinition', TFhirParameterDefinition(elem.value)) 
  else if (elem.value is TFhirRelatedArtifact) then 
    ComposeRelatedArtifact(json, 'valueRelatedArtifact', TFhirRelatedArtifact(elem.value)) 
  else if (elem.value is TFhirTriggerDefinition) then 
    ComposeTriggerDefinition(json, 'valueTriggerDefinition', TFhirTriggerDefinition(elem.value)) 
  else if (elem.value is TFhirUsageContext) then 
    ComposeUsageContext(json, 'valueUsageContext', TFhirUsageContext(elem.value)) 
  else if (elem.value is TFhirDosage) then 
    ComposeDosage(json, 'valueDosage', TFhirDosage(elem.value)) 
  else if (elem.value is TFhirBase64Binary) then 
  begin
    ComposeBase64BinaryValue(json, 'valueBase64Binary', TFhirBase64Binary(elem.value), false);
    ComposeBase64BinaryProps(json, 'valueBase64Binary', TFhirBase64Binary(elem.value), false);
  end
  else if (elem.value is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'valueBoolean', TFhirBoolean(elem.value), false);
    ComposeBooleanProps(json, 'valueBoolean', TFhirBoolean(elem.value), false);
  end
  else if (elem.value is TFhirDate) then 
  begin
    ComposeDateValue(json, 'valueDate', TFhirDate(elem.value), false);
    ComposeDateProps(json, 'valueDate', TFhirDate(elem.value), false);
  end
  else if (elem.value is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'valueDateTime', TFhirDateTime(elem.value), false);
    ComposeDateTimeProps(json, 'valueDateTime', TFhirDateTime(elem.value), false);
  end
  else if (elem.value is TFhirDecimal) then 
  begin
    ComposeDecimalValue(json, 'valueDecimal', TFhirDecimal(elem.value), false);
    ComposeDecimalProps(json, 'valueDecimal', TFhirDecimal(elem.value), false);
  end
  else if (elem.value is TFhirInstant) then 
  begin
    ComposeInstantValue(json, 'valueInstant', TFhirInstant(elem.value), false);
    ComposeInstantProps(json, 'valueInstant', TFhirInstant(elem.value), false);
  end
  else if (elem.value is TFhirInteger) then 
  begin
    ComposeIntegerValue(json, 'valueInteger', TFhirInteger(elem.value), false);
    ComposeIntegerProps(json, 'valueInteger', TFhirInteger(elem.value), false);
  end
  else if (elem.value is TFhirString) then 
  begin
    ComposeStringValue(json, 'valueString', TFhirString(elem.value), false);
    ComposeStringProps(json, 'valueString', TFhirString(elem.value), false);
  end
  else if (elem.value is TFhirTime) then 
  begin
    ComposeTimeValue(json, 'valueTime', TFhirTime(elem.value), false);
    ComposeTimeProps(json, 'valueTime', TFhirTime(elem.value), false);
  end
  else if (elem.value is TFhirUri) then 
  begin
    ComposeUriValue(json, 'valueUri', TFhirUri(elem.value), false);
    ComposeUriProps(json, 'valueUri', TFhirUri(elem.value), false);
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseElementDefinitionConstraint(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseElementDefinitionConstraint(jsn)); {2}
end;

function TFHIRJsonParser.ParseElementDefinitionConstraint(jsn : TJsonObject) : TFhirElementDefinitionConstraint;
begin
  result := TFhirElementDefinitionConstraint.create;
  try
    ParseElementDefinitionConstraintProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseElementDefinitionConstraintProperties(jsn : TJsonObject; result : TFhirElementDefinitionConstraint);
begin
    ParseElementProperties(jsn, result);
    if jsn.has('key') or jsn.has('_key') then
        result.keyElement := parseId(jsn.node['key'], jsn.vObj['_key']);{q}
    if jsn.has('requirements') or jsn.has('_requirements') then
        result.requirementsElement := parseString(jsn.node['requirements'], jsn.vObj['_requirements']);{q}
    if jsn.has('severity') or jsn.has('_severity')  then
      result.severityElement := parseEnum(jsn.path+'/severity', jsn.node['severity'], jsn.vObj['_severity'], CODES_TFhirConstraintSeverityEnum, SYSTEMS_TFhirConstraintSeverityEnum);
    if jsn.has('human') or jsn.has('_human') then
        result.humanElement := parseString(jsn.node['human'], jsn.vObj['_human']);{q}
    if jsn.has('expression') or jsn.has('_expression') then
        result.expressionElement := parseString(jsn.node['expression'], jsn.vObj['_expression']);{q}
    if jsn.has('xpath') or jsn.has('_xpath') then
        result.xpathElement := parseString(jsn.node['xpath'], jsn.vObj['_xpath']);{q}
    if jsn.has('source') or jsn.has('_source') then
        result.sourceElement := parseCanonical(jsn.node['source'], jsn.vObj['_source']);{q}
end;

procedure TFHIRJsonComposer.ComposeElementDefinitionConstraint(json : TJSONWriter; name : string; elem : TFhirElementDefinitionConstraint; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElementProperties(json, elem);
  ComposeIdValue(json, 'key', elem.keyElement, false);
  ComposeIdProps(json, 'key', elem.keyElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'requirements', elem.requirementsElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'requirements', elem.requirementsElement, false);
  ComposeEnumValue(json, 'severity', elem.SeverityElement, CODES_TFhirConstraintSeverityEnum, false);
  ComposeEnumProps(json, 'severity', elem.SeverityElement, CODES_TFhirConstraintSeverityEnum, false);
  ComposeStringValue(json, 'human', elem.humanElement, false);
  ComposeStringProps(json, 'human', elem.humanElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'expression', elem.expressionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'expression', elem.expressionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'xpath', elem.xpathElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'xpath', elem.xpathElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCanonicalValue(json, 'source', elem.sourceElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCanonicalProps(json, 'source', elem.sourceElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseElementDefinitionBinding(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseElementDefinitionBinding(jsn)); {2}
end;

function TFHIRJsonParser.ParseElementDefinitionBinding(jsn : TJsonObject) : TFhirElementDefinitionBinding;
begin
  result := TFhirElementDefinitionBinding.create;
  try
    ParseElementDefinitionBindingProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseElementDefinitionBindingProperties(jsn : TJsonObject; result : TFhirElementDefinitionBinding);
begin
    ParseElementProperties(jsn, result);
    if jsn.has('strength') or jsn.has('_strength')  then
      result.strengthElement := parseEnum(jsn.path+'/strength', jsn.node['strength'], jsn.vObj['_strength'], CODES_TFhirBindingStrengthEnum, SYSTEMS_TFhirBindingStrengthEnum);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('valueSet') or jsn.has('_valueSet') then
        result.valueSetElement := parseCanonical(jsn.node['valueSet'], jsn.vObj['_valueSet']);{q}
end;

procedure TFHIRJsonComposer.ComposeElementDefinitionBinding(json : TJSONWriter; name : string; elem : TFhirElementDefinitionBinding; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElementProperties(json, elem);
  ComposeEnumValue(json, 'strength', elem.StrengthElement, CODES_TFhirBindingStrengthEnum, false);
  ComposeEnumProps(json, 'strength', elem.StrengthElement, CODES_TFhirBindingStrengthEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCanonicalValue(json, 'valueSet', elem.valueSetElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCanonicalProps(json, 'valueSet', elem.valueSetElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseElementDefinitionMapping(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseElementDefinitionMapping(jsn)); {2}
end;

function TFHIRJsonParser.ParseElementDefinitionMapping(jsn : TJsonObject) : TFhirElementDefinitionMapping;
begin
  result := TFhirElementDefinitionMapping.create;
  try
    ParseElementDefinitionMappingProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseElementDefinitionMappingProperties(jsn : TJsonObject; result : TFhirElementDefinitionMapping);
begin
    ParseElementProperties(jsn, result);
    if jsn.has('identity') or jsn.has('_identity') then
        result.identityElement := parseId(jsn.node['identity'], jsn.vObj['_identity']);{q}
    if jsn.has('language') or jsn.has('_language') then
        result.languageElement := parseCode(jsn.node['language'], jsn.vObj['_language']);{q}
    if jsn.has('map') or jsn.has('_map') then
        result.mapElement := parseString(jsn.node['map'], jsn.vObj['_map']);{q}
    if jsn.has('comment') or jsn.has('_comment') then
        result.commentElement := parseString(jsn.node['comment'], jsn.vObj['_comment']);{q}
end;

procedure TFHIRJsonComposer.ComposeElementDefinitionMapping(json : TJSONWriter; name : string; elem : TFhirElementDefinitionMapping; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElementProperties(json, elem);
  ComposeIdValue(json, 'identity', elem.identityElement, false);
  ComposeIdProps(json, 'identity', elem.identityElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeValue(json, 'language', elem.languageElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeProps(json, 'language', elem.languageElement, false);
  ComposeStringValue(json, 'map', elem.mapElement, false);
  ComposeStringProps(json, 'map', elem.mapElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'comment', elem.commentElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'comment', elem.commentElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseElementDefinition(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseElementDefinition(jsn)); {2}
end;

function TFHIRJsonParser.ParseElementDefinition(jsn : TJsonObject) : TFhirElementDefinition;
begin
  result := TFhirElementDefinition.create;
  try
    ParseElementDefinitionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseElementDefinitionProperties(jsn : TJsonObject; result : TFhirElementDefinition);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('path') or jsn.has('_path') then
        result.pathElement := parseString(jsn.node['path'], jsn.vObj['_path']);{q}
    if jsn.has('representation') or jsn.has('_representation') then
      iterateEnumArray(jsn.vArr['representation'], jsn.vArr['_representation'], jsn.path+'/representation', result.representationList, parseEnum, CODES_TFhirPropertyRepresentationEnum, SYSTEMS_TFhirPropertyRepresentationEnum);
    if jsn.has('sliceName') or jsn.has('_sliceName') then
        result.sliceNameElement := parseString(jsn.node['sliceName'], jsn.vObj['_sliceName']);{q}
    if jsn.has('sliceIsConstraining') or jsn.has('_sliceIsConstraining') then
        result.sliceIsConstrainingElement := parseBoolean(jsn.node['sliceIsConstraining'], jsn.vObj['_sliceIsConstraining']);{q}
    if jsn.has('label') or jsn.has('_label') then
        result.label_Element := parseString(jsn.node['label'], jsn.vObj['_label']);{q}
    if jsn.has('code') then
      iterateArray(jsn.vArr['code'], result.codeList, parseCoding);
    if jsn.has('slicing') then
        result.slicing := ParseElementDefinitionSlicing(jsn.vObj['slicing']);{q3}
    if jsn.has('short') or jsn.has('_short') then
        result.shortElement := parseString(jsn.node['short'], jsn.vObj['_short']);{q}
    if jsn.has('definition') or jsn.has('_definition') then
        result.definitionElement := parseMarkdown(jsn.node['definition'], jsn.vObj['_definition']);{q}
    if jsn.has('comment') or jsn.has('_comment') then
        result.commentElement := parseMarkdown(jsn.node['comment'], jsn.vObj['_comment']);{q}
    if jsn.has('requirements') or jsn.has('_requirements') then
        result.requirementsElement := parseMarkdown(jsn.node['requirements'], jsn.vObj['_requirements']);{q}
      if jsn.has('alias') or jsn.has('_alias') then
      iteratePrimitiveArray(jsn.vArr['alias'], jsn.vArr['_alias'], result.aliasList, parseString);
    if jsn.has('min') or jsn.has('_min') then
        result.minElement := parseUnsignedInt(jsn.node['min'], jsn.vObj['_min']);{q}
    if jsn.has('max') or jsn.has('_max') then
        result.maxElement := parseString(jsn.node['max'], jsn.vObj['_max']);{q}
    if jsn.has('base') then
        result.base := ParseElementDefinitionBase(jsn.vObj['base']);{q3}
    if jsn.has('contentReference') or jsn.has('_contentReference') then
        result.contentReferenceElement := parseUri(jsn.node['contentReference'], jsn.vObj['_contentReference']);{q}
    if jsn.has('type') then
      iterateArray(jsn.vArr['type'], result.type_List, parseElementDefinitionType);
    if jsn.has('defaultValueCanonical') or jsn.has('_defaultValueCanonical') then
      result.defaultValue := parseCanonical(jsn.node['defaultValueCanonical'], jsn.vObj['_defaultValueCanonical']);
    if jsn.has('defaultValueCode') or jsn.has('_defaultValueCode') then
      result.defaultValue := parseCode(jsn.node['defaultValueCode'], jsn.vObj['_defaultValueCode']);
    if jsn.has('defaultValueId') or jsn.has('_defaultValueId') then
      result.defaultValue := parseId(jsn.node['defaultValueId'], jsn.vObj['_defaultValueId']);
    if jsn.has('defaultValueMarkdown') or jsn.has('_defaultValueMarkdown') then
      result.defaultValue := parseMarkdown(jsn.node['defaultValueMarkdown'], jsn.vObj['_defaultValueMarkdown']);
    if jsn.has('defaultValueOid') or jsn.has('_defaultValueOid') then
      result.defaultValue := parseOid(jsn.node['defaultValueOid'], jsn.vObj['_defaultValueOid']);
    if jsn.has('defaultValuePositiveInt') or jsn.has('_defaultValuePositiveInt') then
      result.defaultValue := parsePositiveInt(jsn.node['defaultValuePositiveInt'], jsn.vObj['_defaultValuePositiveInt']);
    if jsn.has('defaultValueUnsignedInt') or jsn.has('_defaultValueUnsignedInt') then
      result.defaultValue := parseUnsignedInt(jsn.node['defaultValueUnsignedInt'], jsn.vObj['_defaultValueUnsignedInt']);
    if jsn.has('defaultValueUrl') or jsn.has('_defaultValueUrl') then
      result.defaultValue := parseUrl(jsn.node['defaultValueUrl'], jsn.vObj['_defaultValueUrl']);
    if jsn.has('defaultValueUuid') or jsn.has('_defaultValueUuid') then
      result.defaultValue := parseUuid(jsn.node['defaultValueUuid'], jsn.vObj['_defaultValueUuid']);
    if jsn.has('defaultValueAddress') {a4} then
      result.defaultValue := ParseAddress(jsn.vObj['defaultValueAddress']);
    if jsn.has('defaultValueAge') {a4} then
      result.defaultValue := ParseAge(jsn.vObj['defaultValueAge']);
    if jsn.has('defaultValueAnnotation') {a4} then
      result.defaultValue := ParseAnnotation(jsn.vObj['defaultValueAnnotation']);
    if jsn.has('defaultValueAttachment') {a4} then
      result.defaultValue := ParseAttachment(jsn.vObj['defaultValueAttachment']);
    if jsn.has('defaultValueCodeableConcept') {a4} then
      result.defaultValue := ParseCodeableConcept(jsn.vObj['defaultValueCodeableConcept']);
    if jsn.has('defaultValueCoding') {a4} then
      result.defaultValue := ParseCoding(jsn.vObj['defaultValueCoding']);
    if jsn.has('defaultValueContactPoint') {a4} then
      result.defaultValue := ParseContactPoint(jsn.vObj['defaultValueContactPoint']);
    if jsn.has('defaultValueCount') {a4} then
      result.defaultValue := ParseCount(jsn.vObj['defaultValueCount']);
    if jsn.has('defaultValueDistance') {a4} then
      result.defaultValue := ParseDistance(jsn.vObj['defaultValueDistance']);
    if jsn.has('defaultValueDuration') {a4} then
      result.defaultValue := ParseDuration(jsn.vObj['defaultValueDuration']);
    if jsn.has('defaultValueHumanName') {a4} then
      result.defaultValue := ParseHumanName(jsn.vObj['defaultValueHumanName']);
    if jsn.has('defaultValueIdentifier') {a4} then
      result.defaultValue := ParseIdentifier(jsn.vObj['defaultValueIdentifier']);
    if jsn.has('defaultValueMoney') {a4} then
      result.defaultValue := ParseMoney(jsn.vObj['defaultValueMoney']);
    if jsn.has('defaultValuePeriod') {a4} then
      result.defaultValue := ParsePeriod(jsn.vObj['defaultValuePeriod']);
    if jsn.has('defaultValueQuantity') {a4} then
      result.defaultValue := ParseQuantity(jsn.vObj['defaultValueQuantity']);
    if jsn.has('defaultValueRange') {a4} then
      result.defaultValue := ParseRange(jsn.vObj['defaultValueRange']);
    if jsn.has('defaultValueRatio') {a4} then
      result.defaultValue := ParseRatio(jsn.vObj['defaultValueRatio']);
    if jsn.has('defaultValueReference') {a4} then
      result.defaultValue := ParseReference(jsn.vObj['defaultValueReference']);
    if jsn.has('defaultValueSampledData') {a4} then
      result.defaultValue := ParseSampledData(jsn.vObj['defaultValueSampledData']);
    if jsn.has('defaultValueSignature') {a4} then
      result.defaultValue := ParseSignature(jsn.vObj['defaultValueSignature']);
    if jsn.has('defaultValueTiming') {a4} then
      result.defaultValue := ParseTiming(jsn.vObj['defaultValueTiming']);
    if jsn.has('defaultValueContactDetail') {a4} then
      result.defaultValue := ParseContactDetail(jsn.vObj['defaultValueContactDetail']);
    if jsn.has('defaultValueContributor') {a4} then
      result.defaultValue := ParseContributor(jsn.vObj['defaultValueContributor']);
    if jsn.has('defaultValueDataRequirement') {a4} then
      result.defaultValue := ParseDataRequirement(jsn.vObj['defaultValueDataRequirement']);
    if jsn.has('defaultValueExpression') {a4} then
      result.defaultValue := ParseExpression(jsn.vObj['defaultValueExpression']);
    if jsn.has('defaultValueParameterDefinition') {a4} then
      result.defaultValue := ParseParameterDefinition(jsn.vObj['defaultValueParameterDefinition']);
    if jsn.has('defaultValueRelatedArtifact') {a4} then
      result.defaultValue := ParseRelatedArtifact(jsn.vObj['defaultValueRelatedArtifact']);
    if jsn.has('defaultValueTriggerDefinition') {a4} then
      result.defaultValue := ParseTriggerDefinition(jsn.vObj['defaultValueTriggerDefinition']);
    if jsn.has('defaultValueUsageContext') {a4} then
      result.defaultValue := ParseUsageContext(jsn.vObj['defaultValueUsageContext']);
    if jsn.has('defaultValueDosage') {a4} then
      result.defaultValue := ParseDosage(jsn.vObj['defaultValueDosage']);
    if jsn.has('defaultValueBase64Binary') or jsn.has('_defaultValueBase64Binary') then
      result.defaultValue := parseBase64Binary(jsn.node['defaultValueBase64Binary'], jsn.vObj['_defaultValueBase64Binary']);
    if jsn.has('defaultValueBoolean') or jsn.has('_defaultValueBoolean') then
      result.defaultValue := parseBoolean(jsn.node['defaultValueBoolean'], jsn.vObj['_defaultValueBoolean']);
    if jsn.has('defaultValueDate') or jsn.has('_defaultValueDate') then
      result.defaultValue := parseDate(jsn.node['defaultValueDate'], jsn.vObj['_defaultValueDate']);
    if jsn.has('defaultValueDateTime') or jsn.has('_defaultValueDateTime') then
      result.defaultValue := parseDateTime(jsn.node['defaultValueDateTime'], jsn.vObj['_defaultValueDateTime']);
    if jsn.has('defaultValueDecimal') or jsn.has('_defaultValueDecimal') then
      result.defaultValue := parseDecimal(jsn.node['defaultValueDecimal'], jsn.vObj['_defaultValueDecimal']);
    if jsn.has('defaultValueInstant') or jsn.has('_defaultValueInstant') then
      result.defaultValue := parseInstant(jsn.node['defaultValueInstant'], jsn.vObj['_defaultValueInstant']);
    if jsn.has('defaultValueInteger') or jsn.has('_defaultValueInteger') then
      result.defaultValue := parseInteger(jsn.node['defaultValueInteger'], jsn.vObj['_defaultValueInteger']);
    if jsn.has('defaultValueString') or jsn.has('_defaultValueString') then
      result.defaultValue := parseString(jsn.node['defaultValueString'], jsn.vObj['_defaultValueString']);
    if jsn.has('defaultValueTime') or jsn.has('_defaultValueTime') then
      result.defaultValue := parseTime(jsn.node['defaultValueTime'], jsn.vObj['_defaultValueTime']);
    if jsn.has('defaultValueUri') or jsn.has('_defaultValueUri') then
      result.defaultValue := parseUri(jsn.node['defaultValueUri'], jsn.vObj['_defaultValueUri']);
    if jsn.has('meaningWhenMissing') or jsn.has('_meaningWhenMissing') then
        result.meaningWhenMissingElement := parseMarkdown(jsn.node['meaningWhenMissing'], jsn.vObj['_meaningWhenMissing']);{q}
    if jsn.has('orderMeaning') or jsn.has('_orderMeaning') then
        result.orderMeaningElement := parseString(jsn.node['orderMeaning'], jsn.vObj['_orderMeaning']);{q}
    if jsn.has('fixedCanonical') or jsn.has('_fixedCanonical') then
      result.fixed := parseCanonical(jsn.node['fixedCanonical'], jsn.vObj['_fixedCanonical']);
    if jsn.has('fixedCode') or jsn.has('_fixedCode') then
      result.fixed := parseCode(jsn.node['fixedCode'], jsn.vObj['_fixedCode']);
    if jsn.has('fixedId') or jsn.has('_fixedId') then
      result.fixed := parseId(jsn.node['fixedId'], jsn.vObj['_fixedId']);
    if jsn.has('fixedMarkdown') or jsn.has('_fixedMarkdown') then
      result.fixed := parseMarkdown(jsn.node['fixedMarkdown'], jsn.vObj['_fixedMarkdown']);
    if jsn.has('fixedOid') or jsn.has('_fixedOid') then
      result.fixed := parseOid(jsn.node['fixedOid'], jsn.vObj['_fixedOid']);
    if jsn.has('fixedPositiveInt') or jsn.has('_fixedPositiveInt') then
      result.fixed := parsePositiveInt(jsn.node['fixedPositiveInt'], jsn.vObj['_fixedPositiveInt']);
    if jsn.has('fixedUnsignedInt') or jsn.has('_fixedUnsignedInt') then
      result.fixed := parseUnsignedInt(jsn.node['fixedUnsignedInt'], jsn.vObj['_fixedUnsignedInt']);
    if jsn.has('fixedUrl') or jsn.has('_fixedUrl') then
      result.fixed := parseUrl(jsn.node['fixedUrl'], jsn.vObj['_fixedUrl']);
    if jsn.has('fixedUuid') or jsn.has('_fixedUuid') then
      result.fixed := parseUuid(jsn.node['fixedUuid'], jsn.vObj['_fixedUuid']);
    if jsn.has('fixedAddress') {a4} then
      result.fixed := ParseAddress(jsn.vObj['fixedAddress']);
    if jsn.has('fixedAge') {a4} then
      result.fixed := ParseAge(jsn.vObj['fixedAge']);
    if jsn.has('fixedAnnotation') {a4} then
      result.fixed := ParseAnnotation(jsn.vObj['fixedAnnotation']);
    if jsn.has('fixedAttachment') {a4} then
      result.fixed := ParseAttachment(jsn.vObj['fixedAttachment']);
    if jsn.has('fixedCodeableConcept') {a4} then
      result.fixed := ParseCodeableConcept(jsn.vObj['fixedCodeableConcept']);
    if jsn.has('fixedCoding') {a4} then
      result.fixed := ParseCoding(jsn.vObj['fixedCoding']);
    if jsn.has('fixedContactPoint') {a4} then
      result.fixed := ParseContactPoint(jsn.vObj['fixedContactPoint']);
    if jsn.has('fixedCount') {a4} then
      result.fixed := ParseCount(jsn.vObj['fixedCount']);
    if jsn.has('fixedDistance') {a4} then
      result.fixed := ParseDistance(jsn.vObj['fixedDistance']);
    if jsn.has('fixedDuration') {a4} then
      result.fixed := ParseDuration(jsn.vObj['fixedDuration']);
    if jsn.has('fixedHumanName') {a4} then
      result.fixed := ParseHumanName(jsn.vObj['fixedHumanName']);
    if jsn.has('fixedIdentifier') {a4} then
      result.fixed := ParseIdentifier(jsn.vObj['fixedIdentifier']);
    if jsn.has('fixedMoney') {a4} then
      result.fixed := ParseMoney(jsn.vObj['fixedMoney']);
    if jsn.has('fixedPeriod') {a4} then
      result.fixed := ParsePeriod(jsn.vObj['fixedPeriod']);
    if jsn.has('fixedQuantity') {a4} then
      result.fixed := ParseQuantity(jsn.vObj['fixedQuantity']);
    if jsn.has('fixedRange') {a4} then
      result.fixed := ParseRange(jsn.vObj['fixedRange']);
    if jsn.has('fixedRatio') {a4} then
      result.fixed := ParseRatio(jsn.vObj['fixedRatio']);
    if jsn.has('fixedReference') {a4} then
      result.fixed := ParseReference(jsn.vObj['fixedReference']);
    if jsn.has('fixedSampledData') {a4} then
      result.fixed := ParseSampledData(jsn.vObj['fixedSampledData']);
    if jsn.has('fixedSignature') {a4} then
      result.fixed := ParseSignature(jsn.vObj['fixedSignature']);
    if jsn.has('fixedTiming') {a4} then
      result.fixed := ParseTiming(jsn.vObj['fixedTiming']);
    if jsn.has('fixedContactDetail') {a4} then
      result.fixed := ParseContactDetail(jsn.vObj['fixedContactDetail']);
    if jsn.has('fixedContributor') {a4} then
      result.fixed := ParseContributor(jsn.vObj['fixedContributor']);
    if jsn.has('fixedDataRequirement') {a4} then
      result.fixed := ParseDataRequirement(jsn.vObj['fixedDataRequirement']);
    if jsn.has('fixedExpression') {a4} then
      result.fixed := ParseExpression(jsn.vObj['fixedExpression']);
    if jsn.has('fixedParameterDefinition') {a4} then
      result.fixed := ParseParameterDefinition(jsn.vObj['fixedParameterDefinition']);
    if jsn.has('fixedRelatedArtifact') {a4} then
      result.fixed := ParseRelatedArtifact(jsn.vObj['fixedRelatedArtifact']);
    if jsn.has('fixedTriggerDefinition') {a4} then
      result.fixed := ParseTriggerDefinition(jsn.vObj['fixedTriggerDefinition']);
    if jsn.has('fixedUsageContext') {a4} then
      result.fixed := ParseUsageContext(jsn.vObj['fixedUsageContext']);
    if jsn.has('fixedDosage') {a4} then
      result.fixed := ParseDosage(jsn.vObj['fixedDosage']);
    if jsn.has('fixedBase64Binary') or jsn.has('_fixedBase64Binary') then
      result.fixed := parseBase64Binary(jsn.node['fixedBase64Binary'], jsn.vObj['_fixedBase64Binary']);
    if jsn.has('fixedBoolean') or jsn.has('_fixedBoolean') then
      result.fixed := parseBoolean(jsn.node['fixedBoolean'], jsn.vObj['_fixedBoolean']);
    if jsn.has('fixedDate') or jsn.has('_fixedDate') then
      result.fixed := parseDate(jsn.node['fixedDate'], jsn.vObj['_fixedDate']);
    if jsn.has('fixedDateTime') or jsn.has('_fixedDateTime') then
      result.fixed := parseDateTime(jsn.node['fixedDateTime'], jsn.vObj['_fixedDateTime']);
    if jsn.has('fixedDecimal') or jsn.has('_fixedDecimal') then
      result.fixed := parseDecimal(jsn.node['fixedDecimal'], jsn.vObj['_fixedDecimal']);
    if jsn.has('fixedInstant') or jsn.has('_fixedInstant') then
      result.fixed := parseInstant(jsn.node['fixedInstant'], jsn.vObj['_fixedInstant']);
    if jsn.has('fixedInteger') or jsn.has('_fixedInteger') then
      result.fixed := parseInteger(jsn.node['fixedInteger'], jsn.vObj['_fixedInteger']);
    if jsn.has('fixedString') or jsn.has('_fixedString') then
      result.fixed := parseString(jsn.node['fixedString'], jsn.vObj['_fixedString']);
    if jsn.has('fixedTime') or jsn.has('_fixedTime') then
      result.fixed := parseTime(jsn.node['fixedTime'], jsn.vObj['_fixedTime']);
    if jsn.has('fixedUri') or jsn.has('_fixedUri') then
      result.fixed := parseUri(jsn.node['fixedUri'], jsn.vObj['_fixedUri']);
    if jsn.has('patternCanonical') or jsn.has('_patternCanonical') then
      result.pattern := parseCanonical(jsn.node['patternCanonical'], jsn.vObj['_patternCanonical']);
    if jsn.has('patternCode') or jsn.has('_patternCode') then
      result.pattern := parseCode(jsn.node['patternCode'], jsn.vObj['_patternCode']);
    if jsn.has('patternId') or jsn.has('_patternId') then
      result.pattern := parseId(jsn.node['patternId'], jsn.vObj['_patternId']);
    if jsn.has('patternMarkdown') or jsn.has('_patternMarkdown') then
      result.pattern := parseMarkdown(jsn.node['patternMarkdown'], jsn.vObj['_patternMarkdown']);
    if jsn.has('patternOid') or jsn.has('_patternOid') then
      result.pattern := parseOid(jsn.node['patternOid'], jsn.vObj['_patternOid']);
    if jsn.has('patternPositiveInt') or jsn.has('_patternPositiveInt') then
      result.pattern := parsePositiveInt(jsn.node['patternPositiveInt'], jsn.vObj['_patternPositiveInt']);
    if jsn.has('patternUnsignedInt') or jsn.has('_patternUnsignedInt') then
      result.pattern := parseUnsignedInt(jsn.node['patternUnsignedInt'], jsn.vObj['_patternUnsignedInt']);
    if jsn.has('patternUrl') or jsn.has('_patternUrl') then
      result.pattern := parseUrl(jsn.node['patternUrl'], jsn.vObj['_patternUrl']);
    if jsn.has('patternUuid') or jsn.has('_patternUuid') then
      result.pattern := parseUuid(jsn.node['patternUuid'], jsn.vObj['_patternUuid']);
    if jsn.has('patternAddress') {a4} then
      result.pattern := ParseAddress(jsn.vObj['patternAddress']);
    if jsn.has('patternAge') {a4} then
      result.pattern := ParseAge(jsn.vObj['patternAge']);
    if jsn.has('patternAnnotation') {a4} then
      result.pattern := ParseAnnotation(jsn.vObj['patternAnnotation']);
    if jsn.has('patternAttachment') {a4} then
      result.pattern := ParseAttachment(jsn.vObj['patternAttachment']);
    if jsn.has('patternCodeableConcept') {a4} then
      result.pattern := ParseCodeableConcept(jsn.vObj['patternCodeableConcept']);
    if jsn.has('patternCoding') {a4} then
      result.pattern := ParseCoding(jsn.vObj['patternCoding']);
    if jsn.has('patternContactPoint') {a4} then
      result.pattern := ParseContactPoint(jsn.vObj['patternContactPoint']);
    if jsn.has('patternCount') {a4} then
      result.pattern := ParseCount(jsn.vObj['patternCount']);
    if jsn.has('patternDistance') {a4} then
      result.pattern := ParseDistance(jsn.vObj['patternDistance']);
    if jsn.has('patternDuration') {a4} then
      result.pattern := ParseDuration(jsn.vObj['patternDuration']);
    if jsn.has('patternHumanName') {a4} then
      result.pattern := ParseHumanName(jsn.vObj['patternHumanName']);
    if jsn.has('patternIdentifier') {a4} then
      result.pattern := ParseIdentifier(jsn.vObj['patternIdentifier']);
    if jsn.has('patternMoney') {a4} then
      result.pattern := ParseMoney(jsn.vObj['patternMoney']);
    if jsn.has('patternPeriod') {a4} then
      result.pattern := ParsePeriod(jsn.vObj['patternPeriod']);
    if jsn.has('patternQuantity') {a4} then
      result.pattern := ParseQuantity(jsn.vObj['patternQuantity']);
    if jsn.has('patternRange') {a4} then
      result.pattern := ParseRange(jsn.vObj['patternRange']);
    if jsn.has('patternRatio') {a4} then
      result.pattern := ParseRatio(jsn.vObj['patternRatio']);
    if jsn.has('patternReference') {a4} then
      result.pattern := ParseReference(jsn.vObj['patternReference']);
    if jsn.has('patternSampledData') {a4} then
      result.pattern := ParseSampledData(jsn.vObj['patternSampledData']);
    if jsn.has('patternSignature') {a4} then
      result.pattern := ParseSignature(jsn.vObj['patternSignature']);
    if jsn.has('patternTiming') {a4} then
      result.pattern := ParseTiming(jsn.vObj['patternTiming']);
    if jsn.has('patternContactDetail') {a4} then
      result.pattern := ParseContactDetail(jsn.vObj['patternContactDetail']);
    if jsn.has('patternContributor') {a4} then
      result.pattern := ParseContributor(jsn.vObj['patternContributor']);
    if jsn.has('patternDataRequirement') {a4} then
      result.pattern := ParseDataRequirement(jsn.vObj['patternDataRequirement']);
    if jsn.has('patternExpression') {a4} then
      result.pattern := ParseExpression(jsn.vObj['patternExpression']);
    if jsn.has('patternParameterDefinition') {a4} then
      result.pattern := ParseParameterDefinition(jsn.vObj['patternParameterDefinition']);
    if jsn.has('patternRelatedArtifact') {a4} then
      result.pattern := ParseRelatedArtifact(jsn.vObj['patternRelatedArtifact']);
    if jsn.has('patternTriggerDefinition') {a4} then
      result.pattern := ParseTriggerDefinition(jsn.vObj['patternTriggerDefinition']);
    if jsn.has('patternUsageContext') {a4} then
      result.pattern := ParseUsageContext(jsn.vObj['patternUsageContext']);
    if jsn.has('patternDosage') {a4} then
      result.pattern := ParseDosage(jsn.vObj['patternDosage']);
    if jsn.has('patternBase64Binary') or jsn.has('_patternBase64Binary') then
      result.pattern := parseBase64Binary(jsn.node['patternBase64Binary'], jsn.vObj['_patternBase64Binary']);
    if jsn.has('patternBoolean') or jsn.has('_patternBoolean') then
      result.pattern := parseBoolean(jsn.node['patternBoolean'], jsn.vObj['_patternBoolean']);
    if jsn.has('patternDate') or jsn.has('_patternDate') then
      result.pattern := parseDate(jsn.node['patternDate'], jsn.vObj['_patternDate']);
    if jsn.has('patternDateTime') or jsn.has('_patternDateTime') then
      result.pattern := parseDateTime(jsn.node['patternDateTime'], jsn.vObj['_patternDateTime']);
    if jsn.has('patternDecimal') or jsn.has('_patternDecimal') then
      result.pattern := parseDecimal(jsn.node['patternDecimal'], jsn.vObj['_patternDecimal']);
    if jsn.has('patternInstant') or jsn.has('_patternInstant') then
      result.pattern := parseInstant(jsn.node['patternInstant'], jsn.vObj['_patternInstant']);
    if jsn.has('patternInteger') or jsn.has('_patternInteger') then
      result.pattern := parseInteger(jsn.node['patternInteger'], jsn.vObj['_patternInteger']);
    if jsn.has('patternString') or jsn.has('_patternString') then
      result.pattern := parseString(jsn.node['patternString'], jsn.vObj['_patternString']);
    if jsn.has('patternTime') or jsn.has('_patternTime') then
      result.pattern := parseTime(jsn.node['patternTime'], jsn.vObj['_patternTime']);
    if jsn.has('patternUri') or jsn.has('_patternUri') then
      result.pattern := parseUri(jsn.node['patternUri'], jsn.vObj['_patternUri']);
    if jsn.has('example') then
      iterateArray(jsn.vArr['example'], result.exampleList, parseElementDefinitionExample);
    if jsn.has('minValuePositiveInt') or jsn.has('_minValuePositiveInt') then
      result.minValue := parsePositiveInt(jsn.node['minValuePositiveInt'], jsn.vObj['_minValuePositiveInt']);
    if jsn.has('minValueUnsignedInt') or jsn.has('_minValueUnsignedInt') then
      result.minValue := parseUnsignedInt(jsn.node['minValueUnsignedInt'], jsn.vObj['_minValueUnsignedInt']);
    if jsn.has('minValueQuantity') {a4} then
      result.minValue := ParseQuantity(jsn.vObj['minValueQuantity']);
    if jsn.has('minValueDate') or jsn.has('_minValueDate') then
      result.minValue := parseDate(jsn.node['minValueDate'], jsn.vObj['_minValueDate']);
    if jsn.has('minValueDateTime') or jsn.has('_minValueDateTime') then
      result.minValue := parseDateTime(jsn.node['minValueDateTime'], jsn.vObj['_minValueDateTime']);
    if jsn.has('minValueInstant') or jsn.has('_minValueInstant') then
      result.minValue := parseInstant(jsn.node['minValueInstant'], jsn.vObj['_minValueInstant']);
    if jsn.has('minValueTime') or jsn.has('_minValueTime') then
      result.minValue := parseTime(jsn.node['minValueTime'], jsn.vObj['_minValueTime']);
    if jsn.has('minValueDecimal') or jsn.has('_minValueDecimal') then
      result.minValue := parseDecimal(jsn.node['minValueDecimal'], jsn.vObj['_minValueDecimal']);
    if jsn.has('minValueInteger') or jsn.has('_minValueInteger') then
      result.minValue := parseInteger(jsn.node['minValueInteger'], jsn.vObj['_minValueInteger']);
    if jsn.has('maxValuePositiveInt') or jsn.has('_maxValuePositiveInt') then
      result.maxValue := parsePositiveInt(jsn.node['maxValuePositiveInt'], jsn.vObj['_maxValuePositiveInt']);
    if jsn.has('maxValueUnsignedInt') or jsn.has('_maxValueUnsignedInt') then
      result.maxValue := parseUnsignedInt(jsn.node['maxValueUnsignedInt'], jsn.vObj['_maxValueUnsignedInt']);
    if jsn.has('maxValueQuantity') {a4} then
      result.maxValue := ParseQuantity(jsn.vObj['maxValueQuantity']);
    if jsn.has('maxValueDate') or jsn.has('_maxValueDate') then
      result.maxValue := parseDate(jsn.node['maxValueDate'], jsn.vObj['_maxValueDate']);
    if jsn.has('maxValueDateTime') or jsn.has('_maxValueDateTime') then
      result.maxValue := parseDateTime(jsn.node['maxValueDateTime'], jsn.vObj['_maxValueDateTime']);
    if jsn.has('maxValueInstant') or jsn.has('_maxValueInstant') then
      result.maxValue := parseInstant(jsn.node['maxValueInstant'], jsn.vObj['_maxValueInstant']);
    if jsn.has('maxValueTime') or jsn.has('_maxValueTime') then
      result.maxValue := parseTime(jsn.node['maxValueTime'], jsn.vObj['_maxValueTime']);
    if jsn.has('maxValueDecimal') or jsn.has('_maxValueDecimal') then
      result.maxValue := parseDecimal(jsn.node['maxValueDecimal'], jsn.vObj['_maxValueDecimal']);
    if jsn.has('maxValueInteger') or jsn.has('_maxValueInteger') then
      result.maxValue := parseInteger(jsn.node['maxValueInteger'], jsn.vObj['_maxValueInteger']);
    if jsn.has('maxLength') or jsn.has('_maxLength') then
        result.maxLengthElement := parseInteger(jsn.node['maxLength'], jsn.vObj['_maxLength']);{q}
      if jsn.has('condition') or jsn.has('_condition') then
      iteratePrimitiveArray(jsn.vArr['condition'], jsn.vArr['_condition'], result.conditionList, parseId);
    if jsn.has('constraint') then
      iterateArray(jsn.vArr['constraint'], result.constraintList, parseElementDefinitionConstraint);
    if jsn.has('mustSupport') or jsn.has('_mustSupport') then
        result.mustSupportElement := parseBoolean(jsn.node['mustSupport'], jsn.vObj['_mustSupport']);{q}
    if jsn.has('isModifier') or jsn.has('_isModifier') then
        result.isModifierElement := parseBoolean(jsn.node['isModifier'], jsn.vObj['_isModifier']);{q}
    if jsn.has('isModifierReason') or jsn.has('_isModifierReason') then
        result.isModifierReasonElement := parseString(jsn.node['isModifierReason'], jsn.vObj['_isModifierReason']);{q}
    if jsn.has('isSummary') or jsn.has('_isSummary') then
        result.isSummaryElement := parseBoolean(jsn.node['isSummary'], jsn.vObj['_isSummary']);{q}
    if jsn.has('binding') then
        result.binding := ParseElementDefinitionBinding(jsn.vObj['binding']);{q3}
    if jsn.has('mapping') then
      iterateArray(jsn.vArr['mapping'], result.mappingList, parseElementDefinitionMapping);
end;

procedure TFHIRJsonComposer.ComposeElementDefinition(json : TJSONWriter; name : string; elem : TFhirElementDefinition; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneType(json, '', elem, true);
  ComposeStringValue(json, 'path', elem.pathElement, false);
  ComposeStringProps(json, 'path', elem.pathElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.representationList.Count > 0) then
  begin
    val := false;
    ext := false;
    for i := 0 to elem.representationList.Count - 1 do
    begin
      val := val or (elem.representationList[i].hasPrimitiveValue);
      ext := ext or ((elem.representationList[i].id <> '') or (elem.representationList[i].hasExtensionList));
    end;
    if val then
    begin
      json.valueArray('representation');
      for i := 0 to elem.representationList.Count - 1 do
        ComposeEnumValue(json, '', elem.representationList[i], CODES_TFhirPropertyRepresentationEnum, true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_representation');
      for i := 0 to elem.representationList.Count - 1 do
        ComposeEnumProps(json, '', elem.representationList[i], CODES_TFhirPropertyRepresentationEnum, true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'sliceName', elem.sliceNameElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'sliceName', elem.sliceNameElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBooleanValue(json, 'sliceIsConstraining', elem.sliceIsConstrainingElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBooleanProps(json, 'sliceIsConstraining', elem.sliceIsConstrainingElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'label', elem.label_Element, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'label', elem.label_Element, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.codeList.Count > 0) then
  begin
    json.valueArray('code');
    for i := 0 to elem.codeList.Count - 1 do
      ComposeCoding(json, '', elem.codeList[i]); {z - Coding}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeElementDefinitionSlicing(json, 'slicing', elem.slicing); {a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'short', elem.shortElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'short', elem.shortElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeMarkdownValue(json, 'definition', elem.definitionElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeMarkdownProps(json, 'definition', elem.definitionElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeMarkdownValue(json, 'comment', elem.commentElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeMarkdownProps(json, 'comment', elem.commentElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeMarkdownValue(json, 'requirements', elem.requirementsElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeMarkdownProps(json, 'requirements', elem.requirementsElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.aliasList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.aliasList.Count - 1 do
    begin
      ext := ext or ((elem.aliasList[i].id <> '') or (elem.aliasList[i].hasExtensionList) {no-comments or (elem.aliasList[i].hasComments)});
      val := val or (elem.aliasList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('alias');
      for i := 0 to elem.aliasList.Count - 1 do
        ComposeStringValue(json, '',elem.aliasList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_alias');
      for i := 0 to elem.aliasList.Count - 1 do
        ComposeStringProps(json, '',elem.aliasList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUnsignedIntValue(json, 'min', elem.minElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUnsignedIntProps(json, 'min', elem.minElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'max', elem.maxElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'max', elem.maxElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeElementDefinitionBase(json, 'base', elem.base); {a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUriValue(json, 'contentReference', elem.contentReferenceElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUriProps(json, 'contentReference', elem.contentReferenceElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.type_List.Count > 0) then
  begin
    json.valueArray('type');
    for i := 0 to elem.type_List.Count - 1 do
      ComposeElementDefinitionType(json, '', elem.type_List[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirCanonical) then 
  begin
    ComposeCanonicalValue(json, 'defaultValueCanonical', TFhirCanonical(elem.defaultValue), false);
    ComposeCanonicalProps(json, 'defaultValueCanonical', TFhirCanonical(elem.defaultValue), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirCode) then 
  begin
    ComposeCodeValue(json, 'defaultValueCode', TFhirCode(elem.defaultValue), false);
    ComposeCodeProps(json, 'defaultValueCode', TFhirCode(elem.defaultValue), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirId) then 
  begin
    ComposeIdValue(json, 'defaultValueId', TFhirId(elem.defaultValue), false);
    ComposeIdProps(json, 'defaultValueId', TFhirId(elem.defaultValue), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirMarkdown) then 
  begin
    ComposeMarkdownValue(json, 'defaultValueMarkdown', TFhirMarkdown(elem.defaultValue), false);
    ComposeMarkdownProps(json, 'defaultValueMarkdown', TFhirMarkdown(elem.defaultValue), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirOid) then 
  begin
    ComposeOidValue(json, 'defaultValueOid', TFhirOid(elem.defaultValue), false);
    ComposeOidProps(json, 'defaultValueOid', TFhirOid(elem.defaultValue), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirPositiveInt) then 
  begin
    ComposePositiveIntValue(json, 'defaultValuePositiveInt', TFhirPositiveInt(elem.defaultValue), false);
    ComposePositiveIntProps(json, 'defaultValuePositiveInt', TFhirPositiveInt(elem.defaultValue), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirUnsignedInt) then 
  begin
    ComposeUnsignedIntValue(json, 'defaultValueUnsignedInt', TFhirUnsignedInt(elem.defaultValue), false);
    ComposeUnsignedIntProps(json, 'defaultValueUnsignedInt', TFhirUnsignedInt(elem.defaultValue), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirUrl) then 
  begin
    ComposeUrlValue(json, 'defaultValueUrl', TFhirUrl(elem.defaultValue), false);
    ComposeUrlProps(json, 'defaultValueUrl', TFhirUrl(elem.defaultValue), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirUuid) then 
  begin
    ComposeUuidValue(json, 'defaultValueUuid', TFhirUuid(elem.defaultValue), false);
    ComposeUuidProps(json, 'defaultValueUuid', TFhirUuid(elem.defaultValue), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirAddress) then 
    ComposeAddress(json, 'defaultValueAddress', TFhirAddress(elem.defaultValue)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirAge) then 
    ComposeAge(json, 'defaultValueAge', TFhirAge(elem.defaultValue)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirAnnotation) then 
    ComposeAnnotation(json, 'defaultValueAnnotation', TFhirAnnotation(elem.defaultValue)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirAttachment) then 
    ComposeAttachment(json, 'defaultValueAttachment', TFhirAttachment(elem.defaultValue)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'defaultValueCodeableConcept', TFhirCodeableConcept(elem.defaultValue)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirCoding) then 
    ComposeCoding(json, 'defaultValueCoding', TFhirCoding(elem.defaultValue)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirContactPoint) then 
    ComposeContactPoint(json, 'defaultValueContactPoint', TFhirContactPoint(elem.defaultValue)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirCount) then 
    ComposeCount(json, 'defaultValueCount', TFhirCount(elem.defaultValue)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirDistance) then 
    ComposeDistance(json, 'defaultValueDistance', TFhirDistance(elem.defaultValue)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirDuration) then 
    ComposeDuration(json, 'defaultValueDuration', TFhirDuration(elem.defaultValue)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirHumanName) then 
    ComposeHumanName(json, 'defaultValueHumanName', TFhirHumanName(elem.defaultValue)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirIdentifier) then 
    ComposeIdentifier(json, 'defaultValueIdentifier', TFhirIdentifier(elem.defaultValue)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirMoney) then 
    ComposeMoney(json, 'defaultValueMoney', TFhirMoney(elem.defaultValue)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirPeriod) then 
    ComposePeriod(json, 'defaultValuePeriod', TFhirPeriod(elem.defaultValue)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirQuantity) then 
    ComposeQuantity(json, 'defaultValueQuantity', TFhirQuantity(elem.defaultValue)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirRange) then 
    ComposeRange(json, 'defaultValueRange', TFhirRange(elem.defaultValue)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirRatio) then 
    ComposeRatio(json, 'defaultValueRatio', TFhirRatio(elem.defaultValue)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirReference) then 
    ComposeReference(json, 'defaultValueReference', TFhirReference(elem.defaultValue)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirSampledData) then 
    ComposeSampledData(json, 'defaultValueSampledData', TFhirSampledData(elem.defaultValue)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirSignature) then 
    ComposeSignature(json, 'defaultValueSignature', TFhirSignature(elem.defaultValue)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirTiming) then 
    ComposeTiming(json, 'defaultValueTiming', TFhirTiming(elem.defaultValue)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirContactDetail) then 
    ComposeContactDetail(json, 'defaultValueContactDetail', TFhirContactDetail(elem.defaultValue)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirContributor) then 
    ComposeContributor(json, 'defaultValueContributor', TFhirContributor(elem.defaultValue)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirDataRequirement) then 
    ComposeDataRequirement(json, 'defaultValueDataRequirement', TFhirDataRequirement(elem.defaultValue)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirExpression) then 
    ComposeExpression(json, 'defaultValueExpression', TFhirExpression(elem.defaultValue)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirParameterDefinition) then 
    ComposeParameterDefinition(json, 'defaultValueParameterDefinition', TFhirParameterDefinition(elem.defaultValue)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirRelatedArtifact) then 
    ComposeRelatedArtifact(json, 'defaultValueRelatedArtifact', TFhirRelatedArtifact(elem.defaultValue)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirTriggerDefinition) then 
    ComposeTriggerDefinition(json, 'defaultValueTriggerDefinition', TFhirTriggerDefinition(elem.defaultValue)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirUsageContext) then 
    ComposeUsageContext(json, 'defaultValueUsageContext', TFhirUsageContext(elem.defaultValue)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirDosage) then 
    ComposeDosage(json, 'defaultValueDosage', TFhirDosage(elem.defaultValue)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirBase64Binary) then 
  begin
    ComposeBase64BinaryValue(json, 'defaultValueBase64Binary', TFhirBase64Binary(elem.defaultValue), false);
    ComposeBase64BinaryProps(json, 'defaultValueBase64Binary', TFhirBase64Binary(elem.defaultValue), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'defaultValueBoolean', TFhirBoolean(elem.defaultValue), false);
    ComposeBooleanProps(json, 'defaultValueBoolean', TFhirBoolean(elem.defaultValue), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirDate) then 
  begin
    ComposeDateValue(json, 'defaultValueDate', TFhirDate(elem.defaultValue), false);
    ComposeDateProps(json, 'defaultValueDate', TFhirDate(elem.defaultValue), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'defaultValueDateTime', TFhirDateTime(elem.defaultValue), false);
    ComposeDateTimeProps(json, 'defaultValueDateTime', TFhirDateTime(elem.defaultValue), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirDecimal) then 
  begin
    ComposeDecimalValue(json, 'defaultValueDecimal', TFhirDecimal(elem.defaultValue), false);
    ComposeDecimalProps(json, 'defaultValueDecimal', TFhirDecimal(elem.defaultValue), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirInstant) then 
  begin
    ComposeInstantValue(json, 'defaultValueInstant', TFhirInstant(elem.defaultValue), false);
    ComposeInstantProps(json, 'defaultValueInstant', TFhirInstant(elem.defaultValue), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirInteger) then 
  begin
    ComposeIntegerValue(json, 'defaultValueInteger', TFhirInteger(elem.defaultValue), false);
    ComposeIntegerProps(json, 'defaultValueInteger', TFhirInteger(elem.defaultValue), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirString) then 
  begin
    ComposeStringValue(json, 'defaultValueString', TFhirString(elem.defaultValue), false);
    ComposeStringProps(json, 'defaultValueString', TFhirString(elem.defaultValue), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirTime) then 
  begin
    ComposeTimeValue(json, 'defaultValueTime', TFhirTime(elem.defaultValue), false);
    ComposeTimeProps(json, 'defaultValueTime', TFhirTime(elem.defaultValue), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirUri) then 
  begin
    ComposeUriValue(json, 'defaultValueUri', TFhirUri(elem.defaultValue), false);
    ComposeUriProps(json, 'defaultValueUri', TFhirUri(elem.defaultValue), false);
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeMarkdownValue(json, 'meaningWhenMissing', elem.meaningWhenMissingElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeMarkdownProps(json, 'meaningWhenMissing', elem.meaningWhenMissingElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'orderMeaning', elem.orderMeaningElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'orderMeaning', elem.orderMeaningElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirCanonical) then 
  begin
    ComposeCanonicalValue(json, 'fixedCanonical', TFhirCanonical(elem.fixed), false);
    ComposeCanonicalProps(json, 'fixedCanonical', TFhirCanonical(elem.fixed), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirCode) then 
  begin
    ComposeCodeValue(json, 'fixedCode', TFhirCode(elem.fixed), false);
    ComposeCodeProps(json, 'fixedCode', TFhirCode(elem.fixed), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirId) then 
  begin
    ComposeIdValue(json, 'fixedId', TFhirId(elem.fixed), false);
    ComposeIdProps(json, 'fixedId', TFhirId(elem.fixed), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirMarkdown) then 
  begin
    ComposeMarkdownValue(json, 'fixedMarkdown', TFhirMarkdown(elem.fixed), false);
    ComposeMarkdownProps(json, 'fixedMarkdown', TFhirMarkdown(elem.fixed), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirOid) then 
  begin
    ComposeOidValue(json, 'fixedOid', TFhirOid(elem.fixed), false);
    ComposeOidProps(json, 'fixedOid', TFhirOid(elem.fixed), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirPositiveInt) then 
  begin
    ComposePositiveIntValue(json, 'fixedPositiveInt', TFhirPositiveInt(elem.fixed), false);
    ComposePositiveIntProps(json, 'fixedPositiveInt', TFhirPositiveInt(elem.fixed), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirUnsignedInt) then 
  begin
    ComposeUnsignedIntValue(json, 'fixedUnsignedInt', TFhirUnsignedInt(elem.fixed), false);
    ComposeUnsignedIntProps(json, 'fixedUnsignedInt', TFhirUnsignedInt(elem.fixed), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirUrl) then 
  begin
    ComposeUrlValue(json, 'fixedUrl', TFhirUrl(elem.fixed), false);
    ComposeUrlProps(json, 'fixedUrl', TFhirUrl(elem.fixed), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirUuid) then 
  begin
    ComposeUuidValue(json, 'fixedUuid', TFhirUuid(elem.fixed), false);
    ComposeUuidProps(json, 'fixedUuid', TFhirUuid(elem.fixed), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirAddress) then 
    ComposeAddress(json, 'fixedAddress', TFhirAddress(elem.fixed)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirAge) then 
    ComposeAge(json, 'fixedAge', TFhirAge(elem.fixed)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirAnnotation) then 
    ComposeAnnotation(json, 'fixedAnnotation', TFhirAnnotation(elem.fixed)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirAttachment) then 
    ComposeAttachment(json, 'fixedAttachment', TFhirAttachment(elem.fixed)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'fixedCodeableConcept', TFhirCodeableConcept(elem.fixed)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirCoding) then 
    ComposeCoding(json, 'fixedCoding', TFhirCoding(elem.fixed)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirContactPoint) then 
    ComposeContactPoint(json, 'fixedContactPoint', TFhirContactPoint(elem.fixed)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirCount) then 
    ComposeCount(json, 'fixedCount', TFhirCount(elem.fixed)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirDistance) then 
    ComposeDistance(json, 'fixedDistance', TFhirDistance(elem.fixed)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirDuration) then 
    ComposeDuration(json, 'fixedDuration', TFhirDuration(elem.fixed)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirHumanName) then 
    ComposeHumanName(json, 'fixedHumanName', TFhirHumanName(elem.fixed)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirIdentifier) then 
    ComposeIdentifier(json, 'fixedIdentifier', TFhirIdentifier(elem.fixed)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirMoney) then 
    ComposeMoney(json, 'fixedMoney', TFhirMoney(elem.fixed)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirPeriod) then 
    ComposePeriod(json, 'fixedPeriod', TFhirPeriod(elem.fixed)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirQuantity) then 
    ComposeQuantity(json, 'fixedQuantity', TFhirQuantity(elem.fixed)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirRange) then 
    ComposeRange(json, 'fixedRange', TFhirRange(elem.fixed)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirRatio) then 
    ComposeRatio(json, 'fixedRatio', TFhirRatio(elem.fixed)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirReference) then 
    ComposeReference(json, 'fixedReference', TFhirReference(elem.fixed)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirSampledData) then 
    ComposeSampledData(json, 'fixedSampledData', TFhirSampledData(elem.fixed)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirSignature) then 
    ComposeSignature(json, 'fixedSignature', TFhirSignature(elem.fixed)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirTiming) then 
    ComposeTiming(json, 'fixedTiming', TFhirTiming(elem.fixed)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirContactDetail) then 
    ComposeContactDetail(json, 'fixedContactDetail', TFhirContactDetail(elem.fixed)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirContributor) then 
    ComposeContributor(json, 'fixedContributor', TFhirContributor(elem.fixed)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirDataRequirement) then 
    ComposeDataRequirement(json, 'fixedDataRequirement', TFhirDataRequirement(elem.fixed)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirExpression) then 
    ComposeExpression(json, 'fixedExpression', TFhirExpression(elem.fixed)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirParameterDefinition) then 
    ComposeParameterDefinition(json, 'fixedParameterDefinition', TFhirParameterDefinition(elem.fixed)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirRelatedArtifact) then 
    ComposeRelatedArtifact(json, 'fixedRelatedArtifact', TFhirRelatedArtifact(elem.fixed)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirTriggerDefinition) then 
    ComposeTriggerDefinition(json, 'fixedTriggerDefinition', TFhirTriggerDefinition(elem.fixed)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirUsageContext) then 
    ComposeUsageContext(json, 'fixedUsageContext', TFhirUsageContext(elem.fixed)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirDosage) then 
    ComposeDosage(json, 'fixedDosage', TFhirDosage(elem.fixed)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirBase64Binary) then 
  begin
    ComposeBase64BinaryValue(json, 'fixedBase64Binary', TFhirBase64Binary(elem.fixed), false);
    ComposeBase64BinaryProps(json, 'fixedBase64Binary', TFhirBase64Binary(elem.fixed), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'fixedBoolean', TFhirBoolean(elem.fixed), false);
    ComposeBooleanProps(json, 'fixedBoolean', TFhirBoolean(elem.fixed), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirDate) then 
  begin
    ComposeDateValue(json, 'fixedDate', TFhirDate(elem.fixed), false);
    ComposeDateProps(json, 'fixedDate', TFhirDate(elem.fixed), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'fixedDateTime', TFhirDateTime(elem.fixed), false);
    ComposeDateTimeProps(json, 'fixedDateTime', TFhirDateTime(elem.fixed), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirDecimal) then 
  begin
    ComposeDecimalValue(json, 'fixedDecimal', TFhirDecimal(elem.fixed), false);
    ComposeDecimalProps(json, 'fixedDecimal', TFhirDecimal(elem.fixed), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirInstant) then 
  begin
    ComposeInstantValue(json, 'fixedInstant', TFhirInstant(elem.fixed), false);
    ComposeInstantProps(json, 'fixedInstant', TFhirInstant(elem.fixed), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirInteger) then 
  begin
    ComposeIntegerValue(json, 'fixedInteger', TFhirInteger(elem.fixed), false);
    ComposeIntegerProps(json, 'fixedInteger', TFhirInteger(elem.fixed), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirString) then 
  begin
    ComposeStringValue(json, 'fixedString', TFhirString(elem.fixed), false);
    ComposeStringProps(json, 'fixedString', TFhirString(elem.fixed), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirTime) then 
  begin
    ComposeTimeValue(json, 'fixedTime', TFhirTime(elem.fixed), false);
    ComposeTimeProps(json, 'fixedTime', TFhirTime(elem.fixed), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirUri) then 
  begin
    ComposeUriValue(json, 'fixedUri', TFhirUri(elem.fixed), false);
    ComposeUriProps(json, 'fixedUri', TFhirUri(elem.fixed), false);
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirCanonical) then 
  begin
    ComposeCanonicalValue(json, 'patternCanonical', TFhirCanonical(elem.pattern), false);
    ComposeCanonicalProps(json, 'patternCanonical', TFhirCanonical(elem.pattern), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirCode) then 
  begin
    ComposeCodeValue(json, 'patternCode', TFhirCode(elem.pattern), false);
    ComposeCodeProps(json, 'patternCode', TFhirCode(elem.pattern), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirId) then 
  begin
    ComposeIdValue(json, 'patternId', TFhirId(elem.pattern), false);
    ComposeIdProps(json, 'patternId', TFhirId(elem.pattern), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirMarkdown) then 
  begin
    ComposeMarkdownValue(json, 'patternMarkdown', TFhirMarkdown(elem.pattern), false);
    ComposeMarkdownProps(json, 'patternMarkdown', TFhirMarkdown(elem.pattern), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirOid) then 
  begin
    ComposeOidValue(json, 'patternOid', TFhirOid(elem.pattern), false);
    ComposeOidProps(json, 'patternOid', TFhirOid(elem.pattern), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirPositiveInt) then 
  begin
    ComposePositiveIntValue(json, 'patternPositiveInt', TFhirPositiveInt(elem.pattern), false);
    ComposePositiveIntProps(json, 'patternPositiveInt', TFhirPositiveInt(elem.pattern), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirUnsignedInt) then 
  begin
    ComposeUnsignedIntValue(json, 'patternUnsignedInt', TFhirUnsignedInt(elem.pattern), false);
    ComposeUnsignedIntProps(json, 'patternUnsignedInt', TFhirUnsignedInt(elem.pattern), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirUrl) then 
  begin
    ComposeUrlValue(json, 'patternUrl', TFhirUrl(elem.pattern), false);
    ComposeUrlProps(json, 'patternUrl', TFhirUrl(elem.pattern), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirUuid) then 
  begin
    ComposeUuidValue(json, 'patternUuid', TFhirUuid(elem.pattern), false);
    ComposeUuidProps(json, 'patternUuid', TFhirUuid(elem.pattern), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirAddress) then 
    ComposeAddress(json, 'patternAddress', TFhirAddress(elem.pattern)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirAge) then 
    ComposeAge(json, 'patternAge', TFhirAge(elem.pattern)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirAnnotation) then 
    ComposeAnnotation(json, 'patternAnnotation', TFhirAnnotation(elem.pattern)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirAttachment) then 
    ComposeAttachment(json, 'patternAttachment', TFhirAttachment(elem.pattern)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'patternCodeableConcept', TFhirCodeableConcept(elem.pattern)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirCoding) then 
    ComposeCoding(json, 'patternCoding', TFhirCoding(elem.pattern)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirContactPoint) then 
    ComposeContactPoint(json, 'patternContactPoint', TFhirContactPoint(elem.pattern)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirCount) then 
    ComposeCount(json, 'patternCount', TFhirCount(elem.pattern)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirDistance) then 
    ComposeDistance(json, 'patternDistance', TFhirDistance(elem.pattern)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirDuration) then 
    ComposeDuration(json, 'patternDuration', TFhirDuration(elem.pattern)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirHumanName) then 
    ComposeHumanName(json, 'patternHumanName', TFhirHumanName(elem.pattern)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirIdentifier) then 
    ComposeIdentifier(json, 'patternIdentifier', TFhirIdentifier(elem.pattern)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirMoney) then 
    ComposeMoney(json, 'patternMoney', TFhirMoney(elem.pattern)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirPeriod) then 
    ComposePeriod(json, 'patternPeriod', TFhirPeriod(elem.pattern)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirQuantity) then 
    ComposeQuantity(json, 'patternQuantity', TFhirQuantity(elem.pattern)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirRange) then 
    ComposeRange(json, 'patternRange', TFhirRange(elem.pattern)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirRatio) then 
    ComposeRatio(json, 'patternRatio', TFhirRatio(elem.pattern)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirReference) then 
    ComposeReference(json, 'patternReference', TFhirReference(elem.pattern)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirSampledData) then 
    ComposeSampledData(json, 'patternSampledData', TFhirSampledData(elem.pattern)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirSignature) then 
    ComposeSignature(json, 'patternSignature', TFhirSignature(elem.pattern)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirTiming) then 
    ComposeTiming(json, 'patternTiming', TFhirTiming(elem.pattern)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirContactDetail) then 
    ComposeContactDetail(json, 'patternContactDetail', TFhirContactDetail(elem.pattern)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirContributor) then 
    ComposeContributor(json, 'patternContributor', TFhirContributor(elem.pattern)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirDataRequirement) then 
    ComposeDataRequirement(json, 'patternDataRequirement', TFhirDataRequirement(elem.pattern)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirExpression) then 
    ComposeExpression(json, 'patternExpression', TFhirExpression(elem.pattern)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirParameterDefinition) then 
    ComposeParameterDefinition(json, 'patternParameterDefinition', TFhirParameterDefinition(elem.pattern)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirRelatedArtifact) then 
    ComposeRelatedArtifact(json, 'patternRelatedArtifact', TFhirRelatedArtifact(elem.pattern)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirTriggerDefinition) then 
    ComposeTriggerDefinition(json, 'patternTriggerDefinition', TFhirTriggerDefinition(elem.pattern)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirUsageContext) then 
    ComposeUsageContext(json, 'patternUsageContext', TFhirUsageContext(elem.pattern)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirDosage) then 
    ComposeDosage(json, 'patternDosage', TFhirDosage(elem.pattern)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirBase64Binary) then 
  begin
    ComposeBase64BinaryValue(json, 'patternBase64Binary', TFhirBase64Binary(elem.pattern), false);
    ComposeBase64BinaryProps(json, 'patternBase64Binary', TFhirBase64Binary(elem.pattern), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'patternBoolean', TFhirBoolean(elem.pattern), false);
    ComposeBooleanProps(json, 'patternBoolean', TFhirBoolean(elem.pattern), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirDate) then 
  begin
    ComposeDateValue(json, 'patternDate', TFhirDate(elem.pattern), false);
    ComposeDateProps(json, 'patternDate', TFhirDate(elem.pattern), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'patternDateTime', TFhirDateTime(elem.pattern), false);
    ComposeDateTimeProps(json, 'patternDateTime', TFhirDateTime(elem.pattern), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirDecimal) then 
  begin
    ComposeDecimalValue(json, 'patternDecimal', TFhirDecimal(elem.pattern), false);
    ComposeDecimalProps(json, 'patternDecimal', TFhirDecimal(elem.pattern), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirInstant) then 
  begin
    ComposeInstantValue(json, 'patternInstant', TFhirInstant(elem.pattern), false);
    ComposeInstantProps(json, 'patternInstant', TFhirInstant(elem.pattern), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirInteger) then 
  begin
    ComposeIntegerValue(json, 'patternInteger', TFhirInteger(elem.pattern), false);
    ComposeIntegerProps(json, 'patternInteger', TFhirInteger(elem.pattern), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirString) then 
  begin
    ComposeStringValue(json, 'patternString', TFhirString(elem.pattern), false);
    ComposeStringProps(json, 'patternString', TFhirString(elem.pattern), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirTime) then 
  begin
    ComposeTimeValue(json, 'patternTime', TFhirTime(elem.pattern), false);
    ComposeTimeProps(json, 'patternTime', TFhirTime(elem.pattern), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirUri) then 
  begin
    ComposeUriValue(json, 'patternUri', TFhirUri(elem.pattern), false);
    ComposeUriProps(json, 'patternUri', TFhirUri(elem.pattern), false);
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.exampleList.Count > 0) then
  begin
    json.valueArray('example');
    for i := 0 to elem.exampleList.Count - 1 do
      ComposeElementDefinitionExample(json, '', elem.exampleList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirPositiveInt) then 
  begin
    ComposePositiveIntValue(json, 'minValuePositiveInt', TFhirPositiveInt(elem.minValue), false);
    ComposePositiveIntProps(json, 'minValuePositiveInt', TFhirPositiveInt(elem.minValue), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirUnsignedInt) then 
  begin
    ComposeUnsignedIntValue(json, 'minValueUnsignedInt', TFhirUnsignedInt(elem.minValue), false);
    ComposeUnsignedIntProps(json, 'minValueUnsignedInt', TFhirUnsignedInt(elem.minValue), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirQuantity) then 
    ComposeQuantity(json, 'minValueQuantity', TFhirQuantity(elem.minValue)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirDate) then 
  begin
    ComposeDateValue(json, 'minValueDate', TFhirDate(elem.minValue), false);
    ComposeDateProps(json, 'minValueDate', TFhirDate(elem.minValue), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'minValueDateTime', TFhirDateTime(elem.minValue), false);
    ComposeDateTimeProps(json, 'minValueDateTime', TFhirDateTime(elem.minValue), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirInstant) then 
  begin
    ComposeInstantValue(json, 'minValueInstant', TFhirInstant(elem.minValue), false);
    ComposeInstantProps(json, 'minValueInstant', TFhirInstant(elem.minValue), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirTime) then 
  begin
    ComposeTimeValue(json, 'minValueTime', TFhirTime(elem.minValue), false);
    ComposeTimeProps(json, 'minValueTime', TFhirTime(elem.minValue), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirDecimal) then 
  begin
    ComposeDecimalValue(json, 'minValueDecimal', TFhirDecimal(elem.minValue), false);
    ComposeDecimalProps(json, 'minValueDecimal', TFhirDecimal(elem.minValue), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirInteger) then 
  begin
    ComposeIntegerValue(json, 'minValueInteger', TFhirInteger(elem.minValue), false);
    ComposeIntegerProps(json, 'minValueInteger', TFhirInteger(elem.minValue), false);
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirPositiveInt) then 
  begin
    ComposePositiveIntValue(json, 'maxValuePositiveInt', TFhirPositiveInt(elem.maxValue), false);
    ComposePositiveIntProps(json, 'maxValuePositiveInt', TFhirPositiveInt(elem.maxValue), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirUnsignedInt) then 
  begin
    ComposeUnsignedIntValue(json, 'maxValueUnsignedInt', TFhirUnsignedInt(elem.maxValue), false);
    ComposeUnsignedIntProps(json, 'maxValueUnsignedInt', TFhirUnsignedInt(elem.maxValue), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirQuantity) then 
    ComposeQuantity(json, 'maxValueQuantity', TFhirQuantity(elem.maxValue)) 
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirDate) then 
  begin
    ComposeDateValue(json, 'maxValueDate', TFhirDate(elem.maxValue), false);
    ComposeDateProps(json, 'maxValueDate', TFhirDate(elem.maxValue), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'maxValueDateTime', TFhirDateTime(elem.maxValue), false);
    ComposeDateTimeProps(json, 'maxValueDateTime', TFhirDateTime(elem.maxValue), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirInstant) then 
  begin
    ComposeInstantValue(json, 'maxValueInstant', TFhirInstant(elem.maxValue), false);
    ComposeInstantProps(json, 'maxValueInstant', TFhirInstant(elem.maxValue), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirTime) then 
  begin
    ComposeTimeValue(json, 'maxValueTime', TFhirTime(elem.maxValue), false);
    ComposeTimeProps(json, 'maxValueTime', TFhirTime(elem.maxValue), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirDecimal) then 
  begin
    ComposeDecimalValue(json, 'maxValueDecimal', TFhirDecimal(elem.maxValue), false);
    ComposeDecimalProps(json, 'maxValueDecimal', TFhirDecimal(elem.maxValue), false);
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirInteger) then 
  begin
    ComposeIntegerValue(json, 'maxValueInteger', TFhirInteger(elem.maxValue), false);
    ComposeIntegerProps(json, 'maxValueInteger', TFhirInteger(elem.maxValue), false);
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeIntegerValue(json, 'maxLength', elem.maxLengthElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeIntegerProps(json, 'maxLength', elem.maxLengthElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.conditionList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.conditionList.Count - 1 do
    begin
      ext := ext or ((elem.conditionList[i].id <> '') or (elem.conditionList[i].hasExtensionList) {no-comments or (elem.conditionList[i].hasComments)});
      val := val or (elem.conditionList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('condition');
      for i := 0 to elem.conditionList.Count - 1 do
        ComposeIdValue(json, '',elem.conditionList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_condition');
      for i := 0 to elem.conditionList.Count - 1 do
        ComposeIdProps(json, '',elem.conditionList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.constraintList.Count > 0) then
  begin
    json.valueArray('constraint');
    for i := 0 to elem.constraintList.Count - 1 do
      ComposeElementDefinitionConstraint(json, '', elem.constraintList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBooleanValue(json, 'mustSupport', elem.mustSupportElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBooleanProps(json, 'mustSupport', elem.mustSupportElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBooleanValue(json, 'isModifier', elem.isModifierElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBooleanProps(json, 'isModifier', elem.isModifierElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'isModifierReason', elem.isModifierReasonElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'isModifierReason', elem.isModifierReasonElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBooleanValue(json, 'isSummary', elem.isSummaryElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBooleanProps(json, 'isSummary', elem.isSummaryElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeElementDefinitionBinding(json, 'binding', elem.binding); {a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.mappingList.Count > 0) then
  begin
    json.valueArray('mapping');
    for i := 0 to elem.mappingList.Count - 1 do
      ComposeElementDefinitionMapping(json, '', elem.mappingList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseTimingRepeat(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTimingRepeat(jsn)); {2}
end;

function TFHIRJsonParser.ParseTimingRepeat(jsn : TJsonObject) : TFhirTimingRepeat;
begin
  result := TFhirTimingRepeat.create;
  try
    ParseTimingRepeatProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseTimingRepeatProperties(jsn : TJsonObject; result : TFhirTimingRepeat);
begin
    ParseElementProperties(jsn, result);
    if jsn.has('boundsDuration') {a4} then
      result.bounds := ParseDuration(jsn.vObj['boundsDuration']);
    if jsn.has('boundsRange') {a4} then
      result.bounds := ParseRange(jsn.vObj['boundsRange']);
    if jsn.has('boundsPeriod') {a4} then
      result.bounds := ParsePeriod(jsn.vObj['boundsPeriod']);
    if jsn.has('count') or jsn.has('_count') then
        result.countElement := parsePositiveInt(jsn.node['count'], jsn.vObj['_count']);{q}
    if jsn.has('countMax') or jsn.has('_countMax') then
        result.countMaxElement := parsePositiveInt(jsn.node['countMax'], jsn.vObj['_countMax']);{q}
    if jsn.has('duration') or jsn.has('_duration') then
        result.durationElement := parseDecimal(jsn.node['duration'], jsn.vObj['_duration']);{q}
    if jsn.has('durationMax') or jsn.has('_durationMax') then
        result.durationMaxElement := parseDecimal(jsn.node['durationMax'], jsn.vObj['_durationMax']);{q}
    if jsn.has('durationUnit') or jsn.has('_durationUnit')  then
      result.durationUnitElement := parseEnum(jsn.path+'/durationUnit', jsn.node['durationUnit'], jsn.vObj['_durationUnit'], CODES_TFhirUnitsOfTimeEnum, SYSTEMS_TFhirUnitsOfTimeEnum);
    if jsn.has('frequency') or jsn.has('_frequency') then
        result.frequencyElement := parsePositiveInt(jsn.node['frequency'], jsn.vObj['_frequency']);{q}
    if jsn.has('frequencyMax') or jsn.has('_frequencyMax') then
        result.frequencyMaxElement := parsePositiveInt(jsn.node['frequencyMax'], jsn.vObj['_frequencyMax']);{q}
    if jsn.has('period') or jsn.has('_period') then
        result.periodElement := parseDecimal(jsn.node['period'], jsn.vObj['_period']);{q}
    if jsn.has('periodMax') or jsn.has('_periodMax') then
        result.periodMaxElement := parseDecimal(jsn.node['periodMax'], jsn.vObj['_periodMax']);{q}
    if jsn.has('periodUnit') or jsn.has('_periodUnit')  then
      result.periodUnitElement := parseEnum(jsn.path+'/periodUnit', jsn.node['periodUnit'], jsn.vObj['_periodUnit'], CODES_TFhirUnitsOfTimeEnum, SYSTEMS_TFhirUnitsOfTimeEnum);
    if jsn.has('dayOfWeek') or jsn.has('_dayOfWeek') then
      iterateEnumArray(jsn.vArr['dayOfWeek'], jsn.vArr['_dayOfWeek'], jsn.path+'/dayOfWeek', result.dayOfWeekList, parseEnum, CODES_TFhirDaysOfWeekEnum, SYSTEMS_TFhirDaysOfWeekEnum);
      if jsn.has('timeOfDay') or jsn.has('_timeOfDay') then
      iteratePrimitiveArray(jsn.vArr['timeOfDay'], jsn.vArr['_timeOfDay'], result.timeOfDayList, parseTime);
    if jsn.has('when') or jsn.has('_when') then
      iterateEnumArray(jsn.vArr['when'], jsn.vArr['_when'], jsn.path+'/when', result.whenList, parseEnum, CODES_TFhirEventTimingEnum, SYSTEMS_TFhirEventTimingEnum);
    if jsn.has('offset') or jsn.has('_offset') then
        result.offsetElement := parseUnsignedInt(jsn.node['offset'], jsn.vObj['_offset']);{q}
end;

procedure TFHIRJsonComposer.ComposeTimingRepeat(json : TJSONWriter; name : string; elem : TFhirTimingRepeat; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.bounds is TFhirDuration) then 
    ComposeDuration(json, 'boundsDuration', TFhirDuration(elem.bounds)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.bounds is TFhirRange) then 
    ComposeRange(json, 'boundsRange', TFhirRange(elem.bounds)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.bounds is TFhirPeriod) then 
    ComposePeriod(json, 'boundsPeriod', TFhirPeriod(elem.bounds)) ;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveIntValue(json, 'count', elem.countElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveIntProps(json, 'count', elem.countElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveIntValue(json, 'countMax', elem.countMaxElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveIntProps(json, 'countMax', elem.countMaxElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalValue(json, 'duration', elem.durationElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalProps(json, 'duration', elem.durationElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalValue(json, 'durationMax', elem.durationMaxElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalProps(json, 'durationMax', elem.durationMaxElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnumValue(json, 'durationUnit', elem.DurationUnitElement, CODES_TFhirUnitsOfTimeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnumProps(json, 'durationUnit', elem.DurationUnitElement, CODES_TFhirUnitsOfTimeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveIntValue(json, 'frequency', elem.frequencyElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveIntProps(json, 'frequency', elem.frequencyElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveIntValue(json, 'frequencyMax', elem.frequencyMaxElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveIntProps(json, 'frequencyMax', elem.frequencyMaxElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalValue(json, 'period', elem.periodElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalProps(json, 'period', elem.periodElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalValue(json, 'periodMax', elem.periodMaxElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalProps(json, 'periodMax', elem.periodMaxElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnumValue(json, 'periodUnit', elem.PeriodUnitElement, CODES_TFhirUnitsOfTimeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnumProps(json, 'periodUnit', elem.PeriodUnitElement, CODES_TFhirUnitsOfTimeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.dayOfWeekList.Count > 0) then
  begin
    val := false;
    ext := false;
    for i := 0 to elem.dayOfWeekList.Count - 1 do
    begin
      val := val or (elem.dayOfWeekList[i].hasPrimitiveValue);
      ext := ext or ((elem.dayOfWeekList[i].id <> '') or (elem.dayOfWeekList[i].hasExtensionList));
    end;
    if val then
    begin
      json.valueArray('dayOfWeek');
      for i := 0 to elem.dayOfWeekList.Count - 1 do
        ComposeEnumValue(json, '', elem.dayOfWeekList[i], CODES_TFhirDaysOfWeekEnum, true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_dayOfWeek');
      for i := 0 to elem.dayOfWeekList.Count - 1 do
        ComposeEnumProps(json, '', elem.dayOfWeekList[i], CODES_TFhirDaysOfWeekEnum, true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.timeOfDayList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.timeOfDayList.Count - 1 do
    begin
      ext := ext or ((elem.timeOfDayList[i].id <> '') or (elem.timeOfDayList[i].hasExtensionList) {no-comments or (elem.timeOfDayList[i].hasComments)});
      val := val or (elem.timeOfDayList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('timeOfDay');
      for i := 0 to elem.timeOfDayList.Count - 1 do
        ComposeTimeValue(json, '',elem.timeOfDayList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_timeOfDay');
      for i := 0 to elem.timeOfDayList.Count - 1 do
        ComposeTimeProps(json, '',elem.timeOfDayList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.whenList.Count > 0) then
  begin
    val := false;
    ext := false;
    for i := 0 to elem.whenList.Count - 1 do
    begin
      val := val or (elem.whenList[i].hasPrimitiveValue);
      ext := ext or ((elem.whenList[i].id <> '') or (elem.whenList[i].hasExtensionList));
    end;
    if val then
    begin
      json.valueArray('when');
      for i := 0 to elem.whenList.Count - 1 do
        ComposeEnumValue(json, '', elem.whenList[i], CODES_TFhirEventTimingEnum, true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_when');
      for i := 0 to elem.whenList.Count - 1 do
        ComposeEnumProps(json, '', elem.whenList[i], CODES_TFhirEventTimingEnum, true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedIntValue(json, 'offset', elem.offsetElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedIntProps(json, 'offset', elem.offsetElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseTiming(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTiming(jsn)); {2}
end;

function TFHIRJsonParser.ParseTiming(jsn : TJsonObject) : TFhirTiming;
begin
  result := TFhirTiming.create;
  try
    ParseTimingProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseTimingProperties(jsn : TJsonObject; result : TFhirTiming);
begin
    ParseBackboneElementProperties(jsn, result);
      if jsn.has('event') or jsn.has('_event') then
      iteratePrimitiveArray(jsn.vArr['event'], jsn.vArr['_event'], result.eventList, parseDateTime);
    if jsn.has('repeat') then
        result.repeat_ := ParseTimingRepeat(jsn.vObj['repeat']);{q3}
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
end;

procedure TFHIRJsonComposer.ComposeTiming(json : TJSONWriter; name : string; elem : TFhirTiming; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneType(json, '', elem, true);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.eventList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.eventList.Count - 1 do
    begin
      ext := ext or ((elem.eventList[i].id <> '') or (elem.eventList[i].hasExtensionList) {no-comments or (elem.eventList[i].hasComments)});
      val := val or (elem.eventList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('event');
      for i := 0 to elem.eventList.Count - 1 do
        ComposeDateTimeValue(json, '',elem.eventList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_event');
      for i := 0 to elem.eventList.Count - 1 do
        ComposeDateTimeProps(json, '',elem.eventList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeTimingRepeat(json, 'repeat', elem.repeat_); {a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeableConcept(json, 'code', elem.code); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseCount(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCount(jsn)); {2}
end;

function TFHIRJsonParser.ParseCount(jsn : TJsonObject) : TFhirCount;
begin
  result := TFhirCount.create;
  try
    ParseCountProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCountProperties(jsn : TJsonObject; result : TFhirCount);
begin
    ParseQuantityProperties(jsn, result);
end;

procedure TFHIRJsonComposer.ComposeCount(json : TJSONWriter; name : string; elem : TFhirCount; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeQuantity(json, '', elem, true);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseAge(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAge(jsn)); {2}
end;

function TFHIRJsonParser.ParseAge(jsn : TJsonObject) : TFhirAge;
begin
  result := TFhirAge.create;
  try
    ParseAgeProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseAgeProperties(jsn : TJsonObject; result : TFhirAge);
begin
    ParseQuantityProperties(jsn, result);
end;

procedure TFHIRJsonComposer.ComposeAge(json : TJSONWriter; name : string; elem : TFhirAge; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeQuantity(json, '', elem, true);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseDistance(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDistance(jsn)); {2}
end;

function TFHIRJsonParser.ParseDistance(jsn : TJsonObject) : TFhirDistance;
begin
  result := TFhirDistance.create;
  try
    ParseDistanceProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseDistanceProperties(jsn : TJsonObject; result : TFhirDistance);
begin
    ParseQuantityProperties(jsn, result);
end;

procedure TFHIRJsonComposer.ComposeDistance(json : TJSONWriter; name : string; elem : TFhirDistance; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeQuantity(json, '', elem, true);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseDuration(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDuration(jsn)); {2}
end;

function TFHIRJsonParser.ParseDuration(jsn : TJsonObject) : TFhirDuration;
begin
  result := TFhirDuration.create;
  try
    ParseDurationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseDurationProperties(jsn : TJsonObject; result : TFhirDuration);
begin
    ParseQuantityProperties(jsn, result);
end;

procedure TFHIRJsonComposer.ComposeDuration(json : TJSONWriter; name : string; elem : TFhirDuration; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeQuantity(json, '', elem, true);
  if not noObj then json.finishObject;
end;

{$IFDEF FHIR_ACCOUNT}
procedure TFHIRJsonParser.ParseAccountCoverage(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAccountCoverage(jsn)); {2}
end;

function TFHIRJsonParser.ParseAccountCoverage(jsn : TJsonObject) : TFhirAccountCoverage;
begin
  result := TFhirAccountCoverage.create;
  try
    ParseAccountCoverageProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseAccountCoverageProperties(jsn : TJsonObject; result : TFhirAccountCoverage);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('coverage') then
        result.coverage := ParseReference{TFhirCoverage}(jsn.vObj['coverage']);{q3}
    if jsn.has('priority') or jsn.has('_priority') then
        result.priorityElement := parsePositiveInt(jsn.node['priority'], jsn.vObj['_priority']);{q}
end;

procedure TFHIRJsonComposer.ComposeAccountCoverage(json : TJSONWriter; name : string; elem : TFhirAccountCoverage; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeReference{TFhirCoverage}(json, 'coverage', elem.coverage); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveIntValue(json, 'priority', elem.priorityElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveIntProps(json, 'priority', elem.priorityElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseAccountGuarantor(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAccountGuarantor(jsn)); {2}
end;

function TFHIRJsonParser.ParseAccountGuarantor(jsn : TJsonObject) : TFhirAccountGuarantor;
begin
  result := TFhirAccountGuarantor.create;
  try
    ParseAccountGuarantorProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseAccountGuarantorProperties(jsn : TJsonObject; result : TFhirAccountGuarantor);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('party') then
        result.party := ParseReference{TFhirPatient}(jsn.vObj['party']);{q3}
    if jsn.has('onHold') or jsn.has('_onHold') then
        result.onHoldElement := parseBoolean(jsn.node['onHold'], jsn.vObj['_onHold']);{q}
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q3}
end;

procedure TFHIRJsonComposer.ComposeAccountGuarantor(json : TJSONWriter; name : string; elem : TFhirAccountGuarantor; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeReference{TFhirPatient}(json, 'party', elem.party); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'onHold', elem.onHoldElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'onHold', elem.onHoldElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(json, 'period', elem.period); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseAccount(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAccount(jsn)); {2}
end;

function TFHIRJsonParser.ParseAccount(jsn : TJsonObject) : TFhirAccount;
begin
  result := TFhirAccount.create;
  try
    ParseAccountProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseAccountProperties(jsn : TJsonObject; result : TFhirAccount);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirAccountStatusEnum, SYSTEMS_TFhirAccountStatusEnum);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('subject') then
      iterateArray(jsn.vArr['subject'], result.subjectList, parseReference{TFhirPatient});
    if jsn.has('servicePeriod') then
        result.servicePeriod := ParsePeriod(jsn.vObj['servicePeriod']);{q3}
    if jsn.has('coverage') then
      iterateArray(jsn.vArr['coverage'], result.coverageList, parseAccountCoverage);
    if jsn.has('owner') then
        result.owner := ParseReference{TFhirOrganization}(jsn.vObj['owner']);{q3}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('guarantor') then
      iterateArray(jsn.vArr['guarantor'], result.guarantorList, parseAccountGuarantor);
    if jsn.has('partOf') then
        result.partOf := ParseReference{TFhirAccount}(jsn.vObj['partOf']);{q3}
end;

procedure TFHIRJsonComposer.ComposeAccount(json : TJSONWriter; name : string; elem : TFhirAccount; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirAccountStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirAccountStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') and (elem.subjectList.Count > 0) then
  begin
    json.valueArray('subject');
    for i := 0 to elem.subjectList.Count - 1 do
      ComposeReference{TFhirPatient}(json, '', elem.subjectList[i]); {z - Reference(Patient)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('servicePeriod') then
    ComposePeriod(json, 'servicePeriod', elem.servicePeriod); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('coverage') and (elem.coverageList.Count > 0) then
  begin
    json.valueArray('coverage');
    for i := 0 to elem.coverageList.Count - 1 do
      ComposeAccountCoverage(json, '', elem.coverageList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('owner') then
    ComposeReference{TFhirOrganization}(json, 'owner', elem.owner); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('guarantor') and (elem.guarantorList.Count > 0) then
  begin
    json.valueArray('guarantor');
    for i := 0 to elem.guarantorList.Count - 1 do
      ComposeAccountGuarantor(json, '', elem.guarantorList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('partOf') then
    ComposeReference{TFhirAccount}(json, 'partOf', elem.partOf); {a}
end;

{$ENDIF FHIR_ACCOUNT}
{$IFDEF FHIR_ACTIVITYDEFINITION}
procedure TFHIRJsonParser.ParseActivityDefinitionParticipant(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseActivityDefinitionParticipant(jsn)); {2}
end;

function TFHIRJsonParser.ParseActivityDefinitionParticipant(jsn : TJsonObject) : TFhirActivityDefinitionParticipant;
begin
  result := TFhirActivityDefinitionParticipant.create;
  try
    ParseActivityDefinitionParticipantProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseActivityDefinitionParticipantProperties(jsn : TJsonObject; result : TFhirActivityDefinitionParticipant);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn.node['type'], jsn.vObj['_type'], CODES_TFhirActionParticipantTypeEnum, SYSTEMS_TFhirActionParticipantTypeEnum);
    if jsn.has('role') then
        result.role := ParseCodeableConcept(jsn.vObj['role']);{q3}
end;

procedure TFHIRJsonComposer.ComposeActivityDefinitionParticipant(json : TJSONWriter; name : string; elem : TFhirActivityDefinitionParticipant; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirActionParticipantTypeEnum, false);
  ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirActionParticipantTypeEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'role', elem.role); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseActivityDefinitionDynamicValue(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseActivityDefinitionDynamicValue(jsn)); {2}
end;

function TFHIRJsonParser.ParseActivityDefinitionDynamicValue(jsn : TJsonObject) : TFhirActivityDefinitionDynamicValue;
begin
  result := TFhirActivityDefinitionDynamicValue.create;
  try
    ParseActivityDefinitionDynamicValueProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseActivityDefinitionDynamicValueProperties(jsn : TJsonObject; result : TFhirActivityDefinitionDynamicValue);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('path') or jsn.has('_path') then
        result.pathElement := parseString(jsn.node['path'], jsn.vObj['_path']);{q}
    if jsn.has('expression') then
        result.expression := ParseExpression(jsn.vObj['expression']);{q3}
end;

procedure TFHIRJsonComposer.ComposeActivityDefinitionDynamicValue(json : TJSONWriter; name : string; elem : TFhirActivityDefinitionDynamicValue; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'path', elem.pathElement, false);
  ComposeStringProps(json, 'path', elem.pathElement, false);
  ComposeExpression(json, 'expression', elem.expression); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseActivityDefinition(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseActivityDefinition(jsn)); {2}
end;

function TFHIRJsonParser.ParseActivityDefinition(jsn : TJsonObject) : TFhirActivityDefinition;
begin
  result := TFhirActivityDefinition.create;
  try
    ParseActivityDefinitionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseActivityDefinitionProperties(jsn : TJsonObject; result : TFhirActivityDefinition);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := parseUri(jsn.node['url'], jsn.vObj['_url']);{q}
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := parseString(jsn.node['version'], jsn.vObj['_version']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('title') or jsn.has('_title') then
        result.titleElement := parseString(jsn.node['title'], jsn.vObj['_title']);{q}
    if jsn.has('subtitle') or jsn.has('_subtitle') then
        result.subtitleElement := parseString(jsn.node['subtitle'], jsn.vObj['_subtitle']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    if jsn.has('experimental') or jsn.has('_experimental') then
        result.experimentalElement := parseBoolean(jsn.node['experimental'], jsn.vObj['_experimental']);{q}
    if jsn.has('subjectCodeableConcept') {a4} then
      result.subject := ParseCodeableConcept(jsn.vObj['subjectCodeableConcept']);
    if jsn.has('subjectReference') {a3} then
      result.subject := ParseReference(jsn.vObj['subjectReference']);
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := parseDateTime(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('publisher') or jsn.has('_publisher') then
        result.publisherElement := parseString(jsn.node['publisher'], jsn.vObj['_publisher']);{q}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseContactDetail);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseMarkdown(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('useContext') then
      iterateArray(jsn.vArr['useContext'], result.useContextList, parseUsageContext);
    if jsn.has('jurisdiction') then
      iterateArray(jsn.vArr['jurisdiction'], result.jurisdictionList, parseCodeableConcept);
    if jsn.has('purpose') or jsn.has('_purpose') then
        result.purposeElement := parseMarkdown(jsn.node['purpose'], jsn.vObj['_purpose']);{q}
    if jsn.has('usage') or jsn.has('_usage') then
        result.usageElement := parseString(jsn.node['usage'], jsn.vObj['_usage']);{q}
    if jsn.has('copyright') or jsn.has('_copyright') then
        result.copyrightElement := parseMarkdown(jsn.node['copyright'], jsn.vObj['_copyright']);{q}
    if jsn.has('approvalDate') or jsn.has('_approvalDate') then
        result.approvalDateElement := parseDate(jsn.node['approvalDate'], jsn.vObj['_approvalDate']);{q}
    if jsn.has('lastReviewDate') or jsn.has('_lastReviewDate') then
        result.lastReviewDateElement := parseDate(jsn.node['lastReviewDate'], jsn.vObj['_lastReviewDate']);{q}
    if jsn.has('effectivePeriod') then
        result.effectivePeriod := ParsePeriod(jsn.vObj['effectivePeriod']);{q3}
    if jsn.has('topic') then
      iterateArray(jsn.vArr['topic'], result.topicList, parseCodeableConcept);
    if jsn.has('author') then
      iterateArray(jsn.vArr['author'], result.authorList, parseContactDetail);
    if jsn.has('editor') then
      iterateArray(jsn.vArr['editor'], result.editorList, parseContactDetail);
    if jsn.has('reviewer') then
      iterateArray(jsn.vArr['reviewer'], result.reviewerList, parseContactDetail);
    if jsn.has('endorser') then
      iterateArray(jsn.vArr['endorser'], result.endorserList, parseContactDetail);
    if jsn.has('relatedArtifact') then
      iterateArray(jsn.vArr['relatedArtifact'], result.relatedArtifactList, parseRelatedArtifact);
      if jsn.has('library') or jsn.has('_library') then
      iteratePrimitiveArray(jsn.vArr['library'], jsn.vArr['_library'], result.library_List, parseCanonical);
    if jsn.has('kind') or jsn.has('_kind')  then
      result.kindElement := parseEnum(jsn.path+'/kind', jsn.node['kind'], jsn.vObj['_kind'], CODES_TFhirRequestResourceTypesEnum, SYSTEMS_TFhirRequestResourceTypesEnum);
    if jsn.has('profile') or jsn.has('_profile') then
        result.profileElement := parseCanonical(jsn.node['profile'], jsn.vObj['_profile']);{q}
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('intent') or jsn.has('_intent')  then
      result.intentElement := parseEnum(jsn.path+'/intent', jsn.node['intent'], jsn.vObj['_intent'], CODES_TFhirRequestIntentEnum, SYSTEMS_TFhirRequestIntentEnum);
    if jsn.has('priority') or jsn.has('_priority')  then
      result.priorityElement := parseEnum(jsn.path+'/priority', jsn.node['priority'], jsn.vObj['_priority'], CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum);
    if jsn.has('doNotPerform') or jsn.has('_doNotPerform') then
        result.doNotPerformElement := parseBoolean(jsn.node['doNotPerform'], jsn.vObj['_doNotPerform']);{q}
    if jsn.has('timingTiming') {a4} then
      result.timing := ParseTiming(jsn.vObj['timingTiming']);
    if jsn.has('timingAge') {a4} then
      result.timing := ParseAge(jsn.vObj['timingAge']);
    if jsn.has('timingPeriod') {a4} then
      result.timing := ParsePeriod(jsn.vObj['timingPeriod']);
    if jsn.has('timingRange') {a4} then
      result.timing := ParseRange(jsn.vObj['timingRange']);
    if jsn.has('timingDuration') {a4} then
      result.timing := ParseDuration(jsn.vObj['timingDuration']);
    if jsn.has('timingDateTime') or jsn.has('_timingDateTime') then
      result.timing := parseDateTime(jsn.node['timingDateTime'], jsn.vObj['_timingDateTime']);
    if jsn.has('location') then
        result.location := ParseReference{TFhirLocation}(jsn.vObj['location']);{q3}
    if jsn.has('participant') then
      iterateArray(jsn.vArr['participant'], result.participantList, parseActivityDefinitionParticipant);
    if jsn.has('productReference') {a3} then
      result.product := ParseReference(jsn.vObj['productReference']);
    if jsn.has('productCodeableConcept') {a4} then
      result.product := ParseCodeableConcept(jsn.vObj['productCodeableConcept']);
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q3}
    if jsn.has('dosage') then
      iterateArray(jsn.vArr['dosage'], result.dosageList, parseDosage);
    if jsn.has('bodySite') then
      iterateArray(jsn.vArr['bodySite'], result.bodySiteList, parseCodeableConcept);
    if jsn.has('specimenRequirement') then
      iterateArray(jsn.vArr['specimenRequirement'], result.specimenRequirementList, parseReference{TFhirSpecimenDefinition});
    if jsn.has('observationRequirement') then
      iterateArray(jsn.vArr['observationRequirement'], result.observationRequirementList, parseReference{TFhirObservationDefinition});
    if jsn.has('observationResultRequirement') then
      iterateArray(jsn.vArr['observationResultRequirement'], result.observationResultRequirementList, parseReference{TFhirObservationDefinition});
    if jsn.has('transform') or jsn.has('_transform') then
        result.transformElement := parseCanonical(jsn.node['transform'], jsn.vObj['_transform']);{q}
    if jsn.has('dynamicValue') then
      iterateArray(jsn.vArr['dynamicValue'], result.dynamicValueList, parseActivityDefinitionDynamicValue);
end;

procedure TFHIRJsonComposer.ComposeActivityDefinition(json : TJSONWriter; name : string; elem : TFhirActivityDefinition; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUriValue(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUriProps(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeStringValue(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeStringProps(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeStringValue(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeStringProps(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('subtitle') then
    ComposeStringValue(json, 'subtitle', elem.subtitleElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('subtitle') then
    ComposeStringProps(json, 'subtitle', elem.subtitleElement, false);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBooleanValue(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBooleanProps(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.subject is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'subjectCodeableConcept', TFhirCodeableConcept(elem.subject)) 
  else if (SummaryOption in [soFull, soData]) and (elem.subject is TFhirReference) then
    ComposeReference(json, 'subjectReference', TFhirReference(elem.subject));
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringValue(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringProps(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') and (elem.contactList.Count > 0) then
  begin
    json.valueArray('contact');
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(json, '', elem.contactList[i]); {z - ContactDetail}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeMarkdownValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeMarkdownProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') and (elem.useContextList.Count > 0) then
  begin
    json.valueArray('useContext');
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(json, '', elem.useContextList[i]); {z - UsageContext}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') and (elem.jurisdictionList.Count > 0) then
  begin
    json.valueArray('jurisdiction');
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.jurisdictionList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdownValue(json, 'purpose', elem.purposeElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdownProps(json, 'purpose', elem.purposeElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('usage') then
    ComposeStringValue(json, 'usage', elem.usageElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('usage') then
    ComposeStringProps(json, 'usage', elem.usageElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdownValue(json, 'copyright', elem.copyrightElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdownProps(json, 'copyright', elem.copyrightElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('approvalDate') then
    ComposeDateValue(json, 'approvalDate', elem.approvalDateElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('approvalDate') then
    ComposeDateProps(json, 'approvalDate', elem.approvalDateElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('lastReviewDate') then
    ComposeDateValue(json, 'lastReviewDate', elem.lastReviewDateElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('lastReviewDate') then
    ComposeDateProps(json, 'lastReviewDate', elem.lastReviewDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('effectivePeriod') then
    ComposePeriod(json, 'effectivePeriod', elem.effectivePeriod); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('topic') and (elem.topicList.Count > 0) then
  begin
    json.valueArray('topic');
    for i := 0 to elem.topicList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.topicList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('author') and (elem.authorList.Count > 0) then
  begin
    json.valueArray('author');
    for i := 0 to elem.authorList.Count - 1 do
      ComposeContactDetail(json, '', elem.authorList[i]); {z - ContactDetail}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('editor') and (elem.editorList.Count > 0) then
  begin
    json.valueArray('editor');
    for i := 0 to elem.editorList.Count - 1 do
      ComposeContactDetail(json, '', elem.editorList[i]); {z - ContactDetail}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('reviewer') and (elem.reviewerList.Count > 0) then
  begin
    json.valueArray('reviewer');
    for i := 0 to elem.reviewerList.Count - 1 do
      ComposeContactDetail(json, '', elem.reviewerList[i]); {z - ContactDetail}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('endorser') and (elem.endorserList.Count > 0) then
  begin
    json.valueArray('endorser');
    for i := 0 to elem.endorserList.Count - 1 do
      ComposeContactDetail(json, '', elem.endorserList[i]); {z - ContactDetail}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('relatedArtifact') and (elem.relatedArtifactList.Count > 0) then
  begin
    json.valueArray('relatedArtifact');
    for i := 0 to elem.relatedArtifactList.Count - 1 do
      ComposeRelatedArtifact(json, '', elem.relatedArtifactList[i]); {z - RelatedArtifact}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('library_') and (elem.library_List.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.library_List.Count - 1 do
    begin
      ext := ext or ((elem.library_List[i].id <> '') or (elem.library_List[i].hasExtensionList) {no-comments or (elem.library_List[i].hasComments)});
      val := val or (elem.library_List[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('library');
      for i := 0 to elem.library_List.Count - 1 do
        ComposeCanonicalValue(json, '',elem.library_List[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_library');
      for i := 0 to elem.library_List.Count - 1 do
        ComposeCanonicalProps(json, '',elem.library_List[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('kind') then
    ComposeEnumValue(json, 'kind', elem.KindElement, CODES_TFhirRequestResourceTypesEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('kind') then
    ComposeEnumProps(json, 'kind', elem.KindElement, CODES_TFhirRequestResourceTypesEnum, false);
  if (SummaryOption in [soFull, soData]) and doCompose('profile') then
    ComposeCanonicalValue(json, 'profile', elem.profileElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('profile') then
    ComposeCanonicalProps(json, 'profile', elem.profileElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') then
    ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('intent') then
    ComposeEnumValue(json, 'intent', elem.IntentElement, CODES_TFhirRequestIntentEnum, false);
  if (SummaryOption in [soFull, soData]) and doCompose('intent') then
    ComposeEnumProps(json, 'intent', elem.IntentElement, CODES_TFhirRequestIntentEnum, false);
  if (SummaryOption in [soFull, soData]) and doCompose('priority') then
    ComposeEnumValue(json, 'priority', elem.PriorityElement, CODES_TFhirRequestPriorityEnum, false);
  if (SummaryOption in [soFull, soData]) and doCompose('priority') then
    ComposeEnumProps(json, 'priority', elem.PriorityElement, CODES_TFhirRequestPriorityEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('doNotPerform') then
    ComposeBooleanValue(json, 'doNotPerform', elem.doNotPerformElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('doNotPerform') then
    ComposeBooleanProps(json, 'doNotPerform', elem.doNotPerformElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirTiming) then 
    ComposeTiming(json, 'timingTiming', TFhirTiming(elem.timing)) 
  else if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirAge) then 
    ComposeAge(json, 'timingAge', TFhirAge(elem.timing)) 
  else if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirPeriod) then 
    ComposePeriod(json, 'timingPeriod', TFhirPeriod(elem.timing)) 
  else if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirRange) then 
    ComposeRange(json, 'timingRange', TFhirRange(elem.timing)) 
  else if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirDuration) then 
    ComposeDuration(json, 'timingDuration', TFhirDuration(elem.timing)) 
  else if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'timingDateTime', TFhirDateTime(elem.timing), false);
    ComposeDateTimeProps(json, 'timingDateTime', TFhirDateTime(elem.timing), false);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('location') then
    ComposeReference{TFhirLocation}(json, 'location', elem.location); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('participant') and (elem.participantList.Count > 0) then
  begin
    json.valueArray('participant');
    for i := 0 to elem.participantList.Count - 1 do
      ComposeActivityDefinitionParticipant(json, '', elem.participantList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.product is TFhirReference) then
    ComposeReference(json, 'productReference', TFhirReference(elem.product))
  else if (SummaryOption in [soFull, soData]) and (elem.product is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'productCodeableConcept', TFhirCodeableConcept(elem.product)) ;
  if (SummaryOption in [soFull, soData]) and doCompose('quantity') then
    ComposeQuantity(json, 'quantity', elem.quantity); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('dosage') and (elem.dosageList.Count > 0) then
  begin
    json.valueArray('dosage');
    for i := 0 to elem.dosageList.Count - 1 do
      ComposeDosage(json, '', elem.dosageList[i]); {z - Dosage}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('bodySite') and (elem.bodySiteList.Count > 0) then
  begin
    json.valueArray('bodySite');
    for i := 0 to elem.bodySiteList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.bodySiteList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('specimenRequirement') and (elem.specimenRequirementList.Count > 0) then
  begin
    json.valueArray('specimenRequirement');
    for i := 0 to elem.specimenRequirementList.Count - 1 do
      ComposeReference{TFhirSpecimenDefinition}(json, '', elem.specimenRequirementList[i]); {z - Reference(SpecimenDefinition)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('observationRequirement') and (elem.observationRequirementList.Count > 0) then
  begin
    json.valueArray('observationRequirement');
    for i := 0 to elem.observationRequirementList.Count - 1 do
      ComposeReference{TFhirObservationDefinition}(json, '', elem.observationRequirementList[i]); {z - Reference(ObservationDefinition)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('observationResultRequirement') and (elem.observationResultRequirementList.Count > 0) then
  begin
    json.valueArray('observationResultRequirement');
    for i := 0 to elem.observationResultRequirementList.Count - 1 do
      ComposeReference{TFhirObservationDefinition}(json, '', elem.observationResultRequirementList[i]); {z - Reference(ObservationDefinition)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('transform') then
    ComposeCanonicalValue(json, 'transform', elem.transformElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('transform') then
    ComposeCanonicalProps(json, 'transform', elem.transformElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('dynamicValue') and (elem.dynamicValueList.Count > 0) then
  begin
    json.valueArray('dynamicValue');
    for i := 0 to elem.dynamicValueList.Count - 1 do
      ComposeActivityDefinitionDynamicValue(json, '', elem.dynamicValueList[i]); {z - }
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_ACTIVITYDEFINITION}
{$IFDEF FHIR_ADVERSEEVENT}
procedure TFHIRJsonParser.ParseAdverseEventSuspectEntity(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAdverseEventSuspectEntity(jsn)); {2}
end;

function TFHIRJsonParser.ParseAdverseEventSuspectEntity(jsn : TJsonObject) : TFhirAdverseEventSuspectEntity;
begin
  result := TFhirAdverseEventSuspectEntity.create;
  try
    ParseAdverseEventSuspectEntityProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseAdverseEventSuspectEntityProperties(jsn : TJsonObject; result : TFhirAdverseEventSuspectEntity);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('instance') then
        result.instance := ParseReference{TFhirImmunization}(jsn.vObj['instance']);{q3}
    if jsn.has('causality') then
      iterateArray(jsn.vArr['causality'], result.causalityList, parseAdverseEventSuspectEntityCausality);
end;

procedure TFHIRJsonComposer.ComposeAdverseEventSuspectEntity(json : TJSONWriter; name : string; elem : TFhirAdverseEventSuspectEntity; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeReference{TFhirImmunization}(json, 'instance', elem.instance); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.causalityList.Count > 0) then
  begin
    json.valueArray('causality');
    for i := 0 to elem.causalityList.Count - 1 do
      ComposeAdverseEventSuspectEntityCausality(json, '', elem.causalityList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseAdverseEventSuspectEntityCausality(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAdverseEventSuspectEntityCausality(jsn)); {2}
end;

function TFHIRJsonParser.ParseAdverseEventSuspectEntityCausality(jsn : TJsonObject) : TFhirAdverseEventSuspectEntityCausality;
begin
  result := TFhirAdverseEventSuspectEntityCausality.create;
  try
    ParseAdverseEventSuspectEntityCausalityProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseAdverseEventSuspectEntityCausalityProperties(jsn : TJsonObject; result : TFhirAdverseEventSuspectEntityCausality);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('assessment') then
        result.assessment := ParseCodeableConcept(jsn.vObj['assessment']);{q3}
    if jsn.has('productRelatedness') or jsn.has('_productRelatedness') then
        result.productRelatednessElement := parseString(jsn.node['productRelatedness'], jsn.vObj['_productRelatedness']);{q}
    if jsn.has('author') then
        result.author := ParseReference{TFhirPractitioner}(jsn.vObj['author']);{q3}
    if jsn.has('method') then
        result.method := ParseCodeableConcept(jsn.vObj['method']);{q3}
end;

procedure TFHIRJsonComposer.ComposeAdverseEventSuspectEntityCausality(json : TJSONWriter; name : string; elem : TFhirAdverseEventSuspectEntityCausality; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'assessment', elem.assessment); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'productRelatedness', elem.productRelatednessElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'productRelatedness', elem.productRelatednessElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(json, 'author', elem.author); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'method', elem.method); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseAdverseEvent(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAdverseEvent(jsn)); {2}
end;

function TFHIRJsonParser.ParseAdverseEvent(jsn : TJsonObject) : TFhirAdverseEvent;
begin
  result := TFhirAdverseEvent.create;
  try
    ParseAdverseEventProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseAdverseEventProperties(jsn : TJsonObject; result : TFhirAdverseEvent);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q3}
    if jsn.has('actuality') or jsn.has('_actuality')  then
      result.actualityElement := parseEnum(jsn.path+'/actuality', jsn.node['actuality'], jsn.vObj['_actuality'], CODES_TFhirAdverseEventActualityEnum, SYSTEMS_TFhirAdverseEventActualityEnum);
    if jsn.has('category') then
      iterateArray(jsn.vArr['category'], result.categoryList, parseCodeableConcept);
    if jsn.has('event') then
        result.event := ParseCodeableConcept(jsn.vObj['event']);{q3}
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirPatient}(jsn.vObj['subject']);{q3}
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q3}
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := parseDateTime(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('detected') or jsn.has('_detected') then
        result.detectedElement := parseDateTime(jsn.node['detected'], jsn.vObj['_detected']);{q}
    if jsn.has('recordedDate') or jsn.has('_recordedDate') then
        result.recordedDateElement := parseDateTime(jsn.node['recordedDate'], jsn.vObj['_recordedDate']);{q}
    if jsn.has('resultingCondition') then
      iterateArray(jsn.vArr['resultingCondition'], result.resultingConditionList, parseReference{TFhirCondition});
    if jsn.has('location') then
        result.location := ParseReference{TFhirLocation}(jsn.vObj['location']);{q3}
    if jsn.has('seriousness') then
        result.seriousness := ParseCodeableConcept(jsn.vObj['seriousness']);{q3}
    if jsn.has('severity') then
        result.severity := ParseCodeableConcept(jsn.vObj['severity']);{q3}
    if jsn.has('outcome') then
        result.outcome := ParseCodeableConcept(jsn.vObj['outcome']);{q3}
    if jsn.has('recorder') then
        result.recorder := ParseReference{TFhirPatient}(jsn.vObj['recorder']);{q3}
    if jsn.has('contributor') then
      iterateArray(jsn.vArr['contributor'], result.contributorList, parseReference{TFhirPractitioner});
    if jsn.has('suspectEntity') then
      iterateArray(jsn.vArr['suspectEntity'], result.suspectEntityList, parseAdverseEventSuspectEntity);
    if jsn.has('subjectMedicalHistory') then
      iterateArray(jsn.vArr['subjectMedicalHistory'], result.subjectMedicalHistoryList, parseReference{TFhirCondition});
    if jsn.has('referenceDocument') then
      iterateArray(jsn.vArr['referenceDocument'], result.referenceDocumentList, parseReference{TFhirDocumentReference});
    if jsn.has('study') then
      iterateArray(jsn.vArr['study'], result.studyList, parseReference{TFhirResearchStudy});
end;

procedure TFHIRJsonComposer.ComposeAdverseEvent(json : TJSONWriter; name : string; elem : TFhirAdverseEvent; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  ComposeEnumValue(json, 'actuality', elem.ActualityElement, CODES_TFhirAdverseEventActualityEnum, false);
  ComposeEnumProps(json, 'actuality', elem.ActualityElement, CODES_TFhirAdverseEventActualityEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') and (elem.categoryList.Count > 0) then
  begin
    json.valueArray('category');
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.categoryList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('event') then
    ComposeCodeableConcept(json, 'event', elem.event); {a}
  ComposeReference{TFhirPatient}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('detected') then
    ComposeDateTimeValue(json, 'detected', elem.detectedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('detected') then
    ComposeDateTimeProps(json, 'detected', elem.detectedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('recordedDate') then
    ComposeDateTimeValue(json, 'recordedDate', elem.recordedDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('recordedDate') then
    ComposeDateTimeProps(json, 'recordedDate', elem.recordedDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('resultingCondition') and (elem.resultingConditionList.Count > 0) then
  begin
    json.valueArray('resultingCondition');
    for i := 0 to elem.resultingConditionList.Count - 1 do
      ComposeReference{TFhirCondition}(json, '', elem.resultingConditionList[i]); {z - Reference(Condition)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('location') then
    ComposeReference{TFhirLocation}(json, 'location', elem.location); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('seriousness') then
    ComposeCodeableConcept(json, 'seriousness', elem.seriousness); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('severity') then
    ComposeCodeableConcept(json, 'severity', elem.severity); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('outcome') then
    ComposeCodeableConcept(json, 'outcome', elem.outcome); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('recorder') then
    ComposeReference{TFhirPatient}(json, 'recorder', elem.recorder); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contributor') and (elem.contributorList.Count > 0) then
  begin
    json.valueArray('contributor');
    for i := 0 to elem.contributorList.Count - 1 do
      ComposeReference{TFhirPractitioner}(json, '', elem.contributorList[i]); {z - Reference(Practitioner)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('suspectEntity') and (elem.suspectEntityList.Count > 0) then
  begin
    json.valueArray('suspectEntity');
    for i := 0 to elem.suspectEntityList.Count - 1 do
      ComposeAdverseEventSuspectEntity(json, '', elem.suspectEntityList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subjectMedicalHistory') and (elem.subjectMedicalHistoryList.Count > 0) then
  begin
    json.valueArray('subjectMedicalHistory');
    for i := 0 to elem.subjectMedicalHistoryList.Count - 1 do
      ComposeReference{TFhirCondition}(json, '', elem.subjectMedicalHistoryList[i]); {z - Reference(Condition)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('referenceDocument') and (elem.referenceDocumentList.Count > 0) then
  begin
    json.valueArray('referenceDocument');
    for i := 0 to elem.referenceDocumentList.Count - 1 do
      ComposeReference{TFhirDocumentReference}(json, '', elem.referenceDocumentList[i]); {z - Reference(DocumentReference)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('study') and (elem.studyList.Count > 0) then
  begin
    json.valueArray('study');
    for i := 0 to elem.studyList.Count - 1 do
      ComposeReference{TFhirResearchStudy}(json, '', elem.studyList[i]); {z - Reference(ResearchStudy)}
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_ADVERSEEVENT}
{$IFDEF FHIR_ALLERGYINTOLERANCE}
procedure TFHIRJsonParser.ParseAllergyIntoleranceReaction(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAllergyIntoleranceReaction(jsn)); {2}
end;

function TFHIRJsonParser.ParseAllergyIntoleranceReaction(jsn : TJsonObject) : TFhirAllergyIntoleranceReaction;
begin
  result := TFhirAllergyIntoleranceReaction.create;
  try
    ParseAllergyIntoleranceReactionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseAllergyIntoleranceReactionProperties(jsn : TJsonObject; result : TFhirAllergyIntoleranceReaction);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('substance') then
        result.substance := ParseCodeableConcept(jsn.vObj['substance']);{q3}
    if jsn.has('manifestation') then
      iterateArray(jsn.vArr['manifestation'], result.manifestationList, parseCodeableConcept);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('onset') or jsn.has('_onset') then
        result.onsetElement := parseDateTime(jsn.node['onset'], jsn.vObj['_onset']);{q}
    if jsn.has('severity') or jsn.has('_severity')  then
      result.severityElement := parseEnum(jsn.path+'/severity', jsn.node['severity'], jsn.vObj['_severity'], CODES_TFhirReactionEventSeverityEnum, SYSTEMS_TFhirReactionEventSeverityEnum);
    if jsn.has('exposureRoute') then
        result.exposureRoute := ParseCodeableConcept(jsn.vObj['exposureRoute']);{q3}
    if jsn.has('note') then
      iterateArray(jsn.vArr['note'], result.noteList, parseAnnotation);
end;

procedure TFHIRJsonComposer.ComposeAllergyIntoleranceReaction(json : TJSONWriter; name : string; elem : TFhirAllergyIntoleranceReaction; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'substance', elem.substance); {a}
  if (elem.manifestationList.Count > 0) then
  begin
    json.valueArray('manifestation');
    for i := 0 to elem.manifestationList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.manifestationList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTimeValue(json, 'onset', elem.onsetElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTimeProps(json, 'onset', elem.onsetElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumValue(json, 'severity', elem.SeverityElement, CODES_TFhirReactionEventSeverityEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumProps(json, 'severity', elem.SeverityElement, CODES_TFhirReactionEventSeverityEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'exposureRoute', elem.exposureRoute); {a}
  if (SummaryOption in [soFull, soData]) and (elem.noteList.Count > 0) then
  begin
    json.valueArray('note');
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(json, '', elem.noteList[i]); {z - Annotation}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseAllergyIntolerance(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAllergyIntolerance(jsn)); {2}
end;

function TFHIRJsonParser.ParseAllergyIntolerance(jsn : TJsonObject) : TFhirAllergyIntolerance;
begin
  result := TFhirAllergyIntolerance.create;
  try
    ParseAllergyIntoleranceProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseAllergyIntoleranceProperties(jsn : TJsonObject; result : TFhirAllergyIntolerance);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('clinicalStatus') then
        result.clinicalStatus := ParseCodeableConcept(jsn.vObj['clinicalStatus']);{q3}
    if jsn.has('verificationStatus') then
        result.verificationStatus := ParseCodeableConcept(jsn.vObj['verificationStatus']);{q3}
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn.node['type'], jsn.vObj['_type'], CODES_TFhirAllergyIntoleranceTypeEnum, SYSTEMS_TFhirAllergyIntoleranceTypeEnum);
    if jsn.has('category') or jsn.has('_category') then
      iterateEnumArray(jsn.vArr['category'], jsn.vArr['_category'], jsn.path+'/category', result.categoryList, parseEnum, CODES_TFhirAllergyIntoleranceCategoryEnum, SYSTEMS_TFhirAllergyIntoleranceCategoryEnum);
    if jsn.has('criticality') or jsn.has('_criticality')  then
      result.criticalityElement := parseEnum(jsn.path+'/criticality', jsn.node['criticality'], jsn.vObj['_criticality'], CODES_TFhirAllergyIntoleranceCriticalityEnum, SYSTEMS_TFhirAllergyIntoleranceCriticalityEnum);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q3}
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q3}
    if jsn.has('onsetAge') {a4} then
      result.onset := ParseAge(jsn.vObj['onsetAge']);
    if jsn.has('onsetPeriod') {a4} then
      result.onset := ParsePeriod(jsn.vObj['onsetPeriod']);
    if jsn.has('onsetRange') {a4} then
      result.onset := ParseRange(jsn.vObj['onsetRange']);
    if jsn.has('onsetDateTime') or jsn.has('_onsetDateTime') then
      result.onset := parseDateTime(jsn.node['onsetDateTime'], jsn.vObj['_onsetDateTime']);
    if jsn.has('onsetString') or jsn.has('_onsetString') then
      result.onset := parseString(jsn.node['onsetString'], jsn.vObj['_onsetString']);
    if jsn.has('recordedDate') or jsn.has('_recordedDate') then
        result.recordedDateElement := parseDateTime(jsn.node['recordedDate'], jsn.vObj['_recordedDate']);{q}
    if jsn.has('recorder') then
        result.recorder := ParseReference{TFhirPractitioner}(jsn.vObj['recorder']);{q3}
    if jsn.has('asserter') then
        result.asserter := ParseReference{TFhirPatient}(jsn.vObj['asserter']);{q3}
    if jsn.has('lastOccurrence') or jsn.has('_lastOccurrence') then
        result.lastOccurrenceElement := parseDateTime(jsn.node['lastOccurrence'], jsn.vObj['_lastOccurrence']);{q}
    if jsn.has('note') then
      iterateArray(jsn.vArr['note'], result.noteList, parseAnnotation);
    if jsn.has('reaction') then
      iterateArray(jsn.vArr['reaction'], result.reactionList, parseAllergyIntoleranceReaction);
end;

procedure TFHIRJsonComposer.ComposeAllergyIntolerance(json : TJSONWriter; name : string; elem : TFhirAllergyIntolerance; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('clinicalStatus') then
    ComposeCodeableConcept(json, 'clinicalStatus', elem.clinicalStatus); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('verificationStatus') then
    ComposeCodeableConcept(json, 'verificationStatus', elem.verificationStatus); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirAllergyIntoleranceTypeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirAllergyIntoleranceTypeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') and (elem.categoryList.Count > 0) then
  begin
    val := false;
    ext := false;
    for i := 0 to elem.categoryList.Count - 1 do
    begin
      val := val or (elem.categoryList[i].hasPrimitiveValue);
      ext := ext or ((elem.categoryList[i].id <> '') or (elem.categoryList[i].hasExtensionList));
    end;
    if val then
    begin
      json.valueArray('category');
      for i := 0 to elem.categoryList.Count - 1 do
        ComposeEnumValue(json, '', elem.categoryList[i], CODES_TFhirAllergyIntoleranceCategoryEnum, true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_category');
      for i := 0 to elem.categoryList.Count - 1 do
        ComposeEnumProps(json, '', elem.categoryList[i], CODES_TFhirAllergyIntoleranceCategoryEnum, true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('criticality') then
    ComposeEnumValue(json, 'criticality', elem.CriticalityElement, CODES_TFhirAllergyIntoleranceCriticalityEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('criticality') then
    ComposeEnumProps(json, 'criticality', elem.CriticalityElement, CODES_TFhirAllergyIntoleranceCriticalityEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') then
    ComposeCodeableConcept(json, 'code', elem.code); {a}
  ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if (SummaryOption in [soFull, soData]) and (elem.onset is TFhirAge) then 
    ComposeAge(json, 'onsetAge', TFhirAge(elem.onset)) 
  else if (SummaryOption in [soFull, soData]) and (elem.onset is TFhirPeriod) then 
    ComposePeriod(json, 'onsetPeriod', TFhirPeriod(elem.onset)) 
  else if (SummaryOption in [soFull, soData]) and (elem.onset is TFhirRange) then 
    ComposeRange(json, 'onsetRange', TFhirRange(elem.onset)) 
  else if (SummaryOption in [soFull, soData]) and (elem.onset is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'onsetDateTime', TFhirDateTime(elem.onset), false);
    ComposeDateTimeProps(json, 'onsetDateTime', TFhirDateTime(elem.onset), false);
  end
  else if (SummaryOption in [soFull, soData]) and (elem.onset is TFhirString) then 
  begin
    ComposeStringValue(json, 'onsetString', TFhirString(elem.onset), false);
    ComposeStringProps(json, 'onsetString', TFhirString(elem.onset), false);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('recordedDate') then
    ComposeDateTimeValue(json, 'recordedDate', elem.recordedDateElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('recordedDate') then
    ComposeDateTimeProps(json, 'recordedDate', elem.recordedDateElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('recorder') then
    ComposeReference{TFhirPractitioner}(json, 'recorder', elem.recorder); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('asserter') then
    ComposeReference{TFhirPatient}(json, 'asserter', elem.asserter); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('lastOccurrence') then
    ComposeDateTimeValue(json, 'lastOccurrence', elem.lastOccurrenceElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('lastOccurrence') then
    ComposeDateTimeProps(json, 'lastOccurrence', elem.lastOccurrenceElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('note') and (elem.noteList.Count > 0) then
  begin
    json.valueArray('note');
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(json, '', elem.noteList[i]); {z - Annotation}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('reaction') and (elem.reactionList.Count > 0) then
  begin
    json.valueArray('reaction');
    for i := 0 to elem.reactionList.Count - 1 do
      ComposeAllergyIntoleranceReaction(json, '', elem.reactionList[i]); {z - }
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_ALLERGYINTOLERANCE}
{$IFDEF FHIR_APPOINTMENT}
procedure TFHIRJsonParser.ParseAppointmentParticipant(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAppointmentParticipant(jsn)); {2}
end;

function TFHIRJsonParser.ParseAppointmentParticipant(jsn : TJsonObject) : TFhirAppointmentParticipant;
begin
  result := TFhirAppointmentParticipant.create;
  try
    ParseAppointmentParticipantProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseAppointmentParticipantProperties(jsn : TJsonObject; result : TFhirAppointmentParticipant);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
      iterateArray(jsn.vArr['type'], result.type_List, parseCodeableConcept);
    if jsn.has('actor') then
        result.actor := ParseReference{TFhirPatient}(jsn.vObj['actor']);{q3}
    if jsn.has('required') or jsn.has('_required')  then
      result.requiredElement := parseEnum(jsn.path+'/required', jsn.node['required'], jsn.vObj['_required'], CODES_TFhirParticipantrequiredEnum, SYSTEMS_TFhirParticipantrequiredEnum);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirParticipationstatusEnum, SYSTEMS_TFhirParticipationstatusEnum);
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q3}
end;

procedure TFHIRJsonComposer.ComposeAppointmentParticipant(json : TJSONWriter; name : string; elem : TFhirAppointmentParticipant; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.type_List.Count > 0) then
  begin
    json.valueArray('type');
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(json, '', elem.type_List[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(json, 'actor', elem.actor); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnumValue(json, 'required', elem.RequiredElement, CODES_TFhirParticipantrequiredEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnumProps(json, 'required', elem.RequiredElement, CODES_TFhirParticipantrequiredEnum, false);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirParticipationstatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirParticipationstatusEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(json, 'period', elem.period); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseAppointment(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAppointment(jsn)); {2}
end;

function TFHIRJsonParser.ParseAppointment(jsn : TJsonObject) : TFhirAppointment;
begin
  result := TFhirAppointment.create;
  try
    ParseAppointmentProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseAppointmentProperties(jsn : TJsonObject; result : TFhirAppointment);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirAppointmentstatusEnum, SYSTEMS_TFhirAppointmentstatusEnum);
    if jsn.has('cancelationReason') then
        result.cancelationReason := ParseCodeableConcept(jsn.vObj['cancelationReason']);{q3}
    if jsn.has('serviceCategory') then
      iterateArray(jsn.vArr['serviceCategory'], result.serviceCategoryList, parseCodeableConcept);
    if jsn.has('serviceType') then
      iterateArray(jsn.vArr['serviceType'], result.serviceTypeList, parseCodeableConcept);
    if jsn.has('specialty') then
      iterateArray(jsn.vArr['specialty'], result.specialtyList, parseCodeableConcept);
    if jsn.has('appointmentType') then
        result.appointmentType := ParseCodeableConcept(jsn.vObj['appointmentType']);{q3}
    if jsn.has('reasonCode') then
      iterateArray(jsn.vArr['reasonCode'], result.reasonCodeList, parseCodeableConcept);
    if jsn.has('reasonReference') then
      iterateArray(jsn.vArr['reasonReference'], result.reasonReferenceList, parseReference{TFhirCondition});
    if jsn.has('priority') or jsn.has('_priority') then
        result.priorityElement := parseUnsignedInt(jsn.node['priority'], jsn.vObj['_priority']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('supportingInformation') then
      iterateArray(jsn.vArr['supportingInformation'], result.supportingInformationList, parseReference{TFhirReference});
    if jsn.has('start') or jsn.has('_start') then
        result.startElement := parseInstant(jsn.node['start'], jsn.vObj['_start']);{q}
    if jsn.has('end') or jsn.has('_end') then
        result.end_Element := parseInstant(jsn.node['end'], jsn.vObj['_end']);{q}
    if jsn.has('minutesDuration') or jsn.has('_minutesDuration') then
        result.minutesDurationElement := parsePositiveInt(jsn.node['minutesDuration'], jsn.vObj['_minutesDuration']);{q}
    if jsn.has('slot') then
      iterateArray(jsn.vArr['slot'], result.slotList, parseReference{TFhirSlot});
    if jsn.has('created') or jsn.has('_created') then
        result.createdElement := parseDateTime(jsn.node['created'], jsn.vObj['_created']);{q}
    if jsn.has('comment') or jsn.has('_comment') then
        result.commentElement := parseString(jsn.node['comment'], jsn.vObj['_comment']);{q}
    if jsn.has('patientInstruction') or jsn.has('_patientInstruction') then
        result.patientInstructionElement := parseString(jsn.node['patientInstruction'], jsn.vObj['_patientInstruction']);{q}
    if jsn.has('basedOn') then
      iterateArray(jsn.vArr['basedOn'], result.basedOnList, parseReference{TFhirServiceRequest});
    if jsn.has('participant') then
      iterateArray(jsn.vArr['participant'], result.participantList, parseAppointmentParticipant);
    if jsn.has('requestedPeriod') then
      iterateArray(jsn.vArr['requestedPeriod'], result.requestedPeriodList, parsePeriod);
end;

procedure TFHIRJsonComposer.ComposeAppointment(json : TJSONWriter; name : string; elem : TFhirAppointment; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirAppointmentstatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirAppointmentstatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('cancelationReason') then
    ComposeCodeableConcept(json, 'cancelationReason', elem.cancelationReason); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('serviceCategory') and (elem.serviceCategoryList.Count > 0) then
  begin
    json.valueArray('serviceCategory');
    for i := 0 to elem.serviceCategoryList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.serviceCategoryList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('serviceType') and (elem.serviceTypeList.Count > 0) then
  begin
    json.valueArray('serviceType');
    for i := 0 to elem.serviceTypeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.serviceTypeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('specialty') and (elem.specialtyList.Count > 0) then
  begin
    json.valueArray('specialty');
    for i := 0 to elem.specialtyList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.specialtyList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('appointmentType') then
    ComposeCodeableConcept(json, 'appointmentType', elem.appointmentType); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonCode') and (elem.reasonCodeList.Count > 0) then
  begin
    json.valueArray('reasonCode');
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.reasonCodeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('reasonReference') and (elem.reasonReferenceList.Count > 0) then
  begin
    json.valueArray('reasonReference');
    for i := 0 to elem.reasonReferenceList.Count - 1 do
      ComposeReference{TFhirCondition}(json, '', elem.reasonReferenceList[i]); {z - Reference(Condition)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('priority') then
    ComposeUnsignedIntValue(json, 'priority', elem.priorityElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('priority') then
    ComposeUnsignedIntProps(json, 'priority', elem.priorityElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('supportingInformation') and (elem.supportingInformationList.Count > 0) then
  begin
    json.valueArray('supportingInformation');
    for i := 0 to elem.supportingInformationList.Count - 1 do
      ComposeReference{TFhirReference}(json, '', elem.supportingInformationList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('start') then
    ComposeInstantValue(json, 'start', elem.startElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('start') then
    ComposeInstantProps(json, 'start', elem.startElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('end_') then
    ComposeInstantValue(json, 'end', elem.end_Element, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('end_') then
    ComposeInstantProps(json, 'end', elem.end_Element, false);
  if (SummaryOption in [soFull, soData]) and doCompose('minutesDuration') then
    ComposePositiveIntValue(json, 'minutesDuration', elem.minutesDurationElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('minutesDuration') then
    ComposePositiveIntProps(json, 'minutesDuration', elem.minutesDurationElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('slot') and (elem.slotList.Count > 0) then
  begin
    json.valueArray('slot');
    for i := 0 to elem.slotList.Count - 1 do
      ComposeReference{TFhirSlot}(json, '', elem.slotList[i]); {z - Reference(Slot)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('created') then
    ComposeDateTimeValue(json, 'created', elem.createdElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('created') then
    ComposeDateTimeProps(json, 'created', elem.createdElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('comment') then
    ComposeStringValue(json, 'comment', elem.commentElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('comment') then
    ComposeStringProps(json, 'comment', elem.commentElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('patientInstruction') then
    ComposeStringValue(json, 'patientInstruction', elem.patientInstructionElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('patientInstruction') then
    ComposeStringProps(json, 'patientInstruction', elem.patientInstructionElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('basedOn') and (elem.basedOnList.Count > 0) then
  begin
    json.valueArray('basedOn');
    for i := 0 to elem.basedOnList.Count - 1 do
      ComposeReference{TFhirServiceRequest}(json, '', elem.basedOnList[i]); {z - Reference(ServiceRequest)}
    json.FinishArray;
  end;
  if (elem.participantList.Count > 0) then
  begin
    json.valueArray('participant');
    for i := 0 to elem.participantList.Count - 1 do
      ComposeAppointmentParticipant(json, '', elem.participantList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('requestedPeriod') and (elem.requestedPeriodList.Count > 0) then
  begin
    json.valueArray('requestedPeriod');
    for i := 0 to elem.requestedPeriodList.Count - 1 do
      ComposePeriod(json, '', elem.requestedPeriodList[i]); {z - Period}
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_APPOINTMENT}
{$IFDEF FHIR_APPOINTMENTRESPONSE}
procedure TFHIRJsonParser.ParseAppointmentResponse(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAppointmentResponse(jsn)); {2}
end;

function TFHIRJsonParser.ParseAppointmentResponse(jsn : TJsonObject) : TFhirAppointmentResponse;
begin
  result := TFhirAppointmentResponse.create;
  try
    ParseAppointmentResponseProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseAppointmentResponseProperties(jsn : TJsonObject; result : TFhirAppointmentResponse);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('appointment') then
        result.appointment := ParseReference{TFhirAppointment}(jsn.vObj['appointment']);{q3}
    if jsn.has('start') or jsn.has('_start') then
        result.startElement := parseInstant(jsn.node['start'], jsn.vObj['_start']);{q}
    if jsn.has('end') or jsn.has('_end') then
        result.end_Element := parseInstant(jsn.node['end'], jsn.vObj['_end']);{q}
    if jsn.has('participantType') then
      iterateArray(jsn.vArr['participantType'], result.participantTypeList, parseCodeableConcept);
    if jsn.has('actor') then
        result.actor := ParseReference{TFhirPatient}(jsn.vObj['actor']);{q3}
    if jsn.has('participantStatus') or jsn.has('_participantStatus')  then
      result.participantStatusElement := parseEnum(jsn.path+'/participantStatus', jsn.node['participantStatus'], jsn.vObj['_participantStatus'], CODES_TFhirParticipationstatusEnum, SYSTEMS_TFhirParticipationstatusEnum);
    if jsn.has('comment') or jsn.has('_comment') then
        result.commentElement := parseString(jsn.node['comment'], jsn.vObj['_comment']);{q}
end;

procedure TFHIRJsonComposer.ComposeAppointmentResponse(json : TJSONWriter; name : string; elem : TFhirAppointmentResponse; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeReference{TFhirAppointment}(json, 'appointment', elem.appointment); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('start') then
    ComposeInstantValue(json, 'start', elem.startElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('start') then
    ComposeInstantProps(json, 'start', elem.startElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('end_') then
    ComposeInstantValue(json, 'end', elem.end_Element, false);
  if (SummaryOption in [soFull, soData]) and doCompose('end_') then
    ComposeInstantProps(json, 'end', elem.end_Element, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('participantType') and (elem.participantTypeList.Count > 0) then
  begin
    json.valueArray('participantType');
    for i := 0 to elem.participantTypeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.participantTypeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('actor') then
    ComposeReference{TFhirPatient}(json, 'actor', elem.actor); {a}
  ComposeEnumValue(json, 'participantStatus', elem.ParticipantStatusElement, CODES_TFhirParticipationstatusEnum, false);
  ComposeEnumProps(json, 'participantStatus', elem.ParticipantStatusElement, CODES_TFhirParticipationstatusEnum, false);
  if (SummaryOption in [soFull, soData]) and doCompose('comment') then
    ComposeStringValue(json, 'comment', elem.commentElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('comment') then
    ComposeStringProps(json, 'comment', elem.commentElement, false);
end;

{$ENDIF FHIR_APPOINTMENTRESPONSE}
{$IFDEF FHIR_AUDITEVENT}
procedure TFHIRJsonParser.ParseAuditEventAgent(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAuditEventAgent(jsn)); {2}
end;

function TFHIRJsonParser.ParseAuditEventAgent(jsn : TJsonObject) : TFhirAuditEventAgent;
begin
  result := TFhirAuditEventAgent.create;
  try
    ParseAuditEventAgentProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseAuditEventAgentProperties(jsn : TJsonObject; result : TFhirAuditEventAgent);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('role') then
      iterateArray(jsn.vArr['role'], result.roleList, parseCodeableConcept);
    if jsn.has('who') then
        result.who := ParseReference{TFhirPractitionerRole}(jsn.vObj['who']);{q3}
    if jsn.has('altId') or jsn.has('_altId') then
        result.altIdElement := parseString(jsn.node['altId'], jsn.vObj['_altId']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('requestor') or jsn.has('_requestor') then
        result.requestorElement := parseBoolean(jsn.node['requestor'], jsn.vObj['_requestor']);{q}
    if jsn.has('location') then
        result.location := ParseReference{TFhirLocation}(jsn.vObj['location']);{q3}
      if jsn.has('policy') or jsn.has('_policy') then
      iteratePrimitiveArray(jsn.vArr['policy'], jsn.vArr['_policy'], result.policyList, parseUri);
    if jsn.has('media') then
        result.media := ParseCoding(jsn.vObj['media']);{q3}
    if jsn.has('network') then
        result.network := ParseAuditEventAgentNetwork(jsn.vObj['network']);{q3}
    if jsn.has('purposeOfUse') then
      iterateArray(jsn.vArr['purposeOfUse'], result.purposeOfUseList, parseCodeableConcept);
end;

procedure TFHIRJsonComposer.ComposeAuditEventAgent(json : TJSONWriter; name : string; elem : TFhirAuditEventAgent; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) and (elem.roleList.Count > 0) then
  begin
    json.valueArray('role');
    for i := 0 to elem.roleList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.roleList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitionerRole}(json, 'who', elem.who); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'altId', elem.altIdElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'altId', elem.altIdElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  ComposeBooleanValue(json, 'requestor', elem.requestorElement, false);
  ComposeBooleanProps(json, 'requestor', elem.requestorElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirLocation}(json, 'location', elem.location); {a}
  if (SummaryOption in [soFull, soData]) and (elem.policyList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.policyList.Count - 1 do
    begin
      ext := ext or ((elem.policyList[i].id <> '') or (elem.policyList[i].hasExtensionList) {no-comments or (elem.policyList[i].hasComments)});
      val := val or (elem.policyList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('policy');
      for i := 0 to elem.policyList.Count - 1 do
        ComposeUriValue(json, '',elem.policyList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_policy');
      for i := 0 to elem.policyList.Count - 1 do
        ComposeUriProps(json, '',elem.policyList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(json, 'media', elem.media); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeAuditEventAgentNetwork(json, 'network', elem.network); {a}
  if (SummaryOption in [soFull, soData]) and (elem.purposeOfUseList.Count > 0) then
  begin
    json.valueArray('purposeOfUse');
    for i := 0 to elem.purposeOfUseList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.purposeOfUseList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseAuditEventAgentNetwork(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAuditEventAgentNetwork(jsn)); {2}
end;

function TFHIRJsonParser.ParseAuditEventAgentNetwork(jsn : TJsonObject) : TFhirAuditEventAgentNetwork;
begin
  result := TFhirAuditEventAgentNetwork.create;
  try
    ParseAuditEventAgentNetworkProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseAuditEventAgentNetworkProperties(jsn : TJsonObject; result : TFhirAuditEventAgentNetwork);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('address') or jsn.has('_address') then
        result.addressElement := parseString(jsn.node['address'], jsn.vObj['_address']);{q}
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn.node['type'], jsn.vObj['_type'], CODES_TFhirNetworkTypeEnum, SYSTEMS_TFhirNetworkTypeEnum);
end;

procedure TFHIRJsonComposer.ComposeAuditEventAgentNetwork(json : TJSONWriter; name : string; elem : TFhirAuditEventAgentNetwork; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'address', elem.addressElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'address', elem.addressElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirNetworkTypeEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirNetworkTypeEnum, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseAuditEventSource(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAuditEventSource(jsn)); {2}
end;

function TFHIRJsonParser.ParseAuditEventSource(jsn : TJsonObject) : TFhirAuditEventSource;
begin
  result := TFhirAuditEventSource.create;
  try
    ParseAuditEventSourceProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseAuditEventSourceProperties(jsn : TJsonObject; result : TFhirAuditEventSource);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('site') or jsn.has('_site') then
        result.siteElement := parseString(jsn.node['site'], jsn.vObj['_site']);{q}
    if jsn.has('observer') then
        result.observer := ParseReference{TFhirPractitionerRole}(jsn.vObj['observer']);{q3}
    if jsn.has('type') then
      iterateArray(jsn.vArr['type'], result.type_List, parseCoding);
end;

procedure TFHIRJsonComposer.ComposeAuditEventSource(json : TJSONWriter; name : string; elem : TFhirAuditEventSource; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'site', elem.siteElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'site', elem.siteElement, false);
  ComposeReference{TFhirPractitionerRole}(json, 'observer', elem.observer); {a}
  if (SummaryOption in [soFull, soData]) and (elem.type_List.Count > 0) then
  begin
    json.valueArray('type');
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCoding(json, '', elem.type_List[i]); {z - Coding}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseAuditEventEntity(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAuditEventEntity(jsn)); {2}
end;

function TFHIRJsonParser.ParseAuditEventEntity(jsn : TJsonObject) : TFhirAuditEventEntity;
begin
  result := TFhirAuditEventEntity.create;
  try
    ParseAuditEventEntityProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseAuditEventEntityProperties(jsn : TJsonObject; result : TFhirAuditEventEntity);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('what') then
        result.what := ParseReference{TFhirReference}(jsn.vObj['what']);{q3}
    if jsn.has('type') then
        result.type_ := ParseCoding(jsn.vObj['type']);{q3}
    if jsn.has('role') then
        result.role := ParseCoding(jsn.vObj['role']);{q3}
    if jsn.has('lifecycle') then
        result.lifecycle := ParseCoding(jsn.vObj['lifecycle']);{q3}
    if jsn.has('securityLabel') then
      iterateArray(jsn.vArr['securityLabel'], result.securityLabelList, parseCoding);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('query') or jsn.has('_query') then
        result.queryElement := parseBase64Binary(jsn.node['query'], jsn.vObj['_query']);{q}
    if jsn.has('detail') then
      iterateArray(jsn.vArr['detail'], result.detailList, parseAuditEventEntityDetail);
end;

procedure TFHIRJsonComposer.ComposeAuditEventEntity(json : TJSONWriter; name : string; elem : TFhirAuditEventEntity; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirReference}(json, 'what', elem.what); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(json, 'role', elem.role); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(json, 'lifecycle', elem.lifecycle); {a}
  if (SummaryOption in [soFull, soData]) and (elem.securityLabelList.Count > 0) then
  begin
    json.valueArray('securityLabel');
    for i := 0 to elem.securityLabelList.Count - 1 do
      ComposeCoding(json, '', elem.securityLabelList[i]); {z - Coding}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBase64BinaryValue(json, 'query', elem.queryElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBase64BinaryProps(json, 'query', elem.queryElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.detailList.Count > 0) then
  begin
    json.valueArray('detail');
    for i := 0 to elem.detailList.Count - 1 do
      ComposeAuditEventEntityDetail(json, '', elem.detailList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseAuditEventEntityDetail(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAuditEventEntityDetail(jsn)); {2}
end;

function TFHIRJsonParser.ParseAuditEventEntityDetail(jsn : TJsonObject) : TFhirAuditEventEntityDetail;
begin
  result := TFhirAuditEventEntityDetail.create;
  try
    ParseAuditEventEntityDetailProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseAuditEventEntityDetailProperties(jsn : TJsonObject; result : TFhirAuditEventEntityDetail);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type') then
        result.type_Element := parseString(jsn.node['type'], jsn.vObj['_type']);{q}
    if jsn.has('valueString') or jsn.has('_valueString') then
      result.value := parseString(jsn.node['valueString'], jsn.vObj['_valueString']);
    if jsn.has('valueBase64Binary') or jsn.has('_valueBase64Binary') then
      result.value := parseBase64Binary(jsn.node['valueBase64Binary'], jsn.vObj['_valueBase64Binary']);
end;

procedure TFHIRJsonComposer.ComposeAuditEventEntityDetail(json : TJSONWriter; name : string; elem : TFhirAuditEventEntityDetail; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'type', elem.type_Element, false);
  ComposeStringProps(json, 'type', elem.type_Element, false);
  if (elem.value is TFhirString) then 
  begin
    ComposeStringValue(json, 'valueString', TFhirString(elem.value), false);
    ComposeStringProps(json, 'valueString', TFhirString(elem.value), false);
  end
  else if (elem.value is TFhirBase64Binary) then 
  begin
    ComposeBase64BinaryValue(json, 'valueBase64Binary', TFhirBase64Binary(elem.value), false);
    ComposeBase64BinaryProps(json, 'valueBase64Binary', TFhirBase64Binary(elem.value), false);
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseAuditEvent(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAuditEvent(jsn)); {2}
end;

function TFHIRJsonParser.ParseAuditEvent(jsn : TJsonObject) : TFhirAuditEvent;
begin
  result := TFhirAuditEvent.create;
  try
    ParseAuditEventProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseAuditEventProperties(jsn : TJsonObject; result : TFhirAuditEvent);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCoding(jsn.vObj['type']);{q3}
    if jsn.has('subtype') then
      iterateArray(jsn.vArr['subtype'], result.subtypeList, parseCoding);
    if jsn.has('action') or jsn.has('_action')  then
      result.actionElement := parseEnum(jsn.path+'/action', jsn.node['action'], jsn.vObj['_action'], CODES_TFhirAuditEventActionEnum, SYSTEMS_TFhirAuditEventActionEnum);
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q3}
    if jsn.has('recorded') or jsn.has('_recorded') then
        result.recordedElement := parseInstant(jsn.node['recorded'], jsn.vObj['_recorded']);{q}
    if jsn.has('outcome') or jsn.has('_outcome')  then
      result.outcomeElement := parseEnum(jsn.path+'/outcome', jsn.node['outcome'], jsn.vObj['_outcome'], CODES_TFhirAuditEventOutcomeEnum, SYSTEMS_TFhirAuditEventOutcomeEnum);
    if jsn.has('outcomeDesc') or jsn.has('_outcomeDesc') then
        result.outcomeDescElement := parseString(jsn.node['outcomeDesc'], jsn.vObj['_outcomeDesc']);{q}
    if jsn.has('purposeOfEvent') then
      iterateArray(jsn.vArr['purposeOfEvent'], result.purposeOfEventList, parseCodeableConcept);
    if jsn.has('agent') then
      iterateArray(jsn.vArr['agent'], result.agentList, parseAuditEventAgent);
    if jsn.has('source') then
        result.source := ParseAuditEventSource(jsn.vObj['source']);{q3}
    if jsn.has('entity') then
      iterateArray(jsn.vArr['entity'], result.entityList, parseAuditEventEntity);
end;

procedure TFHIRJsonComposer.ComposeAuditEvent(json : TJSONWriter; name : string; elem : TFhirAuditEvent; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  ComposeCoding(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subtype') and (elem.subtypeList.Count > 0) then
  begin
    json.valueArray('subtype');
    for i := 0 to elem.subtypeList.Count - 1 do
      ComposeCoding(json, '', elem.subtypeList[i]); {z - Coding}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('action') then
    ComposeEnumValue(json, 'action', elem.ActionElement, CODES_TFhirAuditEventActionEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('action') then
    ComposeEnumProps(json, 'action', elem.ActionElement, CODES_TFhirAuditEventActionEnum, false);
  if (SummaryOption in [soFull, soData]) and doCompose('period') then
    ComposePeriod(json, 'period', elem.period); {a}
  ComposeInstantValue(json, 'recorded', elem.recordedElement, false);
  ComposeInstantProps(json, 'recorded', elem.recordedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('outcome') then
    ComposeEnumValue(json, 'outcome', elem.OutcomeElement, CODES_TFhirAuditEventOutcomeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('outcome') then
    ComposeEnumProps(json, 'outcome', elem.OutcomeElement, CODES_TFhirAuditEventOutcomeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('outcomeDesc') then
    ComposeStringValue(json, 'outcomeDesc', elem.outcomeDescElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('outcomeDesc') then
    ComposeStringProps(json, 'outcomeDesc', elem.outcomeDescElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('purposeOfEvent') and (elem.purposeOfEventList.Count > 0) then
  begin
    json.valueArray('purposeOfEvent');
    for i := 0 to elem.purposeOfEventList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.purposeOfEventList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (elem.agentList.Count > 0) then
  begin
    json.valueArray('agent');
    for i := 0 to elem.agentList.Count - 1 do
      ComposeAuditEventAgent(json, '', elem.agentList[i]); {z - }
    json.FinishArray;
  end;
  ComposeAuditEventSource(json, 'source', elem.source); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('entity') and (elem.entityList.Count > 0) then
  begin
    json.valueArray('entity');
    for i := 0 to elem.entityList.Count - 1 do
      ComposeAuditEventEntity(json, '', elem.entityList[i]); {z - }
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_AUDITEVENT}
{$IFDEF FHIR_BASIC}
procedure TFHIRJsonParser.ParseBasic(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseBasic(jsn)); {2}
end;

function TFHIRJsonParser.ParseBasic(jsn : TJsonObject) : TFhirBasic;
begin
  result := TFhirBasic.create;
  try
    ParseBasicProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseBasicProperties(jsn : TJsonObject; result : TFhirBasic);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirReference}(jsn.vObj['subject']);{q3}
    if jsn.has('created') or jsn.has('_created') then
        result.createdElement := parseDate(jsn.node['created'], jsn.vObj['_created']);{q}
    if jsn.has('author') then
        result.author := ParseReference{TFhirPractitioner}(jsn.vObj['author']);{q3}
end;

procedure TFHIRJsonComposer.ComposeBasic(json : TJSONWriter; name : string; elem : TFhirBasic; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{TFhirReference}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('created') then
    ComposeDateValue(json, 'created', elem.createdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('created') then
    ComposeDateProps(json, 'created', elem.createdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('author') then
    ComposeReference{TFhirPractitioner}(json, 'author', elem.author); {a}
end;

{$ENDIF FHIR_BASIC}
{$IFDEF FHIR_BINARY}
procedure TFHIRJsonParser.ParseBinary(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseBinary(jsn)); {2}
end;

function TFHIRJsonParser.ParseBinary(jsn : TJsonObject) : TFhirBinary;
begin
  result := TFhirBinary.create;
  try
    ParseBinaryProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseBinaryProperties(jsn : TJsonObject; result : TFhirBinary);
begin
    ParseResourceProperties(jsn, result);
    if jsn.has('contentType') or jsn.has('_contentType') then
        result.contentTypeElement := parseCode(jsn.node['contentType'], jsn.vObj['_contentType']);{q}
    if jsn.has('securityContext') then
        result.securityContext := ParseReference{TFhirReference}(jsn.vObj['securityContext']);{q3}
    if jsn.has('data') or jsn.has('_data') then
        result.dataElement := parseBase64Binary(jsn.node['data'], jsn.vObj['_data']);{q}
end;

procedure TFHIRJsonComposer.ComposeBinary(json : TJSONWriter; name : string; elem : TFhirBinary; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  ComposeCodeValue(json, 'contentType', elem.contentTypeElement, false);
  ComposeCodeProps(json, 'contentType', elem.contentTypeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('securityContext') then
    ComposeReference{TFhirReference}(json, 'securityContext', elem.securityContext); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('data') then
    ComposeBase64BinaryValue(json, 'data', elem.dataElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('data') then
    ComposeBase64BinaryProps(json, 'data', elem.dataElement, false);
end;

{$ENDIF FHIR_BINARY}
{$IFDEF FHIR_BIOLOGICALLYDERIVEDPRODUCT}
procedure TFHIRJsonParser.ParseBiologicallyDerivedProductCollection(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseBiologicallyDerivedProductCollection(jsn)); {2}
end;

function TFHIRJsonParser.ParseBiologicallyDerivedProductCollection(jsn : TJsonObject) : TFhirBiologicallyDerivedProductCollection;
begin
  result := TFhirBiologicallyDerivedProductCollection.create;
  try
    ParseBiologicallyDerivedProductCollectionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseBiologicallyDerivedProductCollectionProperties(jsn : TJsonObject; result : TFhirBiologicallyDerivedProductCollection);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('collector') then
        result.collector := ParseReference{TFhirPractitioner}(jsn.vObj['collector']);{q3}
    if jsn.has('source') then
        result.source := ParseReference{TFhirPatient}(jsn.vObj['source']);{q3}
    if jsn.has('collectedPeriod') {a4} then
      result.collected := ParsePeriod(jsn.vObj['collectedPeriod']);
    if jsn.has('collectedDateTime') or jsn.has('_collectedDateTime') then
      result.collected := parseDateTime(jsn.node['collectedDateTime'], jsn.vObj['_collectedDateTime']);
end;

procedure TFHIRJsonComposer.ComposeBiologicallyDerivedProductCollection(json : TJSONWriter; name : string; elem : TFhirBiologicallyDerivedProductCollection; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirPractitioner}(json, 'collector', elem.collector); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirPatient}(json, 'source', elem.source); {a}
  if (SummaryOption in [soFull, soData]) and (elem.collected is TFhirPeriod) then 
    ComposePeriod(json, 'collectedPeriod', TFhirPeriod(elem.collected)) 
  else if (SummaryOption in [soFull, soData]) and (elem.collected is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'collectedDateTime', TFhirDateTime(elem.collected), false);
    ComposeDateTimeProps(json, 'collectedDateTime', TFhirDateTime(elem.collected), false);
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseBiologicallyDerivedProductProcessing(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseBiologicallyDerivedProductProcessing(jsn)); {2}
end;

function TFHIRJsonParser.ParseBiologicallyDerivedProductProcessing(jsn : TJsonObject) : TFhirBiologicallyDerivedProductProcessing;
begin
  result := TFhirBiologicallyDerivedProductProcessing.create;
  try
    ParseBiologicallyDerivedProductProcessingProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseBiologicallyDerivedProductProcessingProperties(jsn : TJsonObject; result : TFhirBiologicallyDerivedProductProcessing);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('procedure') then
        result.procedure_ := ParseCodeableConcept(jsn.vObj['procedure']);{q3}
    if jsn.has('additive') then
        result.additive := ParseReference{TFhirSubstance}(jsn.vObj['additive']);{q3}
    if jsn.has('timePeriod') {a4} then
      result.time := ParsePeriod(jsn.vObj['timePeriod']);
    if jsn.has('timeDateTime') or jsn.has('_timeDateTime') then
      result.time := parseDateTime(jsn.node['timeDateTime'], jsn.vObj['_timeDateTime']);
end;

procedure TFHIRJsonComposer.ComposeBiologicallyDerivedProductProcessing(json : TJSONWriter; name : string; elem : TFhirBiologicallyDerivedProductProcessing; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'procedure', elem.procedure_); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirSubstance}(json, 'additive', elem.additive); {a}
  if (SummaryOption in [soFull, soData]) and (elem.time is TFhirPeriod) then 
    ComposePeriod(json, 'timePeriod', TFhirPeriod(elem.time)) 
  else if (SummaryOption in [soFull, soData]) and (elem.time is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'timeDateTime', TFhirDateTime(elem.time), false);
    ComposeDateTimeProps(json, 'timeDateTime', TFhirDateTime(elem.time), false);
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseBiologicallyDerivedProductManipulation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseBiologicallyDerivedProductManipulation(jsn)); {2}
end;

function TFHIRJsonParser.ParseBiologicallyDerivedProductManipulation(jsn : TJsonObject) : TFhirBiologicallyDerivedProductManipulation;
begin
  result := TFhirBiologicallyDerivedProductManipulation.create;
  try
    ParseBiologicallyDerivedProductManipulationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseBiologicallyDerivedProductManipulationProperties(jsn : TJsonObject; result : TFhirBiologicallyDerivedProductManipulation);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('timePeriod') {a4} then
      result.time := ParsePeriod(jsn.vObj['timePeriod']);
    if jsn.has('timeDateTime') or jsn.has('_timeDateTime') then
      result.time := parseDateTime(jsn.node['timeDateTime'], jsn.vObj['_timeDateTime']);
end;

procedure TFHIRJsonComposer.ComposeBiologicallyDerivedProductManipulation(json : TJSONWriter; name : string; elem : TFhirBiologicallyDerivedProductManipulation; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.time is TFhirPeriod) then 
    ComposePeriod(json, 'timePeriod', TFhirPeriod(elem.time)) 
  else if (SummaryOption in [soFull, soData]) and (elem.time is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'timeDateTime', TFhirDateTime(elem.time), false);
    ComposeDateTimeProps(json, 'timeDateTime', TFhirDateTime(elem.time), false);
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseBiologicallyDerivedProductStorage(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseBiologicallyDerivedProductStorage(jsn)); {2}
end;

function TFHIRJsonParser.ParseBiologicallyDerivedProductStorage(jsn : TJsonObject) : TFhirBiologicallyDerivedProductStorage;
begin
  result := TFhirBiologicallyDerivedProductStorage.create;
  try
    ParseBiologicallyDerivedProductStorageProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseBiologicallyDerivedProductStorageProperties(jsn : TJsonObject; result : TFhirBiologicallyDerivedProductStorage);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('temperature') or jsn.has('_temperature') then
        result.temperatureElement := parseDecimal(jsn.node['temperature'], jsn.vObj['_temperature']);{q}
    if jsn.has('scale') or jsn.has('_scale')  then
      result.scaleElement := parseEnum(jsn.path+'/scale', jsn.node['scale'], jsn.vObj['_scale'], CODES_TFhirProductStorageScaleEnum, SYSTEMS_TFhirProductStorageScaleEnum);
    if jsn.has('duration') then
        result.duration := ParsePeriod(jsn.vObj['duration']);{q3}
end;

procedure TFHIRJsonComposer.ComposeBiologicallyDerivedProductStorage(json : TJSONWriter; name : string; elem : TFhirBiologicallyDerivedProductStorage; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalValue(json, 'temperature', elem.temperatureElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalProps(json, 'temperature', elem.temperatureElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumValue(json, 'scale', elem.ScaleElement, CODES_TFhirProductStorageScaleEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumProps(json, 'scale', elem.ScaleElement, CODES_TFhirProductStorageScaleEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(json, 'duration', elem.duration); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseBiologicallyDerivedProduct(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseBiologicallyDerivedProduct(jsn)); {2}
end;

function TFHIRJsonParser.ParseBiologicallyDerivedProduct(jsn : TJsonObject) : TFhirBiologicallyDerivedProduct;
begin
  result := TFhirBiologicallyDerivedProduct.create;
  try
    ParseBiologicallyDerivedProductProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseBiologicallyDerivedProductProperties(jsn : TJsonObject; result : TFhirBiologicallyDerivedProduct);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('productCategory') or jsn.has('_productCategory')  then
      result.productCategoryElement := parseEnum(jsn.path+'/productCategory', jsn.node['productCategory'], jsn.vObj['_productCategory'], CODES_TFhirProductCategoryEnum, SYSTEMS_TFhirProductCategoryEnum);
    if jsn.has('productCode') then
        result.productCode := ParseCodeableConcept(jsn.vObj['productCode']);{q3}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirProductStatusEnum, SYSTEMS_TFhirProductStatusEnum);
    if jsn.has('request') then
      iterateArray(jsn.vArr['request'], result.requestList, parseReference{TFhirServiceRequest});
    if jsn.has('quantity') or jsn.has('_quantity') then
        result.quantityElement := parseInteger(jsn.node['quantity'], jsn.vObj['_quantity']);{q}
    if jsn.has('parent') then
      iterateArray(jsn.vArr['parent'], result.parentList, parseReference{TFhirBiologicallyDerivedProduct});
    if jsn.has('collection') then
        result.collection := ParseBiologicallyDerivedProductCollection(jsn.vObj['collection']);{q3}
    if jsn.has('processing') then
      iterateArray(jsn.vArr['processing'], result.processingList, parseBiologicallyDerivedProductProcessing);
    if jsn.has('manipulation') then
        result.manipulation := ParseBiologicallyDerivedProductManipulation(jsn.vObj['manipulation']);{q3}
    if jsn.has('storage') then
      iterateArray(jsn.vArr['storage'], result.storageList, parseBiologicallyDerivedProductStorage);
end;

procedure TFHIRJsonComposer.ComposeBiologicallyDerivedProduct(json : TJSONWriter; name : string; elem : TFhirBiologicallyDerivedProduct; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('productCategory') then
    ComposeEnumValue(json, 'productCategory', elem.ProductCategoryElement, CODES_TFhirProductCategoryEnum, false);
  if (SummaryOption in [soFull, soData]) and doCompose('productCategory') then
    ComposeEnumProps(json, 'productCategory', elem.ProductCategoryElement, CODES_TFhirProductCategoryEnum, false);
  if (SummaryOption in [soFull, soData]) and doCompose('productCode') then
    ComposeCodeableConcept(json, 'productCode', elem.productCode); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('status') then
    ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirProductStatusEnum, false);
  if (SummaryOption in [soFull, soData]) and doCompose('status') then
    ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirProductStatusEnum, false);
  if (SummaryOption in [soFull, soData]) and doCompose('request') and (elem.requestList.Count > 0) then
  begin
    json.valueArray('request');
    for i := 0 to elem.requestList.Count - 1 do
      ComposeReference{TFhirServiceRequest}(json, '', elem.requestList[i]); {z - Reference(ServiceRequest)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('quantity') then
    ComposeIntegerValue(json, 'quantity', elem.quantityElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('quantity') then
    ComposeIntegerProps(json, 'quantity', elem.quantityElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('parent') and (elem.parentList.Count > 0) then
  begin
    json.valueArray('parent');
    for i := 0 to elem.parentList.Count - 1 do
      ComposeReference{TFhirBiologicallyDerivedProduct}(json, '', elem.parentList[i]); {z - Reference(BiologicallyDerivedProduct)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('collection') then
    ComposeBiologicallyDerivedProductCollection(json, 'collection', elem.collection); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('processing') and (elem.processingList.Count > 0) then
  begin
    json.valueArray('processing');
    for i := 0 to elem.processingList.Count - 1 do
      ComposeBiologicallyDerivedProductProcessing(json, '', elem.processingList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('manipulation') then
    ComposeBiologicallyDerivedProductManipulation(json, 'manipulation', elem.manipulation); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('storage') and (elem.storageList.Count > 0) then
  begin
    json.valueArray('storage');
    for i := 0 to elem.storageList.Count - 1 do
      ComposeBiologicallyDerivedProductStorage(json, '', elem.storageList[i]); {z - }
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_BIOLOGICALLYDERIVEDPRODUCT}
{$IFDEF FHIR_BODYSTRUCTURE}
procedure TFHIRJsonParser.ParseBodyStructure(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseBodyStructure(jsn)); {2}
end;

function TFHIRJsonParser.ParseBodyStructure(jsn : TJsonObject) : TFhirBodyStructure;
begin
  result := TFhirBodyStructure.create;
  try
    ParseBodyStructureProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseBodyStructureProperties(jsn : TJsonObject; result : TFhirBodyStructure);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('active') or jsn.has('_active') then
        result.activeElement := parseBoolean(jsn.node['active'], jsn.vObj['_active']);{q}
    if jsn.has('morphology') then
        result.morphology := ParseCodeableConcept(jsn.vObj['morphology']);{q3}
    if jsn.has('location') then
        result.location := ParseCodeableConcept(jsn.vObj['location']);{q3}
    if jsn.has('locationQualifier') then
      iterateArray(jsn.vArr['locationQualifier'], result.locationQualifierList, parseCodeableConcept);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('image') then
      iterateArray(jsn.vArr['image'], result.imageList, parseAttachment);
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q3}
end;

procedure TFHIRJsonComposer.ComposeBodyStructure(json : TJSONWriter; name : string; elem : TFhirBodyStructure; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('active') then
    ComposeBooleanValue(json, 'active', elem.activeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('active') then
    ComposeBooleanProps(json, 'active', elem.activeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('morphology') then
    ComposeCodeableConcept(json, 'morphology', elem.morphology); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('location') then
    ComposeCodeableConcept(json, 'location', elem.location); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('locationQualifier') and (elem.locationQualifierList.Count > 0) then
  begin
    json.valueArray('locationQualifier');
    for i := 0 to elem.locationQualifierList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.locationQualifierList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('image') and (elem.imageList.Count > 0) then
  begin
    json.valueArray('image');
    for i := 0 to elem.imageList.Count - 1 do
      ComposeAttachment(json, '', elem.imageList[i]); {z - Attachment}
    json.FinishArray;
  end;
  ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
end;

{$ENDIF FHIR_BODYSTRUCTURE}
{$IFDEF FHIR_BUNDLE}
procedure TFHIRJsonParser.ParseBundleLink(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseBundleLink(jsn)); {2}
end;

function TFHIRJsonParser.ParseBundleLink(jsn : TJsonObject) : TFhirBundleLink;
begin
  result := TFhirBundleLink.create;
  try
    ParseBundleLinkProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseBundleLinkProperties(jsn : TJsonObject; result : TFhirBundleLink);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('relation') or jsn.has('_relation') then
        result.relationElement := parseString(jsn.node['relation'], jsn.vObj['_relation']);{q}
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := parseUri(jsn.node['url'], jsn.vObj['_url']);{q}
end;

procedure TFHIRJsonComposer.ComposeBundleLink(json : TJSONWriter; name : string; elem : TFhirBundleLink; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'relation', elem.relationElement, false);
  ComposeStringProps(json, 'relation', elem.relationElement, false);
  ComposeUriValue(json, 'url', elem.urlElement, false);
  ComposeUriProps(json, 'url', elem.urlElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseBundleEntry(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseBundleEntry(jsn)); {2}
end;

function TFHIRJsonParser.ParseBundleEntry(jsn : TJsonObject) : TFhirBundleEntry;
begin
  result := TFhirBundleEntry.create;
  try
    ParseBundleEntryProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseBundleEntryProperties(jsn : TJsonObject; result : TFhirBundleEntry);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('link') then
      iterateArray(jsn.vArr['link'], result.link_List, parseBundleLink);
    if jsn.has('fullUrl') or jsn.has('_fullUrl') then
        result.fullUrlElement := parseUri(jsn.node['fullUrl'], jsn.vObj['_fullUrl']);{q}
    if jsn.has('resource') then
        result.resource := ParseInnerResource(jsn.vObj['resource']);{q3}
    if jsn.has('search') then
        result.search := ParseBundleEntrySearch(jsn.vObj['search']);{q3}
    if jsn.has('request') then
        result.request := ParseBundleEntryRequest(jsn.vObj['request']);{q3}
    if jsn.has('response') then
        result.response := ParseBundleEntryResponse(jsn.vObj['response']);{q3}
end;

procedure TFHIRJsonComposer.ComposeBundleEntry(json : TJSONWriter; name : string; elem : TFhirBundleEntry; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.link_List.Count > 0) then
  begin
    json.valueArray('link');
    for i := 0 to elem.link_List.Count - 1 do
      ComposeBundleLink(json, '', elem.link_List[i]); {z - @Bundle.link}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUriValue(json, 'fullUrl', elem.fullUrlElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUriProps(json, 'fullUrl', elem.fullUrlElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInnerResource(json, 'resource', elem, elem.resource); {a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBundleEntrySearch(json, 'search', elem.search); {a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBundleEntryRequest(json, 'request', elem.request); {a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBundleEntryResponse(json, 'response', elem.response); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseBundleEntrySearch(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseBundleEntrySearch(jsn)); {2}
end;

function TFHIRJsonParser.ParseBundleEntrySearch(jsn : TJsonObject) : TFhirBundleEntrySearch;
begin
  result := TFhirBundleEntrySearch.create;
  try
    ParseBundleEntrySearchProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseBundleEntrySearchProperties(jsn : TJsonObject; result : TFhirBundleEntrySearch);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('mode') or jsn.has('_mode')  then
      result.modeElement := parseEnum(jsn.path+'/mode', jsn.node['mode'], jsn.vObj['_mode'], CODES_TFhirSearchEntryModeEnum, SYSTEMS_TFhirSearchEntryModeEnum);
    if jsn.has('score') or jsn.has('_score') then
        result.scoreElement := parseDecimal(jsn.node['score'], jsn.vObj['_score']);{q}
end;

procedure TFHIRJsonComposer.ComposeBundleEntrySearch(json : TJSONWriter; name : string; elem : TFhirBundleEntrySearch; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeEnumValue(json, 'mode', elem.ModeElement, CODES_TFhirSearchEntryModeEnum, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeEnumProps(json, 'mode', elem.ModeElement, CODES_TFhirSearchEntryModeEnum, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDecimalValue(json, 'score', elem.scoreElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDecimalProps(json, 'score', elem.scoreElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseBundleEntryRequest(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseBundleEntryRequest(jsn)); {2}
end;

function TFHIRJsonParser.ParseBundleEntryRequest(jsn : TJsonObject) : TFhirBundleEntryRequest;
begin
  result := TFhirBundleEntryRequest.create;
  try
    ParseBundleEntryRequestProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseBundleEntryRequestProperties(jsn : TJsonObject; result : TFhirBundleEntryRequest);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('method') or jsn.has('_method')  then
      result.methodElement := parseEnum(jsn.path+'/method', jsn.node['method'], jsn.vObj['_method'], CODES_TFhirHttpVerbEnum, SYSTEMS_TFhirHttpVerbEnum);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := parseUri(jsn.node['url'], jsn.vObj['_url']);{q}
    if jsn.has('ifNoneMatch') or jsn.has('_ifNoneMatch') then
        result.ifNoneMatchElement := parseString(jsn.node['ifNoneMatch'], jsn.vObj['_ifNoneMatch']);{q}
    if jsn.has('ifModifiedSince') or jsn.has('_ifModifiedSince') then
        result.ifModifiedSinceElement := parseInstant(jsn.node['ifModifiedSince'], jsn.vObj['_ifModifiedSince']);{q}
    if jsn.has('ifMatch') or jsn.has('_ifMatch') then
        result.ifMatchElement := parseString(jsn.node['ifMatch'], jsn.vObj['_ifMatch']);{q}
    if jsn.has('ifNoneExist') or jsn.has('_ifNoneExist') then
        result.ifNoneExistElement := parseString(jsn.node['ifNoneExist'], jsn.vObj['_ifNoneExist']);{q}
end;

procedure TFHIRJsonComposer.ComposeBundleEntryRequest(json : TJSONWriter; name : string; elem : TFhirBundleEntryRequest; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'method', elem.MethodElement, CODES_TFhirHttpVerbEnum, false);
  ComposeEnumProps(json, 'method', elem.MethodElement, CODES_TFhirHttpVerbEnum, false);
  ComposeUriValue(json, 'url', elem.urlElement, false);
  ComposeUriProps(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'ifNoneMatch', elem.ifNoneMatchElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'ifNoneMatch', elem.ifNoneMatchElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInstantValue(json, 'ifModifiedSince', elem.ifModifiedSinceElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInstantProps(json, 'ifModifiedSince', elem.ifModifiedSinceElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'ifMatch', elem.ifMatchElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'ifMatch', elem.ifMatchElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'ifNoneExist', elem.ifNoneExistElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'ifNoneExist', elem.ifNoneExistElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseBundleEntryResponse(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseBundleEntryResponse(jsn)); {2}
end;

function TFHIRJsonParser.ParseBundleEntryResponse(jsn : TJsonObject) : TFhirBundleEntryResponse;
begin
  result := TFhirBundleEntryResponse.create;
  try
    ParseBundleEntryResponseProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseBundleEntryResponseProperties(jsn : TJsonObject; result : TFhirBundleEntryResponse);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('status') or jsn.has('_status') then
        result.statusElement := parseString(jsn.node['status'], jsn.vObj['_status']);{q}
    if jsn.has('location') or jsn.has('_location') then
        result.locationElement := parseUri(jsn.node['location'], jsn.vObj['_location']);{q}
    if jsn.has('etag') or jsn.has('_etag') then
        result.etagElement := parseString(jsn.node['etag'], jsn.vObj['_etag']);{q}
    if jsn.has('lastModified') or jsn.has('_lastModified') then
        result.lastModifiedElement := parseInstant(jsn.node['lastModified'], jsn.vObj['_lastModified']);{q}
    if jsn.has('outcome') then
        result.outcome := ParseInnerResource(jsn.vObj['outcome']);{q3}
end;

procedure TFHIRJsonComposer.ComposeBundleEntryResponse(json : TJSONWriter; name : string; elem : TFhirBundleEntryResponse; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'status', elem.statusElement, false);
  ComposeStringProps(json, 'status', elem.statusElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUriValue(json, 'location', elem.locationElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUriProps(json, 'location', elem.locationElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'etag', elem.etagElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'etag', elem.etagElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInstantValue(json, 'lastModified', elem.lastModifiedElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInstantProps(json, 'lastModified', elem.lastModifiedElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInnerResource(json, 'outcome', elem, elem.outcome); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseBundle(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseBundle(jsn)); {2}
end;

function TFHIRJsonParser.ParseBundle(jsn : TJsonObject) : TFhirBundle;
begin
  result := TFhirBundle.create;
  try
    ParseBundleProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseBundleProperties(jsn : TJsonObject; result : TFhirBundle);
begin
    ParseResourceProperties(jsn, result);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q3}
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn.node['type'], jsn.vObj['_type'], CODES_TFhirBundleTypeEnum, SYSTEMS_TFhirBundleTypeEnum);
    if jsn.has('timestamp') or jsn.has('_timestamp') then
        result.timestampElement := parseInstant(jsn.node['timestamp'], jsn.vObj['_timestamp']);{q}
    if jsn.has('total') or jsn.has('_total') then
        result.totalElement := parseUnsignedInt(jsn.node['total'], jsn.vObj['_total']);{q}
    if jsn.has('link') then
      iterateArray(jsn.vArr['link'], result.link_List, parseBundleLink);
    if jsn.has('entry') then
      iterateArray(jsn.vArr['entry'], result.entryList, parseBundleEntry);
    if jsn.has('signature') then
        result.signature := ParseSignature(jsn.vObj['signature']);{q3}
end;

procedure TFHIRJsonComposer.ComposeBundle(json : TJSONWriter; name : string; elem : TFhirBundle; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirBundleTypeEnum, false);
  ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirBundleTypeEnum, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInstantValue(json, 'timestamp', elem.timestampElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInstantProps(json, 'timestamp', elem.timestampElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData, soCount]) then
    ComposeUnsignedIntValue(json, 'total', elem.totalElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData, soCount]) then
    ComposeUnsignedIntProps(json, 'total', elem.totalElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.link_List.Count > 0) then
  begin
    json.valueArray('link');
    for i := 0 to elem.link_List.Count - 1 do
      ComposeBundleLink(json, '', elem.link_List[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.entryList.Count > 0) then
  begin
    json.valueArray('entry');
    for i := 0 to elem.entryList.Count - 1 do
      ComposeBundleEntry(json, '', elem.entryList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeSignature(json, 'signature', elem.signature); {a}
end;

{$ENDIF FHIR_BUNDLE}
{$IFDEF FHIR_CAPABILITYSTATEMENT}
procedure TFHIRJsonParser.ParseCapabilityStatementSoftware(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCapabilityStatementSoftware(jsn)); {2}
end;

function TFHIRJsonParser.ParseCapabilityStatementSoftware(jsn : TJsonObject) : TFhirCapabilityStatementSoftware;
begin
  result := TFhirCapabilityStatementSoftware.create;
  try
    ParseCapabilityStatementSoftwareProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCapabilityStatementSoftwareProperties(jsn : TJsonObject; result : TFhirCapabilityStatementSoftware);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := parseString(jsn.node['version'], jsn.vObj['_version']);{q}
    if jsn.has('releaseDate') or jsn.has('_releaseDate') then
        result.releaseDateElement := parseDateTime(jsn.node['releaseDate'], jsn.vObj['_releaseDate']);{q}
end;

procedure TFHIRJsonComposer.ComposeCapabilityStatementSoftware(json : TJSONWriter; name : string; elem : TFhirCapabilityStatementSoftware; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'name', elem.nameElement, false);
  ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'releaseDate', elem.releaseDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'releaseDate', elem.releaseDateElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseCapabilityStatementImplementation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCapabilityStatementImplementation(jsn)); {2}
end;

function TFHIRJsonParser.ParseCapabilityStatementImplementation(jsn : TJsonObject) : TFhirCapabilityStatementImplementation;
begin
  result := TFhirCapabilityStatementImplementation.create;
  try
    ParseCapabilityStatementImplementationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCapabilityStatementImplementationProperties(jsn : TJsonObject; result : TFhirCapabilityStatementImplementation);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := parseUrl(jsn.node['url'], jsn.vObj['_url']);{q}
    if jsn.has('custodian') then
        result.custodian := ParseReference{TFhirOrganization}(jsn.vObj['custodian']);{q3}
end;

procedure TFHIRJsonComposer.ComposeCapabilityStatementImplementation(json : TJSONWriter; name : string; elem : TFhirCapabilityStatementImplementation; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'description', elem.descriptionElement, false);
  ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUrlValue(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUrlProps(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(json, 'custodian', elem.custodian); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseCapabilityStatementRest(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCapabilityStatementRest(jsn)); {2}
end;

function TFHIRJsonParser.ParseCapabilityStatementRest(jsn : TJsonObject) : TFhirCapabilityStatementRest;
begin
  result := TFhirCapabilityStatementRest.create;
  try
    ParseCapabilityStatementRestProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCapabilityStatementRestProperties(jsn : TJsonObject; result : TFhirCapabilityStatementRest);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('mode') or jsn.has('_mode')  then
      result.modeElement := parseEnum(jsn.path+'/mode', jsn.node['mode'], jsn.vObj['_mode'], CODES_TFhirRestfulCapabilityModeEnum, SYSTEMS_TFhirRestfulCapabilityModeEnum);
    if jsn.has('documentation') or jsn.has('_documentation') then
        result.documentationElement := parseMarkdown(jsn.node['documentation'], jsn.vObj['_documentation']);{q}
    if jsn.has('security') then
        result.security := ParseCapabilityStatementRestSecurity(jsn.vObj['security']);{q3}
    if jsn.has('resource') then
      iterateArray(jsn.vArr['resource'], result.resourceList, parseCapabilityStatementRestResource);
    if jsn.has('interaction') then
      iterateArray(jsn.vArr['interaction'], result.interactionList, parseCapabilityStatementRestInteraction);
    if jsn.has('searchParam') then
      iterateArray(jsn.vArr['searchParam'], result.searchParamList, parseCapabilityStatementRestResourceSearchParam);
    if jsn.has('operation') then
      iterateArray(jsn.vArr['operation'], result.operationList, parseCapabilityStatementRestResourceOperation);
      if jsn.has('compartment') or jsn.has('_compartment') then
      iteratePrimitiveArray(jsn.vArr['compartment'], jsn.vArr['_compartment'], result.compartmentList, parseCanonical);
end;

procedure TFHIRJsonComposer.ComposeCapabilityStatementRest(json : TJSONWriter; name : string; elem : TFhirCapabilityStatementRest; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'mode', elem.ModeElement, CODES_TFhirRestfulCapabilityModeEnum, false);
  ComposeEnumProps(json, 'mode', elem.ModeElement, CODES_TFhirRestfulCapabilityModeEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdownValue(json, 'documentation', elem.documentationElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdownProps(json, 'documentation', elem.documentationElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCapabilityStatementRestSecurity(json, 'security', elem.security); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.resourceList.Count > 0) then
  begin
    json.valueArray('resource');
    for i := 0 to elem.resourceList.Count - 1 do
      ComposeCapabilityStatementRestResource(json, '', elem.resourceList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.interactionList.Count > 0) then
  begin
    json.valueArray('interaction');
    for i := 0 to elem.interactionList.Count - 1 do
      ComposeCapabilityStatementRestInteraction(json, '', elem.interactionList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.searchParamList.Count > 0) then
  begin
    json.valueArray('searchParam');
    for i := 0 to elem.searchParamList.Count - 1 do
      ComposeCapabilityStatementRestResourceSearchParam(json, '', elem.searchParamList[i]); {z - @CapabilityStatement.rest.resource.searchParam}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.operationList.Count > 0) then
  begin
    json.valueArray('operation');
    for i := 0 to elem.operationList.Count - 1 do
      ComposeCapabilityStatementRestResourceOperation(json, '', elem.operationList[i]); {z - @CapabilityStatement.rest.resource.operation}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.compartmentList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.compartmentList.Count - 1 do
    begin
      ext := ext or ((elem.compartmentList[i].id <> '') or (elem.compartmentList[i].hasExtensionList) {no-comments or (elem.compartmentList[i].hasComments)});
      val := val or (elem.compartmentList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('compartment');
      for i := 0 to elem.compartmentList.Count - 1 do
        ComposeCanonicalValue(json, '',elem.compartmentList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_compartment');
      for i := 0 to elem.compartmentList.Count - 1 do
        ComposeCanonicalProps(json, '',elem.compartmentList[i], true);
      json.FinishArray;
    end;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseCapabilityStatementRestSecurity(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCapabilityStatementRestSecurity(jsn)); {2}
end;

function TFHIRJsonParser.ParseCapabilityStatementRestSecurity(jsn : TJsonObject) : TFhirCapabilityStatementRestSecurity;
begin
  result := TFhirCapabilityStatementRestSecurity.create;
  try
    ParseCapabilityStatementRestSecurityProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCapabilityStatementRestSecurityProperties(jsn : TJsonObject; result : TFhirCapabilityStatementRestSecurity);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('cors') or jsn.has('_cors') then
        result.corsElement := parseBoolean(jsn.node['cors'], jsn.vObj['_cors']);{q}
    if jsn.has('service') then
      iterateArray(jsn.vArr['service'], result.serviceList, parseCodeableConcept);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseMarkdown(jsn.node['description'], jsn.vObj['_description']);{q}
end;

procedure TFHIRJsonComposer.ComposeCapabilityStatementRestSecurity(json : TJSONWriter; name : string; elem : TFhirCapabilityStatementRestSecurity; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBooleanValue(json, 'cors', elem.corsElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBooleanProps(json, 'cors', elem.corsElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.serviceList.Count > 0) then
  begin
    json.valueArray('service');
    for i := 0 to elem.serviceList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.serviceList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdownValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdownProps(json, 'description', elem.descriptionElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseCapabilityStatementRestResource(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCapabilityStatementRestResource(jsn)); {2}
end;

function TFHIRJsonParser.ParseCapabilityStatementRestResource(jsn : TJsonObject) : TFhirCapabilityStatementRestResource;
begin
  result := TFhirCapabilityStatementRestResource.create;
  try
    ParseCapabilityStatementRestResourceProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCapabilityStatementRestResourceProperties(jsn : TJsonObject; result : TFhirCapabilityStatementRestResource);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn.node['type'], jsn.vObj['_type'], CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum);
    if jsn.has('profile') or jsn.has('_profile') then
        result.profileElement := parseCanonical(jsn.node['profile'], jsn.vObj['_profile']);{q}
      if jsn.has('supportedProfile') or jsn.has('_supportedProfile') then
      iteratePrimitiveArray(jsn.vArr['supportedProfile'], jsn.vArr['_supportedProfile'], result.supportedProfileList, parseCanonical);
    if jsn.has('documentation') or jsn.has('_documentation') then
        result.documentationElement := parseMarkdown(jsn.node['documentation'], jsn.vObj['_documentation']);{q}
    if jsn.has('interaction') then
      iterateArray(jsn.vArr['interaction'], result.interactionList, parseCapabilityStatementRestResourceInteraction);
    if jsn.has('versioning') or jsn.has('_versioning')  then
      result.versioningElement := parseEnum(jsn.path+'/versioning', jsn.node['versioning'], jsn.vObj['_versioning'], CODES_TFhirVersioningPolicyEnum, SYSTEMS_TFhirVersioningPolicyEnum);
    if jsn.has('readHistory') or jsn.has('_readHistory') then
        result.readHistoryElement := parseBoolean(jsn.node['readHistory'], jsn.vObj['_readHistory']);{q}
    if jsn.has('updateCreate') or jsn.has('_updateCreate') then
        result.updateCreateElement := parseBoolean(jsn.node['updateCreate'], jsn.vObj['_updateCreate']);{q}
    if jsn.has('conditionalCreate') or jsn.has('_conditionalCreate') then
        result.conditionalCreateElement := parseBoolean(jsn.node['conditionalCreate'], jsn.vObj['_conditionalCreate']);{q}
    if jsn.has('conditionalRead') or jsn.has('_conditionalRead')  then
      result.conditionalReadElement := parseEnum(jsn.path+'/conditionalRead', jsn.node['conditionalRead'], jsn.vObj['_conditionalRead'], CODES_TFhirConditionalReadStatusEnum, SYSTEMS_TFhirConditionalReadStatusEnum);
    if jsn.has('conditionalUpdate') or jsn.has('_conditionalUpdate') then
        result.conditionalUpdateElement := parseBoolean(jsn.node['conditionalUpdate'], jsn.vObj['_conditionalUpdate']);{q}
    if jsn.has('conditionalDelete') or jsn.has('_conditionalDelete')  then
      result.conditionalDeleteElement := parseEnum(jsn.path+'/conditionalDelete', jsn.node['conditionalDelete'], jsn.vObj['_conditionalDelete'], CODES_TFhirConditionalDeleteStatusEnum, SYSTEMS_TFhirConditionalDeleteStatusEnum);
    if jsn.has('referencePolicy') or jsn.has('_referencePolicy') then
      iterateEnumArray(jsn.vArr['referencePolicy'], jsn.vArr['_referencePolicy'], jsn.path+'/referencePolicy', result.referencePolicyList, parseEnum, CODES_TFhirReferenceHandlingPolicyEnum, SYSTEMS_TFhirReferenceHandlingPolicyEnum);
      if jsn.has('searchInclude') or jsn.has('_searchInclude') then
      iteratePrimitiveArray(jsn.vArr['searchInclude'], jsn.vArr['_searchInclude'], result.searchIncludeList, parseString);
      if jsn.has('searchRevInclude') or jsn.has('_searchRevInclude') then
      iteratePrimitiveArray(jsn.vArr['searchRevInclude'], jsn.vArr['_searchRevInclude'], result.searchRevIncludeList, parseString);
    if jsn.has('searchParam') then
      iterateArray(jsn.vArr['searchParam'], result.searchParamList, parseCapabilityStatementRestResourceSearchParam);
    if jsn.has('operation') then
      iterateArray(jsn.vArr['operation'], result.operationList, parseCapabilityStatementRestResourceOperation);
end;

procedure TFHIRJsonComposer.ComposeCapabilityStatementRestResource(json : TJSONWriter; name : string; elem : TFhirCapabilityStatementRestResource; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirResourceTypesEnum, false);
  ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirResourceTypesEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCanonicalValue(json, 'profile', elem.profileElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCanonicalProps(json, 'profile', elem.profileElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.supportedProfileList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.supportedProfileList.Count - 1 do
    begin
      ext := ext or ((elem.supportedProfileList[i].id <> '') or (elem.supportedProfileList[i].hasExtensionList) {no-comments or (elem.supportedProfileList[i].hasComments)});
      val := val or (elem.supportedProfileList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('supportedProfile');
      for i := 0 to elem.supportedProfileList.Count - 1 do
        ComposeCanonicalValue(json, '',elem.supportedProfileList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_supportedProfile');
      for i := 0 to elem.supportedProfileList.Count - 1 do
        ComposeCanonicalProps(json, '',elem.supportedProfileList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdownValue(json, 'documentation', elem.documentationElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdownProps(json, 'documentation', elem.documentationElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.interactionList.Count > 0) then
  begin
    json.valueArray('interaction');
    for i := 0 to elem.interactionList.Count - 1 do
      ComposeCapabilityStatementRestResourceInteraction(json, '', elem.interactionList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumValue(json, 'versioning', elem.VersioningElement, CODES_TFhirVersioningPolicyEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumProps(json, 'versioning', elem.VersioningElement, CODES_TFhirVersioningPolicyEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'readHistory', elem.readHistoryElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'readHistory', elem.readHistoryElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'updateCreate', elem.updateCreateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'updateCreate', elem.updateCreateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'conditionalCreate', elem.conditionalCreateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'conditionalCreate', elem.conditionalCreateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumValue(json, 'conditionalRead', elem.ConditionalReadElement, CODES_TFhirConditionalReadStatusEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumProps(json, 'conditionalRead', elem.ConditionalReadElement, CODES_TFhirConditionalReadStatusEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'conditionalUpdate', elem.conditionalUpdateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'conditionalUpdate', elem.conditionalUpdateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumValue(json, 'conditionalDelete', elem.ConditionalDeleteElement, CODES_TFhirConditionalDeleteStatusEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumProps(json, 'conditionalDelete', elem.ConditionalDeleteElement, CODES_TFhirConditionalDeleteStatusEnum, false);
  if (SummaryOption in [soFull, soData]) and (elem.referencePolicyList.Count > 0) then
  begin
    val := false;
    ext := false;
    for i := 0 to elem.referencePolicyList.Count - 1 do
    begin
      val := val or (elem.referencePolicyList[i].hasPrimitiveValue);
      ext := ext or ((elem.referencePolicyList[i].id <> '') or (elem.referencePolicyList[i].hasExtensionList));
    end;
    if val then
    begin
      json.valueArray('referencePolicy');
      for i := 0 to elem.referencePolicyList.Count - 1 do
        ComposeEnumValue(json, '', elem.referencePolicyList[i], CODES_TFhirReferenceHandlingPolicyEnum, true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_referencePolicy');
      for i := 0 to elem.referencePolicyList.Count - 1 do
        ComposeEnumProps(json, '', elem.referencePolicyList[i], CODES_TFhirReferenceHandlingPolicyEnum, true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.searchIncludeList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.searchIncludeList.Count - 1 do
    begin
      ext := ext or ((elem.searchIncludeList[i].id <> '') or (elem.searchIncludeList[i].hasExtensionList) {no-comments or (elem.searchIncludeList[i].hasComments)});
      val := val or (elem.searchIncludeList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('searchInclude');
      for i := 0 to elem.searchIncludeList.Count - 1 do
        ComposeStringValue(json, '',elem.searchIncludeList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_searchInclude');
      for i := 0 to elem.searchIncludeList.Count - 1 do
        ComposeStringProps(json, '',elem.searchIncludeList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.searchRevIncludeList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.searchRevIncludeList.Count - 1 do
    begin
      ext := ext or ((elem.searchRevIncludeList[i].id <> '') or (elem.searchRevIncludeList[i].hasExtensionList) {no-comments or (elem.searchRevIncludeList[i].hasComments)});
      val := val or (elem.searchRevIncludeList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('searchRevInclude');
      for i := 0 to elem.searchRevIncludeList.Count - 1 do
        ComposeStringValue(json, '',elem.searchRevIncludeList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_searchRevInclude');
      for i := 0 to elem.searchRevIncludeList.Count - 1 do
        ComposeStringProps(json, '',elem.searchRevIncludeList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.searchParamList.Count > 0) then
  begin
    json.valueArray('searchParam');
    for i := 0 to elem.searchParamList.Count - 1 do
      ComposeCapabilityStatementRestResourceSearchParam(json, '', elem.searchParamList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.operationList.Count > 0) then
  begin
    json.valueArray('operation');
    for i := 0 to elem.operationList.Count - 1 do
      ComposeCapabilityStatementRestResourceOperation(json, '', elem.operationList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseCapabilityStatementRestResourceInteraction(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCapabilityStatementRestResourceInteraction(jsn)); {2}
end;

function TFHIRJsonParser.ParseCapabilityStatementRestResourceInteraction(jsn : TJsonObject) : TFhirCapabilityStatementRestResourceInteraction;
begin
  result := TFhirCapabilityStatementRestResourceInteraction.create;
  try
    ParseCapabilityStatementRestResourceInteractionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCapabilityStatementRestResourceInteractionProperties(jsn : TJsonObject; result : TFhirCapabilityStatementRestResourceInteraction);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') or jsn.has('_code')  then
      result.codeElement := parseEnum(jsn.path+'/code', jsn.node['code'], jsn.vObj['_code'], CODES_TFhirTypeRestfulInteractionEnum, SYSTEMS_TFhirTypeRestfulInteractionEnum);
    if jsn.has('documentation') or jsn.has('_documentation') then
        result.documentationElement := parseMarkdown(jsn.node['documentation'], jsn.vObj['_documentation']);{q}
end;

procedure TFHIRJsonComposer.ComposeCapabilityStatementRestResourceInteraction(json : TJSONWriter; name : string; elem : TFhirCapabilityStatementRestResourceInteraction; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'code', elem.CodeElement, CODES_TFhirTypeRestfulInteractionEnum, false);
  ComposeEnumProps(json, 'code', elem.CodeElement, CODES_TFhirTypeRestfulInteractionEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdownValue(json, 'documentation', elem.documentationElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdownProps(json, 'documentation', elem.documentationElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseCapabilityStatementRestResourceSearchParam(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCapabilityStatementRestResourceSearchParam(jsn)); {2}
end;

function TFHIRJsonParser.ParseCapabilityStatementRestResourceSearchParam(jsn : TJsonObject) : TFhirCapabilityStatementRestResourceSearchParam;
begin
  result := TFhirCapabilityStatementRestResourceSearchParam.create;
  try
    ParseCapabilityStatementRestResourceSearchParamProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCapabilityStatementRestResourceSearchParamProperties(jsn : TJsonObject; result : TFhirCapabilityStatementRestResourceSearchParam);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('definition') or jsn.has('_definition') then
        result.definitionElement := parseCanonical(jsn.node['definition'], jsn.vObj['_definition']);{q}
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn.node['type'], jsn.vObj['_type'], CODES_TFhirSearchParamTypeEnum, SYSTEMS_TFhirSearchParamTypeEnum);
    if jsn.has('documentation') or jsn.has('_documentation') then
        result.documentationElement := parseMarkdown(jsn.node['documentation'], jsn.vObj['_documentation']);{q}
end;

procedure TFHIRJsonComposer.ComposeCapabilityStatementRestResourceSearchParam(json : TJSONWriter; name : string; elem : TFhirCapabilityStatementRestResourceSearchParam; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'name', elem.nameElement, false);
  ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonicalValue(json, 'definition', elem.definitionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonicalProps(json, 'definition', elem.definitionElement, false);
  ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirSearchParamTypeEnum, false);
  ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirSearchParamTypeEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdownValue(json, 'documentation', elem.documentationElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdownProps(json, 'documentation', elem.documentationElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseCapabilityStatementRestResourceOperation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCapabilityStatementRestResourceOperation(jsn)); {2}
end;

function TFHIRJsonParser.ParseCapabilityStatementRestResourceOperation(jsn : TJsonObject) : TFhirCapabilityStatementRestResourceOperation;
begin
  result := TFhirCapabilityStatementRestResourceOperation.create;
  try
    ParseCapabilityStatementRestResourceOperationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCapabilityStatementRestResourceOperationProperties(jsn : TJsonObject; result : TFhirCapabilityStatementRestResourceOperation);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('definition') or jsn.has('_definition') then
        result.definitionElement := parseCanonical(jsn.node['definition'], jsn.vObj['_definition']);{q}
    if jsn.has('documentation') or jsn.has('_documentation') then
        result.documentationElement := parseMarkdown(jsn.node['documentation'], jsn.vObj['_documentation']);{q}
end;

procedure TFHIRJsonComposer.ComposeCapabilityStatementRestResourceOperation(json : TJSONWriter; name : string; elem : TFhirCapabilityStatementRestResourceOperation; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'name', elem.nameElement, false);
  ComposeStringProps(json, 'name', elem.nameElement, false);
  ComposeCanonicalValue(json, 'definition', elem.definitionElement, false);
  ComposeCanonicalProps(json, 'definition', elem.definitionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdownValue(json, 'documentation', elem.documentationElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdownProps(json, 'documentation', elem.documentationElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseCapabilityStatementRestInteraction(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCapabilityStatementRestInteraction(jsn)); {2}
end;

function TFHIRJsonParser.ParseCapabilityStatementRestInteraction(jsn : TJsonObject) : TFhirCapabilityStatementRestInteraction;
begin
  result := TFhirCapabilityStatementRestInteraction.create;
  try
    ParseCapabilityStatementRestInteractionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCapabilityStatementRestInteractionProperties(jsn : TJsonObject; result : TFhirCapabilityStatementRestInteraction);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') or jsn.has('_code')  then
      result.codeElement := parseEnum(jsn.path+'/code', jsn.node['code'], jsn.vObj['_code'], CODES_TFhirSystemRestfulInteractionEnum, SYSTEMS_TFhirSystemRestfulInteractionEnum);
    if jsn.has('documentation') or jsn.has('_documentation') then
        result.documentationElement := parseMarkdown(jsn.node['documentation'], jsn.vObj['_documentation']);{q}
end;

procedure TFHIRJsonComposer.ComposeCapabilityStatementRestInteraction(json : TJSONWriter; name : string; elem : TFhirCapabilityStatementRestInteraction; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'code', elem.CodeElement, CODES_TFhirSystemRestfulInteractionEnum, false);
  ComposeEnumProps(json, 'code', elem.CodeElement, CODES_TFhirSystemRestfulInteractionEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdownValue(json, 'documentation', elem.documentationElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdownProps(json, 'documentation', elem.documentationElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseCapabilityStatementMessaging(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCapabilityStatementMessaging(jsn)); {2}
end;

function TFHIRJsonParser.ParseCapabilityStatementMessaging(jsn : TJsonObject) : TFhirCapabilityStatementMessaging;
begin
  result := TFhirCapabilityStatementMessaging.create;
  try
    ParseCapabilityStatementMessagingProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCapabilityStatementMessagingProperties(jsn : TJsonObject; result : TFhirCapabilityStatementMessaging);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('endpoint') then
      iterateArray(jsn.vArr['endpoint'], result.endpointList, parseCapabilityStatementMessagingEndpoint);
    if jsn.has('reliableCache') or jsn.has('_reliableCache') then
        result.reliableCacheElement := parseUnsignedInt(jsn.node['reliableCache'], jsn.vObj['_reliableCache']);{q}
    if jsn.has('documentation') or jsn.has('_documentation') then
        result.documentationElement := parseMarkdown(jsn.node['documentation'], jsn.vObj['_documentation']);{q}
    if jsn.has('supportedMessage') then
      iterateArray(jsn.vArr['supportedMessage'], result.supportedMessageList, parseCapabilityStatementMessagingSupportedMessage);
end;

procedure TFHIRJsonComposer.ComposeCapabilityStatementMessaging(json : TJSONWriter; name : string; elem : TFhirCapabilityStatementMessaging; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and (elem.endpointList.Count > 0) then
  begin
    json.valueArray('endpoint');
    for i := 0 to elem.endpointList.Count - 1 do
      ComposeCapabilityStatementMessagingEndpoint(json, '', elem.endpointList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeUnsignedIntValue(json, 'reliableCache', elem.reliableCacheElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeUnsignedIntProps(json, 'reliableCache', elem.reliableCacheElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdownValue(json, 'documentation', elem.documentationElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdownProps(json, 'documentation', elem.documentationElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.supportedMessageList.Count > 0) then
  begin
    json.valueArray('supportedMessage');
    for i := 0 to elem.supportedMessageList.Count - 1 do
      ComposeCapabilityStatementMessagingSupportedMessage(json, '', elem.supportedMessageList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseCapabilityStatementMessagingEndpoint(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCapabilityStatementMessagingEndpoint(jsn)); {2}
end;

function TFHIRJsonParser.ParseCapabilityStatementMessagingEndpoint(jsn : TJsonObject) : TFhirCapabilityStatementMessagingEndpoint;
begin
  result := TFhirCapabilityStatementMessagingEndpoint.create;
  try
    ParseCapabilityStatementMessagingEndpointProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCapabilityStatementMessagingEndpointProperties(jsn : TJsonObject; result : TFhirCapabilityStatementMessagingEndpoint);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('protocol') then
        result.protocol := ParseCoding(jsn.vObj['protocol']);{q3}
    if jsn.has('address') or jsn.has('_address') then
        result.addressElement := parseUrl(jsn.node['address'], jsn.vObj['_address']);{q}
end;

procedure TFHIRJsonComposer.ComposeCapabilityStatementMessagingEndpoint(json : TJSONWriter; name : string; elem : TFhirCapabilityStatementMessagingEndpoint; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCoding(json, 'protocol', elem.protocol); {a}
  ComposeUrlValue(json, 'address', elem.addressElement, false);
  ComposeUrlProps(json, 'address', elem.addressElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseCapabilityStatementMessagingSupportedMessage(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCapabilityStatementMessagingSupportedMessage(jsn)); {2}
end;

function TFHIRJsonParser.ParseCapabilityStatementMessagingSupportedMessage(jsn : TJsonObject) : TFhirCapabilityStatementMessagingSupportedMessage;
begin
  result := TFhirCapabilityStatementMessagingSupportedMessage.create;
  try
    ParseCapabilityStatementMessagingSupportedMessageProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCapabilityStatementMessagingSupportedMessageProperties(jsn : TJsonObject; result : TFhirCapabilityStatementMessagingSupportedMessage);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('mode') or jsn.has('_mode')  then
      result.modeElement := parseEnum(jsn.path+'/mode', jsn.node['mode'], jsn.vObj['_mode'], CODES_TFhirEventCapabilityModeEnum, SYSTEMS_TFhirEventCapabilityModeEnum);
    if jsn.has('definition') or jsn.has('_definition') then
        result.definitionElement := parseCanonical(jsn.node['definition'], jsn.vObj['_definition']);{q}
end;

procedure TFHIRJsonComposer.ComposeCapabilityStatementMessagingSupportedMessage(json : TJSONWriter; name : string; elem : TFhirCapabilityStatementMessagingSupportedMessage; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'mode', elem.ModeElement, CODES_TFhirEventCapabilityModeEnum, false);
  ComposeEnumProps(json, 'mode', elem.ModeElement, CODES_TFhirEventCapabilityModeEnum, false);
  ComposeCanonicalValue(json, 'definition', elem.definitionElement, false);
  ComposeCanonicalProps(json, 'definition', elem.definitionElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseCapabilityStatementDocument(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCapabilityStatementDocument(jsn)); {2}
end;

function TFHIRJsonParser.ParseCapabilityStatementDocument(jsn : TJsonObject) : TFhirCapabilityStatementDocument;
begin
  result := TFhirCapabilityStatementDocument.create;
  try
    ParseCapabilityStatementDocumentProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCapabilityStatementDocumentProperties(jsn : TJsonObject; result : TFhirCapabilityStatementDocument);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('mode') or jsn.has('_mode')  then
      result.modeElement := parseEnum(jsn.path+'/mode', jsn.node['mode'], jsn.vObj['_mode'], CODES_TFhirDocumentModeEnum, SYSTEMS_TFhirDocumentModeEnum);
    if jsn.has('documentation') or jsn.has('_documentation') then
        result.documentationElement := parseMarkdown(jsn.node['documentation'], jsn.vObj['_documentation']);{q}
    if jsn.has('profile') or jsn.has('_profile') then
        result.profileElement := parseCanonical(jsn.node['profile'], jsn.vObj['_profile']);{q}
end;

procedure TFHIRJsonComposer.ComposeCapabilityStatementDocument(json : TJSONWriter; name : string; elem : TFhirCapabilityStatementDocument; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'mode', elem.ModeElement, CODES_TFhirDocumentModeEnum, false);
  ComposeEnumProps(json, 'mode', elem.ModeElement, CODES_TFhirDocumentModeEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdownValue(json, 'documentation', elem.documentationElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdownProps(json, 'documentation', elem.documentationElement, false);
  ComposeCanonicalValue(json, 'profile', elem.profileElement, false);
  ComposeCanonicalProps(json, 'profile', elem.profileElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseCapabilityStatement(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCapabilityStatement(jsn)); {2}
end;

function TFHIRJsonParser.ParseCapabilityStatement(jsn : TJsonObject) : TFhirCapabilityStatement;
begin
  result := TFhirCapabilityStatement.create;
  try
    ParseCapabilityStatementProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCapabilityStatementProperties(jsn : TJsonObject; result : TFhirCapabilityStatement);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := parseUri(jsn.node['url'], jsn.vObj['_url']);{q}
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := parseString(jsn.node['version'], jsn.vObj['_version']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('title') or jsn.has('_title') then
        result.titleElement := parseString(jsn.node['title'], jsn.vObj['_title']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    if jsn.has('experimental') or jsn.has('_experimental') then
        result.experimentalElement := parseBoolean(jsn.node['experimental'], jsn.vObj['_experimental']);{q}
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := parseDateTime(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('publisher') or jsn.has('_publisher') then
        result.publisherElement := parseString(jsn.node['publisher'], jsn.vObj['_publisher']);{q}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseContactDetail);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseMarkdown(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('useContext') then
      iterateArray(jsn.vArr['useContext'], result.useContextList, parseUsageContext);
    if jsn.has('jurisdiction') then
      iterateArray(jsn.vArr['jurisdiction'], result.jurisdictionList, parseCodeableConcept);
    if jsn.has('purpose') or jsn.has('_purpose') then
        result.purposeElement := parseMarkdown(jsn.node['purpose'], jsn.vObj['_purpose']);{q}
    if jsn.has('copyright') or jsn.has('_copyright') then
        result.copyrightElement := parseMarkdown(jsn.node['copyright'], jsn.vObj['_copyright']);{q}
    if jsn.has('kind') or jsn.has('_kind')  then
      result.kindElement := parseEnum(jsn.path+'/kind', jsn.node['kind'], jsn.vObj['_kind'], CODES_TFhirCapabilityStatementKindEnum, SYSTEMS_TFhirCapabilityStatementKindEnum);
      if jsn.has('instantiates') or jsn.has('_instantiates') then
      iteratePrimitiveArray(jsn.vArr['instantiates'], jsn.vArr['_instantiates'], result.instantiatesList, parseCanonical);
      if jsn.has('imports') or jsn.has('_imports') then
      iteratePrimitiveArray(jsn.vArr['imports'], jsn.vArr['_imports'], result.importsList, parseCanonical);
    if jsn.has('software') then
        result.software := ParseCapabilityStatementSoftware(jsn.vObj['software']);{q3}
    if jsn.has('implementation') then
        result.implementation_ := ParseCapabilityStatementImplementation(jsn.vObj['implementation']);{q3}
    if jsn.has('fhirVersion') or jsn.has('_fhirVersion') then
      result.fhirVersionElement := parseEnum(jsn.path+'/fhirVersion', jsn.node['fhirVersion'], jsn.vObj['_fhirVersion'], CODES_TFhirFHIRVersionEnum, SYSTEMS_TFhirFHIRVersionEnum);
      if jsn.has('format') or jsn.has('_format') then
      iteratePrimitiveArray(jsn.vArr['format'], jsn.vArr['_format'], result.formatList, parseCode);
      if jsn.has('patchFormat') or jsn.has('_patchFormat') then
      iteratePrimitiveArray(jsn.vArr['patchFormat'], jsn.vArr['_patchFormat'], result.patchFormatList, parseCode);
      if jsn.has('implementationGuide') or jsn.has('_implementationGuide') then
      iteratePrimitiveArray(jsn.vArr['implementationGuide'], jsn.vArr['_implementationGuide'], result.implementationGuideList, parseCanonical);
    if jsn.has('rest') then
      iterateArray(jsn.vArr['rest'], result.restList, parseCapabilityStatementRest);
    if jsn.has('messaging') then
      iterateArray(jsn.vArr['messaging'], result.messagingList, parseCapabilityStatementMessaging);
    if jsn.has('document') then
      iterateArray(jsn.vArr['document'], result.documentList, parseCapabilityStatementDocument);
end;

procedure TFHIRJsonComposer.ComposeCapabilityStatement(json : TJSONWriter; name : string; elem : TFhirCapabilityStatement; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUriValue(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUriProps(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeStringValue(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeStringProps(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeStringValue(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeStringProps(json, 'title', elem.titleElement, false);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBooleanValue(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBooleanProps(json, 'experimental', elem.experimentalElement, false);
  ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringValue(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringProps(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') and (elem.contactList.Count > 0) then
  begin
    json.valueArray('contact');
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(json, '', elem.contactList[i]); {z - ContactDetail}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdownValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdownProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') and (elem.useContextList.Count > 0) then
  begin
    json.valueArray('useContext');
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(json, '', elem.useContextList[i]); {z - UsageContext}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') and (elem.jurisdictionList.Count > 0) then
  begin
    json.valueArray('jurisdiction');
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.jurisdictionList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdownValue(json, 'purpose', elem.purposeElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdownProps(json, 'purpose', elem.purposeElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdownValue(json, 'copyright', elem.copyrightElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdownProps(json, 'copyright', elem.copyrightElement, false);
  ComposeEnumValue(json, 'kind', elem.KindElement, CODES_TFhirCapabilityStatementKindEnum, false);
  ComposeEnumProps(json, 'kind', elem.KindElement, CODES_TFhirCapabilityStatementKindEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('instantiates') and (elem.instantiatesList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.instantiatesList.Count - 1 do
    begin
      ext := ext or ((elem.instantiatesList[i].id <> '') or (elem.instantiatesList[i].hasExtensionList) {no-comments or (elem.instantiatesList[i].hasComments)});
      val := val or (elem.instantiatesList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('instantiates');
      for i := 0 to elem.instantiatesList.Count - 1 do
        ComposeCanonicalValue(json, '',elem.instantiatesList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_instantiates');
      for i := 0 to elem.instantiatesList.Count - 1 do
        ComposeCanonicalProps(json, '',elem.instantiatesList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('imports') and (elem.importsList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.importsList.Count - 1 do
    begin
      ext := ext or ((elem.importsList[i].id <> '') or (elem.importsList[i].hasExtensionList) {no-comments or (elem.importsList[i].hasComments)});
      val := val or (elem.importsList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('imports');
      for i := 0 to elem.importsList.Count - 1 do
        ComposeCanonicalValue(json, '',elem.importsList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_imports');
      for i := 0 to elem.importsList.Count - 1 do
        ComposeCanonicalProps(json, '',elem.importsList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('software') then
    ComposeCapabilityStatementSoftware(json, 'software', elem.software); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('implementation_') then
    ComposeCapabilityStatementImplementation(json, 'implementation', elem.implementation_); {a}
  ComposeEnumValue(json, 'fhirVersion', elem.FhirVersionElement, CODES_TFhirFHIRVersionEnum, false);
  ComposeEnumProps(json, 'fhirVersion', elem.FhirVersionElement, CODES_TFhirFHIRVersionEnum, false);
  if (elem.formatList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.formatList.Count - 1 do
    begin
      ext := ext or ((elem.formatList[i].id <> '') or (elem.formatList[i].hasExtensionList) {no-comments or (elem.formatList[i].hasComments)});
      val := val or (elem.formatList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('format');
      for i := 0 to elem.formatList.Count - 1 do
        ComposeCodeValue(json, '',elem.formatList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_format');
      for i := 0 to elem.formatList.Count - 1 do
        ComposeCodeProps(json, '',elem.formatList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('patchFormat') and (elem.patchFormatList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.patchFormatList.Count - 1 do
    begin
      ext := ext or ((elem.patchFormatList[i].id <> '') or (elem.patchFormatList[i].hasExtensionList) {no-comments or (elem.patchFormatList[i].hasComments)});
      val := val or (elem.patchFormatList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('patchFormat');
      for i := 0 to elem.patchFormatList.Count - 1 do
        ComposeCodeValue(json, '',elem.patchFormatList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_patchFormat');
      for i := 0 to elem.patchFormatList.Count - 1 do
        ComposeCodeProps(json, '',elem.patchFormatList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('implementationGuide') and (elem.implementationGuideList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.implementationGuideList.Count - 1 do
    begin
      ext := ext or ((elem.implementationGuideList[i].id <> '') or (elem.implementationGuideList[i].hasExtensionList) {no-comments or (elem.implementationGuideList[i].hasComments)});
      val := val or (elem.implementationGuideList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('implementationGuide');
      for i := 0 to elem.implementationGuideList.Count - 1 do
        ComposeCanonicalValue(json, '',elem.implementationGuideList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_implementationGuide');
      for i := 0 to elem.implementationGuideList.Count - 1 do
        ComposeCanonicalProps(json, '',elem.implementationGuideList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('rest') and (elem.restList.Count > 0) then
  begin
    json.valueArray('rest');
    for i := 0 to elem.restList.Count - 1 do
      ComposeCapabilityStatementRest(json, '', elem.restList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('messaging') and (elem.messagingList.Count > 0) then
  begin
    json.valueArray('messaging');
    for i := 0 to elem.messagingList.Count - 1 do
      ComposeCapabilityStatementMessaging(json, '', elem.messagingList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('document') and (elem.documentList.Count > 0) then
  begin
    json.valueArray('document');
    for i := 0 to elem.documentList.Count - 1 do
      ComposeCapabilityStatementDocument(json, '', elem.documentList[i]); {z - }
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_CAPABILITYSTATEMENT}
{$IFDEF FHIR_CAREPLAN}
procedure TFHIRJsonParser.ParseCarePlanActivity(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCarePlanActivity(jsn)); {2}
end;

function TFHIRJsonParser.ParseCarePlanActivity(jsn : TJsonObject) : TFhirCarePlanActivity;
begin
  result := TFhirCarePlanActivity.create;
  try
    ParseCarePlanActivityProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCarePlanActivityProperties(jsn : TJsonObject; result : TFhirCarePlanActivity);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('outcomeCodeableConcept') then
      iterateArray(jsn.vArr['outcomeCodeableConcept'], result.outcomeCodeableConceptList, parseCodeableConcept);
    if jsn.has('outcomeReference') then
      iterateArray(jsn.vArr['outcomeReference'], result.outcomeReferenceList, parseReference{TFhirReference});
    if jsn.has('progress') then
      iterateArray(jsn.vArr['progress'], result.progressList, parseAnnotation);
    if jsn.has('reference') then
        result.reference := ParseReference{TFhirAppointment}(jsn.vObj['reference']);{q3}
    if jsn.has('detail') then
        result.detail := ParseCarePlanActivityDetail(jsn.vObj['detail']);{q3}
end;

procedure TFHIRJsonComposer.ComposeCarePlanActivity(json : TJSONWriter; name : string; elem : TFhirCarePlanActivity; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and (elem.outcomeCodeableConceptList.Count > 0) then
  begin
    json.valueArray('outcomeCodeableConcept');
    for i := 0 to elem.outcomeCodeableConceptList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.outcomeCodeableConceptList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.outcomeReferenceList.Count > 0) then
  begin
    json.valueArray('outcomeReference');
    for i := 0 to elem.outcomeReferenceList.Count - 1 do
      ComposeReference{TFhirReference}(json, '', elem.outcomeReferenceList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.progressList.Count > 0) then
  begin
    json.valueArray('progress');
    for i := 0 to elem.progressList.Count - 1 do
      ComposeAnnotation(json, '', elem.progressList[i]); {z - Annotation}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirAppointment}(json, 'reference', elem.reference); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCarePlanActivityDetail(json, 'detail', elem.detail); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseCarePlanActivityDetail(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCarePlanActivityDetail(jsn)); {2}
end;

function TFHIRJsonParser.ParseCarePlanActivityDetail(jsn : TJsonObject) : TFhirCarePlanActivityDetail;
begin
  result := TFhirCarePlanActivityDetail.create;
  try
    ParseCarePlanActivityDetailProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCarePlanActivityDetailProperties(jsn : TJsonObject; result : TFhirCarePlanActivityDetail);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('kind') or jsn.has('_kind')  then
      result.kindElement := parseEnum(jsn.path+'/kind', jsn.node['kind'], jsn.vObj['_kind'], CODES_TFhirCarePlanActivityKindEnum, SYSTEMS_TFhirCarePlanActivityKindEnum);
      if jsn.has('instantiatesCanonical') or jsn.has('_instantiatesCanonical') then
      iteratePrimitiveArray(jsn.vArr['instantiatesCanonical'], jsn.vArr['_instantiatesCanonical'], result.instantiatesCanonicalList, parseCanonical);
      if jsn.has('instantiatesUri') or jsn.has('_instantiatesUri') then
      iteratePrimitiveArray(jsn.vArr['instantiatesUri'], jsn.vArr['_instantiatesUri'], result.instantiatesUriList, parseUri);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('reasonCode') then
      iterateArray(jsn.vArr['reasonCode'], result.reasonCodeList, parseCodeableConcept);
    if jsn.has('reasonReference') then
      iterateArray(jsn.vArr['reasonReference'], result.reasonReferenceList, parseReference{TFhirCondition});
    if jsn.has('goal') then
      iterateArray(jsn.vArr['goal'], result.goalList, parseReference{TFhirGoal});
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirCarePlanActivityStatusEnum, SYSTEMS_TFhirCarePlanActivityStatusEnum);
    if jsn.has('statusReason') then
        result.statusReason := ParseCodeableConcept(jsn.vObj['statusReason']);{q3}
    if jsn.has('doNotPerform') or jsn.has('_doNotPerform') then
        result.doNotPerformElement := parseBoolean(jsn.node['doNotPerform'], jsn.vObj['_doNotPerform']);{q}
    if jsn.has('scheduledTiming') {a4} then
      result.scheduled := ParseTiming(jsn.vObj['scheduledTiming']);
    if jsn.has('scheduledPeriod') {a4} then
      result.scheduled := ParsePeriod(jsn.vObj['scheduledPeriod']);
    if jsn.has('scheduledString') or jsn.has('_scheduledString') then
      result.scheduled := parseString(jsn.node['scheduledString'], jsn.vObj['_scheduledString']);
    if jsn.has('location') then
        result.location := ParseReference{TFhirLocation}(jsn.vObj['location']);{q3}
    if jsn.has('performer') then
      iterateArray(jsn.vArr['performer'], result.performerList, parseReference{TFhirPractitioner});
    if jsn.has('productCodeableConcept') {a4} then
      result.product := ParseCodeableConcept(jsn.vObj['productCodeableConcept']);
    if jsn.has('productReference') {a3} then
      result.product := ParseReference(jsn.vObj['productReference']);
    if jsn.has('dailyAmount') then
        result.dailyAmount := ParseQuantity(jsn.vObj['dailyAmount']);{q3}
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q3}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseString(jsn.node['description'], jsn.vObj['_description']);{q}
end;

procedure TFHIRJsonComposer.ComposeCarePlanActivityDetail(json : TJSONWriter; name : string; elem : TFhirCarePlanActivityDetail; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumValue(json, 'kind', elem.KindElement, CODES_TFhirCarePlanActivityKindEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumProps(json, 'kind', elem.KindElement, CODES_TFhirCarePlanActivityKindEnum, false);
  if (SummaryOption in [soFull, soData]) and (elem.instantiatesCanonicalList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.instantiatesCanonicalList.Count - 1 do
    begin
      ext := ext or ((elem.instantiatesCanonicalList[i].id <> '') or (elem.instantiatesCanonicalList[i].hasExtensionList) {no-comments or (elem.instantiatesCanonicalList[i].hasComments)});
      val := val or (elem.instantiatesCanonicalList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('instantiatesCanonical');
      for i := 0 to elem.instantiatesCanonicalList.Count - 1 do
        ComposeCanonicalValue(json, '',elem.instantiatesCanonicalList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_instantiatesCanonical');
      for i := 0 to elem.instantiatesCanonicalList.Count - 1 do
        ComposeCanonicalProps(json, '',elem.instantiatesCanonicalList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.instantiatesUriList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.instantiatesUriList.Count - 1 do
    begin
      ext := ext or ((elem.instantiatesUriList[i].id <> '') or (elem.instantiatesUriList[i].hasExtensionList) {no-comments or (elem.instantiatesUriList[i].hasComments)});
      val := val or (elem.instantiatesUriList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('instantiatesUri');
      for i := 0 to elem.instantiatesUriList.Count - 1 do
        ComposeUriValue(json, '',elem.instantiatesUriList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_instantiatesUri');
      for i := 0 to elem.instantiatesUriList.Count - 1 do
        ComposeUriProps(json, '',elem.instantiatesUriList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soData]) and (elem.reasonCodeList.Count > 0) then
  begin
    json.valueArray('reasonCode');
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.reasonCodeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.reasonReferenceList.Count > 0) then
  begin
    json.valueArray('reasonReference');
    for i := 0 to elem.reasonReferenceList.Count - 1 do
      ComposeReference{TFhirCondition}(json, '', elem.reasonReferenceList[i]); {z - Reference(Condition)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.goalList.Count > 0) then
  begin
    json.valueArray('goal');
    for i := 0 to elem.goalList.Count - 1 do
      ComposeReference{TFhirGoal}(json, '', elem.goalList[i]); {z - Reference(Goal)}
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirCarePlanActivityStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirCarePlanActivityStatusEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'statusReason', elem.statusReason); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'doNotPerform', elem.doNotPerformElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'doNotPerform', elem.doNotPerformElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.scheduled is TFhirTiming) then 
    ComposeTiming(json, 'scheduledTiming', TFhirTiming(elem.scheduled)) 
  else if (SummaryOption in [soFull, soData]) and (elem.scheduled is TFhirPeriod) then 
    ComposePeriod(json, 'scheduledPeriod', TFhirPeriod(elem.scheduled)) 
  else if (SummaryOption in [soFull, soData]) and (elem.scheduled is TFhirString) then 
  begin
    ComposeStringValue(json, 'scheduledString', TFhirString(elem.scheduled), false);
    ComposeStringProps(json, 'scheduledString', TFhirString(elem.scheduled), false);
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirLocation}(json, 'location', elem.location); {a}
  if (SummaryOption in [soFull, soData]) and (elem.performerList.Count > 0) then
  begin
    json.valueArray('performer');
    for i := 0 to elem.performerList.Count - 1 do
      ComposeReference{TFhirPractitioner}(json, '', elem.performerList[i]); {z - Reference(Practitioner)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.product is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'productCodeableConcept', TFhirCodeableConcept(elem.product)) 
  else if (SummaryOption in [soFull, soData]) and (elem.product is TFhirReference) then
    ComposeReference(json, 'productReference', TFhirReference(elem.product));
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'dailyAmount', elem.dailyAmount); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'quantity', elem.quantity); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseCarePlan(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCarePlan(jsn)); {2}
end;

function TFHIRJsonParser.ParseCarePlan(jsn : TJsonObject) : TFhirCarePlan;
begin
  result := TFhirCarePlan.create;
  try
    ParseCarePlanProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCarePlanProperties(jsn : TJsonObject; result : TFhirCarePlan);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
      if jsn.has('instantiatesCanonical') or jsn.has('_instantiatesCanonical') then
      iteratePrimitiveArray(jsn.vArr['instantiatesCanonical'], jsn.vArr['_instantiatesCanonical'], result.instantiatesCanonicalList, parseCanonical);
      if jsn.has('instantiatesUri') or jsn.has('_instantiatesUri') then
      iteratePrimitiveArray(jsn.vArr['instantiatesUri'], jsn.vArr['_instantiatesUri'], result.instantiatesUriList, parseUri);
    if jsn.has('basedOn') then
      iterateArray(jsn.vArr['basedOn'], result.basedOnList, parseReference{TFhirCarePlan});
    if jsn.has('replaces') then
      iterateArray(jsn.vArr['replaces'], result.replacesList, parseReference{TFhirCarePlan});
    if jsn.has('partOf') then
      iterateArray(jsn.vArr['partOf'], result.partOfList, parseReference{TFhirCarePlan});
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirRequestStatusEnum, SYSTEMS_TFhirRequestStatusEnum);
    if jsn.has('intent') or jsn.has('_intent')  then
      result.intentElement := parseEnum(jsn.path+'/intent', jsn.node['intent'], jsn.vObj['_intent'], CODES_TFhirCarePlanIntentEnum, SYSTEMS_TFhirCarePlanIntentEnum);
    if jsn.has('category') then
      iterateArray(jsn.vArr['category'], result.categoryList, parseCodeableConcept);
    if jsn.has('title') or jsn.has('_title') then
        result.titleElement := parseString(jsn.node['title'], jsn.vObj['_title']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirPatient}(jsn.vObj['subject']);{q3}
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q3}
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q3}
    if jsn.has('created') or jsn.has('_created') then
        result.createdElement := parseDateTime(jsn.node['created'], jsn.vObj['_created']);{q}
    if jsn.has('author') then
        result.author := ParseReference{TFhirPatient}(jsn.vObj['author']);{q3}
    if jsn.has('contributor') then
      iterateArray(jsn.vArr['contributor'], result.contributorList, parseReference{TFhirPatient});
    if jsn.has('careTeam') then
      iterateArray(jsn.vArr['careTeam'], result.careTeamList, parseReference{TFhirCareTeam});
    if jsn.has('addresses') then
      iterateArray(jsn.vArr['addresses'], result.addressesList, parseReference{TFhirCondition});
    if jsn.has('supportingInfo') then
      iterateArray(jsn.vArr['supportingInfo'], result.supportingInfoList, parseReference{TFhirReference});
    if jsn.has('goal') then
      iterateArray(jsn.vArr['goal'], result.goalList, parseReference{TFhirGoal});
    if jsn.has('activity') then
      iterateArray(jsn.vArr['activity'], result.activityList, parseCarePlanActivity);
    if jsn.has('note') then
      iterateArray(jsn.vArr['note'], result.noteList, parseAnnotation);
end;

procedure TFHIRJsonComposer.ComposeCarePlan(json : TJSONWriter; name : string; elem : TFhirCarePlan; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('instantiatesCanonical') and (elem.instantiatesCanonicalList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.instantiatesCanonicalList.Count - 1 do
    begin
      ext := ext or ((elem.instantiatesCanonicalList[i].id <> '') or (elem.instantiatesCanonicalList[i].hasExtensionList) {no-comments or (elem.instantiatesCanonicalList[i].hasComments)});
      val := val or (elem.instantiatesCanonicalList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('instantiatesCanonical');
      for i := 0 to elem.instantiatesCanonicalList.Count - 1 do
        ComposeCanonicalValue(json, '',elem.instantiatesCanonicalList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_instantiatesCanonical');
      for i := 0 to elem.instantiatesCanonicalList.Count - 1 do
        ComposeCanonicalProps(json, '',elem.instantiatesCanonicalList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('instantiatesUri') and (elem.instantiatesUriList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.instantiatesUriList.Count - 1 do
    begin
      ext := ext or ((elem.instantiatesUriList[i].id <> '') or (elem.instantiatesUriList[i].hasExtensionList) {no-comments or (elem.instantiatesUriList[i].hasComments)});
      val := val or (elem.instantiatesUriList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('instantiatesUri');
      for i := 0 to elem.instantiatesUriList.Count - 1 do
        ComposeUriValue(json, '',elem.instantiatesUriList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_instantiatesUri');
      for i := 0 to elem.instantiatesUriList.Count - 1 do
        ComposeUriProps(json, '',elem.instantiatesUriList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('basedOn') and (elem.basedOnList.Count > 0) then
  begin
    json.valueArray('basedOn');
    for i := 0 to elem.basedOnList.Count - 1 do
      ComposeReference{TFhirCarePlan}(json, '', elem.basedOnList[i]); {z - Reference(CarePlan)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('replaces') and (elem.replacesList.Count > 0) then
  begin
    json.valueArray('replaces');
    for i := 0 to elem.replacesList.Count - 1 do
      ComposeReference{TFhirCarePlan}(json, '', elem.replacesList[i]); {z - Reference(CarePlan)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('partOf') and (elem.partOfList.Count > 0) then
  begin
    json.valueArray('partOf');
    for i := 0 to elem.partOfList.Count - 1 do
      ComposeReference{TFhirCarePlan}(json, '', elem.partOfList[i]); {z - Reference(CarePlan)}
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirRequestStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirRequestStatusEnum, false);
  ComposeEnumValue(json, 'intent', elem.IntentElement, CODES_TFhirCarePlanIntentEnum, false);
  ComposeEnumProps(json, 'intent', elem.IntentElement, CODES_TFhirCarePlanIntentEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') and (elem.categoryList.Count > 0) then
  begin
    json.valueArray('category');
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.categoryList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeStringValue(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeStringProps(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  ComposeReference{TFhirPatient}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('period') then
    ComposePeriod(json, 'period', elem.period); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('created') then
    ComposeDateTimeValue(json, 'created', elem.createdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('created') then
    ComposeDateTimeProps(json, 'created', elem.createdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('author') then
    ComposeReference{TFhirPatient}(json, 'author', elem.author); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('contributor') and (elem.contributorList.Count > 0) then
  begin
    json.valueArray('contributor');
    for i := 0 to elem.contributorList.Count - 1 do
      ComposeReference{TFhirPatient}(json, '', elem.contributorList[i]); {z - Reference(Patient)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('careTeam') and (elem.careTeamList.Count > 0) then
  begin
    json.valueArray('careTeam');
    for i := 0 to elem.careTeamList.Count - 1 do
      ComposeReference{TFhirCareTeam}(json, '', elem.careTeamList[i]); {z - Reference(CareTeam)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('addresses') and (elem.addressesList.Count > 0) then
  begin
    json.valueArray('addresses');
    for i := 0 to elem.addressesList.Count - 1 do
      ComposeReference{TFhirCondition}(json, '', elem.addressesList[i]); {z - Reference(Condition)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('supportingInfo') and (elem.supportingInfoList.Count > 0) then
  begin
    json.valueArray('supportingInfo');
    for i := 0 to elem.supportingInfoList.Count - 1 do
      ComposeReference{TFhirReference}(json, '', elem.supportingInfoList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('goal') and (elem.goalList.Count > 0) then
  begin
    json.valueArray('goal');
    for i := 0 to elem.goalList.Count - 1 do
      ComposeReference{TFhirGoal}(json, '', elem.goalList[i]); {z - Reference(Goal)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('activity') and (elem.activityList.Count > 0) then
  begin
    json.valueArray('activity');
    for i := 0 to elem.activityList.Count - 1 do
      ComposeCarePlanActivity(json, '', elem.activityList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('note') and (elem.noteList.Count > 0) then
  begin
    json.valueArray('note');
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(json, '', elem.noteList[i]); {z - Annotation}
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_CAREPLAN}
{$IFDEF FHIR_CARETEAM}
procedure TFHIRJsonParser.ParseCareTeamParticipant(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCareTeamParticipant(jsn)); {2}
end;

function TFHIRJsonParser.ParseCareTeamParticipant(jsn : TJsonObject) : TFhirCareTeamParticipant;
begin
  result := TFhirCareTeamParticipant.create;
  try
    ParseCareTeamParticipantProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCareTeamParticipantProperties(jsn : TJsonObject; result : TFhirCareTeamParticipant);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('role') then
      iterateArray(jsn.vArr['role'], result.roleList, parseCodeableConcept);
    if jsn.has('member') then
        result.member := ParseReference{TFhirPractitioner}(jsn.vObj['member']);{q3}
    if jsn.has('onBehalfOf') then
        result.onBehalfOf := ParseReference{TFhirOrganization}(jsn.vObj['onBehalfOf']);{q3}
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q3}
end;

procedure TFHIRJsonComposer.ComposeCareTeamParticipant(json : TJSONWriter; name : string; elem : TFhirCareTeamParticipant; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.roleList.Count > 0) then
  begin
    json.valueArray('role');
    for i := 0 to elem.roleList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.roleList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(json, 'member', elem.member); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(json, 'onBehalfOf', elem.onBehalfOf); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(json, 'period', elem.period); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseCareTeam(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCareTeam(jsn)); {2}
end;

function TFHIRJsonParser.ParseCareTeam(jsn : TJsonObject) : TFhirCareTeam;
begin
  result := TFhirCareTeam.create;
  try
    ParseCareTeamProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCareTeamProperties(jsn : TJsonObject; result : TFhirCareTeam);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirCareTeamStatusEnum, SYSTEMS_TFhirCareTeamStatusEnum);
    if jsn.has('category') then
      iterateArray(jsn.vArr['category'], result.categoryList, parseCodeableConcept);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirPatient}(jsn.vObj['subject']);{q3}
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q3}
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q3}
    if jsn.has('participant') then
      iterateArray(jsn.vArr['participant'], result.participantList, parseCareTeamParticipant);
    if jsn.has('reasonCode') then
      iterateArray(jsn.vArr['reasonCode'], result.reasonCodeList, parseCodeableConcept);
    if jsn.has('reasonReference') then
      iterateArray(jsn.vArr['reasonReference'], result.reasonReferenceList, parseReference{TFhirCondition});
    if jsn.has('managingOrganization') then
      iterateArray(jsn.vArr['managingOrganization'], result.managingOrganizationList, parseReference{TFhirOrganization});
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    if jsn.has('note') then
      iterateArray(jsn.vArr['note'], result.noteList, parseAnnotation);
end;

procedure TFHIRJsonComposer.ComposeCareTeam(json : TJSONWriter; name : string; elem : TFhirCareTeam; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirCareTeamStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirCareTeamStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') and (elem.categoryList.Count > 0) then
  begin
    json.valueArray('category');
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.categoryList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{TFhirPatient}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('period') then
    ComposePeriod(json, 'period', elem.period); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('participant') and (elem.participantList.Count > 0) then
  begin
    json.valueArray('participant');
    for i := 0 to elem.participantList.Count - 1 do
      ComposeCareTeamParticipant(json, '', elem.participantList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('reasonCode') and (elem.reasonCodeList.Count > 0) then
  begin
    json.valueArray('reasonCode');
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.reasonCodeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('reasonReference') and (elem.reasonReferenceList.Count > 0) then
  begin
    json.valueArray('reasonReference');
    for i := 0 to elem.reasonReferenceList.Count - 1 do
      ComposeReference{TFhirCondition}(json, '', elem.reasonReferenceList[i]); {z - Reference(Condition)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('managingOrganization') and (elem.managingOrganizationList.Count > 0) then
  begin
    json.valueArray('managingOrganization');
    for i := 0 to elem.managingOrganizationList.Count - 1 do
      ComposeReference{TFhirOrganization}(json, '', elem.managingOrganizationList[i]); {z - Reference(Organization)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('telecom') and (elem.telecomList.Count > 0) then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '', elem.telecomList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('note') and (elem.noteList.Count > 0) then
  begin
    json.valueArray('note');
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(json, '', elem.noteList[i]); {z - Annotation}
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_CARETEAM}
{$IFDEF FHIR_CATALOGENTRY}
procedure TFHIRJsonParser.ParseCatalogEntryRelatedEntry(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCatalogEntryRelatedEntry(jsn)); {2}
end;

function TFHIRJsonParser.ParseCatalogEntryRelatedEntry(jsn : TJsonObject) : TFhirCatalogEntryRelatedEntry;
begin
  result := TFhirCatalogEntryRelatedEntry.create;
  try
    ParseCatalogEntryRelatedEntryProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCatalogEntryRelatedEntryProperties(jsn : TJsonObject; result : TFhirCatalogEntryRelatedEntry);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('relationtype') or jsn.has('_relationtype')  then
      result.relationtypeElement := parseEnum(jsn.path+'/relationtype', jsn.node['relationtype'], jsn.vObj['_relationtype'], CODES_TFhirRelationTypeEnum, SYSTEMS_TFhirRelationTypeEnum);
    if jsn.has('item') then
        result.item := ParseReference{TFhirCatalogEntry}(jsn.vObj['item']);{q3}
end;

procedure TFHIRJsonComposer.ComposeCatalogEntryRelatedEntry(json : TJSONWriter; name : string; elem : TFhirCatalogEntryRelatedEntry; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'relationtype', elem.RelationtypeElement, CODES_TFhirRelationTypeEnum, false);
  ComposeEnumProps(json, 'relationtype', elem.RelationtypeElement, CODES_TFhirRelationTypeEnum, false);
  ComposeReference{TFhirCatalogEntry}(json, 'item', elem.item); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseCatalogEntry(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCatalogEntry(jsn)); {2}
end;

function TFHIRJsonParser.ParseCatalogEntry(jsn : TJsonObject) : TFhirCatalogEntry;
begin
  result := TFhirCatalogEntry.create;
  try
    ParseCatalogEntryProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCatalogEntryProperties(jsn : TJsonObject; result : TFhirCatalogEntry);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('orderable') or jsn.has('_orderable') then
        result.orderableElement := parseBoolean(jsn.node['orderable'], jsn.vObj['_orderable']);{q}
    if jsn.has('referencedItem') then
        result.referencedItem := ParseReference{TFhirMedication}(jsn.vObj['referencedItem']);{q3}
    if jsn.has('additionalIdentifier') then
      iterateArray(jsn.vArr['additionalIdentifier'], result.additionalIdentifierList, parseIdentifier);
    if jsn.has('classification') then
      iterateArray(jsn.vArr['classification'], result.classificationList, parseCodeableConcept);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    if jsn.has('validityPeriod') then
        result.validityPeriod := ParsePeriod(jsn.vObj['validityPeriod']);{q3}
    if jsn.has('validTo') or jsn.has('_validTo') then
        result.validToElement := parseDateTime(jsn.node['validTo'], jsn.vObj['_validTo']);{q}
    if jsn.has('lastUpdated') or jsn.has('_lastUpdated') then
        result.lastUpdatedElement := parseDateTime(jsn.node['lastUpdated'], jsn.vObj['_lastUpdated']);{q}
    if jsn.has('additionalCharacteristic') then
      iterateArray(jsn.vArr['additionalCharacteristic'], result.additionalCharacteristicList, parseCodeableConcept);
    if jsn.has('additionalClassification') then
      iterateArray(jsn.vArr['additionalClassification'], result.additionalClassificationList, parseCodeableConcept);
    if jsn.has('relatedEntry') then
      iterateArray(jsn.vArr['relatedEntry'], result.relatedEntryList, parseCatalogEntryRelatedEntry);
end;

procedure TFHIRJsonComposer.ComposeCatalogEntry(json : TJSONWriter; name : string; elem : TFhirCatalogEntry; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('type_') then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  ComposeBooleanValue(json, 'orderable', elem.orderableElement, false);
  ComposeBooleanProps(json, 'orderable', elem.orderableElement, false);
  ComposeReference{TFhirMedication}(json, 'referencedItem', elem.referencedItem); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('additionalIdentifier') and (elem.additionalIdentifierList.Count > 0) then
  begin
    json.valueArray('additionalIdentifier');
    for i := 0 to elem.additionalIdentifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.additionalIdentifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('classification') and (elem.classificationList.Count > 0) then
  begin
    json.valueArray('classification');
    for i := 0 to elem.classificationList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.classificationList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('status') then
    ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, false);
  if (SummaryOption in [soFull, soData]) and doCompose('status') then
    ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, false);
  if (SummaryOption in [soFull, soData]) and doCompose('validityPeriod') then
    ComposePeriod(json, 'validityPeriod', elem.validityPeriod); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('validTo') then
    ComposeDateTimeValue(json, 'validTo', elem.validToElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('validTo') then
    ComposeDateTimeProps(json, 'validTo', elem.validToElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('lastUpdated') then
    ComposeDateTimeValue(json, 'lastUpdated', elem.lastUpdatedElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('lastUpdated') then
    ComposeDateTimeProps(json, 'lastUpdated', elem.lastUpdatedElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('additionalCharacteristic') and (elem.additionalCharacteristicList.Count > 0) then
  begin
    json.valueArray('additionalCharacteristic');
    for i := 0 to elem.additionalCharacteristicList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.additionalCharacteristicList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('additionalClassification') and (elem.additionalClassificationList.Count > 0) then
  begin
    json.valueArray('additionalClassification');
    for i := 0 to elem.additionalClassificationList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.additionalClassificationList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('relatedEntry') and (elem.relatedEntryList.Count > 0) then
  begin
    json.valueArray('relatedEntry');
    for i := 0 to elem.relatedEntryList.Count - 1 do
      ComposeCatalogEntryRelatedEntry(json, '', elem.relatedEntryList[i]); {z - }
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_CATALOGENTRY}
{$IFDEF FHIR_CHARGEITEM}
procedure TFHIRJsonParser.ParseChargeItemPerformer(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseChargeItemPerformer(jsn)); {2}
end;

function TFHIRJsonParser.ParseChargeItemPerformer(jsn : TJsonObject) : TFhirChargeItemPerformer;
begin
  result := TFhirChargeItemPerformer.create;
  try
    ParseChargeItemPerformerProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseChargeItemPerformerProperties(jsn : TJsonObject; result : TFhirChargeItemPerformer);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('function') then
        result.function_ := ParseCodeableConcept(jsn.vObj['function']);{q3}
    if jsn.has('actor') then
        result.actor := ParseReference{TFhirPractitioner}(jsn.vObj['actor']);{q3}
end;

procedure TFHIRJsonComposer.ComposeChargeItemPerformer(json : TJSONWriter; name : string; elem : TFhirChargeItemPerformer; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'function', elem.function_); {a}
  ComposeReference{TFhirPractitioner}(json, 'actor', elem.actor); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseChargeItem(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseChargeItem(jsn)); {2}
end;

function TFHIRJsonParser.ParseChargeItem(jsn : TJsonObject) : TFhirChargeItem;
begin
  result := TFhirChargeItem.create;
  try
    ParseChargeItemProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseChargeItemProperties(jsn : TJsonObject; result : TFhirChargeItem);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
      if jsn.has('definitionUri') or jsn.has('_definitionUri') then
      iteratePrimitiveArray(jsn.vArr['definitionUri'], jsn.vArr['_definitionUri'], result.definitionUriList, parseUri);
      if jsn.has('definitionCanonical') or jsn.has('_definitionCanonical') then
      iteratePrimitiveArray(jsn.vArr['definitionCanonical'], jsn.vArr['_definitionCanonical'], result.definitionCanonicalList, parseCanonical);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirChargeitemStatusEnum, SYSTEMS_TFhirChargeitemStatusEnum);
    if jsn.has('partOf') then
      iterateArray(jsn.vArr['partOf'], result.partOfList, parseReference{TFhirChargeItem});
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirPatient}(jsn.vObj['subject']);{q3}
    if jsn.has('context') then
        result.context := ParseReference{TFhirEncounter}(jsn.vObj['context']);{q3}
    if jsn.has('occurrencePeriod') {a4} then
      result.occurrence := ParsePeriod(jsn.vObj['occurrencePeriod']);
    if jsn.has('occurrenceTiming') {a4} then
      result.occurrence := ParseTiming(jsn.vObj['occurrenceTiming']);
    if jsn.has('occurrenceDateTime') or jsn.has('_occurrenceDateTime') then
      result.occurrence := parseDateTime(jsn.node['occurrenceDateTime'], jsn.vObj['_occurrenceDateTime']);
    if jsn.has('performer') then
      iterateArray(jsn.vArr['performer'], result.performerList, parseChargeItemPerformer);
    if jsn.has('performingOrganization') then
        result.performingOrganization := ParseReference{TFhirOrganization}(jsn.vObj['performingOrganization']);{q3}
    if jsn.has('requestingOrganization') then
        result.requestingOrganization := ParseReference{TFhirOrganization}(jsn.vObj['requestingOrganization']);{q3}
    if jsn.has('costCenter') then
        result.costCenter := ParseReference{TFhirOrganization}(jsn.vObj['costCenter']);{q3}
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q3}
    if jsn.has('bodysite') then
      iterateArray(jsn.vArr['bodysite'], result.bodysiteList, parseCodeableConcept);
    if jsn.has('factorOverride') or jsn.has('_factorOverride') then
        result.factorOverrideElement := parseDecimal(jsn.node['factorOverride'], jsn.vObj['_factorOverride']);{q}
    if jsn.has('priceOverride') then
        result.priceOverride := ParseMoney(jsn.vObj['priceOverride']);{q3}
    if jsn.has('overrideReason') or jsn.has('_overrideReason') then
        result.overrideReasonElement := parseString(jsn.node['overrideReason'], jsn.vObj['_overrideReason']);{q}
    if jsn.has('enterer') then
        result.enterer := ParseReference{TFhirPractitioner}(jsn.vObj['enterer']);{q3}
    if jsn.has('enteredDate') or jsn.has('_enteredDate') then
        result.enteredDateElement := parseDateTime(jsn.node['enteredDate'], jsn.vObj['_enteredDate']);{q}
    if jsn.has('reason') then
      iterateArray(jsn.vArr['reason'], result.reasonList, parseCodeableConcept);
    if jsn.has('service') then
      iterateArray(jsn.vArr['service'], result.serviceList, parseReference{TFhirDiagnosticReport});
    if jsn.has('productReference') {a3} then
      result.product := ParseReference(jsn.vObj['productReference']);
    if jsn.has('productCodeableConcept') {a4} then
      result.product := ParseCodeableConcept(jsn.vObj['productCodeableConcept']);
    if jsn.has('account') then
      iterateArray(jsn.vArr['account'], result.accountList, parseReference{TFhirAccount});
    if jsn.has('note') then
      iterateArray(jsn.vArr['note'], result.noteList, parseAnnotation);
    if jsn.has('supportingInformation') then
      iterateArray(jsn.vArr['supportingInformation'], result.supportingInformationList, parseReference{TFhirReference});
end;

procedure TFHIRJsonComposer.ComposeChargeItem(json : TJSONWriter; name : string; elem : TFhirChargeItem; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('definitionUri') and (elem.definitionUriList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.definitionUriList.Count - 1 do
    begin
      ext := ext or ((elem.definitionUriList[i].id <> '') or (elem.definitionUriList[i].hasExtensionList) {no-comments or (elem.definitionUriList[i].hasComments)});
      val := val or (elem.definitionUriList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('definitionUri');
      for i := 0 to elem.definitionUriList.Count - 1 do
        ComposeUriValue(json, '',elem.definitionUriList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_definitionUri');
      for i := 0 to elem.definitionUriList.Count - 1 do
        ComposeUriProps(json, '',elem.definitionUriList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('definitionCanonical') and (elem.definitionCanonicalList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.definitionCanonicalList.Count - 1 do
    begin
      ext := ext or ((elem.definitionCanonicalList[i].id <> '') or (elem.definitionCanonicalList[i].hasExtensionList) {no-comments or (elem.definitionCanonicalList[i].hasComments)});
      val := val or (elem.definitionCanonicalList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('definitionCanonical');
      for i := 0 to elem.definitionCanonicalList.Count - 1 do
        ComposeCanonicalValue(json, '',elem.definitionCanonicalList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_definitionCanonical');
      for i := 0 to elem.definitionCanonicalList.Count - 1 do
        ComposeCanonicalProps(json, '',elem.definitionCanonicalList[i], true);
      json.FinishArray;
    end;
  end;
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirChargeitemStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirChargeitemStatusEnum, false);
  if (SummaryOption in [soFull, soData]) and doCompose('partOf') and (elem.partOfList.Count > 0) then
  begin
    json.valueArray('partOf');
    for i := 0 to elem.partOfList.Count - 1 do
      ComposeReference{TFhirChargeItem}(json, '', elem.partOfList[i]); {z - Reference(ChargeItem)}
    json.FinishArray;
  end;
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  ComposeReference{TFhirPatient}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('context') then
    ComposeReference{TFhirEncounter}(json, 'context', elem.context); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirPeriod) then 
    ComposePeriod(json, 'occurrencePeriod', TFhirPeriod(elem.occurrence)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirTiming) then 
    ComposeTiming(json, 'occurrenceTiming', TFhirTiming(elem.occurrence)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'occurrenceDateTime', TFhirDateTime(elem.occurrence), false);
    ComposeDateTimeProps(json, 'occurrenceDateTime', TFhirDateTime(elem.occurrence), false);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('performer') and (elem.performerList.Count > 0) then
  begin
    json.valueArray('performer');
    for i := 0 to elem.performerList.Count - 1 do
      ComposeChargeItemPerformer(json, '', elem.performerList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('performingOrganization') then
    ComposeReference{TFhirOrganization}(json, 'performingOrganization', elem.performingOrganization); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('requestingOrganization') then
    ComposeReference{TFhirOrganization}(json, 'requestingOrganization', elem.requestingOrganization); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('costCenter') then
    ComposeReference{TFhirOrganization}(json, 'costCenter', elem.costCenter); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('quantity') then
    ComposeQuantity(json, 'quantity', elem.quantity); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('bodysite') and (elem.bodysiteList.Count > 0) then
  begin
    json.valueArray('bodysite');
    for i := 0 to elem.bodysiteList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.bodysiteList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('factorOverride') then
    ComposeDecimalValue(json, 'factorOverride', elem.factorOverrideElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('factorOverride') then
    ComposeDecimalProps(json, 'factorOverride', elem.factorOverrideElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('priceOverride') then
    ComposeMoney(json, 'priceOverride', elem.priceOverride); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('overrideReason') then
    ComposeStringValue(json, 'overrideReason', elem.overrideReasonElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('overrideReason') then
    ComposeStringProps(json, 'overrideReason', elem.overrideReasonElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('enterer') then
    ComposeReference{TFhirPractitioner}(json, 'enterer', elem.enterer); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('enteredDate') then
    ComposeDateTimeValue(json, 'enteredDate', elem.enteredDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('enteredDate') then
    ComposeDateTimeProps(json, 'enteredDate', elem.enteredDateElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('reason') and (elem.reasonList.Count > 0) then
  begin
    json.valueArray('reason');
    for i := 0 to elem.reasonList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.reasonList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('service') and (elem.serviceList.Count > 0) then
  begin
    json.valueArray('service');
    for i := 0 to elem.serviceList.Count - 1 do
      ComposeReference{TFhirDiagnosticReport}(json, '', elem.serviceList[i]); {z - Reference(DiagnosticReport)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.product is TFhirReference) then
    ComposeReference(json, 'productReference', TFhirReference(elem.product))
  else if (SummaryOption in [soFull, soData]) and (elem.product is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'productCodeableConcept', TFhirCodeableConcept(elem.product)) ;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('account') and (elem.accountList.Count > 0) then
  begin
    json.valueArray('account');
    for i := 0 to elem.accountList.Count - 1 do
      ComposeReference{TFhirAccount}(json, '', elem.accountList[i]); {z - Reference(Account)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('note') and (elem.noteList.Count > 0) then
  begin
    json.valueArray('note');
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(json, '', elem.noteList[i]); {z - Annotation}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('supportingInformation') and (elem.supportingInformationList.Count > 0) then
  begin
    json.valueArray('supportingInformation');
    for i := 0 to elem.supportingInformationList.Count - 1 do
      ComposeReference{TFhirReference}(json, '', elem.supportingInformationList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_CHARGEITEM}
{$IFDEF FHIR_CHARGEITEMDEFINITION}
procedure TFHIRJsonParser.ParseChargeItemDefinitionApplicability(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseChargeItemDefinitionApplicability(jsn)); {2}
end;

function TFHIRJsonParser.ParseChargeItemDefinitionApplicability(jsn : TJsonObject) : TFhirChargeItemDefinitionApplicability;
begin
  result := TFhirChargeItemDefinitionApplicability.create;
  try
    ParseChargeItemDefinitionApplicabilityProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseChargeItemDefinitionApplicabilityProperties(jsn : TJsonObject; result : TFhirChargeItemDefinitionApplicability);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('language') or jsn.has('_language') then
        result.languageElement := parseString(jsn.node['language'], jsn.vObj['_language']);{q}
    if jsn.has('expression') or jsn.has('_expression') then
        result.expressionElement := parseString(jsn.node['expression'], jsn.vObj['_expression']);{q}
end;

procedure TFHIRJsonComposer.ComposeChargeItemDefinitionApplicability(json : TJSONWriter; name : string; elem : TFhirChargeItemDefinitionApplicability; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'language', elem.languageElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'language', elem.languageElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'expression', elem.expressionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'expression', elem.expressionElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseChargeItemDefinitionPropertyGroup(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseChargeItemDefinitionPropertyGroup(jsn)); {2}
end;

function TFHIRJsonParser.ParseChargeItemDefinitionPropertyGroup(jsn : TJsonObject) : TFhirChargeItemDefinitionPropertyGroup;
begin
  result := TFhirChargeItemDefinitionPropertyGroup.create;
  try
    ParseChargeItemDefinitionPropertyGroupProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseChargeItemDefinitionPropertyGroupProperties(jsn : TJsonObject; result : TFhirChargeItemDefinitionPropertyGroup);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('applicability') then
      iterateArray(jsn.vArr['applicability'], result.applicabilityList, parseChargeItemDefinitionApplicability);
    if jsn.has('priceComponent') then
      iterateArray(jsn.vArr['priceComponent'], result.priceComponentList, parseChargeItemDefinitionPropertyGroupPriceComponent);
end;

procedure TFHIRJsonComposer.ComposeChargeItemDefinitionPropertyGroup(json : TJSONWriter; name : string; elem : TFhirChargeItemDefinitionPropertyGroup; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and (elem.applicabilityList.Count > 0) then
  begin
    json.valueArray('applicability');
    for i := 0 to elem.applicabilityList.Count - 1 do
      ComposeChargeItemDefinitionApplicability(json, '', elem.applicabilityList[i]); {z - @ChargeItemDefinition.applicability}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.priceComponentList.Count > 0) then
  begin
    json.valueArray('priceComponent');
    for i := 0 to elem.priceComponentList.Count - 1 do
      ComposeChargeItemDefinitionPropertyGroupPriceComponent(json, '', elem.priceComponentList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseChargeItemDefinitionPropertyGroupPriceComponent(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseChargeItemDefinitionPropertyGroupPriceComponent(jsn)); {2}
end;

function TFHIRJsonParser.ParseChargeItemDefinitionPropertyGroupPriceComponent(jsn : TJsonObject) : TFhirChargeItemDefinitionPropertyGroupPriceComponent;
begin
  result := TFhirChargeItemDefinitionPropertyGroupPriceComponent.create;
  try
    ParseChargeItemDefinitionPropertyGroupPriceComponentProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseChargeItemDefinitionPropertyGroupPriceComponentProperties(jsn : TJsonObject; result : TFhirChargeItemDefinitionPropertyGroupPriceComponent);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn.node['type'], jsn.vObj['_type'], CODES_TFhirInvoicePriceComponentTypeEnum, SYSTEMS_TFhirInvoicePriceComponentTypeEnum);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('factor') or jsn.has('_factor') then
        result.factorElement := parseDecimal(jsn.node['factor'], jsn.vObj['_factor']);{q}
    if jsn.has('amount') then
        result.amount := ParseMoney(jsn.vObj['amount']);{q3}
end;

procedure TFHIRJsonComposer.ComposeChargeItemDefinitionPropertyGroupPriceComponent(json : TJSONWriter; name : string; elem : TFhirChargeItemDefinitionPropertyGroupPriceComponent; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirInvoicePriceComponentTypeEnum, false);
  ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirInvoicePriceComponentTypeEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalValue(json, 'factor', elem.factorElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalProps(json, 'factor', elem.factorElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(json, 'amount', elem.amount); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseChargeItemDefinition(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseChargeItemDefinition(jsn)); {2}
end;

function TFHIRJsonParser.ParseChargeItemDefinition(jsn : TJsonObject) : TFhirChargeItemDefinition;
begin
  result := TFhirChargeItemDefinition.create;
  try
    ParseChargeItemDefinitionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseChargeItemDefinitionProperties(jsn : TJsonObject; result : TFhirChargeItemDefinition);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := parseUri(jsn.node['url'], jsn.vObj['_url']);{q}
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := parseString(jsn.node['version'], jsn.vObj['_version']);{q}
    if jsn.has('title') or jsn.has('_title') then
        result.titleElement := parseString(jsn.node['title'], jsn.vObj['_title']);{q}
      if jsn.has('derivedFromUri') or jsn.has('_derivedFromUri') then
      iteratePrimitiveArray(jsn.vArr['derivedFromUri'], jsn.vArr['_derivedFromUri'], result.derivedFromUriList, parseUri);
      if jsn.has('partOf') or jsn.has('_partOf') then
      iteratePrimitiveArray(jsn.vArr['partOf'], jsn.vArr['_partOf'], result.partOfList, parseCanonical);
      if jsn.has('replaces') or jsn.has('_replaces') then
      iteratePrimitiveArray(jsn.vArr['replaces'], jsn.vArr['_replaces'], result.replacesList, parseCanonical);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    if jsn.has('experimental') or jsn.has('_experimental') then
        result.experimentalElement := parseBoolean(jsn.node['experimental'], jsn.vObj['_experimental']);{q}
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := parseDateTime(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('publisher') or jsn.has('_publisher') then
        result.publisherElement := parseString(jsn.node['publisher'], jsn.vObj['_publisher']);{q}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseContactDetail);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseMarkdown(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('useContext') then
      iterateArray(jsn.vArr['useContext'], result.useContextList, parseUsageContext);
    if jsn.has('jurisdiction') then
      iterateArray(jsn.vArr['jurisdiction'], result.jurisdictionList, parseCodeableConcept);
    if jsn.has('copyright') or jsn.has('_copyright') then
        result.copyrightElement := parseMarkdown(jsn.node['copyright'], jsn.vObj['_copyright']);{q}
    if jsn.has('approvalDate') or jsn.has('_approvalDate') then
        result.approvalDateElement := parseDate(jsn.node['approvalDate'], jsn.vObj['_approvalDate']);{q}
    if jsn.has('lastReviewDate') or jsn.has('_lastReviewDate') then
        result.lastReviewDateElement := parseDate(jsn.node['lastReviewDate'], jsn.vObj['_lastReviewDate']);{q}
    if jsn.has('effectivePeriod') then
        result.effectivePeriod := ParsePeriod(jsn.vObj['effectivePeriod']);{q3}
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('instance') then
      iterateArray(jsn.vArr['instance'], result.instanceList, parseReference{TFhirMedication});
    if jsn.has('applicability') then
      iterateArray(jsn.vArr['applicability'], result.applicabilityList, parseChargeItemDefinitionApplicability);
    if jsn.has('propertyGroup') then
      iterateArray(jsn.vArr['propertyGroup'], result.propertyGroupList, parseChargeItemDefinitionPropertyGroup);
end;

procedure TFHIRJsonComposer.ComposeChargeItemDefinition(json : TJSONWriter; name : string; elem : TFhirChargeItemDefinition; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  ComposeUriValue(json, 'url', elem.urlElement, false);
  ComposeUriProps(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeStringValue(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeStringProps(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeStringValue(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeStringProps(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('derivedFromUri') and (elem.derivedFromUriList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.derivedFromUriList.Count - 1 do
    begin
      ext := ext or ((elem.derivedFromUriList[i].id <> '') or (elem.derivedFromUriList[i].hasExtensionList) {no-comments or (elem.derivedFromUriList[i].hasComments)});
      val := val or (elem.derivedFromUriList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('derivedFromUri');
      for i := 0 to elem.derivedFromUriList.Count - 1 do
        ComposeUriValue(json, '',elem.derivedFromUriList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_derivedFromUri');
      for i := 0 to elem.derivedFromUriList.Count - 1 do
        ComposeUriProps(json, '',elem.derivedFromUriList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('partOf') and (elem.partOfList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.partOfList.Count - 1 do
    begin
      ext := ext or ((elem.partOfList[i].id <> '') or (elem.partOfList[i].hasExtensionList) {no-comments or (elem.partOfList[i].hasComments)});
      val := val or (elem.partOfList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('partOf');
      for i := 0 to elem.partOfList.Count - 1 do
        ComposeCanonicalValue(json, '',elem.partOfList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_partOf');
      for i := 0 to elem.partOfList.Count - 1 do
        ComposeCanonicalProps(json, '',elem.partOfList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('replaces') and (elem.replacesList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.replacesList.Count - 1 do
    begin
      ext := ext or ((elem.replacesList[i].id <> '') or (elem.replacesList[i].hasExtensionList) {no-comments or (elem.replacesList[i].hasComments)});
      val := val or (elem.replacesList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('replaces');
      for i := 0 to elem.replacesList.Count - 1 do
        ComposeCanonicalValue(json, '',elem.replacesList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_replaces');
      for i := 0 to elem.replacesList.Count - 1 do
        ComposeCanonicalProps(json, '',elem.replacesList[i], true);
      json.FinishArray;
    end;
  end;
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBooleanValue(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBooleanProps(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringValue(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringProps(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') and (elem.contactList.Count > 0) then
  begin
    json.valueArray('contact');
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(json, '', elem.contactList[i]); {z - ContactDetail}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeMarkdownValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeMarkdownProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') and (elem.useContextList.Count > 0) then
  begin
    json.valueArray('useContext');
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(json, '', elem.useContextList[i]); {z - UsageContext}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') and (elem.jurisdictionList.Count > 0) then
  begin
    json.valueArray('jurisdiction');
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.jurisdictionList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdownValue(json, 'copyright', elem.copyrightElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdownProps(json, 'copyright', elem.copyrightElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('approvalDate') then
    ComposeDateValue(json, 'approvalDate', elem.approvalDateElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('approvalDate') then
    ComposeDateProps(json, 'approvalDate', elem.approvalDateElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('lastReviewDate') then
    ComposeDateValue(json, 'lastReviewDate', elem.lastReviewDateElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('lastReviewDate') then
    ComposeDateProps(json, 'lastReviewDate', elem.lastReviewDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('effectivePeriod') then
    ComposePeriod(json, 'effectivePeriod', elem.effectivePeriod); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') then
    ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('instance') and (elem.instanceList.Count > 0) then
  begin
    json.valueArray('instance');
    for i := 0 to elem.instanceList.Count - 1 do
      ComposeReference{TFhirMedication}(json, '', elem.instanceList[i]); {z - Reference(Medication)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('applicability') and (elem.applicabilityList.Count > 0) then
  begin
    json.valueArray('applicability');
    for i := 0 to elem.applicabilityList.Count - 1 do
      ComposeChargeItemDefinitionApplicability(json, '', elem.applicabilityList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('propertyGroup') and (elem.propertyGroupList.Count > 0) then
  begin
    json.valueArray('propertyGroup');
    for i := 0 to elem.propertyGroupList.Count - 1 do
      ComposeChargeItemDefinitionPropertyGroup(json, '', elem.propertyGroupList[i]); {z - }
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_CHARGEITEMDEFINITION}
{$IFDEF FHIR_CLAIM}
procedure TFHIRJsonParser.ParseClaimRelated(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimRelated(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimRelated(jsn : TJsonObject) : TFhirClaimRelated;
begin
  result := TFhirClaimRelated.create;
  try
    ParseClaimRelatedProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseClaimRelatedProperties(jsn : TJsonObject; result : TFhirClaimRelated);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('claim') then
        result.claim := ParseReference{TFhirClaim}(jsn.vObj['claim']);{q3}
    if jsn.has('relationship') then
        result.relationship := ParseCodeableConcept(jsn.vObj['relationship']);{q3}
    if jsn.has('reference') then
        result.reference := ParseIdentifier(jsn.vObj['reference']);{q3}
end;

procedure TFHIRJsonComposer.ComposeClaimRelated(json : TJSONWriter; name : string; elem : TFhirClaimRelated; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirClaim}(json, 'claim', elem.claim); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'relationship', elem.relationship); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(json, 'reference', elem.reference); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseClaimPayee(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimPayee(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimPayee(jsn : TJsonObject) : TFhirClaimPayee;
begin
  result := TFhirClaimPayee.create;
  try
    ParseClaimPayeeProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseClaimPayeeProperties(jsn : TJsonObject; result : TFhirClaimPayee);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('party') then
        result.party := ParseReference{TFhirPractitioner}(jsn.vObj['party']);{q3}
end;

procedure TFHIRJsonComposer.ComposeClaimPayee(json : TJSONWriter; name : string; elem : TFhirClaimPayee; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirPractitioner}(json, 'party', elem.party); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseClaimCareTeam(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimCareTeam(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimCareTeam(jsn : TJsonObject) : TFhirClaimCareTeam;
begin
  result := TFhirClaimCareTeam.create;
  try
    ParseClaimCareTeamProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseClaimCareTeamProperties(jsn : TJsonObject; result : TFhirClaimCareTeam);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('sequence') or jsn.has('_sequence') then
        result.sequenceElement := parsePositiveInt(jsn.node['sequence'], jsn.vObj['_sequence']);{q}
    if jsn.has('provider') then
        result.provider := ParseReference{TFhirPractitioner}(jsn.vObj['provider']);{q3}
    if jsn.has('responsible') or jsn.has('_responsible') then
        result.responsibleElement := parseBoolean(jsn.node['responsible'], jsn.vObj['_responsible']);{q}
    if jsn.has('role') then
        result.role := ParseCodeableConcept(jsn.vObj['role']);{q3}
    if jsn.has('qualification') then
        result.qualification := ParseCodeableConcept(jsn.vObj['qualification']);{q3}
end;

procedure TFHIRJsonComposer.ComposeClaimCareTeam(json : TJSONWriter; name : string; elem : TFhirClaimCareTeam; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposePositiveIntValue(json, 'sequence', elem.sequenceElement, false);
  ComposePositiveIntProps(json, 'sequence', elem.sequenceElement, false);
  ComposeReference{TFhirPractitioner}(json, 'provider', elem.provider); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'responsible', elem.responsibleElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'responsible', elem.responsibleElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'role', elem.role); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'qualification', elem.qualification); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseClaimSupportingInfo(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimSupportingInfo(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimSupportingInfo(jsn : TJsonObject) : TFhirClaimSupportingInfo;
begin
  result := TFhirClaimSupportingInfo.create;
  try
    ParseClaimSupportingInfoProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseClaimSupportingInfoProperties(jsn : TJsonObject; result : TFhirClaimSupportingInfo);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('sequence') or jsn.has('_sequence') then
        result.sequenceElement := parsePositiveInt(jsn.node['sequence'], jsn.vObj['_sequence']);{q}
    if jsn.has('category') then
        result.category := ParseCodeableConcept(jsn.vObj['category']);{q3}
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('timingPeriod') {a4} then
      result.timing := ParsePeriod(jsn.vObj['timingPeriod']);
    if jsn.has('timingDate') or jsn.has('_timingDate') then
      result.timing := parseDate(jsn.node['timingDate'], jsn.vObj['_timingDate']);
    if jsn.has('valueQuantity') {a4} then
      result.value := ParseQuantity(jsn.vObj['valueQuantity']);
    if jsn.has('valueAttachment') {a4} then
      result.value := ParseAttachment(jsn.vObj['valueAttachment']);
    if jsn.has('valueReference') {a3} then
      result.value := ParseReference(jsn.vObj['valueReference']);
    if jsn.has('valueBoolean') or jsn.has('_valueBoolean') then
      result.value := parseBoolean(jsn.node['valueBoolean'], jsn.vObj['_valueBoolean']);
    if jsn.has('valueString') or jsn.has('_valueString') then
      result.value := parseString(jsn.node['valueString'], jsn.vObj['_valueString']);
    if jsn.has('reason') then
        result.reason := ParseCodeableConcept(jsn.vObj['reason']);{q3}
end;

procedure TFHIRJsonComposer.ComposeClaimSupportingInfo(json : TJSONWriter; name : string; elem : TFhirClaimSupportingInfo; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposePositiveIntValue(json, 'sequence', elem.sequenceElement, false);
  ComposePositiveIntProps(json, 'sequence', elem.sequenceElement, false);
  ComposeCodeableConcept(json, 'category', elem.category); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirPeriod) then 
    ComposePeriod(json, 'timingPeriod', TFhirPeriod(elem.timing)) 
  else if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirDate) then 
  begin
    ComposeDateValue(json, 'timingDate', TFhirDate(elem.timing), false);
    ComposeDateProps(json, 'timingDate', TFhirDate(elem.timing), false);
  end;
  if (SummaryOption in [soFull, soData]) and (elem.value is TFhirQuantity) then 
    ComposeQuantity(json, 'valueQuantity', TFhirQuantity(elem.value)) 
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirAttachment) then 
    ComposeAttachment(json, 'valueAttachment', TFhirAttachment(elem.value)) 
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirReference) then
    ComposeReference(json, 'valueReference', TFhirReference(elem.value))
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'valueBoolean', TFhirBoolean(elem.value), false);
    ComposeBooleanProps(json, 'valueBoolean', TFhirBoolean(elem.value), false);
  end
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirString) then 
  begin
    ComposeStringValue(json, 'valueString', TFhirString(elem.value), false);
    ComposeStringProps(json, 'valueString', TFhirString(elem.value), false);
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'reason', elem.reason); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseClaimDiagnosis(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimDiagnosis(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimDiagnosis(jsn : TJsonObject) : TFhirClaimDiagnosis;
begin
  result := TFhirClaimDiagnosis.create;
  try
    ParseClaimDiagnosisProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseClaimDiagnosisProperties(jsn : TJsonObject; result : TFhirClaimDiagnosis);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('sequence') or jsn.has('_sequence') then
        result.sequenceElement := parsePositiveInt(jsn.node['sequence'], jsn.vObj['_sequence']);{q}
    if jsn.has('diagnosisCodeableConcept') {a4} then
      result.diagnosis := ParseCodeableConcept(jsn.vObj['diagnosisCodeableConcept']);
    if jsn.has('diagnosisReference') {a3} then
      result.diagnosis := ParseReference(jsn.vObj['diagnosisReference']);
    if jsn.has('type') then
      iterateArray(jsn.vArr['type'], result.type_List, parseCodeableConcept);
    if jsn.has('onAdmission') then
        result.onAdmission := ParseCodeableConcept(jsn.vObj['onAdmission']);{q3}
    if jsn.has('packageCode') then
        result.packageCode := ParseCodeableConcept(jsn.vObj['packageCode']);{q3}
end;

procedure TFHIRJsonComposer.ComposeClaimDiagnosis(json : TJSONWriter; name : string; elem : TFhirClaimDiagnosis; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposePositiveIntValue(json, 'sequence', elem.sequenceElement, false);
  ComposePositiveIntProps(json, 'sequence', elem.sequenceElement, false);
  if (elem.diagnosis is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'diagnosisCodeableConcept', TFhirCodeableConcept(elem.diagnosis)) 
  else if (elem.diagnosis is TFhirReference) then
    ComposeReference(json, 'diagnosisReference', TFhirReference(elem.diagnosis));
  if (SummaryOption in [soFull, soData]) and (elem.type_List.Count > 0) then
  begin
    json.valueArray('type');
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(json, '', elem.type_List[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'onAdmission', elem.onAdmission); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'packageCode', elem.packageCode); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseClaimProcedure(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimProcedure(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimProcedure(jsn : TJsonObject) : TFhirClaimProcedure;
begin
  result := TFhirClaimProcedure.create;
  try
    ParseClaimProcedureProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseClaimProcedureProperties(jsn : TJsonObject; result : TFhirClaimProcedure);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('sequence') or jsn.has('_sequence') then
        result.sequenceElement := parsePositiveInt(jsn.node['sequence'], jsn.vObj['_sequence']);{q}
    if jsn.has('type') then
      iterateArray(jsn.vArr['type'], result.type_List, parseCodeableConcept);
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := parseDateTime(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('procedureCodeableConcept') {a4} then
      result.procedure_ := ParseCodeableConcept(jsn.vObj['procedureCodeableConcept']);
    if jsn.has('procedureReference') {a3} then
      result.procedure_ := ParseReference(jsn.vObj['procedureReference']);
    if jsn.has('udi') then
      iterateArray(jsn.vArr['udi'], result.udiList, parseReference{TFhirDevice});
end;

procedure TFHIRJsonComposer.ComposeClaimProcedure(json : TJSONWriter; name : string; elem : TFhirClaimProcedure; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposePositiveIntValue(json, 'sequence', elem.sequenceElement, false);
  ComposePositiveIntProps(json, 'sequence', elem.sequenceElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.type_List.Count > 0) then
  begin
    json.valueArray('type');
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(json, '', elem.type_List[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (elem.procedure_ is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'procedureCodeableConcept', TFhirCodeableConcept(elem.procedure_)) 
  else if (elem.procedure_ is TFhirReference) then
    ComposeReference(json, 'procedureReference', TFhirReference(elem.procedure_));
  if (SummaryOption in [soFull, soData]) and (elem.udiList.Count > 0) then
  begin
    json.valueArray('udi');
    for i := 0 to elem.udiList.Count - 1 do
      ComposeReference{TFhirDevice}(json, '', elem.udiList[i]); {z - Reference(Device)}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseClaimInsurance(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimInsurance(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimInsurance(jsn : TJsonObject) : TFhirClaimInsurance;
begin
  result := TFhirClaimInsurance.create;
  try
    ParseClaimInsuranceProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseClaimInsuranceProperties(jsn : TJsonObject; result : TFhirClaimInsurance);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('sequence') or jsn.has('_sequence') then
        result.sequenceElement := parsePositiveInt(jsn.node['sequence'], jsn.vObj['_sequence']);{q}
    if jsn.has('focal') or jsn.has('_focal') then
        result.focalElement := parseBoolean(jsn.node['focal'], jsn.vObj['_focal']);{q}
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q3}
    if jsn.has('coverage') then
        result.coverage := ParseReference{TFhirCoverage}(jsn.vObj['coverage']);{q3}
    if jsn.has('businessArrangement') or jsn.has('_businessArrangement') then
        result.businessArrangementElement := parseString(jsn.node['businessArrangement'], jsn.vObj['_businessArrangement']);{q}
      if jsn.has('preAuthRef') or jsn.has('_preAuthRef') then
      iteratePrimitiveArray(jsn.vArr['preAuthRef'], jsn.vArr['_preAuthRef'], result.preAuthRefList, parseString);
    if jsn.has('claimResponse') then
        result.claimResponse := ParseReference{TFhirClaimResponse}(jsn.vObj['claimResponse']);{q3}
end;

procedure TFHIRJsonComposer.ComposeClaimInsurance(json : TJSONWriter; name : string; elem : TFhirClaimInsurance; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposePositiveIntValue(json, 'sequence', elem.sequenceElement, false);
  ComposePositiveIntProps(json, 'sequence', elem.sequenceElement, false);
  ComposeBooleanValue(json, 'focal', elem.focalElement, false);
  ComposeBooleanProps(json, 'focal', elem.focalElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  ComposeReference{TFhirCoverage}(json, 'coverage', elem.coverage); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'businessArrangement', elem.businessArrangementElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'businessArrangement', elem.businessArrangementElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.preAuthRefList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.preAuthRefList.Count - 1 do
    begin
      ext := ext or ((elem.preAuthRefList[i].id <> '') or (elem.preAuthRefList[i].hasExtensionList) {no-comments or (elem.preAuthRefList[i].hasComments)});
      val := val or (elem.preAuthRefList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('preAuthRef');
      for i := 0 to elem.preAuthRefList.Count - 1 do
        ComposeStringValue(json, '',elem.preAuthRefList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_preAuthRef');
      for i := 0 to elem.preAuthRefList.Count - 1 do
        ComposeStringProps(json, '',elem.preAuthRefList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirClaimResponse}(json, 'claimResponse', elem.claimResponse); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseClaimAccident(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimAccident(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimAccident(jsn : TJsonObject) : TFhirClaimAccident;
begin
  result := TFhirClaimAccident.create;
  try
    ParseClaimAccidentProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseClaimAccidentProperties(jsn : TJsonObject; result : TFhirClaimAccident);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := parseDate(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('locationAddress') {a4} then
      result.location := ParseAddress(jsn.vObj['locationAddress']);
    if jsn.has('locationReference') {a3} then
      result.location := ParseReference(jsn.vObj['locationReference']);
end;

procedure TFHIRJsonComposer.ComposeClaimAccident(json : TJSONWriter; name : string; elem : TFhirClaimAccident; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeDateValue(json, 'date', elem.dateElement, false);
  ComposeDateProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) and (elem.location is TFhirAddress) then 
    ComposeAddress(json, 'locationAddress', TFhirAddress(elem.location)) 
  else if (SummaryOption in [soFull, soData]) and (elem.location is TFhirReference) then
    ComposeReference(json, 'locationReference', TFhirReference(elem.location));
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseClaimItem(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimItem(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimItem(jsn : TJsonObject) : TFhirClaimItem;
begin
  result := TFhirClaimItem.create;
  try
    ParseClaimItemProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseClaimItemProperties(jsn : TJsonObject; result : TFhirClaimItem);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('sequence') or jsn.has('_sequence') then
        result.sequenceElement := parsePositiveInt(jsn.node['sequence'], jsn.vObj['_sequence']);{q}
      if jsn.has('careTeamSequence') or jsn.has('_careTeamSequence') then
      iteratePrimitiveArray(jsn.vArr['careTeamSequence'], jsn.vArr['_careTeamSequence'], result.careTeamSequenceList, parsePositiveInt);
      if jsn.has('diagnosisSequence') or jsn.has('_diagnosisSequence') then
      iteratePrimitiveArray(jsn.vArr['diagnosisSequence'], jsn.vArr['_diagnosisSequence'], result.diagnosisSequenceList, parsePositiveInt);
      if jsn.has('procedureSequence') or jsn.has('_procedureSequence') then
      iteratePrimitiveArray(jsn.vArr['procedureSequence'], jsn.vArr['_procedureSequence'], result.procedureSequenceList, parsePositiveInt);
      if jsn.has('informationSequence') or jsn.has('_informationSequence') then
      iteratePrimitiveArray(jsn.vArr['informationSequence'], jsn.vArr['_informationSequence'], result.informationSequenceList, parsePositiveInt);
    if jsn.has('revenue') then
        result.revenue := ParseCodeableConcept(jsn.vObj['revenue']);{q3}
    if jsn.has('category') then
        result.category := ParseCodeableConcept(jsn.vObj['category']);{q3}
    if jsn.has('productOrService') then
        result.productOrService := ParseCodeableConcept(jsn.vObj['productOrService']);{q3}
    if jsn.has('modifier') then
      iterateArray(jsn.vArr['modifier'], result.modifierList, parseCodeableConcept);
    if jsn.has('programCode') then
      iterateArray(jsn.vArr['programCode'], result.programCodeList, parseCodeableConcept);
    if jsn.has('servicedPeriod') {a4} then
      result.serviced := ParsePeriod(jsn.vObj['servicedPeriod']);
    if jsn.has('servicedDate') or jsn.has('_servicedDate') then
      result.serviced := parseDate(jsn.node['servicedDate'], jsn.vObj['_servicedDate']);
    if jsn.has('locationCodeableConcept') {a4} then
      result.location := ParseCodeableConcept(jsn.vObj['locationCodeableConcept']);
    if jsn.has('locationAddress') {a4} then
      result.location := ParseAddress(jsn.vObj['locationAddress']);
    if jsn.has('locationReference') {a3} then
      result.location := ParseReference(jsn.vObj['locationReference']);
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q3}
    if jsn.has('unitPrice') then
        result.unitPrice := ParseMoney(jsn.vObj['unitPrice']);{q3}
    if jsn.has('factor') or jsn.has('_factor') then
        result.factorElement := parseDecimal(jsn.node['factor'], jsn.vObj['_factor']);{q}
    if jsn.has('net') then
        result.net := ParseMoney(jsn.vObj['net']);{q3}
    if jsn.has('udi') then
      iterateArray(jsn.vArr['udi'], result.udiList, parseReference{TFhirDevice});
    if jsn.has('bodySite') then
        result.bodySite := ParseCodeableConcept(jsn.vObj['bodySite']);{q3}
    if jsn.has('subSite') then
      iterateArray(jsn.vArr['subSite'], result.subSiteList, parseCodeableConcept);
    if jsn.has('encounter') then
      iterateArray(jsn.vArr['encounter'], result.encounterList, parseReference{TFhirEncounter});
    if jsn.has('detail') then
      iterateArray(jsn.vArr['detail'], result.detailList, parseClaimItemDetail);
end;

procedure TFHIRJsonComposer.ComposeClaimItem(json : TJSONWriter; name : string; elem : TFhirClaimItem; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposePositiveIntValue(json, 'sequence', elem.sequenceElement, false);
  ComposePositiveIntProps(json, 'sequence', elem.sequenceElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.careTeamSequenceList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.careTeamSequenceList.Count - 1 do
    begin
      ext := ext or ((elem.careTeamSequenceList[i].id <> '') or (elem.careTeamSequenceList[i].hasExtensionList) {no-comments or (elem.careTeamSequenceList[i].hasComments)});
      val := val or (elem.careTeamSequenceList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('careTeamSequence');
      for i := 0 to elem.careTeamSequenceList.Count - 1 do
        ComposePositiveIntValue(json, '',elem.careTeamSequenceList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_careTeamSequence');
      for i := 0 to elem.careTeamSequenceList.Count - 1 do
        ComposePositiveIntProps(json, '',elem.careTeamSequenceList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.diagnosisSequenceList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.diagnosisSequenceList.Count - 1 do
    begin
      ext := ext or ((elem.diagnosisSequenceList[i].id <> '') or (elem.diagnosisSequenceList[i].hasExtensionList) {no-comments or (elem.diagnosisSequenceList[i].hasComments)});
      val := val or (elem.diagnosisSequenceList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('diagnosisSequence');
      for i := 0 to elem.diagnosisSequenceList.Count - 1 do
        ComposePositiveIntValue(json, '',elem.diagnosisSequenceList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_diagnosisSequence');
      for i := 0 to elem.diagnosisSequenceList.Count - 1 do
        ComposePositiveIntProps(json, '',elem.diagnosisSequenceList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.procedureSequenceList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.procedureSequenceList.Count - 1 do
    begin
      ext := ext or ((elem.procedureSequenceList[i].id <> '') or (elem.procedureSequenceList[i].hasExtensionList) {no-comments or (elem.procedureSequenceList[i].hasComments)});
      val := val or (elem.procedureSequenceList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('procedureSequence');
      for i := 0 to elem.procedureSequenceList.Count - 1 do
        ComposePositiveIntValue(json, '',elem.procedureSequenceList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_procedureSequence');
      for i := 0 to elem.procedureSequenceList.Count - 1 do
        ComposePositiveIntProps(json, '',elem.procedureSequenceList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.informationSequenceList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.informationSequenceList.Count - 1 do
    begin
      ext := ext or ((elem.informationSequenceList[i].id <> '') or (elem.informationSequenceList[i].hasExtensionList) {no-comments or (elem.informationSequenceList[i].hasComments)});
      val := val or (elem.informationSequenceList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('informationSequence');
      for i := 0 to elem.informationSequenceList.Count - 1 do
        ComposePositiveIntValue(json, '',elem.informationSequenceList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_informationSequence');
      for i := 0 to elem.informationSequenceList.Count - 1 do
        ComposePositiveIntProps(json, '',elem.informationSequenceList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'revenue', elem.revenue); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'category', elem.category); {a}
  ComposeCodeableConcept(json, 'productOrService', elem.productOrService); {a}
  if (SummaryOption in [soFull, soData]) and (elem.modifierList.Count > 0) then
  begin
    json.valueArray('modifier');
    for i := 0 to elem.modifierList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.modifierList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.programCodeList.Count > 0) then
  begin
    json.valueArray('programCode');
    for i := 0 to elem.programCodeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.programCodeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.serviced is TFhirPeriod) then 
    ComposePeriod(json, 'servicedPeriod', TFhirPeriod(elem.serviced)) 
  else if (SummaryOption in [soFull, soData]) and (elem.serviced is TFhirDate) then 
  begin
    ComposeDateValue(json, 'servicedDate', TFhirDate(elem.serviced), false);
    ComposeDateProps(json, 'servicedDate', TFhirDate(elem.serviced), false);
  end;
  if (SummaryOption in [soFull, soData]) and (elem.location is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'locationCodeableConcept', TFhirCodeableConcept(elem.location)) 
  else if (SummaryOption in [soFull, soData]) and (elem.location is TFhirAddress) then 
    ComposeAddress(json, 'locationAddress', TFhirAddress(elem.location)) 
  else if (SummaryOption in [soFull, soData]) and (elem.location is TFhirReference) then
    ComposeReference(json, 'locationReference', TFhirReference(elem.location));
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'quantity', elem.quantity); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(json, 'unitPrice', elem.unitPrice); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalValue(json, 'factor', elem.factorElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalProps(json, 'factor', elem.factorElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(json, 'net', elem.net); {a}
  if (SummaryOption in [soFull, soData]) and (elem.udiList.Count > 0) then
  begin
    json.valueArray('udi');
    for i := 0 to elem.udiList.Count - 1 do
      ComposeReference{TFhirDevice}(json, '', elem.udiList[i]); {z - Reference(Device)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'bodySite', elem.bodySite); {a}
  if (SummaryOption in [soFull, soData]) and (elem.subSiteList.Count > 0) then
  begin
    json.valueArray('subSite');
    for i := 0 to elem.subSiteList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.subSiteList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.encounterList.Count > 0) then
  begin
    json.valueArray('encounter');
    for i := 0 to elem.encounterList.Count - 1 do
      ComposeReference{TFhirEncounter}(json, '', elem.encounterList[i]); {z - Reference(Encounter)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.detailList.Count > 0) then
  begin
    json.valueArray('detail');
    for i := 0 to elem.detailList.Count - 1 do
      ComposeClaimItemDetail(json, '', elem.detailList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseClaimItemDetail(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimItemDetail(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimItemDetail(jsn : TJsonObject) : TFhirClaimItemDetail;
begin
  result := TFhirClaimItemDetail.create;
  try
    ParseClaimItemDetailProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseClaimItemDetailProperties(jsn : TJsonObject; result : TFhirClaimItemDetail);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('sequence') or jsn.has('_sequence') then
        result.sequenceElement := parsePositiveInt(jsn.node['sequence'], jsn.vObj['_sequence']);{q}
    if jsn.has('revenue') then
        result.revenue := ParseCodeableConcept(jsn.vObj['revenue']);{q3}
    if jsn.has('category') then
        result.category := ParseCodeableConcept(jsn.vObj['category']);{q3}
    if jsn.has('productOrService') then
        result.productOrService := ParseCodeableConcept(jsn.vObj['productOrService']);{q3}
    if jsn.has('modifier') then
      iterateArray(jsn.vArr['modifier'], result.modifierList, parseCodeableConcept);
    if jsn.has('programCode') then
      iterateArray(jsn.vArr['programCode'], result.programCodeList, parseCodeableConcept);
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q3}
    if jsn.has('unitPrice') then
        result.unitPrice := ParseMoney(jsn.vObj['unitPrice']);{q3}
    if jsn.has('factor') or jsn.has('_factor') then
        result.factorElement := parseDecimal(jsn.node['factor'], jsn.vObj['_factor']);{q}
    if jsn.has('net') then
        result.net := ParseMoney(jsn.vObj['net']);{q3}
    if jsn.has('udi') then
      iterateArray(jsn.vArr['udi'], result.udiList, parseReference{TFhirDevice});
    if jsn.has('subDetail') then
      iterateArray(jsn.vArr['subDetail'], result.subDetailList, parseClaimItemDetailSubDetail);
end;

procedure TFHIRJsonComposer.ComposeClaimItemDetail(json : TJSONWriter; name : string; elem : TFhirClaimItemDetail; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposePositiveIntValue(json, 'sequence', elem.sequenceElement, false);
  ComposePositiveIntProps(json, 'sequence', elem.sequenceElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'revenue', elem.revenue); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'category', elem.category); {a}
  ComposeCodeableConcept(json, 'productOrService', elem.productOrService); {a}
  if (SummaryOption in [soFull, soData]) and (elem.modifierList.Count > 0) then
  begin
    json.valueArray('modifier');
    for i := 0 to elem.modifierList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.modifierList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.programCodeList.Count > 0) then
  begin
    json.valueArray('programCode');
    for i := 0 to elem.programCodeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.programCodeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'quantity', elem.quantity); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(json, 'unitPrice', elem.unitPrice); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalValue(json, 'factor', elem.factorElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalProps(json, 'factor', elem.factorElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(json, 'net', elem.net); {a}
  if (SummaryOption in [soFull, soData]) and (elem.udiList.Count > 0) then
  begin
    json.valueArray('udi');
    for i := 0 to elem.udiList.Count - 1 do
      ComposeReference{TFhirDevice}(json, '', elem.udiList[i]); {z - Reference(Device)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.subDetailList.Count > 0) then
  begin
    json.valueArray('subDetail');
    for i := 0 to elem.subDetailList.Count - 1 do
      ComposeClaimItemDetailSubDetail(json, '', elem.subDetailList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseClaimItemDetailSubDetail(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimItemDetailSubDetail(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimItemDetailSubDetail(jsn : TJsonObject) : TFhirClaimItemDetailSubDetail;
begin
  result := TFhirClaimItemDetailSubDetail.create;
  try
    ParseClaimItemDetailSubDetailProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseClaimItemDetailSubDetailProperties(jsn : TJsonObject; result : TFhirClaimItemDetailSubDetail);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('sequence') or jsn.has('_sequence') then
        result.sequenceElement := parsePositiveInt(jsn.node['sequence'], jsn.vObj['_sequence']);{q}
    if jsn.has('revenue') then
        result.revenue := ParseCodeableConcept(jsn.vObj['revenue']);{q3}
    if jsn.has('category') then
        result.category := ParseCodeableConcept(jsn.vObj['category']);{q3}
    if jsn.has('productOrService') then
        result.productOrService := ParseCodeableConcept(jsn.vObj['productOrService']);{q3}
    if jsn.has('modifier') then
      iterateArray(jsn.vArr['modifier'], result.modifierList, parseCodeableConcept);
    if jsn.has('programCode') then
      iterateArray(jsn.vArr['programCode'], result.programCodeList, parseCodeableConcept);
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q3}
    if jsn.has('unitPrice') then
        result.unitPrice := ParseMoney(jsn.vObj['unitPrice']);{q3}
    if jsn.has('factor') or jsn.has('_factor') then
        result.factorElement := parseDecimal(jsn.node['factor'], jsn.vObj['_factor']);{q}
    if jsn.has('net') then
        result.net := ParseMoney(jsn.vObj['net']);{q3}
    if jsn.has('udi') then
      iterateArray(jsn.vArr['udi'], result.udiList, parseReference{TFhirDevice});
end;

procedure TFHIRJsonComposer.ComposeClaimItemDetailSubDetail(json : TJSONWriter; name : string; elem : TFhirClaimItemDetailSubDetail; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposePositiveIntValue(json, 'sequence', elem.sequenceElement, false);
  ComposePositiveIntProps(json, 'sequence', elem.sequenceElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'revenue', elem.revenue); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'category', elem.category); {a}
  ComposeCodeableConcept(json, 'productOrService', elem.productOrService); {a}
  if (SummaryOption in [soFull, soData]) and (elem.modifierList.Count > 0) then
  begin
    json.valueArray('modifier');
    for i := 0 to elem.modifierList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.modifierList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.programCodeList.Count > 0) then
  begin
    json.valueArray('programCode');
    for i := 0 to elem.programCodeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.programCodeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'quantity', elem.quantity); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(json, 'unitPrice', elem.unitPrice); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalValue(json, 'factor', elem.factorElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalProps(json, 'factor', elem.factorElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(json, 'net', elem.net); {a}
  if (SummaryOption in [soFull, soData]) and (elem.udiList.Count > 0) then
  begin
    json.valueArray('udi');
    for i := 0 to elem.udiList.Count - 1 do
      ComposeReference{TFhirDevice}(json, '', elem.udiList[i]); {z - Reference(Device)}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseClaim(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaim(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaim(jsn : TJsonObject) : TFhirClaim;
begin
  result := TFhirClaim.create;
  try
    ParseClaimProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseClaimProperties(jsn : TJsonObject; result : TFhirClaim);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirFmStatusEnum, SYSTEMS_TFhirFmStatusEnum);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('subType') then
        result.subType := ParseCodeableConcept(jsn.vObj['subType']);{q3}
    if jsn.has('use') or jsn.has('_use')  then
      result.useElement := parseEnum(jsn.path+'/use', jsn.node['use'], jsn.vObj['_use'], CODES_TFhirClaimUseEnum, SYSTEMS_TFhirClaimUseEnum);
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q3}
    if jsn.has('billablePeriod') then
        result.billablePeriod := ParsePeriod(jsn.vObj['billablePeriod']);{q3}
    if jsn.has('created') or jsn.has('_created') then
        result.createdElement := parseDateTime(jsn.node['created'], jsn.vObj['_created']);{q}
    if jsn.has('enterer') then
        result.enterer := ParseReference{TFhirPractitioner}(jsn.vObj['enterer']);{q3}
    if jsn.has('insurer') then
        result.insurer := ParseReference{TFhirOrganization}(jsn.vObj['insurer']);{q3}
    if jsn.has('provider') then
        result.provider := ParseReference{TFhirPractitioner}(jsn.vObj['provider']);{q3}
    if jsn.has('priority') then
        result.priority := ParseCodeableConcept(jsn.vObj['priority']);{q3}
    if jsn.has('fundsReserve') then
        result.fundsReserve := ParseCodeableConcept(jsn.vObj['fundsReserve']);{q3}
    if jsn.has('related') then
      iterateArray(jsn.vArr['related'], result.relatedList, parseClaimRelated);
    if jsn.has('prescription') then
        result.prescription := ParseReference{TFhirDeviceRequest}(jsn.vObj['prescription']);{q3}
    if jsn.has('originalPrescription') then
        result.originalPrescription := ParseReference{TFhirDeviceRequest}(jsn.vObj['originalPrescription']);{q3}
    if jsn.has('payee') then
        result.payee := ParseClaimPayee(jsn.vObj['payee']);{q3}
    if jsn.has('referral') then
        result.referral := ParseReference{TFhirServiceRequest}(jsn.vObj['referral']);{q3}
    if jsn.has('facility') then
        result.facility := ParseReference{TFhirLocation}(jsn.vObj['facility']);{q3}
    if jsn.has('careTeam') then
      iterateArray(jsn.vArr['careTeam'], result.careTeamList, parseClaimCareTeam);
    if jsn.has('supportingInfo') then
      iterateArray(jsn.vArr['supportingInfo'], result.supportingInfoList, parseClaimSupportingInfo);
    if jsn.has('diagnosis') then
      iterateArray(jsn.vArr['diagnosis'], result.diagnosisList, parseClaimDiagnosis);
    if jsn.has('procedure') then
      iterateArray(jsn.vArr['procedure'], result.procedure_List, parseClaimProcedure);
    if jsn.has('insurance') then
      iterateArray(jsn.vArr['insurance'], result.insuranceList, parseClaimInsurance);
    if jsn.has('accident') then
        result.accident := ParseClaimAccident(jsn.vObj['accident']);{q3}
    if jsn.has('item') then
      iterateArray(jsn.vArr['item'], result.itemList, parseClaimItem);
    if jsn.has('total') then
        result.total := ParseMoney(jsn.vObj['total']);{q3}
end;

procedure TFHIRJsonComposer.ComposeClaim(json : TJSONWriter; name : string; elem : TFhirClaim; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirFmStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirFmStatusEnum, false);
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('subType') then
    ComposeCodeableConcept(json, 'subType', elem.subType); {a}
  ComposeEnumValue(json, 'use', elem.UseElement, CODES_TFhirClaimUseEnum, false);
  ComposeEnumProps(json, 'use', elem.UseElement, CODES_TFhirClaimUseEnum, false);
    ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('billablePeriod') then
    ComposePeriod(json, 'billablePeriod', elem.billablePeriod); {a}
    ComposeDateTimeValue(json, 'created', elem.createdElement, false);
    ComposeDateTimeProps(json, 'created', elem.createdElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('enterer') then
    ComposeReference{TFhirPractitioner}(json, 'enterer', elem.enterer); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('insurer') then
    ComposeReference{TFhirOrganization}(json, 'insurer', elem.insurer); {a}
    ComposeReference{TFhirPractitioner}(json, 'provider', elem.provider); {a}
    ComposeCodeableConcept(json, 'priority', elem.priority); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('fundsReserve') then
    ComposeCodeableConcept(json, 'fundsReserve', elem.fundsReserve); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('related') and (elem.relatedList.Count > 0) then
  begin
    json.valueArray('related');
    for i := 0 to elem.relatedList.Count - 1 do
      ComposeClaimRelated(json, '', elem.relatedList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('prescription') then
    ComposeReference{TFhirDeviceRequest}(json, 'prescription', elem.prescription); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('originalPrescription') then
    ComposeReference{TFhirDeviceRequest}(json, 'originalPrescription', elem.originalPrescription); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('payee') then
    ComposeClaimPayee(json, 'payee', elem.payee); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('referral') then
    ComposeReference{TFhirServiceRequest}(json, 'referral', elem.referral); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('facility') then
    ComposeReference{TFhirLocation}(json, 'facility', elem.facility); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('careTeam') and (elem.careTeamList.Count > 0) then
  begin
    json.valueArray('careTeam');
    for i := 0 to elem.careTeamList.Count - 1 do
      ComposeClaimCareTeam(json, '', elem.careTeamList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('supportingInfo') and (elem.supportingInfoList.Count > 0) then
  begin
    json.valueArray('supportingInfo');
    for i := 0 to elem.supportingInfoList.Count - 1 do
      ComposeClaimSupportingInfo(json, '', elem.supportingInfoList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('diagnosis') and (elem.diagnosisList.Count > 0) then
  begin
    json.valueArray('diagnosis');
    for i := 0 to elem.diagnosisList.Count - 1 do
      ComposeClaimDiagnosis(json, '', elem.diagnosisList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('procedure_') and (elem.procedure_List.Count > 0) then
  begin
    json.valueArray('procedure');
    for i := 0 to elem.procedure_List.Count - 1 do
      ComposeClaimProcedure(json, '', elem.procedure_List[i]); {z - }
    json.FinishArray;
  end;
  if (elem.insuranceList.Count > 0) then
  begin
    json.valueArray('insurance');
    for i := 0 to elem.insuranceList.Count - 1 do
      ComposeClaimInsurance(json, '', elem.insuranceList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('accident') then
    ComposeClaimAccident(json, 'accident', elem.accident); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('item') and (elem.itemList.Count > 0) then
  begin
    json.valueArray('item');
    for i := 0 to elem.itemList.Count - 1 do
      ComposeClaimItem(json, '', elem.itemList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('total') then
    ComposeMoney(json, 'total', elem.total); {a}
end;

{$ENDIF FHIR_CLAIM}
{$IFDEF FHIR_CLAIMRESPONSE}
procedure TFHIRJsonParser.ParseClaimResponseItem(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimResponseItem(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimResponseItem(jsn : TJsonObject) : TFhirClaimResponseItem;
begin
  result := TFhirClaimResponseItem.create;
  try
    ParseClaimResponseItemProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseClaimResponseItemProperties(jsn : TJsonObject; result : TFhirClaimResponseItem);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('itemSequence') or jsn.has('_itemSequence') then
        result.itemSequenceElement := parsePositiveInt(jsn.node['itemSequence'], jsn.vObj['_itemSequence']);{q}
      if jsn.has('noteNumber') or jsn.has('_noteNumber') then
      iteratePrimitiveArray(jsn.vArr['noteNumber'], jsn.vArr['_noteNumber'], result.noteNumberList, parsePositiveInt);
    if jsn.has('adjudication') then
      iterateArray(jsn.vArr['adjudication'], result.adjudicationList, parseClaimResponseItemAdjudication);
    if jsn.has('detail') then
      iterateArray(jsn.vArr['detail'], result.detailList, parseClaimResponseItemDetail);
end;

procedure TFHIRJsonComposer.ComposeClaimResponseItem(json : TJSONWriter; name : string; elem : TFhirClaimResponseItem; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposePositiveIntValue(json, 'itemSequence', elem.itemSequenceElement, false);
  ComposePositiveIntProps(json, 'itemSequence', elem.itemSequenceElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.noteNumberList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.noteNumberList.Count - 1 do
    begin
      ext := ext or ((elem.noteNumberList[i].id <> '') or (elem.noteNumberList[i].hasExtensionList) {no-comments or (elem.noteNumberList[i].hasComments)});
      val := val or (elem.noteNumberList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('noteNumber');
      for i := 0 to elem.noteNumberList.Count - 1 do
        ComposePositiveIntValue(json, '',elem.noteNumberList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_noteNumber');
      for i := 0 to elem.noteNumberList.Count - 1 do
        ComposePositiveIntProps(json, '',elem.noteNumberList[i], true);
      json.FinishArray;
    end;
  end;
  if (elem.adjudicationList.Count > 0) then
  begin
    json.valueArray('adjudication');
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeClaimResponseItemAdjudication(json, '', elem.adjudicationList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.detailList.Count > 0) then
  begin
    json.valueArray('detail');
    for i := 0 to elem.detailList.Count - 1 do
      ComposeClaimResponseItemDetail(json, '', elem.detailList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseClaimResponseItemAdjudication(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimResponseItemAdjudication(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimResponseItemAdjudication(jsn : TJsonObject) : TFhirClaimResponseItemAdjudication;
begin
  result := TFhirClaimResponseItemAdjudication.create;
  try
    ParseClaimResponseItemAdjudicationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseClaimResponseItemAdjudicationProperties(jsn : TJsonObject; result : TFhirClaimResponseItemAdjudication);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('category') then
        result.category := ParseCodeableConcept(jsn.vObj['category']);{q3}
    if jsn.has('reason') then
        result.reason := ParseCodeableConcept(jsn.vObj['reason']);{q3}
    if jsn.has('amount') then
        result.amount := ParseMoney(jsn.vObj['amount']);{q3}
    if jsn.has('value') or jsn.has('_value') then
        result.valueElement := parseDecimal(jsn.node['value'], jsn.vObj['_value']);{q}
end;

procedure TFHIRJsonComposer.ComposeClaimResponseItemAdjudication(json : TJSONWriter; name : string; elem : TFhirClaimResponseItemAdjudication; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'category', elem.category); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'reason', elem.reason); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(json, 'amount', elem.amount); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalValue(json, 'value', elem.valueElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalProps(json, 'value', elem.valueElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseClaimResponseItemDetail(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimResponseItemDetail(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimResponseItemDetail(jsn : TJsonObject) : TFhirClaimResponseItemDetail;
begin
  result := TFhirClaimResponseItemDetail.create;
  try
    ParseClaimResponseItemDetailProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseClaimResponseItemDetailProperties(jsn : TJsonObject; result : TFhirClaimResponseItemDetail);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('detailSequence') or jsn.has('_detailSequence') then
        result.detailSequenceElement := parsePositiveInt(jsn.node['detailSequence'], jsn.vObj['_detailSequence']);{q}
      if jsn.has('noteNumber') or jsn.has('_noteNumber') then
      iteratePrimitiveArray(jsn.vArr['noteNumber'], jsn.vArr['_noteNumber'], result.noteNumberList, parsePositiveInt);
    if jsn.has('adjudication') then
      iterateArray(jsn.vArr['adjudication'], result.adjudicationList, parseClaimResponseItemAdjudication);
    if jsn.has('subDetail') then
      iterateArray(jsn.vArr['subDetail'], result.subDetailList, parseClaimResponseItemDetailSubDetail);
end;

procedure TFHIRJsonComposer.ComposeClaimResponseItemDetail(json : TJSONWriter; name : string; elem : TFhirClaimResponseItemDetail; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposePositiveIntValue(json, 'detailSequence', elem.detailSequenceElement, false);
  ComposePositiveIntProps(json, 'detailSequence', elem.detailSequenceElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.noteNumberList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.noteNumberList.Count - 1 do
    begin
      ext := ext or ((elem.noteNumberList[i].id <> '') or (elem.noteNumberList[i].hasExtensionList) {no-comments or (elem.noteNumberList[i].hasComments)});
      val := val or (elem.noteNumberList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('noteNumber');
      for i := 0 to elem.noteNumberList.Count - 1 do
        ComposePositiveIntValue(json, '',elem.noteNumberList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_noteNumber');
      for i := 0 to elem.noteNumberList.Count - 1 do
        ComposePositiveIntProps(json, '',elem.noteNumberList[i], true);
      json.FinishArray;
    end;
  end;
  if (elem.adjudicationList.Count > 0) then
  begin
    json.valueArray('adjudication');
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeClaimResponseItemAdjudication(json, '', elem.adjudicationList[i]); {z - @ClaimResponse.item.adjudication}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.subDetailList.Count > 0) then
  begin
    json.valueArray('subDetail');
    for i := 0 to elem.subDetailList.Count - 1 do
      ComposeClaimResponseItemDetailSubDetail(json, '', elem.subDetailList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseClaimResponseItemDetailSubDetail(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimResponseItemDetailSubDetail(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimResponseItemDetailSubDetail(jsn : TJsonObject) : TFhirClaimResponseItemDetailSubDetail;
begin
  result := TFhirClaimResponseItemDetailSubDetail.create;
  try
    ParseClaimResponseItemDetailSubDetailProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseClaimResponseItemDetailSubDetailProperties(jsn : TJsonObject; result : TFhirClaimResponseItemDetailSubDetail);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('subDetailSequence') or jsn.has('_subDetailSequence') then
        result.subDetailSequenceElement := parsePositiveInt(jsn.node['subDetailSequence'], jsn.vObj['_subDetailSequence']);{q}
      if jsn.has('noteNumber') or jsn.has('_noteNumber') then
      iteratePrimitiveArray(jsn.vArr['noteNumber'], jsn.vArr['_noteNumber'], result.noteNumberList, parsePositiveInt);
    if jsn.has('adjudication') then
      iterateArray(jsn.vArr['adjudication'], result.adjudicationList, parseClaimResponseItemAdjudication);
end;

procedure TFHIRJsonComposer.ComposeClaimResponseItemDetailSubDetail(json : TJSONWriter; name : string; elem : TFhirClaimResponseItemDetailSubDetail; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposePositiveIntValue(json, 'subDetailSequence', elem.subDetailSequenceElement, false);
  ComposePositiveIntProps(json, 'subDetailSequence', elem.subDetailSequenceElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.noteNumberList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.noteNumberList.Count - 1 do
    begin
      ext := ext or ((elem.noteNumberList[i].id <> '') or (elem.noteNumberList[i].hasExtensionList) {no-comments or (elem.noteNumberList[i].hasComments)});
      val := val or (elem.noteNumberList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('noteNumber');
      for i := 0 to elem.noteNumberList.Count - 1 do
        ComposePositiveIntValue(json, '',elem.noteNumberList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_noteNumber');
      for i := 0 to elem.noteNumberList.Count - 1 do
        ComposePositiveIntProps(json, '',elem.noteNumberList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.adjudicationList.Count > 0) then
  begin
    json.valueArray('adjudication');
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeClaimResponseItemAdjudication(json, '', elem.adjudicationList[i]); {z - @ClaimResponse.item.adjudication}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseClaimResponseAddItem(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimResponseAddItem(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimResponseAddItem(jsn : TJsonObject) : TFhirClaimResponseAddItem;
begin
  result := TFhirClaimResponseAddItem.create;
  try
    ParseClaimResponseAddItemProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseClaimResponseAddItemProperties(jsn : TJsonObject; result : TFhirClaimResponseAddItem);
begin
    ParseBackboneElementProperties(jsn, result);
      if jsn.has('itemSequence') or jsn.has('_itemSequence') then
      iteratePrimitiveArray(jsn.vArr['itemSequence'], jsn.vArr['_itemSequence'], result.itemSequenceList, parsePositiveInt);
      if jsn.has('detailSequence') or jsn.has('_detailSequence') then
      iteratePrimitiveArray(jsn.vArr['detailSequence'], jsn.vArr['_detailSequence'], result.detailSequenceList, parsePositiveInt);
      if jsn.has('subdetailSequence') or jsn.has('_subdetailSequence') then
      iteratePrimitiveArray(jsn.vArr['subdetailSequence'], jsn.vArr['_subdetailSequence'], result.subdetailSequenceList, parsePositiveInt);
    if jsn.has('provider') then
      iterateArray(jsn.vArr['provider'], result.providerList, parseReference{TFhirPractitioner});
    if jsn.has('productOrService') then
        result.productOrService := ParseCodeableConcept(jsn.vObj['productOrService']);{q3}
    if jsn.has('modifier') then
      iterateArray(jsn.vArr['modifier'], result.modifierList, parseCodeableConcept);
    if jsn.has('programCode') then
      iterateArray(jsn.vArr['programCode'], result.programCodeList, parseCodeableConcept);
    if jsn.has('servicedPeriod') {a4} then
      result.serviced := ParsePeriod(jsn.vObj['servicedPeriod']);
    if jsn.has('servicedDate') or jsn.has('_servicedDate') then
      result.serviced := parseDate(jsn.node['servicedDate'], jsn.vObj['_servicedDate']);
    if jsn.has('locationCodeableConcept') {a4} then
      result.location := ParseCodeableConcept(jsn.vObj['locationCodeableConcept']);
    if jsn.has('locationAddress') {a4} then
      result.location := ParseAddress(jsn.vObj['locationAddress']);
    if jsn.has('locationReference') {a3} then
      result.location := ParseReference(jsn.vObj['locationReference']);
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q3}
    if jsn.has('unitPrice') then
        result.unitPrice := ParseMoney(jsn.vObj['unitPrice']);{q3}
    if jsn.has('factor') or jsn.has('_factor') then
        result.factorElement := parseDecimal(jsn.node['factor'], jsn.vObj['_factor']);{q}
    if jsn.has('net') then
        result.net := ParseMoney(jsn.vObj['net']);{q3}
    if jsn.has('bodySite') then
        result.bodySite := ParseCodeableConcept(jsn.vObj['bodySite']);{q3}
    if jsn.has('subSite') then
      iterateArray(jsn.vArr['subSite'], result.subSiteList, parseCodeableConcept);
      if jsn.has('noteNumber') or jsn.has('_noteNumber') then
      iteratePrimitiveArray(jsn.vArr['noteNumber'], jsn.vArr['_noteNumber'], result.noteNumberList, parsePositiveInt);
    if jsn.has('adjudication') then
      iterateArray(jsn.vArr['adjudication'], result.adjudicationList, parseClaimResponseItemAdjudication);
    if jsn.has('detail') then
      iterateArray(jsn.vArr['detail'], result.detailList, parseClaimResponseAddItemDetail);
end;

procedure TFHIRJsonComposer.ComposeClaimResponseAddItem(json : TJSONWriter; name : string; elem : TFhirClaimResponseAddItem; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and (elem.itemSequenceList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.itemSequenceList.Count - 1 do
    begin
      ext := ext or ((elem.itemSequenceList[i].id <> '') or (elem.itemSequenceList[i].hasExtensionList) {no-comments or (elem.itemSequenceList[i].hasComments)});
      val := val or (elem.itemSequenceList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('itemSequence');
      for i := 0 to elem.itemSequenceList.Count - 1 do
        ComposePositiveIntValue(json, '',elem.itemSequenceList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_itemSequence');
      for i := 0 to elem.itemSequenceList.Count - 1 do
        ComposePositiveIntProps(json, '',elem.itemSequenceList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.detailSequenceList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.detailSequenceList.Count - 1 do
    begin
      ext := ext or ((elem.detailSequenceList[i].id <> '') or (elem.detailSequenceList[i].hasExtensionList) {no-comments or (elem.detailSequenceList[i].hasComments)});
      val := val or (elem.detailSequenceList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('detailSequence');
      for i := 0 to elem.detailSequenceList.Count - 1 do
        ComposePositiveIntValue(json, '',elem.detailSequenceList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_detailSequence');
      for i := 0 to elem.detailSequenceList.Count - 1 do
        ComposePositiveIntProps(json, '',elem.detailSequenceList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.subdetailSequenceList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.subdetailSequenceList.Count - 1 do
    begin
      ext := ext or ((elem.subdetailSequenceList[i].id <> '') or (elem.subdetailSequenceList[i].hasExtensionList) {no-comments or (elem.subdetailSequenceList[i].hasComments)});
      val := val or (elem.subdetailSequenceList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('subdetailSequence');
      for i := 0 to elem.subdetailSequenceList.Count - 1 do
        ComposePositiveIntValue(json, '',elem.subdetailSequenceList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_subdetailSequence');
      for i := 0 to elem.subdetailSequenceList.Count - 1 do
        ComposePositiveIntProps(json, '',elem.subdetailSequenceList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.providerList.Count > 0) then
  begin
    json.valueArray('provider');
    for i := 0 to elem.providerList.Count - 1 do
      ComposeReference{TFhirPractitioner}(json, '', elem.providerList[i]); {z - Reference(Practitioner)}
    json.FinishArray;
  end;
  ComposeCodeableConcept(json, 'productOrService', elem.productOrService); {a}
  if (SummaryOption in [soFull, soData]) and (elem.modifierList.Count > 0) then
  begin
    json.valueArray('modifier');
    for i := 0 to elem.modifierList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.modifierList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.programCodeList.Count > 0) then
  begin
    json.valueArray('programCode');
    for i := 0 to elem.programCodeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.programCodeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.serviced is TFhirPeriod) then 
    ComposePeriod(json, 'servicedPeriod', TFhirPeriod(elem.serviced)) 
  else if (SummaryOption in [soFull, soData]) and (elem.serviced is TFhirDate) then 
  begin
    ComposeDateValue(json, 'servicedDate', TFhirDate(elem.serviced), false);
    ComposeDateProps(json, 'servicedDate', TFhirDate(elem.serviced), false);
  end;
  if (SummaryOption in [soFull, soData]) and (elem.location is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'locationCodeableConcept', TFhirCodeableConcept(elem.location)) 
  else if (SummaryOption in [soFull, soData]) and (elem.location is TFhirAddress) then 
    ComposeAddress(json, 'locationAddress', TFhirAddress(elem.location)) 
  else if (SummaryOption in [soFull, soData]) and (elem.location is TFhirReference) then
    ComposeReference(json, 'locationReference', TFhirReference(elem.location));
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'quantity', elem.quantity); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(json, 'unitPrice', elem.unitPrice); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalValue(json, 'factor', elem.factorElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalProps(json, 'factor', elem.factorElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(json, 'net', elem.net); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'bodySite', elem.bodySite); {a}
  if (SummaryOption in [soFull, soData]) and (elem.subSiteList.Count > 0) then
  begin
    json.valueArray('subSite');
    for i := 0 to elem.subSiteList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.subSiteList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.noteNumberList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.noteNumberList.Count - 1 do
    begin
      ext := ext or ((elem.noteNumberList[i].id <> '') or (elem.noteNumberList[i].hasExtensionList) {no-comments or (elem.noteNumberList[i].hasComments)});
      val := val or (elem.noteNumberList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('noteNumber');
      for i := 0 to elem.noteNumberList.Count - 1 do
        ComposePositiveIntValue(json, '',elem.noteNumberList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_noteNumber');
      for i := 0 to elem.noteNumberList.Count - 1 do
        ComposePositiveIntProps(json, '',elem.noteNumberList[i], true);
      json.FinishArray;
    end;
  end;
  if (elem.adjudicationList.Count > 0) then
  begin
    json.valueArray('adjudication');
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeClaimResponseItemAdjudication(json, '', elem.adjudicationList[i]); {z - @ClaimResponse.item.adjudication}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.detailList.Count > 0) then
  begin
    json.valueArray('detail');
    for i := 0 to elem.detailList.Count - 1 do
      ComposeClaimResponseAddItemDetail(json, '', elem.detailList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseClaimResponseAddItemDetail(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimResponseAddItemDetail(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimResponseAddItemDetail(jsn : TJsonObject) : TFhirClaimResponseAddItemDetail;
begin
  result := TFhirClaimResponseAddItemDetail.create;
  try
    ParseClaimResponseAddItemDetailProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseClaimResponseAddItemDetailProperties(jsn : TJsonObject; result : TFhirClaimResponseAddItemDetail);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('productOrService') then
        result.productOrService := ParseCodeableConcept(jsn.vObj['productOrService']);{q3}
    if jsn.has('modifier') then
      iterateArray(jsn.vArr['modifier'], result.modifierList, parseCodeableConcept);
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q3}
    if jsn.has('unitPrice') then
        result.unitPrice := ParseMoney(jsn.vObj['unitPrice']);{q3}
    if jsn.has('factor') or jsn.has('_factor') then
        result.factorElement := parseDecimal(jsn.node['factor'], jsn.vObj['_factor']);{q}
    if jsn.has('net') then
        result.net := ParseMoney(jsn.vObj['net']);{q3}
      if jsn.has('noteNumber') or jsn.has('_noteNumber') then
      iteratePrimitiveArray(jsn.vArr['noteNumber'], jsn.vArr['_noteNumber'], result.noteNumberList, parsePositiveInt);
    if jsn.has('adjudication') then
      iterateArray(jsn.vArr['adjudication'], result.adjudicationList, parseClaimResponseItemAdjudication);
    if jsn.has('subDetail') then
      iterateArray(jsn.vArr['subDetail'], result.subDetailList, parseClaimResponseAddItemDetailSubDetail);
end;

procedure TFHIRJsonComposer.ComposeClaimResponseAddItemDetail(json : TJSONWriter; name : string; elem : TFhirClaimResponseAddItemDetail; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'productOrService', elem.productOrService); {a}
  if (SummaryOption in [soFull, soData]) and (elem.modifierList.Count > 0) then
  begin
    json.valueArray('modifier');
    for i := 0 to elem.modifierList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.modifierList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'quantity', elem.quantity); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(json, 'unitPrice', elem.unitPrice); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalValue(json, 'factor', elem.factorElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalProps(json, 'factor', elem.factorElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(json, 'net', elem.net); {a}
  if (SummaryOption in [soFull, soData]) and (elem.noteNumberList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.noteNumberList.Count - 1 do
    begin
      ext := ext or ((elem.noteNumberList[i].id <> '') or (elem.noteNumberList[i].hasExtensionList) {no-comments or (elem.noteNumberList[i].hasComments)});
      val := val or (elem.noteNumberList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('noteNumber');
      for i := 0 to elem.noteNumberList.Count - 1 do
        ComposePositiveIntValue(json, '',elem.noteNumberList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_noteNumber');
      for i := 0 to elem.noteNumberList.Count - 1 do
        ComposePositiveIntProps(json, '',elem.noteNumberList[i], true);
      json.FinishArray;
    end;
  end;
  if (elem.adjudicationList.Count > 0) then
  begin
    json.valueArray('adjudication');
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeClaimResponseItemAdjudication(json, '', elem.adjudicationList[i]); {z - @ClaimResponse.item.adjudication}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.subDetailList.Count > 0) then
  begin
    json.valueArray('subDetail');
    for i := 0 to elem.subDetailList.Count - 1 do
      ComposeClaimResponseAddItemDetailSubDetail(json, '', elem.subDetailList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseClaimResponseAddItemDetailSubDetail(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimResponseAddItemDetailSubDetail(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimResponseAddItemDetailSubDetail(jsn : TJsonObject) : TFhirClaimResponseAddItemDetailSubDetail;
begin
  result := TFhirClaimResponseAddItemDetailSubDetail.create;
  try
    ParseClaimResponseAddItemDetailSubDetailProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseClaimResponseAddItemDetailSubDetailProperties(jsn : TJsonObject; result : TFhirClaimResponseAddItemDetailSubDetail);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('productOrService') then
        result.productOrService := ParseCodeableConcept(jsn.vObj['productOrService']);{q3}
    if jsn.has('modifier') then
      iterateArray(jsn.vArr['modifier'], result.modifierList, parseCodeableConcept);
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q3}
    if jsn.has('unitPrice') then
        result.unitPrice := ParseMoney(jsn.vObj['unitPrice']);{q3}
    if jsn.has('factor') or jsn.has('_factor') then
        result.factorElement := parseDecimal(jsn.node['factor'], jsn.vObj['_factor']);{q}
    if jsn.has('net') then
        result.net := ParseMoney(jsn.vObj['net']);{q3}
      if jsn.has('noteNumber') or jsn.has('_noteNumber') then
      iteratePrimitiveArray(jsn.vArr['noteNumber'], jsn.vArr['_noteNumber'], result.noteNumberList, parsePositiveInt);
    if jsn.has('adjudication') then
      iterateArray(jsn.vArr['adjudication'], result.adjudicationList, parseClaimResponseItemAdjudication);
end;

procedure TFHIRJsonComposer.ComposeClaimResponseAddItemDetailSubDetail(json : TJSONWriter; name : string; elem : TFhirClaimResponseAddItemDetailSubDetail; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'productOrService', elem.productOrService); {a}
  if (SummaryOption in [soFull, soData]) and (elem.modifierList.Count > 0) then
  begin
    json.valueArray('modifier');
    for i := 0 to elem.modifierList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.modifierList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'quantity', elem.quantity); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(json, 'unitPrice', elem.unitPrice); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalValue(json, 'factor', elem.factorElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalProps(json, 'factor', elem.factorElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(json, 'net', elem.net); {a}
  if (SummaryOption in [soFull, soData]) and (elem.noteNumberList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.noteNumberList.Count - 1 do
    begin
      ext := ext or ((elem.noteNumberList[i].id <> '') or (elem.noteNumberList[i].hasExtensionList) {no-comments or (elem.noteNumberList[i].hasComments)});
      val := val or (elem.noteNumberList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('noteNumber');
      for i := 0 to elem.noteNumberList.Count - 1 do
        ComposePositiveIntValue(json, '',elem.noteNumberList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_noteNumber');
      for i := 0 to elem.noteNumberList.Count - 1 do
        ComposePositiveIntProps(json, '',elem.noteNumberList[i], true);
      json.FinishArray;
    end;
  end;
  if (elem.adjudicationList.Count > 0) then
  begin
    json.valueArray('adjudication');
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeClaimResponseItemAdjudication(json, '', elem.adjudicationList[i]); {z - @ClaimResponse.item.adjudication}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseClaimResponseTotal(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimResponseTotal(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimResponseTotal(jsn : TJsonObject) : TFhirClaimResponseTotal;
begin
  result := TFhirClaimResponseTotal.create;
  try
    ParseClaimResponseTotalProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseClaimResponseTotalProperties(jsn : TJsonObject; result : TFhirClaimResponseTotal);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('category') then
        result.category := ParseCodeableConcept(jsn.vObj['category']);{q3}
    if jsn.has('amount') then
        result.amount := ParseMoney(jsn.vObj['amount']);{q3}
end;

procedure TFHIRJsonComposer.ComposeClaimResponseTotal(json : TJSONWriter; name : string; elem : TFhirClaimResponseTotal; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'category', elem.category); {a}
  ComposeMoney(json, 'amount', elem.amount); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseClaimResponsePayment(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimResponsePayment(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimResponsePayment(jsn : TJsonObject) : TFhirClaimResponsePayment;
begin
  result := TFhirClaimResponsePayment.create;
  try
    ParseClaimResponsePaymentProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseClaimResponsePaymentProperties(jsn : TJsonObject; result : TFhirClaimResponsePayment);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('adjustment') then
        result.adjustment := ParseMoney(jsn.vObj['adjustment']);{q3}
    if jsn.has('adjustmentReason') then
        result.adjustmentReason := ParseCodeableConcept(jsn.vObj['adjustmentReason']);{q3}
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := parseDate(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('amount') then
        result.amount := ParseMoney(jsn.vObj['amount']);{q3}
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q3}
end;

procedure TFHIRJsonComposer.ComposeClaimResponsePayment(json : TJSONWriter; name : string; elem : TFhirClaimResponsePayment; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(json, 'adjustment', elem.adjustment); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'adjustmentReason', elem.adjustmentReason); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeDateValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateProps(json, 'date', elem.dateElement, false);
    ComposeMoney(json, 'amount', elem.amount); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseClaimResponseProcessNote(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimResponseProcessNote(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimResponseProcessNote(jsn : TJsonObject) : TFhirClaimResponseProcessNote;
begin
  result := TFhirClaimResponseProcessNote.create;
  try
    ParseClaimResponseProcessNoteProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseClaimResponseProcessNoteProperties(jsn : TJsonObject; result : TFhirClaimResponseProcessNote);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('number') or jsn.has('_number') then
        result.numberElement := parsePositiveInt(jsn.node['number'], jsn.vObj['_number']);{q}
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn.node['type'], jsn.vObj['_type'], CODES_TFhirNoteTypeEnum, SYSTEMS_TFhirNoteTypeEnum);
    if jsn.has('text') or jsn.has('_text') then
        result.textElement := parseString(jsn.node['text'], jsn.vObj['_text']);{q}
    if jsn.has('language') then
        result.language := ParseCodeableConcept(jsn.vObj['language']);{q3}
end;

procedure TFHIRJsonComposer.ComposeClaimResponseProcessNote(json : TJSONWriter; name : string; elem : TFhirClaimResponseProcessNote; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveIntValue(json, 'number', elem.numberElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveIntProps(json, 'number', elem.numberElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirNoteTypeEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirNoteTypeEnum, false);
    ComposeStringValue(json, 'text', elem.textElement, false);
    ComposeStringProps(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'language', elem.language); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseClaimResponseInsurance(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimResponseInsurance(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimResponseInsurance(jsn : TJsonObject) : TFhirClaimResponseInsurance;
begin
  result := TFhirClaimResponseInsurance.create;
  try
    ParseClaimResponseInsuranceProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseClaimResponseInsuranceProperties(jsn : TJsonObject; result : TFhirClaimResponseInsurance);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('sequence') or jsn.has('_sequence') then
        result.sequenceElement := parsePositiveInt(jsn.node['sequence'], jsn.vObj['_sequence']);{q}
    if jsn.has('focal') or jsn.has('_focal') then
        result.focalElement := parseBoolean(jsn.node['focal'], jsn.vObj['_focal']);{q}
    if jsn.has('coverage') then
        result.coverage := ParseReference{TFhirCoverage}(jsn.vObj['coverage']);{q3}
    if jsn.has('businessArrangement') or jsn.has('_businessArrangement') then
        result.businessArrangementElement := parseString(jsn.node['businessArrangement'], jsn.vObj['_businessArrangement']);{q}
    if jsn.has('claimResponse') then
        result.claimResponse := ParseReference{TFhirClaimResponse}(jsn.vObj['claimResponse']);{q3}
end;

procedure TFHIRJsonComposer.ComposeClaimResponseInsurance(json : TJSONWriter; name : string; elem : TFhirClaimResponseInsurance; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposePositiveIntValue(json, 'sequence', elem.sequenceElement, false);
  ComposePositiveIntProps(json, 'sequence', elem.sequenceElement, false);
  ComposeBooleanValue(json, 'focal', elem.focalElement, false);
  ComposeBooleanProps(json, 'focal', elem.focalElement, false);
  ComposeReference{TFhirCoverage}(json, 'coverage', elem.coverage); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'businessArrangement', elem.businessArrangementElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'businessArrangement', elem.businessArrangementElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirClaimResponse}(json, 'claimResponse', elem.claimResponse); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseClaimResponseError(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimResponseError(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimResponseError(jsn : TJsonObject) : TFhirClaimResponseError;
begin
  result := TFhirClaimResponseError.create;
  try
    ParseClaimResponseErrorProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseClaimResponseErrorProperties(jsn : TJsonObject; result : TFhirClaimResponseError);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('itemSequence') or jsn.has('_itemSequence') then
        result.itemSequenceElement := parsePositiveInt(jsn.node['itemSequence'], jsn.vObj['_itemSequence']);{q}
    if jsn.has('detailSequence') or jsn.has('_detailSequence') then
        result.detailSequenceElement := parsePositiveInt(jsn.node['detailSequence'], jsn.vObj['_detailSequence']);{q}
    if jsn.has('subDetailSequence') or jsn.has('_subDetailSequence') then
        result.subDetailSequenceElement := parsePositiveInt(jsn.node['subDetailSequence'], jsn.vObj['_subDetailSequence']);{q}
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
end;

procedure TFHIRJsonComposer.ComposeClaimResponseError(json : TJSONWriter; name : string; elem : TFhirClaimResponseError; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveIntValue(json, 'itemSequence', elem.itemSequenceElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveIntProps(json, 'itemSequence', elem.itemSequenceElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveIntValue(json, 'detailSequence', elem.detailSequenceElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveIntProps(json, 'detailSequence', elem.detailSequenceElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveIntValue(json, 'subDetailSequence', elem.subDetailSequenceElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveIntProps(json, 'subDetailSequence', elem.subDetailSequenceElement, false);
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseClaimResponse(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimResponse(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimResponse(jsn : TJsonObject) : TFhirClaimResponse;
begin
  result := TFhirClaimResponse.create;
  try
    ParseClaimResponseProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseClaimResponseProperties(jsn : TJsonObject; result : TFhirClaimResponse);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirFmStatusEnum, SYSTEMS_TFhirFmStatusEnum);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('subType') then
        result.subType := ParseCodeableConcept(jsn.vObj['subType']);{q3}
    if jsn.has('use') or jsn.has('_use')  then
      result.useElement := parseEnum(jsn.path+'/use', jsn.node['use'], jsn.vObj['_use'], CODES_TFhirClaimUseEnum, SYSTEMS_TFhirClaimUseEnum);
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q3}
    if jsn.has('created') or jsn.has('_created') then
        result.createdElement := parseDateTime(jsn.node['created'], jsn.vObj['_created']);{q}
    if jsn.has('insurer') then
        result.insurer := ParseReference{TFhirOrganization}(jsn.vObj['insurer']);{q3}
    if jsn.has('requestor') then
        result.requestor := ParseReference{TFhirPractitioner}(jsn.vObj['requestor']);{q3}
    if jsn.has('request') then
        result.request := ParseReference{TFhirClaim}(jsn.vObj['request']);{q3}
    if jsn.has('outcome') or jsn.has('_outcome')  then
      result.outcomeElement := parseEnum(jsn.path+'/outcome', jsn.node['outcome'], jsn.vObj['_outcome'], CODES_TFhirRemittanceOutcomeEnum, SYSTEMS_TFhirRemittanceOutcomeEnum);
    if jsn.has('disposition') or jsn.has('_disposition') then
        result.dispositionElement := parseString(jsn.node['disposition'], jsn.vObj['_disposition']);{q}
    if jsn.has('preAuthRef') or jsn.has('_preAuthRef') then
        result.preAuthRefElement := parseString(jsn.node['preAuthRef'], jsn.vObj['_preAuthRef']);{q}
    if jsn.has('preAuthPeriod') then
        result.preAuthPeriod := ParsePeriod(jsn.vObj['preAuthPeriod']);{q3}
    if jsn.has('payeeType') then
        result.payeeType := ParseCodeableConcept(jsn.vObj['payeeType']);{q3}
    if jsn.has('item') then
      iterateArray(jsn.vArr['item'], result.itemList, parseClaimResponseItem);
    if jsn.has('addItem') then
      iterateArray(jsn.vArr['addItem'], result.addItemList, parseClaimResponseAddItem);
    if jsn.has('adjudication') then
      iterateArray(jsn.vArr['adjudication'], result.adjudicationList, parseClaimResponseItemAdjudication);
    if jsn.has('total') then
      iterateArray(jsn.vArr['total'], result.totalList, parseClaimResponseTotal);
    if jsn.has('payment') then
        result.payment := ParseClaimResponsePayment(jsn.vObj['payment']);{q3}
    if jsn.has('fundsReserve') then
        result.fundsReserve := ParseCodeableConcept(jsn.vObj['fundsReserve']);{q3}
    if jsn.has('formCode') then
        result.formCode := ParseCodeableConcept(jsn.vObj['formCode']);{q3}
    if jsn.has('form') then
        result.form := ParseAttachment(jsn.vObj['form']);{q3}
    if jsn.has('processNote') then
      iterateArray(jsn.vArr['processNote'], result.processNoteList, parseClaimResponseProcessNote);
    if jsn.has('communicationRequest') then
      iterateArray(jsn.vArr['communicationRequest'], result.communicationRequestList, parseReference{TFhirCommunicationRequest});
    if jsn.has('insurance') then
      iterateArray(jsn.vArr['insurance'], result.insuranceList, parseClaimResponseInsurance);
    if jsn.has('error') then
      iterateArray(jsn.vArr['error'], result.errorList, parseClaimResponseError);
end;

procedure TFHIRJsonComposer.ComposeClaimResponse(json : TJSONWriter; name : string; elem : TFhirClaimResponse; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirFmStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirFmStatusEnum, false);
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('subType') then
    ComposeCodeableConcept(json, 'subType', elem.subType); {a}
  ComposeEnumValue(json, 'use', elem.UseElement, CODES_TFhirClaimUseEnum, false);
  ComposeEnumProps(json, 'use', elem.UseElement, CODES_TFhirClaimUseEnum, false);
    ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
    ComposeDateTimeValue(json, 'created', elem.createdElement, false);
    ComposeDateTimeProps(json, 'created', elem.createdElement, false);
    ComposeReference{TFhirOrganization}(json, 'insurer', elem.insurer); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('requestor') then
    ComposeReference{TFhirPractitioner}(json, 'requestor', elem.requestor); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('request') then
    ComposeReference{TFhirClaim}(json, 'request', elem.request); {a}
  ComposeEnumValue(json, 'outcome', elem.OutcomeElement, CODES_TFhirRemittanceOutcomeEnum, false);
  ComposeEnumProps(json, 'outcome', elem.OutcomeElement, CODES_TFhirRemittanceOutcomeEnum, false);
  if (SummaryOption in [soFull, soData]) and doCompose('disposition') then
    ComposeStringValue(json, 'disposition', elem.dispositionElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('disposition') then
    ComposeStringProps(json, 'disposition', elem.dispositionElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('preAuthRef') then
    ComposeStringValue(json, 'preAuthRef', elem.preAuthRefElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('preAuthRef') then
    ComposeStringProps(json, 'preAuthRef', elem.preAuthRefElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('preAuthPeriod') then
    ComposePeriod(json, 'preAuthPeriod', elem.preAuthPeriod); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('payeeType') then
    ComposeCodeableConcept(json, 'payeeType', elem.payeeType); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('item') and (elem.itemList.Count > 0) then
  begin
    json.valueArray('item');
    for i := 0 to elem.itemList.Count - 1 do
      ComposeClaimResponseItem(json, '', elem.itemList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('addItem') and (elem.addItemList.Count > 0) then
  begin
    json.valueArray('addItem');
    for i := 0 to elem.addItemList.Count - 1 do
      ComposeClaimResponseAddItem(json, '', elem.addItemList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('adjudication') and (elem.adjudicationList.Count > 0) then
  begin
    json.valueArray('adjudication');
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeClaimResponseItemAdjudication(json, '', elem.adjudicationList[i]); {z - @ClaimResponse.item.adjudication}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('total') and (elem.totalList.Count > 0) then
  begin
    json.valueArray('total');
    for i := 0 to elem.totalList.Count - 1 do
      ComposeClaimResponseTotal(json, '', elem.totalList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('payment') then
    ComposeClaimResponsePayment(json, 'payment', elem.payment); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('fundsReserve') then
    ComposeCodeableConcept(json, 'fundsReserve', elem.fundsReserve); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('formCode') then
    ComposeCodeableConcept(json, 'formCode', elem.formCode); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('form') then
    ComposeAttachment(json, 'form', elem.form); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('processNote') and (elem.processNoteList.Count > 0) then
  begin
    json.valueArray('processNote');
    for i := 0 to elem.processNoteList.Count - 1 do
      ComposeClaimResponseProcessNote(json, '', elem.processNoteList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('communicationRequest') and (elem.communicationRequestList.Count > 0) then
  begin
    json.valueArray('communicationRequest');
    for i := 0 to elem.communicationRequestList.Count - 1 do
      ComposeReference{TFhirCommunicationRequest}(json, '', elem.communicationRequestList[i]); {z - Reference(CommunicationRequest)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('insurance') and (elem.insuranceList.Count > 0) then
  begin
    json.valueArray('insurance');
    for i := 0 to elem.insuranceList.Count - 1 do
      ComposeClaimResponseInsurance(json, '', elem.insuranceList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('error') and (elem.errorList.Count > 0) then
  begin
    json.valueArray('error');
    for i := 0 to elem.errorList.Count - 1 do
      ComposeClaimResponseError(json, '', elem.errorList[i]); {z - }
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_CLAIMRESPONSE}
{$IFDEF FHIR_CLINICALIMPRESSION}
procedure TFHIRJsonParser.ParseClinicalImpressionInvestigation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClinicalImpressionInvestigation(jsn)); {2}
end;

function TFHIRJsonParser.ParseClinicalImpressionInvestigation(jsn : TJsonObject) : TFhirClinicalImpressionInvestigation;
begin
  result := TFhirClinicalImpressionInvestigation.create;
  try
    ParseClinicalImpressionInvestigationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseClinicalImpressionInvestigationProperties(jsn : TJsonObject; result : TFhirClinicalImpressionInvestigation);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('item') then
      iterateArray(jsn.vArr['item'], result.itemList, parseReference{TFhirObservation});
end;

procedure TFHIRJsonComposer.ComposeClinicalImpressionInvestigation(json : TJSONWriter; name : string; elem : TFhirClinicalImpressionInvestigation; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soData]) and (elem.itemList.Count > 0) then
  begin
    json.valueArray('item');
    for i := 0 to elem.itemList.Count - 1 do
      ComposeReference{TFhirObservation}(json, '', elem.itemList[i]); {z - Reference(Observation)}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseClinicalImpressionFinding(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClinicalImpressionFinding(jsn)); {2}
end;

function TFHIRJsonParser.ParseClinicalImpressionFinding(jsn : TJsonObject) : TFhirClinicalImpressionFinding;
begin
  result := TFhirClinicalImpressionFinding.create;
  try
    ParseClinicalImpressionFindingProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseClinicalImpressionFindingProperties(jsn : TJsonObject; result : TFhirClinicalImpressionFinding);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('itemCodeableConcept') then
        result.itemCodeableConcept := ParseCodeableConcept(jsn.vObj['itemCodeableConcept']);{q3}
    if jsn.has('itemReference') then
        result.itemReference := ParseReference{TFhirCondition}(jsn.vObj['itemReference']);{q3}
    if jsn.has('basis') or jsn.has('_basis') then
        result.basisElement := parseString(jsn.node['basis'], jsn.vObj['_basis']);{q}
end;

procedure TFHIRJsonComposer.ComposeClinicalImpressionFinding(json : TJSONWriter; name : string; elem : TFhirClinicalImpressionFinding; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'itemCodeableConcept', elem.itemCodeableConcept); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirCondition}(json, 'itemReference', elem.itemReference); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'basis', elem.basisElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'basis', elem.basisElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseClinicalImpression(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClinicalImpression(jsn)); {2}
end;

function TFHIRJsonParser.ParseClinicalImpression(jsn : TJsonObject) : TFhirClinicalImpression;
begin
  result := TFhirClinicalImpression.create;
  try
    ParseClinicalImpressionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseClinicalImpressionProperties(jsn : TJsonObject; result : TFhirClinicalImpression);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirClinicalimpressionStatusEnum, SYSTEMS_TFhirClinicalimpressionStatusEnum);
    if jsn.has('statusReason') then
        result.statusReason := ParseCodeableConcept(jsn.vObj['statusReason']);{q3}
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirPatient}(jsn.vObj['subject']);{q3}
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q3}
    if jsn.has('effectivePeriod') {a4} then
      result.effective := ParsePeriod(jsn.vObj['effectivePeriod']);
    if jsn.has('effectiveDateTime') or jsn.has('_effectiveDateTime') then
      result.effective := parseDateTime(jsn.node['effectiveDateTime'], jsn.vObj['_effectiveDateTime']);
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := parseDateTime(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('assessor') then
        result.assessor := ParseReference{TFhirPractitioner}(jsn.vObj['assessor']);{q3}
    if jsn.has('previous') then
        result.previous := ParseReference{TFhirClinicalImpression}(jsn.vObj['previous']);{q3}
    if jsn.has('problem') then
      iterateArray(jsn.vArr['problem'], result.problemList, parseReference{TFhirCondition});
    if jsn.has('investigation') then
      iterateArray(jsn.vArr['investigation'], result.investigationList, parseClinicalImpressionInvestigation);
      if jsn.has('protocol') or jsn.has('_protocol') then
      iteratePrimitiveArray(jsn.vArr['protocol'], jsn.vArr['_protocol'], result.protocolList, parseUri);
    if jsn.has('summary') or jsn.has('_summary') then
        result.summaryElement := parseString(jsn.node['summary'], jsn.vObj['_summary']);{q}
    if jsn.has('finding') then
      iterateArray(jsn.vArr['finding'], result.findingList, parseClinicalImpressionFinding);
    if jsn.has('prognosisCodeableConcept') then
      iterateArray(jsn.vArr['prognosisCodeableConcept'], result.prognosisCodeableConceptList, parseCodeableConcept);
    if jsn.has('prognosisReference') then
      iterateArray(jsn.vArr['prognosisReference'], result.prognosisReferenceList, parseReference{TFhirRiskAssessment});
    if jsn.has('supportingInfo') then
      iterateArray(jsn.vArr['supportingInfo'], result.supportingInfoList, parseReference{TFhirReference});
    if jsn.has('note') then
      iterateArray(jsn.vArr['note'], result.noteList, parseAnnotation);
end;

procedure TFHIRJsonComposer.ComposeClinicalImpression(json : TJSONWriter; name : string; elem : TFhirClinicalImpression; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirClinicalimpressionStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirClinicalimpressionStatusEnum, false);
  if (SummaryOption in [soFull, soData]) and doCompose('statusReason') then
    ComposeCodeableConcept(json, 'statusReason', elem.statusReason); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') then
    ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  ComposeReference{TFhirPatient}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.effective is TFhirPeriod) then 
    ComposePeriod(json, 'effectivePeriod', TFhirPeriod(elem.effective)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.effective is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'effectiveDateTime', TFhirDateTime(elem.effective), false);
    ComposeDateTimeProps(json, 'effectiveDateTime', TFhirDateTime(elem.effective), false);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('assessor') then
    ComposeReference{TFhirPractitioner}(json, 'assessor', elem.assessor); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('previous') then
    ComposeReference{TFhirClinicalImpression}(json, 'previous', elem.previous); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('problem') and (elem.problemList.Count > 0) then
  begin
    json.valueArray('problem');
    for i := 0 to elem.problemList.Count - 1 do
      ComposeReference{TFhirCondition}(json, '', elem.problemList[i]); {z - Reference(Condition)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('investigation') and (elem.investigationList.Count > 0) then
  begin
    json.valueArray('investigation');
    for i := 0 to elem.investigationList.Count - 1 do
      ComposeClinicalImpressionInvestigation(json, '', elem.investigationList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('protocol') and (elem.protocolList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.protocolList.Count - 1 do
    begin
      ext := ext or ((elem.protocolList[i].id <> '') or (elem.protocolList[i].hasExtensionList) {no-comments or (elem.protocolList[i].hasComments)});
      val := val or (elem.protocolList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('protocol');
      for i := 0 to elem.protocolList.Count - 1 do
        ComposeUriValue(json, '',elem.protocolList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_protocol');
      for i := 0 to elem.protocolList.Count - 1 do
        ComposeUriProps(json, '',elem.protocolList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('summary') then
    ComposeStringValue(json, 'summary', elem.summaryElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('summary') then
    ComposeStringProps(json, 'summary', elem.summaryElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('finding') and (elem.findingList.Count > 0) then
  begin
    json.valueArray('finding');
    for i := 0 to elem.findingList.Count - 1 do
      ComposeClinicalImpressionFinding(json, '', elem.findingList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('prognosisCodeableConcept') and (elem.prognosisCodeableConceptList.Count > 0) then
  begin
    json.valueArray('prognosisCodeableConcept');
    for i := 0 to elem.prognosisCodeableConceptList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.prognosisCodeableConceptList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('prognosisReference') and (elem.prognosisReferenceList.Count > 0) then
  begin
    json.valueArray('prognosisReference');
    for i := 0 to elem.prognosisReferenceList.Count - 1 do
      ComposeReference{TFhirRiskAssessment}(json, '', elem.prognosisReferenceList[i]); {z - Reference(RiskAssessment)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('supportingInfo') and (elem.supportingInfoList.Count > 0) then
  begin
    json.valueArray('supportingInfo');
    for i := 0 to elem.supportingInfoList.Count - 1 do
      ComposeReference{TFhirReference}(json, '', elem.supportingInfoList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('note') and (elem.noteList.Count > 0) then
  begin
    json.valueArray('note');
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(json, '', elem.noteList[i]); {z - Annotation}
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_CLINICALIMPRESSION}
{$IFDEF FHIR_CODESYSTEM}
procedure TFHIRJsonParser.ParseCodeSystemFilter(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCodeSystemFilter(jsn)); {2}
end;

function TFHIRJsonParser.ParseCodeSystemFilter(jsn : TJsonObject) : TFhirCodeSystemFilter;
begin
  result := TFhirCodeSystemFilter.create;
  try
    ParseCodeSystemFilterProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCodeSystemFilterProperties(jsn : TJsonObject; result : TFhirCodeSystemFilter);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') or jsn.has('_code') then
        result.codeElement := parseCode(jsn.node['code'], jsn.vObj['_code']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('operator') or jsn.has('_operator') then
      iterateEnumArray(jsn.vArr['operator'], jsn.vArr['_operator'], jsn.path+'/operator', result.operatorList, parseEnum, CODES_TFhirFilterOperatorEnum, SYSTEMS_TFhirFilterOperatorEnum);
    if jsn.has('value') or jsn.has('_value') then
        result.valueElement := parseString(jsn.node['value'], jsn.vObj['_value']);{q}
end;

procedure TFHIRJsonComposer.ComposeCodeSystemFilter(json : TJSONWriter; name : string; elem : TFhirCodeSystemFilter; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeValue(json, 'code', elem.codeElement, false);
  ComposeCodeProps(json, 'code', elem.codeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (elem.operatorList.Count > 0) then
  begin
    val := false;
    ext := false;
    for i := 0 to elem.operatorList.Count - 1 do
    begin
      val := val or (elem.operatorList[i].hasPrimitiveValue);
      ext := ext or ((elem.operatorList[i].id <> '') or (elem.operatorList[i].hasExtensionList));
    end;
    if val then
    begin
      json.valueArray('operator');
      for i := 0 to elem.operatorList.Count - 1 do
        ComposeEnumValue(json, '', elem.operatorList[i], CODES_TFhirFilterOperatorEnum, true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_operator');
      for i := 0 to elem.operatorList.Count - 1 do
        ComposeEnumProps(json, '', elem.operatorList[i], CODES_TFhirFilterOperatorEnum, true);
      json.FinishArray;
    end;
  end;
  ComposeStringValue(json, 'value', elem.valueElement, false);
  ComposeStringProps(json, 'value', elem.valueElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseCodeSystemProperty(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCodeSystemProperty(jsn)); {2}
end;

function TFHIRJsonParser.ParseCodeSystemProperty(jsn : TJsonObject) : TFhirCodeSystemProperty;
begin
  result := TFhirCodeSystemProperty.create;
  try
    ParseCodeSystemPropertyProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCodeSystemPropertyProperties(jsn : TJsonObject; result : TFhirCodeSystemProperty);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') or jsn.has('_code') then
        result.codeElement := parseCode(jsn.node['code'], jsn.vObj['_code']);{q}
    if jsn.has('uri') or jsn.has('_uri') then
        result.uriElement := parseUri(jsn.node['uri'], jsn.vObj['_uri']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn.node['type'], jsn.vObj['_type'], CODES_TFhirConceptPropertyTypeEnum, SYSTEMS_TFhirConceptPropertyTypeEnum);
end;

procedure TFHIRJsonComposer.ComposeCodeSystemProperty(json : TJSONWriter; name : string; elem : TFhirCodeSystemProperty; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeValue(json, 'code', elem.codeElement, false);
  ComposeCodeProps(json, 'code', elem.codeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUriValue(json, 'uri', elem.uriElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUriProps(json, 'uri', elem.uriElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirConceptPropertyTypeEnum, false);
  ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirConceptPropertyTypeEnum, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseCodeSystemConcept(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCodeSystemConcept(jsn)); {2}
end;

function TFHIRJsonParser.ParseCodeSystemConcept(jsn : TJsonObject) : TFhirCodeSystemConcept;
begin
  result := TFhirCodeSystemConcept.create;
  try
    ParseCodeSystemConceptProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCodeSystemConceptProperties(jsn : TJsonObject; result : TFhirCodeSystemConcept);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') or jsn.has('_code') then
        result.codeElement := parseCode(jsn.node['code'], jsn.vObj['_code']);{q}
    if jsn.has('display') or jsn.has('_display') then
        result.displayElement := parseString(jsn.node['display'], jsn.vObj['_display']);{q}
    if jsn.has('definition') or jsn.has('_definition') then
        result.definitionElement := parseString(jsn.node['definition'], jsn.vObj['_definition']);{q}
    if jsn.has('designation') then
      iterateArray(jsn.vArr['designation'], result.designationList, parseCodeSystemConceptDesignation);
    if jsn.has('property') then
      iterateArray(jsn.vArr['property'], result.property_List, parseCodeSystemConceptProperty);
    if jsn.has('concept') then
      iterateArray(jsn.vArr['concept'], result.conceptList, parseCodeSystemConcept);
end;

procedure TFHIRJsonComposer.ComposeCodeSystemConcept(json : TJSONWriter; name : string; elem : TFhirCodeSystemConcept; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeValue(json, 'code', elem.codeElement, false);
  ComposeCodeProps(json, 'code', elem.codeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'display', elem.displayElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'display', elem.displayElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'definition', elem.definitionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'definition', elem.definitionElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.designationList.Count > 0) then
  begin
    json.valueArray('designation');
    for i := 0 to elem.designationList.Count - 1 do
      ComposeCodeSystemConceptDesignation(json, '', elem.designationList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.property_List.Count > 0) then
  begin
    json.valueArray('property');
    for i := 0 to elem.property_List.Count - 1 do
      ComposeCodeSystemConceptProperty(json, '', elem.property_List[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.conceptList.Count > 0) then
  begin
    json.valueArray('concept');
    for i := 0 to elem.conceptList.Count - 1 do
      ComposeCodeSystemConcept(json, '', elem.conceptList[i]); {z - @CodeSystem.concept}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseCodeSystemConceptDesignation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCodeSystemConceptDesignation(jsn)); {2}
end;

function TFHIRJsonParser.ParseCodeSystemConceptDesignation(jsn : TJsonObject) : TFhirCodeSystemConceptDesignation;
begin
  result := TFhirCodeSystemConceptDesignation.create;
  try
    ParseCodeSystemConceptDesignationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCodeSystemConceptDesignationProperties(jsn : TJsonObject; result : TFhirCodeSystemConceptDesignation);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('language') or jsn.has('_language') then
        result.languageElement := parseCode(jsn.node['language'], jsn.vObj['_language']);{q}
    if jsn.has('use') then
        result.use := ParseCoding(jsn.vObj['use']);{q3}
    if jsn.has('value') or jsn.has('_value') then
        result.valueElement := parseString(jsn.node['value'], jsn.vObj['_value']);{q}
end;

procedure TFHIRJsonComposer.ComposeCodeSystemConceptDesignation(json : TJSONWriter; name : string; elem : TFhirCodeSystemConceptDesignation; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeValue(json, 'language', elem.languageElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeProps(json, 'language', elem.languageElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(json, 'use', elem.use); {a}
  ComposeStringValue(json, 'value', elem.valueElement, false);
  ComposeStringProps(json, 'value', elem.valueElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseCodeSystemConceptProperty(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCodeSystemConceptProperty(jsn)); {2}
end;

function TFHIRJsonParser.ParseCodeSystemConceptProperty(jsn : TJsonObject) : TFhirCodeSystemConceptProperty;
begin
  result := TFhirCodeSystemConceptProperty.create;
  try
    ParseCodeSystemConceptPropertyProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCodeSystemConceptPropertyProperties(jsn : TJsonObject; result : TFhirCodeSystemConceptProperty);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') or jsn.has('_code') then
        result.codeElement := parseCode(jsn.node['code'], jsn.vObj['_code']);{q}
    if jsn.has('valueCode') or jsn.has('_valueCode') then
      result.value := parseCode(jsn.node['valueCode'], jsn.vObj['_valueCode']);
    if jsn.has('valueCoding') {a4} then
      result.value := ParseCoding(jsn.vObj['valueCoding']);
    if jsn.has('valueString') or jsn.has('_valueString') then
      result.value := parseString(jsn.node['valueString'], jsn.vObj['_valueString']);
    if jsn.has('valueInteger') or jsn.has('_valueInteger') then
      result.value := parseInteger(jsn.node['valueInteger'], jsn.vObj['_valueInteger']);
    if jsn.has('valueBoolean') or jsn.has('_valueBoolean') then
      result.value := parseBoolean(jsn.node['valueBoolean'], jsn.vObj['_valueBoolean']);
    if jsn.has('valueDateTime') or jsn.has('_valueDateTime') then
      result.value := parseDateTime(jsn.node['valueDateTime'], jsn.vObj['_valueDateTime']);
    if jsn.has('valueDecimal') or jsn.has('_valueDecimal') then
      result.value := parseDecimal(jsn.node['valueDecimal'], jsn.vObj['_valueDecimal']);
end;

procedure TFHIRJsonComposer.ComposeCodeSystemConceptProperty(json : TJSONWriter; name : string; elem : TFhirCodeSystemConceptProperty; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeValue(json, 'code', elem.codeElement, false);
  ComposeCodeProps(json, 'code', elem.codeElement, false);
  if (elem.value is TFhirCode) then 
  begin
    ComposeCodeValue(json, 'valueCode', TFhirCode(elem.value), false);
    ComposeCodeProps(json, 'valueCode', TFhirCode(elem.value), false);
  end
  else if (elem.value is TFhirCoding) then 
    ComposeCoding(json, 'valueCoding', TFhirCoding(elem.value)) 
  else if (elem.value is TFhirString) then 
  begin
    ComposeStringValue(json, 'valueString', TFhirString(elem.value), false);
    ComposeStringProps(json, 'valueString', TFhirString(elem.value), false);
  end
  else if (elem.value is TFhirInteger) then 
  begin
    ComposeIntegerValue(json, 'valueInteger', TFhirInteger(elem.value), false);
    ComposeIntegerProps(json, 'valueInteger', TFhirInteger(elem.value), false);
  end
  else if (elem.value is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'valueBoolean', TFhirBoolean(elem.value), false);
    ComposeBooleanProps(json, 'valueBoolean', TFhirBoolean(elem.value), false);
  end
  else if (elem.value is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'valueDateTime', TFhirDateTime(elem.value), false);
    ComposeDateTimeProps(json, 'valueDateTime', TFhirDateTime(elem.value), false);
  end
  else if (elem.value is TFhirDecimal) then 
  begin
    ComposeDecimalValue(json, 'valueDecimal', TFhirDecimal(elem.value), false);
    ComposeDecimalProps(json, 'valueDecimal', TFhirDecimal(elem.value), false);
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseCodeSystem(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCodeSystem(jsn)); {2}
end;

function TFHIRJsonParser.ParseCodeSystem(jsn : TJsonObject) : TFhirCodeSystem;
begin
  result := TFhirCodeSystem.create;
  try
    ParseCodeSystemProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCodeSystemProperties(jsn : TJsonObject; result : TFhirCodeSystem);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := parseUri(jsn.node['url'], jsn.vObj['_url']);{q}
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := parseString(jsn.node['version'], jsn.vObj['_version']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('title') or jsn.has('_title') then
        result.titleElement := parseString(jsn.node['title'], jsn.vObj['_title']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    if jsn.has('experimental') or jsn.has('_experimental') then
        result.experimentalElement := parseBoolean(jsn.node['experimental'], jsn.vObj['_experimental']);{q}
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := parseDateTime(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('publisher') or jsn.has('_publisher') then
        result.publisherElement := parseString(jsn.node['publisher'], jsn.vObj['_publisher']);{q}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseContactDetail);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseMarkdown(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('useContext') then
      iterateArray(jsn.vArr['useContext'], result.useContextList, parseUsageContext);
    if jsn.has('jurisdiction') then
      iterateArray(jsn.vArr['jurisdiction'], result.jurisdictionList, parseCodeableConcept);
    if jsn.has('purpose') or jsn.has('_purpose') then
        result.purposeElement := parseMarkdown(jsn.node['purpose'], jsn.vObj['_purpose']);{q}
    if jsn.has('copyright') or jsn.has('_copyright') then
        result.copyrightElement := parseMarkdown(jsn.node['copyright'], jsn.vObj['_copyright']);{q}
    if jsn.has('caseSensitive') or jsn.has('_caseSensitive') then
        result.caseSensitiveElement := parseBoolean(jsn.node['caseSensitive'], jsn.vObj['_caseSensitive']);{q}
    if jsn.has('valueSet') or jsn.has('_valueSet') then
        result.valueSetElement := parseCanonical(jsn.node['valueSet'], jsn.vObj['_valueSet']);{q}
    if jsn.has('hierarchyMeaning') or jsn.has('_hierarchyMeaning')  then
      result.hierarchyMeaningElement := parseEnum(jsn.path+'/hierarchyMeaning', jsn.node['hierarchyMeaning'], jsn.vObj['_hierarchyMeaning'], CODES_TFhirCodesystemHierarchyMeaningEnum, SYSTEMS_TFhirCodesystemHierarchyMeaningEnum);
    if jsn.has('compositional') or jsn.has('_compositional') then
        result.compositionalElement := parseBoolean(jsn.node['compositional'], jsn.vObj['_compositional']);{q}
    if jsn.has('versionNeeded') or jsn.has('_versionNeeded') then
        result.versionNeededElement := parseBoolean(jsn.node['versionNeeded'], jsn.vObj['_versionNeeded']);{q}
    if jsn.has('content') or jsn.has('_content')  then
      result.contentElement := parseEnum(jsn.path+'/content', jsn.node['content'], jsn.vObj['_content'], CODES_TFhirCodesystemContentModeEnum, SYSTEMS_TFhirCodesystemContentModeEnum);
    if jsn.has('supplements') or jsn.has('_supplements') then
        result.supplementsElement := parseCanonical(jsn.node['supplements'], jsn.vObj['_supplements']);{q}
    if jsn.has('count') or jsn.has('_count') then
        result.countElement := parseUnsignedInt(jsn.node['count'], jsn.vObj['_count']);{q}
    if jsn.has('filter') then
      iterateArray(jsn.vArr['filter'], result.filterList, parseCodeSystemFilter);
    if jsn.has('property') then
      iterateArray(jsn.vArr['property'], result.property_List, parseCodeSystemProperty);
    if jsn.has('concept') then
      iterateArray(jsn.vArr['concept'], result.conceptList, parseCodeSystemConcept);
end;

procedure TFHIRJsonComposer.ComposeCodeSystem(json : TJSONWriter; name : string; elem : TFhirCodeSystem; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUriValue(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUriProps(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeStringValue(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeStringProps(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeStringValue(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeStringProps(json, 'title', elem.titleElement, false);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBooleanValue(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBooleanProps(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringValue(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringProps(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') and (elem.contactList.Count > 0) then
  begin
    json.valueArray('contact');
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(json, '', elem.contactList[i]); {z - ContactDetail}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdownValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdownProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') and (elem.useContextList.Count > 0) then
  begin
    json.valueArray('useContext');
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(json, '', elem.useContextList[i]); {z - UsageContext}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') and (elem.jurisdictionList.Count > 0) then
  begin
    json.valueArray('jurisdiction');
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.jurisdictionList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdownValue(json, 'purpose', elem.purposeElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdownProps(json, 'purpose', elem.purposeElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdownValue(json, 'copyright', elem.copyrightElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdownProps(json, 'copyright', elem.copyrightElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('caseSensitive') then
    ComposeBooleanValue(json, 'caseSensitive', elem.caseSensitiveElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('caseSensitive') then
    ComposeBooleanProps(json, 'caseSensitive', elem.caseSensitiveElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('valueSet') then
    ComposeCanonicalValue(json, 'valueSet', elem.valueSetElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('valueSet') then
    ComposeCanonicalProps(json, 'valueSet', elem.valueSetElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('hierarchyMeaning') then
    ComposeEnumValue(json, 'hierarchyMeaning', elem.HierarchyMeaningElement, CODES_TFhirCodesystemHierarchyMeaningEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('hierarchyMeaning') then
    ComposeEnumProps(json, 'hierarchyMeaning', elem.HierarchyMeaningElement, CODES_TFhirCodesystemHierarchyMeaningEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('compositional') then
    ComposeBooleanValue(json, 'compositional', elem.compositionalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('compositional') then
    ComposeBooleanProps(json, 'compositional', elem.compositionalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('versionNeeded') then
    ComposeBooleanValue(json, 'versionNeeded', elem.versionNeededElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('versionNeeded') then
    ComposeBooleanProps(json, 'versionNeeded', elem.versionNeededElement, false);
  ComposeEnumValue(json, 'content', elem.ContentElement, CODES_TFhirCodesystemContentModeEnum, false);
  ComposeEnumProps(json, 'content', elem.ContentElement, CODES_TFhirCodesystemContentModeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('supplements') then
    ComposeCanonicalValue(json, 'supplements', elem.supplementsElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('supplements') then
    ComposeCanonicalProps(json, 'supplements', elem.supplementsElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('count') then
    ComposeUnsignedIntValue(json, 'count', elem.countElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('count') then
    ComposeUnsignedIntProps(json, 'count', elem.countElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('filter') and (elem.filterList.Count > 0) then
  begin
    json.valueArray('filter');
    for i := 0 to elem.filterList.Count - 1 do
      ComposeCodeSystemFilter(json, '', elem.filterList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('property_') and (elem.property_List.Count > 0) then
  begin
    json.valueArray('property');
    for i := 0 to elem.property_List.Count - 1 do
      ComposeCodeSystemProperty(json, '', elem.property_List[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('concept') and (elem.conceptList.Count > 0) then
  begin
    json.valueArray('concept');
    for i := 0 to elem.conceptList.Count - 1 do
      ComposeCodeSystemConcept(json, '', elem.conceptList[i]); {z - }
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_CODESYSTEM}
{$IFDEF FHIR_COMMUNICATION}
procedure TFHIRJsonParser.ParseCommunicationPayload(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCommunicationPayload(jsn)); {2}
end;

function TFHIRJsonParser.ParseCommunicationPayload(jsn : TJsonObject) : TFhirCommunicationPayload;
begin
  result := TFhirCommunicationPayload.create;
  try
    ParseCommunicationPayloadProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCommunicationPayloadProperties(jsn : TJsonObject; result : TFhirCommunicationPayload);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('contentAttachment') {a4} then
      result.content := ParseAttachment(jsn.vObj['contentAttachment']);
    if jsn.has('contentReference') {a3} then
      result.content := ParseReference(jsn.vObj['contentReference']);
    if jsn.has('contentString') or jsn.has('_contentString') then
      result.content := parseString(jsn.node['contentString'], jsn.vObj['_contentString']);
end;

procedure TFHIRJsonComposer.ComposeCommunicationPayload(json : TJSONWriter; name : string; elem : TFhirCommunicationPayload; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (elem.content is TFhirAttachment) then 
    ComposeAttachment(json, 'contentAttachment', TFhirAttachment(elem.content)) 
  else if (elem.content is TFhirReference) then
    ComposeReference(json, 'contentReference', TFhirReference(elem.content))
  else if (elem.content is TFhirString) then 
  begin
    ComposeStringValue(json, 'contentString', TFhirString(elem.content), false);
    ComposeStringProps(json, 'contentString', TFhirString(elem.content), false);
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseCommunication(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCommunication(jsn)); {2}
end;

function TFHIRJsonParser.ParseCommunication(jsn : TJsonObject) : TFhirCommunication;
begin
  result := TFhirCommunication.create;
  try
    ParseCommunicationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCommunicationProperties(jsn : TJsonObject; result : TFhirCommunication);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
      if jsn.has('instantiatesCanonical') or jsn.has('_instantiatesCanonical') then
      iteratePrimitiveArray(jsn.vArr['instantiatesCanonical'], jsn.vArr['_instantiatesCanonical'], result.instantiatesCanonicalList, parseCanonical);
      if jsn.has('instantiatesUri') or jsn.has('_instantiatesUri') then
      iteratePrimitiveArray(jsn.vArr['instantiatesUri'], jsn.vArr['_instantiatesUri'], result.instantiatesUriList, parseUri);
    if jsn.has('basedOn') then
      iterateArray(jsn.vArr['basedOn'], result.basedOnList, parseReference{TFhirReference});
    if jsn.has('partOf') then
      iterateArray(jsn.vArr['partOf'], result.partOfList, parseReference{TFhirReference});
    if jsn.has('inResponseTo') then
      iterateArray(jsn.vArr['inResponseTo'], result.inResponseToList, parseReference{TFhirCommunication});
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirEventStatusEnum, SYSTEMS_TFhirEventStatusEnum);
    if jsn.has('statusReason') then
        result.statusReason := ParseCodeableConcept(jsn.vObj['statusReason']);{q3}
    if jsn.has('category') then
      iterateArray(jsn.vArr['category'], result.categoryList, parseCodeableConcept);
    if jsn.has('priority') or jsn.has('_priority')  then
      result.priorityElement := parseEnum(jsn.path+'/priority', jsn.node['priority'], jsn.vObj['_priority'], CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum);
    if jsn.has('medium') then
      iterateArray(jsn.vArr['medium'], result.mediumList, parseCodeableConcept);
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirPatient}(jsn.vObj['subject']);{q3}
    if jsn.has('topic') then
        result.topic := ParseCodeableConcept(jsn.vObj['topic']);{q3}
    if jsn.has('about') then
      iterateArray(jsn.vArr['about'], result.aboutList, parseReference{TFhirReference});
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q3}
    if jsn.has('sent') or jsn.has('_sent') then
        result.sentElement := parseDateTime(jsn.node['sent'], jsn.vObj['_sent']);{q}
    if jsn.has('received') or jsn.has('_received') then
        result.receivedElement := parseDateTime(jsn.node['received'], jsn.vObj['_received']);{q}
    if jsn.has('recipient') then
      iterateArray(jsn.vArr['recipient'], result.recipientList, parseReference{TFhirDevice});
    if jsn.has('sender') then
        result.sender := ParseReference{TFhirDevice}(jsn.vObj['sender']);{q3}
    if jsn.has('reasonCode') then
      iterateArray(jsn.vArr['reasonCode'], result.reasonCodeList, parseCodeableConcept);
    if jsn.has('reasonReference') then
      iterateArray(jsn.vArr['reasonReference'], result.reasonReferenceList, parseReference{TFhirCondition});
    if jsn.has('payload') then
      iterateArray(jsn.vArr['payload'], result.payloadList, parseCommunicationPayload);
    if jsn.has('note') then
      iterateArray(jsn.vArr['note'], result.noteList, parseAnnotation);
end;

procedure TFHIRJsonComposer.ComposeCommunication(json : TJSONWriter; name : string; elem : TFhirCommunication; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('instantiatesCanonical') and (elem.instantiatesCanonicalList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.instantiatesCanonicalList.Count - 1 do
    begin
      ext := ext or ((elem.instantiatesCanonicalList[i].id <> '') or (elem.instantiatesCanonicalList[i].hasExtensionList) {no-comments or (elem.instantiatesCanonicalList[i].hasComments)});
      val := val or (elem.instantiatesCanonicalList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('instantiatesCanonical');
      for i := 0 to elem.instantiatesCanonicalList.Count - 1 do
        ComposeCanonicalValue(json, '',elem.instantiatesCanonicalList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_instantiatesCanonical');
      for i := 0 to elem.instantiatesCanonicalList.Count - 1 do
        ComposeCanonicalProps(json, '',elem.instantiatesCanonicalList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('instantiatesUri') and (elem.instantiatesUriList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.instantiatesUriList.Count - 1 do
    begin
      ext := ext or ((elem.instantiatesUriList[i].id <> '') or (elem.instantiatesUriList[i].hasExtensionList) {no-comments or (elem.instantiatesUriList[i].hasComments)});
      val := val or (elem.instantiatesUriList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('instantiatesUri');
      for i := 0 to elem.instantiatesUriList.Count - 1 do
        ComposeUriValue(json, '',elem.instantiatesUriList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_instantiatesUri');
      for i := 0 to elem.instantiatesUriList.Count - 1 do
        ComposeUriProps(json, '',elem.instantiatesUriList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('basedOn') and (elem.basedOnList.Count > 0) then
  begin
    json.valueArray('basedOn');
    for i := 0 to elem.basedOnList.Count - 1 do
      ComposeReference{TFhirReference}(json, '', elem.basedOnList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('partOf') and (elem.partOfList.Count > 0) then
  begin
    json.valueArray('partOf');
    for i := 0 to elem.partOfList.Count - 1 do
      ComposeReference{TFhirReference}(json, '', elem.partOfList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('inResponseTo') and (elem.inResponseToList.Count > 0) then
  begin
    json.valueArray('inResponseTo');
    for i := 0 to elem.inResponseToList.Count - 1 do
      ComposeReference{TFhirCommunication}(json, '', elem.inResponseToList[i]); {z - Reference(Communication)}
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirEventStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirEventStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('statusReason') then
    ComposeCodeableConcept(json, 'statusReason', elem.statusReason); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('category') and (elem.categoryList.Count > 0) then
  begin
    json.valueArray('category');
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.categoryList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('priority') then
    ComposeEnumValue(json, 'priority', elem.PriorityElement, CODES_TFhirRequestPriorityEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('priority') then
    ComposeEnumProps(json, 'priority', elem.PriorityElement, CODES_TFhirRequestPriorityEnum, false);
  if (SummaryOption in [soFull, soData]) and doCompose('medium') and (elem.mediumList.Count > 0) then
  begin
    json.valueArray('medium');
    for i := 0 to elem.mediumList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.mediumList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{TFhirPatient}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('topic') then
    ComposeCodeableConcept(json, 'topic', elem.topic); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('about') and (elem.aboutList.Count > 0) then
  begin
    json.valueArray('about');
    for i := 0 to elem.aboutList.Count - 1 do
      ComposeReference{TFhirReference}(json, '', elem.aboutList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('sent') then
    ComposeDateTimeValue(json, 'sent', elem.sentElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('sent') then
    ComposeDateTimeProps(json, 'sent', elem.sentElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('received') then
    ComposeDateTimeValue(json, 'received', elem.receivedElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('received') then
    ComposeDateTimeProps(json, 'received', elem.receivedElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('recipient') and (elem.recipientList.Count > 0) then
  begin
    json.valueArray('recipient');
    for i := 0 to elem.recipientList.Count - 1 do
      ComposeReference{TFhirDevice}(json, '', elem.recipientList[i]); {z - Reference(Device)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('sender') then
    ComposeReference{TFhirDevice}(json, 'sender', elem.sender); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonCode') and (elem.reasonCodeList.Count > 0) then
  begin
    json.valueArray('reasonCode');
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.reasonCodeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonReference') and (elem.reasonReferenceList.Count > 0) then
  begin
    json.valueArray('reasonReference');
    for i := 0 to elem.reasonReferenceList.Count - 1 do
      ComposeReference{TFhirCondition}(json, '', elem.reasonReferenceList[i]); {z - Reference(Condition)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('payload') and (elem.payloadList.Count > 0) then
  begin
    json.valueArray('payload');
    for i := 0 to elem.payloadList.Count - 1 do
      ComposeCommunicationPayload(json, '', elem.payloadList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('note') and (elem.noteList.Count > 0) then
  begin
    json.valueArray('note');
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(json, '', elem.noteList[i]); {z - Annotation}
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_COMMUNICATION}
{$IFDEF FHIR_COMMUNICATIONREQUEST}
procedure TFHIRJsonParser.ParseCommunicationRequestPayload(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCommunicationRequestPayload(jsn)); {2}
end;

function TFHIRJsonParser.ParseCommunicationRequestPayload(jsn : TJsonObject) : TFhirCommunicationRequestPayload;
begin
  result := TFhirCommunicationRequestPayload.create;
  try
    ParseCommunicationRequestPayloadProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCommunicationRequestPayloadProperties(jsn : TJsonObject; result : TFhirCommunicationRequestPayload);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('contentAttachment') {a4} then
      result.content := ParseAttachment(jsn.vObj['contentAttachment']);
    if jsn.has('contentReference') {a3} then
      result.content := ParseReference(jsn.vObj['contentReference']);
    if jsn.has('contentString') or jsn.has('_contentString') then
      result.content := parseString(jsn.node['contentString'], jsn.vObj['_contentString']);
end;

procedure TFHIRJsonComposer.ComposeCommunicationRequestPayload(json : TJSONWriter; name : string; elem : TFhirCommunicationRequestPayload; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (elem.content is TFhirAttachment) then 
    ComposeAttachment(json, 'contentAttachment', TFhirAttachment(elem.content)) 
  else if (elem.content is TFhirReference) then
    ComposeReference(json, 'contentReference', TFhirReference(elem.content))
  else if (elem.content is TFhirString) then 
  begin
    ComposeStringValue(json, 'contentString', TFhirString(elem.content), false);
    ComposeStringProps(json, 'contentString', TFhirString(elem.content), false);
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseCommunicationRequest(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCommunicationRequest(jsn)); {2}
end;

function TFHIRJsonParser.ParseCommunicationRequest(jsn : TJsonObject) : TFhirCommunicationRequest;
begin
  result := TFhirCommunicationRequest.create;
  try
    ParseCommunicationRequestProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCommunicationRequestProperties(jsn : TJsonObject; result : TFhirCommunicationRequest);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('basedOn') then
      iterateArray(jsn.vArr['basedOn'], result.basedOnList, parseReference{TFhirReference});
    if jsn.has('replaces') then
      iterateArray(jsn.vArr['replaces'], result.replacesList, parseReference{TFhirCommunicationRequest});
    if jsn.has('groupIdentifier') then
        result.groupIdentifier := ParseIdentifier(jsn.vObj['groupIdentifier']);{q3}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirRequestStatusEnum, SYSTEMS_TFhirRequestStatusEnum);
    if jsn.has('statusReason') then
        result.statusReason := ParseCodeableConcept(jsn.vObj['statusReason']);{q3}
    if jsn.has('category') then
      iterateArray(jsn.vArr['category'], result.categoryList, parseCodeableConcept);
    if jsn.has('priority') or jsn.has('_priority')  then
      result.priorityElement := parseEnum(jsn.path+'/priority', jsn.node['priority'], jsn.vObj['_priority'], CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum);
    if jsn.has('doNotPerform') or jsn.has('_doNotPerform') then
        result.doNotPerformElement := parseBoolean(jsn.node['doNotPerform'], jsn.vObj['_doNotPerform']);{q}
    if jsn.has('medium') then
      iterateArray(jsn.vArr['medium'], result.mediumList, parseCodeableConcept);
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirPatient}(jsn.vObj['subject']);{q3}
    if jsn.has('about') then
      iterateArray(jsn.vArr['about'], result.aboutList, parseReference{TFhirReference});
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q3}
    if jsn.has('payload') then
      iterateArray(jsn.vArr['payload'], result.payloadList, parseCommunicationRequestPayload);
    if jsn.has('occurrencePeriod') {a4} then
      result.occurrence := ParsePeriod(jsn.vObj['occurrencePeriod']);
    if jsn.has('occurrenceDateTime') or jsn.has('_occurrenceDateTime') then
      result.occurrence := parseDateTime(jsn.node['occurrenceDateTime'], jsn.vObj['_occurrenceDateTime']);
    if jsn.has('authoredOn') or jsn.has('_authoredOn') then
        result.authoredOnElement := parseDateTime(jsn.node['authoredOn'], jsn.vObj['_authoredOn']);{q}
    if jsn.has('requester') then
        result.requester := ParseReference{TFhirPractitioner}(jsn.vObj['requester']);{q3}
    if jsn.has('recipient') then
      iterateArray(jsn.vArr['recipient'], result.recipientList, parseReference{TFhirDevice});
    if jsn.has('sender') then
        result.sender := ParseReference{TFhirDevice}(jsn.vObj['sender']);{q3}
    if jsn.has('reasonCode') then
      iterateArray(jsn.vArr['reasonCode'], result.reasonCodeList, parseCodeableConcept);
    if jsn.has('reasonReference') then
      iterateArray(jsn.vArr['reasonReference'], result.reasonReferenceList, parseReference{TFhirCondition});
    if jsn.has('note') then
      iterateArray(jsn.vArr['note'], result.noteList, parseAnnotation);
end;

procedure TFHIRJsonComposer.ComposeCommunicationRequest(json : TJSONWriter; name : string; elem : TFhirCommunicationRequest; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('basedOn') and (elem.basedOnList.Count > 0) then
  begin
    json.valueArray('basedOn');
    for i := 0 to elem.basedOnList.Count - 1 do
      ComposeReference{TFhirReference}(json, '', elem.basedOnList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('replaces') and (elem.replacesList.Count > 0) then
  begin
    json.valueArray('replaces');
    for i := 0 to elem.replacesList.Count - 1 do
      ComposeReference{TFhirCommunicationRequest}(json, '', elem.replacesList[i]); {z - Reference(CommunicationRequest)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('groupIdentifier') then
    ComposeIdentifier(json, 'groupIdentifier', elem.groupIdentifier); {a}
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirRequestStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirRequestStatusEnum, false);
  if (SummaryOption in [soFull, soData]) and doCompose('statusReason') then
    ComposeCodeableConcept(json, 'statusReason', elem.statusReason); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('category') and (elem.categoryList.Count > 0) then
  begin
    json.valueArray('category');
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.categoryList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('priority') then
    ComposeEnumValue(json, 'priority', elem.PriorityElement, CODES_TFhirRequestPriorityEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('priority') then
    ComposeEnumProps(json, 'priority', elem.PriorityElement, CODES_TFhirRequestPriorityEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('doNotPerform') then
    ComposeBooleanValue(json, 'doNotPerform', elem.doNotPerformElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('doNotPerform') then
    ComposeBooleanProps(json, 'doNotPerform', elem.doNotPerformElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('medium') and (elem.mediumList.Count > 0) then
  begin
    json.valueArray('medium');
    for i := 0 to elem.mediumList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.mediumList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('subject') then
    ComposeReference{TFhirPatient}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('about') and (elem.aboutList.Count > 0) then
  begin
    json.valueArray('about');
    for i := 0 to elem.aboutList.Count - 1 do
      ComposeReference{TFhirReference}(json, '', elem.aboutList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('payload') and (elem.payloadList.Count > 0) then
  begin
    json.valueArray('payload');
    for i := 0 to elem.payloadList.Count - 1 do
      ComposeCommunicationRequestPayload(json, '', elem.payloadList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirPeriod) then 
    ComposePeriod(json, 'occurrencePeriod', TFhirPeriod(elem.occurrence)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'occurrenceDateTime', TFhirDateTime(elem.occurrence), false);
    ComposeDateTimeProps(json, 'occurrenceDateTime', TFhirDateTime(elem.occurrence), false);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('authoredOn') then
    ComposeDateTimeValue(json, 'authoredOn', elem.authoredOnElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('authoredOn') then
    ComposeDateTimeProps(json, 'authoredOn', elem.authoredOnElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requester') then
    ComposeReference{TFhirPractitioner}(json, 'requester', elem.requester); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('recipient') and (elem.recipientList.Count > 0) then
  begin
    json.valueArray('recipient');
    for i := 0 to elem.recipientList.Count - 1 do
      ComposeReference{TFhirDevice}(json, '', elem.recipientList[i]); {z - Reference(Device)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('sender') then
    ComposeReference{TFhirDevice}(json, 'sender', elem.sender); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonCode') and (elem.reasonCodeList.Count > 0) then
  begin
    json.valueArray('reasonCode');
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.reasonCodeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonReference') and (elem.reasonReferenceList.Count > 0) then
  begin
    json.valueArray('reasonReference');
    for i := 0 to elem.reasonReferenceList.Count - 1 do
      ComposeReference{TFhirCondition}(json, '', elem.reasonReferenceList[i]); {z - Reference(Condition)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('note') and (elem.noteList.Count > 0) then
  begin
    json.valueArray('note');
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(json, '', elem.noteList[i]); {z - Annotation}
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_COMMUNICATIONREQUEST}
{$IFDEF FHIR_COMPARTMENTDEFINITION}
procedure TFHIRJsonParser.ParseCompartmentDefinitionResource(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCompartmentDefinitionResource(jsn)); {2}
end;

function TFHIRJsonParser.ParseCompartmentDefinitionResource(jsn : TJsonObject) : TFhirCompartmentDefinitionResource;
begin
  result := TFhirCompartmentDefinitionResource.create;
  try
    ParseCompartmentDefinitionResourceProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCompartmentDefinitionResourceProperties(jsn : TJsonObject; result : TFhirCompartmentDefinitionResource);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') or jsn.has('_code')  then
      result.codeElement := parseEnum(jsn.path+'/code', jsn.node['code'], jsn.vObj['_code'], CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum);
      if jsn.has('param') or jsn.has('_param') then
      iteratePrimitiveArray(jsn.vArr['param'], jsn.vArr['_param'], result.paramList, parseString);
    if jsn.has('documentation') or jsn.has('_documentation') then
        result.documentationElement := parseString(jsn.node['documentation'], jsn.vObj['_documentation']);{q}
end;

procedure TFHIRJsonComposer.ComposeCompartmentDefinitionResource(json : TJSONWriter; name : string; elem : TFhirCompartmentDefinitionResource; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'code', elem.CodeElement, CODES_TFhirResourceTypesEnum, false);
  ComposeEnumProps(json, 'code', elem.CodeElement, CODES_TFhirResourceTypesEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.paramList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.paramList.Count - 1 do
    begin
      ext := ext or ((elem.paramList[i].id <> '') or (elem.paramList[i].hasExtensionList) {no-comments or (elem.paramList[i].hasComments)});
      val := val or (elem.paramList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('param');
      for i := 0 to elem.paramList.Count - 1 do
        ComposeStringValue(json, '',elem.paramList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_param');
      for i := 0 to elem.paramList.Count - 1 do
        ComposeStringProps(json, '',elem.paramList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'documentation', elem.documentationElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'documentation', elem.documentationElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseCompartmentDefinition(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCompartmentDefinition(jsn)); {2}
end;

function TFHIRJsonParser.ParseCompartmentDefinition(jsn : TJsonObject) : TFhirCompartmentDefinition;
begin
  result := TFhirCompartmentDefinition.create;
  try
    ParseCompartmentDefinitionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCompartmentDefinitionProperties(jsn : TJsonObject; result : TFhirCompartmentDefinition);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := parseUri(jsn.node['url'], jsn.vObj['_url']);{q}
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := parseString(jsn.node['version'], jsn.vObj['_version']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    if jsn.has('experimental') or jsn.has('_experimental') then
        result.experimentalElement := parseBoolean(jsn.node['experimental'], jsn.vObj['_experimental']);{q}
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := parseDateTime(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('publisher') or jsn.has('_publisher') then
        result.publisherElement := parseString(jsn.node['publisher'], jsn.vObj['_publisher']);{q}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseContactDetail);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseMarkdown(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('useContext') then
      iterateArray(jsn.vArr['useContext'], result.useContextList, parseUsageContext);
    if jsn.has('purpose') or jsn.has('_purpose') then
        result.purposeElement := parseMarkdown(jsn.node['purpose'], jsn.vObj['_purpose']);{q}
    if jsn.has('code') or jsn.has('_code')  then
      result.codeElement := parseEnum(jsn.path+'/code', jsn.node['code'], jsn.vObj['_code'], CODES_TFhirCompartmentTypeEnum, SYSTEMS_TFhirCompartmentTypeEnum);
    if jsn.has('search') or jsn.has('_search') then
        result.searchElement := parseBoolean(jsn.node['search'], jsn.vObj['_search']);{q}
    if jsn.has('resource') then
      iterateArray(jsn.vArr['resource'], result.resourceList, parseCompartmentDefinitionResource);
end;

procedure TFHIRJsonComposer.ComposeCompartmentDefinition(json : TJSONWriter; name : string; elem : TFhirCompartmentDefinition; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  ComposeUriValue(json, 'url', elem.urlElement, false);
  ComposeUriProps(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeStringValue(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeStringProps(json, 'version', elem.versionElement, false);
  ComposeStringValue(json, 'name', elem.nameElement, false);
  ComposeStringProps(json, 'name', elem.nameElement, false);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBooleanValue(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBooleanProps(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringValue(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringProps(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') and (elem.contactList.Count > 0) then
  begin
    json.valueArray('contact');
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(json, '', elem.contactList[i]); {z - ContactDetail}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdownValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdownProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') and (elem.useContextList.Count > 0) then
  begin
    json.valueArray('useContext');
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(json, '', elem.useContextList[i]); {z - UsageContext}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdownValue(json, 'purpose', elem.purposeElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdownProps(json, 'purpose', elem.purposeElement, false);
  ComposeEnumValue(json, 'code', elem.CodeElement, CODES_TFhirCompartmentTypeEnum, false);
  ComposeEnumProps(json, 'code', elem.CodeElement, CODES_TFhirCompartmentTypeEnum, false);
  ComposeBooleanValue(json, 'search', elem.searchElement, false);
  ComposeBooleanProps(json, 'search', elem.searchElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('resource') and (elem.resourceList.Count > 0) then
  begin
    json.valueArray('resource');
    for i := 0 to elem.resourceList.Count - 1 do
      ComposeCompartmentDefinitionResource(json, '', elem.resourceList[i]); {z - }
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_COMPARTMENTDEFINITION}
{$IFDEF FHIR_COMPOSITION}
procedure TFHIRJsonParser.ParseCompositionAttester(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCompositionAttester(jsn)); {2}
end;

function TFHIRJsonParser.ParseCompositionAttester(jsn : TJsonObject) : TFhirCompositionAttester;
begin
  result := TFhirCompositionAttester.create;
  try
    ParseCompositionAttesterProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCompositionAttesterProperties(jsn : TJsonObject; result : TFhirCompositionAttester);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('mode') or jsn.has('_mode')  then
      result.modeElement := parseEnum(jsn.path+'/mode', jsn.node['mode'], jsn.vObj['_mode'], CODES_TFhirCompositionAttestationModeEnum, SYSTEMS_TFhirCompositionAttestationModeEnum);
    if jsn.has('time') or jsn.has('_time') then
        result.timeElement := parseDateTime(jsn.node['time'], jsn.vObj['_time']);{q}
    if jsn.has('party') then
        result.party := ParseReference{TFhirPatient}(jsn.vObj['party']);{q3}
end;

procedure TFHIRJsonComposer.ComposeCompositionAttester(json : TJSONWriter; name : string; elem : TFhirCompositionAttester; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'mode', elem.ModeElement, CODES_TFhirCompositionAttestationModeEnum, false);
  ComposeEnumProps(json, 'mode', elem.ModeElement, CODES_TFhirCompositionAttestationModeEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTimeValue(json, 'time', elem.timeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTimeProps(json, 'time', elem.timeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirPatient}(json, 'party', elem.party); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseCompositionRelatesTo(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCompositionRelatesTo(jsn)); {2}
end;

function TFHIRJsonParser.ParseCompositionRelatesTo(jsn : TJsonObject) : TFhirCompositionRelatesTo;
begin
  result := TFhirCompositionRelatesTo.create;
  try
    ParseCompositionRelatesToProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCompositionRelatesToProperties(jsn : TJsonObject; result : TFhirCompositionRelatesTo);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') or jsn.has('_code')  then
      result.codeElement := parseEnum(jsn.path+'/code', jsn.node['code'], jsn.vObj['_code'], CODES_TFhirDocumentRelationshipTypeEnum, SYSTEMS_TFhirDocumentRelationshipTypeEnum);
    if jsn.has('targetIdentifier') {a4} then
      result.target := ParseIdentifier(jsn.vObj['targetIdentifier']);
    if jsn.has('targetReference') {a3} then
      result.target := ParseReference(jsn.vObj['targetReference']);
end;

procedure TFHIRJsonComposer.ComposeCompositionRelatesTo(json : TJSONWriter; name : string; elem : TFhirCompositionRelatesTo; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'code', elem.CodeElement, CODES_TFhirDocumentRelationshipTypeEnum, false);
  ComposeEnumProps(json, 'code', elem.CodeElement, CODES_TFhirDocumentRelationshipTypeEnum, false);
  if (elem.target is TFhirIdentifier) then 
    ComposeIdentifier(json, 'targetIdentifier', TFhirIdentifier(elem.target)) 
  else if (elem.target is TFhirReference) then
    ComposeReference(json, 'targetReference', TFhirReference(elem.target));
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseCompositionEvent(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCompositionEvent(jsn)); {2}
end;

function TFHIRJsonParser.ParseCompositionEvent(jsn : TJsonObject) : TFhirCompositionEvent;
begin
  result := TFhirCompositionEvent.create;
  try
    ParseCompositionEventProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCompositionEventProperties(jsn : TJsonObject; result : TFhirCompositionEvent);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
      iterateArray(jsn.vArr['code'], result.codeList, parseCodeableConcept);
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q3}
    if jsn.has('detail') then
      iterateArray(jsn.vArr['detail'], result.detailList, parseReference{TFhirReference});
end;

procedure TFHIRJsonComposer.ComposeCompositionEvent(json : TJSONWriter; name : string; elem : TFhirCompositionEvent; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.codeList.Count > 0) then
  begin
    json.valueArray('code');
    for i := 0 to elem.codeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.codeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(json, 'period', elem.period); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.detailList.Count > 0) then
  begin
    json.valueArray('detail');
    for i := 0 to elem.detailList.Count - 1 do
      ComposeReference{TFhirReference}(json, '', elem.detailList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseCompositionSection(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCompositionSection(jsn)); {2}
end;

function TFHIRJsonParser.ParseCompositionSection(jsn : TJsonObject) : TFhirCompositionSection;
begin
  result := TFhirCompositionSection.create;
  try
    ParseCompositionSectionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCompositionSectionProperties(jsn : TJsonObject; result : TFhirCompositionSection);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('title') or jsn.has('_title') then
        result.titleElement := parseString(jsn.node['title'], jsn.vObj['_title']);{q}
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('author') then
      iterateArray(jsn.vArr['author'], result.authorList, parseReference{TFhirPractitioner});
    if jsn.has('focus') then
        result.focus := ParseReference{TFhirReference}(jsn.vObj['focus']);{q3}
    if jsn.has('text') then
        result.text := ParseNarrative(jsn.vObj['text']);{q3}
    if jsn.has('mode') or jsn.has('_mode')  then
      result.modeElement := parseEnum(jsn.path+'/mode', jsn.node['mode'], jsn.vObj['_mode'], CODES_TFhirListModeEnum, SYSTEMS_TFhirListModeEnum);
    if jsn.has('orderedBy') then
        result.orderedBy := ParseCodeableConcept(jsn.vObj['orderedBy']);{q3}
    if jsn.has('entry') then
      iterateArray(jsn.vArr['entry'], result.entryList, parseReference{TFhirReference});
    if jsn.has('emptyReason') then
        result.emptyReason := ParseCodeableConcept(jsn.vObj['emptyReason']);{q3}
    if jsn.has('section') then
      iterateArray(jsn.vArr['section'], result.sectionList, parseCompositionSection);
end;

procedure TFHIRJsonComposer.ComposeCompositionSection(json : TJSONWriter; name : string; elem : TFhirCompositionSection; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soData]) and (elem.authorList.Count > 0) then
  begin
    json.valueArray('author');
    for i := 0 to elem.authorList.Count - 1 do
      ComposeReference{TFhirPractitioner}(json, '', elem.authorList[i]); {z - Reference(Practitioner)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirReference}(json, 'focus', elem.focus); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeNarrative(json, 'text', elem.text); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumValue(json, 'mode', elem.ModeElement, CODES_TFhirListModeEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumProps(json, 'mode', elem.ModeElement, CODES_TFhirListModeEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'orderedBy', elem.orderedBy); {a}
  if (SummaryOption in [soFull, soData]) and (elem.entryList.Count > 0) then
  begin
    json.valueArray('entry');
    for i := 0 to elem.entryList.Count - 1 do
      ComposeReference{TFhirReference}(json, '', elem.entryList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'emptyReason', elem.emptyReason); {a}
  if (SummaryOption in [soFull, soData]) and (elem.sectionList.Count > 0) then
  begin
    json.valueArray('section');
    for i := 0 to elem.sectionList.Count - 1 do
      ComposeCompositionSection(json, '', elem.sectionList[i]); {z - @Composition.section}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseComposition(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseComposition(jsn)); {2}
end;

function TFHIRJsonParser.ParseComposition(jsn : TJsonObject) : TFhirComposition;
begin
  result := TFhirComposition.create;
  try
    ParseCompositionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCompositionProperties(jsn : TJsonObject; result : TFhirComposition);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q3}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirCompositionStatusEnum, SYSTEMS_TFhirCompositionStatusEnum);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('category') then
      iterateArray(jsn.vArr['category'], result.categoryList, parseCodeableConcept);
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirReference}(jsn.vObj['subject']);{q3}
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q3}
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := parseDateTime(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('author') then
      iterateArray(jsn.vArr['author'], result.authorList, parseReference{TFhirPractitioner});
    if jsn.has('title') or jsn.has('_title') then
        result.titleElement := parseString(jsn.node['title'], jsn.vObj['_title']);{q}
    if jsn.has('confidentiality') or jsn.has('_confidentiality')  then
      result.confidentialityElement := parseEnum(jsn.path+'/confidentiality', jsn.node['confidentiality'], jsn.vObj['_confidentiality'], CODES_TFhirV3ConfidentialityClassificationEnum, SYSTEMS_TFhirV3ConfidentialityClassificationEnum);
    if jsn.has('attester') then
      iterateArray(jsn.vArr['attester'], result.attesterList, parseCompositionAttester);
    if jsn.has('custodian') then
        result.custodian := ParseReference{TFhirOrganization}(jsn.vObj['custodian']);{q3}
    if jsn.has('relatesTo') then
      iterateArray(jsn.vArr['relatesTo'], result.relatesToList, parseCompositionRelatesTo);
    if jsn.has('event') then
      iterateArray(jsn.vArr['event'], result.eventList, parseCompositionEvent);
    if jsn.has('section') then
      iterateArray(jsn.vArr['section'], result.sectionList, parseCompositionSection);
end;

procedure TFHIRJsonComposer.ComposeComposition(json : TJSONWriter; name : string; elem : TFhirComposition; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirCompositionStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirCompositionStatusEnum, false);
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') and (elem.categoryList.Count > 0) then
  begin
    json.valueArray('category');
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.categoryList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{TFhirReference}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (elem.authorList.Count > 0) then
  begin
    json.valueArray('author');
    for i := 0 to elem.authorList.Count - 1 do
      ComposeReference{TFhirPractitioner}(json, '', elem.authorList[i]); {z - Reference(Practitioner)}
    json.FinishArray;
  end;
  ComposeStringValue(json, 'title', elem.titleElement, false);
  ComposeStringProps(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('confidentiality') then
    ComposeEnumValue(json, 'confidentiality', elem.ConfidentialityElement, CODES_TFhirV3ConfidentialityClassificationEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('confidentiality') then
    ComposeEnumProps(json, 'confidentiality', elem.ConfidentialityElement, CODES_TFhirV3ConfidentialityClassificationEnum, false);
  if (SummaryOption in [soFull, soData]) and doCompose('attester') and (elem.attesterList.Count > 0) then
  begin
    json.valueArray('attester');
    for i := 0 to elem.attesterList.Count - 1 do
      ComposeCompositionAttester(json, '', elem.attesterList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('custodian') then
    ComposeReference{TFhirOrganization}(json, 'custodian', elem.custodian); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('relatesTo') and (elem.relatesToList.Count > 0) then
  begin
    json.valueArray('relatesTo');
    for i := 0 to elem.relatesToList.Count - 1 do
      ComposeCompositionRelatesTo(json, '', elem.relatesToList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('event') and (elem.eventList.Count > 0) then
  begin
    json.valueArray('event');
    for i := 0 to elem.eventList.Count - 1 do
      ComposeCompositionEvent(json, '', elem.eventList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('section') and (elem.sectionList.Count > 0) then
  begin
    json.valueArray('section');
    for i := 0 to elem.sectionList.Count - 1 do
      ComposeCompositionSection(json, '', elem.sectionList[i]); {z - }
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_COMPOSITION}
{$IFDEF FHIR_CONCEPTMAP}
procedure TFHIRJsonParser.ParseConceptMapGroup(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConceptMapGroup(jsn)); {2}
end;

function TFHIRJsonParser.ParseConceptMapGroup(jsn : TJsonObject) : TFhirConceptMapGroup;
begin
  result := TFhirConceptMapGroup.create;
  try
    ParseConceptMapGroupProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseConceptMapGroupProperties(jsn : TJsonObject; result : TFhirConceptMapGroup);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('source') or jsn.has('_source') then
        result.sourceElement := parseUri(jsn.node['source'], jsn.vObj['_source']);{q}
    if jsn.has('sourceVersion') or jsn.has('_sourceVersion') then
        result.sourceVersionElement := parseString(jsn.node['sourceVersion'], jsn.vObj['_sourceVersion']);{q}
    if jsn.has('target') or jsn.has('_target') then
        result.targetElement := parseUri(jsn.node['target'], jsn.vObj['_target']);{q}
    if jsn.has('targetVersion') or jsn.has('_targetVersion') then
        result.targetVersionElement := parseString(jsn.node['targetVersion'], jsn.vObj['_targetVersion']);{q}
    if jsn.has('element') then
      iterateArray(jsn.vArr['element'], result.elementList, parseConceptMapGroupElement);
    if jsn.has('unmapped') then
        result.unmapped := ParseConceptMapGroupUnmapped(jsn.vObj['unmapped']);{q3}
end;

procedure TFHIRJsonComposer.ComposeConceptMapGroup(json : TJSONWriter; name : string; elem : TFhirConceptMapGroup; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeUriValue(json, 'source', elem.sourceElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeUriProps(json, 'source', elem.sourceElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'sourceVersion', elem.sourceVersionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'sourceVersion', elem.sourceVersionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeUriValue(json, 'target', elem.targetElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeUriProps(json, 'target', elem.targetElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'targetVersion', elem.targetVersionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'targetVersion', elem.targetVersionElement, false);
  if (elem.elementList.Count > 0) then
  begin
    json.valueArray('element');
    for i := 0 to elem.elementList.Count - 1 do
      ComposeConceptMapGroupElement(json, '', elem.elementList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeConceptMapGroupUnmapped(json, 'unmapped', elem.unmapped); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseConceptMapGroupElement(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConceptMapGroupElement(jsn)); {2}
end;

function TFHIRJsonParser.ParseConceptMapGroupElement(jsn : TJsonObject) : TFhirConceptMapGroupElement;
begin
  result := TFhirConceptMapGroupElement.create;
  try
    ParseConceptMapGroupElementProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseConceptMapGroupElementProperties(jsn : TJsonObject; result : TFhirConceptMapGroupElement);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') or jsn.has('_code') then
        result.codeElement := parseCode(jsn.node['code'], jsn.vObj['_code']);{q}
    if jsn.has('display') or jsn.has('_display') then
        result.displayElement := parseString(jsn.node['display'], jsn.vObj['_display']);{q}
    if jsn.has('target') then
      iterateArray(jsn.vArr['target'], result.targetList, parseConceptMapGroupElementTarget);
end;

procedure TFHIRJsonComposer.ComposeConceptMapGroupElement(json : TJSONWriter; name : string; elem : TFhirConceptMapGroupElement; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeValue(json, 'code', elem.codeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeProps(json, 'code', elem.codeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'display', elem.displayElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'display', elem.displayElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.targetList.Count > 0) then
  begin
    json.valueArray('target');
    for i := 0 to elem.targetList.Count - 1 do
      ComposeConceptMapGroupElementTarget(json, '', elem.targetList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseConceptMapGroupElementTarget(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConceptMapGroupElementTarget(jsn)); {2}
end;

function TFHIRJsonParser.ParseConceptMapGroupElementTarget(jsn : TJsonObject) : TFhirConceptMapGroupElementTarget;
begin
  result := TFhirConceptMapGroupElementTarget.create;
  try
    ParseConceptMapGroupElementTargetProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseConceptMapGroupElementTargetProperties(jsn : TJsonObject; result : TFhirConceptMapGroupElementTarget);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') or jsn.has('_code') then
        result.codeElement := parseCode(jsn.node['code'], jsn.vObj['_code']);{q}
    if jsn.has('display') or jsn.has('_display') then
        result.displayElement := parseString(jsn.node['display'], jsn.vObj['_display']);{q}
    if jsn.has('equivalence') or jsn.has('_equivalence')  then
      result.equivalenceElement := parseEnum(jsn.path+'/equivalence', jsn.node['equivalence'], jsn.vObj['_equivalence'], CODES_TFhirConceptMapEquivalenceEnum, SYSTEMS_TFhirConceptMapEquivalenceEnum);
    if jsn.has('comment') or jsn.has('_comment') then
        result.commentElement := parseString(jsn.node['comment'], jsn.vObj['_comment']);{q}
    if jsn.has('dependsOn') then
      iterateArray(jsn.vArr['dependsOn'], result.dependsOnList, parseConceptMapGroupElementTargetDependsOn);
    if jsn.has('product') then
      iterateArray(jsn.vArr['product'], result.productList, parseConceptMapGroupElementTargetDependsOn);
end;

procedure TFHIRJsonComposer.ComposeConceptMapGroupElementTarget(json : TJSONWriter; name : string; elem : TFhirConceptMapGroupElementTarget; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeValue(json, 'code', elem.codeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeProps(json, 'code', elem.codeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'display', elem.displayElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'display', elem.displayElement, false);
  ComposeEnumValue(json, 'equivalence', elem.EquivalenceElement, CODES_TFhirConceptMapEquivalenceEnum, false);
  ComposeEnumProps(json, 'equivalence', elem.EquivalenceElement, CODES_TFhirConceptMapEquivalenceEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'comment', elem.commentElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'comment', elem.commentElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.dependsOnList.Count > 0) then
  begin
    json.valueArray('dependsOn');
    for i := 0 to elem.dependsOnList.Count - 1 do
      ComposeConceptMapGroupElementTargetDependsOn(json, '', elem.dependsOnList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.productList.Count > 0) then
  begin
    json.valueArray('product');
    for i := 0 to elem.productList.Count - 1 do
      ComposeConceptMapGroupElementTargetDependsOn(json, '', elem.productList[i]); {z - @ConceptMap.group.element.target.dependsOn}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseConceptMapGroupElementTargetDependsOn(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConceptMapGroupElementTargetDependsOn(jsn)); {2}
end;

function TFHIRJsonParser.ParseConceptMapGroupElementTargetDependsOn(jsn : TJsonObject) : TFhirConceptMapGroupElementTargetDependsOn;
begin
  result := TFhirConceptMapGroupElementTargetDependsOn.create;
  try
    ParseConceptMapGroupElementTargetDependsOnProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseConceptMapGroupElementTargetDependsOnProperties(jsn : TJsonObject; result : TFhirConceptMapGroupElementTargetDependsOn);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('property') or jsn.has('_property') then
        result.property_Element := parseUri(jsn.node['property'], jsn.vObj['_property']);{q}
    if jsn.has('system') or jsn.has('_system') then
        result.systemElement := parseCanonical(jsn.node['system'], jsn.vObj['_system']);{q}
    if jsn.has('value') or jsn.has('_value') then
        result.valueElement := parseString(jsn.node['value'], jsn.vObj['_value']);{q}
    if jsn.has('display') or jsn.has('_display') then
        result.displayElement := parseString(jsn.node['display'], jsn.vObj['_display']);{q}
end;

procedure TFHIRJsonComposer.ComposeConceptMapGroupElementTargetDependsOn(json : TJSONWriter; name : string; elem : TFhirConceptMapGroupElementTargetDependsOn; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeUriValue(json, 'property', elem.property_Element, false);
  ComposeUriProps(json, 'property', elem.property_Element, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonicalValue(json, 'system', elem.systemElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonicalProps(json, 'system', elem.systemElement, false);
  ComposeStringValue(json, 'value', elem.valueElement, false);
  ComposeStringProps(json, 'value', elem.valueElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'display', elem.displayElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'display', elem.displayElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseConceptMapGroupUnmapped(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConceptMapGroupUnmapped(jsn)); {2}
end;

function TFHIRJsonParser.ParseConceptMapGroupUnmapped(jsn : TJsonObject) : TFhirConceptMapGroupUnmapped;
begin
  result := TFhirConceptMapGroupUnmapped.create;
  try
    ParseConceptMapGroupUnmappedProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseConceptMapGroupUnmappedProperties(jsn : TJsonObject; result : TFhirConceptMapGroupUnmapped);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('mode') or jsn.has('_mode')  then
      result.modeElement := parseEnum(jsn.path+'/mode', jsn.node['mode'], jsn.vObj['_mode'], CODES_TFhirConceptmapUnmappedModeEnum, SYSTEMS_TFhirConceptmapUnmappedModeEnum);
    if jsn.has('code') or jsn.has('_code') then
        result.codeElement := parseCode(jsn.node['code'], jsn.vObj['_code']);{q}
    if jsn.has('display') or jsn.has('_display') then
        result.displayElement := parseString(jsn.node['display'], jsn.vObj['_display']);{q}
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := parseCanonical(jsn.node['url'], jsn.vObj['_url']);{q}
end;

procedure TFHIRJsonComposer.ComposeConceptMapGroupUnmapped(json : TJSONWriter; name : string; elem : TFhirConceptMapGroupUnmapped; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'mode', elem.ModeElement, CODES_TFhirConceptmapUnmappedModeEnum, false);
  ComposeEnumProps(json, 'mode', elem.ModeElement, CODES_TFhirConceptmapUnmappedModeEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeValue(json, 'code', elem.codeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeProps(json, 'code', elem.codeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'display', elem.displayElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'display', elem.displayElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonicalValue(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonicalProps(json, 'url', elem.urlElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseConceptMap(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConceptMap(jsn)); {2}
end;

function TFHIRJsonParser.ParseConceptMap(jsn : TJsonObject) : TFhirConceptMap;
begin
  result := TFhirConceptMap.create;
  try
    ParseConceptMapProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseConceptMapProperties(jsn : TJsonObject; result : TFhirConceptMap);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := parseUri(jsn.node['url'], jsn.vObj['_url']);{q}
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q3}
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := parseString(jsn.node['version'], jsn.vObj['_version']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('title') or jsn.has('_title') then
        result.titleElement := parseString(jsn.node['title'], jsn.vObj['_title']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    if jsn.has('experimental') or jsn.has('_experimental') then
        result.experimentalElement := parseBoolean(jsn.node['experimental'], jsn.vObj['_experimental']);{q}
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := parseDateTime(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('publisher') or jsn.has('_publisher') then
        result.publisherElement := parseString(jsn.node['publisher'], jsn.vObj['_publisher']);{q}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseContactDetail);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseMarkdown(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('useContext') then
      iterateArray(jsn.vArr['useContext'], result.useContextList, parseUsageContext);
    if jsn.has('jurisdiction') then
      iterateArray(jsn.vArr['jurisdiction'], result.jurisdictionList, parseCodeableConcept);
    if jsn.has('purpose') or jsn.has('_purpose') then
        result.purposeElement := parseMarkdown(jsn.node['purpose'], jsn.vObj['_purpose']);{q}
    if jsn.has('copyright') or jsn.has('_copyright') then
        result.copyrightElement := parseMarkdown(jsn.node['copyright'], jsn.vObj['_copyright']);{q}
    if jsn.has('sourceCanonical') or jsn.has('_sourceCanonical') then
      result.source := parseCanonical(jsn.node['sourceCanonical'], jsn.vObj['_sourceCanonical']);
    if jsn.has('sourceUri') or jsn.has('_sourceUri') then
      result.source := parseUri(jsn.node['sourceUri'], jsn.vObj['_sourceUri']);
    if jsn.has('targetCanonical') or jsn.has('_targetCanonical') then
      result.target := parseCanonical(jsn.node['targetCanonical'], jsn.vObj['_targetCanonical']);
    if jsn.has('targetUri') or jsn.has('_targetUri') then
      result.target := parseUri(jsn.node['targetUri'], jsn.vObj['_targetUri']);
    if jsn.has('group') then
      iterateArray(jsn.vArr['group'], result.groupList, parseConceptMapGroup);
end;

procedure TFHIRJsonComposer.ComposeConceptMap(json : TJSONWriter; name : string; elem : TFhirConceptMap; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUriValue(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUriProps(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeStringValue(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeStringProps(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeStringValue(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeStringProps(json, 'title', elem.titleElement, false);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBooleanValue(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBooleanProps(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringValue(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringProps(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') and (elem.contactList.Count > 0) then
  begin
    json.valueArray('contact');
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(json, '', elem.contactList[i]); {z - ContactDetail}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdownValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdownProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') and (elem.useContextList.Count > 0) then
  begin
    json.valueArray('useContext');
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(json, '', elem.useContextList[i]); {z - UsageContext}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') and (elem.jurisdictionList.Count > 0) then
  begin
    json.valueArray('jurisdiction');
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.jurisdictionList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdownValue(json, 'purpose', elem.purposeElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdownProps(json, 'purpose', elem.purposeElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdownValue(json, 'copyright', elem.copyrightElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdownProps(json, 'copyright', elem.copyrightElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.source is TFhirCanonical) then 
  begin
    ComposeCanonicalValue(json, 'sourceCanonical', TFhirCanonical(elem.source), false);
    ComposeCanonicalProps(json, 'sourceCanonical', TFhirCanonical(elem.source), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.source is TFhirUri) then 
  begin
    ComposeUriValue(json, 'sourceUri', TFhirUri(elem.source), false);
    ComposeUriProps(json, 'sourceUri', TFhirUri(elem.source), false);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.target is TFhirCanonical) then 
  begin
    ComposeCanonicalValue(json, 'targetCanonical', TFhirCanonical(elem.target), false);
    ComposeCanonicalProps(json, 'targetCanonical', TFhirCanonical(elem.target), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.target is TFhirUri) then 
  begin
    ComposeUriValue(json, 'targetUri', TFhirUri(elem.target), false);
    ComposeUriProps(json, 'targetUri', TFhirUri(elem.target), false);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('group') and (elem.groupList.Count > 0) then
  begin
    json.valueArray('group');
    for i := 0 to elem.groupList.Count - 1 do
      ComposeConceptMapGroup(json, '', elem.groupList[i]); {z - }
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_CONCEPTMAP}
{$IFDEF FHIR_CONDITION}
procedure TFHIRJsonParser.ParseConditionStage(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConditionStage(jsn)); {2}
end;

function TFHIRJsonParser.ParseConditionStage(jsn : TJsonObject) : TFhirConditionStage;
begin
  result := TFhirConditionStage.create;
  try
    ParseConditionStageProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseConditionStageProperties(jsn : TJsonObject; result : TFhirConditionStage);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('summary') then
        result.summary := ParseCodeableConcept(jsn.vObj['summary']);{q3}
    if jsn.has('assessment') then
      iterateArray(jsn.vArr['assessment'], result.assessmentList, parseReference{TFhirClinicalImpression});
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
end;

procedure TFHIRJsonComposer.ComposeConditionStage(json : TJSONWriter; name : string; elem : TFhirConditionStage; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'summary', elem.summary); {a}
  if (SummaryOption in [soFull, soData]) and (elem.assessmentList.Count > 0) then
  begin
    json.valueArray('assessment');
    for i := 0 to elem.assessmentList.Count - 1 do
      ComposeReference{TFhirClinicalImpression}(json, '', elem.assessmentList[i]); {z - Reference(ClinicalImpression)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseConditionEvidence(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConditionEvidence(jsn)); {2}
end;

function TFHIRJsonParser.ParseConditionEvidence(jsn : TJsonObject) : TFhirConditionEvidence;
begin
  result := TFhirConditionEvidence.create;
  try
    ParseConditionEvidenceProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseConditionEvidenceProperties(jsn : TJsonObject; result : TFhirConditionEvidence);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
      iterateArray(jsn.vArr['code'], result.codeList, parseCodeableConcept);
    if jsn.has('detail') then
      iterateArray(jsn.vArr['detail'], result.detailList, parseReference{TFhirReference});
end;

procedure TFHIRJsonComposer.ComposeConditionEvidence(json : TJSONWriter; name : string; elem : TFhirConditionEvidence; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.codeList.Count > 0) then
  begin
    json.valueArray('code');
    for i := 0 to elem.codeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.codeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.detailList.Count > 0) then
  begin
    json.valueArray('detail');
    for i := 0 to elem.detailList.Count - 1 do
      ComposeReference{TFhirReference}(json, '', elem.detailList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseCondition(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCondition(jsn)); {2}
end;

function TFHIRJsonParser.ParseCondition(jsn : TJsonObject) : TFhirCondition;
begin
  result := TFhirCondition.create;
  try
    ParseConditionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseConditionProperties(jsn : TJsonObject; result : TFhirCondition);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('clinicalStatus') then
        result.clinicalStatus := ParseCodeableConcept(jsn.vObj['clinicalStatus']);{q3}
    if jsn.has('verificationStatus') then
        result.verificationStatus := ParseCodeableConcept(jsn.vObj['verificationStatus']);{q3}
    if jsn.has('category') then
      iterateArray(jsn.vArr['category'], result.categoryList, parseCodeableConcept);
    if jsn.has('severity') then
        result.severity := ParseCodeableConcept(jsn.vObj['severity']);{q3}
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('bodySite') then
      iterateArray(jsn.vArr['bodySite'], result.bodySiteList, parseCodeableConcept);
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirPatient}(jsn.vObj['subject']);{q3}
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q3}
    if jsn.has('onsetAge') {a4} then
      result.onset := ParseAge(jsn.vObj['onsetAge']);
    if jsn.has('onsetPeriod') {a4} then
      result.onset := ParsePeriod(jsn.vObj['onsetPeriod']);
    if jsn.has('onsetRange') {a4} then
      result.onset := ParseRange(jsn.vObj['onsetRange']);
    if jsn.has('onsetDateTime') or jsn.has('_onsetDateTime') then
      result.onset := parseDateTime(jsn.node['onsetDateTime'], jsn.vObj['_onsetDateTime']);
    if jsn.has('onsetString') or jsn.has('_onsetString') then
      result.onset := parseString(jsn.node['onsetString'], jsn.vObj['_onsetString']);
    if jsn.has('abatementAge') {a4} then
      result.abatement := ParseAge(jsn.vObj['abatementAge']);
    if jsn.has('abatementPeriod') {a4} then
      result.abatement := ParsePeriod(jsn.vObj['abatementPeriod']);
    if jsn.has('abatementRange') {a4} then
      result.abatement := ParseRange(jsn.vObj['abatementRange']);
    if jsn.has('abatementDateTime') or jsn.has('_abatementDateTime') then
      result.abatement := parseDateTime(jsn.node['abatementDateTime'], jsn.vObj['_abatementDateTime']);
    if jsn.has('abatementString') or jsn.has('_abatementString') then
      result.abatement := parseString(jsn.node['abatementString'], jsn.vObj['_abatementString']);
    if jsn.has('recordedDate') or jsn.has('_recordedDate') then
        result.recordedDateElement := parseDateTime(jsn.node['recordedDate'], jsn.vObj['_recordedDate']);{q}
    if jsn.has('recorder') then
        result.recorder := ParseReference{TFhirPractitioner}(jsn.vObj['recorder']);{q3}
    if jsn.has('asserter') then
        result.asserter := ParseReference{TFhirPractitioner}(jsn.vObj['asserter']);{q3}
    if jsn.has('stage') then
      iterateArray(jsn.vArr['stage'], result.stageList, parseConditionStage);
    if jsn.has('evidence') then
      iterateArray(jsn.vArr['evidence'], result.evidenceList, parseConditionEvidence);
    if jsn.has('note') then
      iterateArray(jsn.vArr['note'], result.noteList, parseAnnotation);
end;

procedure TFHIRJsonComposer.ComposeCondition(json : TJSONWriter; name : string; elem : TFhirCondition; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('clinicalStatus') then
    ComposeCodeableConcept(json, 'clinicalStatus', elem.clinicalStatus); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('verificationStatus') then
    ComposeCodeableConcept(json, 'verificationStatus', elem.verificationStatus); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('category') and (elem.categoryList.Count > 0) then
  begin
    json.valueArray('category');
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.categoryList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('severity') then
    ComposeCodeableConcept(json, 'severity', elem.severity); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') then
    ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('bodySite') and (elem.bodySiteList.Count > 0) then
  begin
    json.valueArray('bodySite');
    for i := 0 to elem.bodySiteList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.bodySiteList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  ComposeReference{TFhirPatient}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.onset is TFhirAge) then 
    ComposeAge(json, 'onsetAge', TFhirAge(elem.onset)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.onset is TFhirPeriod) then 
    ComposePeriod(json, 'onsetPeriod', TFhirPeriod(elem.onset)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.onset is TFhirRange) then 
    ComposeRange(json, 'onsetRange', TFhirRange(elem.onset)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.onset is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'onsetDateTime', TFhirDateTime(elem.onset), false);
    ComposeDateTimeProps(json, 'onsetDateTime', TFhirDateTime(elem.onset), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.onset is TFhirString) then 
  begin
    ComposeStringValue(json, 'onsetString', TFhirString(elem.onset), false);
    ComposeStringProps(json, 'onsetString', TFhirString(elem.onset), false);
  end;
  if (SummaryOption in [soFull, soData]) and (elem.abatement is TFhirAge) then 
    ComposeAge(json, 'abatementAge', TFhirAge(elem.abatement)) 
  else if (SummaryOption in [soFull, soData]) and (elem.abatement is TFhirPeriod) then 
    ComposePeriod(json, 'abatementPeriod', TFhirPeriod(elem.abatement)) 
  else if (SummaryOption in [soFull, soData]) and (elem.abatement is TFhirRange) then 
    ComposeRange(json, 'abatementRange', TFhirRange(elem.abatement)) 
  else if (SummaryOption in [soFull, soData]) and (elem.abatement is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'abatementDateTime', TFhirDateTime(elem.abatement), false);
    ComposeDateTimeProps(json, 'abatementDateTime', TFhirDateTime(elem.abatement), false);
  end
  else if (SummaryOption in [soFull, soData]) and (elem.abatement is TFhirString) then 
  begin
    ComposeStringValue(json, 'abatementString', TFhirString(elem.abatement), false);
    ComposeStringProps(json, 'abatementString', TFhirString(elem.abatement), false);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('recordedDate') then
    ComposeDateTimeValue(json, 'recordedDate', elem.recordedDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('recordedDate') then
    ComposeDateTimeProps(json, 'recordedDate', elem.recordedDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('recorder') then
    ComposeReference{TFhirPractitioner}(json, 'recorder', elem.recorder); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('asserter') then
    ComposeReference{TFhirPractitioner}(json, 'asserter', elem.asserter); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('stage') and (elem.stageList.Count > 0) then
  begin
    json.valueArray('stage');
    for i := 0 to elem.stageList.Count - 1 do
      ComposeConditionStage(json, '', elem.stageList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('evidence') and (elem.evidenceList.Count > 0) then
  begin
    json.valueArray('evidence');
    for i := 0 to elem.evidenceList.Count - 1 do
      ComposeConditionEvidence(json, '', elem.evidenceList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('note') and (elem.noteList.Count > 0) then
  begin
    json.valueArray('note');
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(json, '', elem.noteList[i]); {z - Annotation}
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_CONDITION}
{$IFDEF FHIR_CONSENT}
procedure TFHIRJsonParser.ParseConsentPolicy(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConsentPolicy(jsn)); {2}
end;

function TFHIRJsonParser.ParseConsentPolicy(jsn : TJsonObject) : TFhirConsentPolicy;
begin
  result := TFhirConsentPolicy.create;
  try
    ParseConsentPolicyProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseConsentPolicyProperties(jsn : TJsonObject; result : TFhirConsentPolicy);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('authority') or jsn.has('_authority') then
        result.authorityElement := parseUri(jsn.node['authority'], jsn.vObj['_authority']);{q}
    if jsn.has('uri') or jsn.has('_uri') then
        result.uriElement := parseUri(jsn.node['uri'], jsn.vObj['_uri']);{q}
end;

procedure TFHIRJsonComposer.ComposeConsentPolicy(json : TJSONWriter; name : string; elem : TFhirConsentPolicy; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeUriValue(json, 'authority', elem.authorityElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeUriProps(json, 'authority', elem.authorityElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeUriValue(json, 'uri', elem.uriElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeUriProps(json, 'uri', elem.uriElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseConsentVerification(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConsentVerification(jsn)); {2}
end;

function TFHIRJsonParser.ParseConsentVerification(jsn : TJsonObject) : TFhirConsentVerification;
begin
  result := TFhirConsentVerification.create;
  try
    ParseConsentVerificationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseConsentVerificationProperties(jsn : TJsonObject; result : TFhirConsentVerification);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('verified') or jsn.has('_verified') then
        result.verifiedElement := parseBoolean(jsn.node['verified'], jsn.vObj['_verified']);{q}
    if jsn.has('verifiedWith') then
        result.verifiedWith := ParseReference{TFhirPatient}(jsn.vObj['verifiedWith']);{q3}
    if jsn.has('verificationDate') or jsn.has('_verificationDate') then
        result.verificationDateElement := parseDateTime(jsn.node['verificationDate'], jsn.vObj['_verificationDate']);{q}
end;

procedure TFHIRJsonComposer.ComposeConsentVerification(json : TJSONWriter; name : string; elem : TFhirConsentVerification; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeBooleanValue(json, 'verified', elem.verifiedElement, false);
  ComposeBooleanProps(json, 'verified', elem.verifiedElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirPatient}(json, 'verifiedWith', elem.verifiedWith); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTimeValue(json, 'verificationDate', elem.verificationDateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTimeProps(json, 'verificationDate', elem.verificationDateElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseConsentProvision(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConsentProvision(jsn)); {2}
end;

function TFHIRJsonParser.ParseConsentProvision(jsn : TJsonObject) : TFhirConsentProvision;
begin
  result := TFhirConsentProvision.create;
  try
    ParseConsentProvisionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseConsentProvisionProperties(jsn : TJsonObject; result : TFhirConsentProvision);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn.node['type'], jsn.vObj['_type'], CODES_TFhirConsentProvisionTypeEnum, SYSTEMS_TFhirConsentProvisionTypeEnum);
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q3}
    if jsn.has('actor') then
      iterateArray(jsn.vArr['actor'], result.actorList, parseConsentProvisionActor);
    if jsn.has('action') then
      iterateArray(jsn.vArr['action'], result.actionList, parseCodeableConcept);
    if jsn.has('securityLabel') then
      iterateArray(jsn.vArr['securityLabel'], result.securityLabelList, parseCoding);
    if jsn.has('purpose') then
      iterateArray(jsn.vArr['purpose'], result.purposeList, parseCoding);
    if jsn.has('class') then
      iterateArray(jsn.vArr['class'], result.class_List, parseCoding);
    if jsn.has('code') then
      iterateArray(jsn.vArr['code'], result.codeList, parseCodeableConcept);
    if jsn.has('dataPeriod') then
        result.dataPeriod := ParsePeriod(jsn.vObj['dataPeriod']);{q3}
    if jsn.has('data') then
      iterateArray(jsn.vArr['data'], result.dataList, parseConsentProvisionData);
    if jsn.has('provision') then
      iterateArray(jsn.vArr['provision'], result.provisionList, parseConsentProvision);
end;

procedure TFHIRJsonComposer.ComposeConsentProvision(json : TJSONWriter; name : string; elem : TFhirConsentProvision; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirConsentProvisionTypeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirConsentProvisionTypeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(json, 'period', elem.period); {a}
  if (SummaryOption in [soFull, soData]) and (elem.actorList.Count > 0) then
  begin
    json.valueArray('actor');
    for i := 0 to elem.actorList.Count - 1 do
      ComposeConsentProvisionActor(json, '', elem.actorList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.actionList.Count > 0) then
  begin
    json.valueArray('action');
    for i := 0 to elem.actionList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.actionList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.securityLabelList.Count > 0) then
  begin
    json.valueArray('securityLabel');
    for i := 0 to elem.securityLabelList.Count - 1 do
      ComposeCoding(json, '', elem.securityLabelList[i]); {z - Coding}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.purposeList.Count > 0) then
  begin
    json.valueArray('purpose');
    for i := 0 to elem.purposeList.Count - 1 do
      ComposeCoding(json, '', elem.purposeList[i]); {z - Coding}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.class_List.Count > 0) then
  begin
    json.valueArray('class');
    for i := 0 to elem.class_List.Count - 1 do
      ComposeCoding(json, '', elem.class_List[i]); {z - Coding}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.codeList.Count > 0) then
  begin
    json.valueArray('code');
    for i := 0 to elem.codeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.codeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(json, 'dataPeriod', elem.dataPeriod); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.dataList.Count > 0) then
  begin
    json.valueArray('data');
    for i := 0 to elem.dataList.Count - 1 do
      ComposeConsentProvisionData(json, '', elem.dataList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.provisionList.Count > 0) then
  begin
    json.valueArray('provision');
    for i := 0 to elem.provisionList.Count - 1 do
      ComposeConsentProvision(json, '', elem.provisionList[i]); {z - @Consent.provision}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseConsentProvisionActor(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConsentProvisionActor(jsn)); {2}
end;

function TFHIRJsonParser.ParseConsentProvisionActor(jsn : TJsonObject) : TFhirConsentProvisionActor;
begin
  result := TFhirConsentProvisionActor.create;
  try
    ParseConsentProvisionActorProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseConsentProvisionActorProperties(jsn : TJsonObject; result : TFhirConsentProvisionActor);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('role') then
        result.role := ParseCodeableConcept(jsn.vObj['role']);{q3}
    if jsn.has('reference') then
        result.reference := ParseReference{TFhirDevice}(jsn.vObj['reference']);{q3}
end;

procedure TFHIRJsonComposer.ComposeConsentProvisionActor(json : TJSONWriter; name : string; elem : TFhirConsentProvisionActor; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'role', elem.role); {a}
  ComposeReference{TFhirDevice}(json, 'reference', elem.reference); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseConsentProvisionData(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConsentProvisionData(jsn)); {2}
end;

function TFHIRJsonParser.ParseConsentProvisionData(jsn : TJsonObject) : TFhirConsentProvisionData;
begin
  result := TFhirConsentProvisionData.create;
  try
    ParseConsentProvisionDataProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseConsentProvisionDataProperties(jsn : TJsonObject; result : TFhirConsentProvisionData);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('meaning') or jsn.has('_meaning')  then
      result.meaningElement := parseEnum(jsn.path+'/meaning', jsn.node['meaning'], jsn.vObj['_meaning'], CODES_TFhirConsentDataMeaningEnum, SYSTEMS_TFhirConsentDataMeaningEnum);
    if jsn.has('reference') then
        result.reference := ParseReference{TFhirReference}(jsn.vObj['reference']);{q3}
end;

procedure TFHIRJsonComposer.ComposeConsentProvisionData(json : TJSONWriter; name : string; elem : TFhirConsentProvisionData; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'meaning', elem.MeaningElement, CODES_TFhirConsentDataMeaningEnum, false);
  ComposeEnumProps(json, 'meaning', elem.MeaningElement, CODES_TFhirConsentDataMeaningEnum, false);
  ComposeReference{TFhirReference}(json, 'reference', elem.reference); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseConsent(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConsent(jsn)); {2}
end;

function TFHIRJsonParser.ParseConsent(jsn : TJsonObject) : TFhirConsent;
begin
  result := TFhirConsent.create;
  try
    ParseConsentProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseConsentProperties(jsn : TJsonObject; result : TFhirConsent);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirConsentStateCodesEnum, SYSTEMS_TFhirConsentStateCodesEnum);
    if jsn.has('scope') then
        result.scope := ParseCodeableConcept(jsn.vObj['scope']);{q3}
    if jsn.has('category') then
      iterateArray(jsn.vArr['category'], result.categoryList, parseCodeableConcept);
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q3}
    if jsn.has('dateTime') or jsn.has('_dateTime') then
        result.dateTimeElement := parseDateTime(jsn.node['dateTime'], jsn.vObj['_dateTime']);{q}
    if jsn.has('performer') then
      iterateArray(jsn.vArr['performer'], result.performerList, parseReference{TFhirOrganization});
    if jsn.has('organization') then
      iterateArray(jsn.vArr['organization'], result.organizationList, parseReference{TFhirOrganization});
    if jsn.has('sourceAttachment') {a4} then
      result.source := ParseAttachment(jsn.vObj['sourceAttachment']);
    if jsn.has('sourceReference') {a3} then
      result.source := ParseReference(jsn.vObj['sourceReference']);
    if jsn.has('policy') then
      iterateArray(jsn.vArr['policy'], result.policyList, parseConsentPolicy);
    if jsn.has('policyRule') then
        result.policyRule := ParseCodeableConcept(jsn.vObj['policyRule']);{q3}
    if jsn.has('verification') then
      iterateArray(jsn.vArr['verification'], result.verificationList, parseConsentVerification);
    if jsn.has('provision') then
        result.provision := ParseConsentProvision(jsn.vObj['provision']);{q3}
end;

procedure TFHIRJsonComposer.ComposeConsent(json : TJSONWriter; name : string; elem : TFhirConsent; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirConsentStateCodesEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirConsentStateCodesEnum, false);
  ComposeCodeableConcept(json, 'scope', elem.scope); {a}
  if (elem.categoryList.Count > 0) then
  begin
    json.valueArray('category');
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.categoryList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('patient') then
    ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dateTime') then
    ComposeDateTimeValue(json, 'dateTime', elem.dateTimeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dateTime') then
    ComposeDateTimeProps(json, 'dateTime', elem.dateTimeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('performer') and (elem.performerList.Count > 0) then
  begin
    json.valueArray('performer');
    for i := 0 to elem.performerList.Count - 1 do
      ComposeReference{TFhirOrganization}(json, '', elem.performerList[i]); {z - Reference(Organization)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('organization') and (elem.organizationList.Count > 0) then
  begin
    json.valueArray('organization');
    for i := 0 to elem.organizationList.Count - 1 do
      ComposeReference{TFhirOrganization}(json, '', elem.organizationList[i]); {z - Reference(Organization)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.source is TFhirAttachment) then 
    ComposeAttachment(json, 'sourceAttachment', TFhirAttachment(elem.source)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.source is TFhirReference) then
    ComposeReference(json, 'sourceReference', TFhirReference(elem.source));
  if (SummaryOption in [soFull, soData]) and doCompose('policy') and (elem.policyList.Count > 0) then
  begin
    json.valueArray('policy');
    for i := 0 to elem.policyList.Count - 1 do
      ComposeConsentPolicy(json, '', elem.policyList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('policyRule') then
    ComposeCodeableConcept(json, 'policyRule', elem.policyRule); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('verification') and (elem.verificationList.Count > 0) then
  begin
    json.valueArray('verification');
    for i := 0 to elem.verificationList.Count - 1 do
      ComposeConsentVerification(json, '', elem.verificationList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('provision') then
    ComposeConsentProvision(json, 'provision', elem.provision); {a}
end;

{$ENDIF FHIR_CONSENT}
{$IFDEF FHIR_CONTRACT}
procedure TFHIRJsonParser.ParseContractContentDefinition(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseContractContentDefinition(jsn)); {2}
end;

function TFHIRJsonParser.ParseContractContentDefinition(jsn : TJsonObject) : TFhirContractContentDefinition;
begin
  result := TFhirContractContentDefinition.create;
  try
    ParseContractContentDefinitionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseContractContentDefinitionProperties(jsn : TJsonObject; result : TFhirContractContentDefinition);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('subType') then
        result.subType := ParseCodeableConcept(jsn.vObj['subType']);{q3}
    if jsn.has('publisher') then
        result.publisher := ParseReference{TFhirPractitioner}(jsn.vObj['publisher']);{q3}
    if jsn.has('publicationDate') or jsn.has('_publicationDate') then
        result.publicationDateElement := parseDateTime(jsn.node['publicationDate'], jsn.vObj['_publicationDate']);{q}
    if jsn.has('publicationStatus') or jsn.has('_publicationStatus')  then
      result.publicationStatusElement := parseEnum(jsn.path+'/publicationStatus', jsn.node['publicationStatus'], jsn.vObj['_publicationStatus'], CODES_TFhirContractPublicationstatusEnum, SYSTEMS_TFhirContractPublicationstatusEnum);
    if jsn.has('copyright') or jsn.has('_copyright') then
        result.copyrightElement := parseMarkdown(jsn.node['copyright'], jsn.vObj['_copyright']);{q}
end;

procedure TFHIRJsonComposer.ComposeContractContentDefinition(json : TJSONWriter; name : string; elem : TFhirContractContentDefinition; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'subType', elem.subType); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirPractitioner}(json, 'publisher', elem.publisher); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTimeValue(json, 'publicationDate', elem.publicationDateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTimeProps(json, 'publicationDate', elem.publicationDateElement, false);
  ComposeEnumValue(json, 'publicationStatus', elem.PublicationStatusElement, CODES_TFhirContractPublicationstatusEnum, false);
  ComposeEnumProps(json, 'publicationStatus', elem.PublicationStatusElement, CODES_TFhirContractPublicationstatusEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdownValue(json, 'copyright', elem.copyrightElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdownProps(json, 'copyright', elem.copyrightElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseContractTerm(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseContractTerm(jsn)); {2}
end;

function TFHIRJsonParser.ParseContractTerm(jsn : TJsonObject) : TFhirContractTerm;
begin
  result := TFhirContractTerm.create;
  try
    ParseContractTermProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseContractTermProperties(jsn : TJsonObject; result : TFhirContractTerm);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q3}
    if jsn.has('issued') or jsn.has('_issued') then
        result.issuedElement := parseDateTime(jsn.node['issued'], jsn.vObj['_issued']);{q}
    if jsn.has('applies') then
        result.applies := ParsePeriod(jsn.vObj['applies']);{q3}
    if jsn.has('topicCodeableConcept') {a4} then
      result.topic := ParseCodeableConcept(jsn.vObj['topicCodeableConcept']);
    if jsn.has('topicReference') {a3} then
      result.topic := ParseReference(jsn.vObj['topicReference']);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('subType') then
        result.subType := ParseCodeableConcept(jsn.vObj['subType']);{q3}
    if jsn.has('text') or jsn.has('_text') then
        result.textElement := parseString(jsn.node['text'], jsn.vObj['_text']);{q}
    if jsn.has('securityLabel') then
      iterateArray(jsn.vArr['securityLabel'], result.securityLabelList, parseContractTermSecurityLabel);
    if jsn.has('offer') then
        result.offer := ParseContractTermOffer(jsn.vObj['offer']);{q3}
    if jsn.has('asset') then
      iterateArray(jsn.vArr['asset'], result.assetList, parseContractTermAsset);
    if jsn.has('action') then
      iterateArray(jsn.vArr['action'], result.actionList, parseContractTermAction);
    if jsn.has('group') then
      iterateArray(jsn.vArr['group'], result.groupList, parseContractTerm);
end;

procedure TFHIRJsonComposer.ComposeContractTerm(json : TJSONWriter; name : string; elem : TFhirContractTerm; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'issued', elem.issuedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'issued', elem.issuedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(json, 'applies', elem.applies); {a}
  if (SummaryOption in [soFull, soData]) and (elem.topic is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'topicCodeableConcept', TFhirCodeableConcept(elem.topic)) 
  else if (SummaryOption in [soFull, soData]) and (elem.topic is TFhirReference) then
    ComposeReference(json, 'topicReference', TFhirReference(elem.topic));
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'subType', elem.subType); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.securityLabelList.Count > 0) then
  begin
    json.valueArray('securityLabel');
    for i := 0 to elem.securityLabelList.Count - 1 do
      ComposeContractTermSecurityLabel(json, '', elem.securityLabelList[i]); {z - }
    json.FinishArray;
  end;
  ComposeContractTermOffer(json, 'offer', elem.offer); {a}
  if (SummaryOption in [soFull, soData]) and (elem.assetList.Count > 0) then
  begin
    json.valueArray('asset');
    for i := 0 to elem.assetList.Count - 1 do
      ComposeContractTermAsset(json, '', elem.assetList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.actionList.Count > 0) then
  begin
    json.valueArray('action');
    for i := 0 to elem.actionList.Count - 1 do
      ComposeContractTermAction(json, '', elem.actionList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.groupList.Count > 0) then
  begin
    json.valueArray('group');
    for i := 0 to elem.groupList.Count - 1 do
      ComposeContractTerm(json, '', elem.groupList[i]); {z - @Contract.term}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseContractTermSecurityLabel(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseContractTermSecurityLabel(jsn)); {2}
end;

function TFHIRJsonParser.ParseContractTermSecurityLabel(jsn : TJsonObject) : TFhirContractTermSecurityLabel;
begin
  result := TFhirContractTermSecurityLabel.create;
  try
    ParseContractTermSecurityLabelProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseContractTermSecurityLabelProperties(jsn : TJsonObject; result : TFhirContractTermSecurityLabel);
begin
    ParseBackboneElementProperties(jsn, result);
      if jsn.has('number') or jsn.has('_number') then
      iteratePrimitiveArray(jsn.vArr['number'], jsn.vArr['_number'], result.numberList, parseUnsignedInt);
    if jsn.has('classification') then
        result.classification := ParseCoding(jsn.vObj['classification']);{q3}
    if jsn.has('category') then
      iterateArray(jsn.vArr['category'], result.categoryList, parseCoding);
    if jsn.has('control') then
      iterateArray(jsn.vArr['control'], result.controlList, parseCoding);
end;

procedure TFHIRJsonComposer.ComposeContractTermSecurityLabel(json : TJSONWriter; name : string; elem : TFhirContractTermSecurityLabel; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and (elem.numberList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.numberList.Count - 1 do
    begin
      ext := ext or ((elem.numberList[i].id <> '') or (elem.numberList[i].hasExtensionList) {no-comments or (elem.numberList[i].hasComments)});
      val := val or (elem.numberList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('number');
      for i := 0 to elem.numberList.Count - 1 do
        ComposeUnsignedIntValue(json, '',elem.numberList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_number');
      for i := 0 to elem.numberList.Count - 1 do
        ComposeUnsignedIntProps(json, '',elem.numberList[i], true);
      json.FinishArray;
    end;
  end;
  ComposeCoding(json, 'classification', elem.classification); {a}
  if (SummaryOption in [soFull, soData]) and (elem.categoryList.Count > 0) then
  begin
    json.valueArray('category');
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCoding(json, '', elem.categoryList[i]); {z - Coding}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.controlList.Count > 0) then
  begin
    json.valueArray('control');
    for i := 0 to elem.controlList.Count - 1 do
      ComposeCoding(json, '', elem.controlList[i]); {z - Coding}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseContractTermOffer(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseContractTermOffer(jsn)); {2}
end;

function TFHIRJsonParser.ParseContractTermOffer(jsn : TJsonObject) : TFhirContractTermOffer;
begin
  result := TFhirContractTermOffer.create;
  try
    ParseContractTermOfferProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseContractTermOfferProperties(jsn : TJsonObject; result : TFhirContractTermOffer);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('party') then
      iterateArray(jsn.vArr['party'], result.partyList, parseContractTermOfferParty);
    if jsn.has('topic') then
        result.topic := ParseReference{TFhirReference}(jsn.vObj['topic']);{q3}
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('decision') then
        result.decision := ParseCodeableConcept(jsn.vObj['decision']);{q3}
    if jsn.has('decisionMode') then
      iterateArray(jsn.vArr['decisionMode'], result.decisionModeList, parseCodeableConcept);
    if jsn.has('answer') then
      iterateArray(jsn.vArr['answer'], result.answerList, parseContractTermOfferAnswer);
    if jsn.has('text') or jsn.has('_text') then
        result.textElement := parseString(jsn.node['text'], jsn.vObj['_text']);{q}
      if jsn.has('linkId') or jsn.has('_linkId') then
      iteratePrimitiveArray(jsn.vArr['linkId'], jsn.vArr['_linkId'], result.linkIdList, parseString);
      if jsn.has('securityLabelNumber') or jsn.has('_securityLabelNumber') then
      iteratePrimitiveArray(jsn.vArr['securityLabelNumber'], jsn.vArr['_securityLabelNumber'], result.securityLabelNumberList, parseUnsignedInt);
end;

procedure TFHIRJsonComposer.ComposeContractTermOffer(json : TJSONWriter; name : string; elem : TFhirContractTermOffer; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.partyList.Count > 0) then
  begin
    json.valueArray('party');
    for i := 0 to elem.partyList.Count - 1 do
      ComposeContractTermOfferParty(json, '', elem.partyList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirReference}(json, 'topic', elem.topic); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'decision', elem.decision); {a}
  if (SummaryOption in [soFull, soData]) and (elem.decisionModeList.Count > 0) then
  begin
    json.valueArray('decisionMode');
    for i := 0 to elem.decisionModeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.decisionModeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.answerList.Count > 0) then
  begin
    json.valueArray('answer');
    for i := 0 to elem.answerList.Count - 1 do
      ComposeContractTermOfferAnswer(json, '', elem.answerList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.linkIdList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.linkIdList.Count - 1 do
    begin
      ext := ext or ((elem.linkIdList[i].id <> '') or (elem.linkIdList[i].hasExtensionList) {no-comments or (elem.linkIdList[i].hasComments)});
      val := val or (elem.linkIdList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('linkId');
      for i := 0 to elem.linkIdList.Count - 1 do
        ComposeStringValue(json, '',elem.linkIdList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_linkId');
      for i := 0 to elem.linkIdList.Count - 1 do
        ComposeStringProps(json, '',elem.linkIdList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.securityLabelNumberList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.securityLabelNumberList.Count - 1 do
    begin
      ext := ext or ((elem.securityLabelNumberList[i].id <> '') or (elem.securityLabelNumberList[i].hasExtensionList) {no-comments or (elem.securityLabelNumberList[i].hasComments)});
      val := val or (elem.securityLabelNumberList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('securityLabelNumber');
      for i := 0 to elem.securityLabelNumberList.Count - 1 do
        ComposeUnsignedIntValue(json, '',elem.securityLabelNumberList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_securityLabelNumber');
      for i := 0 to elem.securityLabelNumberList.Count - 1 do
        ComposeUnsignedIntProps(json, '',elem.securityLabelNumberList[i], true);
      json.FinishArray;
    end;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseContractTermOfferParty(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseContractTermOfferParty(jsn)); {2}
end;

function TFHIRJsonParser.ParseContractTermOfferParty(jsn : TJsonObject) : TFhirContractTermOfferParty;
begin
  result := TFhirContractTermOfferParty.create;
  try
    ParseContractTermOfferPartyProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseContractTermOfferPartyProperties(jsn : TJsonObject; result : TFhirContractTermOfferParty);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('reference') then
      iterateArray(jsn.vArr['reference'], result.referenceList, parseReference{TFhirPatient});
    if jsn.has('role') then
        result.role := ParseCodeableConcept(jsn.vObj['role']);{q3}
end;

procedure TFHIRJsonComposer.ComposeContractTermOfferParty(json : TJSONWriter; name : string; elem : TFhirContractTermOfferParty; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (elem.referenceList.Count > 0) then
  begin
    json.valueArray('reference');
    for i := 0 to elem.referenceList.Count - 1 do
      ComposeReference{TFhirPatient}(json, '', elem.referenceList[i]); {z - Reference(Patient)}
    json.FinishArray;
  end;
  ComposeCodeableConcept(json, 'role', elem.role); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseContractTermOfferAnswer(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseContractTermOfferAnswer(jsn)); {2}
end;

function TFHIRJsonParser.ParseContractTermOfferAnswer(jsn : TJsonObject) : TFhirContractTermOfferAnswer;
begin
  result := TFhirContractTermOfferAnswer.create;
  try
    ParseContractTermOfferAnswerProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseContractTermOfferAnswerProperties(jsn : TJsonObject; result : TFhirContractTermOfferAnswer);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('valueAttachment') {a4} then
      result.value := ParseAttachment(jsn.vObj['valueAttachment']);
    if jsn.has('valueCoding') {a4} then
      result.value := ParseCoding(jsn.vObj['valueCoding']);
    if jsn.has('valueQuantity') {a4} then
      result.value := ParseQuantity(jsn.vObj['valueQuantity']);
    if jsn.has('valueReference') {a3} then
      result.value := ParseReference(jsn.vObj['valueReference']);
    if jsn.has('valueBoolean') or jsn.has('_valueBoolean') then
      result.value := parseBoolean(jsn.node['valueBoolean'], jsn.vObj['_valueBoolean']);
    if jsn.has('valueDecimal') or jsn.has('_valueDecimal') then
      result.value := parseDecimal(jsn.node['valueDecimal'], jsn.vObj['_valueDecimal']);
    if jsn.has('valueInteger') or jsn.has('_valueInteger') then
      result.value := parseInteger(jsn.node['valueInteger'], jsn.vObj['_valueInteger']);
    if jsn.has('valueDate') or jsn.has('_valueDate') then
      result.value := parseDate(jsn.node['valueDate'], jsn.vObj['_valueDate']);
    if jsn.has('valueDateTime') or jsn.has('_valueDateTime') then
      result.value := parseDateTime(jsn.node['valueDateTime'], jsn.vObj['_valueDateTime']);
    if jsn.has('valueTime') or jsn.has('_valueTime') then
      result.value := parseTime(jsn.node['valueTime'], jsn.vObj['_valueTime']);
    if jsn.has('valueString') or jsn.has('_valueString') then
      result.value := parseString(jsn.node['valueString'], jsn.vObj['_valueString']);
    if jsn.has('valueUri') or jsn.has('_valueUri') then
      result.value := parseUri(jsn.node['valueUri'], jsn.vObj['_valueUri']);
end;

procedure TFHIRJsonComposer.ComposeContractTermOfferAnswer(json : TJSONWriter; name : string; elem : TFhirContractTermOfferAnswer; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (elem.value is TFhirAttachment) then 
    ComposeAttachment(json, 'valueAttachment', TFhirAttachment(elem.value)) 
  else if (elem.value is TFhirCoding) then 
    ComposeCoding(json, 'valueCoding', TFhirCoding(elem.value)) 
  else if (elem.value is TFhirQuantity) then 
    ComposeQuantity(json, 'valueQuantity', TFhirQuantity(elem.value)) 
  else if (elem.value is TFhirReference) then
    ComposeReference(json, 'valueReference', TFhirReference(elem.value))
  else if (elem.value is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'valueBoolean', TFhirBoolean(elem.value), false);
    ComposeBooleanProps(json, 'valueBoolean', TFhirBoolean(elem.value), false);
  end
  else if (elem.value is TFhirDecimal) then 
  begin
    ComposeDecimalValue(json, 'valueDecimal', TFhirDecimal(elem.value), false);
    ComposeDecimalProps(json, 'valueDecimal', TFhirDecimal(elem.value), false);
  end
  else if (elem.value is TFhirInteger) then 
  begin
    ComposeIntegerValue(json, 'valueInteger', TFhirInteger(elem.value), false);
    ComposeIntegerProps(json, 'valueInteger', TFhirInteger(elem.value), false);
  end
  else if (elem.value is TFhirDate) then 
  begin
    ComposeDateValue(json, 'valueDate', TFhirDate(elem.value), false);
    ComposeDateProps(json, 'valueDate', TFhirDate(elem.value), false);
  end
  else if (elem.value is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'valueDateTime', TFhirDateTime(elem.value), false);
    ComposeDateTimeProps(json, 'valueDateTime', TFhirDateTime(elem.value), false);
  end
  else if (elem.value is TFhirTime) then 
  begin
    ComposeTimeValue(json, 'valueTime', TFhirTime(elem.value), false);
    ComposeTimeProps(json, 'valueTime', TFhirTime(elem.value), false);
  end
  else if (elem.value is TFhirString) then 
  begin
    ComposeStringValue(json, 'valueString', TFhirString(elem.value), false);
    ComposeStringProps(json, 'valueString', TFhirString(elem.value), false);
  end
  else if (elem.value is TFhirUri) then 
  begin
    ComposeUriValue(json, 'valueUri', TFhirUri(elem.value), false);
    ComposeUriProps(json, 'valueUri', TFhirUri(elem.value), false);
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseContractTermAsset(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseContractTermAsset(jsn)); {2}
end;

function TFHIRJsonParser.ParseContractTermAsset(jsn : TJsonObject) : TFhirContractTermAsset;
begin
  result := TFhirContractTermAsset.create;
  try
    ParseContractTermAssetProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseContractTermAssetProperties(jsn : TJsonObject; result : TFhirContractTermAsset);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('scope') then
        result.scope := ParseCodeableConcept(jsn.vObj['scope']);{q3}
    if jsn.has('type') then
      iterateArray(jsn.vArr['type'], result.type_List, parseCodeableConcept);
    if jsn.has('typeReference') then
      iterateArray(jsn.vArr['typeReference'], result.typeReferenceList, parseReference{TFhirReference});
    if jsn.has('subtype') then
      iterateArray(jsn.vArr['subtype'], result.subtypeList, parseCodeableConcept);
    if jsn.has('relationship') then
        result.relationship := ParseCoding(jsn.vObj['relationship']);{q3}
    if jsn.has('context') then
      iterateArray(jsn.vArr['context'], result.contextList, parseContractTermAssetContext);
    if jsn.has('condition') or jsn.has('_condition') then
        result.conditionElement := parseString(jsn.node['condition'], jsn.vObj['_condition']);{q}
    if jsn.has('periodType') then
      iterateArray(jsn.vArr['periodType'], result.periodTypeList, parseCodeableConcept);
    if jsn.has('period') then
      iterateArray(jsn.vArr['period'], result.periodList, parsePeriod);
    if jsn.has('usePeriod') then
      iterateArray(jsn.vArr['usePeriod'], result.usePeriodList, parsePeriod);
    if jsn.has('text') or jsn.has('_text') then
        result.textElement := parseString(jsn.node['text'], jsn.vObj['_text']);{q}
      if jsn.has('linkId') or jsn.has('_linkId') then
      iteratePrimitiveArray(jsn.vArr['linkId'], jsn.vArr['_linkId'], result.linkIdList, parseString);
    if jsn.has('answer') then
      iterateArray(jsn.vArr['answer'], result.answerList, parseContractTermOfferAnswer);
      if jsn.has('securityLabelNumber') or jsn.has('_securityLabelNumber') then
      iteratePrimitiveArray(jsn.vArr['securityLabelNumber'], jsn.vArr['_securityLabelNumber'], result.securityLabelNumberList, parseUnsignedInt);
    if jsn.has('valuedItem') then
      iterateArray(jsn.vArr['valuedItem'], result.valuedItemList, parseContractTermAssetValuedItem);
end;

procedure TFHIRJsonComposer.ComposeContractTermAsset(json : TJSONWriter; name : string; elem : TFhirContractTermAsset; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'scope', elem.scope); {a}
  if (SummaryOption in [soFull, soData]) and (elem.type_List.Count > 0) then
  begin
    json.valueArray('type');
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(json, '', elem.type_List[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.typeReferenceList.Count > 0) then
  begin
    json.valueArray('typeReference');
    for i := 0 to elem.typeReferenceList.Count - 1 do
      ComposeReference{TFhirReference}(json, '', elem.typeReferenceList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.subtypeList.Count > 0) then
  begin
    json.valueArray('subtype');
    for i := 0 to elem.subtypeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.subtypeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(json, 'relationship', elem.relationship); {a}
  if (SummaryOption in [soFull, soData]) and (elem.contextList.Count > 0) then
  begin
    json.valueArray('context');
    for i := 0 to elem.contextList.Count - 1 do
      ComposeContractTermAssetContext(json, '', elem.contextList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'condition', elem.conditionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'condition', elem.conditionElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.periodTypeList.Count > 0) then
  begin
    json.valueArray('periodType');
    for i := 0 to elem.periodTypeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.periodTypeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.periodList.Count > 0) then
  begin
    json.valueArray('period');
    for i := 0 to elem.periodList.Count - 1 do
      ComposePeriod(json, '', elem.periodList[i]); {z - Period}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.usePeriodList.Count > 0) then
  begin
    json.valueArray('usePeriod');
    for i := 0 to elem.usePeriodList.Count - 1 do
      ComposePeriod(json, '', elem.usePeriodList[i]); {z - Period}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.linkIdList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.linkIdList.Count - 1 do
    begin
      ext := ext or ((elem.linkIdList[i].id <> '') or (elem.linkIdList[i].hasExtensionList) {no-comments or (elem.linkIdList[i].hasComments)});
      val := val or (elem.linkIdList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('linkId');
      for i := 0 to elem.linkIdList.Count - 1 do
        ComposeStringValue(json, '',elem.linkIdList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_linkId');
      for i := 0 to elem.linkIdList.Count - 1 do
        ComposeStringProps(json, '',elem.linkIdList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.answerList.Count > 0) then
  begin
    json.valueArray('answer');
    for i := 0 to elem.answerList.Count - 1 do
      ComposeContractTermOfferAnswer(json, '', elem.answerList[i]); {z - @Contract.term.offer.answer}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.securityLabelNumberList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.securityLabelNumberList.Count - 1 do
    begin
      ext := ext or ((elem.securityLabelNumberList[i].id <> '') or (elem.securityLabelNumberList[i].hasExtensionList) {no-comments or (elem.securityLabelNumberList[i].hasComments)});
      val := val or (elem.securityLabelNumberList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('securityLabelNumber');
      for i := 0 to elem.securityLabelNumberList.Count - 1 do
        ComposeUnsignedIntValue(json, '',elem.securityLabelNumberList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_securityLabelNumber');
      for i := 0 to elem.securityLabelNumberList.Count - 1 do
        ComposeUnsignedIntProps(json, '',elem.securityLabelNumberList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.valuedItemList.Count > 0) then
  begin
    json.valueArray('valuedItem');
    for i := 0 to elem.valuedItemList.Count - 1 do
      ComposeContractTermAssetValuedItem(json, '', elem.valuedItemList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseContractTermAssetContext(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseContractTermAssetContext(jsn)); {2}
end;

function TFHIRJsonParser.ParseContractTermAssetContext(jsn : TJsonObject) : TFhirContractTermAssetContext;
begin
  result := TFhirContractTermAssetContext.create;
  try
    ParseContractTermAssetContextProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseContractTermAssetContextProperties(jsn : TJsonObject; result : TFhirContractTermAssetContext);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('reference') then
        result.reference := ParseReference{TFhirReference}(jsn.vObj['reference']);{q3}
    if jsn.has('code') then
      iterateArray(jsn.vArr['code'], result.codeList, parseCodeableConcept);
    if jsn.has('text') or jsn.has('_text') then
        result.textElement := parseString(jsn.node['text'], jsn.vObj['_text']);{q}
end;

procedure TFHIRJsonComposer.ComposeContractTermAssetContext(json : TJSONWriter; name : string; elem : TFhirContractTermAssetContext; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirReference}(json, 'reference', elem.reference); {a}
  if (SummaryOption in [soFull, soData]) and (elem.codeList.Count > 0) then
  begin
    json.valueArray('code');
    for i := 0 to elem.codeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.codeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'text', elem.textElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseContractTermAssetValuedItem(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseContractTermAssetValuedItem(jsn)); {2}
end;

function TFHIRJsonParser.ParseContractTermAssetValuedItem(jsn : TJsonObject) : TFhirContractTermAssetValuedItem;
begin
  result := TFhirContractTermAssetValuedItem.create;
  try
    ParseContractTermAssetValuedItemProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseContractTermAssetValuedItemProperties(jsn : TJsonObject; result : TFhirContractTermAssetValuedItem);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('entityCodeableConcept') {a4} then
      result.entity := ParseCodeableConcept(jsn.vObj['entityCodeableConcept']);
    if jsn.has('entityReference') {a3} then
      result.entity := ParseReference(jsn.vObj['entityReference']);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q3}
    if jsn.has('effectiveTime') or jsn.has('_effectiveTime') then
        result.effectiveTimeElement := parseDateTime(jsn.node['effectiveTime'], jsn.vObj['_effectiveTime']);{q}
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q3}
    if jsn.has('unitPrice') then
        result.unitPrice := ParseMoney(jsn.vObj['unitPrice']);{q3}
    if jsn.has('factor') or jsn.has('_factor') then
        result.factorElement := parseDecimal(jsn.node['factor'], jsn.vObj['_factor']);{q}
    if jsn.has('points') or jsn.has('_points') then
        result.pointsElement := parseDecimal(jsn.node['points'], jsn.vObj['_points']);{q}
    if jsn.has('net') then
        result.net := ParseMoney(jsn.vObj['net']);{q3}
    if jsn.has('payment') or jsn.has('_payment') then
        result.paymentElement := parseString(jsn.node['payment'], jsn.vObj['_payment']);{q}
    if jsn.has('paymentDate') or jsn.has('_paymentDate') then
        result.paymentDateElement := parseDateTime(jsn.node['paymentDate'], jsn.vObj['_paymentDate']);{q}
    if jsn.has('responsible') then
        result.responsible := ParseReference{TFhirOrganization}(jsn.vObj['responsible']);{q3}
    if jsn.has('recipient') then
        result.recipient := ParseReference{TFhirOrganization}(jsn.vObj['recipient']);{q3}
      if jsn.has('linkId') or jsn.has('_linkId') then
      iteratePrimitiveArray(jsn.vArr['linkId'], jsn.vArr['_linkId'], result.linkIdList, parseString);
      if jsn.has('securityLabelNumber') or jsn.has('_securityLabelNumber') then
      iteratePrimitiveArray(jsn.vArr['securityLabelNumber'], jsn.vArr['_securityLabelNumber'], result.securityLabelNumberList, parseUnsignedInt);
end;

procedure TFHIRJsonComposer.ComposeContractTermAssetValuedItem(json : TJSONWriter; name : string; elem : TFhirContractTermAssetValuedItem; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and (elem.entity is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'entityCodeableConcept', TFhirCodeableConcept(elem.entity)) 
  else if (SummaryOption in [soFull, soData]) and (elem.entity is TFhirReference) then
    ComposeReference(json, 'entityReference', TFhirReference(elem.entity));
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTimeValue(json, 'effectiveTime', elem.effectiveTimeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTimeProps(json, 'effectiveTime', elem.effectiveTimeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'quantity', elem.quantity); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(json, 'unitPrice', elem.unitPrice); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalValue(json, 'factor', elem.factorElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalProps(json, 'factor', elem.factorElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalValue(json, 'points', elem.pointsElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalProps(json, 'points', elem.pointsElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(json, 'net', elem.net); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'payment', elem.paymentElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'payment', elem.paymentElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTimeValue(json, 'paymentDate', elem.paymentDateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTimeProps(json, 'paymentDate', elem.paymentDateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(json, 'responsible', elem.responsible); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(json, 'recipient', elem.recipient); {a}
  if (SummaryOption in [soFull, soData]) and (elem.linkIdList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.linkIdList.Count - 1 do
    begin
      ext := ext or ((elem.linkIdList[i].id <> '') or (elem.linkIdList[i].hasExtensionList) {no-comments or (elem.linkIdList[i].hasComments)});
      val := val or (elem.linkIdList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('linkId');
      for i := 0 to elem.linkIdList.Count - 1 do
        ComposeStringValue(json, '',elem.linkIdList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_linkId');
      for i := 0 to elem.linkIdList.Count - 1 do
        ComposeStringProps(json, '',elem.linkIdList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.securityLabelNumberList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.securityLabelNumberList.Count - 1 do
    begin
      ext := ext or ((elem.securityLabelNumberList[i].id <> '') or (elem.securityLabelNumberList[i].hasExtensionList) {no-comments or (elem.securityLabelNumberList[i].hasComments)});
      val := val or (elem.securityLabelNumberList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('securityLabelNumber');
      for i := 0 to elem.securityLabelNumberList.Count - 1 do
        ComposeUnsignedIntValue(json, '',elem.securityLabelNumberList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_securityLabelNumber');
      for i := 0 to elem.securityLabelNumberList.Count - 1 do
        ComposeUnsignedIntProps(json, '',elem.securityLabelNumberList[i], true);
      json.FinishArray;
    end;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseContractTermAction(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseContractTermAction(jsn)); {2}
end;

function TFHIRJsonParser.ParseContractTermAction(jsn : TJsonObject) : TFhirContractTermAction;
begin
  result := TFhirContractTermAction.create;
  try
    ParseContractTermActionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseContractTermActionProperties(jsn : TJsonObject; result : TFhirContractTermAction);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('doNotPerform') or jsn.has('_doNotPerform') then
        result.doNotPerformElement := parseBoolean(jsn.node['doNotPerform'], jsn.vObj['_doNotPerform']);{q}
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('subject') then
      iterateArray(jsn.vArr['subject'], result.subjectList, parseContractTermActionSubject);
    if jsn.has('intent') then
        result.intent := ParseCodeableConcept(jsn.vObj['intent']);{q3}
      if jsn.has('linkId') or jsn.has('_linkId') then
      iteratePrimitiveArray(jsn.vArr['linkId'], jsn.vArr['_linkId'], result.linkIdList, parseString);
    if jsn.has('status') then
        result.status := ParseCodeableConcept(jsn.vObj['status']);{q3}
    if jsn.has('context') then
        result.context := ParseReference{TFhirEncounter}(jsn.vObj['context']);{q3}
      if jsn.has('contextLinkId') or jsn.has('_contextLinkId') then
      iteratePrimitiveArray(jsn.vArr['contextLinkId'], jsn.vArr['_contextLinkId'], result.contextLinkIdList, parseString);
    if jsn.has('occurrencePeriod') {a4} then
      result.occurrence := ParsePeriod(jsn.vObj['occurrencePeriod']);
    if jsn.has('occurrenceTiming') {a4} then
      result.occurrence := ParseTiming(jsn.vObj['occurrenceTiming']);
    if jsn.has('occurrenceDateTime') or jsn.has('_occurrenceDateTime') then
      result.occurrence := parseDateTime(jsn.node['occurrenceDateTime'], jsn.vObj['_occurrenceDateTime']);
    if jsn.has('requester') then
      iterateArray(jsn.vArr['requester'], result.requesterList, parseReference{TFhirPatient});
      if jsn.has('requesterLinkId') or jsn.has('_requesterLinkId') then
      iteratePrimitiveArray(jsn.vArr['requesterLinkId'], jsn.vArr['_requesterLinkId'], result.requesterLinkIdList, parseString);
    if jsn.has('performerType') then
      iterateArray(jsn.vArr['performerType'], result.performerTypeList, parseCodeableConcept);
    if jsn.has('performerRole') then
        result.performerRole := ParseCodeableConcept(jsn.vObj['performerRole']);{q3}
    if jsn.has('performer') then
        result.performer := ParseReference{TFhirRelatedPerson}(jsn.vObj['performer']);{q3}
      if jsn.has('performerLinkId') or jsn.has('_performerLinkId') then
      iteratePrimitiveArray(jsn.vArr['performerLinkId'], jsn.vArr['_performerLinkId'], result.performerLinkIdList, parseString);
    if jsn.has('reasonCode') then
      iterateArray(jsn.vArr['reasonCode'], result.reasonCodeList, parseCodeableConcept);
    if jsn.has('reasonReference') then
      iterateArray(jsn.vArr['reasonReference'], result.reasonReferenceList, parseReference{TFhirCondition});
      if jsn.has('reason') or jsn.has('_reason') then
      iteratePrimitiveArray(jsn.vArr['reason'], jsn.vArr['_reason'], result.reasonList, parseString);
      if jsn.has('reasonLinkId') or jsn.has('_reasonLinkId') then
      iteratePrimitiveArray(jsn.vArr['reasonLinkId'], jsn.vArr['_reasonLinkId'], result.reasonLinkIdList, parseString);
    if jsn.has('note') then
      iterateArray(jsn.vArr['note'], result.noteList, parseAnnotation);
      if jsn.has('securityLabelNumber') or jsn.has('_securityLabelNumber') then
      iteratePrimitiveArray(jsn.vArr['securityLabelNumber'], jsn.vArr['_securityLabelNumber'], result.securityLabelNumberList, parseUnsignedInt);
end;

procedure TFHIRJsonComposer.ComposeContractTermAction(json : TJSONWriter; name : string; elem : TFhirContractTermAction; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'doNotPerform', elem.doNotPerformElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'doNotPerform', elem.doNotPerformElement, false);
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) and (elem.subjectList.Count > 0) then
  begin
    json.valueArray('subject');
    for i := 0 to elem.subjectList.Count - 1 do
      ComposeContractTermActionSubject(json, '', elem.subjectList[i]); {z - }
    json.FinishArray;
  end;
  ComposeCodeableConcept(json, 'intent', elem.intent); {a}
  if (SummaryOption in [soFull, soData]) and (elem.linkIdList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.linkIdList.Count - 1 do
    begin
      ext := ext or ((elem.linkIdList[i].id <> '') or (elem.linkIdList[i].hasExtensionList) {no-comments or (elem.linkIdList[i].hasComments)});
      val := val or (elem.linkIdList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('linkId');
      for i := 0 to elem.linkIdList.Count - 1 do
        ComposeStringValue(json, '',elem.linkIdList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_linkId');
      for i := 0 to elem.linkIdList.Count - 1 do
        ComposeStringProps(json, '',elem.linkIdList[i], true);
      json.FinishArray;
    end;
  end;
  ComposeCodeableConcept(json, 'status', elem.status); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirEncounter}(json, 'context', elem.context); {a}
  if (SummaryOption in [soFull, soData]) and (elem.contextLinkIdList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.contextLinkIdList.Count - 1 do
    begin
      ext := ext or ((elem.contextLinkIdList[i].id <> '') or (elem.contextLinkIdList[i].hasExtensionList) {no-comments or (elem.contextLinkIdList[i].hasComments)});
      val := val or (elem.contextLinkIdList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('contextLinkId');
      for i := 0 to elem.contextLinkIdList.Count - 1 do
        ComposeStringValue(json, '',elem.contextLinkIdList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_contextLinkId');
      for i := 0 to elem.contextLinkIdList.Count - 1 do
        ComposeStringProps(json, '',elem.contextLinkIdList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.occurrence is TFhirPeriod) then 
    ComposePeriod(json, 'occurrencePeriod', TFhirPeriod(elem.occurrence)) 
  else if (SummaryOption in [soFull, soData]) and (elem.occurrence is TFhirTiming) then 
    ComposeTiming(json, 'occurrenceTiming', TFhirTiming(elem.occurrence)) 
  else if (SummaryOption in [soFull, soData]) and (elem.occurrence is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'occurrenceDateTime', TFhirDateTime(elem.occurrence), false);
    ComposeDateTimeProps(json, 'occurrenceDateTime', TFhirDateTime(elem.occurrence), false);
  end;
  if (SummaryOption in [soFull, soData]) and (elem.requesterList.Count > 0) then
  begin
    json.valueArray('requester');
    for i := 0 to elem.requesterList.Count - 1 do
      ComposeReference{TFhirPatient}(json, '', elem.requesterList[i]); {z - Reference(Patient)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.requesterLinkIdList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.requesterLinkIdList.Count - 1 do
    begin
      ext := ext or ((elem.requesterLinkIdList[i].id <> '') or (elem.requesterLinkIdList[i].hasExtensionList) {no-comments or (elem.requesterLinkIdList[i].hasComments)});
      val := val or (elem.requesterLinkIdList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('requesterLinkId');
      for i := 0 to elem.requesterLinkIdList.Count - 1 do
        ComposeStringValue(json, '',elem.requesterLinkIdList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_requesterLinkId');
      for i := 0 to elem.requesterLinkIdList.Count - 1 do
        ComposeStringProps(json, '',elem.requesterLinkIdList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.performerTypeList.Count > 0) then
  begin
    json.valueArray('performerType');
    for i := 0 to elem.performerTypeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.performerTypeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'performerRole', elem.performerRole); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirRelatedPerson}(json, 'performer', elem.performer); {a}
  if (SummaryOption in [soFull, soData]) and (elem.performerLinkIdList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.performerLinkIdList.Count - 1 do
    begin
      ext := ext or ((elem.performerLinkIdList[i].id <> '') or (elem.performerLinkIdList[i].hasExtensionList) {no-comments or (elem.performerLinkIdList[i].hasComments)});
      val := val or (elem.performerLinkIdList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('performerLinkId');
      for i := 0 to elem.performerLinkIdList.Count - 1 do
        ComposeStringValue(json, '',elem.performerLinkIdList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_performerLinkId');
      for i := 0 to elem.performerLinkIdList.Count - 1 do
        ComposeStringProps(json, '',elem.performerLinkIdList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.reasonCodeList.Count > 0) then
  begin
    json.valueArray('reasonCode');
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.reasonCodeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.reasonReferenceList.Count > 0) then
  begin
    json.valueArray('reasonReference');
    for i := 0 to elem.reasonReferenceList.Count - 1 do
      ComposeReference{TFhirCondition}(json, '', elem.reasonReferenceList[i]); {z - Reference(Condition)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.reasonList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.reasonList.Count - 1 do
    begin
      ext := ext or ((elem.reasonList[i].id <> '') or (elem.reasonList[i].hasExtensionList) {no-comments or (elem.reasonList[i].hasComments)});
      val := val or (elem.reasonList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('reason');
      for i := 0 to elem.reasonList.Count - 1 do
        ComposeStringValue(json, '',elem.reasonList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_reason');
      for i := 0 to elem.reasonList.Count - 1 do
        ComposeStringProps(json, '',elem.reasonList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.reasonLinkIdList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.reasonLinkIdList.Count - 1 do
    begin
      ext := ext or ((elem.reasonLinkIdList[i].id <> '') or (elem.reasonLinkIdList[i].hasExtensionList) {no-comments or (elem.reasonLinkIdList[i].hasComments)});
      val := val or (elem.reasonLinkIdList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('reasonLinkId');
      for i := 0 to elem.reasonLinkIdList.Count - 1 do
        ComposeStringValue(json, '',elem.reasonLinkIdList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_reasonLinkId');
      for i := 0 to elem.reasonLinkIdList.Count - 1 do
        ComposeStringProps(json, '',elem.reasonLinkIdList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.noteList.Count > 0) then
  begin
    json.valueArray('note');
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(json, '', elem.noteList[i]); {z - Annotation}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.securityLabelNumberList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.securityLabelNumberList.Count - 1 do
    begin
      ext := ext or ((elem.securityLabelNumberList[i].id <> '') or (elem.securityLabelNumberList[i].hasExtensionList) {no-comments or (elem.securityLabelNumberList[i].hasComments)});
      val := val or (elem.securityLabelNumberList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('securityLabelNumber');
      for i := 0 to elem.securityLabelNumberList.Count - 1 do
        ComposeUnsignedIntValue(json, '',elem.securityLabelNumberList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_securityLabelNumber');
      for i := 0 to elem.securityLabelNumberList.Count - 1 do
        ComposeUnsignedIntProps(json, '',elem.securityLabelNumberList[i], true);
      json.FinishArray;
    end;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseContractTermActionSubject(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseContractTermActionSubject(jsn)); {2}
end;

function TFHIRJsonParser.ParseContractTermActionSubject(jsn : TJsonObject) : TFhirContractTermActionSubject;
begin
  result := TFhirContractTermActionSubject.create;
  try
    ParseContractTermActionSubjectProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseContractTermActionSubjectProperties(jsn : TJsonObject; result : TFhirContractTermActionSubject);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('reference') then
      iterateArray(jsn.vArr['reference'], result.referenceList, parseReference{TFhirPatient});
    if jsn.has('role') then
        result.role := ParseCodeableConcept(jsn.vObj['role']);{q3}
end;

procedure TFHIRJsonComposer.ComposeContractTermActionSubject(json : TJSONWriter; name : string; elem : TFhirContractTermActionSubject; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (elem.referenceList.Count > 0) then
  begin
    json.valueArray('reference');
    for i := 0 to elem.referenceList.Count - 1 do
      ComposeReference{TFhirPatient}(json, '', elem.referenceList[i]); {z - Reference(Patient)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'role', elem.role); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseContractSigner(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseContractSigner(jsn)); {2}
end;

function TFHIRJsonParser.ParseContractSigner(jsn : TJsonObject) : TFhirContractSigner;
begin
  result := TFhirContractSigner.create;
  try
    ParseContractSignerProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseContractSignerProperties(jsn : TJsonObject; result : TFhirContractSigner);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCoding(jsn.vObj['type']);{q3}
    if jsn.has('party') then
        result.party := ParseReference{TFhirOrganization}(jsn.vObj['party']);{q3}
    if jsn.has('signature') then
      iterateArray(jsn.vArr['signature'], result.signatureList, parseSignature);
end;

procedure TFHIRJsonComposer.ComposeContractSigner(json : TJSONWriter; name : string; elem : TFhirContractSigner; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCoding(json, 'type', elem.type_); {a}
  ComposeReference{TFhirOrganization}(json, 'party', elem.party); {a}
  if (elem.signatureList.Count > 0) then
  begin
    json.valueArray('signature');
    for i := 0 to elem.signatureList.Count - 1 do
      ComposeSignature(json, '', elem.signatureList[i]); {z - Signature}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseContractFriendly(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseContractFriendly(jsn)); {2}
end;

function TFHIRJsonParser.ParseContractFriendly(jsn : TJsonObject) : TFhirContractFriendly;
begin
  result := TFhirContractFriendly.create;
  try
    ParseContractFriendlyProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseContractFriendlyProperties(jsn : TJsonObject; result : TFhirContractFriendly);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('contentAttachment') {a4} then
      result.content := ParseAttachment(jsn.vObj['contentAttachment']);
    if jsn.has('contentReference') {a3} then
      result.content := ParseReference(jsn.vObj['contentReference']);
end;

procedure TFHIRJsonComposer.ComposeContractFriendly(json : TJSONWriter; name : string; elem : TFhirContractFriendly; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (elem.content is TFhirAttachment) then 
    ComposeAttachment(json, 'contentAttachment', TFhirAttachment(elem.content)) 
  else if (elem.content is TFhirReference) then
    ComposeReference(json, 'contentReference', TFhirReference(elem.content));
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseContractLegal(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseContractLegal(jsn)); {2}
end;

function TFHIRJsonParser.ParseContractLegal(jsn : TJsonObject) : TFhirContractLegal;
begin
  result := TFhirContractLegal.create;
  try
    ParseContractLegalProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseContractLegalProperties(jsn : TJsonObject; result : TFhirContractLegal);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('contentAttachment') {a4} then
      result.content := ParseAttachment(jsn.vObj['contentAttachment']);
    if jsn.has('contentReference') {a3} then
      result.content := ParseReference(jsn.vObj['contentReference']);
end;

procedure TFHIRJsonComposer.ComposeContractLegal(json : TJSONWriter; name : string; elem : TFhirContractLegal; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (elem.content is TFhirAttachment) then 
    ComposeAttachment(json, 'contentAttachment', TFhirAttachment(elem.content)) 
  else if (elem.content is TFhirReference) then
    ComposeReference(json, 'contentReference', TFhirReference(elem.content));
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseContractRule(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseContractRule(jsn)); {2}
end;

function TFHIRJsonParser.ParseContractRule(jsn : TJsonObject) : TFhirContractRule;
begin
  result := TFhirContractRule.create;
  try
    ParseContractRuleProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseContractRuleProperties(jsn : TJsonObject; result : TFhirContractRule);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('contentAttachment') {a4} then
      result.content := ParseAttachment(jsn.vObj['contentAttachment']);
    if jsn.has('contentReference') {a3} then
      result.content := ParseReference(jsn.vObj['contentReference']);
end;

procedure TFHIRJsonComposer.ComposeContractRule(json : TJSONWriter; name : string; elem : TFhirContractRule; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (elem.content is TFhirAttachment) then 
    ComposeAttachment(json, 'contentAttachment', TFhirAttachment(elem.content)) 
  else if (elem.content is TFhirReference) then
    ComposeReference(json, 'contentReference', TFhirReference(elem.content));
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseContract(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseContract(jsn)); {2}
end;

function TFHIRJsonParser.ParseContract(jsn : TJsonObject) : TFhirContract;
begin
  result := TFhirContract.create;
  try
    ParseContractProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseContractProperties(jsn : TJsonObject; result : TFhirContract);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := parseUri(jsn.node['url'], jsn.vObj['_url']);{q}
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := parseString(jsn.node['version'], jsn.vObj['_version']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirContractStatusEnum, SYSTEMS_TFhirContractStatusEnum);
    if jsn.has('legalState') then
        result.legalState := ParseCodeableConcept(jsn.vObj['legalState']);{q3}
    if jsn.has('instantiatesCanonical') then
        result.instantiatesCanonical := ParseReference{TFhirContract}(jsn.vObj['instantiatesCanonical']);{q3}
    if jsn.has('instantiatesUri') or jsn.has('_instantiatesUri') then
        result.instantiatesUriElement := parseUri(jsn.node['instantiatesUri'], jsn.vObj['_instantiatesUri']);{q}
    if jsn.has('contentDerivative') then
        result.contentDerivative := ParseCodeableConcept(jsn.vObj['contentDerivative']);{q3}
    if jsn.has('issued') or jsn.has('_issued') then
        result.issuedElement := parseDateTime(jsn.node['issued'], jsn.vObj['_issued']);{q}
    if jsn.has('applies') then
        result.applies := ParsePeriod(jsn.vObj['applies']);{q3}
    if jsn.has('expirationType') then
        result.expirationType := ParseCodeableConcept(jsn.vObj['expirationType']);{q3}
    if jsn.has('subject') then
      iterateArray(jsn.vArr['subject'], result.subjectList, parseReference{TFhirReference});
    if jsn.has('authority') then
      iterateArray(jsn.vArr['authority'], result.authorityList, parseReference{TFhirOrganization});
    if jsn.has('domain') then
      iterateArray(jsn.vArr['domain'], result.domainList, parseReference{TFhirLocation});
    if jsn.has('site') then
      iterateArray(jsn.vArr['site'], result.siteList, parseReference{TFhirLocation});
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('title') or jsn.has('_title') then
        result.titleElement := parseString(jsn.node['title'], jsn.vObj['_title']);{q}
    if jsn.has('subtitle') or jsn.has('_subtitle') then
        result.subtitleElement := parseString(jsn.node['subtitle'], jsn.vObj['_subtitle']);{q}
      if jsn.has('alias') or jsn.has('_alias') then
      iteratePrimitiveArray(jsn.vArr['alias'], jsn.vArr['_alias'], result.aliasList, parseString);
    if jsn.has('author') then
        result.author := ParseReference{TFhirPatient}(jsn.vObj['author']);{q3}
    if jsn.has('scope') then
        result.scope := ParseCodeableConcept(jsn.vObj['scope']);{q3}
    if jsn.has('topicCodeableConcept') {a4} then
      result.topic := ParseCodeableConcept(jsn.vObj['topicCodeableConcept']);
    if jsn.has('topicReference') {a3} then
      result.topic := ParseReference(jsn.vObj['topicReference']);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('subType') then
      iterateArray(jsn.vArr['subType'], result.subTypeList, parseCodeableConcept);
    if jsn.has('contentDefinition') then
        result.contentDefinition := ParseContractContentDefinition(jsn.vObj['contentDefinition']);{q3}
    if jsn.has('term') then
      iterateArray(jsn.vArr['term'], result.termList, parseContractTerm);
    if jsn.has('supportingInfo') then
      iterateArray(jsn.vArr['supportingInfo'], result.supportingInfoList, parseReference{TFhirReference});
    if jsn.has('relevantHistory') then
      iterateArray(jsn.vArr['relevantHistory'], result.relevantHistoryList, parseReference{TFhirProvenance});
    if jsn.has('signer') then
      iterateArray(jsn.vArr['signer'], result.signerList, parseContractSigner);
    if jsn.has('friendly') then
      iterateArray(jsn.vArr['friendly'], result.friendlyList, parseContractFriendly);
    if jsn.has('legal') then
      iterateArray(jsn.vArr['legal'], result.legalList, parseContractLegal);
    if jsn.has('rule') then
      iterateArray(jsn.vArr['rule'], result.ruleList, parseContractRule);
    if jsn.has('legallyBindingAttachment') {a4} then
      result.legallyBinding := ParseAttachment(jsn.vObj['legallyBindingAttachment']);
    if jsn.has('legallyBindingReference') {a3} then
      result.legallyBinding := ParseReference(jsn.vObj['legallyBindingReference']);
end;

procedure TFHIRJsonComposer.ComposeContract(json : TJSONWriter; name : string; elem : TFhirContract; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('url') then
    ComposeUriValue(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('url') then
    ComposeUriProps(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeStringValue(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeStringProps(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirContractStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirContractStatusEnum, false);
  if (SummaryOption in [soFull, soData]) and doCompose('legalState') then
    ComposeCodeableConcept(json, 'legalState', elem.legalState); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('instantiatesCanonical') then
    ComposeReference{TFhirContract}(json, 'instantiatesCanonical', elem.instantiatesCanonical); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('instantiatesUri') then
    ComposeUriValue(json, 'instantiatesUri', elem.instantiatesUriElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('instantiatesUri') then
    ComposeUriProps(json, 'instantiatesUri', elem.instantiatesUriElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('contentDerivative') then
    ComposeCodeableConcept(json, 'contentDerivative', elem.contentDerivative); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('issued') then
    ComposeDateTimeValue(json, 'issued', elem.issuedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('issued') then
    ComposeDateTimeProps(json, 'issued', elem.issuedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('applies') then
    ComposePeriod(json, 'applies', elem.applies); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('expirationType') then
    ComposeCodeableConcept(json, 'expirationType', elem.expirationType); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') and (elem.subjectList.Count > 0) then
  begin
    json.valueArray('subject');
    for i := 0 to elem.subjectList.Count - 1 do
      ComposeReference{TFhirReference}(json, '', elem.subjectList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('authority') and (elem.authorityList.Count > 0) then
  begin
    json.valueArray('authority');
    for i := 0 to elem.authorityList.Count - 1 do
      ComposeReference{TFhirOrganization}(json, '', elem.authorityList[i]); {z - Reference(Organization)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('domain') and (elem.domainList.Count > 0) then
  begin
    json.valueArray('domain');
    for i := 0 to elem.domainList.Count - 1 do
      ComposeReference{TFhirLocation}(json, '', elem.domainList[i]); {z - Reference(Location)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('site') and (elem.siteList.Count > 0) then
  begin
    json.valueArray('site');
    for i := 0 to elem.siteList.Count - 1 do
      ComposeReference{TFhirLocation}(json, '', elem.siteList[i]); {z - Reference(Location)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeStringValue(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeStringProps(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('subtitle') then
    ComposeStringValue(json, 'subtitle', elem.subtitleElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('subtitle') then
    ComposeStringProps(json, 'subtitle', elem.subtitleElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('alias') and (elem.aliasList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.aliasList.Count - 1 do
    begin
      ext := ext or ((elem.aliasList[i].id <> '') or (elem.aliasList[i].hasExtensionList) {no-comments or (elem.aliasList[i].hasComments)});
      val := val or (elem.aliasList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('alias');
      for i := 0 to elem.aliasList.Count - 1 do
        ComposeStringValue(json, '',elem.aliasList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_alias');
      for i := 0 to elem.aliasList.Count - 1 do
        ComposeStringProps(json, '',elem.aliasList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('author') then
    ComposeReference{TFhirPatient}(json, 'author', elem.author); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('scope') then
    ComposeCodeableConcept(json, 'scope', elem.scope); {a}
  if (SummaryOption in [soFull, soData]) and (elem.topic is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'topicCodeableConcept', TFhirCodeableConcept(elem.topic)) 
  else if (SummaryOption in [soFull, soData]) and (elem.topic is TFhirReference) then
    ComposeReference(json, 'topicReference', TFhirReference(elem.topic));
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subType') and (elem.subTypeList.Count > 0) then
  begin
    json.valueArray('subType');
    for i := 0 to elem.subTypeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.subTypeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('contentDefinition') then
    ComposeContractContentDefinition(json, 'contentDefinition', elem.contentDefinition); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('term') and (elem.termList.Count > 0) then
  begin
    json.valueArray('term');
    for i := 0 to elem.termList.Count - 1 do
      ComposeContractTerm(json, '', elem.termList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('supportingInfo') and (elem.supportingInfoList.Count > 0) then
  begin
    json.valueArray('supportingInfo');
    for i := 0 to elem.supportingInfoList.Count - 1 do
      ComposeReference{TFhirReference}(json, '', elem.supportingInfoList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('relevantHistory') and (elem.relevantHistoryList.Count > 0) then
  begin
    json.valueArray('relevantHistory');
    for i := 0 to elem.relevantHistoryList.Count - 1 do
      ComposeReference{TFhirProvenance}(json, '', elem.relevantHistoryList[i]); {z - Reference(Provenance)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('signer') and (elem.signerList.Count > 0) then
  begin
    json.valueArray('signer');
    for i := 0 to elem.signerList.Count - 1 do
      ComposeContractSigner(json, '', elem.signerList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('friendly') and (elem.friendlyList.Count > 0) then
  begin
    json.valueArray('friendly');
    for i := 0 to elem.friendlyList.Count - 1 do
      ComposeContractFriendly(json, '', elem.friendlyList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('legal') and (elem.legalList.Count > 0) then
  begin
    json.valueArray('legal');
    for i := 0 to elem.legalList.Count - 1 do
      ComposeContractLegal(json, '', elem.legalList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('rule') and (elem.ruleList.Count > 0) then
  begin
    json.valueArray('rule');
    for i := 0 to elem.ruleList.Count - 1 do
      ComposeContractRule(json, '', elem.ruleList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.legallyBinding is TFhirAttachment) then 
    ComposeAttachment(json, 'legallyBindingAttachment', TFhirAttachment(elem.legallyBinding)) 
  else if (SummaryOption in [soFull, soData]) and (elem.legallyBinding is TFhirReference) then
    ComposeReference(json, 'legallyBindingReference', TFhirReference(elem.legallyBinding));
end;

{$ENDIF FHIR_CONTRACT}
{$IFDEF FHIR_COVERAGE}
procedure TFHIRJsonParser.ParseCoverageClass(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCoverageClass(jsn)); {2}
end;

function TFHIRJsonParser.ParseCoverageClass(jsn : TJsonObject) : TFhirCoverageClass;
begin
  result := TFhirCoverageClass.create;
  try
    ParseCoverageClassProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCoverageClassProperties(jsn : TJsonObject; result : TFhirCoverageClass);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('value') or jsn.has('_value') then
        result.valueElement := parseString(jsn.node['value'], jsn.vObj['_value']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
end;

procedure TFHIRJsonComposer.ComposeCoverageClass(json : TJSONWriter; name : string; elem : TFhirCoverageClass; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  ComposeStringValue(json, 'value', elem.valueElement, false);
  ComposeStringProps(json, 'value', elem.valueElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseCoverageCostToBeneficiary(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCoverageCostToBeneficiary(jsn)); {2}
end;

function TFHIRJsonParser.ParseCoverageCostToBeneficiary(jsn : TJsonObject) : TFhirCoverageCostToBeneficiary;
begin
  result := TFhirCoverageCostToBeneficiary.create;
  try
    ParseCoverageCostToBeneficiaryProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCoverageCostToBeneficiaryProperties(jsn : TJsonObject; result : TFhirCoverageCostToBeneficiary);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('valueQuantity') {a4} then
      result.value := ParseQuantity(jsn.vObj['valueQuantity']);
    if jsn.has('valueMoney') {a4} then
      result.value := ParseMoney(jsn.vObj['valueMoney']);
    if jsn.has('exception') then
      iterateArray(jsn.vArr['exception'], result.exceptionList, parseCoverageCostToBeneficiaryException);
end;

procedure TFHIRJsonComposer.ComposeCoverageCostToBeneficiary(json : TJSONWriter; name : string; elem : TFhirCoverageCostToBeneficiary; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (elem.value is TFhirQuantity) then 
    ComposeQuantity(json, 'valueQuantity', TFhirQuantity(elem.value)) 
  else if (elem.value is TFhirMoney) then 
    ComposeMoney(json, 'valueMoney', TFhirMoney(elem.value)) ;
  if (SummaryOption in [soFull, soData]) and (elem.exceptionList.Count > 0) then
  begin
    json.valueArray('exception');
    for i := 0 to elem.exceptionList.Count - 1 do
      ComposeCoverageCostToBeneficiaryException(json, '', elem.exceptionList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseCoverageCostToBeneficiaryException(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCoverageCostToBeneficiaryException(jsn)); {2}
end;

function TFHIRJsonParser.ParseCoverageCostToBeneficiaryException(jsn : TJsonObject) : TFhirCoverageCostToBeneficiaryException;
begin
  result := TFhirCoverageCostToBeneficiaryException.create;
  try
    ParseCoverageCostToBeneficiaryExceptionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCoverageCostToBeneficiaryExceptionProperties(jsn : TJsonObject; result : TFhirCoverageCostToBeneficiaryException);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q3}
end;

procedure TFHIRJsonComposer.ComposeCoverageCostToBeneficiaryException(json : TJSONWriter; name : string; elem : TFhirCoverageCostToBeneficiaryException; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(json, 'period', elem.period); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseCoverage(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCoverage(jsn)); {2}
end;

function TFHIRJsonParser.ParseCoverage(jsn : TJsonObject) : TFhirCoverage;
begin
  result := TFhirCoverage.create;
  try
    ParseCoverageProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCoverageProperties(jsn : TJsonObject; result : TFhirCoverage);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirFmStatusEnum, SYSTEMS_TFhirFmStatusEnum);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('policyHolder') then
        result.policyHolder := ParseReference{TFhirPatient}(jsn.vObj['policyHolder']);{q3}
    if jsn.has('subscriber') then
        result.subscriber := ParseReference{TFhirPatient}(jsn.vObj['subscriber']);{q3}
    if jsn.has('subscriberId') or jsn.has('_subscriberId') then
        result.subscriberIdElement := parseString(jsn.node['subscriberId'], jsn.vObj['_subscriberId']);{q}
    if jsn.has('beneficiary') then
        result.beneficiary := ParseReference{TFhirPatient}(jsn.vObj['beneficiary']);{q3}
    if jsn.has('dependent') or jsn.has('_dependent') then
        result.dependentElement := parseString(jsn.node['dependent'], jsn.vObj['_dependent']);{q}
    if jsn.has('relationship') then
        result.relationship := ParseCodeableConcept(jsn.vObj['relationship']);{q3}
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q3}
    if jsn.has('payor') then
      iterateArray(jsn.vArr['payor'], result.payorList, parseReference{TFhirOrganization});
    if jsn.has('class') then
      iterateArray(jsn.vArr['class'], result.class_List, parseCoverageClass);
    if jsn.has('order') or jsn.has('_order') then
        result.orderElement := parsePositiveInt(jsn.node['order'], jsn.vObj['_order']);{q}
    if jsn.has('network') or jsn.has('_network') then
        result.networkElement := parseString(jsn.node['network'], jsn.vObj['_network']);{q}
    if jsn.has('costToBeneficiary') then
      iterateArray(jsn.vArr['costToBeneficiary'], result.costToBeneficiaryList, parseCoverageCostToBeneficiary);
    if jsn.has('subrogation') or jsn.has('_subrogation') then
        result.subrogationElement := parseBoolean(jsn.node['subrogation'], jsn.vObj['_subrogation']);{q}
    if jsn.has('contract') then
      iterateArray(jsn.vArr['contract'], result.contractList, parseReference{TFhirContract});
end;

procedure TFHIRJsonComposer.ComposeCoverage(json : TJSONWriter; name : string; elem : TFhirCoverage; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirFmStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirFmStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('policyHolder') then
    ComposeReference{TFhirPatient}(json, 'policyHolder', elem.policyHolder); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subscriber') then
    ComposeReference{TFhirPatient}(json, 'subscriber', elem.subscriber); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subscriberId') then
    ComposeStringValue(json, 'subscriberId', elem.subscriberIdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subscriberId') then
    ComposeStringProps(json, 'subscriberId', elem.subscriberIdElement, false);
    ComposeReference{TFhirPatient}(json, 'beneficiary', elem.beneficiary); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dependent') then
    ComposeStringValue(json, 'dependent', elem.dependentElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dependent') then
    ComposeStringProps(json, 'dependent', elem.dependentElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('relationship') then
    ComposeCodeableConcept(json, 'relationship', elem.relationship); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('period') then
    ComposePeriod(json, 'period', elem.period); {a}
  if (elem.payorList.Count > 0) then
  begin
    json.valueArray('payor');
    for i := 0 to elem.payorList.Count - 1 do
      ComposeReference{TFhirOrganization}(json, '', elem.payorList[i]); {z - Reference(Organization)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('class_') and (elem.class_List.Count > 0) then
  begin
    json.valueArray('class');
    for i := 0 to elem.class_List.Count - 1 do
      ComposeCoverageClass(json, '', elem.class_List[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('order') then
    ComposePositiveIntValue(json, 'order', elem.orderElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('order') then
    ComposePositiveIntProps(json, 'order', elem.orderElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('network') then
    ComposeStringValue(json, 'network', elem.networkElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('network') then
    ComposeStringProps(json, 'network', elem.networkElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('costToBeneficiary') and (elem.costToBeneficiaryList.Count > 0) then
  begin
    json.valueArray('costToBeneficiary');
    for i := 0 to elem.costToBeneficiaryList.Count - 1 do
      ComposeCoverageCostToBeneficiary(json, '', elem.costToBeneficiaryList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('subrogation') then
    ComposeBooleanValue(json, 'subrogation', elem.subrogationElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('subrogation') then
    ComposeBooleanProps(json, 'subrogation', elem.subrogationElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('contract') and (elem.contractList.Count > 0) then
  begin
    json.valueArray('contract');
    for i := 0 to elem.contractList.Count - 1 do
      ComposeReference{TFhirContract}(json, '', elem.contractList[i]); {z - Reference(Contract)}
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_COVERAGE}
{$IFDEF FHIR_COVERAGEELIGIBILITYREQUEST}
procedure TFHIRJsonParser.ParseCoverageEligibilityRequestSupportingInfo(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCoverageEligibilityRequestSupportingInfo(jsn)); {2}
end;

function TFHIRJsonParser.ParseCoverageEligibilityRequestSupportingInfo(jsn : TJsonObject) : TFhirCoverageEligibilityRequestSupportingInfo;
begin
  result := TFhirCoverageEligibilityRequestSupportingInfo.create;
  try
    ParseCoverageEligibilityRequestSupportingInfoProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCoverageEligibilityRequestSupportingInfoProperties(jsn : TJsonObject; result : TFhirCoverageEligibilityRequestSupportingInfo);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('sequence') or jsn.has('_sequence') then
        result.sequenceElement := parsePositiveInt(jsn.node['sequence'], jsn.vObj['_sequence']);{q}
    if jsn.has('information') then
        result.information := ParseReference{TFhirReference}(jsn.vObj['information']);{q3}
    if jsn.has('appliesToAll') or jsn.has('_appliesToAll') then
        result.appliesToAllElement := parseBoolean(jsn.node['appliesToAll'], jsn.vObj['_appliesToAll']);{q}
end;

procedure TFHIRJsonComposer.ComposeCoverageEligibilityRequestSupportingInfo(json : TJSONWriter; name : string; elem : TFhirCoverageEligibilityRequestSupportingInfo; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposePositiveIntValue(json, 'sequence', elem.sequenceElement, false);
  ComposePositiveIntProps(json, 'sequence', elem.sequenceElement, false);
  ComposeReference{TFhirReference}(json, 'information', elem.information); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'appliesToAll', elem.appliesToAllElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'appliesToAll', elem.appliesToAllElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseCoverageEligibilityRequestInsurance(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCoverageEligibilityRequestInsurance(jsn)); {2}
end;

function TFHIRJsonParser.ParseCoverageEligibilityRequestInsurance(jsn : TJsonObject) : TFhirCoverageEligibilityRequestInsurance;
begin
  result := TFhirCoverageEligibilityRequestInsurance.create;
  try
    ParseCoverageEligibilityRequestInsuranceProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCoverageEligibilityRequestInsuranceProperties(jsn : TJsonObject; result : TFhirCoverageEligibilityRequestInsurance);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('focal') or jsn.has('_focal') then
        result.focalElement := parseBoolean(jsn.node['focal'], jsn.vObj['_focal']);{q}
    if jsn.has('coverage') then
        result.coverage := ParseReference{TFhirCoverage}(jsn.vObj['coverage']);{q3}
    if jsn.has('businessArrangement') or jsn.has('_businessArrangement') then
        result.businessArrangementElement := parseString(jsn.node['businessArrangement'], jsn.vObj['_businessArrangement']);{q}
end;

procedure TFHIRJsonComposer.ComposeCoverageEligibilityRequestInsurance(json : TJSONWriter; name : string; elem : TFhirCoverageEligibilityRequestInsurance; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'focal', elem.focalElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'focal', elem.focalElement, false);
  ComposeReference{TFhirCoverage}(json, 'coverage', elem.coverage); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'businessArrangement', elem.businessArrangementElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'businessArrangement', elem.businessArrangementElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseCoverageEligibilityRequestItem(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCoverageEligibilityRequestItem(jsn)); {2}
end;

function TFHIRJsonParser.ParseCoverageEligibilityRequestItem(jsn : TJsonObject) : TFhirCoverageEligibilityRequestItem;
begin
  result := TFhirCoverageEligibilityRequestItem.create;
  try
    ParseCoverageEligibilityRequestItemProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCoverageEligibilityRequestItemProperties(jsn : TJsonObject; result : TFhirCoverageEligibilityRequestItem);
begin
    ParseBackboneElementProperties(jsn, result);
      if jsn.has('supportingInfoSequence') or jsn.has('_supportingInfoSequence') then
      iteratePrimitiveArray(jsn.vArr['supportingInfoSequence'], jsn.vArr['_supportingInfoSequence'], result.supportingInfoSequenceList, parsePositiveInt);
    if jsn.has('category') then
        result.category := ParseCodeableConcept(jsn.vObj['category']);{q3}
    if jsn.has('productOrService') then
        result.productOrService := ParseCodeableConcept(jsn.vObj['productOrService']);{q3}
    if jsn.has('modifier') then
      iterateArray(jsn.vArr['modifier'], result.modifierList, parseCodeableConcept);
    if jsn.has('provider') then
        result.provider := ParseReference{TFhirPractitioner}(jsn.vObj['provider']);{q3}
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q3}
    if jsn.has('unitPrice') then
        result.unitPrice := ParseMoney(jsn.vObj['unitPrice']);{q3}
    if jsn.has('facility') then
        result.facility := ParseReference{TFhirLocation}(jsn.vObj['facility']);{q3}
    if jsn.has('diagnosis') then
      iterateArray(jsn.vArr['diagnosis'], result.diagnosisList, parseCoverageEligibilityRequestItemDiagnosis);
    if jsn.has('detail') then
      iterateArray(jsn.vArr['detail'], result.detailList, parseReference{TFhirReference});
end;

procedure TFHIRJsonComposer.ComposeCoverageEligibilityRequestItem(json : TJSONWriter; name : string; elem : TFhirCoverageEligibilityRequestItem; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and (elem.supportingInfoSequenceList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.supportingInfoSequenceList.Count - 1 do
    begin
      ext := ext or ((elem.supportingInfoSequenceList[i].id <> '') or (elem.supportingInfoSequenceList[i].hasExtensionList) {no-comments or (elem.supportingInfoSequenceList[i].hasComments)});
      val := val or (elem.supportingInfoSequenceList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('supportingInfoSequence');
      for i := 0 to elem.supportingInfoSequenceList.Count - 1 do
        ComposePositiveIntValue(json, '',elem.supportingInfoSequenceList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_supportingInfoSequence');
      for i := 0 to elem.supportingInfoSequenceList.Count - 1 do
        ComposePositiveIntProps(json, '',elem.supportingInfoSequenceList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'category', elem.category); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'productOrService', elem.productOrService); {a}
  if (SummaryOption in [soFull, soData]) and (elem.modifierList.Count > 0) then
  begin
    json.valueArray('modifier');
    for i := 0 to elem.modifierList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.modifierList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirPractitioner}(json, 'provider', elem.provider); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'quantity', elem.quantity); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(json, 'unitPrice', elem.unitPrice); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirLocation}(json, 'facility', elem.facility); {a}
  if (SummaryOption in [soFull, soData]) and (elem.diagnosisList.Count > 0) then
  begin
    json.valueArray('diagnosis');
    for i := 0 to elem.diagnosisList.Count - 1 do
      ComposeCoverageEligibilityRequestItemDiagnosis(json, '', elem.diagnosisList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.detailList.Count > 0) then
  begin
    json.valueArray('detail');
    for i := 0 to elem.detailList.Count - 1 do
      ComposeReference{TFhirReference}(json, '', elem.detailList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseCoverageEligibilityRequestItemDiagnosis(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCoverageEligibilityRequestItemDiagnosis(jsn)); {2}
end;

function TFHIRJsonParser.ParseCoverageEligibilityRequestItemDiagnosis(jsn : TJsonObject) : TFhirCoverageEligibilityRequestItemDiagnosis;
begin
  result := TFhirCoverageEligibilityRequestItemDiagnosis.create;
  try
    ParseCoverageEligibilityRequestItemDiagnosisProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCoverageEligibilityRequestItemDiagnosisProperties(jsn : TJsonObject; result : TFhirCoverageEligibilityRequestItemDiagnosis);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('diagnosisCodeableConcept') {a4} then
      result.diagnosis := ParseCodeableConcept(jsn.vObj['diagnosisCodeableConcept']);
    if jsn.has('diagnosisReference') {a3} then
      result.diagnosis := ParseReference(jsn.vObj['diagnosisReference']);
end;

procedure TFHIRJsonComposer.ComposeCoverageEligibilityRequestItemDiagnosis(json : TJSONWriter; name : string; elem : TFhirCoverageEligibilityRequestItemDiagnosis; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and (elem.diagnosis is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'diagnosisCodeableConcept', TFhirCodeableConcept(elem.diagnosis)) 
  else if (SummaryOption in [soFull, soData]) and (elem.diagnosis is TFhirReference) then
    ComposeReference(json, 'diagnosisReference', TFhirReference(elem.diagnosis));
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseCoverageEligibilityRequest(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCoverageEligibilityRequest(jsn)); {2}
end;

function TFHIRJsonParser.ParseCoverageEligibilityRequest(jsn : TJsonObject) : TFhirCoverageEligibilityRequest;
begin
  result := TFhirCoverageEligibilityRequest.create;
  try
    ParseCoverageEligibilityRequestProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCoverageEligibilityRequestProperties(jsn : TJsonObject; result : TFhirCoverageEligibilityRequest);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirFmStatusEnum, SYSTEMS_TFhirFmStatusEnum);
    if jsn.has('priority') then
        result.priority := ParseCodeableConcept(jsn.vObj['priority']);{q3}
    if jsn.has('purpose') or jsn.has('_purpose') then
      iterateEnumArray(jsn.vArr['purpose'], jsn.vArr['_purpose'], jsn.path+'/purpose', result.purposeList, parseEnum, CODES_TFhirEligibilityrequestPurposeEnum, SYSTEMS_TFhirEligibilityrequestPurposeEnum);
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q3}
    if jsn.has('servicedPeriod') {a4} then
      result.serviced := ParsePeriod(jsn.vObj['servicedPeriod']);
    if jsn.has('servicedDate') or jsn.has('_servicedDate') then
      result.serviced := parseDate(jsn.node['servicedDate'], jsn.vObj['_servicedDate']);
    if jsn.has('created') or jsn.has('_created') then
        result.createdElement := parseDateTime(jsn.node['created'], jsn.vObj['_created']);{q}
    if jsn.has('enterer') then
        result.enterer := ParseReference{TFhirPractitioner}(jsn.vObj['enterer']);{q3}
    if jsn.has('provider') then
        result.provider := ParseReference{TFhirPractitioner}(jsn.vObj['provider']);{q3}
    if jsn.has('insurer') then
        result.insurer := ParseReference{TFhirOrganization}(jsn.vObj['insurer']);{q3}
    if jsn.has('facility') then
        result.facility := ParseReference{TFhirLocation}(jsn.vObj['facility']);{q3}
    if jsn.has('supportingInfo') then
      iterateArray(jsn.vArr['supportingInfo'], result.supportingInfoList, parseCoverageEligibilityRequestSupportingInfo);
    if jsn.has('insurance') then
      iterateArray(jsn.vArr['insurance'], result.insuranceList, parseCoverageEligibilityRequestInsurance);
    if jsn.has('item') then
      iterateArray(jsn.vArr['item'], result.itemList, parseCoverageEligibilityRequestItem);
end;

procedure TFHIRJsonComposer.ComposeCoverageEligibilityRequest(json : TJSONWriter; name : string; elem : TFhirCoverageEligibilityRequest; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirFmStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirFmStatusEnum, false);
  if (SummaryOption in [soFull, soData]) and doCompose('priority') then
    ComposeCodeableConcept(json, 'priority', elem.priority); {a}
  if (elem.purposeList.Count > 0) then
  begin
    val := false;
    ext := false;
    for i := 0 to elem.purposeList.Count - 1 do
    begin
      val := val or (elem.purposeList[i].hasPrimitiveValue);
      ext := ext or ((elem.purposeList[i].id <> '') or (elem.purposeList[i].hasExtensionList));
    end;
    if val then
    begin
      json.valueArray('purpose');
      for i := 0 to elem.purposeList.Count - 1 do
        ComposeEnumValue(json, '', elem.purposeList[i], CODES_TFhirEligibilityrequestPurposeEnum, true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_purpose');
      for i := 0 to elem.purposeList.Count - 1 do
        ComposeEnumProps(json, '', elem.purposeList[i], CODES_TFhirEligibilityrequestPurposeEnum, true);
      json.FinishArray;
    end;
  end;
    ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  if (SummaryOption in [soFull, soData]) and (elem.serviced is TFhirPeriod) then 
    ComposePeriod(json, 'servicedPeriod', TFhirPeriod(elem.serviced)) 
  else if (SummaryOption in [soFull, soData]) and (elem.serviced is TFhirDate) then 
  begin
    ComposeDateValue(json, 'servicedDate', TFhirDate(elem.serviced), false);
    ComposeDateProps(json, 'servicedDate', TFhirDate(elem.serviced), false);
  end;
    ComposeDateTimeValue(json, 'created', elem.createdElement, false);
    ComposeDateTimeProps(json, 'created', elem.createdElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('enterer') then
    ComposeReference{TFhirPractitioner}(json, 'enterer', elem.enterer); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('provider') then
    ComposeReference{TFhirPractitioner}(json, 'provider', elem.provider); {a}
    ComposeReference{TFhirOrganization}(json, 'insurer', elem.insurer); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('facility') then
    ComposeReference{TFhirLocation}(json, 'facility', elem.facility); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('supportingInfo') and (elem.supportingInfoList.Count > 0) then
  begin
    json.valueArray('supportingInfo');
    for i := 0 to elem.supportingInfoList.Count - 1 do
      ComposeCoverageEligibilityRequestSupportingInfo(json, '', elem.supportingInfoList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('insurance') and (elem.insuranceList.Count > 0) then
  begin
    json.valueArray('insurance');
    for i := 0 to elem.insuranceList.Count - 1 do
      ComposeCoverageEligibilityRequestInsurance(json, '', elem.insuranceList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('item') and (elem.itemList.Count > 0) then
  begin
    json.valueArray('item');
    for i := 0 to elem.itemList.Count - 1 do
      ComposeCoverageEligibilityRequestItem(json, '', elem.itemList[i]); {z - }
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_COVERAGEELIGIBILITYREQUEST}
{$IFDEF FHIR_COVERAGEELIGIBILITYRESPONSE}
procedure TFHIRJsonParser.ParseCoverageEligibilityResponseInsurance(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCoverageEligibilityResponseInsurance(jsn)); {2}
end;

function TFHIRJsonParser.ParseCoverageEligibilityResponseInsurance(jsn : TJsonObject) : TFhirCoverageEligibilityResponseInsurance;
begin
  result := TFhirCoverageEligibilityResponseInsurance.create;
  try
    ParseCoverageEligibilityResponseInsuranceProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCoverageEligibilityResponseInsuranceProperties(jsn : TJsonObject; result : TFhirCoverageEligibilityResponseInsurance);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('coverage') then
        result.coverage := ParseReference{TFhirCoverage}(jsn.vObj['coverage']);{q3}
    if jsn.has('inforce') or jsn.has('_inforce') then
        result.inforceElement := parseBoolean(jsn.node['inforce'], jsn.vObj['_inforce']);{q}
    if jsn.has('benefitPeriod') then
        result.benefitPeriod := ParsePeriod(jsn.vObj['benefitPeriod']);{q3}
    if jsn.has('item') then
      iterateArray(jsn.vArr['item'], result.itemList, parseCoverageEligibilityResponseInsuranceItem);
end;

procedure TFHIRJsonComposer.ComposeCoverageEligibilityResponseInsurance(json : TJSONWriter; name : string; elem : TFhirCoverageEligibilityResponseInsurance; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
    ComposeReference{TFhirCoverage}(json, 'coverage', elem.coverage); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'inforce', elem.inforceElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'inforce', elem.inforceElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(json, 'benefitPeriod', elem.benefitPeriod); {a}
  if (SummaryOption in [soFull, soData]) and (elem.itemList.Count > 0) then
  begin
    json.valueArray('item');
    for i := 0 to elem.itemList.Count - 1 do
      ComposeCoverageEligibilityResponseInsuranceItem(json, '', elem.itemList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseCoverageEligibilityResponseInsuranceItem(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCoverageEligibilityResponseInsuranceItem(jsn)); {2}
end;

function TFHIRJsonParser.ParseCoverageEligibilityResponseInsuranceItem(jsn : TJsonObject) : TFhirCoverageEligibilityResponseInsuranceItem;
begin
  result := TFhirCoverageEligibilityResponseInsuranceItem.create;
  try
    ParseCoverageEligibilityResponseInsuranceItemProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCoverageEligibilityResponseInsuranceItemProperties(jsn : TJsonObject; result : TFhirCoverageEligibilityResponseInsuranceItem);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('category') then
        result.category := ParseCodeableConcept(jsn.vObj['category']);{q3}
    if jsn.has('productOrService') then
        result.productOrService := ParseCodeableConcept(jsn.vObj['productOrService']);{q3}
    if jsn.has('modifier') then
      iterateArray(jsn.vArr['modifier'], result.modifierList, parseCodeableConcept);
    if jsn.has('provider') then
        result.provider := ParseReference{TFhirPractitioner}(jsn.vObj['provider']);{q3}
    if jsn.has('excluded') or jsn.has('_excluded') then
        result.excludedElement := parseBoolean(jsn.node['excluded'], jsn.vObj['_excluded']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('network') then
        result.network := ParseCodeableConcept(jsn.vObj['network']);{q3}
    if jsn.has('unit') then
        result.unit_ := ParseCodeableConcept(jsn.vObj['unit']);{q3}
    if jsn.has('term') then
        result.term := ParseCodeableConcept(jsn.vObj['term']);{q3}
    if jsn.has('benefit') then
      iterateArray(jsn.vArr['benefit'], result.benefitList, parseCoverageEligibilityResponseInsuranceItemBenefit);
    if jsn.has('authorizationRequired') or jsn.has('_authorizationRequired') then
        result.authorizationRequiredElement := parseBoolean(jsn.node['authorizationRequired'], jsn.vObj['_authorizationRequired']);{q}
    if jsn.has('authorizationSupporting') then
      iterateArray(jsn.vArr['authorizationSupporting'], result.authorizationSupportingList, parseCodeableConcept);
    if jsn.has('authorizationUrl') or jsn.has('_authorizationUrl') then
        result.authorizationUrlElement := parseUri(jsn.node['authorizationUrl'], jsn.vObj['_authorizationUrl']);{q}
end;

procedure TFHIRJsonComposer.ComposeCoverageEligibilityResponseInsuranceItem(json : TJSONWriter; name : string; elem : TFhirCoverageEligibilityResponseInsuranceItem; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'category', elem.category); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'productOrService', elem.productOrService); {a}
  if (SummaryOption in [soFull, soData]) and (elem.modifierList.Count > 0) then
  begin
    json.valueArray('modifier');
    for i := 0 to elem.modifierList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.modifierList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirPractitioner}(json, 'provider', elem.provider); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'excluded', elem.excludedElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'excluded', elem.excludedElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'network', elem.network); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'unit', elem.unit_); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'term', elem.term); {a}
  if (SummaryOption in [soFull, soData]) and (elem.benefitList.Count > 0) then
  begin
    json.valueArray('benefit');
    for i := 0 to elem.benefitList.Count - 1 do
      ComposeCoverageEligibilityResponseInsuranceItemBenefit(json, '', elem.benefitList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'authorizationRequired', elem.authorizationRequiredElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'authorizationRequired', elem.authorizationRequiredElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.authorizationSupportingList.Count > 0) then
  begin
    json.valueArray('authorizationSupporting');
    for i := 0 to elem.authorizationSupportingList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.authorizationSupportingList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeUriValue(json, 'authorizationUrl', elem.authorizationUrlElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeUriProps(json, 'authorizationUrl', elem.authorizationUrlElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseCoverageEligibilityResponseInsuranceItemBenefit(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCoverageEligibilityResponseInsuranceItemBenefit(jsn)); {2}
end;

function TFHIRJsonParser.ParseCoverageEligibilityResponseInsuranceItemBenefit(jsn : TJsonObject) : TFhirCoverageEligibilityResponseInsuranceItemBenefit;
begin
  result := TFhirCoverageEligibilityResponseInsuranceItemBenefit.create;
  try
    ParseCoverageEligibilityResponseInsuranceItemBenefitProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCoverageEligibilityResponseInsuranceItemBenefitProperties(jsn : TJsonObject; result : TFhirCoverageEligibilityResponseInsuranceItemBenefit);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('allowedUnsignedInt') or jsn.has('_allowedUnsignedInt') then
      result.allowed := parseUnsignedInt(jsn.node['allowedUnsignedInt'], jsn.vObj['_allowedUnsignedInt']);
    if jsn.has('allowedMoney') {a4} then
      result.allowed := ParseMoney(jsn.vObj['allowedMoney']);
    if jsn.has('allowedString') or jsn.has('_allowedString') then
      result.allowed := parseString(jsn.node['allowedString'], jsn.vObj['_allowedString']);
    if jsn.has('usedUnsignedInt') or jsn.has('_usedUnsignedInt') then
      result.used := parseUnsignedInt(jsn.node['usedUnsignedInt'], jsn.vObj['_usedUnsignedInt']);
    if jsn.has('usedMoney') {a4} then
      result.used := ParseMoney(jsn.vObj['usedMoney']);
    if jsn.has('usedString') or jsn.has('_usedString') then
      result.used := parseString(jsn.node['usedString'], jsn.vObj['_usedString']);
end;

procedure TFHIRJsonComposer.ComposeCoverageEligibilityResponseInsuranceItemBenefit(json : TJSONWriter; name : string; elem : TFhirCoverageEligibilityResponseInsuranceItemBenefit; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) and (elem.allowed is TFhirUnsignedInt) then 
  begin
    ComposeUnsignedIntValue(json, 'allowedUnsignedInt', TFhirUnsignedInt(elem.allowed), false);
    ComposeUnsignedIntProps(json, 'allowedUnsignedInt', TFhirUnsignedInt(elem.allowed), false);
  end
  else if (SummaryOption in [soFull, soData]) and (elem.allowed is TFhirMoney) then 
    ComposeMoney(json, 'allowedMoney', TFhirMoney(elem.allowed)) 
  else if (SummaryOption in [soFull, soData]) and (elem.allowed is TFhirString) then 
  begin
    ComposeStringValue(json, 'allowedString', TFhirString(elem.allowed), false);
    ComposeStringProps(json, 'allowedString', TFhirString(elem.allowed), false);
  end;
  if (SummaryOption in [soFull, soData]) and (elem.used is TFhirUnsignedInt) then 
  begin
    ComposeUnsignedIntValue(json, 'usedUnsignedInt', TFhirUnsignedInt(elem.used), false);
    ComposeUnsignedIntProps(json, 'usedUnsignedInt', TFhirUnsignedInt(elem.used), false);
  end
  else if (SummaryOption in [soFull, soData]) and (elem.used is TFhirMoney) then 
    ComposeMoney(json, 'usedMoney', TFhirMoney(elem.used)) 
  else if (SummaryOption in [soFull, soData]) and (elem.used is TFhirString) then 
  begin
    ComposeStringValue(json, 'usedString', TFhirString(elem.used), false);
    ComposeStringProps(json, 'usedString', TFhirString(elem.used), false);
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseCoverageEligibilityResponseError(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCoverageEligibilityResponseError(jsn)); {2}
end;

function TFHIRJsonParser.ParseCoverageEligibilityResponseError(jsn : TJsonObject) : TFhirCoverageEligibilityResponseError;
begin
  result := TFhirCoverageEligibilityResponseError.create;
  try
    ParseCoverageEligibilityResponseErrorProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCoverageEligibilityResponseErrorProperties(jsn : TJsonObject; result : TFhirCoverageEligibilityResponseError);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
end;

procedure TFHIRJsonComposer.ComposeCoverageEligibilityResponseError(json : TJSONWriter; name : string; elem : TFhirCoverageEligibilityResponseError; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseCoverageEligibilityResponse(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCoverageEligibilityResponse(jsn)); {2}
end;

function TFHIRJsonParser.ParseCoverageEligibilityResponse(jsn : TJsonObject) : TFhirCoverageEligibilityResponse;
begin
  result := TFhirCoverageEligibilityResponse.create;
  try
    ParseCoverageEligibilityResponseProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCoverageEligibilityResponseProperties(jsn : TJsonObject; result : TFhirCoverageEligibilityResponse);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirFmStatusEnum, SYSTEMS_TFhirFmStatusEnum);
    if jsn.has('purpose') or jsn.has('_purpose') then
      iterateEnumArray(jsn.vArr['purpose'], jsn.vArr['_purpose'], jsn.path+'/purpose', result.purposeList, parseEnum, CODES_TFhirEligibilityresponsePurposeEnum, SYSTEMS_TFhirEligibilityresponsePurposeEnum);
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q3}
    if jsn.has('servicedPeriod') {a4} then
      result.serviced := ParsePeriod(jsn.vObj['servicedPeriod']);
    if jsn.has('servicedDate') or jsn.has('_servicedDate') then
      result.serviced := parseDate(jsn.node['servicedDate'], jsn.vObj['_servicedDate']);
    if jsn.has('created') or jsn.has('_created') then
        result.createdElement := parseDateTime(jsn.node['created'], jsn.vObj['_created']);{q}
    if jsn.has('requestor') then
        result.requestor := ParseReference{TFhirPractitioner}(jsn.vObj['requestor']);{q3}
    if jsn.has('request') then
        result.request := ParseReference{TFhirCoverageEligibilityRequest}(jsn.vObj['request']);{q3}
    if jsn.has('outcome') or jsn.has('_outcome')  then
      result.outcomeElement := parseEnum(jsn.path+'/outcome', jsn.node['outcome'], jsn.vObj['_outcome'], CODES_TFhirRemittanceOutcomeEnum, SYSTEMS_TFhirRemittanceOutcomeEnum);
    if jsn.has('disposition') or jsn.has('_disposition') then
        result.dispositionElement := parseString(jsn.node['disposition'], jsn.vObj['_disposition']);{q}
    if jsn.has('insurer') then
        result.insurer := ParseReference{TFhirOrganization}(jsn.vObj['insurer']);{q3}
    if jsn.has('insurance') then
      iterateArray(jsn.vArr['insurance'], result.insuranceList, parseCoverageEligibilityResponseInsurance);
    if jsn.has('preAuthRef') or jsn.has('_preAuthRef') then
        result.preAuthRefElement := parseString(jsn.node['preAuthRef'], jsn.vObj['_preAuthRef']);{q}
    if jsn.has('form') then
        result.form := ParseCodeableConcept(jsn.vObj['form']);{q3}
    if jsn.has('error') then
      iterateArray(jsn.vArr['error'], result.errorList, parseCoverageEligibilityResponseError);
end;

procedure TFHIRJsonComposer.ComposeCoverageEligibilityResponse(json : TJSONWriter; name : string; elem : TFhirCoverageEligibilityResponse; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirFmStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirFmStatusEnum, false);
  if (elem.purposeList.Count > 0) then
  begin
    val := false;
    ext := false;
    for i := 0 to elem.purposeList.Count - 1 do
    begin
      val := val or (elem.purposeList[i].hasPrimitiveValue);
      ext := ext or ((elem.purposeList[i].id <> '') or (elem.purposeList[i].hasExtensionList));
    end;
    if val then
    begin
      json.valueArray('purpose');
      for i := 0 to elem.purposeList.Count - 1 do
        ComposeEnumValue(json, '', elem.purposeList[i], CODES_TFhirEligibilityresponsePurposeEnum, true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_purpose');
      for i := 0 to elem.purposeList.Count - 1 do
        ComposeEnumProps(json, '', elem.purposeList[i], CODES_TFhirEligibilityresponsePurposeEnum, true);
      json.FinishArray;
    end;
  end;
    ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  if (SummaryOption in [soFull, soData]) and (elem.serviced is TFhirPeriod) then 
    ComposePeriod(json, 'servicedPeriod', TFhirPeriod(elem.serviced)) 
  else if (SummaryOption in [soFull, soData]) and (elem.serviced is TFhirDate) then 
  begin
    ComposeDateValue(json, 'servicedDate', TFhirDate(elem.serviced), false);
    ComposeDateProps(json, 'servicedDate', TFhirDate(elem.serviced), false);
  end;
    ComposeDateTimeValue(json, 'created', elem.createdElement, false);
    ComposeDateTimeProps(json, 'created', elem.createdElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('requestor') then
    ComposeReference{TFhirPractitioner}(json, 'requestor', elem.requestor); {a}
    ComposeReference{TFhirCoverageEligibilityRequest}(json, 'request', elem.request); {a}
  ComposeEnumValue(json, 'outcome', elem.OutcomeElement, CODES_TFhirRemittanceOutcomeEnum, false);
  ComposeEnumProps(json, 'outcome', elem.OutcomeElement, CODES_TFhirRemittanceOutcomeEnum, false);
  if (SummaryOption in [soFull, soData]) and doCompose('disposition') then
    ComposeStringValue(json, 'disposition', elem.dispositionElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('disposition') then
    ComposeStringProps(json, 'disposition', elem.dispositionElement, false);
    ComposeReference{TFhirOrganization}(json, 'insurer', elem.insurer); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('insurance') and (elem.insuranceList.Count > 0) then
  begin
    json.valueArray('insurance');
    for i := 0 to elem.insuranceList.Count - 1 do
      ComposeCoverageEligibilityResponseInsurance(json, '', elem.insuranceList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('preAuthRef') then
    ComposeStringValue(json, 'preAuthRef', elem.preAuthRefElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('preAuthRef') then
    ComposeStringProps(json, 'preAuthRef', elem.preAuthRefElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('form') then
    ComposeCodeableConcept(json, 'form', elem.form); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('error') and (elem.errorList.Count > 0) then
  begin
    json.valueArray('error');
    for i := 0 to elem.errorList.Count - 1 do
      ComposeCoverageEligibilityResponseError(json, '', elem.errorList[i]); {z - }
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_COVERAGEELIGIBILITYRESPONSE}
{$IFDEF FHIR_DETECTEDISSUE}
procedure TFHIRJsonParser.ParseDetectedIssueEvidence(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDetectedIssueEvidence(jsn)); {2}
end;

function TFHIRJsonParser.ParseDetectedIssueEvidence(jsn : TJsonObject) : TFhirDetectedIssueEvidence;
begin
  result := TFhirDetectedIssueEvidence.create;
  try
    ParseDetectedIssueEvidenceProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseDetectedIssueEvidenceProperties(jsn : TJsonObject; result : TFhirDetectedIssueEvidence);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
      iterateArray(jsn.vArr['code'], result.codeList, parseCodeableConcept);
    if jsn.has('detail') then
      iterateArray(jsn.vArr['detail'], result.detailList, parseReference{TFhirReference});
end;

procedure TFHIRJsonComposer.ComposeDetectedIssueEvidence(json : TJSONWriter; name : string; elem : TFhirDetectedIssueEvidence; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and (elem.codeList.Count > 0) then
  begin
    json.valueArray('code');
    for i := 0 to elem.codeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.codeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.detailList.Count > 0) then
  begin
    json.valueArray('detail');
    for i := 0 to elem.detailList.Count - 1 do
      ComposeReference{TFhirReference}(json, '', elem.detailList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseDetectedIssueMitigation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDetectedIssueMitigation(jsn)); {2}
end;

function TFHIRJsonParser.ParseDetectedIssueMitigation(jsn : TJsonObject) : TFhirDetectedIssueMitigation;
begin
  result := TFhirDetectedIssueMitigation.create;
  try
    ParseDetectedIssueMitigationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseDetectedIssueMitigationProperties(jsn : TJsonObject; result : TFhirDetectedIssueMitigation);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('action') then
        result.action := ParseCodeableConcept(jsn.vObj['action']);{q3}
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := parseDateTime(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('author') then
        result.author := ParseReference{TFhirPractitioner}(jsn.vObj['author']);{q3}
end;

procedure TFHIRJsonComposer.ComposeDetectedIssueMitigation(json : TJSONWriter; name : string; elem : TFhirDetectedIssueMitigation; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'action', elem.action); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirPractitioner}(json, 'author', elem.author); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseDetectedIssue(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDetectedIssue(jsn)); {2}
end;

function TFHIRJsonParser.ParseDetectedIssue(jsn : TJsonObject) : TFhirDetectedIssue;
begin
  result := TFhirDetectedIssue.create;
  try
    ParseDetectedIssueProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseDetectedIssueProperties(jsn : TJsonObject; result : TFhirDetectedIssue);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirObservationStatusEnum, SYSTEMS_TFhirObservationStatusEnum);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('severity') or jsn.has('_severity')  then
      result.severityElement := parseEnum(jsn.path+'/severity', jsn.node['severity'], jsn.vObj['_severity'], CODES_TFhirDetectedissueSeverityEnum, SYSTEMS_TFhirDetectedissueSeverityEnum);
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q3}
    if jsn.has('identifiedPeriod') {a4} then
      result.identified := ParsePeriod(jsn.vObj['identifiedPeriod']);
    if jsn.has('identifiedDateTime') or jsn.has('_identifiedDateTime') then
      result.identified := parseDateTime(jsn.node['identifiedDateTime'], jsn.vObj['_identifiedDateTime']);
    if jsn.has('author') then
        result.author := ParseReference{TFhirPractitioner}(jsn.vObj['author']);{q3}
    if jsn.has('implicated') then
      iterateArray(jsn.vArr['implicated'], result.implicatedList, parseReference{TFhirReference});
    if jsn.has('evidence') then
      iterateArray(jsn.vArr['evidence'], result.evidenceList, parseDetectedIssueEvidence);
    if jsn.has('detail') or jsn.has('_detail') then
        result.detailElement := parseString(jsn.node['detail'], jsn.vObj['_detail']);{q}
    if jsn.has('reference') or jsn.has('_reference') then
        result.referenceElement := parseUri(jsn.node['reference'], jsn.vObj['_reference']);{q}
    if jsn.has('mitigation') then
      iterateArray(jsn.vArr['mitigation'], result.mitigationList, parseDetectedIssueMitigation);
end;

procedure TFHIRJsonComposer.ComposeDetectedIssue(json : TJSONWriter; name : string; elem : TFhirDetectedIssue; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirObservationStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirObservationStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') then
    ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('severity') then
    ComposeEnumValue(json, 'severity', elem.SeverityElement, CODES_TFhirDetectedissueSeverityEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('severity') then
    ComposeEnumProps(json, 'severity', elem.SeverityElement, CODES_TFhirDetectedissueSeverityEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('patient') then
    ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.identified is TFhirPeriod) then 
    ComposePeriod(json, 'identifiedPeriod', TFhirPeriod(elem.identified)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.identified is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'identifiedDateTime', TFhirDateTime(elem.identified), false);
    ComposeDateTimeProps(json, 'identifiedDateTime', TFhirDateTime(elem.identified), false);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('author') then
    ComposeReference{TFhirPractitioner}(json, 'author', elem.author); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('implicated') and (elem.implicatedList.Count > 0) then
  begin
    json.valueArray('implicated');
    for i := 0 to elem.implicatedList.Count - 1 do
      ComposeReference{TFhirReference}(json, '', elem.implicatedList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('evidence') and (elem.evidenceList.Count > 0) then
  begin
    json.valueArray('evidence');
    for i := 0 to elem.evidenceList.Count - 1 do
      ComposeDetectedIssueEvidence(json, '', elem.evidenceList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('detail') then
    ComposeStringValue(json, 'detail', elem.detailElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('detail') then
    ComposeStringProps(json, 'detail', elem.detailElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('reference') then
    ComposeUriValue(json, 'reference', elem.referenceElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('reference') then
    ComposeUriProps(json, 'reference', elem.referenceElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('mitigation') and (elem.mitigationList.Count > 0) then
  begin
    json.valueArray('mitigation');
    for i := 0 to elem.mitigationList.Count - 1 do
      ComposeDetectedIssueMitigation(json, '', elem.mitigationList[i]); {z - }
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_DETECTEDISSUE}
{$IFDEF FHIR_DEVICE}
procedure TFHIRJsonParser.ParseDeviceUdiCarrier(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDeviceUdiCarrier(jsn)); {2}
end;

function TFHIRJsonParser.ParseDeviceUdiCarrier(jsn : TJsonObject) : TFhirDeviceUdiCarrier;
begin
  result := TFhirDeviceUdiCarrier.create;
  try
    ParseDeviceUdiCarrierProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseDeviceUdiCarrierProperties(jsn : TJsonObject; result : TFhirDeviceUdiCarrier);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('deviceIdentifier') or jsn.has('_deviceIdentifier') then
        result.deviceIdentifierElement := parseString(jsn.node['deviceIdentifier'], jsn.vObj['_deviceIdentifier']);{q}
    if jsn.has('issuer') or jsn.has('_issuer') then
        result.issuerElement := parseUri(jsn.node['issuer'], jsn.vObj['_issuer']);{q}
    if jsn.has('jurisdiction') or jsn.has('_jurisdiction') then
        result.jurisdictionElement := parseUri(jsn.node['jurisdiction'], jsn.vObj['_jurisdiction']);{q}
    if jsn.has('carrierAIDC') or jsn.has('_carrierAIDC') then
        result.carrierAIDCElement := parseBase64Binary(jsn.node['carrierAIDC'], jsn.vObj['_carrierAIDC']);{q}
    if jsn.has('carrierHRF') or jsn.has('_carrierHRF') then
        result.carrierHRFElement := parseString(jsn.node['carrierHRF'], jsn.vObj['_carrierHRF']);{q}
    if jsn.has('entryType') or jsn.has('_entryType')  then
      result.entryTypeElement := parseEnum(jsn.path+'/entryType', jsn.node['entryType'], jsn.vObj['_entryType'], CODES_TFhirUdiEntryTypeEnum, SYSTEMS_TFhirUdiEntryTypeEnum);
end;

procedure TFHIRJsonComposer.ComposeDeviceUdiCarrier(json : TJSONWriter; name : string; elem : TFhirDeviceUdiCarrier; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'deviceIdentifier', elem.deviceIdentifierElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'deviceIdentifier', elem.deviceIdentifierElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeUriValue(json, 'issuer', elem.issuerElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeUriProps(json, 'issuer', elem.issuerElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeUriValue(json, 'jurisdiction', elem.jurisdictionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeUriProps(json, 'jurisdiction', elem.jurisdictionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBase64BinaryValue(json, 'carrierAIDC', elem.carrierAIDCElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBase64BinaryProps(json, 'carrierAIDC', elem.carrierAIDCElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'carrierHRF', elem.carrierHRFElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'carrierHRF', elem.carrierHRFElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumValue(json, 'entryType', elem.EntryTypeElement, CODES_TFhirUdiEntryTypeEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumProps(json, 'entryType', elem.EntryTypeElement, CODES_TFhirUdiEntryTypeEnum, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseDeviceDeviceName(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDeviceDeviceName(jsn)); {2}
end;

function TFHIRJsonParser.ParseDeviceDeviceName(jsn : TJsonObject) : TFhirDeviceDeviceName;
begin
  result := TFhirDeviceDeviceName.create;
  try
    ParseDeviceDeviceNameProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseDeviceDeviceNameProperties(jsn : TJsonObject; result : TFhirDeviceDeviceName);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn.node['type'], jsn.vObj['_type'], CODES_TFhirDeviceNametypeEnum, SYSTEMS_TFhirDeviceNametypeEnum);
end;

procedure TFHIRJsonComposer.ComposeDeviceDeviceName(json : TJSONWriter; name : string; elem : TFhirDeviceDeviceName; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'name', elem.nameElement, false);
  ComposeStringProps(json, 'name', elem.nameElement, false);
  ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirDeviceNametypeEnum, false);
  ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirDeviceNametypeEnum, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseDeviceSpecialization(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDeviceSpecialization(jsn)); {2}
end;

function TFHIRJsonParser.ParseDeviceSpecialization(jsn : TJsonObject) : TFhirDeviceSpecialization;
begin
  result := TFhirDeviceSpecialization.create;
  try
    ParseDeviceSpecializationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseDeviceSpecializationProperties(jsn : TJsonObject; result : TFhirDeviceSpecialization);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('systemType') then
        result.systemType := ParseCodeableConcept(jsn.vObj['systemType']);{q3}
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := parseString(jsn.node['version'], jsn.vObj['_version']);{q}
end;

procedure TFHIRJsonComposer.ComposeDeviceSpecialization(json : TJSONWriter; name : string; elem : TFhirDeviceSpecialization; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'systemType', elem.systemType); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'version', elem.versionElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseDeviceVersion(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDeviceVersion(jsn)); {2}
end;

function TFHIRJsonParser.ParseDeviceVersion(jsn : TJsonObject) : TFhirDeviceVersion;
begin
  result := TFhirDeviceVersion.create;
  try
    ParseDeviceVersionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseDeviceVersionProperties(jsn : TJsonObject; result : TFhirDeviceVersion);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('component') then
        result.component := ParseIdentifier(jsn.vObj['component']);{q3}
    if jsn.has('value') or jsn.has('_value') then
        result.valueElement := parseString(jsn.node['value'], jsn.vObj['_value']);{q}
end;

procedure TFHIRJsonComposer.ComposeDeviceVersion(json : TJSONWriter; name : string; elem : TFhirDeviceVersion; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(json, 'component', elem.component); {a}
  ComposeStringValue(json, 'value', elem.valueElement, false);
  ComposeStringProps(json, 'value', elem.valueElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseDeviceProperty(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDeviceProperty(jsn)); {2}
end;

function TFHIRJsonParser.ParseDeviceProperty(jsn : TJsonObject) : TFhirDeviceProperty;
begin
  result := TFhirDeviceProperty.create;
  try
    ParseDevicePropertyProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseDevicePropertyProperties(jsn : TJsonObject; result : TFhirDeviceProperty);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('valueQuantity') then
      iterateArray(jsn.vArr['valueQuantity'], result.valueQuantityList, parseQuantity);
    if jsn.has('valueCode') then
      iterateArray(jsn.vArr['valueCode'], result.valueCodeList, parseCodeableConcept);
end;

procedure TFHIRJsonComposer.ComposeDeviceProperty(json : TJSONWriter; name : string; elem : TFhirDeviceProperty; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) and (elem.valueQuantityList.Count > 0) then
  begin
    json.valueArray('valueQuantity');
    for i := 0 to elem.valueQuantityList.Count - 1 do
      ComposeQuantity(json, '', elem.valueQuantityList[i]); {z - Quantity}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.valueCodeList.Count > 0) then
  begin
    json.valueArray('valueCode');
    for i := 0 to elem.valueCodeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.valueCodeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseDevice(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDevice(jsn)); {2}
end;

function TFHIRJsonParser.ParseDevice(jsn : TJsonObject) : TFhirDevice;
begin
  result := TFhirDevice.create;
  try
    ParseDeviceProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseDeviceProperties(jsn : TJsonObject; result : TFhirDevice);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('definition') then
        result.definition := ParseReference{TFhirDeviceDefinition}(jsn.vObj['definition']);{q3}
    if jsn.has('udiCarrier') then
      iterateArray(jsn.vArr['udiCarrier'], result.udiCarrierList, parseDeviceUdiCarrier);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirDeviceStatusEnum, SYSTEMS_TFhirDeviceStatusEnum);
    if jsn.has('statusReason') then
      iterateArray(jsn.vArr['statusReason'], result.statusReasonList, parseCodeableConcept);
    if jsn.has('distinctIdentifier') or jsn.has('_distinctIdentifier') then
        result.distinctIdentifierElement := parseString(jsn.node['distinctIdentifier'], jsn.vObj['_distinctIdentifier']);{q}
    if jsn.has('manufacturer') or jsn.has('_manufacturer') then
        result.manufacturerElement := parseString(jsn.node['manufacturer'], jsn.vObj['_manufacturer']);{q}
    if jsn.has('manufactureDate') or jsn.has('_manufactureDate') then
        result.manufactureDateElement := parseDateTime(jsn.node['manufactureDate'], jsn.vObj['_manufactureDate']);{q}
    if jsn.has('expirationDate') or jsn.has('_expirationDate') then
        result.expirationDateElement := parseDateTime(jsn.node['expirationDate'], jsn.vObj['_expirationDate']);{q}
    if jsn.has('lotNumber') or jsn.has('_lotNumber') then
        result.lotNumberElement := parseString(jsn.node['lotNumber'], jsn.vObj['_lotNumber']);{q}
    if jsn.has('serialNumber') or jsn.has('_serialNumber') then
        result.serialNumberElement := parseString(jsn.node['serialNumber'], jsn.vObj['_serialNumber']);{q}
    if jsn.has('deviceName') then
      iterateArray(jsn.vArr['deviceName'], result.deviceNameList, parseDeviceDeviceName);
    if jsn.has('modelNumber') or jsn.has('_modelNumber') then
        result.modelNumberElement := parseString(jsn.node['modelNumber'], jsn.vObj['_modelNumber']);{q}
    if jsn.has('partNumber') or jsn.has('_partNumber') then
        result.partNumberElement := parseString(jsn.node['partNumber'], jsn.vObj['_partNumber']);{q}
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('specialization') then
      iterateArray(jsn.vArr['specialization'], result.specializationList, parseDeviceSpecialization);
    if jsn.has('version') then
      iterateArray(jsn.vArr['version'], result.versionList, parseDeviceVersion);
    if jsn.has('property') then
      iterateArray(jsn.vArr['property'], result.property_List, parseDeviceProperty);
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q3}
    if jsn.has('owner') then
        result.owner := ParseReference{TFhirOrganization}(jsn.vObj['owner']);{q3}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseContactPoint);
    if jsn.has('location') then
        result.location := ParseReference{TFhirLocation}(jsn.vObj['location']);{q3}
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := parseUri(jsn.node['url'], jsn.vObj['_url']);{q}
    if jsn.has('note') then
      iterateArray(jsn.vArr['note'], result.noteList, parseAnnotation);
    if jsn.has('safety') then
      iterateArray(jsn.vArr['safety'], result.safetyList, parseCodeableConcept);
    if jsn.has('parent') then
        result.parent := ParseReference{TFhirDevice}(jsn.vObj['parent']);{q3}
end;

procedure TFHIRJsonComposer.ComposeDevice(json : TJSONWriter; name : string; elem : TFhirDevice; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('definition') then
    ComposeReference{TFhirDeviceDefinition}(json, 'definition', elem.definition); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('udiCarrier') and (elem.udiCarrierList.Count > 0) then
  begin
    json.valueArray('udiCarrier');
    for i := 0 to elem.udiCarrierList.Count - 1 do
      ComposeDeviceUdiCarrier(json, '', elem.udiCarrierList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirDeviceStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirDeviceStatusEnum, false);
  if (SummaryOption in [soFull, soData]) and doCompose('statusReason') and (elem.statusReasonList.Count > 0) then
  begin
    json.valueArray('statusReason');
    for i := 0 to elem.statusReasonList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.statusReasonList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('distinctIdentifier') then
    ComposeStringValue(json, 'distinctIdentifier', elem.distinctIdentifierElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('distinctIdentifier') then
    ComposeStringProps(json, 'distinctIdentifier', elem.distinctIdentifierElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('manufacturer') then
    ComposeStringValue(json, 'manufacturer', elem.manufacturerElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('manufacturer') then
    ComposeStringProps(json, 'manufacturer', elem.manufacturerElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('manufactureDate') then
    ComposeDateTimeValue(json, 'manufactureDate', elem.manufactureDateElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('manufactureDate') then
    ComposeDateTimeProps(json, 'manufactureDate', elem.manufactureDateElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('expirationDate') then
    ComposeDateTimeValue(json, 'expirationDate', elem.expirationDateElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('expirationDate') then
    ComposeDateTimeProps(json, 'expirationDate', elem.expirationDateElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('lotNumber') then
    ComposeStringValue(json, 'lotNumber', elem.lotNumberElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('lotNumber') then
    ComposeStringProps(json, 'lotNumber', elem.lotNumberElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('serialNumber') then
    ComposeStringValue(json, 'serialNumber', elem.serialNumberElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('serialNumber') then
    ComposeStringProps(json, 'serialNumber', elem.serialNumberElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('deviceName') and (elem.deviceNameList.Count > 0) then
  begin
    json.valueArray('deviceName');
    for i := 0 to elem.deviceNameList.Count - 1 do
      ComposeDeviceDeviceName(json, '', elem.deviceNameList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('modelNumber') then
    ComposeStringValue(json, 'modelNumber', elem.modelNumberElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('modelNumber') then
    ComposeStringProps(json, 'modelNumber', elem.modelNumberElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('partNumber') then
    ComposeStringValue(json, 'partNumber', elem.partNumberElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('partNumber') then
    ComposeStringProps(json, 'partNumber', elem.partNumberElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('type_') then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('specialization') and (elem.specializationList.Count > 0) then
  begin
    json.valueArray('specialization');
    for i := 0 to elem.specializationList.Count - 1 do
      ComposeDeviceSpecialization(json, '', elem.specializationList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('version') and (elem.versionList.Count > 0) then
  begin
    json.valueArray('version');
    for i := 0 to elem.versionList.Count - 1 do
      ComposeDeviceVersion(json, '', elem.versionList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('property_') and (elem.property_List.Count > 0) then
  begin
    json.valueArray('property');
    for i := 0 to elem.property_List.Count - 1 do
      ComposeDeviceProperty(json, '', elem.property_List[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('patient') then
    ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('owner') then
    ComposeReference{TFhirOrganization}(json, 'owner', elem.owner); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('contact') and (elem.contactList.Count > 0) then
  begin
    json.valueArray('contact');
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactPoint(json, '', elem.contactList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('location') then
    ComposeReference{TFhirLocation}(json, 'location', elem.location); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('url') then
    ComposeUriValue(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('url') then
    ComposeUriProps(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('note') and (elem.noteList.Count > 0) then
  begin
    json.valueArray('note');
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(json, '', elem.noteList[i]); {z - Annotation}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('safety') and (elem.safetyList.Count > 0) then
  begin
    json.valueArray('safety');
    for i := 0 to elem.safetyList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.safetyList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('parent') then
    ComposeReference{TFhirDevice}(json, 'parent', elem.parent); {a}
end;

{$ENDIF FHIR_DEVICE}
{$IFDEF FHIR_DEVICEDEFINITION}
procedure TFHIRJsonParser.ParseDeviceDefinitionUdiDeviceIdentifier(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDeviceDefinitionUdiDeviceIdentifier(jsn)); {2}
end;

function TFHIRJsonParser.ParseDeviceDefinitionUdiDeviceIdentifier(jsn : TJsonObject) : TFhirDeviceDefinitionUdiDeviceIdentifier;
begin
  result := TFhirDeviceDefinitionUdiDeviceIdentifier.create;
  try
    ParseDeviceDefinitionUdiDeviceIdentifierProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseDeviceDefinitionUdiDeviceIdentifierProperties(jsn : TJsonObject; result : TFhirDeviceDefinitionUdiDeviceIdentifier);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('deviceIdentifier') or jsn.has('_deviceIdentifier') then
        result.deviceIdentifierElement := parseString(jsn.node['deviceIdentifier'], jsn.vObj['_deviceIdentifier']);{q}
    if jsn.has('issuer') or jsn.has('_issuer') then
        result.issuerElement := parseUri(jsn.node['issuer'], jsn.vObj['_issuer']);{q}
    if jsn.has('jurisdiction') or jsn.has('_jurisdiction') then
        result.jurisdictionElement := parseUri(jsn.node['jurisdiction'], jsn.vObj['_jurisdiction']);{q}
end;

procedure TFHIRJsonComposer.ComposeDeviceDefinitionUdiDeviceIdentifier(json : TJSONWriter; name : string; elem : TFhirDeviceDefinitionUdiDeviceIdentifier; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'deviceIdentifier', elem.deviceIdentifierElement, false);
  ComposeStringProps(json, 'deviceIdentifier', elem.deviceIdentifierElement, false);
  ComposeUriValue(json, 'issuer', elem.issuerElement, false);
  ComposeUriProps(json, 'issuer', elem.issuerElement, false);
  ComposeUriValue(json, 'jurisdiction', elem.jurisdictionElement, false);
  ComposeUriProps(json, 'jurisdiction', elem.jurisdictionElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseDeviceDefinitionDeviceName(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDeviceDefinitionDeviceName(jsn)); {2}
end;

function TFHIRJsonParser.ParseDeviceDefinitionDeviceName(jsn : TJsonObject) : TFhirDeviceDefinitionDeviceName;
begin
  result := TFhirDeviceDefinitionDeviceName.create;
  try
    ParseDeviceDefinitionDeviceNameProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseDeviceDefinitionDeviceNameProperties(jsn : TJsonObject; result : TFhirDeviceDefinitionDeviceName);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn.node['type'], jsn.vObj['_type'], CODES_TFhirDeviceNametypeEnum, SYSTEMS_TFhirDeviceNametypeEnum);
end;

procedure TFHIRJsonComposer.ComposeDeviceDefinitionDeviceName(json : TJSONWriter; name : string; elem : TFhirDeviceDefinitionDeviceName; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'name', elem.nameElement, false);
  ComposeStringProps(json, 'name', elem.nameElement, false);
  ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirDeviceNametypeEnum, false);
  ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirDeviceNametypeEnum, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseDeviceDefinitionSpecialization(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDeviceDefinitionSpecialization(jsn)); {2}
end;

function TFHIRJsonParser.ParseDeviceDefinitionSpecialization(jsn : TJsonObject) : TFhirDeviceDefinitionSpecialization;
begin
  result := TFhirDeviceDefinitionSpecialization.create;
  try
    ParseDeviceDefinitionSpecializationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseDeviceDefinitionSpecializationProperties(jsn : TJsonObject; result : TFhirDeviceDefinitionSpecialization);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('systemType') or jsn.has('_systemType') then
        result.systemTypeElement := parseString(jsn.node['systemType'], jsn.vObj['_systemType']);{q}
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := parseString(jsn.node['version'], jsn.vObj['_version']);{q}
end;

procedure TFHIRJsonComposer.ComposeDeviceDefinitionSpecialization(json : TJSONWriter; name : string; elem : TFhirDeviceDefinitionSpecialization; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'systemType', elem.systemTypeElement, false);
  ComposeStringProps(json, 'systemType', elem.systemTypeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'version', elem.versionElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseDeviceDefinitionCapability(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDeviceDefinitionCapability(jsn)); {2}
end;

function TFHIRJsonParser.ParseDeviceDefinitionCapability(jsn : TJsonObject) : TFhirDeviceDefinitionCapability;
begin
  result := TFhirDeviceDefinitionCapability.create;
  try
    ParseDeviceDefinitionCapabilityProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseDeviceDefinitionCapabilityProperties(jsn : TJsonObject; result : TFhirDeviceDefinitionCapability);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('description') then
      iterateArray(jsn.vArr['description'], result.descriptionList, parseCodeableConcept);
end;

procedure TFHIRJsonComposer.ComposeDeviceDefinitionCapability(json : TJSONWriter; name : string; elem : TFhirDeviceDefinitionCapability; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) and (elem.descriptionList.Count > 0) then
  begin
    json.valueArray('description');
    for i := 0 to elem.descriptionList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.descriptionList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseDeviceDefinitionProperty(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDeviceDefinitionProperty(jsn)); {2}
end;

function TFHIRJsonParser.ParseDeviceDefinitionProperty(jsn : TJsonObject) : TFhirDeviceDefinitionProperty;
begin
  result := TFhirDeviceDefinitionProperty.create;
  try
    ParseDeviceDefinitionPropertyProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseDeviceDefinitionPropertyProperties(jsn : TJsonObject; result : TFhirDeviceDefinitionProperty);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('valueQuantity') then
      iterateArray(jsn.vArr['valueQuantity'], result.valueQuantityList, parseQuantity);
    if jsn.has('valueCode') then
      iterateArray(jsn.vArr['valueCode'], result.valueCodeList, parseCodeableConcept);
end;

procedure TFHIRJsonComposer.ComposeDeviceDefinitionProperty(json : TJSONWriter; name : string; elem : TFhirDeviceDefinitionProperty; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) and (elem.valueQuantityList.Count > 0) then
  begin
    json.valueArray('valueQuantity');
    for i := 0 to elem.valueQuantityList.Count - 1 do
      ComposeQuantity(json, '', elem.valueQuantityList[i]); {z - Quantity}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.valueCodeList.Count > 0) then
  begin
    json.valueArray('valueCode');
    for i := 0 to elem.valueCodeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.valueCodeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseDeviceDefinitionMaterial(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDeviceDefinitionMaterial(jsn)); {2}
end;

function TFHIRJsonParser.ParseDeviceDefinitionMaterial(jsn : TJsonObject) : TFhirDeviceDefinitionMaterial;
begin
  result := TFhirDeviceDefinitionMaterial.create;
  try
    ParseDeviceDefinitionMaterialProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseDeviceDefinitionMaterialProperties(jsn : TJsonObject; result : TFhirDeviceDefinitionMaterial);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('substance') then
        result.substance := ParseCodeableConcept(jsn.vObj['substance']);{q3}
    if jsn.has('alternate') or jsn.has('_alternate') then
        result.alternateElement := parseBoolean(jsn.node['alternate'], jsn.vObj['_alternate']);{q}
    if jsn.has('allergenicIndicator') or jsn.has('_allergenicIndicator') then
        result.allergenicIndicatorElement := parseBoolean(jsn.node['allergenicIndicator'], jsn.vObj['_allergenicIndicator']);{q}
end;

procedure TFHIRJsonComposer.ComposeDeviceDefinitionMaterial(json : TJSONWriter; name : string; elem : TFhirDeviceDefinitionMaterial; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'substance', elem.substance); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'alternate', elem.alternateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'alternate', elem.alternateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'allergenicIndicator', elem.allergenicIndicatorElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'allergenicIndicator', elem.allergenicIndicatorElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseDeviceDefinition(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDeviceDefinition(jsn)); {2}
end;

function TFHIRJsonParser.ParseDeviceDefinition(jsn : TJsonObject) : TFhirDeviceDefinition;
begin
  result := TFhirDeviceDefinition.create;
  try
    ParseDeviceDefinitionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseDeviceDefinitionProperties(jsn : TJsonObject; result : TFhirDeviceDefinition);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('udiDeviceIdentifier') then
      iterateArray(jsn.vArr['udiDeviceIdentifier'], result.udiDeviceIdentifierList, parseDeviceDefinitionUdiDeviceIdentifier);
    if jsn.has('manufacturerReference') {a3} then
      result.manufacturer := ParseReference(jsn.vObj['manufacturerReference']);
    if jsn.has('manufacturerString') or jsn.has('_manufacturerString') then
      result.manufacturer := parseString(jsn.node['manufacturerString'], jsn.vObj['_manufacturerString']);
    if jsn.has('deviceName') then
      iterateArray(jsn.vArr['deviceName'], result.deviceNameList, parseDeviceDefinitionDeviceName);
    if jsn.has('modelNumber') or jsn.has('_modelNumber') then
        result.modelNumberElement := parseString(jsn.node['modelNumber'], jsn.vObj['_modelNumber']);{q}
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('specialization') then
      iterateArray(jsn.vArr['specialization'], result.specializationList, parseDeviceDefinitionSpecialization);
      if jsn.has('version') or jsn.has('_version') then
      iteratePrimitiveArray(jsn.vArr['version'], jsn.vArr['_version'], result.versionList, parseString);
    if jsn.has('safety') then
      iterateArray(jsn.vArr['safety'], result.safetyList, parseCodeableConcept);
    if jsn.has('shelfLifeStorage') then
      iterateArray(jsn.vArr['shelfLifeStorage'], result.shelfLifeStorageList, parseProductShelfLife);
    if jsn.has('physicalCharacteristics') then
        result.physicalCharacteristics := ParseProdCharacteristic(jsn.vObj['physicalCharacteristics']);{q3}
    if jsn.has('languageCode') then
      iterateArray(jsn.vArr['languageCode'], result.languageCodeList, parseCodeableConcept);
    if jsn.has('capability') then
      iterateArray(jsn.vArr['capability'], result.capabilityList, parseDeviceDefinitionCapability);
    if jsn.has('property') then
      iterateArray(jsn.vArr['property'], result.property_List, parseDeviceDefinitionProperty);
    if jsn.has('owner') then
        result.owner := ParseReference{TFhirOrganization}(jsn.vObj['owner']);{q3}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseContactPoint);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := parseUri(jsn.node['url'], jsn.vObj['_url']);{q}
    if jsn.has('onlineInformation') or jsn.has('_onlineInformation') then
        result.onlineInformationElement := parseUri(jsn.node['onlineInformation'], jsn.vObj['_onlineInformation']);{q}
    if jsn.has('note') then
      iterateArray(jsn.vArr['note'], result.noteList, parseAnnotation);
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q3}
    if jsn.has('parentDevice') then
        result.parentDevice := ParseReference{TFhirDeviceDefinition}(jsn.vObj['parentDevice']);{q3}
    if jsn.has('material') then
      iterateArray(jsn.vArr['material'], result.materialList, parseDeviceDefinitionMaterial);
end;

procedure TFHIRJsonComposer.ComposeDeviceDefinition(json : TJSONWriter; name : string; elem : TFhirDeviceDefinition; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('udiDeviceIdentifier') and (elem.udiDeviceIdentifierList.Count > 0) then
  begin
    json.valueArray('udiDeviceIdentifier');
    for i := 0 to elem.udiDeviceIdentifierList.Count - 1 do
      ComposeDeviceDefinitionUdiDeviceIdentifier(json, '', elem.udiDeviceIdentifierList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.manufacturer is TFhirReference) then
    ComposeReference(json, 'manufacturerReference', TFhirReference(elem.manufacturer))
  else if (SummaryOption in [soFull, soData]) and (elem.manufacturer is TFhirString) then 
  begin
    ComposeStringValue(json, 'manufacturerString', TFhirString(elem.manufacturer), false);
    ComposeStringProps(json, 'manufacturerString', TFhirString(elem.manufacturer), false);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('deviceName') and (elem.deviceNameList.Count > 0) then
  begin
    json.valueArray('deviceName');
    for i := 0 to elem.deviceNameList.Count - 1 do
      ComposeDeviceDefinitionDeviceName(json, '', elem.deviceNameList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('modelNumber') then
    ComposeStringValue(json, 'modelNumber', elem.modelNumberElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('modelNumber') then
    ComposeStringProps(json, 'modelNumber', elem.modelNumberElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('type_') then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('specialization') and (elem.specializationList.Count > 0) then
  begin
    json.valueArray('specialization');
    for i := 0 to elem.specializationList.Count - 1 do
      ComposeDeviceDefinitionSpecialization(json, '', elem.specializationList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('version') and (elem.versionList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.versionList.Count - 1 do
    begin
      ext := ext or ((elem.versionList[i].id <> '') or (elem.versionList[i].hasExtensionList) {no-comments or (elem.versionList[i].hasComments)});
      val := val or (elem.versionList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('version');
      for i := 0 to elem.versionList.Count - 1 do
        ComposeStringValue(json, '',elem.versionList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_version');
      for i := 0 to elem.versionList.Count - 1 do
        ComposeStringProps(json, '',elem.versionList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('safety') and (elem.safetyList.Count > 0) then
  begin
    json.valueArray('safety');
    for i := 0 to elem.safetyList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.safetyList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('shelfLifeStorage') and (elem.shelfLifeStorageList.Count > 0) then
  begin
    json.valueArray('shelfLifeStorage');
    for i := 0 to elem.shelfLifeStorageList.Count - 1 do
      ComposeProductShelfLife(json, '', elem.shelfLifeStorageList[i]); {z - ProductShelfLife}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('physicalCharacteristics') then
    ComposeProdCharacteristic(json, 'physicalCharacteristics', elem.physicalCharacteristics); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('languageCode') and (elem.languageCodeList.Count > 0) then
  begin
    json.valueArray('languageCode');
    for i := 0 to elem.languageCodeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.languageCodeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('capability') and (elem.capabilityList.Count > 0) then
  begin
    json.valueArray('capability');
    for i := 0 to elem.capabilityList.Count - 1 do
      ComposeDeviceDefinitionCapability(json, '', elem.capabilityList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('property_') and (elem.property_List.Count > 0) then
  begin
    json.valueArray('property');
    for i := 0 to elem.property_List.Count - 1 do
      ComposeDeviceDefinitionProperty(json, '', elem.property_List[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('owner') then
    ComposeReference{TFhirOrganization}(json, 'owner', elem.owner); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('contact') and (elem.contactList.Count > 0) then
  begin
    json.valueArray('contact');
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactPoint(json, '', elem.contactList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('url') then
    ComposeUriValue(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('url') then
    ComposeUriProps(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('onlineInformation') then
    ComposeUriValue(json, 'onlineInformation', elem.onlineInformationElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('onlineInformation') then
    ComposeUriProps(json, 'onlineInformation', elem.onlineInformationElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('note') and (elem.noteList.Count > 0) then
  begin
    json.valueArray('note');
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(json, '', elem.noteList[i]); {z - Annotation}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('quantity') then
    ComposeQuantity(json, 'quantity', elem.quantity); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('parentDevice') then
    ComposeReference{TFhirDeviceDefinition}(json, 'parentDevice', elem.parentDevice); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('material') and (elem.materialList.Count > 0) then
  begin
    json.valueArray('material');
    for i := 0 to elem.materialList.Count - 1 do
      ComposeDeviceDefinitionMaterial(json, '', elem.materialList[i]); {z - }
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_DEVICEDEFINITION}
{$IFDEF FHIR_DEVICEMETRIC}
procedure TFHIRJsonParser.ParseDeviceMetricCalibration(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDeviceMetricCalibration(jsn)); {2}
end;

function TFHIRJsonParser.ParseDeviceMetricCalibration(jsn : TJsonObject) : TFhirDeviceMetricCalibration;
begin
  result := TFhirDeviceMetricCalibration.create;
  try
    ParseDeviceMetricCalibrationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseDeviceMetricCalibrationProperties(jsn : TJsonObject; result : TFhirDeviceMetricCalibration);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn.node['type'], jsn.vObj['_type'], CODES_TFhirMetricCalibrationTypeEnum, SYSTEMS_TFhirMetricCalibrationTypeEnum);
    if jsn.has('state') or jsn.has('_state')  then
      result.stateElement := parseEnum(jsn.path+'/state', jsn.node['state'], jsn.vObj['_state'], CODES_TFhirMetricCalibrationStateEnum, SYSTEMS_TFhirMetricCalibrationStateEnum);
    if jsn.has('time') or jsn.has('_time') then
        result.timeElement := parseInstant(jsn.node['time'], jsn.vObj['_time']);{q}
end;

procedure TFHIRJsonComposer.ComposeDeviceMetricCalibration(json : TJSONWriter; name : string; elem : TFhirDeviceMetricCalibration; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirMetricCalibrationTypeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirMetricCalibrationTypeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnumValue(json, 'state', elem.StateElement, CODES_TFhirMetricCalibrationStateEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnumProps(json, 'state', elem.StateElement, CODES_TFhirMetricCalibrationStateEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstantValue(json, 'time', elem.timeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstantProps(json, 'time', elem.timeElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseDeviceMetric(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDeviceMetric(jsn)); {2}
end;

function TFHIRJsonParser.ParseDeviceMetric(jsn : TJsonObject) : TFhirDeviceMetric;
begin
  result := TFhirDeviceMetric.create;
  try
    ParseDeviceMetricProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseDeviceMetricProperties(jsn : TJsonObject; result : TFhirDeviceMetric);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('unit') then
        result.unit_ := ParseCodeableConcept(jsn.vObj['unit']);{q3}
    if jsn.has('source') then
        result.source := ParseReference{TFhirDevice}(jsn.vObj['source']);{q3}
    if jsn.has('parent') then
        result.parent := ParseReference{TFhirDevice}(jsn.vObj['parent']);{q3}
    if jsn.has('operationalStatus') or jsn.has('_operationalStatus')  then
      result.operationalStatusElement := parseEnum(jsn.path+'/operationalStatus', jsn.node['operationalStatus'], jsn.vObj['_operationalStatus'], CODES_TFhirMetricOperationalStatusEnum, SYSTEMS_TFhirMetricOperationalStatusEnum);
    if jsn.has('color') or jsn.has('_color')  then
      result.colorElement := parseEnum(jsn.path+'/color', jsn.node['color'], jsn.vObj['_color'], CODES_TFhirMetricColorEnum, SYSTEMS_TFhirMetricColorEnum);
    if jsn.has('category') or jsn.has('_category')  then
      result.categoryElement := parseEnum(jsn.path+'/category', jsn.node['category'], jsn.vObj['_category'], CODES_TFhirMetricCategoryEnum, SYSTEMS_TFhirMetricCategoryEnum);
    if jsn.has('measurementPeriod') then
        result.measurementPeriod := ParseTiming(jsn.vObj['measurementPeriod']);{q3}
    if jsn.has('calibration') then
      iterateArray(jsn.vArr['calibration'], result.calibrationList, parseDeviceMetricCalibration);
end;

procedure TFHIRJsonComposer.ComposeDeviceMetric(json : TJSONWriter; name : string; elem : TFhirDeviceMetric; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('unit_') then
    ComposeCodeableConcept(json, 'unit', elem.unit_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('source') then
    ComposeReference{TFhirDevice}(json, 'source', elem.source); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('parent') then
    ComposeReference{TFhirDevice}(json, 'parent', elem.parent); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('operationalStatus') then
    ComposeEnumValue(json, 'operationalStatus', elem.OperationalStatusElement, CODES_TFhirMetricOperationalStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('operationalStatus') then
    ComposeEnumProps(json, 'operationalStatus', elem.OperationalStatusElement, CODES_TFhirMetricOperationalStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('color') then
    ComposeEnumValue(json, 'color', elem.ColorElement, CODES_TFhirMetricColorEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('color') then
    ComposeEnumProps(json, 'color', elem.ColorElement, CODES_TFhirMetricColorEnum, false);
  ComposeEnumValue(json, 'category', elem.CategoryElement, CODES_TFhirMetricCategoryEnum, false);
  ComposeEnumProps(json, 'category', elem.CategoryElement, CODES_TFhirMetricCategoryEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('measurementPeriod') then
    ComposeTiming(json, 'measurementPeriod', elem.measurementPeriod); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('calibration') and (elem.calibrationList.Count > 0) then
  begin
    json.valueArray('calibration');
    for i := 0 to elem.calibrationList.Count - 1 do
      ComposeDeviceMetricCalibration(json, '', elem.calibrationList[i]); {z - }
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_DEVICEMETRIC}
{$IFDEF FHIR_DEVICEREQUEST}
procedure TFHIRJsonParser.ParseDeviceRequestParameter(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDeviceRequestParameter(jsn)); {2}
end;

function TFHIRJsonParser.ParseDeviceRequestParameter(jsn : TJsonObject) : TFhirDeviceRequestParameter;
begin
  result := TFhirDeviceRequestParameter.create;
  try
    ParseDeviceRequestParameterProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseDeviceRequestParameterProperties(jsn : TJsonObject; result : TFhirDeviceRequestParameter);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('valueCodeableConcept') {a4} then
      result.value := ParseCodeableConcept(jsn.vObj['valueCodeableConcept']);
    if jsn.has('valueQuantity') {a4} then
      result.value := ParseQuantity(jsn.vObj['valueQuantity']);
    if jsn.has('valueRange') {a4} then
      result.value := ParseRange(jsn.vObj['valueRange']);
    if jsn.has('valueBoolean') or jsn.has('_valueBoolean') then
      result.value := parseBoolean(jsn.node['valueBoolean'], jsn.vObj['_valueBoolean']);
end;

procedure TFHIRJsonComposer.ComposeDeviceRequestParameter(json : TJSONWriter; name : string; elem : TFhirDeviceRequestParameter; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soData]) and (elem.value is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'valueCodeableConcept', TFhirCodeableConcept(elem.value)) 
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirQuantity) then 
    ComposeQuantity(json, 'valueQuantity', TFhirQuantity(elem.value)) 
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirRange) then 
    ComposeRange(json, 'valueRange', TFhirRange(elem.value)) 
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'valueBoolean', TFhirBoolean(elem.value), false);
    ComposeBooleanProps(json, 'valueBoolean', TFhirBoolean(elem.value), false);
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseDeviceRequest(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDeviceRequest(jsn)); {2}
end;

function TFHIRJsonParser.ParseDeviceRequest(jsn : TJsonObject) : TFhirDeviceRequest;
begin
  result := TFhirDeviceRequest.create;
  try
    ParseDeviceRequestProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseDeviceRequestProperties(jsn : TJsonObject; result : TFhirDeviceRequest);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
      if jsn.has('instantiatesCanonical') or jsn.has('_instantiatesCanonical') then
      iteratePrimitiveArray(jsn.vArr['instantiatesCanonical'], jsn.vArr['_instantiatesCanonical'], result.instantiatesCanonicalList, parseCanonical);
      if jsn.has('instantiatesUri') or jsn.has('_instantiatesUri') then
      iteratePrimitiveArray(jsn.vArr['instantiatesUri'], jsn.vArr['_instantiatesUri'], result.instantiatesUriList, parseUri);
    if jsn.has('basedOn') then
      iterateArray(jsn.vArr['basedOn'], result.basedOnList, parseReference{TFhirReference});
    if jsn.has('priorRequest') then
      iterateArray(jsn.vArr['priorRequest'], result.priorRequestList, parseReference{TFhirReference});
    if jsn.has('groupIdentifier') then
        result.groupIdentifier := ParseIdentifier(jsn.vObj['groupIdentifier']);{q3}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirRequestStatusEnum, SYSTEMS_TFhirRequestStatusEnum);
    if jsn.has('intent') or jsn.has('_intent')  then
      result.intentElement := parseEnum(jsn.path+'/intent', jsn.node['intent'], jsn.vObj['_intent'], CODES_TFhirRequestIntentEnum, SYSTEMS_TFhirRequestIntentEnum);
    if jsn.has('priority') or jsn.has('_priority')  then
      result.priorityElement := parseEnum(jsn.path+'/priority', jsn.node['priority'], jsn.vObj['_priority'], CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum);
    if jsn.has('codeReference') {a3} then
      result.code := ParseReference(jsn.vObj['codeReference']);
    if jsn.has('codeCodeableConcept') {a4} then
      result.code := ParseCodeableConcept(jsn.vObj['codeCodeableConcept']);
    if jsn.has('parameter') then
      iterateArray(jsn.vArr['parameter'], result.parameterList, parseDeviceRequestParameter);
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirPatient}(jsn.vObj['subject']);{q3}
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q3}
    if jsn.has('occurrencePeriod') {a4} then
      result.occurrence := ParsePeriod(jsn.vObj['occurrencePeriod']);
    if jsn.has('occurrenceTiming') {a4} then
      result.occurrence := ParseTiming(jsn.vObj['occurrenceTiming']);
    if jsn.has('occurrenceDateTime') or jsn.has('_occurrenceDateTime') then
      result.occurrence := parseDateTime(jsn.node['occurrenceDateTime'], jsn.vObj['_occurrenceDateTime']);
    if jsn.has('authoredOn') or jsn.has('_authoredOn') then
        result.authoredOnElement := parseDateTime(jsn.node['authoredOn'], jsn.vObj['_authoredOn']);{q}
    if jsn.has('requester') then
        result.requester := ParseReference{TFhirDevice}(jsn.vObj['requester']);{q3}
    if jsn.has('performerType') then
        result.performerType := ParseCodeableConcept(jsn.vObj['performerType']);{q3}
    if jsn.has('performer') then
        result.performer := ParseReference{TFhirPractitioner}(jsn.vObj['performer']);{q3}
    if jsn.has('reasonCode') then
      iterateArray(jsn.vArr['reasonCode'], result.reasonCodeList, parseCodeableConcept);
    if jsn.has('reasonReference') then
      iterateArray(jsn.vArr['reasonReference'], result.reasonReferenceList, parseReference{TFhirCondition});
    if jsn.has('insurance') then
      iterateArray(jsn.vArr['insurance'], result.insuranceList, parseReference{TFhirCoverage});
    if jsn.has('supportingInfo') then
      iterateArray(jsn.vArr['supportingInfo'], result.supportingInfoList, parseReference{TFhirReference});
    if jsn.has('note') then
      iterateArray(jsn.vArr['note'], result.noteList, parseAnnotation);
    if jsn.has('relevantHistory') then
      iterateArray(jsn.vArr['relevantHistory'], result.relevantHistoryList, parseReference{TFhirProvenance});
end;

procedure TFHIRJsonComposer.ComposeDeviceRequest(json : TJSONWriter; name : string; elem : TFhirDeviceRequest; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('instantiatesCanonical') and (elem.instantiatesCanonicalList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.instantiatesCanonicalList.Count - 1 do
    begin
      ext := ext or ((elem.instantiatesCanonicalList[i].id <> '') or (elem.instantiatesCanonicalList[i].hasExtensionList) {no-comments or (elem.instantiatesCanonicalList[i].hasComments)});
      val := val or (elem.instantiatesCanonicalList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('instantiatesCanonical');
      for i := 0 to elem.instantiatesCanonicalList.Count - 1 do
        ComposeCanonicalValue(json, '',elem.instantiatesCanonicalList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_instantiatesCanonical');
      for i := 0 to elem.instantiatesCanonicalList.Count - 1 do
        ComposeCanonicalProps(json, '',elem.instantiatesCanonicalList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('instantiatesUri') and (elem.instantiatesUriList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.instantiatesUriList.Count - 1 do
    begin
      ext := ext or ((elem.instantiatesUriList[i].id <> '') or (elem.instantiatesUriList[i].hasExtensionList) {no-comments or (elem.instantiatesUriList[i].hasComments)});
      val := val or (elem.instantiatesUriList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('instantiatesUri');
      for i := 0 to elem.instantiatesUriList.Count - 1 do
        ComposeUriValue(json, '',elem.instantiatesUriList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_instantiatesUri');
      for i := 0 to elem.instantiatesUriList.Count - 1 do
        ComposeUriProps(json, '',elem.instantiatesUriList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('basedOn') and (elem.basedOnList.Count > 0) then
  begin
    json.valueArray('basedOn');
    for i := 0 to elem.basedOnList.Count - 1 do
      ComposeReference{TFhirReference}(json, '', elem.basedOnList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('priorRequest') and (elem.priorRequestList.Count > 0) then
  begin
    json.valueArray('priorRequest');
    for i := 0 to elem.priorRequestList.Count - 1 do
      ComposeReference{TFhirReference}(json, '', elem.priorRequestList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('groupIdentifier') then
    ComposeIdentifier(json, 'groupIdentifier', elem.groupIdentifier); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirRequestStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirRequestStatusEnum, false);
  ComposeEnumValue(json, 'intent', elem.IntentElement, CODES_TFhirRequestIntentEnum, false);
  ComposeEnumProps(json, 'intent', elem.IntentElement, CODES_TFhirRequestIntentEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('priority') then
    ComposeEnumValue(json, 'priority', elem.PriorityElement, CODES_TFhirRequestPriorityEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('priority') then
    ComposeEnumProps(json, 'priority', elem.PriorityElement, CODES_TFhirRequestPriorityEnum, false);
  if (elem.code is TFhirReference) then
    ComposeReference(json, 'codeReference', TFhirReference(elem.code))
  else if (elem.code is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'codeCodeableConcept', TFhirCodeableConcept(elem.code)) ;
  if (SummaryOption in [soFull, soData]) and doCompose('parameter') and (elem.parameterList.Count > 0) then
  begin
    json.valueArray('parameter');
    for i := 0 to elem.parameterList.Count - 1 do
      ComposeDeviceRequestParameter(json, '', elem.parameterList[i]); {z - }
    json.FinishArray;
  end;
  ComposeReference{TFhirPatient}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirPeriod) then 
    ComposePeriod(json, 'occurrencePeriod', TFhirPeriod(elem.occurrence)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirTiming) then 
    ComposeTiming(json, 'occurrenceTiming', TFhirTiming(elem.occurrence)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'occurrenceDateTime', TFhirDateTime(elem.occurrence), false);
    ComposeDateTimeProps(json, 'occurrenceDateTime', TFhirDateTime(elem.occurrence), false);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('authoredOn') then
    ComposeDateTimeValue(json, 'authoredOn', elem.authoredOnElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('authoredOn') then
    ComposeDateTimeProps(json, 'authoredOn', elem.authoredOnElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requester') then
    ComposeReference{TFhirDevice}(json, 'requester', elem.requester); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('performerType') then
    ComposeCodeableConcept(json, 'performerType', elem.performerType); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('performer') then
    ComposeReference{TFhirPractitioner}(json, 'performer', elem.performer); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonCode') and (elem.reasonCodeList.Count > 0) then
  begin
    json.valueArray('reasonCode');
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.reasonCodeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonReference') and (elem.reasonReferenceList.Count > 0) then
  begin
    json.valueArray('reasonReference');
    for i := 0 to elem.reasonReferenceList.Count - 1 do
      ComposeReference{TFhirCondition}(json, '', elem.reasonReferenceList[i]); {z - Reference(Condition)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('insurance') and (elem.insuranceList.Count > 0) then
  begin
    json.valueArray('insurance');
    for i := 0 to elem.insuranceList.Count - 1 do
      ComposeReference{TFhirCoverage}(json, '', elem.insuranceList[i]); {z - Reference(Coverage)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('supportingInfo') and (elem.supportingInfoList.Count > 0) then
  begin
    json.valueArray('supportingInfo');
    for i := 0 to elem.supportingInfoList.Count - 1 do
      ComposeReference{TFhirReference}(json, '', elem.supportingInfoList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('note') and (elem.noteList.Count > 0) then
  begin
    json.valueArray('note');
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(json, '', elem.noteList[i]); {z - Annotation}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('relevantHistory') and (elem.relevantHistoryList.Count > 0) then
  begin
    json.valueArray('relevantHistory');
    for i := 0 to elem.relevantHistoryList.Count - 1 do
      ComposeReference{TFhirProvenance}(json, '', elem.relevantHistoryList[i]); {z - Reference(Provenance)}
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_DEVICEREQUEST}
{$IFDEF FHIR_DEVICEUSESTATEMENT}
procedure TFHIRJsonParser.ParseDeviceUseStatement(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDeviceUseStatement(jsn)); {2}
end;

function TFHIRJsonParser.ParseDeviceUseStatement(jsn : TJsonObject) : TFhirDeviceUseStatement;
begin
  result := TFhirDeviceUseStatement.create;
  try
    ParseDeviceUseStatementProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseDeviceUseStatementProperties(jsn : TJsonObject; result : TFhirDeviceUseStatement);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('basedOn') then
      iterateArray(jsn.vArr['basedOn'], result.basedOnList, parseReference{TFhirServiceRequest});
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirDeviceStatementStatusEnum, SYSTEMS_TFhirDeviceStatementStatusEnum);
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirPatient}(jsn.vObj['subject']);{q3}
    if jsn.has('derivedFrom') then
      iterateArray(jsn.vArr['derivedFrom'], result.derivedFromList, parseReference{TFhirServiceRequest});
    if jsn.has('timingTiming') {a4} then
      result.timing := ParseTiming(jsn.vObj['timingTiming']);
    if jsn.has('timingPeriod') {a4} then
      result.timing := ParsePeriod(jsn.vObj['timingPeriod']);
    if jsn.has('timingDateTime') or jsn.has('_timingDateTime') then
      result.timing := parseDateTime(jsn.node['timingDateTime'], jsn.vObj['_timingDateTime']);
    if jsn.has('recordedOn') or jsn.has('_recordedOn') then
        result.recordedOnElement := parseDateTime(jsn.node['recordedOn'], jsn.vObj['_recordedOn']);{q}
    if jsn.has('source') then
        result.source := ParseReference{TFhirPatient}(jsn.vObj['source']);{q3}
    if jsn.has('device') then
        result.device := ParseReference{TFhirDevice}(jsn.vObj['device']);{q3}
    if jsn.has('reasonCode') then
      iterateArray(jsn.vArr['reasonCode'], result.reasonCodeList, parseCodeableConcept);
    if jsn.has('reasonReference') then
      iterateArray(jsn.vArr['reasonReference'], result.reasonReferenceList, parseReference{TFhirCondition});
    if jsn.has('bodySite') then
        result.bodySite := ParseCodeableConcept(jsn.vObj['bodySite']);{q3}
    if jsn.has('note') then
      iterateArray(jsn.vArr['note'], result.noteList, parseAnnotation);
end;

procedure TFHIRJsonComposer.ComposeDeviceUseStatement(json : TJSONWriter; name : string; elem : TFhirDeviceUseStatement; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('basedOn') and (elem.basedOnList.Count > 0) then
  begin
    json.valueArray('basedOn');
    for i := 0 to elem.basedOnList.Count - 1 do
      ComposeReference{TFhirServiceRequest}(json, '', elem.basedOnList[i]); {z - Reference(ServiceRequest)}
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirDeviceStatementStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirDeviceStatementStatusEnum, false);
  ComposeReference{TFhirPatient}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('derivedFrom') and (elem.derivedFromList.Count > 0) then
  begin
    json.valueArray('derivedFrom');
    for i := 0 to elem.derivedFromList.Count - 1 do
      ComposeReference{TFhirServiceRequest}(json, '', elem.derivedFromList[i]); {z - Reference(ServiceRequest)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.timing is TFhirTiming) then 
    ComposeTiming(json, 'timingTiming', TFhirTiming(elem.timing)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.timing is TFhirPeriod) then 
    ComposePeriod(json, 'timingPeriod', TFhirPeriod(elem.timing)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.timing is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'timingDateTime', TFhirDateTime(elem.timing), false);
    ComposeDateTimeProps(json, 'timingDateTime', TFhirDateTime(elem.timing), false);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('recordedOn') then
    ComposeDateTimeValue(json, 'recordedOn', elem.recordedOnElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('recordedOn') then
    ComposeDateTimeProps(json, 'recordedOn', elem.recordedOnElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('source') then
    ComposeReference{TFhirPatient}(json, 'source', elem.source); {a}
  ComposeReference{TFhirDevice}(json, 'device', elem.device); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonCode') and (elem.reasonCodeList.Count > 0) then
  begin
    json.valueArray('reasonCode');
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.reasonCodeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonReference') and (elem.reasonReferenceList.Count > 0) then
  begin
    json.valueArray('reasonReference');
    for i := 0 to elem.reasonReferenceList.Count - 1 do
      ComposeReference{TFhirCondition}(json, '', elem.reasonReferenceList[i]); {z - Reference(Condition)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('bodySite') then
    ComposeCodeableConcept(json, 'bodySite', elem.bodySite); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('note') and (elem.noteList.Count > 0) then
  begin
    json.valueArray('note');
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(json, '', elem.noteList[i]); {z - Annotation}
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_DEVICEUSESTATEMENT}
{$IFDEF FHIR_DIAGNOSTICREPORT}
procedure TFHIRJsonParser.ParseDiagnosticReportMedia(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDiagnosticReportMedia(jsn)); {2}
end;

function TFHIRJsonParser.ParseDiagnosticReportMedia(jsn : TJsonObject) : TFhirDiagnosticReportMedia;
begin
  result := TFhirDiagnosticReportMedia.create;
  try
    ParseDiagnosticReportMediaProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseDiagnosticReportMediaProperties(jsn : TJsonObject; result : TFhirDiagnosticReportMedia);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('comment') or jsn.has('_comment') then
        result.commentElement := parseString(jsn.node['comment'], jsn.vObj['_comment']);{q}
    if jsn.has('link') then
        result.link_ := ParseReference{TFhirMedia}(jsn.vObj['link']);{q3}
end;

procedure TFHIRJsonComposer.ComposeDiagnosticReportMedia(json : TJSONWriter; name : string; elem : TFhirDiagnosticReportMedia; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'comment', elem.commentElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'comment', elem.commentElement, false);
  ComposeReference{TFhirMedia}(json, 'link', elem.link_); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseDiagnosticReport(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDiagnosticReport(jsn)); {2}
end;

function TFHIRJsonParser.ParseDiagnosticReport(jsn : TJsonObject) : TFhirDiagnosticReport;
begin
  result := TFhirDiagnosticReport.create;
  try
    ParseDiagnosticReportProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseDiagnosticReportProperties(jsn : TJsonObject; result : TFhirDiagnosticReport);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('basedOn') then
      iterateArray(jsn.vArr['basedOn'], result.basedOnList, parseReference{TFhirCarePlan});
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirDiagnosticReportStatusEnum, SYSTEMS_TFhirDiagnosticReportStatusEnum);
    if jsn.has('category') then
      iterateArray(jsn.vArr['category'], result.categoryList, parseCodeableConcept);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirPatient}(jsn.vObj['subject']);{q3}
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q3}
    if jsn.has('effectivePeriod') {a4} then
      result.effective := ParsePeriod(jsn.vObj['effectivePeriod']);
    if jsn.has('effectiveDateTime') or jsn.has('_effectiveDateTime') then
      result.effective := parseDateTime(jsn.node['effectiveDateTime'], jsn.vObj['_effectiveDateTime']);
    if jsn.has('issued') or jsn.has('_issued') then
        result.issuedElement := parseInstant(jsn.node['issued'], jsn.vObj['_issued']);{q}
    if jsn.has('performer') then
      iterateArray(jsn.vArr['performer'], result.performerList, parseReference{TFhirPractitioner});
    if jsn.has('resultsInterpreter') then
      iterateArray(jsn.vArr['resultsInterpreter'], result.resultsInterpreterList, parseReference{TFhirPractitioner});
    if jsn.has('specimen') then
      iterateArray(jsn.vArr['specimen'], result.specimenList, parseReference{TFhirSpecimen});
    if jsn.has('result') then
      iterateArray(jsn.vArr['result'], result.resultList, parseReference{TFhirObservation});
    if jsn.has('imagingStudy') then
      iterateArray(jsn.vArr['imagingStudy'], result.imagingStudyList, parseReference{TFhirImagingStudy});
    if jsn.has('media') then
      iterateArray(jsn.vArr['media'], result.mediaList, parseDiagnosticReportMedia);
    if jsn.has('conclusion') or jsn.has('_conclusion') then
        result.conclusionElement := parseString(jsn.node['conclusion'], jsn.vObj['_conclusion']);{q}
    if jsn.has('conclusionCode') then
      iterateArray(jsn.vArr['conclusionCode'], result.conclusionCodeList, parseCodeableConcept);
    if jsn.has('presentedForm') then
      iterateArray(jsn.vArr['presentedForm'], result.presentedFormList, parseAttachment);
end;

procedure TFHIRJsonComposer.ComposeDiagnosticReport(json : TJSONWriter; name : string; elem : TFhirDiagnosticReport; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('basedOn') and (elem.basedOnList.Count > 0) then
  begin
    json.valueArray('basedOn');
    for i := 0 to elem.basedOnList.Count - 1 do
      ComposeReference{TFhirCarePlan}(json, '', elem.basedOnList[i]); {z - Reference(CarePlan)}
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirDiagnosticReportStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirDiagnosticReportStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') and (elem.categoryList.Count > 0) then
  begin
    json.valueArray('category');
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.categoryList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{TFhirPatient}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.effective is TFhirPeriod) then 
    ComposePeriod(json, 'effectivePeriod', TFhirPeriod(elem.effective)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.effective is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'effectiveDateTime', TFhirDateTime(elem.effective), false);
    ComposeDateTimeProps(json, 'effectiveDateTime', TFhirDateTime(elem.effective), false);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('issued') then
    ComposeInstantValue(json, 'issued', elem.issuedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('issued') then
    ComposeInstantProps(json, 'issued', elem.issuedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('performer') and (elem.performerList.Count > 0) then
  begin
    json.valueArray('performer');
    for i := 0 to elem.performerList.Count - 1 do
      ComposeReference{TFhirPractitioner}(json, '', elem.performerList[i]); {z - Reference(Practitioner)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('resultsInterpreter') and (elem.resultsInterpreterList.Count > 0) then
  begin
    json.valueArray('resultsInterpreter');
    for i := 0 to elem.resultsInterpreterList.Count - 1 do
      ComposeReference{TFhirPractitioner}(json, '', elem.resultsInterpreterList[i]); {z - Reference(Practitioner)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('specimen') and (elem.specimenList.Count > 0) then
  begin
    json.valueArray('specimen');
    for i := 0 to elem.specimenList.Count - 1 do
      ComposeReference{TFhirSpecimen}(json, '', elem.specimenList[i]); {z - Reference(Specimen)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('result') and (elem.resultList.Count > 0) then
  begin
    json.valueArray('result');
    for i := 0 to elem.resultList.Count - 1 do
      ComposeReference{TFhirObservation}(json, '', elem.resultList[i]); {z - Reference(Observation)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('imagingStudy') and (elem.imagingStudyList.Count > 0) then
  begin
    json.valueArray('imagingStudy');
    for i := 0 to elem.imagingStudyList.Count - 1 do
      ComposeReference{TFhirImagingStudy}(json, '', elem.imagingStudyList[i]); {z - Reference(ImagingStudy)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('media') and (elem.mediaList.Count > 0) then
  begin
    json.valueArray('media');
    for i := 0 to elem.mediaList.Count - 1 do
      ComposeDiagnosticReportMedia(json, '', elem.mediaList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('conclusion') then
    ComposeStringValue(json, 'conclusion', elem.conclusionElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('conclusion') then
    ComposeStringProps(json, 'conclusion', elem.conclusionElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('conclusionCode') and (elem.conclusionCodeList.Count > 0) then
  begin
    json.valueArray('conclusionCode');
    for i := 0 to elem.conclusionCodeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.conclusionCodeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('presentedForm') and (elem.presentedFormList.Count > 0) then
  begin
    json.valueArray('presentedForm');
    for i := 0 to elem.presentedFormList.Count - 1 do
      ComposeAttachment(json, '', elem.presentedFormList[i]); {z - Attachment}
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_DIAGNOSTICREPORT}
{$IFDEF FHIR_DOCUMENTMANIFEST}
procedure TFHIRJsonParser.ParseDocumentManifestRelated(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDocumentManifestRelated(jsn)); {2}
end;

function TFHIRJsonParser.ParseDocumentManifestRelated(jsn : TJsonObject) : TFhirDocumentManifestRelated;
begin
  result := TFhirDocumentManifestRelated.create;
  try
    ParseDocumentManifestRelatedProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseDocumentManifestRelatedProperties(jsn : TJsonObject; result : TFhirDocumentManifestRelated);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q3}
    if jsn.has('ref') then
        result.ref := ParseReference{TFhirReference}(jsn.vObj['ref']);{q3}
end;

procedure TFHIRJsonComposer.ComposeDocumentManifestRelated(json : TJSONWriter; name : string; elem : TFhirDocumentManifestRelated; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirReference}(json, 'ref', elem.ref); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseDocumentManifest(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDocumentManifest(jsn)); {2}
end;

function TFHIRJsonParser.ParseDocumentManifest(jsn : TJsonObject) : TFhirDocumentManifest;
begin
  result := TFhirDocumentManifest.create;
  try
    ParseDocumentManifestProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseDocumentManifestProperties(jsn : TJsonObject; result : TFhirDocumentManifest);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('masterIdentifier') then
        result.masterIdentifier := ParseIdentifier(jsn.vObj['masterIdentifier']);{q3}
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirDocumentReferenceStatusEnum, SYSTEMS_TFhirDocumentReferenceStatusEnum);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirPatient}(jsn.vObj['subject']);{q3}
    if jsn.has('created') or jsn.has('_created') then
        result.createdElement := parseDateTime(jsn.node['created'], jsn.vObj['_created']);{q}
    if jsn.has('author') then
      iterateArray(jsn.vArr['author'], result.authorList, parseReference{TFhirPractitioner});
    if jsn.has('recipient') then
      iterateArray(jsn.vArr['recipient'], result.recipientList, parseReference{TFhirPatient});
    if jsn.has('source') or jsn.has('_source') then
        result.sourceElement := parseUri(jsn.node['source'], jsn.vObj['_source']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('content') then
      iterateArray(jsn.vArr['content'], result.contentList, parseReference{TFhirReference});
    if jsn.has('related') then
      iterateArray(jsn.vArr['related'], result.relatedList, parseDocumentManifestRelated);
end;

procedure TFHIRJsonComposer.ComposeDocumentManifest(json : TJSONWriter; name : string; elem : TFhirDocumentManifest; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('masterIdentifier') then
    ComposeIdentifier(json, 'masterIdentifier', elem.masterIdentifier); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirDocumentReferenceStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirDocumentReferenceStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{TFhirPatient}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('created') then
    ComposeDateTimeValue(json, 'created', elem.createdElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('created') then
    ComposeDateTimeProps(json, 'created', elem.createdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('author') and (elem.authorList.Count > 0) then
  begin
    json.valueArray('author');
    for i := 0 to elem.authorList.Count - 1 do
      ComposeReference{TFhirPractitioner}(json, '', elem.authorList[i]); {z - Reference(Practitioner)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('recipient') and (elem.recipientList.Count > 0) then
  begin
    json.valueArray('recipient');
    for i := 0 to elem.recipientList.Count - 1 do
      ComposeReference{TFhirPatient}(json, '', elem.recipientList[i]); {z - Reference(Patient)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('source') then
    ComposeUriValue(json, 'source', elem.sourceElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('source') then
    ComposeUriProps(json, 'source', elem.sourceElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (elem.contentList.Count > 0) then
  begin
    json.valueArray('content');
    for i := 0 to elem.contentList.Count - 1 do
      ComposeReference{TFhirReference}(json, '', elem.contentList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('related') and (elem.relatedList.Count > 0) then
  begin
    json.valueArray('related');
    for i := 0 to elem.relatedList.Count - 1 do
      ComposeDocumentManifestRelated(json, '', elem.relatedList[i]); {z - }
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_DOCUMENTMANIFEST}
{$IFDEF FHIR_DOCUMENTREFERENCE}
procedure TFHIRJsonParser.ParseDocumentReferenceRelatesTo(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDocumentReferenceRelatesTo(jsn)); {2}
end;

function TFHIRJsonParser.ParseDocumentReferenceRelatesTo(jsn : TJsonObject) : TFhirDocumentReferenceRelatesTo;
begin
  result := TFhirDocumentReferenceRelatesTo.create;
  try
    ParseDocumentReferenceRelatesToProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseDocumentReferenceRelatesToProperties(jsn : TJsonObject; result : TFhirDocumentReferenceRelatesTo);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') or jsn.has('_code')  then
      result.codeElement := parseEnum(jsn.path+'/code', jsn.node['code'], jsn.vObj['_code'], CODES_TFhirDocumentRelationshipTypeEnum, SYSTEMS_TFhirDocumentRelationshipTypeEnum);
    if jsn.has('target') then
        result.target := ParseReference{TFhirDocumentReference}(jsn.vObj['target']);{q3}
end;

procedure TFHIRJsonComposer.ComposeDocumentReferenceRelatesTo(json : TJSONWriter; name : string; elem : TFhirDocumentReferenceRelatesTo; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'code', elem.CodeElement, CODES_TFhirDocumentRelationshipTypeEnum, false);
  ComposeEnumProps(json, 'code', elem.CodeElement, CODES_TFhirDocumentRelationshipTypeEnum, false);
  ComposeReference{TFhirDocumentReference}(json, 'target', elem.target); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseDocumentReferenceContent(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDocumentReferenceContent(jsn)); {2}
end;

function TFHIRJsonParser.ParseDocumentReferenceContent(jsn : TJsonObject) : TFhirDocumentReferenceContent;
begin
  result := TFhirDocumentReferenceContent.create;
  try
    ParseDocumentReferenceContentProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseDocumentReferenceContentProperties(jsn : TJsonObject; result : TFhirDocumentReferenceContent);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('attachment') then
        result.attachment := ParseAttachment(jsn.vObj['attachment']);{q3}
    if jsn.has('format') then
        result.format := ParseCoding(jsn.vObj['format']);{q3}
end;

procedure TFHIRJsonComposer.ComposeDocumentReferenceContent(json : TJSONWriter; name : string; elem : TFhirDocumentReferenceContent; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeAttachment(json, 'attachment', elem.attachment); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'format', elem.format); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseDocumentReferenceContext(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDocumentReferenceContext(jsn)); {2}
end;

function TFHIRJsonParser.ParseDocumentReferenceContext(jsn : TJsonObject) : TFhirDocumentReferenceContext;
begin
  result := TFhirDocumentReferenceContext.create;
  try
    ParseDocumentReferenceContextProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseDocumentReferenceContextProperties(jsn : TJsonObject; result : TFhirDocumentReferenceContext);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('encounter') then
      iterateArray(jsn.vArr['encounter'], result.encounterList, parseReference{TFhirEncounter});
    if jsn.has('event') then
      iterateArray(jsn.vArr['event'], result.eventList, parseCodeableConcept);
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q3}
    if jsn.has('facilityType') then
        result.facilityType := ParseCodeableConcept(jsn.vObj['facilityType']);{q3}
    if jsn.has('practiceSetting') then
        result.practiceSetting := ParseCodeableConcept(jsn.vObj['practiceSetting']);{q3}
    if jsn.has('sourcePatientInfo') then
        result.sourcePatientInfo := ParseReference{TFhirPatient}(jsn.vObj['sourcePatientInfo']);{q3}
    if jsn.has('related') then
      iterateArray(jsn.vArr['related'], result.relatedList, parseReference{TFhirReference});
end;

procedure TFHIRJsonComposer.ComposeDocumentReferenceContext(json : TJSONWriter; name : string; elem : TFhirDocumentReferenceContext; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and (elem.encounterList.Count > 0) then
  begin
    json.valueArray('encounter');
    for i := 0 to elem.encounterList.Count - 1 do
      ComposeReference{TFhirEncounter}(json, '', elem.encounterList[i]); {z - Reference(Encounter)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.eventList.Count > 0) then
  begin
    json.valueArray('event');
    for i := 0 to elem.eventList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.eventList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(json, 'period', elem.period); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'facilityType', elem.facilityType); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'practiceSetting', elem.practiceSetting); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirPatient}(json, 'sourcePatientInfo', elem.sourcePatientInfo); {a}
  if (SummaryOption in [soFull, soData]) and (elem.relatedList.Count > 0) then
  begin
    json.valueArray('related');
    for i := 0 to elem.relatedList.Count - 1 do
      ComposeReference{TFhirReference}(json, '', elem.relatedList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseDocumentReference(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDocumentReference(jsn)); {2}
end;

function TFHIRJsonParser.ParseDocumentReference(jsn : TJsonObject) : TFhirDocumentReference;
begin
  result := TFhirDocumentReference.create;
  try
    ParseDocumentReferenceProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseDocumentReferenceProperties(jsn : TJsonObject; result : TFhirDocumentReference);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('masterIdentifier') then
        result.masterIdentifier := ParseIdentifier(jsn.vObj['masterIdentifier']);{q3}
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirDocumentReferenceStatusEnum, SYSTEMS_TFhirDocumentReferenceStatusEnum);
    if jsn.has('docStatus') or jsn.has('_docStatus')  then
      result.docStatusElement := parseEnum(jsn.path+'/docStatus', jsn.node['docStatus'], jsn.vObj['_docStatus'], CODES_TFhirCompositionStatusEnum, SYSTEMS_TFhirCompositionStatusEnum);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('category') then
      iterateArray(jsn.vArr['category'], result.categoryList, parseCodeableConcept);
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirPatient}(jsn.vObj['subject']);{q3}
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := parseInstant(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('author') then
      iterateArray(jsn.vArr['author'], result.authorList, parseReference{TFhirPractitioner});
    if jsn.has('authenticator') then
        result.authenticator := ParseReference{TFhirPractitioner}(jsn.vObj['authenticator']);{q3}
    if jsn.has('custodian') then
        result.custodian := ParseReference{TFhirOrganization}(jsn.vObj['custodian']);{q3}
    if jsn.has('relatesTo') then
      iterateArray(jsn.vArr['relatesTo'], result.relatesToList, parseDocumentReferenceRelatesTo);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('securityLabel') then
      iterateArray(jsn.vArr['securityLabel'], result.securityLabelList, parseCodeableConcept);
    if jsn.has('content') then
      iterateArray(jsn.vArr['content'], result.contentList, parseDocumentReferenceContent);
    if jsn.has('context') then
        result.context := ParseDocumentReferenceContext(jsn.vObj['context']);{q3}
end;

procedure TFHIRJsonComposer.ComposeDocumentReference(json : TJSONWriter; name : string; elem : TFhirDocumentReference; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('masterIdentifier') then
    ComposeIdentifier(json, 'masterIdentifier', elem.masterIdentifier); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirDocumentReferenceStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirDocumentReferenceStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('docStatus') then
    ComposeEnumValue(json, 'docStatus', elem.DocStatusElement, CODES_TFhirCompositionStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('docStatus') then
    ComposeEnumProps(json, 'docStatus', elem.DocStatusElement, CODES_TFhirCompositionStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') and (elem.categoryList.Count > 0) then
  begin
    json.valueArray('category');
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.categoryList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{TFhirPatient}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeInstantValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeInstantProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('author') and (elem.authorList.Count > 0) then
  begin
    json.valueArray('author');
    for i := 0 to elem.authorList.Count - 1 do
      ComposeReference{TFhirPractitioner}(json, '', elem.authorList[i]); {z - Reference(Practitioner)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('authenticator') then
    ComposeReference{TFhirPractitioner}(json, 'authenticator', elem.authenticator); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('custodian') then
    ComposeReference{TFhirOrganization}(json, 'custodian', elem.custodian); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('relatesTo') and (elem.relatesToList.Count > 0) then
  begin
    json.valueArray('relatesTo');
    for i := 0 to elem.relatesToList.Count - 1 do
      ComposeDocumentReferenceRelatesTo(json, '', elem.relatesToList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('securityLabel') and (elem.securityLabelList.Count > 0) then
  begin
    json.valueArray('securityLabel');
    for i := 0 to elem.securityLabelList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.securityLabelList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (elem.contentList.Count > 0) then
  begin
    json.valueArray('content');
    for i := 0 to elem.contentList.Count - 1 do
      ComposeDocumentReferenceContent(json, '', elem.contentList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('context') then
    ComposeDocumentReferenceContext(json, 'context', elem.context); {a}
end;

{$ENDIF FHIR_DOCUMENTREFERENCE}
{$IFDEF FHIR_EFFECTEVIDENCESYNTHESIS}
procedure TFHIRJsonParser.ParseEffectEvidenceSynthesisSampleSize(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseEffectEvidenceSynthesisSampleSize(jsn)); {2}
end;

function TFHIRJsonParser.ParseEffectEvidenceSynthesisSampleSize(jsn : TJsonObject) : TFhirEffectEvidenceSynthesisSampleSize;
begin
  result := TFhirEffectEvidenceSynthesisSampleSize.create;
  try
    ParseEffectEvidenceSynthesisSampleSizeProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseEffectEvidenceSynthesisSampleSizeProperties(jsn : TJsonObject; result : TFhirEffectEvidenceSynthesisSampleSize);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('numberOfStudies') or jsn.has('_numberOfStudies') then
        result.numberOfStudiesElement := parseInteger(jsn.node['numberOfStudies'], jsn.vObj['_numberOfStudies']);{q}
    if jsn.has('numberOfParticipants') or jsn.has('_numberOfParticipants') then
        result.numberOfParticipantsElement := parseInteger(jsn.node['numberOfParticipants'], jsn.vObj['_numberOfParticipants']);{q}
end;

procedure TFHIRJsonComposer.ComposeEffectEvidenceSynthesisSampleSize(json : TJSONWriter; name : string; elem : TFhirEffectEvidenceSynthesisSampleSize; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIntegerValue(json, 'numberOfStudies', elem.numberOfStudiesElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIntegerProps(json, 'numberOfStudies', elem.numberOfStudiesElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIntegerValue(json, 'numberOfParticipants', elem.numberOfParticipantsElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIntegerProps(json, 'numberOfParticipants', elem.numberOfParticipantsElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseEffectEvidenceSynthesisResultsByExposure(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseEffectEvidenceSynthesisResultsByExposure(jsn)); {2}
end;

function TFHIRJsonParser.ParseEffectEvidenceSynthesisResultsByExposure(jsn : TJsonObject) : TFhirEffectEvidenceSynthesisResultsByExposure;
begin
  result := TFhirEffectEvidenceSynthesisResultsByExposure.create;
  try
    ParseEffectEvidenceSynthesisResultsByExposureProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseEffectEvidenceSynthesisResultsByExposureProperties(jsn : TJsonObject; result : TFhirEffectEvidenceSynthesisResultsByExposure);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('exposureState') or jsn.has('_exposureState')  then
      result.exposureStateElement := parseEnum(jsn.path+'/exposureState', jsn.node['exposureState'], jsn.vObj['_exposureState'], CODES_TFhirExposureStateEnum, SYSTEMS_TFhirExposureStateEnum);
    if jsn.has('variantState') then
        result.variantState := ParseCodeableConcept(jsn.vObj['variantState']);{q3}
    if jsn.has('riskEvidenceSynthesis') then
        result.riskEvidenceSynthesis := ParseReference{TFhirRiskEvidenceSynthesis}(jsn.vObj['riskEvidenceSynthesis']);{q3}
end;

procedure TFHIRJsonComposer.ComposeEffectEvidenceSynthesisResultsByExposure(json : TJSONWriter; name : string; elem : TFhirEffectEvidenceSynthesisResultsByExposure; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumValue(json, 'exposureState', elem.ExposureStateElement, CODES_TFhirExposureStateEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumProps(json, 'exposureState', elem.ExposureStateElement, CODES_TFhirExposureStateEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'variantState', elem.variantState); {a}
  ComposeReference{TFhirRiskEvidenceSynthesis}(json, 'riskEvidenceSynthesis', elem.riskEvidenceSynthesis); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseEffectEvidenceSynthesisEffectEstimate(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseEffectEvidenceSynthesisEffectEstimate(jsn)); {2}
end;

function TFHIRJsonParser.ParseEffectEvidenceSynthesisEffectEstimate(jsn : TJsonObject) : TFhirEffectEvidenceSynthesisEffectEstimate;
begin
  result := TFhirEffectEvidenceSynthesisEffectEstimate.create;
  try
    ParseEffectEvidenceSynthesisEffectEstimateProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseEffectEvidenceSynthesisEffectEstimateProperties(jsn : TJsonObject; result : TFhirEffectEvidenceSynthesisEffectEstimate);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('variantState') then
        result.variantState := ParseCodeableConcept(jsn.vObj['variantState']);{q3}
    if jsn.has('value') or jsn.has('_value') then
        result.valueElement := parseDecimal(jsn.node['value'], jsn.vObj['_value']);{q}
    if jsn.has('unitOfMeasure') then
        result.unitOfMeasure := ParseCodeableConcept(jsn.vObj['unitOfMeasure']);{q3}
    if jsn.has('precisionEstimate') then
      iterateArray(jsn.vArr['precisionEstimate'], result.precisionEstimateList, parseEffectEvidenceSynthesisEffectEstimatePrecisionEstimate);
end;

procedure TFHIRJsonComposer.ComposeEffectEvidenceSynthesisEffectEstimate(json : TJSONWriter; name : string; elem : TFhirEffectEvidenceSynthesisEffectEstimate; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'variantState', elem.variantState); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalValue(json, 'value', elem.valueElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalProps(json, 'value', elem.valueElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'unitOfMeasure', elem.unitOfMeasure); {a}
  if (SummaryOption in [soFull, soData]) and (elem.precisionEstimateList.Count > 0) then
  begin
    json.valueArray('precisionEstimate');
    for i := 0 to elem.precisionEstimateList.Count - 1 do
      ComposeEffectEvidenceSynthesisEffectEstimatePrecisionEstimate(json, '', elem.precisionEstimateList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseEffectEvidenceSynthesisEffectEstimatePrecisionEstimate(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseEffectEvidenceSynthesisEffectEstimatePrecisionEstimate(jsn)); {2}
end;

function TFHIRJsonParser.ParseEffectEvidenceSynthesisEffectEstimatePrecisionEstimate(jsn : TJsonObject) : TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate;
begin
  result := TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate.create;
  try
    ParseEffectEvidenceSynthesisEffectEstimatePrecisionEstimateProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseEffectEvidenceSynthesisEffectEstimatePrecisionEstimateProperties(jsn : TJsonObject; result : TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('level') or jsn.has('_level') then
        result.levelElement := parseDecimal(jsn.node['level'], jsn.vObj['_level']);{q}
    if jsn.has('from') or jsn.has('_from') then
        result.fromElement := parseDecimal(jsn.node['from'], jsn.vObj['_from']);{q}
    if jsn.has('to') or jsn.has('_to') then
        result.to_Element := parseDecimal(jsn.node['to'], jsn.vObj['_to']);{q}
end;

procedure TFHIRJsonComposer.ComposeEffectEvidenceSynthesisEffectEstimatePrecisionEstimate(json : TJSONWriter; name : string; elem : TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalValue(json, 'level', elem.levelElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalProps(json, 'level', elem.levelElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalValue(json, 'from', elem.fromElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalProps(json, 'from', elem.fromElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalValue(json, 'to', elem.to_Element, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalProps(json, 'to', elem.to_Element, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseEffectEvidenceSynthesisCertainty(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseEffectEvidenceSynthesisCertainty(jsn)); {2}
end;

function TFHIRJsonParser.ParseEffectEvidenceSynthesisCertainty(jsn : TJsonObject) : TFhirEffectEvidenceSynthesisCertainty;
begin
  result := TFhirEffectEvidenceSynthesisCertainty.create;
  try
    ParseEffectEvidenceSynthesisCertaintyProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseEffectEvidenceSynthesisCertaintyProperties(jsn : TJsonObject; result : TFhirEffectEvidenceSynthesisCertainty);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('rating') then
      iterateArray(jsn.vArr['rating'], result.ratingList, parseCodeableConcept);
    if jsn.has('note') then
      iterateArray(jsn.vArr['note'], result.noteList, parseAnnotation);
    if jsn.has('certaintySubcomponent') then
      iterateArray(jsn.vArr['certaintySubcomponent'], result.certaintySubcomponentList, parseEffectEvidenceSynthesisCertaintyCertaintySubcomponent);
end;

procedure TFHIRJsonComposer.ComposeEffectEvidenceSynthesisCertainty(json : TJSONWriter; name : string; elem : TFhirEffectEvidenceSynthesisCertainty; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and (elem.ratingList.Count > 0) then
  begin
    json.valueArray('rating');
    for i := 0 to elem.ratingList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.ratingList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.noteList.Count > 0) then
  begin
    json.valueArray('note');
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(json, '', elem.noteList[i]); {z - Annotation}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.certaintySubcomponentList.Count > 0) then
  begin
    json.valueArray('certaintySubcomponent');
    for i := 0 to elem.certaintySubcomponentList.Count - 1 do
      ComposeEffectEvidenceSynthesisCertaintyCertaintySubcomponent(json, '', elem.certaintySubcomponentList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseEffectEvidenceSynthesisCertaintyCertaintySubcomponent(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseEffectEvidenceSynthesisCertaintyCertaintySubcomponent(jsn)); {2}
end;

function TFHIRJsonParser.ParseEffectEvidenceSynthesisCertaintyCertaintySubcomponent(jsn : TJsonObject) : TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent;
begin
  result := TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent.create;
  try
    ParseEffectEvidenceSynthesisCertaintyCertaintySubcomponentProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseEffectEvidenceSynthesisCertaintyCertaintySubcomponentProperties(jsn : TJsonObject; result : TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('rating') then
      iterateArray(jsn.vArr['rating'], result.ratingList, parseCodeableConcept);
    if jsn.has('note') then
      iterateArray(jsn.vArr['note'], result.noteList, parseAnnotation);
end;

procedure TFHIRJsonComposer.ComposeEffectEvidenceSynthesisCertaintyCertaintySubcomponent(json : TJSONWriter; name : string; elem : TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) and (elem.ratingList.Count > 0) then
  begin
    json.valueArray('rating');
    for i := 0 to elem.ratingList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.ratingList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.noteList.Count > 0) then
  begin
    json.valueArray('note');
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(json, '', elem.noteList[i]); {z - Annotation}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseEffectEvidenceSynthesis(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseEffectEvidenceSynthesis(jsn)); {2}
end;

function TFHIRJsonParser.ParseEffectEvidenceSynthesis(jsn : TJsonObject) : TFhirEffectEvidenceSynthesis;
begin
  result := TFhirEffectEvidenceSynthesis.create;
  try
    ParseEffectEvidenceSynthesisProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseEffectEvidenceSynthesisProperties(jsn : TJsonObject; result : TFhirEffectEvidenceSynthesis);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := parseUri(jsn.node['url'], jsn.vObj['_url']);{q}
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := parseString(jsn.node['version'], jsn.vObj['_version']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('title') or jsn.has('_title') then
        result.titleElement := parseString(jsn.node['title'], jsn.vObj['_title']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := parseDateTime(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('publisher') or jsn.has('_publisher') then
        result.publisherElement := parseString(jsn.node['publisher'], jsn.vObj['_publisher']);{q}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseContactDetail);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseMarkdown(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('note') then
      iterateArray(jsn.vArr['note'], result.noteList, parseAnnotation);
    if jsn.has('useContext') then
      iterateArray(jsn.vArr['useContext'], result.useContextList, parseUsageContext);
    if jsn.has('jurisdiction') then
      iterateArray(jsn.vArr['jurisdiction'], result.jurisdictionList, parseCodeableConcept);
    if jsn.has('copyright') or jsn.has('_copyright') then
        result.copyrightElement := parseMarkdown(jsn.node['copyright'], jsn.vObj['_copyright']);{q}
    if jsn.has('approvalDate') or jsn.has('_approvalDate') then
        result.approvalDateElement := parseDate(jsn.node['approvalDate'], jsn.vObj['_approvalDate']);{q}
    if jsn.has('lastReviewDate') or jsn.has('_lastReviewDate') then
        result.lastReviewDateElement := parseDate(jsn.node['lastReviewDate'], jsn.vObj['_lastReviewDate']);{q}
    if jsn.has('effectivePeriod') then
        result.effectivePeriod := ParsePeriod(jsn.vObj['effectivePeriod']);{q3}
    if jsn.has('topic') then
      iterateArray(jsn.vArr['topic'], result.topicList, parseCodeableConcept);
    if jsn.has('author') then
      iterateArray(jsn.vArr['author'], result.authorList, parseContactDetail);
    if jsn.has('editor') then
      iterateArray(jsn.vArr['editor'], result.editorList, parseContactDetail);
    if jsn.has('reviewer') then
      iterateArray(jsn.vArr['reviewer'], result.reviewerList, parseContactDetail);
    if jsn.has('endorser') then
      iterateArray(jsn.vArr['endorser'], result.endorserList, parseContactDetail);
    if jsn.has('relatedArtifact') then
      iterateArray(jsn.vArr['relatedArtifact'], result.relatedArtifactList, parseRelatedArtifact);
    if jsn.has('synthesisType') then
        result.synthesisType := ParseCodeableConcept(jsn.vObj['synthesisType']);{q3}
    if jsn.has('studyType') then
        result.studyType := ParseCodeableConcept(jsn.vObj['studyType']);{q3}
    if jsn.has('population') then
        result.population := ParseReference{TFhirEvidenceVariable}(jsn.vObj['population']);{q3}
    if jsn.has('exposure') then
        result.exposure := ParseReference{TFhirEvidenceVariable}(jsn.vObj['exposure']);{q3}
    if jsn.has('exposureAlternative') then
        result.exposureAlternative := ParseReference{TFhirEvidenceVariable}(jsn.vObj['exposureAlternative']);{q3}
    if jsn.has('outcome') then
        result.outcome := ParseReference{TFhirEvidenceVariable}(jsn.vObj['outcome']);{q3}
    if jsn.has('sampleSize') then
        result.sampleSize := ParseEffectEvidenceSynthesisSampleSize(jsn.vObj['sampleSize']);{q3}
    if jsn.has('resultsByExposure') then
      iterateArray(jsn.vArr['resultsByExposure'], result.resultsByExposureList, parseEffectEvidenceSynthesisResultsByExposure);
    if jsn.has('effectEstimate') then
      iterateArray(jsn.vArr['effectEstimate'], result.effectEstimateList, parseEffectEvidenceSynthesisEffectEstimate);
    if jsn.has('certainty') then
      iterateArray(jsn.vArr['certainty'], result.certaintyList, parseEffectEvidenceSynthesisCertainty);
end;

procedure TFHIRJsonComposer.ComposeEffectEvidenceSynthesis(json : TJSONWriter; name : string; elem : TFhirEffectEvidenceSynthesis; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUriValue(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUriProps(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeStringValue(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeStringProps(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeStringValue(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeStringProps(json, 'title', elem.titleElement, false);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringValue(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringProps(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') and (elem.contactList.Count > 0) then
  begin
    json.valueArray('contact');
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(json, '', elem.contactList[i]); {z - ContactDetail}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeMarkdownValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeMarkdownProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('note') and (elem.noteList.Count > 0) then
  begin
    json.valueArray('note');
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(json, '', elem.noteList[i]); {z - Annotation}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') and (elem.useContextList.Count > 0) then
  begin
    json.valueArray('useContext');
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(json, '', elem.useContextList[i]); {z - UsageContext}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') and (elem.jurisdictionList.Count > 0) then
  begin
    json.valueArray('jurisdiction');
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.jurisdictionList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdownValue(json, 'copyright', elem.copyrightElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdownProps(json, 'copyright', elem.copyrightElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('approvalDate') then
    ComposeDateValue(json, 'approvalDate', elem.approvalDateElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('approvalDate') then
    ComposeDateProps(json, 'approvalDate', elem.approvalDateElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('lastReviewDate') then
    ComposeDateValue(json, 'lastReviewDate', elem.lastReviewDateElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('lastReviewDate') then
    ComposeDateProps(json, 'lastReviewDate', elem.lastReviewDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('effectivePeriod') then
    ComposePeriod(json, 'effectivePeriod', elem.effectivePeriod); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('topic') and (elem.topicList.Count > 0) then
  begin
    json.valueArray('topic');
    for i := 0 to elem.topicList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.topicList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('author') and (elem.authorList.Count > 0) then
  begin
    json.valueArray('author');
    for i := 0 to elem.authorList.Count - 1 do
      ComposeContactDetail(json, '', elem.authorList[i]); {z - ContactDetail}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('editor') and (elem.editorList.Count > 0) then
  begin
    json.valueArray('editor');
    for i := 0 to elem.editorList.Count - 1 do
      ComposeContactDetail(json, '', elem.editorList[i]); {z - ContactDetail}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('reviewer') and (elem.reviewerList.Count > 0) then
  begin
    json.valueArray('reviewer');
    for i := 0 to elem.reviewerList.Count - 1 do
      ComposeContactDetail(json, '', elem.reviewerList[i]); {z - ContactDetail}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('endorser') and (elem.endorserList.Count > 0) then
  begin
    json.valueArray('endorser');
    for i := 0 to elem.endorserList.Count - 1 do
      ComposeContactDetail(json, '', elem.endorserList[i]); {z - ContactDetail}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('relatedArtifact') and (elem.relatedArtifactList.Count > 0) then
  begin
    json.valueArray('relatedArtifact');
    for i := 0 to elem.relatedArtifactList.Count - 1 do
      ComposeRelatedArtifact(json, '', elem.relatedArtifactList[i]); {z - RelatedArtifact}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('synthesisType') then
    ComposeCodeableConcept(json, 'synthesisType', elem.synthesisType); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('studyType') then
    ComposeCodeableConcept(json, 'studyType', elem.studyType); {a}
  ComposeReference{TFhirEvidenceVariable}(json, 'population', elem.population); {a}
  ComposeReference{TFhirEvidenceVariable}(json, 'exposure', elem.exposure); {a}
  ComposeReference{TFhirEvidenceVariable}(json, 'exposureAlternative', elem.exposureAlternative); {a}
  ComposeReference{TFhirEvidenceVariable}(json, 'outcome', elem.outcome); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('sampleSize') then
    ComposeEffectEvidenceSynthesisSampleSize(json, 'sampleSize', elem.sampleSize); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('resultsByExposure') and (elem.resultsByExposureList.Count > 0) then
  begin
    json.valueArray('resultsByExposure');
    for i := 0 to elem.resultsByExposureList.Count - 1 do
      ComposeEffectEvidenceSynthesisResultsByExposure(json, '', elem.resultsByExposureList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('effectEstimate') and (elem.effectEstimateList.Count > 0) then
  begin
    json.valueArray('effectEstimate');
    for i := 0 to elem.effectEstimateList.Count - 1 do
      ComposeEffectEvidenceSynthesisEffectEstimate(json, '', elem.effectEstimateList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('certainty') and (elem.certaintyList.Count > 0) then
  begin
    json.valueArray('certainty');
    for i := 0 to elem.certaintyList.Count - 1 do
      ComposeEffectEvidenceSynthesisCertainty(json, '', elem.certaintyList[i]); {z - }
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_EFFECTEVIDENCESYNTHESIS}
{$IFDEF FHIR_ENCOUNTER}
procedure TFHIRJsonParser.ParseEncounterStatusHistory(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseEncounterStatusHistory(jsn)); {2}
end;

function TFHIRJsonParser.ParseEncounterStatusHistory(jsn : TJsonObject) : TFhirEncounterStatusHistory;
begin
  result := TFhirEncounterStatusHistory.create;
  try
    ParseEncounterStatusHistoryProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseEncounterStatusHistoryProperties(jsn : TJsonObject; result : TFhirEncounterStatusHistory);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirEncounterStatusEnum, SYSTEMS_TFhirEncounterStatusEnum);
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q3}
end;

procedure TFHIRJsonComposer.ComposeEncounterStatusHistory(json : TJSONWriter; name : string; elem : TFhirEncounterStatusHistory; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirEncounterStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirEncounterStatusEnum, false);
  ComposePeriod(json, 'period', elem.period); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseEncounterClassHistory(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseEncounterClassHistory(jsn)); {2}
end;

function TFHIRJsonParser.ParseEncounterClassHistory(jsn : TJsonObject) : TFhirEncounterClassHistory;
begin
  result := TFhirEncounterClassHistory.create;
  try
    ParseEncounterClassHistoryProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseEncounterClassHistoryProperties(jsn : TJsonObject; result : TFhirEncounterClassHistory);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('class') then
        result.class_ := ParseCoding(jsn.vObj['class']);{q3}
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q3}
end;

procedure TFHIRJsonComposer.ComposeEncounterClassHistory(json : TJSONWriter; name : string; elem : TFhirEncounterClassHistory; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCoding(json, 'class', elem.class_); {a}
  ComposePeriod(json, 'period', elem.period); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseEncounterParticipant(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseEncounterParticipant(jsn)); {2}
end;

function TFHIRJsonParser.ParseEncounterParticipant(jsn : TJsonObject) : TFhirEncounterParticipant;
begin
  result := TFhirEncounterParticipant.create;
  try
    ParseEncounterParticipantProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseEncounterParticipantProperties(jsn : TJsonObject; result : TFhirEncounterParticipant);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
      iterateArray(jsn.vArr['type'], result.type_List, parseCodeableConcept);
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q3}
    if jsn.has('individual') then
        result.individual := ParseReference{TFhirPractitioner}(jsn.vObj['individual']);{q3}
end;

procedure TFHIRJsonComposer.ComposeEncounterParticipant(json : TJSONWriter; name : string; elem : TFhirEncounterParticipant; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.type_List.Count > 0) then
  begin
    json.valueArray('type');
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(json, '', elem.type_List[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(json, 'period', elem.period); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(json, 'individual', elem.individual); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseEncounterDiagnosis(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseEncounterDiagnosis(jsn)); {2}
end;

function TFHIRJsonParser.ParseEncounterDiagnosis(jsn : TJsonObject) : TFhirEncounterDiagnosis;
begin
  result := TFhirEncounterDiagnosis.create;
  try
    ParseEncounterDiagnosisProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseEncounterDiagnosisProperties(jsn : TJsonObject; result : TFhirEncounterDiagnosis);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('condition') then
        result.condition := ParseReference{TFhirCondition}(jsn.vObj['condition']);{q3}
    if jsn.has('use') then
        result.use := ParseCodeableConcept(jsn.vObj['use']);{q3}
    if jsn.has('rank') or jsn.has('_rank') then
        result.rankElement := parsePositiveInt(jsn.node['rank'], jsn.vObj['_rank']);{q}
end;

procedure TFHIRJsonComposer.ComposeEncounterDiagnosis(json : TJSONWriter; name : string; elem : TFhirEncounterDiagnosis; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeReference{TFhirCondition}(json, 'condition', elem.condition); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'use', elem.use); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveIntValue(json, 'rank', elem.rankElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveIntProps(json, 'rank', elem.rankElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseEncounterHospitalization(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseEncounterHospitalization(jsn)); {2}
end;

function TFHIRJsonParser.ParseEncounterHospitalization(jsn : TJsonObject) : TFhirEncounterHospitalization;
begin
  result := TFhirEncounterHospitalization.create;
  try
    ParseEncounterHospitalizationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseEncounterHospitalizationProperties(jsn : TJsonObject; result : TFhirEncounterHospitalization);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('preAdmissionIdentifier') then
        result.preAdmissionIdentifier := ParseIdentifier(jsn.vObj['preAdmissionIdentifier']);{q3}
    if jsn.has('origin') then
        result.origin := ParseReference{TFhirLocation}(jsn.vObj['origin']);{q3}
    if jsn.has('admitSource') then
        result.admitSource := ParseCodeableConcept(jsn.vObj['admitSource']);{q3}
    if jsn.has('reAdmission') then
        result.reAdmission := ParseCodeableConcept(jsn.vObj['reAdmission']);{q3}
    if jsn.has('dietPreference') then
      iterateArray(jsn.vArr['dietPreference'], result.dietPreferenceList, parseCodeableConcept);
    if jsn.has('specialCourtesy') then
      iterateArray(jsn.vArr['specialCourtesy'], result.specialCourtesyList, parseCodeableConcept);
    if jsn.has('specialArrangement') then
      iterateArray(jsn.vArr['specialArrangement'], result.specialArrangementList, parseCodeableConcept);
    if jsn.has('destination') then
        result.destination := ParseReference{TFhirLocation}(jsn.vObj['destination']);{q3}
    if jsn.has('dischargeDisposition') then
        result.dischargeDisposition := ParseCodeableConcept(jsn.vObj['dischargeDisposition']);{q3}
end;

procedure TFHIRJsonComposer.ComposeEncounterHospitalization(json : TJSONWriter; name : string; elem : TFhirEncounterHospitalization; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(json, 'preAdmissionIdentifier', elem.preAdmissionIdentifier); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirLocation}(json, 'origin', elem.origin); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'admitSource', elem.admitSource); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'reAdmission', elem.reAdmission); {a}
  if (SummaryOption in [soFull, soData]) and (elem.dietPreferenceList.Count > 0) then
  begin
    json.valueArray('dietPreference');
    for i := 0 to elem.dietPreferenceList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.dietPreferenceList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.specialCourtesyList.Count > 0) then
  begin
    json.valueArray('specialCourtesy');
    for i := 0 to elem.specialCourtesyList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.specialCourtesyList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.specialArrangementList.Count > 0) then
  begin
    json.valueArray('specialArrangement');
    for i := 0 to elem.specialArrangementList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.specialArrangementList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirLocation}(json, 'destination', elem.destination); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'dischargeDisposition', elem.dischargeDisposition); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseEncounterLocation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseEncounterLocation(jsn)); {2}
end;

function TFHIRJsonParser.ParseEncounterLocation(jsn : TJsonObject) : TFhirEncounterLocation;
begin
  result := TFhirEncounterLocation.create;
  try
    ParseEncounterLocationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseEncounterLocationProperties(jsn : TJsonObject; result : TFhirEncounterLocation);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('location') then
        result.location := ParseReference{TFhirLocation}(jsn.vObj['location']);{q3}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirEncounterLocationStatusEnum, SYSTEMS_TFhirEncounterLocationStatusEnum);
    if jsn.has('physicalType') then
        result.physicalType := ParseCodeableConcept(jsn.vObj['physicalType']);{q3}
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q3}
end;

procedure TFHIRJsonComposer.ComposeEncounterLocation(json : TJSONWriter; name : string; elem : TFhirEncounterLocation; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeReference{TFhirLocation}(json, 'location', elem.location); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirEncounterLocationStatusEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirEncounterLocationStatusEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'physicalType', elem.physicalType); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(json, 'period', elem.period); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseEncounter(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseEncounter(jsn)); {2}
end;

function TFHIRJsonParser.ParseEncounter(jsn : TJsonObject) : TFhirEncounter;
begin
  result := TFhirEncounter.create;
  try
    ParseEncounterProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseEncounterProperties(jsn : TJsonObject; result : TFhirEncounter);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirEncounterStatusEnum, SYSTEMS_TFhirEncounterStatusEnum);
    if jsn.has('statusHistory') then
      iterateArray(jsn.vArr['statusHistory'], result.statusHistoryList, parseEncounterStatusHistory);
    if jsn.has('class') then
        result.class_ := ParseCoding(jsn.vObj['class']);{q3}
    if jsn.has('classHistory') then
      iterateArray(jsn.vArr['classHistory'], result.classHistoryList, parseEncounterClassHistory);
    if jsn.has('type') then
      iterateArray(jsn.vArr['type'], result.type_List, parseCodeableConcept);
    if jsn.has('serviceType') then
        result.serviceType := ParseCodeableConcept(jsn.vObj['serviceType']);{q3}
    if jsn.has('priority') then
        result.priority := ParseCodeableConcept(jsn.vObj['priority']);{q3}
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirPatient}(jsn.vObj['subject']);{q3}
    if jsn.has('episodeOfCare') then
      iterateArray(jsn.vArr['episodeOfCare'], result.episodeOfCareList, parseReference{TFhirEpisodeOfCare});
    if jsn.has('basedOn') then
      iterateArray(jsn.vArr['basedOn'], result.basedOnList, parseReference{TFhirServiceRequest});
    if jsn.has('participant') then
      iterateArray(jsn.vArr['participant'], result.participantList, parseEncounterParticipant);
    if jsn.has('appointment') then
      iterateArray(jsn.vArr['appointment'], result.appointmentList, parseReference{TFhirAppointment});
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q3}
    if jsn.has('length') then
        result.length := ParseDuration(jsn.vObj['length']);{q3}
    if jsn.has('reasonCode') then
      iterateArray(jsn.vArr['reasonCode'], result.reasonCodeList, parseCodeableConcept);
    if jsn.has('reasonReference') then
      iterateArray(jsn.vArr['reasonReference'], result.reasonReferenceList, parseReference{TFhirCondition});
    if jsn.has('diagnosis') then
      iterateArray(jsn.vArr['diagnosis'], result.diagnosisList, parseEncounterDiagnosis);
    if jsn.has('account') then
      iterateArray(jsn.vArr['account'], result.accountList, parseReference{TFhirAccount});
    if jsn.has('hospitalization') then
        result.hospitalization := ParseEncounterHospitalization(jsn.vObj['hospitalization']);{q3}
    if jsn.has('location') then
      iterateArray(jsn.vArr['location'], result.locationList, parseEncounterLocation);
    if jsn.has('serviceProvider') then
        result.serviceProvider := ParseReference{TFhirOrganization}(jsn.vObj['serviceProvider']);{q3}
    if jsn.has('partOf') then
        result.partOf := ParseReference{TFhirEncounter}(jsn.vObj['partOf']);{q3}
end;

procedure TFHIRJsonComposer.ComposeEncounter(json : TJSONWriter; name : string; elem : TFhirEncounter; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirEncounterStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirEncounterStatusEnum, false);
  if (SummaryOption in [soFull, soData]) and doCompose('statusHistory') and (elem.statusHistoryList.Count > 0) then
  begin
    json.valueArray('statusHistory');
    for i := 0 to elem.statusHistoryList.Count - 1 do
      ComposeEncounterStatusHistory(json, '', elem.statusHistoryList[i]); {z - }
    json.FinishArray;
  end;
  ComposeCoding(json, 'class', elem.class_); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('classHistory') and (elem.classHistoryList.Count > 0) then
  begin
    json.valueArray('classHistory');
    for i := 0 to elem.classHistoryList.Count - 1 do
      ComposeEncounterClassHistory(json, '', elem.classHistoryList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') and (elem.type_List.Count > 0) then
  begin
    json.valueArray('type');
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(json, '', elem.type_List[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('serviceType') then
    ComposeCodeableConcept(json, 'serviceType', elem.serviceType); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('priority') then
    ComposeCodeableConcept(json, 'priority', elem.priority); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{TFhirPatient}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('episodeOfCare') and (elem.episodeOfCareList.Count > 0) then
  begin
    json.valueArray('episodeOfCare');
    for i := 0 to elem.episodeOfCareList.Count - 1 do
      ComposeReference{TFhirEpisodeOfCare}(json, '', elem.episodeOfCareList[i]); {z - Reference(EpisodeOfCare)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('basedOn') and (elem.basedOnList.Count > 0) then
  begin
    json.valueArray('basedOn');
    for i := 0 to elem.basedOnList.Count - 1 do
      ComposeReference{TFhirServiceRequest}(json, '', elem.basedOnList[i]); {z - Reference(ServiceRequest)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('participant') and (elem.participantList.Count > 0) then
  begin
    json.valueArray('participant');
    for i := 0 to elem.participantList.Count - 1 do
      ComposeEncounterParticipant(json, '', elem.participantList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('appointment') and (elem.appointmentList.Count > 0) then
  begin
    json.valueArray('appointment');
    for i := 0 to elem.appointmentList.Count - 1 do
      ComposeReference{TFhirAppointment}(json, '', elem.appointmentList[i]); {z - Reference(Appointment)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('period') then
    ComposePeriod(json, 'period', elem.period); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('length') then
    ComposeDuration(json, 'length', elem.length); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonCode') and (elem.reasonCodeList.Count > 0) then
  begin
    json.valueArray('reasonCode');
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.reasonCodeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonReference') and (elem.reasonReferenceList.Count > 0) then
  begin
    json.valueArray('reasonReference');
    for i := 0 to elem.reasonReferenceList.Count - 1 do
      ComposeReference{TFhirCondition}(json, '', elem.reasonReferenceList[i]); {z - Reference(Condition)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('diagnosis') and (elem.diagnosisList.Count > 0) then
  begin
    json.valueArray('diagnosis');
    for i := 0 to elem.diagnosisList.Count - 1 do
      ComposeEncounterDiagnosis(json, '', elem.diagnosisList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('account') and (elem.accountList.Count > 0) then
  begin
    json.valueArray('account');
    for i := 0 to elem.accountList.Count - 1 do
      ComposeReference{TFhirAccount}(json, '', elem.accountList[i]); {z - Reference(Account)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('hospitalization') then
    ComposeEncounterHospitalization(json, 'hospitalization', elem.hospitalization); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('location') and (elem.locationList.Count > 0) then
  begin
    json.valueArray('location');
    for i := 0 to elem.locationList.Count - 1 do
      ComposeEncounterLocation(json, '', elem.locationList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('serviceProvider') then
    ComposeReference{TFhirOrganization}(json, 'serviceProvider', elem.serviceProvider); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('partOf') then
    ComposeReference{TFhirEncounter}(json, 'partOf', elem.partOf); {a}
end;

{$ENDIF FHIR_ENCOUNTER}
{$IFDEF FHIR_ENDPOINT}
procedure TFHIRJsonParser.ParseEndpoint(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseEndpoint(jsn)); {2}
end;

function TFHIRJsonParser.ParseEndpoint(jsn : TJsonObject) : TFhirEndpoint;
begin
  result := TFhirEndpoint.create;
  try
    ParseEndpointProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseEndpointProperties(jsn : TJsonObject; result : TFhirEndpoint);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirEndpointStatusEnum, SYSTEMS_TFhirEndpointStatusEnum);
    if jsn.has('connectionType') then
        result.connectionType := ParseCoding(jsn.vObj['connectionType']);{q3}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('managingOrganization') then
        result.managingOrganization := ParseReference{TFhirOrganization}(jsn.vObj['managingOrganization']);{q3}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseContactPoint);
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q3}
    if jsn.has('payloadType') then
      iterateArray(jsn.vArr['payloadType'], result.payloadTypeList, parseCodeableConcept);
      if jsn.has('payloadMimeType') or jsn.has('_payloadMimeType') then
      iteratePrimitiveArray(jsn.vArr['payloadMimeType'], jsn.vArr['_payloadMimeType'], result.payloadMimeTypeList, parseCode);
    if jsn.has('address') or jsn.has('_address') then
        result.addressElement := parseUrl(jsn.node['address'], jsn.vObj['_address']);{q}
      if jsn.has('header') or jsn.has('_header') then
      iteratePrimitiveArray(jsn.vArr['header'], jsn.vArr['_header'], result.headerList, parseString);
end;

procedure TFHIRJsonComposer.ComposeEndpoint(json : TJSONWriter; name : string; elem : TFhirEndpoint; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirEndpointStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirEndpointStatusEnum, false);
  ComposeCoding(json, 'connectionType', elem.connectionType); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('managingOrganization') then
    ComposeReference{TFhirOrganization}(json, 'managingOrganization', elem.managingOrganization); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('contact') and (elem.contactList.Count > 0) then
  begin
    json.valueArray('contact');
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactPoint(json, '', elem.contactList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('period') then
    ComposePeriod(json, 'period', elem.period); {a}
  if (elem.payloadTypeList.Count > 0) then
  begin
    json.valueArray('payloadType');
    for i := 0 to elem.payloadTypeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.payloadTypeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('payloadMimeType') and (elem.payloadMimeTypeList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.payloadMimeTypeList.Count - 1 do
    begin
      ext := ext or ((elem.payloadMimeTypeList[i].id <> '') or (elem.payloadMimeTypeList[i].hasExtensionList) {no-comments or (elem.payloadMimeTypeList[i].hasComments)});
      val := val or (elem.payloadMimeTypeList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('payloadMimeType');
      for i := 0 to elem.payloadMimeTypeList.Count - 1 do
        ComposeCodeValue(json, '',elem.payloadMimeTypeList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_payloadMimeType');
      for i := 0 to elem.payloadMimeTypeList.Count - 1 do
        ComposeCodeProps(json, '',elem.payloadMimeTypeList[i], true);
      json.FinishArray;
    end;
  end;
  ComposeUrlValue(json, 'address', elem.addressElement, false);
  ComposeUrlProps(json, 'address', elem.addressElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('header') and (elem.headerList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.headerList.Count - 1 do
    begin
      ext := ext or ((elem.headerList[i].id <> '') or (elem.headerList[i].hasExtensionList) {no-comments or (elem.headerList[i].hasComments)});
      val := val or (elem.headerList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('header');
      for i := 0 to elem.headerList.Count - 1 do
        ComposeStringValue(json, '',elem.headerList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_header');
      for i := 0 to elem.headerList.Count - 1 do
        ComposeStringProps(json, '',elem.headerList[i], true);
      json.FinishArray;
    end;
  end;
end;

{$ENDIF FHIR_ENDPOINT}
{$IFDEF FHIR_ENROLLMENTREQUEST}
procedure TFHIRJsonParser.ParseEnrollmentRequest(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseEnrollmentRequest(jsn)); {2}
end;

function TFHIRJsonParser.ParseEnrollmentRequest(jsn : TJsonObject) : TFhirEnrollmentRequest;
begin
  result := TFhirEnrollmentRequest.create;
  try
    ParseEnrollmentRequestProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseEnrollmentRequestProperties(jsn : TJsonObject; result : TFhirEnrollmentRequest);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirFmStatusEnum, SYSTEMS_TFhirFmStatusEnum);
    if jsn.has('created') or jsn.has('_created') then
        result.createdElement := parseDateTime(jsn.node['created'], jsn.vObj['_created']);{q}
    if jsn.has('insurer') then
        result.insurer := ParseReference{TFhirOrganization}(jsn.vObj['insurer']);{q3}
    if jsn.has('provider') then
        result.provider := ParseReference{TFhirPractitioner}(jsn.vObj['provider']);{q3}
    if jsn.has('candidate') then
        result.candidate := ParseReference{TFhirPatient}(jsn.vObj['candidate']);{q3}
    if jsn.has('coverage') then
        result.coverage := ParseReference{TFhirCoverage}(jsn.vObj['coverage']);{q3}
end;

procedure TFHIRJsonComposer.ComposeEnrollmentRequest(json : TJSONWriter; name : string; elem : TFhirEnrollmentRequest; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirFmStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirFmStatusEnum, false);
  if (SummaryOption in [soFull, soData]) and doCompose('created') then
    ComposeDateTimeValue(json, 'created', elem.createdElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('created') then
    ComposeDateTimeProps(json, 'created', elem.createdElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('insurer') then
    ComposeReference{TFhirOrganization}(json, 'insurer', elem.insurer); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('provider') then
    ComposeReference{TFhirPractitioner}(json, 'provider', elem.provider); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('candidate') then
    ComposeReference{TFhirPatient}(json, 'candidate', elem.candidate); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('coverage') then
    ComposeReference{TFhirCoverage}(json, 'coverage', elem.coverage); {a}
end;

{$ENDIF FHIR_ENROLLMENTREQUEST}
{$IFDEF FHIR_ENROLLMENTRESPONSE}
procedure TFHIRJsonParser.ParseEnrollmentResponse(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseEnrollmentResponse(jsn)); {2}
end;

function TFHIRJsonParser.ParseEnrollmentResponse(jsn : TJsonObject) : TFhirEnrollmentResponse;
begin
  result := TFhirEnrollmentResponse.create;
  try
    ParseEnrollmentResponseProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseEnrollmentResponseProperties(jsn : TJsonObject; result : TFhirEnrollmentResponse);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirFmStatusEnum, SYSTEMS_TFhirFmStatusEnum);
    if jsn.has('request') then
        result.request := ParseReference{TFhirEnrollmentRequest}(jsn.vObj['request']);{q3}
    if jsn.has('outcome') or jsn.has('_outcome')  then
      result.outcomeElement := parseEnum(jsn.path+'/outcome', jsn.node['outcome'], jsn.vObj['_outcome'], CODES_TFhirRemittanceOutcomeEnum, SYSTEMS_TFhirRemittanceOutcomeEnum);
    if jsn.has('disposition') or jsn.has('_disposition') then
        result.dispositionElement := parseString(jsn.node['disposition'], jsn.vObj['_disposition']);{q}
    if jsn.has('created') or jsn.has('_created') then
        result.createdElement := parseDateTime(jsn.node['created'], jsn.vObj['_created']);{q}
    if jsn.has('organization') then
        result.organization := ParseReference{TFhirOrganization}(jsn.vObj['organization']);{q3}
    if jsn.has('requestProvider') then
        result.requestProvider := ParseReference{TFhirPractitioner}(jsn.vObj['requestProvider']);{q3}
end;

procedure TFHIRJsonComposer.ComposeEnrollmentResponse(json : TJSONWriter; name : string; elem : TFhirEnrollmentResponse; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirFmStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirFmStatusEnum, false);
  if (SummaryOption in [soFull, soData]) and doCompose('request') then
    ComposeReference{TFhirEnrollmentRequest}(json, 'request', elem.request); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('outcome') then
    ComposeEnumValue(json, 'outcome', elem.OutcomeElement, CODES_TFhirRemittanceOutcomeEnum, false);
  if (SummaryOption in [soFull, soData]) and doCompose('outcome') then
    ComposeEnumProps(json, 'outcome', elem.OutcomeElement, CODES_TFhirRemittanceOutcomeEnum, false);
  if (SummaryOption in [soFull, soData]) and doCompose('disposition') then
    ComposeStringValue(json, 'disposition', elem.dispositionElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('disposition') then
    ComposeStringProps(json, 'disposition', elem.dispositionElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('created') then
    ComposeDateTimeValue(json, 'created', elem.createdElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('created') then
    ComposeDateTimeProps(json, 'created', elem.createdElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('organization') then
    ComposeReference{TFhirOrganization}(json, 'organization', elem.organization); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('requestProvider') then
    ComposeReference{TFhirPractitioner}(json, 'requestProvider', elem.requestProvider); {a}
end;

{$ENDIF FHIR_ENROLLMENTRESPONSE}
{$IFDEF FHIR_EPISODEOFCARE}
procedure TFHIRJsonParser.ParseEpisodeOfCareStatusHistory(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseEpisodeOfCareStatusHistory(jsn)); {2}
end;

function TFHIRJsonParser.ParseEpisodeOfCareStatusHistory(jsn : TJsonObject) : TFhirEpisodeOfCareStatusHistory;
begin
  result := TFhirEpisodeOfCareStatusHistory.create;
  try
    ParseEpisodeOfCareStatusHistoryProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseEpisodeOfCareStatusHistoryProperties(jsn : TJsonObject; result : TFhirEpisodeOfCareStatusHistory);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirEpisodeOfCareStatusEnum, SYSTEMS_TFhirEpisodeOfCareStatusEnum);
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q3}
end;

procedure TFHIRJsonComposer.ComposeEpisodeOfCareStatusHistory(json : TJSONWriter; name : string; elem : TFhirEpisodeOfCareStatusHistory; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirEpisodeOfCareStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirEpisodeOfCareStatusEnum, false);
  ComposePeriod(json, 'period', elem.period); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseEpisodeOfCareDiagnosis(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseEpisodeOfCareDiagnosis(jsn)); {2}
end;

function TFHIRJsonParser.ParseEpisodeOfCareDiagnosis(jsn : TJsonObject) : TFhirEpisodeOfCareDiagnosis;
begin
  result := TFhirEpisodeOfCareDiagnosis.create;
  try
    ParseEpisodeOfCareDiagnosisProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseEpisodeOfCareDiagnosisProperties(jsn : TJsonObject; result : TFhirEpisodeOfCareDiagnosis);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('condition') then
        result.condition := ParseReference{TFhirCondition}(jsn.vObj['condition']);{q3}
    if jsn.has('role') then
        result.role := ParseCodeableConcept(jsn.vObj['role']);{q3}
    if jsn.has('rank') or jsn.has('_rank') then
        result.rankElement := parsePositiveInt(jsn.node['rank'], jsn.vObj['_rank']);{q}
end;

procedure TFHIRJsonComposer.ComposeEpisodeOfCareDiagnosis(json : TJSONWriter; name : string; elem : TFhirEpisodeOfCareDiagnosis; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeReference{TFhirCondition}(json, 'condition', elem.condition); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'role', elem.role); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveIntValue(json, 'rank', elem.rankElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveIntProps(json, 'rank', elem.rankElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseEpisodeOfCare(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseEpisodeOfCare(jsn)); {2}
end;

function TFHIRJsonParser.ParseEpisodeOfCare(jsn : TJsonObject) : TFhirEpisodeOfCare;
begin
  result := TFhirEpisodeOfCare.create;
  try
    ParseEpisodeOfCareProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseEpisodeOfCareProperties(jsn : TJsonObject; result : TFhirEpisodeOfCare);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirEpisodeOfCareStatusEnum, SYSTEMS_TFhirEpisodeOfCareStatusEnum);
    if jsn.has('statusHistory') then
      iterateArray(jsn.vArr['statusHistory'], result.statusHistoryList, parseEpisodeOfCareStatusHistory);
    if jsn.has('type') then
      iterateArray(jsn.vArr['type'], result.type_List, parseCodeableConcept);
    if jsn.has('diagnosis') then
      iterateArray(jsn.vArr['diagnosis'], result.diagnosisList, parseEpisodeOfCareDiagnosis);
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q3}
    if jsn.has('managingOrganization') then
        result.managingOrganization := ParseReference{TFhirOrganization}(jsn.vObj['managingOrganization']);{q3}
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q3}
    if jsn.has('referralRequest') then
      iterateArray(jsn.vArr['referralRequest'], result.referralRequestList, parseReference{TFhirServiceRequest});
    if jsn.has('careManager') then
        result.careManager := ParseReference{TFhirPractitioner}(jsn.vObj['careManager']);{q3}
    if jsn.has('team') then
      iterateArray(jsn.vArr['team'], result.teamList, parseReference{TFhirCareTeam});
    if jsn.has('account') then
      iterateArray(jsn.vArr['account'], result.accountList, parseReference{TFhirAccount});
end;

procedure TFHIRJsonComposer.ComposeEpisodeOfCare(json : TJSONWriter; name : string; elem : TFhirEpisodeOfCare; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirEpisodeOfCareStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirEpisodeOfCareStatusEnum, false);
  if (SummaryOption in [soFull, soData]) and doCompose('statusHistory') and (elem.statusHistoryList.Count > 0) then
  begin
    json.valueArray('statusHistory');
    for i := 0 to elem.statusHistoryList.Count - 1 do
      ComposeEpisodeOfCareStatusHistory(json, '', elem.statusHistoryList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') and (elem.type_List.Count > 0) then
  begin
    json.valueArray('type');
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(json, '', elem.type_List[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('diagnosis') and (elem.diagnosisList.Count > 0) then
  begin
    json.valueArray('diagnosis');
    for i := 0 to elem.diagnosisList.Count - 1 do
      ComposeEpisodeOfCareDiagnosis(json, '', elem.diagnosisList[i]); {z - }
    json.FinishArray;
  end;
  ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('managingOrganization') then
    ComposeReference{TFhirOrganization}(json, 'managingOrganization', elem.managingOrganization); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('period') then
    ComposePeriod(json, 'period', elem.period); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('referralRequest') and (elem.referralRequestList.Count > 0) then
  begin
    json.valueArray('referralRequest');
    for i := 0 to elem.referralRequestList.Count - 1 do
      ComposeReference{TFhirServiceRequest}(json, '', elem.referralRequestList[i]); {z - Reference(ServiceRequest)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('careManager') then
    ComposeReference{TFhirPractitioner}(json, 'careManager', elem.careManager); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('team') and (elem.teamList.Count > 0) then
  begin
    json.valueArray('team');
    for i := 0 to elem.teamList.Count - 1 do
      ComposeReference{TFhirCareTeam}(json, '', elem.teamList[i]); {z - Reference(CareTeam)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('account') and (elem.accountList.Count > 0) then
  begin
    json.valueArray('account');
    for i := 0 to elem.accountList.Count - 1 do
      ComposeReference{TFhirAccount}(json, '', elem.accountList[i]); {z - Reference(Account)}
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_EPISODEOFCARE}
{$IFDEF FHIR_EVENTDEFINITION}
procedure TFHIRJsonParser.ParseEventDefinition(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseEventDefinition(jsn)); {2}
end;

function TFHIRJsonParser.ParseEventDefinition(jsn : TJsonObject) : TFhirEventDefinition;
begin
  result := TFhirEventDefinition.create;
  try
    ParseEventDefinitionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseEventDefinitionProperties(jsn : TJsonObject; result : TFhirEventDefinition);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := parseUri(jsn.node['url'], jsn.vObj['_url']);{q}
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := parseString(jsn.node['version'], jsn.vObj['_version']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('title') or jsn.has('_title') then
        result.titleElement := parseString(jsn.node['title'], jsn.vObj['_title']);{q}
    if jsn.has('subtitle') or jsn.has('_subtitle') then
        result.subtitleElement := parseString(jsn.node['subtitle'], jsn.vObj['_subtitle']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    if jsn.has('experimental') or jsn.has('_experimental') then
        result.experimentalElement := parseBoolean(jsn.node['experimental'], jsn.vObj['_experimental']);{q}
    if jsn.has('subjectCodeableConcept') {a4} then
      result.subject := ParseCodeableConcept(jsn.vObj['subjectCodeableConcept']);
    if jsn.has('subjectReference') {a3} then
      result.subject := ParseReference(jsn.vObj['subjectReference']);
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := parseDateTime(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('publisher') or jsn.has('_publisher') then
        result.publisherElement := parseString(jsn.node['publisher'], jsn.vObj['_publisher']);{q}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseContactDetail);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseMarkdown(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('useContext') then
      iterateArray(jsn.vArr['useContext'], result.useContextList, parseUsageContext);
    if jsn.has('jurisdiction') then
      iterateArray(jsn.vArr['jurisdiction'], result.jurisdictionList, parseCodeableConcept);
    if jsn.has('purpose') or jsn.has('_purpose') then
        result.purposeElement := parseMarkdown(jsn.node['purpose'], jsn.vObj['_purpose']);{q}
    if jsn.has('usage') or jsn.has('_usage') then
        result.usageElement := parseString(jsn.node['usage'], jsn.vObj['_usage']);{q}
    if jsn.has('copyright') or jsn.has('_copyright') then
        result.copyrightElement := parseMarkdown(jsn.node['copyright'], jsn.vObj['_copyright']);{q}
    if jsn.has('approvalDate') or jsn.has('_approvalDate') then
        result.approvalDateElement := parseDate(jsn.node['approvalDate'], jsn.vObj['_approvalDate']);{q}
    if jsn.has('lastReviewDate') or jsn.has('_lastReviewDate') then
        result.lastReviewDateElement := parseDate(jsn.node['lastReviewDate'], jsn.vObj['_lastReviewDate']);{q}
    if jsn.has('effectivePeriod') then
        result.effectivePeriod := ParsePeriod(jsn.vObj['effectivePeriod']);{q3}
    if jsn.has('topic') then
      iterateArray(jsn.vArr['topic'], result.topicList, parseCodeableConcept);
    if jsn.has('author') then
      iterateArray(jsn.vArr['author'], result.authorList, parseContactDetail);
    if jsn.has('editor') then
      iterateArray(jsn.vArr['editor'], result.editorList, parseContactDetail);
    if jsn.has('reviewer') then
      iterateArray(jsn.vArr['reviewer'], result.reviewerList, parseContactDetail);
    if jsn.has('endorser') then
      iterateArray(jsn.vArr['endorser'], result.endorserList, parseContactDetail);
    if jsn.has('relatedArtifact') then
      iterateArray(jsn.vArr['relatedArtifact'], result.relatedArtifactList, parseRelatedArtifact);
    if jsn.has('trigger') then
      iterateArray(jsn.vArr['trigger'], result.triggerList, parseTriggerDefinition);
end;

procedure TFHIRJsonComposer.ComposeEventDefinition(json : TJSONWriter; name : string; elem : TFhirEventDefinition; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUriValue(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUriProps(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeStringValue(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeStringProps(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeStringValue(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeStringProps(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('subtitle') then
    ComposeStringValue(json, 'subtitle', elem.subtitleElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('subtitle') then
    ComposeStringProps(json, 'subtitle', elem.subtitleElement, false);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBooleanValue(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBooleanProps(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.subject is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'subjectCodeableConcept', TFhirCodeableConcept(elem.subject)) 
  else if (SummaryOption in [soFull, soData]) and (elem.subject is TFhirReference) then
    ComposeReference(json, 'subjectReference', TFhirReference(elem.subject));
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringValue(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringProps(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') and (elem.contactList.Count > 0) then
  begin
    json.valueArray('contact');
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(json, '', elem.contactList[i]); {z - ContactDetail}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdownValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdownProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') and (elem.useContextList.Count > 0) then
  begin
    json.valueArray('useContext');
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(json, '', elem.useContextList[i]); {z - UsageContext}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') and (elem.jurisdictionList.Count > 0) then
  begin
    json.valueArray('jurisdiction');
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.jurisdictionList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdownValue(json, 'purpose', elem.purposeElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdownProps(json, 'purpose', elem.purposeElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('usage') then
    ComposeStringValue(json, 'usage', elem.usageElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('usage') then
    ComposeStringProps(json, 'usage', elem.usageElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdownValue(json, 'copyright', elem.copyrightElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdownProps(json, 'copyright', elem.copyrightElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('approvalDate') then
    ComposeDateValue(json, 'approvalDate', elem.approvalDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('approvalDate') then
    ComposeDateProps(json, 'approvalDate', elem.approvalDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('lastReviewDate') then
    ComposeDateValue(json, 'lastReviewDate', elem.lastReviewDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('lastReviewDate') then
    ComposeDateProps(json, 'lastReviewDate', elem.lastReviewDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('effectivePeriod') then
    ComposePeriod(json, 'effectivePeriod', elem.effectivePeriod); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('topic') and (elem.topicList.Count > 0) then
  begin
    json.valueArray('topic');
    for i := 0 to elem.topicList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.topicList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('author') and (elem.authorList.Count > 0) then
  begin
    json.valueArray('author');
    for i := 0 to elem.authorList.Count - 1 do
      ComposeContactDetail(json, '', elem.authorList[i]); {z - ContactDetail}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('editor') and (elem.editorList.Count > 0) then
  begin
    json.valueArray('editor');
    for i := 0 to elem.editorList.Count - 1 do
      ComposeContactDetail(json, '', elem.editorList[i]); {z - ContactDetail}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('reviewer') and (elem.reviewerList.Count > 0) then
  begin
    json.valueArray('reviewer');
    for i := 0 to elem.reviewerList.Count - 1 do
      ComposeContactDetail(json, '', elem.reviewerList[i]); {z - ContactDetail}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('endorser') and (elem.endorserList.Count > 0) then
  begin
    json.valueArray('endorser');
    for i := 0 to elem.endorserList.Count - 1 do
      ComposeContactDetail(json, '', elem.endorserList[i]); {z - ContactDetail}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('relatedArtifact') and (elem.relatedArtifactList.Count > 0) then
  begin
    json.valueArray('relatedArtifact');
    for i := 0 to elem.relatedArtifactList.Count - 1 do
      ComposeRelatedArtifact(json, '', elem.relatedArtifactList[i]); {z - RelatedArtifact}
    json.FinishArray;
  end;
  if (elem.triggerList.Count > 0) then
  begin
    json.valueArray('trigger');
    for i := 0 to elem.triggerList.Count - 1 do
      ComposeTriggerDefinition(json, '', elem.triggerList[i]); {z - TriggerDefinition}
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_EVENTDEFINITION}
{$IFDEF FHIR_EVIDENCE}
procedure TFHIRJsonParser.ParseEvidence(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseEvidence(jsn)); {2}
end;

function TFHIRJsonParser.ParseEvidence(jsn : TJsonObject) : TFhirEvidence;
begin
  result := TFhirEvidence.create;
  try
    ParseEvidenceProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseEvidenceProperties(jsn : TJsonObject; result : TFhirEvidence);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := parseUri(jsn.node['url'], jsn.vObj['_url']);{q}
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := parseString(jsn.node['version'], jsn.vObj['_version']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('title') or jsn.has('_title') then
        result.titleElement := parseString(jsn.node['title'], jsn.vObj['_title']);{q}
    if jsn.has('shortTitle') or jsn.has('_shortTitle') then
        result.shortTitleElement := parseString(jsn.node['shortTitle'], jsn.vObj['_shortTitle']);{q}
    if jsn.has('subtitle') or jsn.has('_subtitle') then
        result.subtitleElement := parseString(jsn.node['subtitle'], jsn.vObj['_subtitle']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := parseDateTime(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('publisher') or jsn.has('_publisher') then
        result.publisherElement := parseString(jsn.node['publisher'], jsn.vObj['_publisher']);{q}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseContactDetail);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseMarkdown(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('note') then
      iterateArray(jsn.vArr['note'], result.noteList, parseAnnotation);
    if jsn.has('useContext') then
      iterateArray(jsn.vArr['useContext'], result.useContextList, parseUsageContext);
    if jsn.has('jurisdiction') then
      iterateArray(jsn.vArr['jurisdiction'], result.jurisdictionList, parseCodeableConcept);
    if jsn.has('copyright') or jsn.has('_copyright') then
        result.copyrightElement := parseMarkdown(jsn.node['copyright'], jsn.vObj['_copyright']);{q}
    if jsn.has('approvalDate') or jsn.has('_approvalDate') then
        result.approvalDateElement := parseDate(jsn.node['approvalDate'], jsn.vObj['_approvalDate']);{q}
    if jsn.has('lastReviewDate') or jsn.has('_lastReviewDate') then
        result.lastReviewDateElement := parseDate(jsn.node['lastReviewDate'], jsn.vObj['_lastReviewDate']);{q}
    if jsn.has('effectivePeriod') then
        result.effectivePeriod := ParsePeriod(jsn.vObj['effectivePeriod']);{q3}
    if jsn.has('topic') then
      iterateArray(jsn.vArr['topic'], result.topicList, parseCodeableConcept);
    if jsn.has('author') then
      iterateArray(jsn.vArr['author'], result.authorList, parseContactDetail);
    if jsn.has('editor') then
      iterateArray(jsn.vArr['editor'], result.editorList, parseContactDetail);
    if jsn.has('reviewer') then
      iterateArray(jsn.vArr['reviewer'], result.reviewerList, parseContactDetail);
    if jsn.has('endorser') then
      iterateArray(jsn.vArr['endorser'], result.endorserList, parseContactDetail);
    if jsn.has('relatedArtifact') then
      iterateArray(jsn.vArr['relatedArtifact'], result.relatedArtifactList, parseRelatedArtifact);
    if jsn.has('exposureBackground') then
        result.exposureBackground := ParseReference{TFhirEvidenceVariable}(jsn.vObj['exposureBackground']);{q3}
    if jsn.has('exposureVariant') then
      iterateArray(jsn.vArr['exposureVariant'], result.exposureVariantList, parseReference{TFhirEvidenceVariable});
    if jsn.has('outcome') then
      iterateArray(jsn.vArr['outcome'], result.outcomeList, parseReference{TFhirEvidenceVariable});
end;

procedure TFHIRJsonComposer.ComposeEvidence(json : TJSONWriter; name : string; elem : TFhirEvidence; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUriValue(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUriProps(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeStringValue(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeStringProps(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeStringValue(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeStringProps(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('shortTitle') then
    ComposeStringValue(json, 'shortTitle', elem.shortTitleElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('shortTitle') then
    ComposeStringProps(json, 'shortTitle', elem.shortTitleElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('subtitle') then
    ComposeStringValue(json, 'subtitle', elem.subtitleElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('subtitle') then
    ComposeStringProps(json, 'subtitle', elem.subtitleElement, false);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringValue(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringProps(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') and (elem.contactList.Count > 0) then
  begin
    json.valueArray('contact');
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(json, '', elem.contactList[i]); {z - ContactDetail}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeMarkdownValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeMarkdownProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('note') and (elem.noteList.Count > 0) then
  begin
    json.valueArray('note');
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(json, '', elem.noteList[i]); {z - Annotation}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') and (elem.useContextList.Count > 0) then
  begin
    json.valueArray('useContext');
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(json, '', elem.useContextList[i]); {z - UsageContext}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') and (elem.jurisdictionList.Count > 0) then
  begin
    json.valueArray('jurisdiction');
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.jurisdictionList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdownValue(json, 'copyright', elem.copyrightElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdownProps(json, 'copyright', elem.copyrightElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('approvalDate') then
    ComposeDateValue(json, 'approvalDate', elem.approvalDateElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('approvalDate') then
    ComposeDateProps(json, 'approvalDate', elem.approvalDateElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('lastReviewDate') then
    ComposeDateValue(json, 'lastReviewDate', elem.lastReviewDateElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('lastReviewDate') then
    ComposeDateProps(json, 'lastReviewDate', elem.lastReviewDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('effectivePeriod') then
    ComposePeriod(json, 'effectivePeriod', elem.effectivePeriod); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('topic') and (elem.topicList.Count > 0) then
  begin
    json.valueArray('topic');
    for i := 0 to elem.topicList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.topicList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('author') and (elem.authorList.Count > 0) then
  begin
    json.valueArray('author');
    for i := 0 to elem.authorList.Count - 1 do
      ComposeContactDetail(json, '', elem.authorList[i]); {z - ContactDetail}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('editor') and (elem.editorList.Count > 0) then
  begin
    json.valueArray('editor');
    for i := 0 to elem.editorList.Count - 1 do
      ComposeContactDetail(json, '', elem.editorList[i]); {z - ContactDetail}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('reviewer') and (elem.reviewerList.Count > 0) then
  begin
    json.valueArray('reviewer');
    for i := 0 to elem.reviewerList.Count - 1 do
      ComposeContactDetail(json, '', elem.reviewerList[i]); {z - ContactDetail}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('endorser') and (elem.endorserList.Count > 0) then
  begin
    json.valueArray('endorser');
    for i := 0 to elem.endorserList.Count - 1 do
      ComposeContactDetail(json, '', elem.endorserList[i]); {z - ContactDetail}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('relatedArtifact') and (elem.relatedArtifactList.Count > 0) then
  begin
    json.valueArray('relatedArtifact');
    for i := 0 to elem.relatedArtifactList.Count - 1 do
      ComposeRelatedArtifact(json, '', elem.relatedArtifactList[i]); {z - RelatedArtifact}
    json.FinishArray;
  end;
  ComposeReference{TFhirEvidenceVariable}(json, 'exposureBackground', elem.exposureBackground); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('exposureVariant') and (elem.exposureVariantList.Count > 0) then
  begin
    json.valueArray('exposureVariant');
    for i := 0 to elem.exposureVariantList.Count - 1 do
      ComposeReference{TFhirEvidenceVariable}(json, '', elem.exposureVariantList[i]); {z - Reference(EvidenceVariable)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('outcome') and (elem.outcomeList.Count > 0) then
  begin
    json.valueArray('outcome');
    for i := 0 to elem.outcomeList.Count - 1 do
      ComposeReference{TFhirEvidenceVariable}(json, '', elem.outcomeList[i]); {z - Reference(EvidenceVariable)}
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_EVIDENCE}
{$IFDEF FHIR_EVIDENCEVARIABLE}
procedure TFHIRJsonParser.ParseEvidenceVariableCharacteristic(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseEvidenceVariableCharacteristic(jsn)); {2}
end;

function TFHIRJsonParser.ParseEvidenceVariableCharacteristic(jsn : TJsonObject) : TFhirEvidenceVariableCharacteristic;
begin
  result := TFhirEvidenceVariableCharacteristic.create;
  try
    ParseEvidenceVariableCharacteristicProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseEvidenceVariableCharacteristicProperties(jsn : TJsonObject; result : TFhirEvidenceVariableCharacteristic);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('definitionReference') {a3} then
      result.definition := ParseReference(jsn.vObj['definitionReference']);
    if jsn.has('definitionCanonical') or jsn.has('_definitionCanonical') then
      result.definition := parseCanonical(jsn.node['definitionCanonical'], jsn.vObj['_definitionCanonical']);
    if jsn.has('definitionCodeableConcept') {a4} then
      result.definition := ParseCodeableConcept(jsn.vObj['definitionCodeableConcept']);
    if jsn.has('definitionExpression') {a4} then
      result.definition := ParseExpression(jsn.vObj['definitionExpression']);
    if jsn.has('definitionDataRequirement') {a4} then
      result.definition := ParseDataRequirement(jsn.vObj['definitionDataRequirement']);
    if jsn.has('definitionTriggerDefinition') {a4} then
      result.definition := ParseTriggerDefinition(jsn.vObj['definitionTriggerDefinition']);
    if jsn.has('usageContext') then
      iterateArray(jsn.vArr['usageContext'], result.usageContextList, parseUsageContext);
    if jsn.has('exclude') or jsn.has('_exclude') then
        result.excludeElement := parseBoolean(jsn.node['exclude'], jsn.vObj['_exclude']);{q}
    if jsn.has('participantEffectivePeriod') {a4} then
      result.participantEffective := ParsePeriod(jsn.vObj['participantEffectivePeriod']);
    if jsn.has('participantEffectiveDuration') {a4} then
      result.participantEffective := ParseDuration(jsn.vObj['participantEffectiveDuration']);
    if jsn.has('participantEffectiveTiming') {a4} then
      result.participantEffective := ParseTiming(jsn.vObj['participantEffectiveTiming']);
    if jsn.has('participantEffectiveDateTime') or jsn.has('_participantEffectiveDateTime') then
      result.participantEffective := parseDateTime(jsn.node['participantEffectiveDateTime'], jsn.vObj['_participantEffectiveDateTime']);
    if jsn.has('timeFromStart') then
        result.timeFromStart := ParseDuration(jsn.vObj['timeFromStart']);{q3}
    if jsn.has('groupMeasure') or jsn.has('_groupMeasure')  then
      result.groupMeasureElement := parseEnum(jsn.path+'/groupMeasure', jsn.node['groupMeasure'], jsn.vObj['_groupMeasure'], CODES_TFhirGroupMeasureEnum, SYSTEMS_TFhirGroupMeasureEnum);
end;

procedure TFHIRJsonComposer.ComposeEvidenceVariableCharacteristic(json : TJSONWriter; name : string; elem : TFhirEvidenceVariableCharacteristic; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (elem.definition is TFhirReference) then
    ComposeReference(json, 'definitionReference', TFhirReference(elem.definition))
  else if (elem.definition is TFhirCanonical) then 
  begin
    ComposeCanonicalValue(json, 'definitionCanonical', TFhirCanonical(elem.definition), false);
    ComposeCanonicalProps(json, 'definitionCanonical', TFhirCanonical(elem.definition), false);
  end
  else if (elem.definition is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'definitionCodeableConcept', TFhirCodeableConcept(elem.definition)) 
  else if (elem.definition is TFhirExpression) then 
    ComposeExpression(json, 'definitionExpression', TFhirExpression(elem.definition)) 
  else if (elem.definition is TFhirDataRequirement) then 
    ComposeDataRequirement(json, 'definitionDataRequirement', TFhirDataRequirement(elem.definition)) 
  else if (elem.definition is TFhirTriggerDefinition) then 
    ComposeTriggerDefinition(json, 'definitionTriggerDefinition', TFhirTriggerDefinition(elem.definition)) ;
  if (SummaryOption in [soFull, soData]) and (elem.usageContextList.Count > 0) then
  begin
    json.valueArray('usageContext');
    for i := 0 to elem.usageContextList.Count - 1 do
      ComposeUsageContext(json, '', elem.usageContextList[i]); {z - UsageContext}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'exclude', elem.excludeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'exclude', elem.excludeElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.participantEffective is TFhirPeriod) then 
    ComposePeriod(json, 'participantEffectivePeriod', TFhirPeriod(elem.participantEffective)) 
  else if (SummaryOption in [soFull, soData]) and (elem.participantEffective is TFhirDuration) then 
    ComposeDuration(json, 'participantEffectiveDuration', TFhirDuration(elem.participantEffective)) 
  else if (SummaryOption in [soFull, soData]) and (elem.participantEffective is TFhirTiming) then 
    ComposeTiming(json, 'participantEffectiveTiming', TFhirTiming(elem.participantEffective)) 
  else if (SummaryOption in [soFull, soData]) and (elem.participantEffective is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'participantEffectiveDateTime', TFhirDateTime(elem.participantEffective), false);
    ComposeDateTimeProps(json, 'participantEffectiveDateTime', TFhirDateTime(elem.participantEffective), false);
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeDuration(json, 'timeFromStart', elem.timeFromStart); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumValue(json, 'groupMeasure', elem.GroupMeasureElement, CODES_TFhirGroupMeasureEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumProps(json, 'groupMeasure', elem.GroupMeasureElement, CODES_TFhirGroupMeasureEnum, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseEvidenceVariable(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseEvidenceVariable(jsn)); {2}
end;

function TFHIRJsonParser.ParseEvidenceVariable(jsn : TJsonObject) : TFhirEvidenceVariable;
begin
  result := TFhirEvidenceVariable.create;
  try
    ParseEvidenceVariableProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseEvidenceVariableProperties(jsn : TJsonObject; result : TFhirEvidenceVariable);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := parseUri(jsn.node['url'], jsn.vObj['_url']);{q}
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := parseString(jsn.node['version'], jsn.vObj['_version']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('title') or jsn.has('_title') then
        result.titleElement := parseString(jsn.node['title'], jsn.vObj['_title']);{q}
    if jsn.has('shortTitle') or jsn.has('_shortTitle') then
        result.shortTitleElement := parseString(jsn.node['shortTitle'], jsn.vObj['_shortTitle']);{q}
    if jsn.has('subtitle') or jsn.has('_subtitle') then
        result.subtitleElement := parseString(jsn.node['subtitle'], jsn.vObj['_subtitle']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := parseDateTime(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('publisher') or jsn.has('_publisher') then
        result.publisherElement := parseString(jsn.node['publisher'], jsn.vObj['_publisher']);{q}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseContactDetail);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseMarkdown(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('note') then
      iterateArray(jsn.vArr['note'], result.noteList, parseAnnotation);
    if jsn.has('useContext') then
      iterateArray(jsn.vArr['useContext'], result.useContextList, parseUsageContext);
    if jsn.has('jurisdiction') then
      iterateArray(jsn.vArr['jurisdiction'], result.jurisdictionList, parseCodeableConcept);
    if jsn.has('copyright') or jsn.has('_copyright') then
        result.copyrightElement := parseMarkdown(jsn.node['copyright'], jsn.vObj['_copyright']);{q}
    if jsn.has('approvalDate') or jsn.has('_approvalDate') then
        result.approvalDateElement := parseDate(jsn.node['approvalDate'], jsn.vObj['_approvalDate']);{q}
    if jsn.has('lastReviewDate') or jsn.has('_lastReviewDate') then
        result.lastReviewDateElement := parseDate(jsn.node['lastReviewDate'], jsn.vObj['_lastReviewDate']);{q}
    if jsn.has('effectivePeriod') then
        result.effectivePeriod := ParsePeriod(jsn.vObj['effectivePeriod']);{q3}
    if jsn.has('topic') then
      iterateArray(jsn.vArr['topic'], result.topicList, parseCodeableConcept);
    if jsn.has('author') then
      iterateArray(jsn.vArr['author'], result.authorList, parseContactDetail);
    if jsn.has('editor') then
      iterateArray(jsn.vArr['editor'], result.editorList, parseContactDetail);
    if jsn.has('reviewer') then
      iterateArray(jsn.vArr['reviewer'], result.reviewerList, parseContactDetail);
    if jsn.has('endorser') then
      iterateArray(jsn.vArr['endorser'], result.endorserList, parseContactDetail);
    if jsn.has('relatedArtifact') then
      iterateArray(jsn.vArr['relatedArtifact'], result.relatedArtifactList, parseRelatedArtifact);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn.node['type'], jsn.vObj['_type'], CODES_TFhirVariableTypeEnum, SYSTEMS_TFhirVariableTypeEnum);
    if jsn.has('characteristic') then
      iterateArray(jsn.vArr['characteristic'], result.characteristicList, parseEvidenceVariableCharacteristic);
end;

procedure TFHIRJsonComposer.ComposeEvidenceVariable(json : TJSONWriter; name : string; elem : TFhirEvidenceVariable; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUriValue(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUriProps(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeStringValue(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeStringProps(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeStringValue(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeStringProps(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('shortTitle') then
    ComposeStringValue(json, 'shortTitle', elem.shortTitleElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('shortTitle') then
    ComposeStringProps(json, 'shortTitle', elem.shortTitleElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('subtitle') then
    ComposeStringValue(json, 'subtitle', elem.subtitleElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('subtitle') then
    ComposeStringProps(json, 'subtitle', elem.subtitleElement, false);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringValue(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringProps(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') and (elem.contactList.Count > 0) then
  begin
    json.valueArray('contact');
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(json, '', elem.contactList[i]); {z - ContactDetail}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeMarkdownValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeMarkdownProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('note') and (elem.noteList.Count > 0) then
  begin
    json.valueArray('note');
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(json, '', elem.noteList[i]); {z - Annotation}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') and (elem.useContextList.Count > 0) then
  begin
    json.valueArray('useContext');
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(json, '', elem.useContextList[i]); {z - UsageContext}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') and (elem.jurisdictionList.Count > 0) then
  begin
    json.valueArray('jurisdiction');
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.jurisdictionList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdownValue(json, 'copyright', elem.copyrightElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdownProps(json, 'copyright', elem.copyrightElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('approvalDate') then
    ComposeDateValue(json, 'approvalDate', elem.approvalDateElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('approvalDate') then
    ComposeDateProps(json, 'approvalDate', elem.approvalDateElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('lastReviewDate') then
    ComposeDateValue(json, 'lastReviewDate', elem.lastReviewDateElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('lastReviewDate') then
    ComposeDateProps(json, 'lastReviewDate', elem.lastReviewDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('effectivePeriod') then
    ComposePeriod(json, 'effectivePeriod', elem.effectivePeriod); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('topic') and (elem.topicList.Count > 0) then
  begin
    json.valueArray('topic');
    for i := 0 to elem.topicList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.topicList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('author') and (elem.authorList.Count > 0) then
  begin
    json.valueArray('author');
    for i := 0 to elem.authorList.Count - 1 do
      ComposeContactDetail(json, '', elem.authorList[i]); {z - ContactDetail}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('editor') and (elem.editorList.Count > 0) then
  begin
    json.valueArray('editor');
    for i := 0 to elem.editorList.Count - 1 do
      ComposeContactDetail(json, '', elem.editorList[i]); {z - ContactDetail}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('reviewer') and (elem.reviewerList.Count > 0) then
  begin
    json.valueArray('reviewer');
    for i := 0 to elem.reviewerList.Count - 1 do
      ComposeContactDetail(json, '', elem.reviewerList[i]); {z - ContactDetail}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('endorser') and (elem.endorserList.Count > 0) then
  begin
    json.valueArray('endorser');
    for i := 0 to elem.endorserList.Count - 1 do
      ComposeContactDetail(json, '', elem.endorserList[i]); {z - ContactDetail}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('relatedArtifact') and (elem.relatedArtifactList.Count > 0) then
  begin
    json.valueArray('relatedArtifact');
    for i := 0 to elem.relatedArtifactList.Count - 1 do
      ComposeRelatedArtifact(json, '', elem.relatedArtifactList[i]); {z - RelatedArtifact}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirVariableTypeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirVariableTypeEnum, false);
  if (elem.characteristicList.Count > 0) then
  begin
    json.valueArray('characteristic');
    for i := 0 to elem.characteristicList.Count - 1 do
      ComposeEvidenceVariableCharacteristic(json, '', elem.characteristicList[i]); {z - }
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_EVIDENCEVARIABLE}
{$IFDEF FHIR_EXAMPLESCENARIO}
procedure TFHIRJsonParser.ParseExampleScenarioActor(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseExampleScenarioActor(jsn)); {2}
end;

function TFHIRJsonParser.ParseExampleScenarioActor(jsn : TJsonObject) : TFhirExampleScenarioActor;
begin
  result := TFhirExampleScenarioActor.create;
  try
    ParseExampleScenarioActorProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseExampleScenarioActorProperties(jsn : TJsonObject; result : TFhirExampleScenarioActor);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('actorId') or jsn.has('_actorId') then
        result.actorIdElement := parseString(jsn.node['actorId'], jsn.vObj['_actorId']);{q}
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn.node['type'], jsn.vObj['_type'], CODES_TFhirExamplescenarioActorTypeEnum, SYSTEMS_TFhirExamplescenarioActorTypeEnum);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseMarkdown(jsn.node['description'], jsn.vObj['_description']);{q}
end;

procedure TFHIRJsonComposer.ComposeExampleScenarioActor(json : TJSONWriter; name : string; elem : TFhirExampleScenarioActor; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'actorId', elem.actorIdElement, false);
  ComposeStringProps(json, 'actorId', elem.actorIdElement, false);
  ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirExamplescenarioActorTypeEnum, false);
  ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirExamplescenarioActorTypeEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdownValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdownProps(json, 'description', elem.descriptionElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseExampleScenarioInstance(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseExampleScenarioInstance(jsn)); {2}
end;

function TFHIRJsonParser.ParseExampleScenarioInstance(jsn : TJsonObject) : TFhirExampleScenarioInstance;
begin
  result := TFhirExampleScenarioInstance.create;
  try
    ParseExampleScenarioInstanceProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseExampleScenarioInstanceProperties(jsn : TJsonObject; result : TFhirExampleScenarioInstance);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('resourceId') or jsn.has('_resourceId') then
        result.resourceIdElement := parseString(jsn.node['resourceId'], jsn.vObj['_resourceId']);{q}
    if jsn.has('resourceType') or jsn.has('_resourceType')  then
      result.resourceTypeElement := parseEnum(jsn.path+'/resourceType', jsn.node['resourceType'], jsn.vObj['_resourceType'], CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseMarkdown(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('version') then
      iterateArray(jsn.vArr['version'], result.versionList, parseExampleScenarioInstanceVersion);
    if jsn.has('containedInstance') then
      iterateArray(jsn.vArr['containedInstance'], result.containedInstanceList, parseExampleScenarioInstanceContainedInstance);
end;

procedure TFHIRJsonComposer.ComposeExampleScenarioInstance(json : TJSONWriter; name : string; elem : TFhirExampleScenarioInstance; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'resourceId', elem.resourceIdElement, false);
  ComposeStringProps(json, 'resourceId', elem.resourceIdElement, false);
  ComposeEnumValue(json, 'resourceType', elem.ResourceTypeElement, CODES_TFhirResourceTypesEnum, false);
  ComposeEnumProps(json, 'resourceType', elem.ResourceTypeElement, CODES_TFhirResourceTypesEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdownValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdownProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.versionList.Count > 0) then
  begin
    json.valueArray('version');
    for i := 0 to elem.versionList.Count - 1 do
      ComposeExampleScenarioInstanceVersion(json, '', elem.versionList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.containedInstanceList.Count > 0) then
  begin
    json.valueArray('containedInstance');
    for i := 0 to elem.containedInstanceList.Count - 1 do
      ComposeExampleScenarioInstanceContainedInstance(json, '', elem.containedInstanceList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseExampleScenarioInstanceVersion(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseExampleScenarioInstanceVersion(jsn)); {2}
end;

function TFHIRJsonParser.ParseExampleScenarioInstanceVersion(jsn : TJsonObject) : TFhirExampleScenarioInstanceVersion;
begin
  result := TFhirExampleScenarioInstanceVersion.create;
  try
    ParseExampleScenarioInstanceVersionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseExampleScenarioInstanceVersionProperties(jsn : TJsonObject; result : TFhirExampleScenarioInstanceVersion);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('versionId') or jsn.has('_versionId') then
        result.versionIdElement := parseString(jsn.node['versionId'], jsn.vObj['_versionId']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseMarkdown(jsn.node['description'], jsn.vObj['_description']);{q}
end;

procedure TFHIRJsonComposer.ComposeExampleScenarioInstanceVersion(json : TJSONWriter; name : string; elem : TFhirExampleScenarioInstanceVersion; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'versionId', elem.versionIdElement, false);
  ComposeStringProps(json, 'versionId', elem.versionIdElement, false);
  ComposeMarkdownValue(json, 'description', elem.descriptionElement, false);
  ComposeMarkdownProps(json, 'description', elem.descriptionElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseExampleScenarioInstanceContainedInstance(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseExampleScenarioInstanceContainedInstance(jsn)); {2}
end;

function TFHIRJsonParser.ParseExampleScenarioInstanceContainedInstance(jsn : TJsonObject) : TFhirExampleScenarioInstanceContainedInstance;
begin
  result := TFhirExampleScenarioInstanceContainedInstance.create;
  try
    ParseExampleScenarioInstanceContainedInstanceProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseExampleScenarioInstanceContainedInstanceProperties(jsn : TJsonObject; result : TFhirExampleScenarioInstanceContainedInstance);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('resourceId') or jsn.has('_resourceId') then
        result.resourceIdElement := parseString(jsn.node['resourceId'], jsn.vObj['_resourceId']);{q}
    if jsn.has('versionId') or jsn.has('_versionId') then
        result.versionIdElement := parseString(jsn.node['versionId'], jsn.vObj['_versionId']);{q}
end;

procedure TFHIRJsonComposer.ComposeExampleScenarioInstanceContainedInstance(json : TJSONWriter; name : string; elem : TFhirExampleScenarioInstanceContainedInstance; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'resourceId', elem.resourceIdElement, false);
  ComposeStringProps(json, 'resourceId', elem.resourceIdElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'versionId', elem.versionIdElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'versionId', elem.versionIdElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseExampleScenarioProcess(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseExampleScenarioProcess(jsn)); {2}
end;

function TFHIRJsonParser.ParseExampleScenarioProcess(jsn : TJsonObject) : TFhirExampleScenarioProcess;
begin
  result := TFhirExampleScenarioProcess.create;
  try
    ParseExampleScenarioProcessProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseExampleScenarioProcessProperties(jsn : TJsonObject; result : TFhirExampleScenarioProcess);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('title') or jsn.has('_title') then
        result.titleElement := parseString(jsn.node['title'], jsn.vObj['_title']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseMarkdown(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('preConditions') or jsn.has('_preConditions') then
        result.preConditionsElement := parseMarkdown(jsn.node['preConditions'], jsn.vObj['_preConditions']);{q}
    if jsn.has('postConditions') or jsn.has('_postConditions') then
        result.postConditionsElement := parseMarkdown(jsn.node['postConditions'], jsn.vObj['_postConditions']);{q}
    if jsn.has('step') then
      iterateArray(jsn.vArr['step'], result.stepList, parseExampleScenarioProcessStep);
end;

procedure TFHIRJsonComposer.ComposeExampleScenarioProcess(json : TJSONWriter; name : string; elem : TFhirExampleScenarioProcess; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'title', elem.titleElement, false);
  ComposeStringProps(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdownValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdownProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdownValue(json, 'preConditions', elem.preConditionsElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdownProps(json, 'preConditions', elem.preConditionsElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdownValue(json, 'postConditions', elem.postConditionsElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdownProps(json, 'postConditions', elem.postConditionsElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.stepList.Count > 0) then
  begin
    json.valueArray('step');
    for i := 0 to elem.stepList.Count - 1 do
      ComposeExampleScenarioProcessStep(json, '', elem.stepList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseExampleScenarioProcessStep(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseExampleScenarioProcessStep(jsn)); {2}
end;

function TFHIRJsonParser.ParseExampleScenarioProcessStep(jsn : TJsonObject) : TFhirExampleScenarioProcessStep;
begin
  result := TFhirExampleScenarioProcessStep.create;
  try
    ParseExampleScenarioProcessStepProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseExampleScenarioProcessStepProperties(jsn : TJsonObject; result : TFhirExampleScenarioProcessStep);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('process') then
      iterateArray(jsn.vArr['process'], result.processList, parseExampleScenarioProcess);
    if jsn.has('pause') or jsn.has('_pause') then
        result.pauseElement := parseBoolean(jsn.node['pause'], jsn.vObj['_pause']);{q}
    if jsn.has('operation') then
        result.operation := ParseExampleScenarioProcessStepOperation(jsn.vObj['operation']);{q3}
    if jsn.has('alternative') then
      iterateArray(jsn.vArr['alternative'], result.alternativeList, parseExampleScenarioProcessStepAlternative);
end;

procedure TFHIRJsonComposer.ComposeExampleScenarioProcessStep(json : TJSONWriter; name : string; elem : TFhirExampleScenarioProcessStep; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and (elem.processList.Count > 0) then
  begin
    json.valueArray('process');
    for i := 0 to elem.processList.Count - 1 do
      ComposeExampleScenarioProcess(json, '', elem.processList[i]); {z - @ExampleScenario.process}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'pause', elem.pauseElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'pause', elem.pauseElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeExampleScenarioProcessStepOperation(json, 'operation', elem.operation); {a}
  if (SummaryOption in [soFull, soData]) and (elem.alternativeList.Count > 0) then
  begin
    json.valueArray('alternative');
    for i := 0 to elem.alternativeList.Count - 1 do
      ComposeExampleScenarioProcessStepAlternative(json, '', elem.alternativeList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseExampleScenarioProcessStepOperation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseExampleScenarioProcessStepOperation(jsn)); {2}
end;

function TFHIRJsonParser.ParseExampleScenarioProcessStepOperation(jsn : TJsonObject) : TFhirExampleScenarioProcessStepOperation;
begin
  result := TFhirExampleScenarioProcessStepOperation.create;
  try
    ParseExampleScenarioProcessStepOperationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseExampleScenarioProcessStepOperationProperties(jsn : TJsonObject; result : TFhirExampleScenarioProcessStepOperation);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('number') or jsn.has('_number') then
        result.numberElement := parseString(jsn.node['number'], jsn.vObj['_number']);{q}
    if jsn.has('type') or jsn.has('_type') then
        result.type_Element := parseString(jsn.node['type'], jsn.vObj['_type']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('initiator') or jsn.has('_initiator') then
        result.initiatorElement := parseString(jsn.node['initiator'], jsn.vObj['_initiator']);{q}
    if jsn.has('receiver') or jsn.has('_receiver') then
        result.receiverElement := parseString(jsn.node['receiver'], jsn.vObj['_receiver']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseMarkdown(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('initiatorActive') or jsn.has('_initiatorActive') then
        result.initiatorActiveElement := parseBoolean(jsn.node['initiatorActive'], jsn.vObj['_initiatorActive']);{q}
    if jsn.has('receiverActive') or jsn.has('_receiverActive') then
        result.receiverActiveElement := parseBoolean(jsn.node['receiverActive'], jsn.vObj['_receiverActive']);{q}
    if jsn.has('request') then
        result.request := ParseExampleScenarioInstanceContainedInstance(jsn.vObj['request']);{q3}
    if jsn.has('response') then
        result.response := ParseExampleScenarioInstanceContainedInstance(jsn.vObj['response']);{q3}
end;

procedure TFHIRJsonComposer.ComposeExampleScenarioProcessStepOperation(json : TJSONWriter; name : string; elem : TFhirExampleScenarioProcessStepOperation; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'number', elem.numberElement, false);
  ComposeStringProps(json, 'number', elem.numberElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'type', elem.type_Element, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'type', elem.type_Element, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'initiator', elem.initiatorElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'initiator', elem.initiatorElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'receiver', elem.receiverElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'receiver', elem.receiverElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdownValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdownProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'initiatorActive', elem.initiatorActiveElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'initiatorActive', elem.initiatorActiveElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'receiverActive', elem.receiverActiveElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'receiverActive', elem.receiverActiveElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeExampleScenarioInstanceContainedInstance(json, 'request', elem.request); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeExampleScenarioInstanceContainedInstance(json, 'response', elem.response); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseExampleScenarioProcessStepAlternative(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseExampleScenarioProcessStepAlternative(jsn)); {2}
end;

function TFHIRJsonParser.ParseExampleScenarioProcessStepAlternative(jsn : TJsonObject) : TFhirExampleScenarioProcessStepAlternative;
begin
  result := TFhirExampleScenarioProcessStepAlternative.create;
  try
    ParseExampleScenarioProcessStepAlternativeProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseExampleScenarioProcessStepAlternativeProperties(jsn : TJsonObject; result : TFhirExampleScenarioProcessStepAlternative);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('title') or jsn.has('_title') then
        result.titleElement := parseString(jsn.node['title'], jsn.vObj['_title']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseMarkdown(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('step') then
      iterateArray(jsn.vArr['step'], result.stepList, parseExampleScenarioProcessStep);
end;

procedure TFHIRJsonComposer.ComposeExampleScenarioProcessStepAlternative(json : TJSONWriter; name : string; elem : TFhirExampleScenarioProcessStepAlternative; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'title', elem.titleElement, false);
  ComposeStringProps(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soData]) then
  ComposeMarkdownValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
  ComposeMarkdownProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.stepList.Count > 0) then
  begin
    json.valueArray('step');
    for i := 0 to elem.stepList.Count - 1 do
      ComposeExampleScenarioProcessStep(json, '', elem.stepList[i]); {z - @ExampleScenario.process.step}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseExampleScenario(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseExampleScenario(jsn)); {2}
end;

function TFHIRJsonParser.ParseExampleScenario(jsn : TJsonObject) : TFhirExampleScenario;
begin
  result := TFhirExampleScenario.create;
  try
    ParseExampleScenarioProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseExampleScenarioProperties(jsn : TJsonObject; result : TFhirExampleScenario);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := parseUri(jsn.node['url'], jsn.vObj['_url']);{q}
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := parseString(jsn.node['version'], jsn.vObj['_version']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    if jsn.has('experimental') or jsn.has('_experimental') then
        result.experimentalElement := parseBoolean(jsn.node['experimental'], jsn.vObj['_experimental']);{q}
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := parseDateTime(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('publisher') or jsn.has('_publisher') then
        result.publisherElement := parseString(jsn.node['publisher'], jsn.vObj['_publisher']);{q}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseContactDetail);
    if jsn.has('useContext') then
      iterateArray(jsn.vArr['useContext'], result.useContextList, parseUsageContext);
    if jsn.has('jurisdiction') then
      iterateArray(jsn.vArr['jurisdiction'], result.jurisdictionList, parseCodeableConcept);
    if jsn.has('copyright') or jsn.has('_copyright') then
        result.copyrightElement := parseMarkdown(jsn.node['copyright'], jsn.vObj['_copyright']);{q}
    if jsn.has('purpose') or jsn.has('_purpose') then
        result.purposeElement := parseMarkdown(jsn.node['purpose'], jsn.vObj['_purpose']);{q}
    if jsn.has('actor') then
      iterateArray(jsn.vArr['actor'], result.actorList, parseExampleScenarioActor);
    if jsn.has('instance') then
      iterateArray(jsn.vArr['instance'], result.instanceList, parseExampleScenarioInstance);
    if jsn.has('process') then
      iterateArray(jsn.vArr['process'], result.processList, parseExampleScenarioProcess);
      if jsn.has('workflow') or jsn.has('_workflow') then
      iteratePrimitiveArray(jsn.vArr['workflow'], jsn.vArr['_workflow'], result.workflowList, parseCanonical);
end;

procedure TFHIRJsonComposer.ComposeExampleScenario(json : TJSONWriter; name : string; elem : TFhirExampleScenario; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUriValue(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUriProps(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeStringValue(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeStringProps(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBooleanValue(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBooleanProps(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringValue(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringProps(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') and (elem.contactList.Count > 0) then
  begin
    json.valueArray('contact');
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(json, '', elem.contactList[i]); {z - ContactDetail}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') and (elem.useContextList.Count > 0) then
  begin
    json.valueArray('useContext');
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(json, '', elem.useContextList[i]); {z - UsageContext}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') and (elem.jurisdictionList.Count > 0) then
  begin
    json.valueArray('jurisdiction');
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.jurisdictionList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdownValue(json, 'copyright', elem.copyrightElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdownProps(json, 'copyright', elem.copyrightElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdownValue(json, 'purpose', elem.purposeElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdownProps(json, 'purpose', elem.purposeElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('actor') and (elem.actorList.Count > 0) then
  begin
    json.valueArray('actor');
    for i := 0 to elem.actorList.Count - 1 do
      ComposeExampleScenarioActor(json, '', elem.actorList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('instance') and (elem.instanceList.Count > 0) then
  begin
    json.valueArray('instance');
    for i := 0 to elem.instanceList.Count - 1 do
      ComposeExampleScenarioInstance(json, '', elem.instanceList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('process') and (elem.processList.Count > 0) then
  begin
    json.valueArray('process');
    for i := 0 to elem.processList.Count - 1 do
      ComposeExampleScenarioProcess(json, '', elem.processList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('workflow') and (elem.workflowList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.workflowList.Count - 1 do
    begin
      ext := ext or ((elem.workflowList[i].id <> '') or (elem.workflowList[i].hasExtensionList) {no-comments or (elem.workflowList[i].hasComments)});
      val := val or (elem.workflowList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('workflow');
      for i := 0 to elem.workflowList.Count - 1 do
        ComposeCanonicalValue(json, '',elem.workflowList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_workflow');
      for i := 0 to elem.workflowList.Count - 1 do
        ComposeCanonicalProps(json, '',elem.workflowList[i], true);
      json.FinishArray;
    end;
  end;
end;

{$ENDIF FHIR_EXAMPLESCENARIO}
{$IFDEF FHIR_EXPLANATIONOFBENEFIT}
procedure TFHIRJsonParser.ParseExplanationOfBenefitRelated(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseExplanationOfBenefitRelated(jsn)); {2}
end;

function TFHIRJsonParser.ParseExplanationOfBenefitRelated(jsn : TJsonObject) : TFhirExplanationOfBenefitRelated;
begin
  result := TFhirExplanationOfBenefitRelated.create;
  try
    ParseExplanationOfBenefitRelatedProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseExplanationOfBenefitRelatedProperties(jsn : TJsonObject; result : TFhirExplanationOfBenefitRelated);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('claim') then
        result.claim := ParseReference{TFhirClaim}(jsn.vObj['claim']);{q3}
    if jsn.has('relationship') then
        result.relationship := ParseCodeableConcept(jsn.vObj['relationship']);{q3}
    if jsn.has('reference') then
        result.reference := ParseIdentifier(jsn.vObj['reference']);{q3}
end;

procedure TFHIRJsonComposer.ComposeExplanationOfBenefitRelated(json : TJSONWriter; name : string; elem : TFhirExplanationOfBenefitRelated; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirClaim}(json, 'claim', elem.claim); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'relationship', elem.relationship); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(json, 'reference', elem.reference); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseExplanationOfBenefitPayee(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseExplanationOfBenefitPayee(jsn)); {2}
end;

function TFHIRJsonParser.ParseExplanationOfBenefitPayee(jsn : TJsonObject) : TFhirExplanationOfBenefitPayee;
begin
  result := TFhirExplanationOfBenefitPayee.create;
  try
    ParseExplanationOfBenefitPayeeProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseExplanationOfBenefitPayeeProperties(jsn : TJsonObject; result : TFhirExplanationOfBenefitPayee);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('party') then
        result.party := ParseReference{TFhirPractitioner}(jsn.vObj['party']);{q3}
end;

procedure TFHIRJsonComposer.ComposeExplanationOfBenefitPayee(json : TJSONWriter; name : string; elem : TFhirExplanationOfBenefitPayee; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirPractitioner}(json, 'party', elem.party); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseExplanationOfBenefitCareTeam(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseExplanationOfBenefitCareTeam(jsn)); {2}
end;

function TFHIRJsonParser.ParseExplanationOfBenefitCareTeam(jsn : TJsonObject) : TFhirExplanationOfBenefitCareTeam;
begin
  result := TFhirExplanationOfBenefitCareTeam.create;
  try
    ParseExplanationOfBenefitCareTeamProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseExplanationOfBenefitCareTeamProperties(jsn : TJsonObject; result : TFhirExplanationOfBenefitCareTeam);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('sequence') or jsn.has('_sequence') then
        result.sequenceElement := parsePositiveInt(jsn.node['sequence'], jsn.vObj['_sequence']);{q}
    if jsn.has('provider') then
        result.provider := ParseReference{TFhirPractitioner}(jsn.vObj['provider']);{q3}
    if jsn.has('responsible') or jsn.has('_responsible') then
        result.responsibleElement := parseBoolean(jsn.node['responsible'], jsn.vObj['_responsible']);{q}
    if jsn.has('role') then
        result.role := ParseCodeableConcept(jsn.vObj['role']);{q3}
    if jsn.has('qualification') then
        result.qualification := ParseCodeableConcept(jsn.vObj['qualification']);{q3}
end;

procedure TFHIRJsonComposer.ComposeExplanationOfBenefitCareTeam(json : TJSONWriter; name : string; elem : TFhirExplanationOfBenefitCareTeam; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposePositiveIntValue(json, 'sequence', elem.sequenceElement, false);
  ComposePositiveIntProps(json, 'sequence', elem.sequenceElement, false);
  ComposeReference{TFhirPractitioner}(json, 'provider', elem.provider); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'responsible', elem.responsibleElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'responsible', elem.responsibleElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'role', elem.role); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'qualification', elem.qualification); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseExplanationOfBenefitSupportingInfo(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseExplanationOfBenefitSupportingInfo(jsn)); {2}
end;

function TFHIRJsonParser.ParseExplanationOfBenefitSupportingInfo(jsn : TJsonObject) : TFhirExplanationOfBenefitSupportingInfo;
begin
  result := TFhirExplanationOfBenefitSupportingInfo.create;
  try
    ParseExplanationOfBenefitSupportingInfoProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseExplanationOfBenefitSupportingInfoProperties(jsn : TJsonObject; result : TFhirExplanationOfBenefitSupportingInfo);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('sequence') or jsn.has('_sequence') then
        result.sequenceElement := parsePositiveInt(jsn.node['sequence'], jsn.vObj['_sequence']);{q}
    if jsn.has('category') then
        result.category := ParseCodeableConcept(jsn.vObj['category']);{q3}
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('timingPeriod') {a4} then
      result.timing := ParsePeriod(jsn.vObj['timingPeriod']);
    if jsn.has('timingDate') or jsn.has('_timingDate') then
      result.timing := parseDate(jsn.node['timingDate'], jsn.vObj['_timingDate']);
    if jsn.has('valueQuantity') {a4} then
      result.value := ParseQuantity(jsn.vObj['valueQuantity']);
    if jsn.has('valueAttachment') {a4} then
      result.value := ParseAttachment(jsn.vObj['valueAttachment']);
    if jsn.has('valueReference') {a3} then
      result.value := ParseReference(jsn.vObj['valueReference']);
    if jsn.has('valueBoolean') or jsn.has('_valueBoolean') then
      result.value := parseBoolean(jsn.node['valueBoolean'], jsn.vObj['_valueBoolean']);
    if jsn.has('valueString') or jsn.has('_valueString') then
      result.value := parseString(jsn.node['valueString'], jsn.vObj['_valueString']);
    if jsn.has('reason') then
        result.reason := ParseCoding(jsn.vObj['reason']);{q3}
end;

procedure TFHIRJsonComposer.ComposeExplanationOfBenefitSupportingInfo(json : TJSONWriter; name : string; elem : TFhirExplanationOfBenefitSupportingInfo; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposePositiveIntValue(json, 'sequence', elem.sequenceElement, false);
  ComposePositiveIntProps(json, 'sequence', elem.sequenceElement, false);
  ComposeCodeableConcept(json, 'category', elem.category); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirPeriod) then 
    ComposePeriod(json, 'timingPeriod', TFhirPeriod(elem.timing)) 
  else if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirDate) then 
  begin
    ComposeDateValue(json, 'timingDate', TFhirDate(elem.timing), false);
    ComposeDateProps(json, 'timingDate', TFhirDate(elem.timing), false);
  end;
  if (SummaryOption in [soFull, soData]) and (elem.value is TFhirQuantity) then 
    ComposeQuantity(json, 'valueQuantity', TFhirQuantity(elem.value)) 
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirAttachment) then 
    ComposeAttachment(json, 'valueAttachment', TFhirAttachment(elem.value)) 
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirReference) then
    ComposeReference(json, 'valueReference', TFhirReference(elem.value))
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'valueBoolean', TFhirBoolean(elem.value), false);
    ComposeBooleanProps(json, 'valueBoolean', TFhirBoolean(elem.value), false);
  end
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirString) then 
  begin
    ComposeStringValue(json, 'valueString', TFhirString(elem.value), false);
    ComposeStringProps(json, 'valueString', TFhirString(elem.value), false);
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(json, 'reason', elem.reason); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseExplanationOfBenefitDiagnosis(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseExplanationOfBenefitDiagnosis(jsn)); {2}
end;

function TFHIRJsonParser.ParseExplanationOfBenefitDiagnosis(jsn : TJsonObject) : TFhirExplanationOfBenefitDiagnosis;
begin
  result := TFhirExplanationOfBenefitDiagnosis.create;
  try
    ParseExplanationOfBenefitDiagnosisProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseExplanationOfBenefitDiagnosisProperties(jsn : TJsonObject; result : TFhirExplanationOfBenefitDiagnosis);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('sequence') or jsn.has('_sequence') then
        result.sequenceElement := parsePositiveInt(jsn.node['sequence'], jsn.vObj['_sequence']);{q}
    if jsn.has('diagnosisCodeableConcept') {a4} then
      result.diagnosis := ParseCodeableConcept(jsn.vObj['diagnosisCodeableConcept']);
    if jsn.has('diagnosisReference') {a3} then
      result.diagnosis := ParseReference(jsn.vObj['diagnosisReference']);
    if jsn.has('type') then
      iterateArray(jsn.vArr['type'], result.type_List, parseCodeableConcept);
    if jsn.has('onAdmission') then
        result.onAdmission := ParseCodeableConcept(jsn.vObj['onAdmission']);{q3}
    if jsn.has('packageCode') then
        result.packageCode := ParseCodeableConcept(jsn.vObj['packageCode']);{q3}
end;

procedure TFHIRJsonComposer.ComposeExplanationOfBenefitDiagnosis(json : TJSONWriter; name : string; elem : TFhirExplanationOfBenefitDiagnosis; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposePositiveIntValue(json, 'sequence', elem.sequenceElement, false);
  ComposePositiveIntProps(json, 'sequence', elem.sequenceElement, false);
  if (elem.diagnosis is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'diagnosisCodeableConcept', TFhirCodeableConcept(elem.diagnosis)) 
  else if (elem.diagnosis is TFhirReference) then
    ComposeReference(json, 'diagnosisReference', TFhirReference(elem.diagnosis));
  if (SummaryOption in [soFull, soData]) and (elem.type_List.Count > 0) then
  begin
    json.valueArray('type');
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(json, '', elem.type_List[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'onAdmission', elem.onAdmission); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'packageCode', elem.packageCode); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseExplanationOfBenefitProcedure(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseExplanationOfBenefitProcedure(jsn)); {2}
end;

function TFHIRJsonParser.ParseExplanationOfBenefitProcedure(jsn : TJsonObject) : TFhirExplanationOfBenefitProcedure;
begin
  result := TFhirExplanationOfBenefitProcedure.create;
  try
    ParseExplanationOfBenefitProcedureProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseExplanationOfBenefitProcedureProperties(jsn : TJsonObject; result : TFhirExplanationOfBenefitProcedure);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('sequence') or jsn.has('_sequence') then
        result.sequenceElement := parsePositiveInt(jsn.node['sequence'], jsn.vObj['_sequence']);{q}
    if jsn.has('type') then
      iterateArray(jsn.vArr['type'], result.type_List, parseCodeableConcept);
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := parseDateTime(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('procedureCodeableConcept') {a4} then
      result.procedure_ := ParseCodeableConcept(jsn.vObj['procedureCodeableConcept']);
    if jsn.has('procedureReference') {a3} then
      result.procedure_ := ParseReference(jsn.vObj['procedureReference']);
    if jsn.has('udi') then
      iterateArray(jsn.vArr['udi'], result.udiList, parseReference{TFhirDevice});
end;

procedure TFHIRJsonComposer.ComposeExplanationOfBenefitProcedure(json : TJSONWriter; name : string; elem : TFhirExplanationOfBenefitProcedure; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposePositiveIntValue(json, 'sequence', elem.sequenceElement, false);
  ComposePositiveIntProps(json, 'sequence', elem.sequenceElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.type_List.Count > 0) then
  begin
    json.valueArray('type');
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(json, '', elem.type_List[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (elem.procedure_ is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'procedureCodeableConcept', TFhirCodeableConcept(elem.procedure_)) 
  else if (elem.procedure_ is TFhirReference) then
    ComposeReference(json, 'procedureReference', TFhirReference(elem.procedure_));
  if (SummaryOption in [soFull, soData]) and (elem.udiList.Count > 0) then
  begin
    json.valueArray('udi');
    for i := 0 to elem.udiList.Count - 1 do
      ComposeReference{TFhirDevice}(json, '', elem.udiList[i]); {z - Reference(Device)}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseExplanationOfBenefitInsurance(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseExplanationOfBenefitInsurance(jsn)); {2}
end;

function TFHIRJsonParser.ParseExplanationOfBenefitInsurance(jsn : TJsonObject) : TFhirExplanationOfBenefitInsurance;
begin
  result := TFhirExplanationOfBenefitInsurance.create;
  try
    ParseExplanationOfBenefitInsuranceProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseExplanationOfBenefitInsuranceProperties(jsn : TJsonObject; result : TFhirExplanationOfBenefitInsurance);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('focal') or jsn.has('_focal') then
        result.focalElement := parseBoolean(jsn.node['focal'], jsn.vObj['_focal']);{q}
    if jsn.has('coverage') then
        result.coverage := ParseReference{TFhirCoverage}(jsn.vObj['coverage']);{q3}
      if jsn.has('preAuthRef') or jsn.has('_preAuthRef') then
      iteratePrimitiveArray(jsn.vArr['preAuthRef'], jsn.vArr['_preAuthRef'], result.preAuthRefList, parseString);
end;

procedure TFHIRJsonComposer.ComposeExplanationOfBenefitInsurance(json : TJSONWriter; name : string; elem : TFhirExplanationOfBenefitInsurance; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeBooleanValue(json, 'focal', elem.focalElement, false);
  ComposeBooleanProps(json, 'focal', elem.focalElement, false);
  ComposeReference{TFhirCoverage}(json, 'coverage', elem.coverage); {a}
  if (SummaryOption in [soFull, soData]) and (elem.preAuthRefList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.preAuthRefList.Count - 1 do
    begin
      ext := ext or ((elem.preAuthRefList[i].id <> '') or (elem.preAuthRefList[i].hasExtensionList) {no-comments or (elem.preAuthRefList[i].hasComments)});
      val := val or (elem.preAuthRefList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('preAuthRef');
      for i := 0 to elem.preAuthRefList.Count - 1 do
        ComposeStringValue(json, '',elem.preAuthRefList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_preAuthRef');
      for i := 0 to elem.preAuthRefList.Count - 1 do
        ComposeStringProps(json, '',elem.preAuthRefList[i], true);
      json.FinishArray;
    end;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseExplanationOfBenefitAccident(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseExplanationOfBenefitAccident(jsn)); {2}
end;

function TFHIRJsonParser.ParseExplanationOfBenefitAccident(jsn : TJsonObject) : TFhirExplanationOfBenefitAccident;
begin
  result := TFhirExplanationOfBenefitAccident.create;
  try
    ParseExplanationOfBenefitAccidentProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseExplanationOfBenefitAccidentProperties(jsn : TJsonObject; result : TFhirExplanationOfBenefitAccident);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := parseDate(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('locationAddress') {a4} then
      result.location := ParseAddress(jsn.vObj['locationAddress']);
    if jsn.has('locationReference') {a3} then
      result.location := ParseReference(jsn.vObj['locationReference']);
end;

procedure TFHIRJsonComposer.ComposeExplanationOfBenefitAccident(json : TJSONWriter; name : string; elem : TFhirExplanationOfBenefitAccident; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) and (elem.location is TFhirAddress) then 
    ComposeAddress(json, 'locationAddress', TFhirAddress(elem.location)) 
  else if (SummaryOption in [soFull, soData]) and (elem.location is TFhirReference) then
    ComposeReference(json, 'locationReference', TFhirReference(elem.location));
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseExplanationOfBenefitItem(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseExplanationOfBenefitItem(jsn)); {2}
end;

function TFHIRJsonParser.ParseExplanationOfBenefitItem(jsn : TJsonObject) : TFhirExplanationOfBenefitItem;
begin
  result := TFhirExplanationOfBenefitItem.create;
  try
    ParseExplanationOfBenefitItemProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseExplanationOfBenefitItemProperties(jsn : TJsonObject; result : TFhirExplanationOfBenefitItem);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('sequence') or jsn.has('_sequence') then
        result.sequenceElement := parsePositiveInt(jsn.node['sequence'], jsn.vObj['_sequence']);{q}
      if jsn.has('careTeamSequence') or jsn.has('_careTeamSequence') then
      iteratePrimitiveArray(jsn.vArr['careTeamSequence'], jsn.vArr['_careTeamSequence'], result.careTeamSequenceList, parsePositiveInt);
      if jsn.has('diagnosisSequence') or jsn.has('_diagnosisSequence') then
      iteratePrimitiveArray(jsn.vArr['diagnosisSequence'], jsn.vArr['_diagnosisSequence'], result.diagnosisSequenceList, parsePositiveInt);
      if jsn.has('procedureSequence') or jsn.has('_procedureSequence') then
      iteratePrimitiveArray(jsn.vArr['procedureSequence'], jsn.vArr['_procedureSequence'], result.procedureSequenceList, parsePositiveInt);
      if jsn.has('informationSequence') or jsn.has('_informationSequence') then
      iteratePrimitiveArray(jsn.vArr['informationSequence'], jsn.vArr['_informationSequence'], result.informationSequenceList, parsePositiveInt);
    if jsn.has('revenue') then
        result.revenue := ParseCodeableConcept(jsn.vObj['revenue']);{q3}
    if jsn.has('category') then
        result.category := ParseCodeableConcept(jsn.vObj['category']);{q3}
    if jsn.has('productOrService') then
        result.productOrService := ParseCodeableConcept(jsn.vObj['productOrService']);{q3}
    if jsn.has('modifier') then
      iterateArray(jsn.vArr['modifier'], result.modifierList, parseCodeableConcept);
    if jsn.has('programCode') then
      iterateArray(jsn.vArr['programCode'], result.programCodeList, parseCodeableConcept);
    if jsn.has('servicedPeriod') {a4} then
      result.serviced := ParsePeriod(jsn.vObj['servicedPeriod']);
    if jsn.has('servicedDate') or jsn.has('_servicedDate') then
      result.serviced := parseDate(jsn.node['servicedDate'], jsn.vObj['_servicedDate']);
    if jsn.has('locationCodeableConcept') {a4} then
      result.location := ParseCodeableConcept(jsn.vObj['locationCodeableConcept']);
    if jsn.has('locationAddress') {a4} then
      result.location := ParseAddress(jsn.vObj['locationAddress']);
    if jsn.has('locationReference') {a3} then
      result.location := ParseReference(jsn.vObj['locationReference']);
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q3}
    if jsn.has('unitPrice') then
        result.unitPrice := ParseMoney(jsn.vObj['unitPrice']);{q3}
    if jsn.has('factor') or jsn.has('_factor') then
        result.factorElement := parseDecimal(jsn.node['factor'], jsn.vObj['_factor']);{q}
    if jsn.has('net') then
        result.net := ParseMoney(jsn.vObj['net']);{q3}
    if jsn.has('udi') then
      iterateArray(jsn.vArr['udi'], result.udiList, parseReference{TFhirDevice});
    if jsn.has('bodySite') then
        result.bodySite := ParseCodeableConcept(jsn.vObj['bodySite']);{q3}
    if jsn.has('subSite') then
      iterateArray(jsn.vArr['subSite'], result.subSiteList, parseCodeableConcept);
    if jsn.has('encounter') then
      iterateArray(jsn.vArr['encounter'], result.encounterList, parseReference{TFhirEncounter});
      if jsn.has('noteNumber') or jsn.has('_noteNumber') then
      iteratePrimitiveArray(jsn.vArr['noteNumber'], jsn.vArr['_noteNumber'], result.noteNumberList, parsePositiveInt);
    if jsn.has('adjudication') then
      iterateArray(jsn.vArr['adjudication'], result.adjudicationList, parseExplanationOfBenefitItemAdjudication);
    if jsn.has('detail') then
      iterateArray(jsn.vArr['detail'], result.detailList, parseExplanationOfBenefitItemDetail);
end;

procedure TFHIRJsonComposer.ComposeExplanationOfBenefitItem(json : TJSONWriter; name : string; elem : TFhirExplanationOfBenefitItem; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposePositiveIntValue(json, 'sequence', elem.sequenceElement, false);
  ComposePositiveIntProps(json, 'sequence', elem.sequenceElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.careTeamSequenceList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.careTeamSequenceList.Count - 1 do
    begin
      ext := ext or ((elem.careTeamSequenceList[i].id <> '') or (elem.careTeamSequenceList[i].hasExtensionList) {no-comments or (elem.careTeamSequenceList[i].hasComments)});
      val := val or (elem.careTeamSequenceList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('careTeamSequence');
      for i := 0 to elem.careTeamSequenceList.Count - 1 do
        ComposePositiveIntValue(json, '',elem.careTeamSequenceList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_careTeamSequence');
      for i := 0 to elem.careTeamSequenceList.Count - 1 do
        ComposePositiveIntProps(json, '',elem.careTeamSequenceList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.diagnosisSequenceList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.diagnosisSequenceList.Count - 1 do
    begin
      ext := ext or ((elem.diagnosisSequenceList[i].id <> '') or (elem.diagnosisSequenceList[i].hasExtensionList) {no-comments or (elem.diagnosisSequenceList[i].hasComments)});
      val := val or (elem.diagnosisSequenceList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('diagnosisSequence');
      for i := 0 to elem.diagnosisSequenceList.Count - 1 do
        ComposePositiveIntValue(json, '',elem.diagnosisSequenceList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_diagnosisSequence');
      for i := 0 to elem.diagnosisSequenceList.Count - 1 do
        ComposePositiveIntProps(json, '',elem.diagnosisSequenceList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.procedureSequenceList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.procedureSequenceList.Count - 1 do
    begin
      ext := ext or ((elem.procedureSequenceList[i].id <> '') or (elem.procedureSequenceList[i].hasExtensionList) {no-comments or (elem.procedureSequenceList[i].hasComments)});
      val := val or (elem.procedureSequenceList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('procedureSequence');
      for i := 0 to elem.procedureSequenceList.Count - 1 do
        ComposePositiveIntValue(json, '',elem.procedureSequenceList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_procedureSequence');
      for i := 0 to elem.procedureSequenceList.Count - 1 do
        ComposePositiveIntProps(json, '',elem.procedureSequenceList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.informationSequenceList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.informationSequenceList.Count - 1 do
    begin
      ext := ext or ((elem.informationSequenceList[i].id <> '') or (elem.informationSequenceList[i].hasExtensionList) {no-comments or (elem.informationSequenceList[i].hasComments)});
      val := val or (elem.informationSequenceList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('informationSequence');
      for i := 0 to elem.informationSequenceList.Count - 1 do
        ComposePositiveIntValue(json, '',elem.informationSequenceList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_informationSequence');
      for i := 0 to elem.informationSequenceList.Count - 1 do
        ComposePositiveIntProps(json, '',elem.informationSequenceList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'revenue', elem.revenue); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'category', elem.category); {a}
  ComposeCodeableConcept(json, 'productOrService', elem.productOrService); {a}
  if (SummaryOption in [soFull, soData]) and (elem.modifierList.Count > 0) then
  begin
    json.valueArray('modifier');
    for i := 0 to elem.modifierList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.modifierList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.programCodeList.Count > 0) then
  begin
    json.valueArray('programCode');
    for i := 0 to elem.programCodeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.programCodeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.serviced is TFhirPeriod) then 
    ComposePeriod(json, 'servicedPeriod', TFhirPeriod(elem.serviced)) 
  else if (SummaryOption in [soFull, soData]) and (elem.serviced is TFhirDate) then 
  begin
    ComposeDateValue(json, 'servicedDate', TFhirDate(elem.serviced), false);
    ComposeDateProps(json, 'servicedDate', TFhirDate(elem.serviced), false);
  end;
  if (SummaryOption in [soFull, soData]) and (elem.location is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'locationCodeableConcept', TFhirCodeableConcept(elem.location)) 
  else if (SummaryOption in [soFull, soData]) and (elem.location is TFhirAddress) then 
    ComposeAddress(json, 'locationAddress', TFhirAddress(elem.location)) 
  else if (SummaryOption in [soFull, soData]) and (elem.location is TFhirReference) then
    ComposeReference(json, 'locationReference', TFhirReference(elem.location));
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'quantity', elem.quantity); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(json, 'unitPrice', elem.unitPrice); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalValue(json, 'factor', elem.factorElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalProps(json, 'factor', elem.factorElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(json, 'net', elem.net); {a}
  if (SummaryOption in [soFull, soData]) and (elem.udiList.Count > 0) then
  begin
    json.valueArray('udi');
    for i := 0 to elem.udiList.Count - 1 do
      ComposeReference{TFhirDevice}(json, '', elem.udiList[i]); {z - Reference(Device)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'bodySite', elem.bodySite); {a}
  if (SummaryOption in [soFull, soData]) and (elem.subSiteList.Count > 0) then
  begin
    json.valueArray('subSite');
    for i := 0 to elem.subSiteList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.subSiteList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.encounterList.Count > 0) then
  begin
    json.valueArray('encounter');
    for i := 0 to elem.encounterList.Count - 1 do
      ComposeReference{TFhirEncounter}(json, '', elem.encounterList[i]); {z - Reference(Encounter)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.noteNumberList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.noteNumberList.Count - 1 do
    begin
      ext := ext or ((elem.noteNumberList[i].id <> '') or (elem.noteNumberList[i].hasExtensionList) {no-comments or (elem.noteNumberList[i].hasComments)});
      val := val or (elem.noteNumberList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('noteNumber');
      for i := 0 to elem.noteNumberList.Count - 1 do
        ComposePositiveIntValue(json, '',elem.noteNumberList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_noteNumber');
      for i := 0 to elem.noteNumberList.Count - 1 do
        ComposePositiveIntProps(json, '',elem.noteNumberList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.adjudicationList.Count > 0) then
  begin
    json.valueArray('adjudication');
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeExplanationOfBenefitItemAdjudication(json, '', elem.adjudicationList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.detailList.Count > 0) then
  begin
    json.valueArray('detail');
    for i := 0 to elem.detailList.Count - 1 do
      ComposeExplanationOfBenefitItemDetail(json, '', elem.detailList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseExplanationOfBenefitItemAdjudication(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseExplanationOfBenefitItemAdjudication(jsn)); {2}
end;

function TFHIRJsonParser.ParseExplanationOfBenefitItemAdjudication(jsn : TJsonObject) : TFhirExplanationOfBenefitItemAdjudication;
begin
  result := TFhirExplanationOfBenefitItemAdjudication.create;
  try
    ParseExplanationOfBenefitItemAdjudicationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseExplanationOfBenefitItemAdjudicationProperties(jsn : TJsonObject; result : TFhirExplanationOfBenefitItemAdjudication);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('category') then
        result.category := ParseCodeableConcept(jsn.vObj['category']);{q3}
    if jsn.has('reason') then
        result.reason := ParseCodeableConcept(jsn.vObj['reason']);{q3}
    if jsn.has('amount') then
        result.amount := ParseMoney(jsn.vObj['amount']);{q3}
    if jsn.has('value') or jsn.has('_value') then
        result.valueElement := parseDecimal(jsn.node['value'], jsn.vObj['_value']);{q}
end;

procedure TFHIRJsonComposer.ComposeExplanationOfBenefitItemAdjudication(json : TJSONWriter; name : string; elem : TFhirExplanationOfBenefitItemAdjudication; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'category', elem.category); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'reason', elem.reason); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(json, 'amount', elem.amount); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalValue(json, 'value', elem.valueElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalProps(json, 'value', elem.valueElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseExplanationOfBenefitItemDetail(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseExplanationOfBenefitItemDetail(jsn)); {2}
end;

function TFHIRJsonParser.ParseExplanationOfBenefitItemDetail(jsn : TJsonObject) : TFhirExplanationOfBenefitItemDetail;
begin
  result := TFhirExplanationOfBenefitItemDetail.create;
  try
    ParseExplanationOfBenefitItemDetailProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseExplanationOfBenefitItemDetailProperties(jsn : TJsonObject; result : TFhirExplanationOfBenefitItemDetail);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('sequence') or jsn.has('_sequence') then
        result.sequenceElement := parsePositiveInt(jsn.node['sequence'], jsn.vObj['_sequence']);{q}
    if jsn.has('revenue') then
        result.revenue := ParseCodeableConcept(jsn.vObj['revenue']);{q3}
    if jsn.has('category') then
        result.category := ParseCodeableConcept(jsn.vObj['category']);{q3}
    if jsn.has('productOrService') then
        result.productOrService := ParseCodeableConcept(jsn.vObj['productOrService']);{q3}
    if jsn.has('modifier') then
      iterateArray(jsn.vArr['modifier'], result.modifierList, parseCodeableConcept);
    if jsn.has('programCode') then
      iterateArray(jsn.vArr['programCode'], result.programCodeList, parseCodeableConcept);
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q3}
    if jsn.has('unitPrice') then
        result.unitPrice := ParseMoney(jsn.vObj['unitPrice']);{q3}
    if jsn.has('factor') or jsn.has('_factor') then
        result.factorElement := parseDecimal(jsn.node['factor'], jsn.vObj['_factor']);{q}
    if jsn.has('net') then
        result.net := ParseMoney(jsn.vObj['net']);{q3}
    if jsn.has('udi') then
      iterateArray(jsn.vArr['udi'], result.udiList, parseReference{TFhirDevice});
      if jsn.has('noteNumber') or jsn.has('_noteNumber') then
      iteratePrimitiveArray(jsn.vArr['noteNumber'], jsn.vArr['_noteNumber'], result.noteNumberList, parsePositiveInt);
    if jsn.has('adjudication') then
      iterateArray(jsn.vArr['adjudication'], result.adjudicationList, parseExplanationOfBenefitItemAdjudication);
    if jsn.has('subDetail') then
      iterateArray(jsn.vArr['subDetail'], result.subDetailList, parseExplanationOfBenefitItemDetailSubDetail);
end;

procedure TFHIRJsonComposer.ComposeExplanationOfBenefitItemDetail(json : TJSONWriter; name : string; elem : TFhirExplanationOfBenefitItemDetail; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposePositiveIntValue(json, 'sequence', elem.sequenceElement, false);
  ComposePositiveIntProps(json, 'sequence', elem.sequenceElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'revenue', elem.revenue); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'category', elem.category); {a}
  ComposeCodeableConcept(json, 'productOrService', elem.productOrService); {a}
  if (SummaryOption in [soFull, soData]) and (elem.modifierList.Count > 0) then
  begin
    json.valueArray('modifier');
    for i := 0 to elem.modifierList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.modifierList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.programCodeList.Count > 0) then
  begin
    json.valueArray('programCode');
    for i := 0 to elem.programCodeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.programCodeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'quantity', elem.quantity); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(json, 'unitPrice', elem.unitPrice); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalValue(json, 'factor', elem.factorElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalProps(json, 'factor', elem.factorElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(json, 'net', elem.net); {a}
  if (SummaryOption in [soFull, soData]) and (elem.udiList.Count > 0) then
  begin
    json.valueArray('udi');
    for i := 0 to elem.udiList.Count - 1 do
      ComposeReference{TFhirDevice}(json, '', elem.udiList[i]); {z - Reference(Device)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.noteNumberList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.noteNumberList.Count - 1 do
    begin
      ext := ext or ((elem.noteNumberList[i].id <> '') or (elem.noteNumberList[i].hasExtensionList) {no-comments or (elem.noteNumberList[i].hasComments)});
      val := val or (elem.noteNumberList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('noteNumber');
      for i := 0 to elem.noteNumberList.Count - 1 do
        ComposePositiveIntValue(json, '',elem.noteNumberList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_noteNumber');
      for i := 0 to elem.noteNumberList.Count - 1 do
        ComposePositiveIntProps(json, '',elem.noteNumberList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.adjudicationList.Count > 0) then
  begin
    json.valueArray('adjudication');
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeExplanationOfBenefitItemAdjudication(json, '', elem.adjudicationList[i]); {z - @ExplanationOfBenefit.item.adjudication}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.subDetailList.Count > 0) then
  begin
    json.valueArray('subDetail');
    for i := 0 to elem.subDetailList.Count - 1 do
      ComposeExplanationOfBenefitItemDetailSubDetail(json, '', elem.subDetailList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseExplanationOfBenefitItemDetailSubDetail(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseExplanationOfBenefitItemDetailSubDetail(jsn)); {2}
end;

function TFHIRJsonParser.ParseExplanationOfBenefitItemDetailSubDetail(jsn : TJsonObject) : TFhirExplanationOfBenefitItemDetailSubDetail;
begin
  result := TFhirExplanationOfBenefitItemDetailSubDetail.create;
  try
    ParseExplanationOfBenefitItemDetailSubDetailProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseExplanationOfBenefitItemDetailSubDetailProperties(jsn : TJsonObject; result : TFhirExplanationOfBenefitItemDetailSubDetail);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('sequence') or jsn.has('_sequence') then
        result.sequenceElement := parsePositiveInt(jsn.node['sequence'], jsn.vObj['_sequence']);{q}
    if jsn.has('revenue') then
        result.revenue := ParseCodeableConcept(jsn.vObj['revenue']);{q3}
    if jsn.has('category') then
        result.category := ParseCodeableConcept(jsn.vObj['category']);{q3}
    if jsn.has('productOrService') then
        result.productOrService := ParseCodeableConcept(jsn.vObj['productOrService']);{q3}
    if jsn.has('modifier') then
      iterateArray(jsn.vArr['modifier'], result.modifierList, parseCodeableConcept);
    if jsn.has('programCode') then
      iterateArray(jsn.vArr['programCode'], result.programCodeList, parseCodeableConcept);
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q3}
    if jsn.has('unitPrice') then
        result.unitPrice := ParseMoney(jsn.vObj['unitPrice']);{q3}
    if jsn.has('factor') or jsn.has('_factor') then
        result.factorElement := parseDecimal(jsn.node['factor'], jsn.vObj['_factor']);{q}
    if jsn.has('net') then
        result.net := ParseMoney(jsn.vObj['net']);{q3}
    if jsn.has('udi') then
      iterateArray(jsn.vArr['udi'], result.udiList, parseReference{TFhirDevice});
      if jsn.has('noteNumber') or jsn.has('_noteNumber') then
      iteratePrimitiveArray(jsn.vArr['noteNumber'], jsn.vArr['_noteNumber'], result.noteNumberList, parsePositiveInt);
    if jsn.has('adjudication') then
      iterateArray(jsn.vArr['adjudication'], result.adjudicationList, parseExplanationOfBenefitItemAdjudication);
end;

procedure TFHIRJsonComposer.ComposeExplanationOfBenefitItemDetailSubDetail(json : TJSONWriter; name : string; elem : TFhirExplanationOfBenefitItemDetailSubDetail; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposePositiveIntValue(json, 'sequence', elem.sequenceElement, false);
  ComposePositiveIntProps(json, 'sequence', elem.sequenceElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'revenue', elem.revenue); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'category', elem.category); {a}
  ComposeCodeableConcept(json, 'productOrService', elem.productOrService); {a}
  if (SummaryOption in [soFull, soData]) and (elem.modifierList.Count > 0) then
  begin
    json.valueArray('modifier');
    for i := 0 to elem.modifierList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.modifierList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.programCodeList.Count > 0) then
  begin
    json.valueArray('programCode');
    for i := 0 to elem.programCodeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.programCodeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'quantity', elem.quantity); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(json, 'unitPrice', elem.unitPrice); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalValue(json, 'factor', elem.factorElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalProps(json, 'factor', elem.factorElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(json, 'net', elem.net); {a}
  if (SummaryOption in [soFull, soData]) and (elem.udiList.Count > 0) then
  begin
    json.valueArray('udi');
    for i := 0 to elem.udiList.Count - 1 do
      ComposeReference{TFhirDevice}(json, '', elem.udiList[i]); {z - Reference(Device)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.noteNumberList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.noteNumberList.Count - 1 do
    begin
      ext := ext or ((elem.noteNumberList[i].id <> '') or (elem.noteNumberList[i].hasExtensionList) {no-comments or (elem.noteNumberList[i].hasComments)});
      val := val or (elem.noteNumberList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('noteNumber');
      for i := 0 to elem.noteNumberList.Count - 1 do
        ComposePositiveIntValue(json, '',elem.noteNumberList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_noteNumber');
      for i := 0 to elem.noteNumberList.Count - 1 do
        ComposePositiveIntProps(json, '',elem.noteNumberList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.adjudicationList.Count > 0) then
  begin
    json.valueArray('adjudication');
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeExplanationOfBenefitItemAdjudication(json, '', elem.adjudicationList[i]); {z - @ExplanationOfBenefit.item.adjudication}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseExplanationOfBenefitAddItem(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseExplanationOfBenefitAddItem(jsn)); {2}
end;

function TFHIRJsonParser.ParseExplanationOfBenefitAddItem(jsn : TJsonObject) : TFhirExplanationOfBenefitAddItem;
begin
  result := TFhirExplanationOfBenefitAddItem.create;
  try
    ParseExplanationOfBenefitAddItemProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseExplanationOfBenefitAddItemProperties(jsn : TJsonObject; result : TFhirExplanationOfBenefitAddItem);
begin
    ParseBackboneElementProperties(jsn, result);
      if jsn.has('itemSequence') or jsn.has('_itemSequence') then
      iteratePrimitiveArray(jsn.vArr['itemSequence'], jsn.vArr['_itemSequence'], result.itemSequenceList, parsePositiveInt);
      if jsn.has('detailSequence') or jsn.has('_detailSequence') then
      iteratePrimitiveArray(jsn.vArr['detailSequence'], jsn.vArr['_detailSequence'], result.detailSequenceList, parsePositiveInt);
      if jsn.has('subDetailSequence') or jsn.has('_subDetailSequence') then
      iteratePrimitiveArray(jsn.vArr['subDetailSequence'], jsn.vArr['_subDetailSequence'], result.subDetailSequenceList, parsePositiveInt);
    if jsn.has('provider') then
      iterateArray(jsn.vArr['provider'], result.providerList, parseReference{TFhirPractitioner});
    if jsn.has('productOrService') then
        result.productOrService := ParseCodeableConcept(jsn.vObj['productOrService']);{q3}
    if jsn.has('modifier') then
      iterateArray(jsn.vArr['modifier'], result.modifierList, parseCodeableConcept);
    if jsn.has('programCode') then
      iterateArray(jsn.vArr['programCode'], result.programCodeList, parseCodeableConcept);
    if jsn.has('servicedPeriod') {a4} then
      result.serviced := ParsePeriod(jsn.vObj['servicedPeriod']);
    if jsn.has('servicedDate') or jsn.has('_servicedDate') then
      result.serviced := parseDate(jsn.node['servicedDate'], jsn.vObj['_servicedDate']);
    if jsn.has('locationCodeableConcept') {a4} then
      result.location := ParseCodeableConcept(jsn.vObj['locationCodeableConcept']);
    if jsn.has('locationAddress') {a4} then
      result.location := ParseAddress(jsn.vObj['locationAddress']);
    if jsn.has('locationReference') {a3} then
      result.location := ParseReference(jsn.vObj['locationReference']);
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q3}
    if jsn.has('unitPrice') then
        result.unitPrice := ParseMoney(jsn.vObj['unitPrice']);{q3}
    if jsn.has('factor') or jsn.has('_factor') then
        result.factorElement := parseDecimal(jsn.node['factor'], jsn.vObj['_factor']);{q}
    if jsn.has('net') then
        result.net := ParseMoney(jsn.vObj['net']);{q3}
    if jsn.has('bodySite') then
        result.bodySite := ParseCodeableConcept(jsn.vObj['bodySite']);{q3}
    if jsn.has('subSite') then
      iterateArray(jsn.vArr['subSite'], result.subSiteList, parseCodeableConcept);
      if jsn.has('noteNumber') or jsn.has('_noteNumber') then
      iteratePrimitiveArray(jsn.vArr['noteNumber'], jsn.vArr['_noteNumber'], result.noteNumberList, parsePositiveInt);
    if jsn.has('adjudication') then
      iterateArray(jsn.vArr['adjudication'], result.adjudicationList, parseExplanationOfBenefitItemAdjudication);
    if jsn.has('detail') then
      iterateArray(jsn.vArr['detail'], result.detailList, parseExplanationOfBenefitAddItemDetail);
end;

procedure TFHIRJsonComposer.ComposeExplanationOfBenefitAddItem(json : TJSONWriter; name : string; elem : TFhirExplanationOfBenefitAddItem; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and (elem.itemSequenceList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.itemSequenceList.Count - 1 do
    begin
      ext := ext or ((elem.itemSequenceList[i].id <> '') or (elem.itemSequenceList[i].hasExtensionList) {no-comments or (elem.itemSequenceList[i].hasComments)});
      val := val or (elem.itemSequenceList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('itemSequence');
      for i := 0 to elem.itemSequenceList.Count - 1 do
        ComposePositiveIntValue(json, '',elem.itemSequenceList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_itemSequence');
      for i := 0 to elem.itemSequenceList.Count - 1 do
        ComposePositiveIntProps(json, '',elem.itemSequenceList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.detailSequenceList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.detailSequenceList.Count - 1 do
    begin
      ext := ext or ((elem.detailSequenceList[i].id <> '') or (elem.detailSequenceList[i].hasExtensionList) {no-comments or (elem.detailSequenceList[i].hasComments)});
      val := val or (elem.detailSequenceList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('detailSequence');
      for i := 0 to elem.detailSequenceList.Count - 1 do
        ComposePositiveIntValue(json, '',elem.detailSequenceList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_detailSequence');
      for i := 0 to elem.detailSequenceList.Count - 1 do
        ComposePositiveIntProps(json, '',elem.detailSequenceList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.subDetailSequenceList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.subDetailSequenceList.Count - 1 do
    begin
      ext := ext or ((elem.subDetailSequenceList[i].id <> '') or (elem.subDetailSequenceList[i].hasExtensionList) {no-comments or (elem.subDetailSequenceList[i].hasComments)});
      val := val or (elem.subDetailSequenceList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('subDetailSequence');
      for i := 0 to elem.subDetailSequenceList.Count - 1 do
        ComposePositiveIntValue(json, '',elem.subDetailSequenceList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_subDetailSequence');
      for i := 0 to elem.subDetailSequenceList.Count - 1 do
        ComposePositiveIntProps(json, '',elem.subDetailSequenceList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.providerList.Count > 0) then
  begin
    json.valueArray('provider');
    for i := 0 to elem.providerList.Count - 1 do
      ComposeReference{TFhirPractitioner}(json, '', elem.providerList[i]); {z - Reference(Practitioner)}
    json.FinishArray;
  end;
  ComposeCodeableConcept(json, 'productOrService', elem.productOrService); {a}
  if (SummaryOption in [soFull, soData]) and (elem.modifierList.Count > 0) then
  begin
    json.valueArray('modifier');
    for i := 0 to elem.modifierList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.modifierList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.programCodeList.Count > 0) then
  begin
    json.valueArray('programCode');
    for i := 0 to elem.programCodeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.programCodeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.serviced is TFhirPeriod) then 
    ComposePeriod(json, 'servicedPeriod', TFhirPeriod(elem.serviced)) 
  else if (SummaryOption in [soFull, soData]) and (elem.serviced is TFhirDate) then 
  begin
    ComposeDateValue(json, 'servicedDate', TFhirDate(elem.serviced), false);
    ComposeDateProps(json, 'servicedDate', TFhirDate(elem.serviced), false);
  end;
  if (SummaryOption in [soFull, soData]) and (elem.location is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'locationCodeableConcept', TFhirCodeableConcept(elem.location)) 
  else if (SummaryOption in [soFull, soData]) and (elem.location is TFhirAddress) then 
    ComposeAddress(json, 'locationAddress', TFhirAddress(elem.location)) 
  else if (SummaryOption in [soFull, soData]) and (elem.location is TFhirReference) then
    ComposeReference(json, 'locationReference', TFhirReference(elem.location));
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'quantity', elem.quantity); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(json, 'unitPrice', elem.unitPrice); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalValue(json, 'factor', elem.factorElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalProps(json, 'factor', elem.factorElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(json, 'net', elem.net); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'bodySite', elem.bodySite); {a}
  if (SummaryOption in [soFull, soData]) and (elem.subSiteList.Count > 0) then
  begin
    json.valueArray('subSite');
    for i := 0 to elem.subSiteList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.subSiteList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.noteNumberList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.noteNumberList.Count - 1 do
    begin
      ext := ext or ((elem.noteNumberList[i].id <> '') or (elem.noteNumberList[i].hasExtensionList) {no-comments or (elem.noteNumberList[i].hasComments)});
      val := val or (elem.noteNumberList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('noteNumber');
      for i := 0 to elem.noteNumberList.Count - 1 do
        ComposePositiveIntValue(json, '',elem.noteNumberList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_noteNumber');
      for i := 0 to elem.noteNumberList.Count - 1 do
        ComposePositiveIntProps(json, '',elem.noteNumberList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.adjudicationList.Count > 0) then
  begin
    json.valueArray('adjudication');
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeExplanationOfBenefitItemAdjudication(json, '', elem.adjudicationList[i]); {z - @ExplanationOfBenefit.item.adjudication}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.detailList.Count > 0) then
  begin
    json.valueArray('detail');
    for i := 0 to elem.detailList.Count - 1 do
      ComposeExplanationOfBenefitAddItemDetail(json, '', elem.detailList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseExplanationOfBenefitAddItemDetail(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseExplanationOfBenefitAddItemDetail(jsn)); {2}
end;

function TFHIRJsonParser.ParseExplanationOfBenefitAddItemDetail(jsn : TJsonObject) : TFhirExplanationOfBenefitAddItemDetail;
begin
  result := TFhirExplanationOfBenefitAddItemDetail.create;
  try
    ParseExplanationOfBenefitAddItemDetailProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseExplanationOfBenefitAddItemDetailProperties(jsn : TJsonObject; result : TFhirExplanationOfBenefitAddItemDetail);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('productOrService') then
        result.productOrService := ParseCodeableConcept(jsn.vObj['productOrService']);{q3}
    if jsn.has('modifier') then
      iterateArray(jsn.vArr['modifier'], result.modifierList, parseCodeableConcept);
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q3}
    if jsn.has('unitPrice') then
        result.unitPrice := ParseMoney(jsn.vObj['unitPrice']);{q3}
    if jsn.has('factor') or jsn.has('_factor') then
        result.factorElement := parseDecimal(jsn.node['factor'], jsn.vObj['_factor']);{q}
    if jsn.has('net') then
        result.net := ParseMoney(jsn.vObj['net']);{q3}
      if jsn.has('noteNumber') or jsn.has('_noteNumber') then
      iteratePrimitiveArray(jsn.vArr['noteNumber'], jsn.vArr['_noteNumber'], result.noteNumberList, parsePositiveInt);
    if jsn.has('adjudication') then
      iterateArray(jsn.vArr['adjudication'], result.adjudicationList, parseExplanationOfBenefitItemAdjudication);
    if jsn.has('subDetail') then
      iterateArray(jsn.vArr['subDetail'], result.subDetailList, parseExplanationOfBenefitAddItemDetailSubDetail);
end;

procedure TFHIRJsonComposer.ComposeExplanationOfBenefitAddItemDetail(json : TJSONWriter; name : string; elem : TFhirExplanationOfBenefitAddItemDetail; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'productOrService', elem.productOrService); {a}
  if (SummaryOption in [soFull, soData]) and (elem.modifierList.Count > 0) then
  begin
    json.valueArray('modifier');
    for i := 0 to elem.modifierList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.modifierList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'quantity', elem.quantity); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(json, 'unitPrice', elem.unitPrice); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalValue(json, 'factor', elem.factorElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalProps(json, 'factor', elem.factorElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(json, 'net', elem.net); {a}
  if (SummaryOption in [soFull, soData]) and (elem.noteNumberList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.noteNumberList.Count - 1 do
    begin
      ext := ext or ((elem.noteNumberList[i].id <> '') or (elem.noteNumberList[i].hasExtensionList) {no-comments or (elem.noteNumberList[i].hasComments)});
      val := val or (elem.noteNumberList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('noteNumber');
      for i := 0 to elem.noteNumberList.Count - 1 do
        ComposePositiveIntValue(json, '',elem.noteNumberList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_noteNumber');
      for i := 0 to elem.noteNumberList.Count - 1 do
        ComposePositiveIntProps(json, '',elem.noteNumberList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.adjudicationList.Count > 0) then
  begin
    json.valueArray('adjudication');
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeExplanationOfBenefitItemAdjudication(json, '', elem.adjudicationList[i]); {z - @ExplanationOfBenefit.item.adjudication}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.subDetailList.Count > 0) then
  begin
    json.valueArray('subDetail');
    for i := 0 to elem.subDetailList.Count - 1 do
      ComposeExplanationOfBenefitAddItemDetailSubDetail(json, '', elem.subDetailList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseExplanationOfBenefitAddItemDetailSubDetail(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseExplanationOfBenefitAddItemDetailSubDetail(jsn)); {2}
end;

function TFHIRJsonParser.ParseExplanationOfBenefitAddItemDetailSubDetail(jsn : TJsonObject) : TFhirExplanationOfBenefitAddItemDetailSubDetail;
begin
  result := TFhirExplanationOfBenefitAddItemDetailSubDetail.create;
  try
    ParseExplanationOfBenefitAddItemDetailSubDetailProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseExplanationOfBenefitAddItemDetailSubDetailProperties(jsn : TJsonObject; result : TFhirExplanationOfBenefitAddItemDetailSubDetail);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('productOrService') then
        result.productOrService := ParseCodeableConcept(jsn.vObj['productOrService']);{q3}
    if jsn.has('modifier') then
      iterateArray(jsn.vArr['modifier'], result.modifierList, parseCodeableConcept);
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q3}
    if jsn.has('unitPrice') then
        result.unitPrice := ParseMoney(jsn.vObj['unitPrice']);{q3}
    if jsn.has('factor') or jsn.has('_factor') then
        result.factorElement := parseDecimal(jsn.node['factor'], jsn.vObj['_factor']);{q}
    if jsn.has('net') then
        result.net := ParseMoney(jsn.vObj['net']);{q3}
      if jsn.has('noteNumber') or jsn.has('_noteNumber') then
      iteratePrimitiveArray(jsn.vArr['noteNumber'], jsn.vArr['_noteNumber'], result.noteNumberList, parsePositiveInt);
    if jsn.has('adjudication') then
      iterateArray(jsn.vArr['adjudication'], result.adjudicationList, parseExplanationOfBenefitItemAdjudication);
end;

procedure TFHIRJsonComposer.ComposeExplanationOfBenefitAddItemDetailSubDetail(json : TJSONWriter; name : string; elem : TFhirExplanationOfBenefitAddItemDetailSubDetail; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'productOrService', elem.productOrService); {a}
  if (SummaryOption in [soFull, soData]) and (elem.modifierList.Count > 0) then
  begin
    json.valueArray('modifier');
    for i := 0 to elem.modifierList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.modifierList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'quantity', elem.quantity); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(json, 'unitPrice', elem.unitPrice); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalValue(json, 'factor', elem.factorElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalProps(json, 'factor', elem.factorElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(json, 'net', elem.net); {a}
  if (SummaryOption in [soFull, soData]) and (elem.noteNumberList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.noteNumberList.Count - 1 do
    begin
      ext := ext or ((elem.noteNumberList[i].id <> '') or (elem.noteNumberList[i].hasExtensionList) {no-comments or (elem.noteNumberList[i].hasComments)});
      val := val or (elem.noteNumberList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('noteNumber');
      for i := 0 to elem.noteNumberList.Count - 1 do
        ComposePositiveIntValue(json, '',elem.noteNumberList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_noteNumber');
      for i := 0 to elem.noteNumberList.Count - 1 do
        ComposePositiveIntProps(json, '',elem.noteNumberList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.adjudicationList.Count > 0) then
  begin
    json.valueArray('adjudication');
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeExplanationOfBenefitItemAdjudication(json, '', elem.adjudicationList[i]); {z - @ExplanationOfBenefit.item.adjudication}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseExplanationOfBenefitTotal(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseExplanationOfBenefitTotal(jsn)); {2}
end;

function TFHIRJsonParser.ParseExplanationOfBenefitTotal(jsn : TJsonObject) : TFhirExplanationOfBenefitTotal;
begin
  result := TFhirExplanationOfBenefitTotal.create;
  try
    ParseExplanationOfBenefitTotalProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseExplanationOfBenefitTotalProperties(jsn : TJsonObject; result : TFhirExplanationOfBenefitTotal);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('category') then
        result.category := ParseCodeableConcept(jsn.vObj['category']);{q3}
    if jsn.has('amount') then
        result.amount := ParseMoney(jsn.vObj['amount']);{q3}
end;

procedure TFHIRJsonComposer.ComposeExplanationOfBenefitTotal(json : TJSONWriter; name : string; elem : TFhirExplanationOfBenefitTotal; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'category', elem.category); {a}
  ComposeMoney(json, 'amount', elem.amount); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseExplanationOfBenefitPayment(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseExplanationOfBenefitPayment(jsn)); {2}
end;

function TFHIRJsonParser.ParseExplanationOfBenefitPayment(jsn : TJsonObject) : TFhirExplanationOfBenefitPayment;
begin
  result := TFhirExplanationOfBenefitPayment.create;
  try
    ParseExplanationOfBenefitPaymentProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseExplanationOfBenefitPaymentProperties(jsn : TJsonObject; result : TFhirExplanationOfBenefitPayment);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('adjustment') then
        result.adjustment := ParseMoney(jsn.vObj['adjustment']);{q3}
    if jsn.has('adjustmentReason') then
        result.adjustmentReason := ParseCodeableConcept(jsn.vObj['adjustmentReason']);{q3}
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := parseDate(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('amount') then
        result.amount := ParseMoney(jsn.vObj['amount']);{q3}
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q3}
end;

procedure TFHIRJsonComposer.ComposeExplanationOfBenefitPayment(json : TJSONWriter; name : string; elem : TFhirExplanationOfBenefitPayment; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(json, 'adjustment', elem.adjustment); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'adjustmentReason', elem.adjustmentReason); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeDateValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(json, 'amount', elem.amount); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseExplanationOfBenefitProcessNote(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseExplanationOfBenefitProcessNote(jsn)); {2}
end;

function TFHIRJsonParser.ParseExplanationOfBenefitProcessNote(jsn : TJsonObject) : TFhirExplanationOfBenefitProcessNote;
begin
  result := TFhirExplanationOfBenefitProcessNote.create;
  try
    ParseExplanationOfBenefitProcessNoteProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseExplanationOfBenefitProcessNoteProperties(jsn : TJsonObject; result : TFhirExplanationOfBenefitProcessNote);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('number') or jsn.has('_number') then
        result.numberElement := parsePositiveInt(jsn.node['number'], jsn.vObj['_number']);{q}
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn.node['type'], jsn.vObj['_type'], CODES_TFhirNoteTypeEnum, SYSTEMS_TFhirNoteTypeEnum);
    if jsn.has('text') or jsn.has('_text') then
        result.textElement := parseString(jsn.node['text'], jsn.vObj['_text']);{q}
    if jsn.has('language') then
        result.language := ParseCodeableConcept(jsn.vObj['language']);{q3}
end;

procedure TFHIRJsonComposer.ComposeExplanationOfBenefitProcessNote(json : TJSONWriter; name : string; elem : TFhirExplanationOfBenefitProcessNote; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveIntValue(json, 'number', elem.numberElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveIntProps(json, 'number', elem.numberElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirNoteTypeEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirNoteTypeEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'language', elem.language); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseExplanationOfBenefitBenefitBalance(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseExplanationOfBenefitBenefitBalance(jsn)); {2}
end;

function TFHIRJsonParser.ParseExplanationOfBenefitBenefitBalance(jsn : TJsonObject) : TFhirExplanationOfBenefitBenefitBalance;
begin
  result := TFhirExplanationOfBenefitBenefitBalance.create;
  try
    ParseExplanationOfBenefitBenefitBalanceProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseExplanationOfBenefitBenefitBalanceProperties(jsn : TJsonObject; result : TFhirExplanationOfBenefitBenefitBalance);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('category') then
        result.category := ParseCodeableConcept(jsn.vObj['category']);{q3}
    if jsn.has('excluded') or jsn.has('_excluded') then
        result.excludedElement := parseBoolean(jsn.node['excluded'], jsn.vObj['_excluded']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('network') then
        result.network := ParseCodeableConcept(jsn.vObj['network']);{q3}
    if jsn.has('unit') then
        result.unit_ := ParseCodeableConcept(jsn.vObj['unit']);{q3}
    if jsn.has('term') then
        result.term := ParseCodeableConcept(jsn.vObj['term']);{q3}
    if jsn.has('financial') then
      iterateArray(jsn.vArr['financial'], result.financialList, parseExplanationOfBenefitBenefitBalanceFinancial);
end;

procedure TFHIRJsonComposer.ComposeExplanationOfBenefitBenefitBalance(json : TJSONWriter; name : string; elem : TFhirExplanationOfBenefitBenefitBalance; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'category', elem.category); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'excluded', elem.excludedElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'excluded', elem.excludedElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'network', elem.network); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'unit', elem.unit_); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'term', elem.term); {a}
  if (SummaryOption in [soFull, soData]) and (elem.financialList.Count > 0) then
  begin
    json.valueArray('financial');
    for i := 0 to elem.financialList.Count - 1 do
      ComposeExplanationOfBenefitBenefitBalanceFinancial(json, '', elem.financialList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseExplanationOfBenefitBenefitBalanceFinancial(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseExplanationOfBenefitBenefitBalanceFinancial(jsn)); {2}
end;

function TFHIRJsonParser.ParseExplanationOfBenefitBenefitBalanceFinancial(jsn : TJsonObject) : TFhirExplanationOfBenefitBenefitBalanceFinancial;
begin
  result := TFhirExplanationOfBenefitBenefitBalanceFinancial.create;
  try
    ParseExplanationOfBenefitBenefitBalanceFinancialProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseExplanationOfBenefitBenefitBalanceFinancialProperties(jsn : TJsonObject; result : TFhirExplanationOfBenefitBenefitBalanceFinancial);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('allowedUnsignedInt') or jsn.has('_allowedUnsignedInt') then
      result.allowed := parseUnsignedInt(jsn.node['allowedUnsignedInt'], jsn.vObj['_allowedUnsignedInt']);
    if jsn.has('allowedMoney') {a4} then
      result.allowed := ParseMoney(jsn.vObj['allowedMoney']);
    if jsn.has('allowedString') or jsn.has('_allowedString') then
      result.allowed := parseString(jsn.node['allowedString'], jsn.vObj['_allowedString']);
    if jsn.has('usedUnsignedInt') or jsn.has('_usedUnsignedInt') then
      result.used := parseUnsignedInt(jsn.node['usedUnsignedInt'], jsn.vObj['_usedUnsignedInt']);
    if jsn.has('usedMoney') {a4} then
      result.used := ParseMoney(jsn.vObj['usedMoney']);
end;

procedure TFHIRJsonComposer.ComposeExplanationOfBenefitBenefitBalanceFinancial(json : TJSONWriter; name : string; elem : TFhirExplanationOfBenefitBenefitBalanceFinancial; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) and (elem.allowed is TFhirUnsignedInt) then 
  begin
    ComposeUnsignedIntValue(json, 'allowedUnsignedInt', TFhirUnsignedInt(elem.allowed), false);
    ComposeUnsignedIntProps(json, 'allowedUnsignedInt', TFhirUnsignedInt(elem.allowed), false);
  end
  else if (SummaryOption in [soFull, soData]) and (elem.allowed is TFhirMoney) then 
    ComposeMoney(json, 'allowedMoney', TFhirMoney(elem.allowed)) 
  else if (SummaryOption in [soFull, soData]) and (elem.allowed is TFhirString) then 
  begin
    ComposeStringValue(json, 'allowedString', TFhirString(elem.allowed), false);
    ComposeStringProps(json, 'allowedString', TFhirString(elem.allowed), false);
  end;
  if (SummaryOption in [soFull, soData]) and (elem.used is TFhirUnsignedInt) then 
  begin
    ComposeUnsignedIntValue(json, 'usedUnsignedInt', TFhirUnsignedInt(elem.used), false);
    ComposeUnsignedIntProps(json, 'usedUnsignedInt', TFhirUnsignedInt(elem.used), false);
  end
  else if (SummaryOption in [soFull, soData]) and (elem.used is TFhirMoney) then 
    ComposeMoney(json, 'usedMoney', TFhirMoney(elem.used)) ;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseExplanationOfBenefit(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseExplanationOfBenefit(jsn)); {2}
end;

function TFHIRJsonParser.ParseExplanationOfBenefit(jsn : TJsonObject) : TFhirExplanationOfBenefit;
begin
  result := TFhirExplanationOfBenefit.create;
  try
    ParseExplanationOfBenefitProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseExplanationOfBenefitProperties(jsn : TJsonObject; result : TFhirExplanationOfBenefit);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirExplanationofbenefitStatusEnum, SYSTEMS_TFhirExplanationofbenefitStatusEnum);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('subType') then
        result.subType := ParseCodeableConcept(jsn.vObj['subType']);{q3}
    if jsn.has('use') or jsn.has('_use')  then
      result.useElement := parseEnum(jsn.path+'/use', jsn.node['use'], jsn.vObj['_use'], CODES_TFhirClaimUseEnum, SYSTEMS_TFhirClaimUseEnum);
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q3}
    if jsn.has('billablePeriod') then
        result.billablePeriod := ParsePeriod(jsn.vObj['billablePeriod']);{q3}
    if jsn.has('created') or jsn.has('_created') then
        result.createdElement := parseDateTime(jsn.node['created'], jsn.vObj['_created']);{q}
    if jsn.has('enterer') then
        result.enterer := ParseReference{TFhirPractitioner}(jsn.vObj['enterer']);{q3}
    if jsn.has('insurer') then
        result.insurer := ParseReference{TFhirOrganization}(jsn.vObj['insurer']);{q3}
    if jsn.has('provider') then
        result.provider := ParseReference{TFhirPractitioner}(jsn.vObj['provider']);{q3}
    if jsn.has('priority') then
        result.priority := ParseCodeableConcept(jsn.vObj['priority']);{q3}
    if jsn.has('fundsReserveRequested') then
        result.fundsReserveRequested := ParseCodeableConcept(jsn.vObj['fundsReserveRequested']);{q3}
    if jsn.has('fundsReserve') then
        result.fundsReserve := ParseCodeableConcept(jsn.vObj['fundsReserve']);{q3}
    if jsn.has('related') then
      iterateArray(jsn.vArr['related'], result.relatedList, parseExplanationOfBenefitRelated);
    if jsn.has('prescription') then
        result.prescription := ParseReference{TFhirMedicationRequest}(jsn.vObj['prescription']);{q3}
    if jsn.has('originalPrescription') then
        result.originalPrescription := ParseReference{TFhirMedicationRequest}(jsn.vObj['originalPrescription']);{q3}
    if jsn.has('payee') then
        result.payee := ParseExplanationOfBenefitPayee(jsn.vObj['payee']);{q3}
    if jsn.has('referral') then
        result.referral := ParseReference{TFhirServiceRequest}(jsn.vObj['referral']);{q3}
    if jsn.has('facility') then
        result.facility := ParseReference{TFhirLocation}(jsn.vObj['facility']);{q3}
    if jsn.has('claim') then
        result.claim := ParseReference{TFhirClaim}(jsn.vObj['claim']);{q3}
    if jsn.has('claimResponse') then
        result.claimResponse := ParseReference{TFhirClaimResponse}(jsn.vObj['claimResponse']);{q3}
    if jsn.has('outcome') or jsn.has('_outcome')  then
      result.outcomeElement := parseEnum(jsn.path+'/outcome', jsn.node['outcome'], jsn.vObj['_outcome'], CODES_TFhirRemittanceOutcomeEnum, SYSTEMS_TFhirRemittanceOutcomeEnum);
    if jsn.has('disposition') or jsn.has('_disposition') then
        result.dispositionElement := parseString(jsn.node['disposition'], jsn.vObj['_disposition']);{q}
      if jsn.has('preAuthRef') or jsn.has('_preAuthRef') then
      iteratePrimitiveArray(jsn.vArr['preAuthRef'], jsn.vArr['_preAuthRef'], result.preAuthRefList, parseString);
    if jsn.has('preAuthRefPeriod') then
      iterateArray(jsn.vArr['preAuthRefPeriod'], result.preAuthRefPeriodList, parsePeriod);
    if jsn.has('careTeam') then
      iterateArray(jsn.vArr['careTeam'], result.careTeamList, parseExplanationOfBenefitCareTeam);
    if jsn.has('supportingInfo') then
      iterateArray(jsn.vArr['supportingInfo'], result.supportingInfoList, parseExplanationOfBenefitSupportingInfo);
    if jsn.has('diagnosis') then
      iterateArray(jsn.vArr['diagnosis'], result.diagnosisList, parseExplanationOfBenefitDiagnosis);
    if jsn.has('procedure') then
      iterateArray(jsn.vArr['procedure'], result.procedure_List, parseExplanationOfBenefitProcedure);
    if jsn.has('precedence') or jsn.has('_precedence') then
        result.precedenceElement := parsePositiveInt(jsn.node['precedence'], jsn.vObj['_precedence']);{q}
    if jsn.has('insurance') then
      iterateArray(jsn.vArr['insurance'], result.insuranceList, parseExplanationOfBenefitInsurance);
    if jsn.has('accident') then
        result.accident := ParseExplanationOfBenefitAccident(jsn.vObj['accident']);{q3}
    if jsn.has('item') then
      iterateArray(jsn.vArr['item'], result.itemList, parseExplanationOfBenefitItem);
    if jsn.has('addItem') then
      iterateArray(jsn.vArr['addItem'], result.addItemList, parseExplanationOfBenefitAddItem);
    if jsn.has('adjudication') then
      iterateArray(jsn.vArr['adjudication'], result.adjudicationList, parseExplanationOfBenefitItemAdjudication);
    if jsn.has('total') then
      iterateArray(jsn.vArr['total'], result.totalList, parseExplanationOfBenefitTotal);
    if jsn.has('payment') then
        result.payment := ParseExplanationOfBenefitPayment(jsn.vObj['payment']);{q3}
    if jsn.has('formCode') then
        result.formCode := ParseCodeableConcept(jsn.vObj['formCode']);{q3}
    if jsn.has('form') then
        result.form := ParseAttachment(jsn.vObj['form']);{q3}
    if jsn.has('processNote') then
      iterateArray(jsn.vArr['processNote'], result.processNoteList, parseExplanationOfBenefitProcessNote);
    if jsn.has('benefitPeriod') then
        result.benefitPeriod := ParsePeriod(jsn.vObj['benefitPeriod']);{q3}
    if jsn.has('benefitBalance') then
      iterateArray(jsn.vArr['benefitBalance'], result.benefitBalanceList, parseExplanationOfBenefitBenefitBalance);
end;

procedure TFHIRJsonComposer.ComposeExplanationOfBenefit(json : TJSONWriter; name : string; elem : TFhirExplanationOfBenefit; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirExplanationofbenefitStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirExplanationofbenefitStatusEnum, false);
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('subType') then
    ComposeCodeableConcept(json, 'subType', elem.subType); {a}
  ComposeEnumValue(json, 'use', elem.UseElement, CODES_TFhirClaimUseEnum, false);
  ComposeEnumProps(json, 'use', elem.UseElement, CODES_TFhirClaimUseEnum, false);
    ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('billablePeriod') then
    ComposePeriod(json, 'billablePeriod', elem.billablePeriod); {a}
    ComposeDateTimeValue(json, 'created', elem.createdElement, false);
    ComposeDateTimeProps(json, 'created', elem.createdElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('enterer') then
    ComposeReference{TFhirPractitioner}(json, 'enterer', elem.enterer); {a}
    ComposeReference{TFhirOrganization}(json, 'insurer', elem.insurer); {a}
    ComposeReference{TFhirPractitioner}(json, 'provider', elem.provider); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('priority') then
    ComposeCodeableConcept(json, 'priority', elem.priority); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('fundsReserveRequested') then
    ComposeCodeableConcept(json, 'fundsReserveRequested', elem.fundsReserveRequested); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('fundsReserve') then
    ComposeCodeableConcept(json, 'fundsReserve', elem.fundsReserve); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('related') and (elem.relatedList.Count > 0) then
  begin
    json.valueArray('related');
    for i := 0 to elem.relatedList.Count - 1 do
      ComposeExplanationOfBenefitRelated(json, '', elem.relatedList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('prescription') then
    ComposeReference{TFhirMedicationRequest}(json, 'prescription', elem.prescription); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('originalPrescription') then
    ComposeReference{TFhirMedicationRequest}(json, 'originalPrescription', elem.originalPrescription); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('payee') then
    ComposeExplanationOfBenefitPayee(json, 'payee', elem.payee); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('referral') then
    ComposeReference{TFhirServiceRequest}(json, 'referral', elem.referral); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('facility') then
    ComposeReference{TFhirLocation}(json, 'facility', elem.facility); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('claim') then
    ComposeReference{TFhirClaim}(json, 'claim', elem.claim); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('claimResponse') then
    ComposeReference{TFhirClaimResponse}(json, 'claimResponse', elem.claimResponse); {a}
  ComposeEnumValue(json, 'outcome', elem.OutcomeElement, CODES_TFhirRemittanceOutcomeEnum, false);
  ComposeEnumProps(json, 'outcome', elem.OutcomeElement, CODES_TFhirRemittanceOutcomeEnum, false);
  if (SummaryOption in [soFull, soData]) and doCompose('disposition') then
    ComposeStringValue(json, 'disposition', elem.dispositionElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('disposition') then
    ComposeStringProps(json, 'disposition', elem.dispositionElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('preAuthRef') and (elem.preAuthRefList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.preAuthRefList.Count - 1 do
    begin
      ext := ext or ((elem.preAuthRefList[i].id <> '') or (elem.preAuthRefList[i].hasExtensionList) {no-comments or (elem.preAuthRefList[i].hasComments)});
      val := val or (elem.preAuthRefList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('preAuthRef');
      for i := 0 to elem.preAuthRefList.Count - 1 do
        ComposeStringValue(json, '',elem.preAuthRefList[i], true);
      json.FinishArray;
    end;
    if ext then
  begin
      json.valueArray('_preAuthRef');
      for i := 0 to elem.preAuthRefList.Count - 1 do
        ComposeStringProps(json, '',elem.preAuthRefList[i], true);
    json.FinishArray;
  end;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('preAuthRefPeriod') and (elem.preAuthRefPeriodList.Count > 0) then
  begin
    json.valueArray('preAuthRefPeriod');
    for i := 0 to elem.preAuthRefPeriodList.Count - 1 do
      ComposePeriod(json, '', elem.preAuthRefPeriodList[i]); {z - Period}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('careTeam') and (elem.careTeamList.Count > 0) then
  begin
    json.valueArray('careTeam');
    for i := 0 to elem.careTeamList.Count - 1 do
      ComposeExplanationOfBenefitCareTeam(json, '', elem.careTeamList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('supportingInfo') and (elem.supportingInfoList.Count > 0) then
  begin
    json.valueArray('supportingInfo');
    for i := 0 to elem.supportingInfoList.Count - 1 do
      ComposeExplanationOfBenefitSupportingInfo(json, '', elem.supportingInfoList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('diagnosis') and (elem.diagnosisList.Count > 0) then
  begin
    json.valueArray('diagnosis');
    for i := 0 to elem.diagnosisList.Count - 1 do
      ComposeExplanationOfBenefitDiagnosis(json, '', elem.diagnosisList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('procedure_') and (elem.procedure_List.Count > 0) then
  begin
    json.valueArray('procedure');
    for i := 0 to elem.procedure_List.Count - 1 do
      ComposeExplanationOfBenefitProcedure(json, '', elem.procedure_List[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('precedence') then
    ComposePositiveIntValue(json, 'precedence', elem.precedenceElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('precedence') then
    ComposePositiveIntProps(json, 'precedence', elem.precedenceElement, false);
  if (elem.insuranceList.Count > 0) then
  begin
    json.valueArray('insurance');
    for i := 0 to elem.insuranceList.Count - 1 do
      ComposeExplanationOfBenefitInsurance(json, '', elem.insuranceList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('accident') then
    ComposeExplanationOfBenefitAccident(json, 'accident', elem.accident); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('item') and (elem.itemList.Count > 0) then
  begin
    json.valueArray('item');
    for i := 0 to elem.itemList.Count - 1 do
      ComposeExplanationOfBenefitItem(json, '', elem.itemList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('addItem') and (elem.addItemList.Count > 0) then
  begin
    json.valueArray('addItem');
    for i := 0 to elem.addItemList.Count - 1 do
      ComposeExplanationOfBenefitAddItem(json, '', elem.addItemList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('adjudication') and (elem.adjudicationList.Count > 0) then
  begin
    json.valueArray('adjudication');
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeExplanationOfBenefitItemAdjudication(json, '', elem.adjudicationList[i]); {z - @ExplanationOfBenefit.item.adjudication}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('total') and (elem.totalList.Count > 0) then
  begin
    json.valueArray('total');
    for i := 0 to elem.totalList.Count - 1 do
      ComposeExplanationOfBenefitTotal(json, '', elem.totalList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('payment') then
    ComposeExplanationOfBenefitPayment(json, 'payment', elem.payment); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('formCode') then
    ComposeCodeableConcept(json, 'formCode', elem.formCode); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('form') then
    ComposeAttachment(json, 'form', elem.form); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('processNote') and (elem.processNoteList.Count > 0) then
  begin
    json.valueArray('processNote');
    for i := 0 to elem.processNoteList.Count - 1 do
      ComposeExplanationOfBenefitProcessNote(json, '', elem.processNoteList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('benefitPeriod') then
    ComposePeriod(json, 'benefitPeriod', elem.benefitPeriod); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('benefitBalance') and (elem.benefitBalanceList.Count > 0) then
  begin
    json.valueArray('benefitBalance');
    for i := 0 to elem.benefitBalanceList.Count - 1 do
      ComposeExplanationOfBenefitBenefitBalance(json, '', elem.benefitBalanceList[i]); {z - }
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_EXPLANATIONOFBENEFIT}
{$IFDEF FHIR_FAMILYMEMBERHISTORY}
procedure TFHIRJsonParser.ParseFamilyMemberHistoryCondition(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseFamilyMemberHistoryCondition(jsn)); {2}
end;

function TFHIRJsonParser.ParseFamilyMemberHistoryCondition(jsn : TJsonObject) : TFhirFamilyMemberHistoryCondition;
begin
  result := TFhirFamilyMemberHistoryCondition.create;
  try
    ParseFamilyMemberHistoryConditionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseFamilyMemberHistoryConditionProperties(jsn : TJsonObject; result : TFhirFamilyMemberHistoryCondition);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('outcome') then
        result.outcome := ParseCodeableConcept(jsn.vObj['outcome']);{q3}
    if jsn.has('contributedToDeath') or jsn.has('_contributedToDeath') then
        result.contributedToDeathElement := parseBoolean(jsn.node['contributedToDeath'], jsn.vObj['_contributedToDeath']);{q}
    if jsn.has('onsetAge') {a4} then
      result.onset := ParseAge(jsn.vObj['onsetAge']);
    if jsn.has('onsetRange') {a4} then
      result.onset := ParseRange(jsn.vObj['onsetRange']);
    if jsn.has('onsetPeriod') {a4} then
      result.onset := ParsePeriod(jsn.vObj['onsetPeriod']);
    if jsn.has('onsetString') or jsn.has('_onsetString') then
      result.onset := parseString(jsn.node['onsetString'], jsn.vObj['_onsetString']);
    if jsn.has('note') then
      iterateArray(jsn.vArr['note'], result.noteList, parseAnnotation);
end;

procedure TFHIRJsonComposer.ComposeFamilyMemberHistoryCondition(json : TJSONWriter; name : string; elem : TFhirFamilyMemberHistoryCondition; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'outcome', elem.outcome); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'contributedToDeath', elem.contributedToDeathElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'contributedToDeath', elem.contributedToDeathElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.onset is TFhirAge) then 
    ComposeAge(json, 'onsetAge', TFhirAge(elem.onset)) 
  else if (SummaryOption in [soFull, soData]) and (elem.onset is TFhirRange) then 
    ComposeRange(json, 'onsetRange', TFhirRange(elem.onset)) 
  else if (SummaryOption in [soFull, soData]) and (elem.onset is TFhirPeriod) then 
    ComposePeriod(json, 'onsetPeriod', TFhirPeriod(elem.onset)) 
  else if (SummaryOption in [soFull, soData]) and (elem.onset is TFhirString) then 
  begin
    ComposeStringValue(json, 'onsetString', TFhirString(elem.onset), false);
    ComposeStringProps(json, 'onsetString', TFhirString(elem.onset), false);
  end;
  if (SummaryOption in [soFull, soData]) and (elem.noteList.Count > 0) then
  begin
    json.valueArray('note');
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(json, '', elem.noteList[i]); {z - Annotation}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseFamilyMemberHistory(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseFamilyMemberHistory(jsn)); {2}
end;

function TFHIRJsonParser.ParseFamilyMemberHistory(jsn : TJsonObject) : TFhirFamilyMemberHistory;
begin
  result := TFhirFamilyMemberHistory.create;
  try
    ParseFamilyMemberHistoryProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseFamilyMemberHistoryProperties(jsn : TJsonObject; result : TFhirFamilyMemberHistory);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
      if jsn.has('instantiatesCanonical') or jsn.has('_instantiatesCanonical') then
      iteratePrimitiveArray(jsn.vArr['instantiatesCanonical'], jsn.vArr['_instantiatesCanonical'], result.instantiatesCanonicalList, parseCanonical);
      if jsn.has('instantiatesUri') or jsn.has('_instantiatesUri') then
      iteratePrimitiveArray(jsn.vArr['instantiatesUri'], jsn.vArr['_instantiatesUri'], result.instantiatesUriList, parseUri);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirHistoryStatusEnum, SYSTEMS_TFhirHistoryStatusEnum);
    if jsn.has('dataAbsentReason') then
        result.dataAbsentReason := ParseCodeableConcept(jsn.vObj['dataAbsentReason']);{q3}
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q3}
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := parseDateTime(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('relationship') then
        result.relationship := ParseCodeableConcept(jsn.vObj['relationship']);{q3}
    if jsn.has('sex') then
        result.sex := ParseCodeableConcept(jsn.vObj['sex']);{q3}
    if jsn.has('bornPeriod') {a4} then
      result.born := ParsePeriod(jsn.vObj['bornPeriod']);
    if jsn.has('bornDate') or jsn.has('_bornDate') then
      result.born := parseDate(jsn.node['bornDate'], jsn.vObj['_bornDate']);
    if jsn.has('bornString') or jsn.has('_bornString') then
      result.born := parseString(jsn.node['bornString'], jsn.vObj['_bornString']);
    if jsn.has('ageAge') {a4} then
      result.age := ParseAge(jsn.vObj['ageAge']);
    if jsn.has('ageRange') {a4} then
      result.age := ParseRange(jsn.vObj['ageRange']);
    if jsn.has('ageString') or jsn.has('_ageString') then
      result.age := parseString(jsn.node['ageString'], jsn.vObj['_ageString']);
    if jsn.has('estimatedAge') or jsn.has('_estimatedAge') then
        result.estimatedAgeElement := parseBoolean(jsn.node['estimatedAge'], jsn.vObj['_estimatedAge']);{q}
    if jsn.has('deceasedAge') {a4} then
      result.deceased := ParseAge(jsn.vObj['deceasedAge']);
    if jsn.has('deceasedRange') {a4} then
      result.deceased := ParseRange(jsn.vObj['deceasedRange']);
    if jsn.has('deceasedBoolean') or jsn.has('_deceasedBoolean') then
      result.deceased := parseBoolean(jsn.node['deceasedBoolean'], jsn.vObj['_deceasedBoolean']);
    if jsn.has('deceasedDate') or jsn.has('_deceasedDate') then
      result.deceased := parseDate(jsn.node['deceasedDate'], jsn.vObj['_deceasedDate']);
    if jsn.has('deceasedString') or jsn.has('_deceasedString') then
      result.deceased := parseString(jsn.node['deceasedString'], jsn.vObj['_deceasedString']);
    if jsn.has('reasonCode') then
      iterateArray(jsn.vArr['reasonCode'], result.reasonCodeList, parseCodeableConcept);
    if jsn.has('reasonReference') then
      iterateArray(jsn.vArr['reasonReference'], result.reasonReferenceList, parseReference{TFhirCondition});
    if jsn.has('note') then
      iterateArray(jsn.vArr['note'], result.noteList, parseAnnotation);
    if jsn.has('condition') then
      iterateArray(jsn.vArr['condition'], result.conditionList, parseFamilyMemberHistoryCondition);
end;

procedure TFHIRJsonComposer.ComposeFamilyMemberHistory(json : TJSONWriter; name : string; elem : TFhirFamilyMemberHistory; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('instantiatesCanonical') and (elem.instantiatesCanonicalList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.instantiatesCanonicalList.Count - 1 do
    begin
      ext := ext or ((elem.instantiatesCanonicalList[i].id <> '') or (elem.instantiatesCanonicalList[i].hasExtensionList) {no-comments or (elem.instantiatesCanonicalList[i].hasComments)});
      val := val or (elem.instantiatesCanonicalList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('instantiatesCanonical');
      for i := 0 to elem.instantiatesCanonicalList.Count - 1 do
        ComposeCanonicalValue(json, '',elem.instantiatesCanonicalList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_instantiatesCanonical');
      for i := 0 to elem.instantiatesCanonicalList.Count - 1 do
        ComposeCanonicalProps(json, '',elem.instantiatesCanonicalList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('instantiatesUri') and (elem.instantiatesUriList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.instantiatesUriList.Count - 1 do
    begin
      ext := ext or ((elem.instantiatesUriList[i].id <> '') or (elem.instantiatesUriList[i].hasExtensionList) {no-comments or (elem.instantiatesUriList[i].hasComments)});
      val := val or (elem.instantiatesUriList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('instantiatesUri');
      for i := 0 to elem.instantiatesUriList.Count - 1 do
        ComposeUriValue(json, '',elem.instantiatesUriList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_instantiatesUri');
      for i := 0 to elem.instantiatesUriList.Count - 1 do
        ComposeUriProps(json, '',elem.instantiatesUriList[i], true);
      json.FinishArray;
    end;
  end;
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirHistoryStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirHistoryStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dataAbsentReason') then
    ComposeCodeableConcept(json, 'dataAbsentReason', elem.dataAbsentReason); {a}
  ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  ComposeCodeableConcept(json, 'relationship', elem.relationship); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('sex') then
    ComposeCodeableConcept(json, 'sex', elem.sex); {a}
  if (SummaryOption in [soFull, soData]) and (elem.born is TFhirPeriod) then 
    ComposePeriod(json, 'bornPeriod', TFhirPeriod(elem.born)) 
  else if (SummaryOption in [soFull, soData]) and (elem.born is TFhirDate) then 
  begin
    ComposeDateValue(json, 'bornDate', TFhirDate(elem.born), false);
    ComposeDateProps(json, 'bornDate', TFhirDate(elem.born), false);
  end
  else if (SummaryOption in [soFull, soData]) and (elem.born is TFhirString) then 
  begin
    ComposeStringValue(json, 'bornString', TFhirString(elem.born), false);
    ComposeStringProps(json, 'bornString', TFhirString(elem.born), false);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.age is TFhirAge) then 
    ComposeAge(json, 'ageAge', TFhirAge(elem.age)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.age is TFhirRange) then 
    ComposeRange(json, 'ageRange', TFhirRange(elem.age)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.age is TFhirString) then 
  begin
    ComposeStringValue(json, 'ageString', TFhirString(elem.age), false);
    ComposeStringProps(json, 'ageString', TFhirString(elem.age), false);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('estimatedAge') then
    ComposeBooleanValue(json, 'estimatedAge', elem.estimatedAgeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('estimatedAge') then
    ComposeBooleanProps(json, 'estimatedAge', elem.estimatedAgeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.deceased is TFhirAge) then 
    ComposeAge(json, 'deceasedAge', TFhirAge(elem.deceased)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.deceased is TFhirRange) then 
    ComposeRange(json, 'deceasedRange', TFhirRange(elem.deceased)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.deceased is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'deceasedBoolean', TFhirBoolean(elem.deceased), false);
    ComposeBooleanProps(json, 'deceasedBoolean', TFhirBoolean(elem.deceased), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.deceased is TFhirDate) then 
  begin
    ComposeDateValue(json, 'deceasedDate', TFhirDate(elem.deceased), false);
    ComposeDateProps(json, 'deceasedDate', TFhirDate(elem.deceased), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.deceased is TFhirString) then 
  begin
    ComposeStringValue(json, 'deceasedString', TFhirString(elem.deceased), false);
    ComposeStringProps(json, 'deceasedString', TFhirString(elem.deceased), false);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonCode') and (elem.reasonCodeList.Count > 0) then
  begin
    json.valueArray('reasonCode');
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.reasonCodeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonReference') and (elem.reasonReferenceList.Count > 0) then
  begin
    json.valueArray('reasonReference');
    for i := 0 to elem.reasonReferenceList.Count - 1 do
      ComposeReference{TFhirCondition}(json, '', elem.reasonReferenceList[i]); {z - Reference(Condition)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('note') and (elem.noteList.Count > 0) then
  begin
    json.valueArray('note');
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(json, '', elem.noteList[i]); {z - Annotation}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('condition') and (elem.conditionList.Count > 0) then
  begin
    json.valueArray('condition');
    for i := 0 to elem.conditionList.Count - 1 do
      ComposeFamilyMemberHistoryCondition(json, '', elem.conditionList[i]); {z - }
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_FAMILYMEMBERHISTORY}
{$IFDEF FHIR_FLAG}
procedure TFHIRJsonParser.ParseFlag(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseFlag(jsn)); {2}
end;

function TFHIRJsonParser.ParseFlag(jsn : TJsonObject) : TFhirFlag;
begin
  result := TFhirFlag.create;
  try
    ParseFlagProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseFlagProperties(jsn : TJsonObject; result : TFhirFlag);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirFlagStatusEnum, SYSTEMS_TFhirFlagStatusEnum);
    if jsn.has('category') then
      iterateArray(jsn.vArr['category'], result.categoryList, parseCodeableConcept);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirPatient}(jsn.vObj['subject']);{q3}
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q3}
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q3}
    if jsn.has('author') then
        result.author := ParseReference{TFhirDevice}(jsn.vObj['author']);{q3}
end;

procedure TFHIRJsonComposer.ComposeFlag(json : TJSONWriter; name : string; elem : TFhirFlag; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirFlagStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirFlagStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') and (elem.categoryList.Count > 0) then
  begin
    json.valueArray('category');
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.categoryList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  ComposeReference{TFhirPatient}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('period') then
    ComposePeriod(json, 'period', elem.period); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('author') then
    ComposeReference{TFhirDevice}(json, 'author', elem.author); {a}
end;

{$ENDIF FHIR_FLAG}
{$IFDEF FHIR_GOAL}
procedure TFHIRJsonParser.ParseGoalTarget(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseGoalTarget(jsn)); {2}
end;

function TFHIRJsonParser.ParseGoalTarget(jsn : TJsonObject) : TFhirGoalTarget;
begin
  result := TFhirGoalTarget.create;
  try
    ParseGoalTargetProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseGoalTargetProperties(jsn : TJsonObject; result : TFhirGoalTarget);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('measure') then
        result.measure := ParseCodeableConcept(jsn.vObj['measure']);{q3}
    if jsn.has('detailQuantity') {a4} then
      result.detail := ParseQuantity(jsn.vObj['detailQuantity']);
    if jsn.has('detailRange') {a4} then
      result.detail := ParseRange(jsn.vObj['detailRange']);
    if jsn.has('detailCodeableConcept') {a4} then
      result.detail := ParseCodeableConcept(jsn.vObj['detailCodeableConcept']);
    if jsn.has('detailRatio') {a4} then
      result.detail := ParseRatio(jsn.vObj['detailRatio']);
    if jsn.has('detailString') or jsn.has('_detailString') then
      result.detail := parseString(jsn.node['detailString'], jsn.vObj['_detailString']);
    if jsn.has('detailBoolean') or jsn.has('_detailBoolean') then
      result.detail := parseBoolean(jsn.node['detailBoolean'], jsn.vObj['_detailBoolean']);
    if jsn.has('detailInteger') or jsn.has('_detailInteger') then
      result.detail := parseInteger(jsn.node['detailInteger'], jsn.vObj['_detailInteger']);
    if jsn.has('dueDuration') {a4} then
      result.due := ParseDuration(jsn.vObj['dueDuration']);
    if jsn.has('dueDate') or jsn.has('_dueDate') then
      result.due := parseDate(jsn.node['dueDate'], jsn.vObj['_dueDate']);
end;

procedure TFHIRJsonComposer.ComposeGoalTarget(json : TJSONWriter; name : string; elem : TFhirGoalTarget; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'measure', elem.measure); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.detail is TFhirQuantity) then 
    ComposeQuantity(json, 'detailQuantity', TFhirQuantity(elem.detail)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.detail is TFhirRange) then 
    ComposeRange(json, 'detailRange', TFhirRange(elem.detail)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.detail is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'detailCodeableConcept', TFhirCodeableConcept(elem.detail)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.detail is TFhirRatio) then 
    ComposeRatio(json, 'detailRatio', TFhirRatio(elem.detail)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.detail is TFhirString) then 
  begin
    ComposeStringValue(json, 'detailString', TFhirString(elem.detail), false);
    ComposeStringProps(json, 'detailString', TFhirString(elem.detail), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.detail is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'detailBoolean', TFhirBoolean(elem.detail), false);
    ComposeBooleanProps(json, 'detailBoolean', TFhirBoolean(elem.detail), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.detail is TFhirInteger) then 
  begin
    ComposeIntegerValue(json, 'detailInteger', TFhirInteger(elem.detail), false);
    ComposeIntegerProps(json, 'detailInteger', TFhirInteger(elem.detail), false);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.due is TFhirDuration) then 
    ComposeDuration(json, 'dueDuration', TFhirDuration(elem.due)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.due is TFhirDate) then 
  begin
    ComposeDateValue(json, 'dueDate', TFhirDate(elem.due), false);
    ComposeDateProps(json, 'dueDate', TFhirDate(elem.due), false);
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseGoal(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseGoal(jsn)); {2}
end;

function TFHIRJsonParser.ParseGoal(jsn : TJsonObject) : TFhirGoal;
begin
  result := TFhirGoal.create;
  try
    ParseGoalProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseGoalProperties(jsn : TJsonObject; result : TFhirGoal);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('lifecycleStatus') or jsn.has('_lifecycleStatus')  then
      result.lifecycleStatusElement := parseEnum(jsn.path+'/lifecycleStatus', jsn.node['lifecycleStatus'], jsn.vObj['_lifecycleStatus'], CODES_TFhirGoalStatusEnum, SYSTEMS_TFhirGoalStatusEnum);
    if jsn.has('achievementStatus') then
        result.achievementStatus := ParseCodeableConcept(jsn.vObj['achievementStatus']);{q3}
    if jsn.has('category') then
      iterateArray(jsn.vArr['category'], result.categoryList, parseCodeableConcept);
    if jsn.has('priority') then
        result.priority := ParseCodeableConcept(jsn.vObj['priority']);{q3}
    if jsn.has('description') then
        result.description := ParseCodeableConcept(jsn.vObj['description']);{q3}
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirPatient}(jsn.vObj['subject']);{q3}
    if jsn.has('startCodeableConcept') {a4} then
      result.start := ParseCodeableConcept(jsn.vObj['startCodeableConcept']);
    if jsn.has('startDate') or jsn.has('_startDate') then
      result.start := parseDate(jsn.node['startDate'], jsn.vObj['_startDate']);
    if jsn.has('target') then
      iterateArray(jsn.vArr['target'], result.targetList, parseGoalTarget);
    if jsn.has('statusDate') or jsn.has('_statusDate') then
        result.statusDateElement := parseDate(jsn.node['statusDate'], jsn.vObj['_statusDate']);{q}
    if jsn.has('statusReason') or jsn.has('_statusReason') then
        result.statusReasonElement := parseString(jsn.node['statusReason'], jsn.vObj['_statusReason']);{q}
    if jsn.has('expressedBy') then
        result.expressedBy := ParseReference{TFhirPatient}(jsn.vObj['expressedBy']);{q3}
    if jsn.has('addresses') then
      iterateArray(jsn.vArr['addresses'], result.addressesList, parseReference{TFhirCondition});
    if jsn.has('note') then
      iterateArray(jsn.vArr['note'], result.noteList, parseAnnotation);
    if jsn.has('outcomeCode') then
      iterateArray(jsn.vArr['outcomeCode'], result.outcomeCodeList, parseCodeableConcept);
    if jsn.has('outcomeReference') then
      iterateArray(jsn.vArr['outcomeReference'], result.outcomeReferenceList, parseReference{TFhirObservation});
end;

procedure TFHIRJsonComposer.ComposeGoal(json : TJSONWriter; name : string; elem : TFhirGoal; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'lifecycleStatus', elem.LifecycleStatusElement, CODES_TFhirGoalStatusEnum, false);
  ComposeEnumProps(json, 'lifecycleStatus', elem.LifecycleStatusElement, CODES_TFhirGoalStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('achievementStatus') then
    ComposeCodeableConcept(json, 'achievementStatus', elem.achievementStatus); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') and (elem.categoryList.Count > 0) then
  begin
    json.valueArray('category');
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.categoryList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('priority') then
    ComposeCodeableConcept(json, 'priority', elem.priority); {a}
  ComposeCodeableConcept(json, 'description', elem.description); {a}
  ComposeReference{TFhirPatient}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.start is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'startCodeableConcept', TFhirCodeableConcept(elem.start)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.start is TFhirDate) then 
  begin
    ComposeDateValue(json, 'startDate', TFhirDate(elem.start), false);
    ComposeDateProps(json, 'startDate', TFhirDate(elem.start), false);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('target') and (elem.targetList.Count > 0) then
  begin
    json.valueArray('target');
    for i := 0 to elem.targetList.Count - 1 do
      ComposeGoalTarget(json, '', elem.targetList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('statusDate') then
    ComposeDateValue(json, 'statusDate', elem.statusDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('statusDate') then
    ComposeDateProps(json, 'statusDate', elem.statusDateElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('statusReason') then
    ComposeStringValue(json, 'statusReason', elem.statusReasonElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('statusReason') then
    ComposeStringProps(json, 'statusReason', elem.statusReasonElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('expressedBy') then
    ComposeReference{TFhirPatient}(json, 'expressedBy', elem.expressedBy); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('addresses') and (elem.addressesList.Count > 0) then
  begin
    json.valueArray('addresses');
    for i := 0 to elem.addressesList.Count - 1 do
      ComposeReference{TFhirCondition}(json, '', elem.addressesList[i]); {z - Reference(Condition)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('note') and (elem.noteList.Count > 0) then
  begin
    json.valueArray('note');
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(json, '', elem.noteList[i]); {z - Annotation}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('outcomeCode') and (elem.outcomeCodeList.Count > 0) then
  begin
    json.valueArray('outcomeCode');
    for i := 0 to elem.outcomeCodeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.outcomeCodeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('outcomeReference') and (elem.outcomeReferenceList.Count > 0) then
  begin
    json.valueArray('outcomeReference');
    for i := 0 to elem.outcomeReferenceList.Count - 1 do
      ComposeReference{TFhirObservation}(json, '', elem.outcomeReferenceList[i]); {z - Reference(Observation)}
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_GOAL}
{$IFDEF FHIR_GRAPHDEFINITION}
procedure TFHIRJsonParser.ParseGraphDefinitionLink(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseGraphDefinitionLink(jsn)); {2}
end;

function TFHIRJsonParser.ParseGraphDefinitionLink(jsn : TJsonObject) : TFhirGraphDefinitionLink;
begin
  result := TFhirGraphDefinitionLink.create;
  try
    ParseGraphDefinitionLinkProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseGraphDefinitionLinkProperties(jsn : TJsonObject; result : TFhirGraphDefinitionLink);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('path') or jsn.has('_path') then
        result.pathElement := parseString(jsn.node['path'], jsn.vObj['_path']);{q}
    if jsn.has('sliceName') or jsn.has('_sliceName') then
        result.sliceNameElement := parseString(jsn.node['sliceName'], jsn.vObj['_sliceName']);{q}
    if jsn.has('min') or jsn.has('_min') then
        result.minElement := parseInteger(jsn.node['min'], jsn.vObj['_min']);{q}
    if jsn.has('max') or jsn.has('_max') then
        result.maxElement := parseString(jsn.node['max'], jsn.vObj['_max']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('target') then
      iterateArray(jsn.vArr['target'], result.targetList, parseGraphDefinitionLinkTarget);
end;

procedure TFHIRJsonComposer.ComposeGraphDefinitionLink(json : TJSONWriter; name : string; elem : TFhirGraphDefinitionLink; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'path', elem.pathElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'path', elem.pathElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'sliceName', elem.sliceNameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'sliceName', elem.sliceNameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIntegerValue(json, 'min', elem.minElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIntegerProps(json, 'min', elem.minElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'max', elem.maxElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'max', elem.maxElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.targetList.Count > 0) then
  begin
    json.valueArray('target');
    for i := 0 to elem.targetList.Count - 1 do
      ComposeGraphDefinitionLinkTarget(json, '', elem.targetList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseGraphDefinitionLinkTarget(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseGraphDefinitionLinkTarget(jsn)); {2}
end;

function TFHIRJsonParser.ParseGraphDefinitionLinkTarget(jsn : TJsonObject) : TFhirGraphDefinitionLinkTarget;
begin
  result := TFhirGraphDefinitionLinkTarget.create;
  try
    ParseGraphDefinitionLinkTargetProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseGraphDefinitionLinkTargetProperties(jsn : TJsonObject; result : TFhirGraphDefinitionLinkTarget);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn.node['type'], jsn.vObj['_type'], CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum);
    if jsn.has('params') or jsn.has('_params') then
        result.paramsElement := parseString(jsn.node['params'], jsn.vObj['_params']);{q}
    if jsn.has('profile') or jsn.has('_profile') then
        result.profileElement := parseCanonical(jsn.node['profile'], jsn.vObj['_profile']);{q}
    if jsn.has('compartment') then
      iterateArray(jsn.vArr['compartment'], result.compartmentList, parseGraphDefinitionLinkTargetCompartment);
    if jsn.has('link') then
      iterateArray(jsn.vArr['link'], result.link_List, parseGraphDefinitionLink);
end;

procedure TFHIRJsonComposer.ComposeGraphDefinitionLinkTarget(json : TJSONWriter; name : string; elem : TFhirGraphDefinitionLinkTarget; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirResourceTypesEnum, false);
  ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirResourceTypesEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'params', elem.paramsElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'params', elem.paramsElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonicalValue(json, 'profile', elem.profileElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonicalProps(json, 'profile', elem.profileElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.compartmentList.Count > 0) then
  begin
    json.valueArray('compartment');
    for i := 0 to elem.compartmentList.Count - 1 do
      ComposeGraphDefinitionLinkTargetCompartment(json, '', elem.compartmentList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.link_List.Count > 0) then
  begin
    json.valueArray('link');
    for i := 0 to elem.link_List.Count - 1 do
      ComposeGraphDefinitionLink(json, '', elem.link_List[i]); {z - @GraphDefinition.link}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseGraphDefinitionLinkTargetCompartment(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseGraphDefinitionLinkTargetCompartment(jsn)); {2}
end;

function TFHIRJsonParser.ParseGraphDefinitionLinkTargetCompartment(jsn : TJsonObject) : TFhirGraphDefinitionLinkTargetCompartment;
begin
  result := TFhirGraphDefinitionLinkTargetCompartment.create;
  try
    ParseGraphDefinitionLinkTargetCompartmentProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseGraphDefinitionLinkTargetCompartmentProperties(jsn : TJsonObject; result : TFhirGraphDefinitionLinkTargetCompartment);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('use') or jsn.has('_use')  then
      result.useElement := parseEnum(jsn.path+'/use', jsn.node['use'], jsn.vObj['_use'], CODES_TFhirGraphCompartmentUseEnum, SYSTEMS_TFhirGraphCompartmentUseEnum);
    if jsn.has('code') or jsn.has('_code')  then
      result.codeElement := parseEnum(jsn.path+'/code', jsn.node['code'], jsn.vObj['_code'], CODES_TFhirCompartmentTypeEnum, SYSTEMS_TFhirCompartmentTypeEnum);
    if jsn.has('rule') or jsn.has('_rule')  then
      result.ruleElement := parseEnum(jsn.path+'/rule', jsn.node['rule'], jsn.vObj['_rule'], CODES_TFhirGraphCompartmentRuleEnum, SYSTEMS_TFhirGraphCompartmentRuleEnum);
    if jsn.has('expression') or jsn.has('_expression') then
        result.expressionElement := parseString(jsn.node['expression'], jsn.vObj['_expression']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseString(jsn.node['description'], jsn.vObj['_description']);{q}
end;

procedure TFHIRJsonComposer.ComposeGraphDefinitionLinkTargetCompartment(json : TJSONWriter; name : string; elem : TFhirGraphDefinitionLinkTargetCompartment; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'use', elem.UseElement, CODES_TFhirGraphCompartmentUseEnum, false);
  ComposeEnumProps(json, 'use', elem.UseElement, CODES_TFhirGraphCompartmentUseEnum, false);
  ComposeEnumValue(json, 'code', elem.CodeElement, CODES_TFhirCompartmentTypeEnum, false);
  ComposeEnumProps(json, 'code', elem.CodeElement, CODES_TFhirCompartmentTypeEnum, false);
  ComposeEnumValue(json, 'rule', elem.RuleElement, CODES_TFhirGraphCompartmentRuleEnum, false);
  ComposeEnumProps(json, 'rule', elem.RuleElement, CODES_TFhirGraphCompartmentRuleEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'expression', elem.expressionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'expression', elem.expressionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseGraphDefinition(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseGraphDefinition(jsn)); {2}
end;

function TFHIRJsonParser.ParseGraphDefinition(jsn : TJsonObject) : TFhirGraphDefinition;
begin
  result := TFhirGraphDefinition.create;
  try
    ParseGraphDefinitionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseGraphDefinitionProperties(jsn : TJsonObject; result : TFhirGraphDefinition);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := parseUri(jsn.node['url'], jsn.vObj['_url']);{q}
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := parseString(jsn.node['version'], jsn.vObj['_version']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    if jsn.has('experimental') or jsn.has('_experimental') then
        result.experimentalElement := parseBoolean(jsn.node['experimental'], jsn.vObj['_experimental']);{q}
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := parseDateTime(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('publisher') or jsn.has('_publisher') then
        result.publisherElement := parseString(jsn.node['publisher'], jsn.vObj['_publisher']);{q}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseContactDetail);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseMarkdown(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('useContext') then
      iterateArray(jsn.vArr['useContext'], result.useContextList, parseUsageContext);
    if jsn.has('jurisdiction') then
      iterateArray(jsn.vArr['jurisdiction'], result.jurisdictionList, parseCodeableConcept);
    if jsn.has('purpose') or jsn.has('_purpose') then
        result.purposeElement := parseMarkdown(jsn.node['purpose'], jsn.vObj['_purpose']);{q}
    if jsn.has('start') or jsn.has('_start')  then
      result.startElement := parseEnum(jsn.path+'/start', jsn.node['start'], jsn.vObj['_start'], CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum);
    if jsn.has('profile') or jsn.has('_profile') then
        result.profileElement := parseCanonical(jsn.node['profile'], jsn.vObj['_profile']);{q}
    if jsn.has('link') then
      iterateArray(jsn.vArr['link'], result.link_List, parseGraphDefinitionLink);
end;

procedure TFHIRJsonComposer.ComposeGraphDefinition(json : TJSONWriter; name : string; elem : TFhirGraphDefinition; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUriValue(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUriProps(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeStringValue(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeStringProps(json, 'version', elem.versionElement, false);
  ComposeStringValue(json, 'name', elem.nameElement, false);
  ComposeStringProps(json, 'name', elem.nameElement, false);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBooleanValue(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBooleanProps(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringValue(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringProps(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') and (elem.contactList.Count > 0) then
  begin
    json.valueArray('contact');
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(json, '', elem.contactList[i]); {z - ContactDetail}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdownValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdownProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') and (elem.useContextList.Count > 0) then
  begin
    json.valueArray('useContext');
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(json, '', elem.useContextList[i]); {z - UsageContext}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') and (elem.jurisdictionList.Count > 0) then
  begin
    json.valueArray('jurisdiction');
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.jurisdictionList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdownValue(json, 'purpose', elem.purposeElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdownProps(json, 'purpose', elem.purposeElement, false);
  ComposeEnumValue(json, 'start', elem.StartElement, CODES_TFhirResourceTypesEnum, false);
  ComposeEnumProps(json, 'start', elem.StartElement, CODES_TFhirResourceTypesEnum, false);
  if (SummaryOption in [soFull, soData]) and doCompose('profile') then
    ComposeCanonicalValue(json, 'profile', elem.profileElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('profile') then
    ComposeCanonicalProps(json, 'profile', elem.profileElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('link_') and (elem.link_List.Count > 0) then
  begin
    json.valueArray('link');
    for i := 0 to elem.link_List.Count - 1 do
      ComposeGraphDefinitionLink(json, '', elem.link_List[i]); {z - }
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_GRAPHDEFINITION}
{$IFDEF FHIR_GROUP}
procedure TFHIRJsonParser.ParseGroupCharacteristic(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseGroupCharacteristic(jsn)); {2}
end;

function TFHIRJsonParser.ParseGroupCharacteristic(jsn : TJsonObject) : TFhirGroupCharacteristic;
begin
  result := TFhirGroupCharacteristic.create;
  try
    ParseGroupCharacteristicProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseGroupCharacteristicProperties(jsn : TJsonObject; result : TFhirGroupCharacteristic);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('valueCodeableConcept') {a4} then
      result.value := ParseCodeableConcept(jsn.vObj['valueCodeableConcept']);
    if jsn.has('valueQuantity') {a4} then
      result.value := ParseQuantity(jsn.vObj['valueQuantity']);
    if jsn.has('valueRange') {a4} then
      result.value := ParseRange(jsn.vObj['valueRange']);
    if jsn.has('valueReference') {a4} then
      result.value := ParseReference(jsn.vObj['valueReference']);
    if jsn.has('valueBoolean') or jsn.has('_valueBoolean') then
      result.value := parseBoolean(jsn.node['valueBoolean'], jsn.vObj['_valueBoolean']);
    if jsn.has('exclude') or jsn.has('_exclude') then
        result.excludeElement := parseBoolean(jsn.node['exclude'], jsn.vObj['_exclude']);{q}
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q3}
end;

procedure TFHIRJsonComposer.ComposeGroupCharacteristic(json : TJSONWriter; name : string; elem : TFhirGroupCharacteristic; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (elem.value is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'valueCodeableConcept', TFhirCodeableConcept(elem.value)) 
  else if (elem.value is TFhirQuantity) then 
    ComposeQuantity(json, 'valueQuantity', TFhirQuantity(elem.value)) 
  else if (elem.value is TFhirRange) then 
    ComposeRange(json, 'valueRange', TFhirRange(elem.value)) 
  else if (elem.value is TFhirReference) then 
    ComposeReference(json, 'valueReference', TFhirReference(elem.value)) 
  else if (elem.value is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'valueBoolean', TFhirBoolean(elem.value), false);
    ComposeBooleanProps(json, 'valueBoolean', TFhirBoolean(elem.value), false);
  end;
  ComposeBooleanValue(json, 'exclude', elem.excludeElement, false);
  ComposeBooleanProps(json, 'exclude', elem.excludeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(json, 'period', elem.period); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseGroupMember(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseGroupMember(jsn)); {2}
end;

function TFHIRJsonParser.ParseGroupMember(jsn : TJsonObject) : TFhirGroupMember;
begin
  result := TFhirGroupMember.create;
  try
    ParseGroupMemberProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseGroupMemberProperties(jsn : TJsonObject; result : TFhirGroupMember);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('entity') then
        result.entity := ParseReference{TFhirPatient}(jsn.vObj['entity']);{q3}
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q3}
    if jsn.has('inactive') or jsn.has('_inactive') then
        result.inactiveElement := parseBoolean(jsn.node['inactive'], jsn.vObj['_inactive']);{q}
end;

procedure TFHIRJsonComposer.ComposeGroupMember(json : TJSONWriter; name : string; elem : TFhirGroupMember; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeReference{TFhirPatient}(json, 'entity', elem.entity); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(json, 'period', elem.period); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'inactive', elem.inactiveElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'inactive', elem.inactiveElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseGroup(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseGroup(jsn)); {2}
end;

function TFHIRJsonParser.ParseGroup(jsn : TJsonObject) : TFhirGroup;
begin
  result := TFhirGroup.create;
  try
    ParseGroupProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseGroupProperties(jsn : TJsonObject; result : TFhirGroup);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('active') or jsn.has('_active') then
        result.activeElement := parseBoolean(jsn.node['active'], jsn.vObj['_active']);{q}
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn.node['type'], jsn.vObj['_type'], CODES_TFhirGroupTypeEnum, SYSTEMS_TFhirGroupTypeEnum);
    if jsn.has('actual') or jsn.has('_actual') then
        result.actualElement := parseBoolean(jsn.node['actual'], jsn.vObj['_actual']);{q}
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('quantity') or jsn.has('_quantity') then
        result.quantityElement := parseUnsignedInt(jsn.node['quantity'], jsn.vObj['_quantity']);{q}
    if jsn.has('managingEntity') then
        result.managingEntity := ParseReference{TFhirOrganization}(jsn.vObj['managingEntity']);{q3}
    if jsn.has('characteristic') then
      iterateArray(jsn.vArr['characteristic'], result.characteristicList, parseGroupCharacteristic);
    if jsn.has('member') then
      iterateArray(jsn.vArr['member'], result.memberList, parseGroupMember);
end;

procedure TFHIRJsonComposer.ComposeGroup(json : TJSONWriter; name : string; elem : TFhirGroup; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('active') then
    ComposeBooleanValue(json, 'active', elem.activeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('active') then
    ComposeBooleanProps(json, 'active', elem.activeElement, false);
  ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirGroupTypeEnum, false);
  ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirGroupTypeEnum, false);
  ComposeBooleanValue(json, 'actual', elem.actualElement, false);
  ComposeBooleanProps(json, 'actual', elem.actualElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') then
    ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('quantity') then
    ComposeUnsignedIntValue(json, 'quantity', elem.quantityElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('quantity') then
    ComposeUnsignedIntProps(json, 'quantity', elem.quantityElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('managingEntity') then
    ComposeReference{TFhirOrganization}(json, 'managingEntity', elem.managingEntity); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('characteristic') and (elem.characteristicList.Count > 0) then
  begin
    json.valueArray('characteristic');
    for i := 0 to elem.characteristicList.Count - 1 do
      ComposeGroupCharacteristic(json, '', elem.characteristicList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('member') and (elem.memberList.Count > 0) then
  begin
    json.valueArray('member');
    for i := 0 to elem.memberList.Count - 1 do
      ComposeGroupMember(json, '', elem.memberList[i]); {z - }
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_GROUP}
{$IFDEF FHIR_GUIDANCERESPONSE}
procedure TFHIRJsonParser.ParseGuidanceResponse(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseGuidanceResponse(jsn)); {2}
end;

function TFHIRJsonParser.ParseGuidanceResponse(jsn : TJsonObject) : TFhirGuidanceResponse;
begin
  result := TFhirGuidanceResponse.create;
  try
    ParseGuidanceResponseProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseGuidanceResponseProperties(jsn : TJsonObject; result : TFhirGuidanceResponse);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('requestIdentifier') then
        result.requestIdentifier := ParseIdentifier(jsn.vObj['requestIdentifier']);{q3}
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('moduleCanonical') or jsn.has('_moduleCanonical') then
      result.module := parseCanonical(jsn.node['moduleCanonical'], jsn.vObj['_moduleCanonical']);
    if jsn.has('moduleCodeableConcept') {a4} then
      result.module := ParseCodeableConcept(jsn.vObj['moduleCodeableConcept']);
    if jsn.has('moduleUri') or jsn.has('_moduleUri') then
      result.module := parseUri(jsn.node['moduleUri'], jsn.vObj['_moduleUri']);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirGuidanceResponseStatusEnum, SYSTEMS_TFhirGuidanceResponseStatusEnum);
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirPatient}(jsn.vObj['subject']);{q3}
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q3}
    if jsn.has('occurrenceDateTime') or jsn.has('_occurrenceDateTime') then
        result.occurrenceDateTimeElement := parseDateTime(jsn.node['occurrenceDateTime'], jsn.vObj['_occurrenceDateTime']);{q}
    if jsn.has('performer') then
        result.performer := ParseReference{TFhirDevice}(jsn.vObj['performer']);{q3}
    if jsn.has('reasonCode') then
      iterateArray(jsn.vArr['reasonCode'], result.reasonCodeList, parseCodeableConcept);
    if jsn.has('reasonReference') then
      iterateArray(jsn.vArr['reasonReference'], result.reasonReferenceList, parseReference{TFhirCondition});
    if jsn.has('note') then
      iterateArray(jsn.vArr['note'], result.noteList, parseAnnotation);
    if jsn.has('evaluationMessage') then
      iterateArray(jsn.vArr['evaluationMessage'], result.evaluationMessageList, parseReference{TFhirOperationOutcome});
    if jsn.has('outputParameters') then
        result.outputParameters := ParseReference{TFhirParameters}(jsn.vObj['outputParameters']);{q3}
    if jsn.has('result') then
        result.result := ParseReference{TFhirCarePlan}(jsn.vObj['result']);{q3}
    if jsn.has('dataRequirement') then
      iterateArray(jsn.vArr['dataRequirement'], result.dataRequirementList, parseDataRequirement);
end;

procedure TFHIRJsonComposer.ComposeGuidanceResponse(json : TJSONWriter; name : string; elem : TFhirGuidanceResponse; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requestIdentifier') then
    ComposeIdentifier(json, 'requestIdentifier', elem.requestIdentifier); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (elem.module is TFhirCanonical) then 
  begin
    ComposeCanonicalValue(json, 'moduleCanonical', TFhirCanonical(elem.module), false);
    ComposeCanonicalProps(json, 'moduleCanonical', TFhirCanonical(elem.module), false);
  end
  else if (elem.module is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'moduleCodeableConcept', TFhirCodeableConcept(elem.module)) 
  else if (elem.module is TFhirUri) then 
  begin
    ComposeUriValue(json, 'moduleUri', TFhirUri(elem.module), false);
    ComposeUriProps(json, 'moduleUri', TFhirUri(elem.module), false);
  end;
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirGuidanceResponseStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirGuidanceResponseStatusEnum, false);
  if (SummaryOption in [soFull, soData]) and doCompose('subject') then
    ComposeReference{TFhirPatient}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('occurrenceDateTime') then
    ComposeDateTimeValue(json, 'occurrenceDateTime', elem.occurrenceDateTimeElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('occurrenceDateTime') then
    ComposeDateTimeProps(json, 'occurrenceDateTime', elem.occurrenceDateTimeElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('performer') then
    ComposeReference{TFhirDevice}(json, 'performer', elem.performer); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('reasonCode') and (elem.reasonCodeList.Count > 0) then
  begin
    json.valueArray('reasonCode');
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.reasonCodeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('reasonReference') and (elem.reasonReferenceList.Count > 0) then
  begin
    json.valueArray('reasonReference');
    for i := 0 to elem.reasonReferenceList.Count - 1 do
      ComposeReference{TFhirCondition}(json, '', elem.reasonReferenceList[i]); {z - Reference(Condition)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('note') and (elem.noteList.Count > 0) then
  begin
    json.valueArray('note');
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(json, '', elem.noteList[i]); {z - Annotation}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('evaluationMessage') and (elem.evaluationMessageList.Count > 0) then
  begin
    json.valueArray('evaluationMessage');
    for i := 0 to elem.evaluationMessageList.Count - 1 do
      ComposeReference{TFhirOperationOutcome}(json, '', elem.evaluationMessageList[i]); {z - Reference(OperationOutcome)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('outputParameters') then
    ComposeReference{TFhirParameters}(json, 'outputParameters', elem.outputParameters); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('result') then
    ComposeReference{TFhirCarePlan}(json, 'result', elem.result); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('dataRequirement') and (elem.dataRequirementList.Count > 0) then
  begin
    json.valueArray('dataRequirement');
    for i := 0 to elem.dataRequirementList.Count - 1 do
      ComposeDataRequirement(json, '', elem.dataRequirementList[i]); {z - DataRequirement}
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_GUIDANCERESPONSE}
{$IFDEF FHIR_HEALTHCARESERVICE}
procedure TFHIRJsonParser.ParseHealthcareServiceEligibility(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseHealthcareServiceEligibility(jsn)); {2}
end;

function TFHIRJsonParser.ParseHealthcareServiceEligibility(jsn : TJsonObject) : TFhirHealthcareServiceEligibility;
begin
  result := TFhirHealthcareServiceEligibility.create;
  try
    ParseHealthcareServiceEligibilityProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseHealthcareServiceEligibilityProperties(jsn : TJsonObject; result : TFhirHealthcareServiceEligibility);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('comment') or jsn.has('_comment') then
        result.commentElement := parseMarkdown(jsn.node['comment'], jsn.vObj['_comment']);{q}
end;

procedure TFHIRJsonComposer.ComposeHealthcareServiceEligibility(json : TJSONWriter; name : string; elem : TFhirHealthcareServiceEligibility; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdownValue(json, 'comment', elem.commentElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdownProps(json, 'comment', elem.commentElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseHealthcareServiceAvailableTime(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseHealthcareServiceAvailableTime(jsn)); {2}
end;

function TFHIRJsonParser.ParseHealthcareServiceAvailableTime(jsn : TJsonObject) : TFhirHealthcareServiceAvailableTime;
begin
  result := TFhirHealthcareServiceAvailableTime.create;
  try
    ParseHealthcareServiceAvailableTimeProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseHealthcareServiceAvailableTimeProperties(jsn : TJsonObject; result : TFhirHealthcareServiceAvailableTime);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('daysOfWeek') or jsn.has('_daysOfWeek') then
      iterateEnumArray(jsn.vArr['daysOfWeek'], jsn.vArr['_daysOfWeek'], jsn.path+'/daysOfWeek', result.daysOfWeekList, parseEnum, CODES_TFhirDaysOfWeekEnum, SYSTEMS_TFhirDaysOfWeekEnum);
    if jsn.has('allDay') or jsn.has('_allDay') then
        result.allDayElement := parseBoolean(jsn.node['allDay'], jsn.vObj['_allDay']);{q}
    if jsn.has('availableStartTime') or jsn.has('_availableStartTime') then
        result.availableStartTimeElement := parseTime(jsn.node['availableStartTime'], jsn.vObj['_availableStartTime']);{q}
    if jsn.has('availableEndTime') or jsn.has('_availableEndTime') then
        result.availableEndTimeElement := parseTime(jsn.node['availableEndTime'], jsn.vObj['_availableEndTime']);{q}
end;

procedure TFHIRJsonComposer.ComposeHealthcareServiceAvailableTime(json : TJSONWriter; name : string; elem : TFhirHealthcareServiceAvailableTime; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and (elem.daysOfWeekList.Count > 0) then
  begin
    val := false;
    ext := false;
    for i := 0 to elem.daysOfWeekList.Count - 1 do
    begin
      val := val or (elem.daysOfWeekList[i].hasPrimitiveValue);
      ext := ext or ((elem.daysOfWeekList[i].id <> '') or (elem.daysOfWeekList[i].hasExtensionList));
    end;
    if val then
    begin
      json.valueArray('daysOfWeek');
      for i := 0 to elem.daysOfWeekList.Count - 1 do
        ComposeEnumValue(json, '', elem.daysOfWeekList[i], CODES_TFhirDaysOfWeekEnum, true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_daysOfWeek');
      for i := 0 to elem.daysOfWeekList.Count - 1 do
        ComposeEnumProps(json, '', elem.daysOfWeekList[i], CODES_TFhirDaysOfWeekEnum, true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'allDay', elem.allDayElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'allDay', elem.allDayElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeTimeValue(json, 'availableStartTime', elem.availableStartTimeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeTimeProps(json, 'availableStartTime', elem.availableStartTimeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeTimeValue(json, 'availableEndTime', elem.availableEndTimeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeTimeProps(json, 'availableEndTime', elem.availableEndTimeElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseHealthcareServiceNotAvailable(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseHealthcareServiceNotAvailable(jsn)); {2}
end;

function TFHIRJsonParser.ParseHealthcareServiceNotAvailable(jsn : TJsonObject) : TFhirHealthcareServiceNotAvailable;
begin
  result := TFhirHealthcareServiceNotAvailable.create;
  try
    ParseHealthcareServiceNotAvailableProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseHealthcareServiceNotAvailableProperties(jsn : TJsonObject; result : TFhirHealthcareServiceNotAvailable);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('during') then
        result.during := ParsePeriod(jsn.vObj['during']);{q3}
end;

procedure TFHIRJsonComposer.ComposeHealthcareServiceNotAvailable(json : TJSONWriter; name : string; elem : TFhirHealthcareServiceNotAvailable; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'description', elem.descriptionElement, false);
  ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(json, 'during', elem.during); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseHealthcareService(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseHealthcareService(jsn)); {2}
end;

function TFHIRJsonParser.ParseHealthcareService(jsn : TJsonObject) : TFhirHealthcareService;
begin
  result := TFhirHealthcareService.create;
  try
    ParseHealthcareServiceProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseHealthcareServiceProperties(jsn : TJsonObject; result : TFhirHealthcareService);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('active') or jsn.has('_active') then
        result.activeElement := parseBoolean(jsn.node['active'], jsn.vObj['_active']);{q}
    if jsn.has('providedBy') then
        result.providedBy := ParseReference{TFhirOrganization}(jsn.vObj['providedBy']);{q3}
    if jsn.has('category') then
      iterateArray(jsn.vArr['category'], result.categoryList, parseCodeableConcept);
    if jsn.has('type') then
      iterateArray(jsn.vArr['type'], result.type_List, parseCodeableConcept);
    if jsn.has('specialty') then
      iterateArray(jsn.vArr['specialty'], result.specialtyList, parseCodeableConcept);
    if jsn.has('location') then
      iterateArray(jsn.vArr['location'], result.locationList, parseReference{TFhirLocation});
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('comment') or jsn.has('_comment') then
        result.commentElement := parseString(jsn.node['comment'], jsn.vObj['_comment']);{q}
    if jsn.has('extraDetails') or jsn.has('_extraDetails') then
        result.extraDetailsElement := parseMarkdown(jsn.node['extraDetails'], jsn.vObj['_extraDetails']);{q}
    if jsn.has('photo') then
        result.photo := ParseAttachment(jsn.vObj['photo']);{q3}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    if jsn.has('coverageArea') then
      iterateArray(jsn.vArr['coverageArea'], result.coverageAreaList, parseReference{TFhirLocation});
    if jsn.has('serviceProvisionCode') then
      iterateArray(jsn.vArr['serviceProvisionCode'], result.serviceProvisionCodeList, parseCodeableConcept);
    if jsn.has('eligibility') then
      iterateArray(jsn.vArr['eligibility'], result.eligibilityList, parseHealthcareServiceEligibility);
    if jsn.has('program') then
      iterateArray(jsn.vArr['program'], result.program_List, parseCodeableConcept);
    if jsn.has('characteristic') then
      iterateArray(jsn.vArr['characteristic'], result.characteristicList, parseCodeableConcept);
    if jsn.has('communication') then
      iterateArray(jsn.vArr['communication'], result.communicationList, parseCodeableConcept);
    if jsn.has('referralMethod') then
      iterateArray(jsn.vArr['referralMethod'], result.referralMethodList, parseCodeableConcept);
    if jsn.has('appointmentRequired') or jsn.has('_appointmentRequired') then
        result.appointmentRequiredElement := parseBoolean(jsn.node['appointmentRequired'], jsn.vObj['_appointmentRequired']);{q}
    if jsn.has('availableTime') then
      iterateArray(jsn.vArr['availableTime'], result.availableTimeList, parseHealthcareServiceAvailableTime);
    if jsn.has('notAvailable') then
      iterateArray(jsn.vArr['notAvailable'], result.notAvailableList, parseHealthcareServiceNotAvailable);
    if jsn.has('availabilityExceptions') or jsn.has('_availabilityExceptions') then
        result.availabilityExceptionsElement := parseString(jsn.node['availabilityExceptions'], jsn.vObj['_availabilityExceptions']);{q}
    if jsn.has('endpoint') then
      iterateArray(jsn.vArr['endpoint'], result.endpointList, parseReference{TFhirEndpoint});
end;

procedure TFHIRJsonComposer.ComposeHealthcareService(json : TJSONWriter; name : string; elem : TFhirHealthcareService; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('active') then
    ComposeBooleanValue(json, 'active', elem.activeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('active') then
    ComposeBooleanProps(json, 'active', elem.activeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('providedBy') then
    ComposeReference{TFhirOrganization}(json, 'providedBy', elem.providedBy); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') and (elem.categoryList.Count > 0) then
  begin
    json.valueArray('category');
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.categoryList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') and (elem.type_List.Count > 0) then
  begin
    json.valueArray('type');
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(json, '', elem.type_List[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('specialty') and (elem.specialtyList.Count > 0) then
  begin
    json.valueArray('specialty');
    for i := 0 to elem.specialtyList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.specialtyList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('location') and (elem.locationList.Count > 0) then
  begin
    json.valueArray('location');
    for i := 0 to elem.locationList.Count - 1 do
      ComposeReference{TFhirLocation}(json, '', elem.locationList[i]); {z - Reference(Location)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('comment') then
    ComposeStringValue(json, 'comment', elem.commentElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('comment') then
    ComposeStringProps(json, 'comment', elem.commentElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('extraDetails') then
    ComposeMarkdownValue(json, 'extraDetails', elem.extraDetailsElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('extraDetails') then
    ComposeMarkdownProps(json, 'extraDetails', elem.extraDetailsElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('photo') then
    ComposeAttachment(json, 'photo', elem.photo); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('telecom') and (elem.telecomList.Count > 0) then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '', elem.telecomList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('coverageArea') and (elem.coverageAreaList.Count > 0) then
  begin
    json.valueArray('coverageArea');
    for i := 0 to elem.coverageAreaList.Count - 1 do
      ComposeReference{TFhirLocation}(json, '', elem.coverageAreaList[i]); {z - Reference(Location)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('serviceProvisionCode') and (elem.serviceProvisionCodeList.Count > 0) then
  begin
    json.valueArray('serviceProvisionCode');
    for i := 0 to elem.serviceProvisionCodeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.serviceProvisionCodeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('eligibility') and (elem.eligibilityList.Count > 0) then
  begin
    json.valueArray('eligibility');
    for i := 0 to elem.eligibilityList.Count - 1 do
      ComposeHealthcareServiceEligibility(json, '', elem.eligibilityList[i]); {z - }
      json.FinishArray;
    end;
  if (SummaryOption in [soFull, soData]) and doCompose('program_') and (elem.program_List.Count > 0) then
    begin
    json.valueArray('program');
    for i := 0 to elem.program_List.Count - 1 do
      ComposeCodeableConcept(json, '', elem.program_List[i]); {z - CodeableConcept}
      json.FinishArray;
    end;
  if (SummaryOption in [soFull, soData]) and doCompose('characteristic') and (elem.characteristicList.Count > 0) then
  begin
    json.valueArray('characteristic');
    for i := 0 to elem.characteristicList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.characteristicList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('communication') and (elem.communicationList.Count > 0) then
  begin
    json.valueArray('communication');
    for i := 0 to elem.communicationList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.communicationList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('referralMethod') and (elem.referralMethodList.Count > 0) then
  begin
    json.valueArray('referralMethod');
    for i := 0 to elem.referralMethodList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.referralMethodList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('appointmentRequired') then
    ComposeBooleanValue(json, 'appointmentRequired', elem.appointmentRequiredElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('appointmentRequired') then
    ComposeBooleanProps(json, 'appointmentRequired', elem.appointmentRequiredElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('availableTime') and (elem.availableTimeList.Count > 0) then
  begin
    json.valueArray('availableTime');
    for i := 0 to elem.availableTimeList.Count - 1 do
      ComposeHealthcareServiceAvailableTime(json, '', elem.availableTimeList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('notAvailable') and (elem.notAvailableList.Count > 0) then
  begin
    json.valueArray('notAvailable');
    for i := 0 to elem.notAvailableList.Count - 1 do
      ComposeHealthcareServiceNotAvailable(json, '', elem.notAvailableList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('availabilityExceptions') then
    ComposeStringValue(json, 'availabilityExceptions', elem.availabilityExceptionsElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('availabilityExceptions') then
    ComposeStringProps(json, 'availabilityExceptions', elem.availabilityExceptionsElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('endpoint') and (elem.endpointList.Count > 0) then
  begin
    json.valueArray('endpoint');
    for i := 0 to elem.endpointList.Count - 1 do
      ComposeReference{TFhirEndpoint}(json, '', elem.endpointList[i]); {z - Reference(Endpoint)}
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_HEALTHCARESERVICE}
{$IFDEF FHIR_IMAGINGSTUDY}
procedure TFHIRJsonParser.ParseImagingStudySeries(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImagingStudySeries(jsn)); {2}
end;

function TFHIRJsonParser.ParseImagingStudySeries(jsn : TJsonObject) : TFhirImagingStudySeries;
begin
  result := TFhirImagingStudySeries.create;
  try
    ParseImagingStudySeriesProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseImagingStudySeriesProperties(jsn : TJsonObject; result : TFhirImagingStudySeries);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('uid') or jsn.has('_uid') then
        result.uidElement := parseId(jsn.node['uid'], jsn.vObj['_uid']);{q}
    if jsn.has('number') or jsn.has('_number') then
        result.numberElement := parseUnsignedInt(jsn.node['number'], jsn.vObj['_number']);{q}
    if jsn.has('modality') then
        result.modality := ParseCoding(jsn.vObj['modality']);{q3}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('numberOfInstances') or jsn.has('_numberOfInstances') then
        result.numberOfInstancesElement := parseUnsignedInt(jsn.node['numberOfInstances'], jsn.vObj['_numberOfInstances']);{q}
    if jsn.has('endpoint') then
      iterateArray(jsn.vArr['endpoint'], result.endpointList, parseReference{TFhirEndpoint});
    if jsn.has('bodySite') then
        result.bodySite := ParseCoding(jsn.vObj['bodySite']);{q3}
    if jsn.has('laterality') then
        result.laterality := ParseCoding(jsn.vObj['laterality']);{q3}
    if jsn.has('specimen') then
      iterateArray(jsn.vArr['specimen'], result.specimenList, parseReference{TFhirSpecimen});
    if jsn.has('started') or jsn.has('_started') then
        result.startedElement := parseDateTime(jsn.node['started'], jsn.vObj['_started']);{q}
    if jsn.has('performer') then
      iterateArray(jsn.vArr['performer'], result.performerList, parseImagingStudySeriesPerformer);
    if jsn.has('instance') then
      iterateArray(jsn.vArr['instance'], result.instanceList, parseImagingStudySeriesInstance);
end;

procedure TFHIRJsonComposer.ComposeImagingStudySeries(json : TJSONWriter; name : string; elem : TFhirImagingStudySeries; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeIdValue(json, 'uid', elem.uidElement, false);
  ComposeIdProps(json, 'uid', elem.uidElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedIntValue(json, 'number', elem.numberElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedIntProps(json, 'number', elem.numberElement, false);
  ComposeCoding(json, 'modality', elem.modality); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedIntValue(json, 'numberOfInstances', elem.numberOfInstancesElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedIntProps(json, 'numberOfInstances', elem.numberOfInstancesElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.endpointList.Count > 0) then
  begin
    json.valueArray('endpoint');
    for i := 0 to elem.endpointList.Count - 1 do
      ComposeReference{TFhirEndpoint}(json, '', elem.endpointList[i]); {z - Reference(Endpoint)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'bodySite', elem.bodySite); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'laterality', elem.laterality); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.specimenList.Count > 0) then
  begin
    json.valueArray('specimen');
    for i := 0 to elem.specimenList.Count - 1 do
      ComposeReference{TFhirSpecimen}(json, '', elem.specimenList[i]); {z - Reference(Specimen)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'started', elem.startedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'started', elem.startedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.performerList.Count > 0) then
  begin
    json.valueArray('performer');
    for i := 0 to elem.performerList.Count - 1 do
      ComposeImagingStudySeriesPerformer(json, '', elem.performerList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.instanceList.Count > 0) then
  begin
    json.valueArray('instance');
    for i := 0 to elem.instanceList.Count - 1 do
      ComposeImagingStudySeriesInstance(json, '', elem.instanceList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseImagingStudySeriesPerformer(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImagingStudySeriesPerformer(jsn)); {2}
end;

function TFHIRJsonParser.ParseImagingStudySeriesPerformer(jsn : TJsonObject) : TFhirImagingStudySeriesPerformer;
begin
  result := TFhirImagingStudySeriesPerformer.create;
  try
    ParseImagingStudySeriesPerformerProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseImagingStudySeriesPerformerProperties(jsn : TJsonObject; result : TFhirImagingStudySeriesPerformer);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('function') then
        result.function_ := ParseCodeableConcept(jsn.vObj['function']);{q3}
    if jsn.has('actor') then
        result.actor := ParseReference{TFhirPractitioner}(jsn.vObj['actor']);{q3}
end;

procedure TFHIRJsonComposer.ComposeImagingStudySeriesPerformer(json : TJSONWriter; name : string; elem : TFhirImagingStudySeriesPerformer; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'function', elem.function_); {a}
  ComposeReference{TFhirPractitioner}(json, 'actor', elem.actor); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseImagingStudySeriesInstance(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImagingStudySeriesInstance(jsn)); {2}
end;

function TFHIRJsonParser.ParseImagingStudySeriesInstance(jsn : TJsonObject) : TFhirImagingStudySeriesInstance;
begin
  result := TFhirImagingStudySeriesInstance.create;
  try
    ParseImagingStudySeriesInstanceProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseImagingStudySeriesInstanceProperties(jsn : TJsonObject; result : TFhirImagingStudySeriesInstance);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('uid') or jsn.has('_uid') then
        result.uidElement := parseId(jsn.node['uid'], jsn.vObj['_uid']);{q}
    if jsn.has('sopClass') then
        result.sopClass := ParseCoding(jsn.vObj['sopClass']);{q3}
    if jsn.has('number') or jsn.has('_number') then
        result.numberElement := parseUnsignedInt(jsn.node['number'], jsn.vObj['_number']);{q}
    if jsn.has('title') or jsn.has('_title') then
        result.titleElement := parseString(jsn.node['title'], jsn.vObj['_title']);{q}
end;

procedure TFHIRJsonComposer.ComposeImagingStudySeriesInstance(json : TJSONWriter; name : string; elem : TFhirImagingStudySeriesInstance; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeIdValue(json, 'uid', elem.uidElement, false);
  ComposeIdProps(json, 'uid', elem.uidElement, false);
  ComposeCoding(json, 'sopClass', elem.sopClass); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeUnsignedIntValue(json, 'number', elem.numberElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeUnsignedIntProps(json, 'number', elem.numberElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'title', elem.titleElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseImagingStudy(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImagingStudy(jsn)); {2}
end;

function TFHIRJsonParser.ParseImagingStudy(jsn : TJsonObject) : TFhirImagingStudy;
begin
  result := TFhirImagingStudy.create;
  try
    ParseImagingStudyProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseImagingStudyProperties(jsn : TJsonObject; result : TFhirImagingStudy);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirImagingstudyStatusEnum, SYSTEMS_TFhirImagingstudyStatusEnum);
    if jsn.has('modality') then
      iterateArray(jsn.vArr['modality'], result.modalityList, parseCoding);
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirPatient}(jsn.vObj['subject']);{q3}
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q3}
    if jsn.has('started') or jsn.has('_started') then
        result.startedElement := parseDateTime(jsn.node['started'], jsn.vObj['_started']);{q}
    if jsn.has('basedOn') then
      iterateArray(jsn.vArr['basedOn'], result.basedOnList, parseReference{TFhirCarePlan});
    if jsn.has('referrer') then
        result.referrer := ParseReference{TFhirPractitioner}(jsn.vObj['referrer']);{q3}
    if jsn.has('interpreter') then
      iterateArray(jsn.vArr['interpreter'], result.interpreterList, parseReference{TFhirPractitioner});
    if jsn.has('endpoint') then
      iterateArray(jsn.vArr['endpoint'], result.endpointList, parseReference{TFhirEndpoint});
    if jsn.has('numberOfSeries') or jsn.has('_numberOfSeries') then
        result.numberOfSeriesElement := parseUnsignedInt(jsn.node['numberOfSeries'], jsn.vObj['_numberOfSeries']);{q}
    if jsn.has('numberOfInstances') or jsn.has('_numberOfInstances') then
        result.numberOfInstancesElement := parseUnsignedInt(jsn.node['numberOfInstances'], jsn.vObj['_numberOfInstances']);{q}
    if jsn.has('procedureReference') then
        result.procedureReference := ParseReference{TFhirProcedure}(jsn.vObj['procedureReference']);{q3}
    if jsn.has('procedureCode') then
      iterateArray(jsn.vArr['procedureCode'], result.procedureCodeList, parseCodeableConcept);
    if jsn.has('location') then
        result.location := ParseReference{TFhirLocation}(jsn.vObj['location']);{q3}
    if jsn.has('reasonCode') then
      iterateArray(jsn.vArr['reasonCode'], result.reasonCodeList, parseCodeableConcept);
    if jsn.has('reasonReference') then
      iterateArray(jsn.vArr['reasonReference'], result.reasonReferenceList, parseReference{TFhirCondition});
    if jsn.has('note') then
      iterateArray(jsn.vArr['note'], result.noteList, parseAnnotation);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('series') then
      iterateArray(jsn.vArr['series'], result.seriesList, parseImagingStudySeries);
end;

procedure TFHIRJsonComposer.ComposeImagingStudy(json : TJSONWriter; name : string; elem : TFhirImagingStudy; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirImagingstudyStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirImagingstudyStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('modality') and (elem.modalityList.Count > 0) then
  begin
    json.valueArray('modality');
    for i := 0 to elem.modalityList.Count - 1 do
      ComposeCoding(json, '', elem.modalityList[i]); {z - Coding}
    json.FinishArray;
  end;
  ComposeReference{TFhirPatient}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('started') then
    ComposeDateTimeValue(json, 'started', elem.startedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('started') then
    ComposeDateTimeProps(json, 'started', elem.startedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('basedOn') and (elem.basedOnList.Count > 0) then
  begin
    json.valueArray('basedOn');
    for i := 0 to elem.basedOnList.Count - 1 do
      ComposeReference{TFhirCarePlan}(json, '', elem.basedOnList[i]); {z - Reference(CarePlan)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('referrer') then
    ComposeReference{TFhirPractitioner}(json, 'referrer', elem.referrer); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('interpreter') and (elem.interpreterList.Count > 0) then
  begin
    json.valueArray('interpreter');
    for i := 0 to elem.interpreterList.Count - 1 do
      ComposeReference{TFhirPractitioner}(json, '', elem.interpreterList[i]); {z - Reference(Practitioner)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('endpoint') and (elem.endpointList.Count > 0) then
  begin
    json.valueArray('endpoint');
    for i := 0 to elem.endpointList.Count - 1 do
      ComposeReference{TFhirEndpoint}(json, '', elem.endpointList[i]); {z - Reference(Endpoint)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('numberOfSeries') then
    ComposeUnsignedIntValue(json, 'numberOfSeries', elem.numberOfSeriesElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('numberOfSeries') then
    ComposeUnsignedIntProps(json, 'numberOfSeries', elem.numberOfSeriesElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('numberOfInstances') then
    ComposeUnsignedIntValue(json, 'numberOfInstances', elem.numberOfInstancesElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('numberOfInstances') then
    ComposeUnsignedIntProps(json, 'numberOfInstances', elem.numberOfInstancesElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('procedureReference') then
    ComposeReference{TFhirProcedure}(json, 'procedureReference', elem.procedureReference); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('procedureCode') and (elem.procedureCodeList.Count > 0) then
  begin
    json.valueArray('procedureCode');
    for i := 0 to elem.procedureCodeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.procedureCodeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('location') then
    ComposeReference{TFhirLocation}(json, 'location', elem.location); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonCode') and (elem.reasonCodeList.Count > 0) then
  begin
    json.valueArray('reasonCode');
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.reasonCodeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonReference') and (elem.reasonReferenceList.Count > 0) then
  begin
    json.valueArray('reasonReference');
    for i := 0 to elem.reasonReferenceList.Count - 1 do
      ComposeReference{TFhirCondition}(json, '', elem.reasonReferenceList[i]); {z - Reference(Condition)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('note') and (elem.noteList.Count > 0) then
  begin
    json.valueArray('note');
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(json, '', elem.noteList[i]); {z - Annotation}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('series') and (elem.seriesList.Count > 0) then
  begin
    json.valueArray('series');
    for i := 0 to elem.seriesList.Count - 1 do
      ComposeImagingStudySeries(json, '', elem.seriesList[i]); {z - }
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_IMAGINGSTUDY}
{$IFDEF FHIR_IMMUNIZATION}
procedure TFHIRJsonParser.ParseImmunizationPerformer(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImmunizationPerformer(jsn)); {2}
end;

function TFHIRJsonParser.ParseImmunizationPerformer(jsn : TJsonObject) : TFhirImmunizationPerformer;
begin
  result := TFhirImmunizationPerformer.create;
  try
    ParseImmunizationPerformerProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseImmunizationPerformerProperties(jsn : TJsonObject; result : TFhirImmunizationPerformer);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('function') then
        result.function_ := ParseCodeableConcept(jsn.vObj['function']);{q3}
    if jsn.has('actor') then
        result.actor := ParseReference{TFhirPractitioner}(jsn.vObj['actor']);{q3}
end;

procedure TFHIRJsonComposer.ComposeImmunizationPerformer(json : TJSONWriter; name : string; elem : TFhirImmunizationPerformer; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'function', elem.function_); {a}
  ComposeReference{TFhirPractitioner}(json, 'actor', elem.actor); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseImmunizationEducation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImmunizationEducation(jsn)); {2}
end;

function TFHIRJsonParser.ParseImmunizationEducation(jsn : TJsonObject) : TFhirImmunizationEducation;
begin
  result := TFhirImmunizationEducation.create;
  try
    ParseImmunizationEducationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseImmunizationEducationProperties(jsn : TJsonObject; result : TFhirImmunizationEducation);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('documentType') or jsn.has('_documentType') then
        result.documentTypeElement := parseString(jsn.node['documentType'], jsn.vObj['_documentType']);{q}
    if jsn.has('reference') or jsn.has('_reference') then
        result.referenceElement := parseUri(jsn.node['reference'], jsn.vObj['_reference']);{q}
    if jsn.has('publicationDate') or jsn.has('_publicationDate') then
        result.publicationDateElement := parseDateTime(jsn.node['publicationDate'], jsn.vObj['_publicationDate']);{q}
    if jsn.has('presentationDate') or jsn.has('_presentationDate') then
        result.presentationDateElement := parseDateTime(jsn.node['presentationDate'], jsn.vObj['_presentationDate']);{q}
end;

procedure TFHIRJsonComposer.ComposeImmunizationEducation(json : TJSONWriter; name : string; elem : TFhirImmunizationEducation; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'documentType', elem.documentTypeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'documentType', elem.documentTypeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeUriValue(json, 'reference', elem.referenceElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeUriProps(json, 'reference', elem.referenceElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTimeValue(json, 'publicationDate', elem.publicationDateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTimeProps(json, 'publicationDate', elem.publicationDateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTimeValue(json, 'presentationDate', elem.presentationDateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTimeProps(json, 'presentationDate', elem.presentationDateElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseImmunizationReaction(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImmunizationReaction(jsn)); {2}
end;

function TFHIRJsonParser.ParseImmunizationReaction(jsn : TJsonObject) : TFhirImmunizationReaction;
begin
  result := TFhirImmunizationReaction.create;
  try
    ParseImmunizationReactionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseImmunizationReactionProperties(jsn : TJsonObject; result : TFhirImmunizationReaction);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := parseDateTime(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('detail') then
        result.detail := ParseReference{TFhirObservation}(jsn.vObj['detail']);{q3}
    if jsn.has('reported') or jsn.has('_reported') then
        result.reportedElement := parseBoolean(jsn.node['reported'], jsn.vObj['_reported']);{q}
end;

procedure TFHIRJsonComposer.ComposeImmunizationReaction(json : TJSONWriter; name : string; elem : TFhirImmunizationReaction; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirObservation}(json, 'detail', elem.detail); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'reported', elem.reportedElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'reported', elem.reportedElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseImmunizationProtocolApplied(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImmunizationProtocolApplied(jsn)); {2}
end;

function TFHIRJsonParser.ParseImmunizationProtocolApplied(jsn : TJsonObject) : TFhirImmunizationProtocolApplied;
begin
  result := TFhirImmunizationProtocolApplied.create;
  try
    ParseImmunizationProtocolAppliedProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseImmunizationProtocolAppliedProperties(jsn : TJsonObject; result : TFhirImmunizationProtocolApplied);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('series') or jsn.has('_series') then
        result.seriesElement := parseString(jsn.node['series'], jsn.vObj['_series']);{q}
    if jsn.has('authority') then
        result.authority := ParseReference{TFhirOrganization}(jsn.vObj['authority']);{q3}
    if jsn.has('targetDisease') then
      iterateArray(jsn.vArr['targetDisease'], result.targetDiseaseList, parseCodeableConcept);
    if jsn.has('doseNumberPositiveInt') or jsn.has('_doseNumberPositiveInt') then
      result.doseNumber := parsePositiveInt(jsn.node['doseNumberPositiveInt'], jsn.vObj['_doseNumberPositiveInt']);
    if jsn.has('doseNumberString') or jsn.has('_doseNumberString') then
      result.doseNumber := parseString(jsn.node['doseNumberString'], jsn.vObj['_doseNumberString']);
    if jsn.has('seriesDosesPositiveInt') or jsn.has('_seriesDosesPositiveInt') then
      result.seriesDoses := parsePositiveInt(jsn.node['seriesDosesPositiveInt'], jsn.vObj['_seriesDosesPositiveInt']);
    if jsn.has('seriesDosesString') or jsn.has('_seriesDosesString') then
      result.seriesDoses := parseString(jsn.node['seriesDosesString'], jsn.vObj['_seriesDosesString']);
end;

procedure TFHIRJsonComposer.ComposeImmunizationProtocolApplied(json : TJSONWriter; name : string; elem : TFhirImmunizationProtocolApplied; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'series', elem.seriesElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'series', elem.seriesElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(json, 'authority', elem.authority); {a}
  if (SummaryOption in [soFull, soData]) and (elem.targetDiseaseList.Count > 0) then
  begin
    json.valueArray('targetDisease');
    for i := 0 to elem.targetDiseaseList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.targetDiseaseList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (elem.doseNumber is TFhirPositiveInt) then 
  begin
    ComposePositiveIntValue(json, 'doseNumberPositiveInt', TFhirPositiveInt(elem.doseNumber), false);
    ComposePositiveIntProps(json, 'doseNumberPositiveInt', TFhirPositiveInt(elem.doseNumber), false);
  end
  else if (elem.doseNumber is TFhirString) then 
  begin
    ComposeStringValue(json, 'doseNumberString', TFhirString(elem.doseNumber), false);
    ComposeStringProps(json, 'doseNumberString', TFhirString(elem.doseNumber), false);
  end;
  if (SummaryOption in [soFull, soData]) and (elem.seriesDoses is TFhirPositiveInt) then 
  begin
    ComposePositiveIntValue(json, 'seriesDosesPositiveInt', TFhirPositiveInt(elem.seriesDoses), false);
    ComposePositiveIntProps(json, 'seriesDosesPositiveInt', TFhirPositiveInt(elem.seriesDoses), false);
  end
  else if (SummaryOption in [soFull, soData]) and (elem.seriesDoses is TFhirString) then 
  begin
    ComposeStringValue(json, 'seriesDosesString', TFhirString(elem.seriesDoses), false);
    ComposeStringProps(json, 'seriesDosesString', TFhirString(elem.seriesDoses), false);
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseImmunization(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImmunization(jsn)); {2}
end;

function TFHIRJsonParser.ParseImmunization(jsn : TJsonObject) : TFhirImmunization;
begin
  result := TFhirImmunization.create;
  try
    ParseImmunizationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseImmunizationProperties(jsn : TJsonObject; result : TFhirImmunization);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirImmunizationStatusEnum, SYSTEMS_TFhirImmunizationStatusEnum);
    if jsn.has('statusReason') then
        result.statusReason := ParseCodeableConcept(jsn.vObj['statusReason']);{q3}
    if jsn.has('vaccineCode') then
        result.vaccineCode := ParseCodeableConcept(jsn.vObj['vaccineCode']);{q3}
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q3}
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q3}
    if jsn.has('occurrenceDateTime') or jsn.has('_occurrenceDateTime') then
      result.occurrence := parseDateTime(jsn.node['occurrenceDateTime'], jsn.vObj['_occurrenceDateTime']);
    if jsn.has('occurrenceString') or jsn.has('_occurrenceString') then
      result.occurrence := parseString(jsn.node['occurrenceString'], jsn.vObj['_occurrenceString']);
    if jsn.has('recorded') or jsn.has('_recorded') then
        result.recordedElement := parseDateTime(jsn.node['recorded'], jsn.vObj['_recorded']);{q}
    if jsn.has('primarySource') or jsn.has('_primarySource') then
        result.primarySourceElement := parseBoolean(jsn.node['primarySource'], jsn.vObj['_primarySource']);{q}
    if jsn.has('reportOrigin') then
        result.reportOrigin := ParseCodeableConcept(jsn.vObj['reportOrigin']);{q3}
    if jsn.has('location') then
        result.location := ParseReference{TFhirLocation}(jsn.vObj['location']);{q3}
    if jsn.has('manufacturer') then
        result.manufacturer := ParseReference{TFhirOrganization}(jsn.vObj['manufacturer']);{q3}
    if jsn.has('lotNumber') or jsn.has('_lotNumber') then
        result.lotNumberElement := parseString(jsn.node['lotNumber'], jsn.vObj['_lotNumber']);{q}
    if jsn.has('expirationDate') or jsn.has('_expirationDate') then
        result.expirationDateElement := parseDate(jsn.node['expirationDate'], jsn.vObj['_expirationDate']);{q}
    if jsn.has('site') then
        result.site := ParseCodeableConcept(jsn.vObj['site']);{q3}
    if jsn.has('route') then
        result.route := ParseCodeableConcept(jsn.vObj['route']);{q3}
    if jsn.has('doseQuantity') then
        result.doseQuantity := ParseQuantity(jsn.vObj['doseQuantity']);{q3}
    if jsn.has('performer') then
      iterateArray(jsn.vArr['performer'], result.performerList, parseImmunizationPerformer);
    if jsn.has('note') then
      iterateArray(jsn.vArr['note'], result.noteList, parseAnnotation);
    if jsn.has('reasonCode') then
      iterateArray(jsn.vArr['reasonCode'], result.reasonCodeList, parseCodeableConcept);
    if jsn.has('reasonReference') then
      iterateArray(jsn.vArr['reasonReference'], result.reasonReferenceList, parseReference{TFhirCondition});
    if jsn.has('isSubpotent') or jsn.has('_isSubpotent') then
        result.isSubpotentElement := parseBoolean(jsn.node['isSubpotent'], jsn.vObj['_isSubpotent']);{q}
    if jsn.has('subpotentReason') then
      iterateArray(jsn.vArr['subpotentReason'], result.subpotentReasonList, parseCodeableConcept);
    if jsn.has('education') then
      iterateArray(jsn.vArr['education'], result.educationList, parseImmunizationEducation);
    if jsn.has('programEligibility') then
      iterateArray(jsn.vArr['programEligibility'], result.programEligibilityList, parseCodeableConcept);
    if jsn.has('fundingSource') then
        result.fundingSource := ParseCodeableConcept(jsn.vObj['fundingSource']);{q3}
    if jsn.has('reaction') then
      iterateArray(jsn.vArr['reaction'], result.reactionList, parseImmunizationReaction);
    if jsn.has('protocolApplied') then
      iterateArray(jsn.vArr['protocolApplied'], result.protocolAppliedList, parseImmunizationProtocolApplied);
end;

procedure TFHIRJsonComposer.ComposeImmunization(json : TJSONWriter; name : string; elem : TFhirImmunization; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirImmunizationStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirImmunizationStatusEnum, false);
  if (SummaryOption in [soFull, soData]) and doCompose('statusReason') then
    ComposeCodeableConcept(json, 'statusReason', elem.statusReason); {a}
  ComposeCodeableConcept(json, 'vaccineCode', elem.vaccineCode); {a}
  ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if (elem.occurrence is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'occurrenceDateTime', TFhirDateTime(elem.occurrence), false);
    ComposeDateTimeProps(json, 'occurrenceDateTime', TFhirDateTime(elem.occurrence), false);
  end
  else if (elem.occurrence is TFhirString) then 
  begin
    ComposeStringValue(json, 'occurrenceString', TFhirString(elem.occurrence), false);
    ComposeStringProps(json, 'occurrenceString', TFhirString(elem.occurrence), false);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('recorded') then
    ComposeDateTimeValue(json, 'recorded', elem.recordedElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('recorded') then
    ComposeDateTimeProps(json, 'recorded', elem.recordedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('primarySource') then
    ComposeBooleanValue(json, 'primarySource', elem.primarySourceElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('primarySource') then
    ComposeBooleanProps(json, 'primarySource', elem.primarySourceElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('reportOrigin') then
    ComposeCodeableConcept(json, 'reportOrigin', elem.reportOrigin); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('location') then
    ComposeReference{TFhirLocation}(json, 'location', elem.location); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('manufacturer') then
    ComposeReference{TFhirOrganization}(json, 'manufacturer', elem.manufacturer); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('lotNumber') then
    ComposeStringValue(json, 'lotNumber', elem.lotNumberElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('lotNumber') then
    ComposeStringProps(json, 'lotNumber', elem.lotNumberElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('expirationDate') then
    ComposeDateValue(json, 'expirationDate', elem.expirationDateElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('expirationDate') then
    ComposeDateProps(json, 'expirationDate', elem.expirationDateElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('site') then
    ComposeCodeableConcept(json, 'site', elem.site); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('route') then
    ComposeCodeableConcept(json, 'route', elem.route); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('doseQuantity') then
    ComposeQuantity(json, 'doseQuantity', elem.doseQuantity); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('performer') and (elem.performerList.Count > 0) then
  begin
    json.valueArray('performer');
    for i := 0 to elem.performerList.Count - 1 do
      ComposeImmunizationPerformer(json, '', elem.performerList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('note') and (elem.noteList.Count > 0) then
  begin
    json.valueArray('note');
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(json, '', elem.noteList[i]); {z - Annotation}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('reasonCode') and (elem.reasonCodeList.Count > 0) then
  begin
    json.valueArray('reasonCode');
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.reasonCodeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('reasonReference') and (elem.reasonReferenceList.Count > 0) then
  begin
    json.valueArray('reasonReference');
    for i := 0 to elem.reasonReferenceList.Count - 1 do
      ComposeReference{TFhirCondition}(json, '', elem.reasonReferenceList[i]); {z - Reference(Condition)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('isSubpotent') then
    ComposeBooleanValue(json, 'isSubpotent', elem.isSubpotentElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('isSubpotent') then
    ComposeBooleanProps(json, 'isSubpotent', elem.isSubpotentElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('subpotentReason') and (elem.subpotentReasonList.Count > 0) then
  begin
    json.valueArray('subpotentReason');
    for i := 0 to elem.subpotentReasonList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.subpotentReasonList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('education') and (elem.educationList.Count > 0) then
  begin
    json.valueArray('education');
    for i := 0 to elem.educationList.Count - 1 do
      ComposeImmunizationEducation(json, '', elem.educationList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('programEligibility') and (elem.programEligibilityList.Count > 0) then
  begin
    json.valueArray('programEligibility');
    for i := 0 to elem.programEligibilityList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.programEligibilityList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('fundingSource') then
    ComposeCodeableConcept(json, 'fundingSource', elem.fundingSource); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('reaction') and (elem.reactionList.Count > 0) then
  begin
    json.valueArray('reaction');
    for i := 0 to elem.reactionList.Count - 1 do
      ComposeImmunizationReaction(json, '', elem.reactionList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('protocolApplied') and (elem.protocolAppliedList.Count > 0) then
  begin
    json.valueArray('protocolApplied');
    for i := 0 to elem.protocolAppliedList.Count - 1 do
      ComposeImmunizationProtocolApplied(json, '', elem.protocolAppliedList[i]); {z - }
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_IMMUNIZATION}
{$IFDEF FHIR_IMMUNIZATIONEVALUATION}
procedure TFHIRJsonParser.ParseImmunizationEvaluation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImmunizationEvaluation(jsn)); {2}
end;

function TFHIRJsonParser.ParseImmunizationEvaluation(jsn : TJsonObject) : TFhirImmunizationEvaluation;
begin
  result := TFhirImmunizationEvaluation.create;
  try
    ParseImmunizationEvaluationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseImmunizationEvaluationProperties(jsn : TJsonObject; result : TFhirImmunizationEvaluation);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirImmunizationEvaluationStatusEnum, SYSTEMS_TFhirImmunizationEvaluationStatusEnum);
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q3}
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := parseDateTime(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('authority') then
        result.authority := ParseReference{TFhirOrganization}(jsn.vObj['authority']);{q3}
    if jsn.has('targetDisease') then
        result.targetDisease := ParseCodeableConcept(jsn.vObj['targetDisease']);{q3}
    if jsn.has('immunizationEvent') then
        result.immunizationEvent := ParseReference{TFhirImmunization}(jsn.vObj['immunizationEvent']);{q3}
    if jsn.has('doseStatus') then
        result.doseStatus := ParseCodeableConcept(jsn.vObj['doseStatus']);{q3}
    if jsn.has('doseStatusReason') then
      iterateArray(jsn.vArr['doseStatusReason'], result.doseStatusReasonList, parseCodeableConcept);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('series') or jsn.has('_series') then
        result.seriesElement := parseString(jsn.node['series'], jsn.vObj['_series']);{q}
    if jsn.has('doseNumberPositiveInt') or jsn.has('_doseNumberPositiveInt') then
      result.doseNumber := parsePositiveInt(jsn.node['doseNumberPositiveInt'], jsn.vObj['_doseNumberPositiveInt']);
    if jsn.has('doseNumberString') or jsn.has('_doseNumberString') then
      result.doseNumber := parseString(jsn.node['doseNumberString'], jsn.vObj['_doseNumberString']);
    if jsn.has('seriesDosesPositiveInt') or jsn.has('_seriesDosesPositiveInt') then
      result.seriesDoses := parsePositiveInt(jsn.node['seriesDosesPositiveInt'], jsn.vObj['_seriesDosesPositiveInt']);
    if jsn.has('seriesDosesString') or jsn.has('_seriesDosesString') then
      result.seriesDoses := parseString(jsn.node['seriesDosesString'], jsn.vObj['_seriesDosesString']);
end;

procedure TFHIRJsonComposer.ComposeImmunizationEvaluation(json : TJSONWriter; name : string; elem : TFhirImmunizationEvaluation; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirImmunizationEvaluationStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirImmunizationEvaluationStatusEnum, false);
  ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('date') then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('date') then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('authority') then
    ComposeReference{TFhirOrganization}(json, 'authority', elem.authority); {a}
  ComposeCodeableConcept(json, 'targetDisease', elem.targetDisease); {a}
  ComposeReference{TFhirImmunization}(json, 'immunizationEvent', elem.immunizationEvent); {a}
  ComposeCodeableConcept(json, 'doseStatus', elem.doseStatus); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('doseStatusReason') and (elem.doseStatusReasonList.Count > 0) then
  begin
    json.valueArray('doseStatusReason');
    for i := 0 to elem.doseStatusReasonList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.doseStatusReasonList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('series') then
    ComposeStringValue(json, 'series', elem.seriesElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('series') then
    ComposeStringProps(json, 'series', elem.seriesElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.doseNumber is TFhirPositiveInt) then 
  begin
    ComposePositiveIntValue(json, 'doseNumberPositiveInt', TFhirPositiveInt(elem.doseNumber), false);
    ComposePositiveIntProps(json, 'doseNumberPositiveInt', TFhirPositiveInt(elem.doseNumber), false);
  end
  else if (SummaryOption in [soFull, soData]) and (elem.doseNumber is TFhirString) then 
  begin
    ComposeStringValue(json, 'doseNumberString', TFhirString(elem.doseNumber), false);
    ComposeStringProps(json, 'doseNumberString', TFhirString(elem.doseNumber), false);
  end;
  if (SummaryOption in [soFull, soData]) and (elem.seriesDoses is TFhirPositiveInt) then 
  begin
    ComposePositiveIntValue(json, 'seriesDosesPositiveInt', TFhirPositiveInt(elem.seriesDoses), false);
    ComposePositiveIntProps(json, 'seriesDosesPositiveInt', TFhirPositiveInt(elem.seriesDoses), false);
  end
  else if (SummaryOption in [soFull, soData]) and (elem.seriesDoses is TFhirString) then 
  begin
    ComposeStringValue(json, 'seriesDosesString', TFhirString(elem.seriesDoses), false);
    ComposeStringProps(json, 'seriesDosesString', TFhirString(elem.seriesDoses), false);
  end;
end;

{$ENDIF FHIR_IMMUNIZATIONEVALUATION}
{$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
procedure TFHIRJsonParser.ParseImmunizationRecommendationRecommendation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImmunizationRecommendationRecommendation(jsn)); {2}
end;

function TFHIRJsonParser.ParseImmunizationRecommendationRecommendation(jsn : TJsonObject) : TFhirImmunizationRecommendationRecommendation;
begin
  result := TFhirImmunizationRecommendationRecommendation.create;
  try
    ParseImmunizationRecommendationRecommendationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseImmunizationRecommendationRecommendationProperties(jsn : TJsonObject; result : TFhirImmunizationRecommendationRecommendation);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('vaccineCode') then
      iterateArray(jsn.vArr['vaccineCode'], result.vaccineCodeList, parseCodeableConcept);
    if jsn.has('targetDisease') then
        result.targetDisease := ParseCodeableConcept(jsn.vObj['targetDisease']);{q3}
    if jsn.has('contraindicatedVaccineCode') then
      iterateArray(jsn.vArr['contraindicatedVaccineCode'], result.contraindicatedVaccineCodeList, parseCodeableConcept);
    if jsn.has('forecastStatus') then
        result.forecastStatus := ParseCodeableConcept(jsn.vObj['forecastStatus']);{q3}
    if jsn.has('forecastReason') then
      iterateArray(jsn.vArr['forecastReason'], result.forecastReasonList, parseCodeableConcept);
    if jsn.has('dateCriterion') then
      iterateArray(jsn.vArr['dateCriterion'], result.dateCriterionList, parseImmunizationRecommendationRecommendationDateCriterion);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('series') or jsn.has('_series') then
        result.seriesElement := parseString(jsn.node['series'], jsn.vObj['_series']);{q}
    if jsn.has('doseNumberPositiveInt') or jsn.has('_doseNumberPositiveInt') then
      result.doseNumber := parsePositiveInt(jsn.node['doseNumberPositiveInt'], jsn.vObj['_doseNumberPositiveInt']);
    if jsn.has('doseNumberString') or jsn.has('_doseNumberString') then
      result.doseNumber := parseString(jsn.node['doseNumberString'], jsn.vObj['_doseNumberString']);
    if jsn.has('seriesDosesPositiveInt') or jsn.has('_seriesDosesPositiveInt') then
      result.seriesDoses := parsePositiveInt(jsn.node['seriesDosesPositiveInt'], jsn.vObj['_seriesDosesPositiveInt']);
    if jsn.has('seriesDosesString') or jsn.has('_seriesDosesString') then
      result.seriesDoses := parseString(jsn.node['seriesDosesString'], jsn.vObj['_seriesDosesString']);
    if jsn.has('supportingImmunization') then
      iterateArray(jsn.vArr['supportingImmunization'], result.supportingImmunizationList, parseReference{TFhirImmunization});
    if jsn.has('supportingPatientInformation') then
      iterateArray(jsn.vArr['supportingPatientInformation'], result.supportingPatientInformationList, parseReference{TFhirReference});
end;

procedure TFHIRJsonComposer.ComposeImmunizationRecommendationRecommendation(json : TJSONWriter; name : string; elem : TFhirImmunizationRecommendationRecommendation; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.vaccineCodeList.Count > 0) then
  begin
    json.valueArray('vaccineCode');
    for i := 0 to elem.vaccineCodeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.vaccineCodeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'targetDisease', elem.targetDisease); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.contraindicatedVaccineCodeList.Count > 0) then
  begin
    json.valueArray('contraindicatedVaccineCode');
    for i := 0 to elem.contraindicatedVaccineCodeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.contraindicatedVaccineCodeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  ComposeCodeableConcept(json, 'forecastStatus', elem.forecastStatus); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.forecastReasonList.Count > 0) then
  begin
    json.valueArray('forecastReason');
    for i := 0 to elem.forecastReasonList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.forecastReasonList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.dateCriterionList.Count > 0) then
  begin
    json.valueArray('dateCriterion');
    for i := 0 to elem.dateCriterionList.Count - 1 do
      ComposeImmunizationRecommendationRecommendationDateCriterion(json, '', elem.dateCriterionList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'series', elem.seriesElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'series', elem.seriesElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.doseNumber is TFhirPositiveInt) then 
  begin
    ComposePositiveIntValue(json, 'doseNumberPositiveInt', TFhirPositiveInt(elem.doseNumber), false);
    ComposePositiveIntProps(json, 'doseNumberPositiveInt', TFhirPositiveInt(elem.doseNumber), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.doseNumber is TFhirString) then 
  begin
    ComposeStringValue(json, 'doseNumberString', TFhirString(elem.doseNumber), false);
    ComposeStringProps(json, 'doseNumberString', TFhirString(elem.doseNumber), false);
  end;
  if (SummaryOption in [soFull, soData]) and (elem.seriesDoses is TFhirPositiveInt) then 
  begin
    ComposePositiveIntValue(json, 'seriesDosesPositiveInt', TFhirPositiveInt(elem.seriesDoses), false);
    ComposePositiveIntProps(json, 'seriesDosesPositiveInt', TFhirPositiveInt(elem.seriesDoses), false);
  end
  else if (SummaryOption in [soFull, soData]) and (elem.seriesDoses is TFhirString) then 
  begin
    ComposeStringValue(json, 'seriesDosesString', TFhirString(elem.seriesDoses), false);
    ComposeStringProps(json, 'seriesDosesString', TFhirString(elem.seriesDoses), false);
  end;
  if (SummaryOption in [soFull, soData]) and (elem.supportingImmunizationList.Count > 0) then
  begin
    json.valueArray('supportingImmunization');
    for i := 0 to elem.supportingImmunizationList.Count - 1 do
      ComposeReference{TFhirImmunization}(json, '', elem.supportingImmunizationList[i]); {z - Reference(Immunization)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.supportingPatientInformationList.Count > 0) then
  begin
    json.valueArray('supportingPatientInformation');
    for i := 0 to elem.supportingPatientInformationList.Count - 1 do
      ComposeReference{TFhirReference}(json, '', elem.supportingPatientInformationList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseImmunizationRecommendationRecommendationDateCriterion(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImmunizationRecommendationRecommendationDateCriterion(jsn)); {2}
end;

function TFHIRJsonParser.ParseImmunizationRecommendationRecommendationDateCriterion(jsn : TJsonObject) : TFhirImmunizationRecommendationRecommendationDateCriterion;
begin
  result := TFhirImmunizationRecommendationRecommendationDateCriterion.create;
  try
    ParseImmunizationRecommendationRecommendationDateCriterionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseImmunizationRecommendationRecommendationDateCriterionProperties(jsn : TJsonObject; result : TFhirImmunizationRecommendationRecommendationDateCriterion);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('value') or jsn.has('_value') then
        result.valueElement := parseDateTime(jsn.node['value'], jsn.vObj['_value']);{q}
end;

procedure TFHIRJsonComposer.ComposeImmunizationRecommendationRecommendationDateCriterion(json : TJSONWriter; name : string; elem : TFhirImmunizationRecommendationRecommendationDateCriterion; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  ComposeDateTimeValue(json, 'value', elem.valueElement, false);
  ComposeDateTimeProps(json, 'value', elem.valueElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseImmunizationRecommendation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImmunizationRecommendation(jsn)); {2}
end;

function TFHIRJsonParser.ParseImmunizationRecommendation(jsn : TJsonObject) : TFhirImmunizationRecommendation;
begin
  result := TFhirImmunizationRecommendation.create;
  try
    ParseImmunizationRecommendationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseImmunizationRecommendationProperties(jsn : TJsonObject; result : TFhirImmunizationRecommendation);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q3}
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := parseDateTime(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('authority') then
        result.authority := ParseReference{TFhirOrganization}(jsn.vObj['authority']);{q3}
    if jsn.has('recommendation') then
      iterateArray(jsn.vArr['recommendation'], result.recommendationList, parseImmunizationRecommendationRecommendation);
end;

procedure TFHIRJsonComposer.ComposeImmunizationRecommendation(json : TJSONWriter; name : string; elem : TFhirImmunizationRecommendation; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('authority') then
    ComposeReference{TFhirOrganization}(json, 'authority', elem.authority); {a}
  if (elem.recommendationList.Count > 0) then
  begin
    json.valueArray('recommendation');
    for i := 0 to elem.recommendationList.Count - 1 do
      ComposeImmunizationRecommendationRecommendation(json, '', elem.recommendationList[i]); {z - }
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_IMMUNIZATIONRECOMMENDATION}
{$IFDEF FHIR_IMPLEMENTATIONGUIDE}
procedure TFHIRJsonParser.ParseImplementationGuideDependsOn(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImplementationGuideDependsOn(jsn)); {2}
end;

function TFHIRJsonParser.ParseImplementationGuideDependsOn(jsn : TJsonObject) : TFhirImplementationGuideDependsOn;
begin
  result := TFhirImplementationGuideDependsOn.create;
  try
    ParseImplementationGuideDependsOnProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseImplementationGuideDependsOnProperties(jsn : TJsonObject; result : TFhirImplementationGuideDependsOn);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('uri') or jsn.has('_uri') then
        result.uriElement := parseCanonical(jsn.node['uri'], jsn.vObj['_uri']);{q}
    if jsn.has('packageId') or jsn.has('_packageId') then
        result.packageIdElement := parseId(jsn.node['packageId'], jsn.vObj['_packageId']);{q}
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := parseString(jsn.node['version'], jsn.vObj['_version']);{q}
end;

procedure TFHIRJsonComposer.ComposeImplementationGuideDependsOn(json : TJSONWriter; name : string; elem : TFhirImplementationGuideDependsOn; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCanonicalValue(json, 'uri', elem.uriElement, false);
  ComposeCanonicalProps(json, 'uri', elem.uriElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdValue(json, 'packageId', elem.packageIdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdProps(json, 'packageId', elem.packageIdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'version', elem.versionElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseImplementationGuideGlobal(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImplementationGuideGlobal(jsn)); {2}
end;

function TFHIRJsonParser.ParseImplementationGuideGlobal(jsn : TJsonObject) : TFhirImplementationGuideGlobal;
begin
  result := TFhirImplementationGuideGlobal.create;
  try
    ParseImplementationGuideGlobalProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseImplementationGuideGlobalProperties(jsn : TJsonObject; result : TFhirImplementationGuideGlobal);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn.node['type'], jsn.vObj['_type'], CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum);
    if jsn.has('profile') or jsn.has('_profile') then
        result.profileElement := parseCanonical(jsn.node['profile'], jsn.vObj['_profile']);{q}
end;

procedure TFHIRJsonComposer.ComposeImplementationGuideGlobal(json : TJSONWriter; name : string; elem : TFhirImplementationGuideGlobal; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirResourceTypesEnum, false);
  ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirResourceTypesEnum, false);
  ComposeCanonicalValue(json, 'profile', elem.profileElement, false);
  ComposeCanonicalProps(json, 'profile', elem.profileElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseImplementationGuideDefinition(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImplementationGuideDefinition(jsn)); {2}
end;

function TFHIRJsonParser.ParseImplementationGuideDefinition(jsn : TJsonObject) : TFhirImplementationGuideDefinition;
begin
  result := TFhirImplementationGuideDefinition.create;
  try
    ParseImplementationGuideDefinitionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseImplementationGuideDefinitionProperties(jsn : TJsonObject; result : TFhirImplementationGuideDefinition);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('grouping') then
      iterateArray(jsn.vArr['grouping'], result.groupingList, parseImplementationGuideDefinitionGrouping);
    if jsn.has('resource') then
      iterateArray(jsn.vArr['resource'], result.resourceList, parseImplementationGuideDefinitionResource);
    if jsn.has('page') then
        result.page := ParseImplementationGuideDefinitionPage(jsn.vObj['page']);{q3}
    if jsn.has('parameter') then
      iterateArray(jsn.vArr['parameter'], result.parameterList, parseImplementationGuideDefinitionParameter);
    if jsn.has('template') then
      iterateArray(jsn.vArr['template'], result.templateList, parseImplementationGuideDefinitionTemplate);
end;

procedure TFHIRJsonComposer.ComposeImplementationGuideDefinition(json : TJSONWriter; name : string; elem : TFhirImplementationGuideDefinition; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and (elem.groupingList.Count > 0) then
  begin
    json.valueArray('grouping');
    for i := 0 to elem.groupingList.Count - 1 do
      ComposeImplementationGuideDefinitionGrouping(json, '', elem.groupingList[i]); {z - }
    json.FinishArray;
  end;
  if (elem.resourceList.Count > 0) then
  begin
    json.valueArray('resource');
    for i := 0 to elem.resourceList.Count - 1 do
      ComposeImplementationGuideDefinitionResource(json, '', elem.resourceList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeImplementationGuideDefinitionPage(json, 'page', elem.page); {a}
  if (SummaryOption in [soFull, soData]) and (elem.parameterList.Count > 0) then
  begin
    json.valueArray('parameter');
    for i := 0 to elem.parameterList.Count - 1 do
      ComposeImplementationGuideDefinitionParameter(json, '', elem.parameterList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.templateList.Count > 0) then
  begin
    json.valueArray('template');
    for i := 0 to elem.templateList.Count - 1 do
      ComposeImplementationGuideDefinitionTemplate(json, '', elem.templateList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseImplementationGuideDefinitionGrouping(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImplementationGuideDefinitionGrouping(jsn)); {2}
end;

function TFHIRJsonParser.ParseImplementationGuideDefinitionGrouping(jsn : TJsonObject) : TFhirImplementationGuideDefinitionGrouping;
begin
  result := TFhirImplementationGuideDefinitionGrouping.create;
  try
    ParseImplementationGuideDefinitionGroupingProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseImplementationGuideDefinitionGroupingProperties(jsn : TJsonObject; result : TFhirImplementationGuideDefinitionGrouping);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseString(jsn.node['description'], jsn.vObj['_description']);{q}
end;

procedure TFHIRJsonComposer.ComposeImplementationGuideDefinitionGrouping(json : TJSONWriter; name : string; elem : TFhirImplementationGuideDefinitionGrouping; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'name', elem.nameElement, false);
  ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseImplementationGuideDefinitionResource(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImplementationGuideDefinitionResource(jsn)); {2}
end;

function TFHIRJsonParser.ParseImplementationGuideDefinitionResource(jsn : TJsonObject) : TFhirImplementationGuideDefinitionResource;
begin
  result := TFhirImplementationGuideDefinitionResource.create;
  try
    ParseImplementationGuideDefinitionResourceProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseImplementationGuideDefinitionResourceProperties(jsn : TJsonObject; result : TFhirImplementationGuideDefinitionResource);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('reference') then
        result.reference := ParseReference{TFhirReference}(jsn.vObj['reference']);{q3}
    if jsn.has('fhirVersion') or jsn.has('_fhirVersion') then
      iterateEnumArray(jsn.vArr['fhirVersion'], jsn.vArr['_fhirVersion'], jsn.path+'/fhirVersion', result.fhirVersionList, parseEnum, CODES_TFhirFHIRVersionEnum, SYSTEMS_TFhirFHIRVersionEnum);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('exampleCanonical') or jsn.has('_exampleCanonical') then
      result.example := parseCanonical(jsn.node['exampleCanonical'], jsn.vObj['_exampleCanonical']);
    if jsn.has('exampleBoolean') or jsn.has('_exampleBoolean') then
      result.example := parseBoolean(jsn.node['exampleBoolean'], jsn.vObj['_exampleBoolean']);
    if jsn.has('groupingId') or jsn.has('_groupingId') then
        result.groupingIdElement := parseId(jsn.node['groupingId'], jsn.vObj['_groupingId']);{q}
end;

procedure TFHIRJsonComposer.ComposeImplementationGuideDefinitionResource(json : TJSONWriter; name : string; elem : TFhirImplementationGuideDefinitionResource; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeReference{TFhirReference}(json, 'reference', elem.reference); {a}
  if (SummaryOption in [soFull, soData]) and (elem.fhirVersionList.Count > 0) then
  begin
    val := false;
    ext := false;
    for i := 0 to elem.fhirVersionList.Count - 1 do
    begin
      val := val or (elem.fhirVersionList[i].hasPrimitiveValue);
      ext := ext or ((elem.fhirVersionList[i].id <> '') or (elem.fhirVersionList[i].hasExtensionList));
    end;
    if val then
    begin
      json.valueArray('fhirVersion');
      for i := 0 to elem.fhirVersionList.Count - 1 do
        ComposeEnumValue(json, '', elem.fhirVersionList[i], CODES_TFhirFHIRVersionEnum, true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_fhirVersion');
      for i := 0 to elem.fhirVersionList.Count - 1 do
        ComposeEnumProps(json, '', elem.fhirVersionList[i], CODES_TFhirFHIRVersionEnum, true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.example is TFhirCanonical) then 
  begin
    ComposeCanonicalValue(json, 'exampleCanonical', TFhirCanonical(elem.example), false);
    ComposeCanonicalProps(json, 'exampleCanonical', TFhirCanonical(elem.example), false);
  end
  else if (SummaryOption in [soFull, soData]) and (elem.example is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'exampleBoolean', TFhirBoolean(elem.example), false);
    ComposeBooleanProps(json, 'exampleBoolean', TFhirBoolean(elem.example), false);
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeIdValue(json, 'groupingId', elem.groupingIdElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdProps(json, 'groupingId', elem.groupingIdElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseImplementationGuideDefinitionPage(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImplementationGuideDefinitionPage(jsn)); {2}
end;

function TFHIRJsonParser.ParseImplementationGuideDefinitionPage(jsn : TJsonObject) : TFhirImplementationGuideDefinitionPage;
begin
  result := TFhirImplementationGuideDefinitionPage.create;
  try
    ParseImplementationGuideDefinitionPageProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseImplementationGuideDefinitionPageProperties(jsn : TJsonObject; result : TFhirImplementationGuideDefinitionPage);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('nameUrl') or jsn.has('_nameUrl') then
      result.name := parseUrl(jsn.node['nameUrl'], jsn.vObj['_nameUrl']);
    if jsn.has('nameReference') {a3} then
      result.name := ParseReference(jsn.vObj['nameReference']);
    if jsn.has('title') or jsn.has('_title') then
        result.titleElement := parseString(jsn.node['title'], jsn.vObj['_title']);{q}
    if jsn.has('generation') or jsn.has('_generation')  then
      result.generationElement := parseEnum(jsn.path+'/generation', jsn.node['generation'], jsn.vObj['_generation'], CODES_TFhirGuidePageGenerationEnum, SYSTEMS_TFhirGuidePageGenerationEnum);
    if jsn.has('page') then
      iterateArray(jsn.vArr['page'], result.pageList, parseImplementationGuideDefinitionPage);
end;

procedure TFHIRJsonComposer.ComposeImplementationGuideDefinitionPage(json : TJSONWriter; name : string; elem : TFhirImplementationGuideDefinitionPage; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (elem.name is TFhirUrl) then 
  begin
    ComposeUrlValue(json, 'nameUrl', TFhirUrl(elem.name), false);
    ComposeUrlProps(json, 'nameUrl', TFhirUrl(elem.name), false);
  end
  else if (elem.name is TFhirReference) then
    ComposeReference(json, 'nameReference', TFhirReference(elem.name));
  ComposeStringValue(json, 'title', elem.titleElement, false);
  ComposeStringProps(json, 'title', elem.titleElement, false);
  ComposeEnumValue(json, 'generation', elem.GenerationElement, CODES_TFhirGuidePageGenerationEnum, false);
  ComposeEnumProps(json, 'generation', elem.GenerationElement, CODES_TFhirGuidePageGenerationEnum, false);
  if (SummaryOption in [soFull, soData]) and (elem.pageList.Count > 0) then
  begin
    json.valueArray('page');
    for i := 0 to elem.pageList.Count - 1 do
      ComposeImplementationGuideDefinitionPage(json, '', elem.pageList[i]); {z - @ImplementationGuide.definition.page}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseImplementationGuideDefinitionParameter(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImplementationGuideDefinitionParameter(jsn)); {2}
end;

function TFHIRJsonParser.ParseImplementationGuideDefinitionParameter(jsn : TJsonObject) : TFhirImplementationGuideDefinitionParameter;
begin
  result := TFhirImplementationGuideDefinitionParameter.create;
  try
    ParseImplementationGuideDefinitionParameterProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseImplementationGuideDefinitionParameterProperties(jsn : TJsonObject; result : TFhirImplementationGuideDefinitionParameter);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') or jsn.has('_code')  then
      result.codeElement := parseEnum(jsn.path+'/code', jsn.node['code'], jsn.vObj['_code'], CODES_TFhirGuideParameterCodeEnum, SYSTEMS_TFhirGuideParameterCodeEnum);
    if jsn.has('value') or jsn.has('_value') then
        result.valueElement := parseString(jsn.node['value'], jsn.vObj['_value']);{q}
end;

procedure TFHIRJsonComposer.ComposeImplementationGuideDefinitionParameter(json : TJSONWriter; name : string; elem : TFhirImplementationGuideDefinitionParameter; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'code', elem.CodeElement, CODES_TFhirGuideParameterCodeEnum, false);
  ComposeEnumProps(json, 'code', elem.CodeElement, CODES_TFhirGuideParameterCodeEnum, false);
  ComposeStringValue(json, 'value', elem.valueElement, false);
  ComposeStringProps(json, 'value', elem.valueElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseImplementationGuideDefinitionTemplate(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImplementationGuideDefinitionTemplate(jsn)); {2}
end;

function TFHIRJsonParser.ParseImplementationGuideDefinitionTemplate(jsn : TJsonObject) : TFhirImplementationGuideDefinitionTemplate;
begin
  result := TFhirImplementationGuideDefinitionTemplate.create;
  try
    ParseImplementationGuideDefinitionTemplateProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseImplementationGuideDefinitionTemplateProperties(jsn : TJsonObject; result : TFhirImplementationGuideDefinitionTemplate);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') or jsn.has('_code') then
        result.codeElement := parseCode(jsn.node['code'], jsn.vObj['_code']);{q}
    if jsn.has('source') or jsn.has('_source') then
        result.sourceElement := parseString(jsn.node['source'], jsn.vObj['_source']);{q}
    if jsn.has('scope') or jsn.has('_scope') then
        result.scopeElement := parseString(jsn.node['scope'], jsn.vObj['_scope']);{q}
end;

procedure TFHIRJsonComposer.ComposeImplementationGuideDefinitionTemplate(json : TJSONWriter; name : string; elem : TFhirImplementationGuideDefinitionTemplate; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeValue(json, 'code', elem.codeElement, false);
  ComposeCodeProps(json, 'code', elem.codeElement, false);
  ComposeStringValue(json, 'source', elem.sourceElement, false);
  ComposeStringProps(json, 'source', elem.sourceElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'scope', elem.scopeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'scope', elem.scopeElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseImplementationGuideManifest(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImplementationGuideManifest(jsn)); {2}
end;

function TFHIRJsonParser.ParseImplementationGuideManifest(jsn : TJsonObject) : TFhirImplementationGuideManifest;
begin
  result := TFhirImplementationGuideManifest.create;
  try
    ParseImplementationGuideManifestProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseImplementationGuideManifestProperties(jsn : TJsonObject; result : TFhirImplementationGuideManifest);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('rendering') or jsn.has('_rendering') then
        result.renderingElement := parseUrl(jsn.node['rendering'], jsn.vObj['_rendering']);{q}
    if jsn.has('resource') then
      iterateArray(jsn.vArr['resource'], result.resourceList, parseImplementationGuideManifestResource);
    if jsn.has('page') then
      iterateArray(jsn.vArr['page'], result.pageList, parseImplementationGuideManifestPage);
      if jsn.has('image') or jsn.has('_image') then
      iteratePrimitiveArray(jsn.vArr['image'], jsn.vArr['_image'], result.imageList, parseString);
      if jsn.has('other') or jsn.has('_other') then
      iteratePrimitiveArray(jsn.vArr['other'], jsn.vArr['_other'], result.otherList, parseString);
end;

procedure TFHIRJsonComposer.ComposeImplementationGuideManifest(json : TJSONWriter; name : string; elem : TFhirImplementationGuideManifest; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUrlValue(json, 'rendering', elem.renderingElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUrlProps(json, 'rendering', elem.renderingElement, false);
  if (elem.resourceList.Count > 0) then
  begin
    json.valueArray('resource');
    for i := 0 to elem.resourceList.Count - 1 do
      ComposeImplementationGuideManifestResource(json, '', elem.resourceList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.pageList.Count > 0) then
  begin
    json.valueArray('page');
    for i := 0 to elem.pageList.Count - 1 do
      ComposeImplementationGuideManifestPage(json, '', elem.pageList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.imageList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.imageList.Count - 1 do
    begin
      ext := ext or ((elem.imageList[i].id <> '') or (elem.imageList[i].hasExtensionList) {no-comments or (elem.imageList[i].hasComments)});
      val := val or (elem.imageList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('image');
      for i := 0 to elem.imageList.Count - 1 do
        ComposeStringValue(json, '',elem.imageList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_image');
      for i := 0 to elem.imageList.Count - 1 do
        ComposeStringProps(json, '',elem.imageList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.otherList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.otherList.Count - 1 do
    begin
      ext := ext or ((elem.otherList[i].id <> '') or (elem.otherList[i].hasExtensionList) {no-comments or (elem.otherList[i].hasComments)});
      val := val or (elem.otherList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('other');
      for i := 0 to elem.otherList.Count - 1 do
        ComposeStringValue(json, '',elem.otherList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_other');
      for i := 0 to elem.otherList.Count - 1 do
        ComposeStringProps(json, '',elem.otherList[i], true);
      json.FinishArray;
    end;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseImplementationGuideManifestResource(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImplementationGuideManifestResource(jsn)); {2}
end;

function TFHIRJsonParser.ParseImplementationGuideManifestResource(jsn : TJsonObject) : TFhirImplementationGuideManifestResource;
begin
  result := TFhirImplementationGuideManifestResource.create;
  try
    ParseImplementationGuideManifestResourceProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseImplementationGuideManifestResourceProperties(jsn : TJsonObject; result : TFhirImplementationGuideManifestResource);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('reference') then
        result.reference := ParseReference{TFhirReference}(jsn.vObj['reference']);{q3}
    if jsn.has('exampleCanonical') or jsn.has('_exampleCanonical') then
      result.example := parseCanonical(jsn.node['exampleCanonical'], jsn.vObj['_exampleCanonical']);
    if jsn.has('exampleBoolean') or jsn.has('_exampleBoolean') then
      result.example := parseBoolean(jsn.node['exampleBoolean'], jsn.vObj['_exampleBoolean']);
    if jsn.has('relativePath') or jsn.has('_relativePath') then
        result.relativePathElement := parseUrl(jsn.node['relativePath'], jsn.vObj['_relativePath']);{q}
end;

procedure TFHIRJsonComposer.ComposeImplementationGuideManifestResource(json : TJSONWriter; name : string; elem : TFhirImplementationGuideManifestResource; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeReference{TFhirReference}(json, 'reference', elem.reference); {a}
  if (SummaryOption in [soFull, soData]) and (elem.example is TFhirCanonical) then 
  begin
    ComposeCanonicalValue(json, 'exampleCanonical', TFhirCanonical(elem.example), false);
    ComposeCanonicalProps(json, 'exampleCanonical', TFhirCanonical(elem.example), false);
  end
  else if (SummaryOption in [soFull, soData]) and (elem.example is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'exampleBoolean', TFhirBoolean(elem.example), false);
    ComposeBooleanProps(json, 'exampleBoolean', TFhirBoolean(elem.example), false);
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeUrlValue(json, 'relativePath', elem.relativePathElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeUrlProps(json, 'relativePath', elem.relativePathElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseImplementationGuideManifestPage(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImplementationGuideManifestPage(jsn)); {2}
end;

function TFHIRJsonParser.ParseImplementationGuideManifestPage(jsn : TJsonObject) : TFhirImplementationGuideManifestPage;
begin
  result := TFhirImplementationGuideManifestPage.create;
  try
    ParseImplementationGuideManifestPageProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseImplementationGuideManifestPageProperties(jsn : TJsonObject; result : TFhirImplementationGuideManifestPage);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('title') or jsn.has('_title') then
        result.titleElement := parseString(jsn.node['title'], jsn.vObj['_title']);{q}
      if jsn.has('anchor') or jsn.has('_anchor') then
      iteratePrimitiveArray(jsn.vArr['anchor'], jsn.vArr['_anchor'], result.anchorList, parseString);
end;

procedure TFHIRJsonComposer.ComposeImplementationGuideManifestPage(json : TJSONWriter; name : string; elem : TFhirImplementationGuideManifestPage; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'name', elem.nameElement, false);
  ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.anchorList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.anchorList.Count - 1 do
    begin
      ext := ext or ((elem.anchorList[i].id <> '') or (elem.anchorList[i].hasExtensionList) {no-comments or (elem.anchorList[i].hasComments)});
      val := val or (elem.anchorList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('anchor');
      for i := 0 to elem.anchorList.Count - 1 do
        ComposeStringValue(json, '',elem.anchorList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_anchor');
      for i := 0 to elem.anchorList.Count - 1 do
        ComposeStringProps(json, '',elem.anchorList[i], true);
      json.FinishArray;
    end;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseImplementationGuide(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImplementationGuide(jsn)); {2}
end;

function TFHIRJsonParser.ParseImplementationGuide(jsn : TJsonObject) : TFhirImplementationGuide;
begin
  result := TFhirImplementationGuide.create;
  try
    ParseImplementationGuideProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseImplementationGuideProperties(jsn : TJsonObject; result : TFhirImplementationGuide);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := parseUri(jsn.node['url'], jsn.vObj['_url']);{q}
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := parseString(jsn.node['version'], jsn.vObj['_version']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('title') or jsn.has('_title') then
        result.titleElement := parseString(jsn.node['title'], jsn.vObj['_title']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    if jsn.has('experimental') or jsn.has('_experimental') then
        result.experimentalElement := parseBoolean(jsn.node['experimental'], jsn.vObj['_experimental']);{q}
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := parseDateTime(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('publisher') or jsn.has('_publisher') then
        result.publisherElement := parseString(jsn.node['publisher'], jsn.vObj['_publisher']);{q}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseContactDetail);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseMarkdown(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('useContext') then
      iterateArray(jsn.vArr['useContext'], result.useContextList, parseUsageContext);
    if jsn.has('jurisdiction') then
      iterateArray(jsn.vArr['jurisdiction'], result.jurisdictionList, parseCodeableConcept);
    if jsn.has('copyright') or jsn.has('_copyright') then
        result.copyrightElement := parseMarkdown(jsn.node['copyright'], jsn.vObj['_copyright']);{q}
    if jsn.has('packageId') or jsn.has('_packageId') then
        result.packageIdElement := parseId(jsn.node['packageId'], jsn.vObj['_packageId']);{q}
    if jsn.has('license') or jsn.has('_license')  then
      result.licenseElement := parseEnum(jsn.path+'/license', jsn.node['license'], jsn.vObj['_license'], CODES_TFhirSpdxLicenseEnum, SYSTEMS_TFhirSpdxLicenseEnum);
    if jsn.has('fhirVersion') or jsn.has('_fhirVersion') then
      iterateEnumArray(jsn.vArr['fhirVersion'], jsn.vArr['_fhirVersion'], jsn.path+'/fhirVersion', result.fhirVersionList, parseEnum, CODES_TFhirFHIRVersionEnum, SYSTEMS_TFhirFHIRVersionEnum);
    if jsn.has('dependsOn') then
      iterateArray(jsn.vArr['dependsOn'], result.dependsOnList, parseImplementationGuideDependsOn);
    if jsn.has('global') then
      iterateArray(jsn.vArr['global'], result.globalList, parseImplementationGuideGlobal);
    if jsn.has('definition') then
        result.definition := ParseImplementationGuideDefinition(jsn.vObj['definition']);{q3}
    if jsn.has('manifest') then
        result.manifest := ParseImplementationGuideManifest(jsn.vObj['manifest']);{q3}
end;

procedure TFHIRJsonComposer.ComposeImplementationGuide(json : TJSONWriter; name : string; elem : TFhirImplementationGuide; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  ComposeUriValue(json, 'url', elem.urlElement, false);
  ComposeUriProps(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeStringValue(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeStringProps(json, 'version', elem.versionElement, false);
  ComposeStringValue(json, 'name', elem.nameElement, false);
  ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeStringValue(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeStringProps(json, 'title', elem.titleElement, false);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBooleanValue(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBooleanProps(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringValue(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringProps(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') and (elem.contactList.Count > 0) then
  begin
    json.valueArray('contact');
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(json, '', elem.contactList[i]); {z - ContactDetail}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdownValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdownProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') and (elem.useContextList.Count > 0) then
  begin
    json.valueArray('useContext');
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(json, '', elem.useContextList[i]); {z - UsageContext}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') and (elem.jurisdictionList.Count > 0) then
  begin
    json.valueArray('jurisdiction');
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.jurisdictionList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdownValue(json, 'copyright', elem.copyrightElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdownProps(json, 'copyright', elem.copyrightElement, false);
    ComposeIdValue(json, 'packageId', elem.packageIdElement, false);
    ComposeIdProps(json, 'packageId', elem.packageIdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('license') then
    ComposeEnumValue(json, 'license', elem.LicenseElement, CODES_TFhirSpdxLicenseEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('license') then
    ComposeEnumProps(json, 'license', elem.LicenseElement, CODES_TFhirSpdxLicenseEnum, false);
  if (elem.fhirVersionList.Count > 0) then
  begin
    val := false;
    ext := false;
    for i := 0 to elem.fhirVersionList.Count - 1 do
    begin
      val := val or (elem.fhirVersionList[i].hasPrimitiveValue);
      ext := ext or ((elem.fhirVersionList[i].id <> '') or (elem.fhirVersionList[i].hasExtensionList));
    end;
    if val then
    begin
      json.valueArray('fhirVersion');
      for i := 0 to elem.fhirVersionList.Count - 1 do
        ComposeEnumValue(json, '', elem.fhirVersionList[i], CODES_TFhirFHIRVersionEnum, true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_fhirVersion');
      for i := 0 to elem.fhirVersionList.Count - 1 do
        ComposeEnumProps(json, '', elem.fhirVersionList[i], CODES_TFhirFHIRVersionEnum, true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dependsOn') and (elem.dependsOnList.Count > 0) then
  begin
    json.valueArray('dependsOn');
    for i := 0 to elem.dependsOnList.Count - 1 do
      ComposeImplementationGuideDependsOn(json, '', elem.dependsOnList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('global') and (elem.globalList.Count > 0) then
  begin
    json.valueArray('global');
    for i := 0 to elem.globalList.Count - 1 do
      ComposeImplementationGuideGlobal(json, '', elem.globalList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('definition') then
    ComposeImplementationGuideDefinition(json, 'definition', elem.definition); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('manifest') then
    ComposeImplementationGuideManifest(json, 'manifest', elem.manifest); {a}
end;

{$ENDIF FHIR_IMPLEMENTATIONGUIDE}
{$IFDEF FHIR_INSURANCEPLAN}
procedure TFHIRJsonParser.ParseInsurancePlanContact(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseInsurancePlanContact(jsn)); {2}
end;

function TFHIRJsonParser.ParseInsurancePlanContact(jsn : TJsonObject) : TFhirInsurancePlanContact;
begin
  result := TFhirInsurancePlanContact.create;
  try
    ParseInsurancePlanContactProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseInsurancePlanContactProperties(jsn : TJsonObject; result : TFhirInsurancePlanContact);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('purpose') then
        result.purpose := ParseCodeableConcept(jsn.vObj['purpose']);{q3}
    if jsn.has('name') then
        result.name := ParseHumanName(jsn.vObj['name']);{q3}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    if jsn.has('address') then
        result.address := ParseAddress(jsn.vObj['address']);{q3}
end;

procedure TFHIRJsonComposer.ComposeInsurancePlanContact(json : TJSONWriter; name : string; elem : TFhirInsurancePlanContact; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'purpose', elem.purpose); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeHumanName(json, 'name', elem.name); {a}
  if (SummaryOption in [soFull, soData]) and (elem.telecomList.Count > 0) then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '', elem.telecomList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeAddress(json, 'address', elem.address); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseInsurancePlanCoverage(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseInsurancePlanCoverage(jsn)); {2}
end;

function TFHIRJsonParser.ParseInsurancePlanCoverage(jsn : TJsonObject) : TFhirInsurancePlanCoverage;
begin
  result := TFhirInsurancePlanCoverage.create;
  try
    ParseInsurancePlanCoverageProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseInsurancePlanCoverageProperties(jsn : TJsonObject; result : TFhirInsurancePlanCoverage);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('network') then
      iterateArray(jsn.vArr['network'], result.networkList, parseReference{TFhirOrganization});
    if jsn.has('benefit') then
      iterateArray(jsn.vArr['benefit'], result.benefitList, parseInsurancePlanCoverageBenefit);
end;

procedure TFHIRJsonComposer.ComposeInsurancePlanCoverage(json : TJSONWriter; name : string; elem : TFhirInsurancePlanCoverage; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) and (elem.networkList.Count > 0) then
  begin
    json.valueArray('network');
    for i := 0 to elem.networkList.Count - 1 do
      ComposeReference{TFhirOrganization}(json, '', elem.networkList[i]); {z - Reference(Organization)}
    json.FinishArray;
  end;
  if (elem.benefitList.Count > 0) then
  begin
    json.valueArray('benefit');
    for i := 0 to elem.benefitList.Count - 1 do
      ComposeInsurancePlanCoverageBenefit(json, '', elem.benefitList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseInsurancePlanCoverageBenefit(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseInsurancePlanCoverageBenefit(jsn)); {2}
end;

function TFHIRJsonParser.ParseInsurancePlanCoverageBenefit(jsn : TJsonObject) : TFhirInsurancePlanCoverageBenefit;
begin
  result := TFhirInsurancePlanCoverageBenefit.create;
  try
    ParseInsurancePlanCoverageBenefitProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseInsurancePlanCoverageBenefitProperties(jsn : TJsonObject; result : TFhirInsurancePlanCoverageBenefit);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('requirement') or jsn.has('_requirement') then
        result.requirementElement := parseString(jsn.node['requirement'], jsn.vObj['_requirement']);{q}
    if jsn.has('limit') then
      iterateArray(jsn.vArr['limit'], result.limitList, parseInsurancePlanCoverageBenefitLimit);
end;

procedure TFHIRJsonComposer.ComposeInsurancePlanCoverageBenefit(json : TJSONWriter; name : string; elem : TFhirInsurancePlanCoverageBenefit; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'requirement', elem.requirementElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'requirement', elem.requirementElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.limitList.Count > 0) then
  begin
    json.valueArray('limit');
    for i := 0 to elem.limitList.Count - 1 do
      ComposeInsurancePlanCoverageBenefitLimit(json, '', elem.limitList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseInsurancePlanCoverageBenefitLimit(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseInsurancePlanCoverageBenefitLimit(jsn)); {2}
end;

function TFHIRJsonParser.ParseInsurancePlanCoverageBenefitLimit(jsn : TJsonObject) : TFhirInsurancePlanCoverageBenefitLimit;
begin
  result := TFhirInsurancePlanCoverageBenefitLimit.create;
  try
    ParseInsurancePlanCoverageBenefitLimitProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseInsurancePlanCoverageBenefitLimitProperties(jsn : TJsonObject; result : TFhirInsurancePlanCoverageBenefitLimit);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('value') then
        result.value := ParseQuantity(jsn.vObj['value']);{q3}
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
end;

procedure TFHIRJsonComposer.ComposeInsurancePlanCoverageBenefitLimit(json : TJSONWriter; name : string; elem : TFhirInsurancePlanCoverageBenefitLimit; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'value', elem.value); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'code', elem.code); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseInsurancePlanPlan(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseInsurancePlanPlan(jsn)); {2}
end;

function TFHIRJsonParser.ParseInsurancePlanPlan(jsn : TJsonObject) : TFhirInsurancePlanPlan;
begin
  result := TFhirInsurancePlanPlan.create;
  try
    ParseInsurancePlanPlanProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseInsurancePlanPlanProperties(jsn : TJsonObject; result : TFhirInsurancePlanPlan);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('coverageArea') then
      iterateArray(jsn.vArr['coverageArea'], result.coverageAreaList, parseReference{TFhirLocation});
    if jsn.has('network') then
      iterateArray(jsn.vArr['network'], result.networkList, parseReference{TFhirOrganization});
    if jsn.has('generalCost') then
      iterateArray(jsn.vArr['generalCost'], result.generalCostList, parseInsurancePlanPlanGeneralCost);
    if jsn.has('specificCost') then
      iterateArray(jsn.vArr['specificCost'], result.specificCostList, parseInsurancePlanPlanSpecificCost);
end;

procedure TFHIRJsonComposer.ComposeInsurancePlanPlan(json : TJSONWriter; name : string; elem : TFhirInsurancePlanPlan; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.coverageAreaList.Count > 0) then
  begin
    json.valueArray('coverageArea');
    for i := 0 to elem.coverageAreaList.Count - 1 do
      ComposeReference{TFhirLocation}(json, '', elem.coverageAreaList[i]); {z - Reference(Location)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.networkList.Count > 0) then
  begin
    json.valueArray('network');
    for i := 0 to elem.networkList.Count - 1 do
      ComposeReference{TFhirOrganization}(json, '', elem.networkList[i]); {z - Reference(Organization)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.generalCostList.Count > 0) then
  begin
    json.valueArray('generalCost');
    for i := 0 to elem.generalCostList.Count - 1 do
      ComposeInsurancePlanPlanGeneralCost(json, '', elem.generalCostList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.specificCostList.Count > 0) then
  begin
    json.valueArray('specificCost');
    for i := 0 to elem.specificCostList.Count - 1 do
      ComposeInsurancePlanPlanSpecificCost(json, '', elem.specificCostList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseInsurancePlanPlanGeneralCost(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseInsurancePlanPlanGeneralCost(jsn)); {2}
end;

function TFHIRJsonParser.ParseInsurancePlanPlanGeneralCost(jsn : TJsonObject) : TFhirInsurancePlanPlanGeneralCost;
begin
  result := TFhirInsurancePlanPlanGeneralCost.create;
  try
    ParseInsurancePlanPlanGeneralCostProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseInsurancePlanPlanGeneralCostProperties(jsn : TJsonObject; result : TFhirInsurancePlanPlanGeneralCost);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('groupSize') or jsn.has('_groupSize') then
        result.groupSizeElement := parsePositiveInt(jsn.node['groupSize'], jsn.vObj['_groupSize']);{q}
    if jsn.has('cost') then
        result.cost := ParseMoney(jsn.vObj['cost']);{q3}
    if jsn.has('comment') or jsn.has('_comment') then
        result.commentElement := parseString(jsn.node['comment'], jsn.vObj['_comment']);{q}
end;

procedure TFHIRJsonComposer.ComposeInsurancePlanPlanGeneralCost(json : TJSONWriter; name : string; elem : TFhirInsurancePlanPlanGeneralCost; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveIntValue(json, 'groupSize', elem.groupSizeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveIntProps(json, 'groupSize', elem.groupSizeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(json, 'cost', elem.cost); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'comment', elem.commentElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'comment', elem.commentElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseInsurancePlanPlanSpecificCost(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseInsurancePlanPlanSpecificCost(jsn)); {2}
end;

function TFHIRJsonParser.ParseInsurancePlanPlanSpecificCost(jsn : TJsonObject) : TFhirInsurancePlanPlanSpecificCost;
begin
  result := TFhirInsurancePlanPlanSpecificCost.create;
  try
    ParseInsurancePlanPlanSpecificCostProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseInsurancePlanPlanSpecificCostProperties(jsn : TJsonObject; result : TFhirInsurancePlanPlanSpecificCost);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('category') then
        result.category := ParseCodeableConcept(jsn.vObj['category']);{q3}
    if jsn.has('benefit') then
      iterateArray(jsn.vArr['benefit'], result.benefitList, parseInsurancePlanPlanSpecificCostBenefit);
end;

procedure TFHIRJsonComposer.ComposeInsurancePlanPlanSpecificCost(json : TJSONWriter; name : string; elem : TFhirInsurancePlanPlanSpecificCost; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'category', elem.category); {a}
  if (SummaryOption in [soFull, soData]) and (elem.benefitList.Count > 0) then
  begin
    json.valueArray('benefit');
    for i := 0 to elem.benefitList.Count - 1 do
      ComposeInsurancePlanPlanSpecificCostBenefit(json, '', elem.benefitList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseInsurancePlanPlanSpecificCostBenefit(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseInsurancePlanPlanSpecificCostBenefit(jsn)); {2}
end;

function TFHIRJsonParser.ParseInsurancePlanPlanSpecificCostBenefit(jsn : TJsonObject) : TFhirInsurancePlanPlanSpecificCostBenefit;
begin
  result := TFhirInsurancePlanPlanSpecificCostBenefit.create;
  try
    ParseInsurancePlanPlanSpecificCostBenefitProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseInsurancePlanPlanSpecificCostBenefitProperties(jsn : TJsonObject; result : TFhirInsurancePlanPlanSpecificCostBenefit);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('cost') then
      iterateArray(jsn.vArr['cost'], result.costList, parseInsurancePlanPlanSpecificCostBenefitCost);
end;

procedure TFHIRJsonComposer.ComposeInsurancePlanPlanSpecificCostBenefit(json : TJSONWriter; name : string; elem : TFhirInsurancePlanPlanSpecificCostBenefit; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) and (elem.costList.Count > 0) then
  begin
    json.valueArray('cost');
    for i := 0 to elem.costList.Count - 1 do
      ComposeInsurancePlanPlanSpecificCostBenefitCost(json, '', elem.costList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseInsurancePlanPlanSpecificCostBenefitCost(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseInsurancePlanPlanSpecificCostBenefitCost(jsn)); {2}
end;

function TFHIRJsonParser.ParseInsurancePlanPlanSpecificCostBenefitCost(jsn : TJsonObject) : TFhirInsurancePlanPlanSpecificCostBenefitCost;
begin
  result := TFhirInsurancePlanPlanSpecificCostBenefitCost.create;
  try
    ParseInsurancePlanPlanSpecificCostBenefitCostProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseInsurancePlanPlanSpecificCostBenefitCostProperties(jsn : TJsonObject; result : TFhirInsurancePlanPlanSpecificCostBenefitCost);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('applicability') then
        result.applicability := ParseCodeableConcept(jsn.vObj['applicability']);{q3}
    if jsn.has('qualifiers') then
      iterateArray(jsn.vArr['qualifiers'], result.qualifiersList, parseCodeableConcept);
    if jsn.has('value') then
        result.value := ParseQuantity(jsn.vObj['value']);{q3}
end;

procedure TFHIRJsonComposer.ComposeInsurancePlanPlanSpecificCostBenefitCost(json : TJSONWriter; name : string; elem : TFhirInsurancePlanPlanSpecificCostBenefitCost; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'applicability', elem.applicability); {a}
  if (SummaryOption in [soFull, soData]) and (elem.qualifiersList.Count > 0) then
  begin
    json.valueArray('qualifiers');
    for i := 0 to elem.qualifiersList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.qualifiersList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'value', elem.value); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseInsurancePlan(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseInsurancePlan(jsn)); {2}
end;

function TFHIRJsonParser.ParseInsurancePlan(jsn : TJsonObject) : TFhirInsurancePlan;
begin
  result := TFhirInsurancePlan.create;
  try
    ParseInsurancePlanProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseInsurancePlanProperties(jsn : TJsonObject; result : TFhirInsurancePlan);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    if jsn.has('type') then
      iterateArray(jsn.vArr['type'], result.type_List, parseCodeableConcept);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
      if jsn.has('alias') or jsn.has('_alias') then
      iteratePrimitiveArray(jsn.vArr['alias'], jsn.vArr['_alias'], result.aliasList, parseString);
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q3}
    if jsn.has('ownedBy') then
        result.ownedBy := ParseReference{TFhirOrganization}(jsn.vObj['ownedBy']);{q3}
    if jsn.has('administeredBy') then
        result.administeredBy := ParseReference{TFhirOrganization}(jsn.vObj['administeredBy']);{q3}
    if jsn.has('coverageArea') then
      iterateArray(jsn.vArr['coverageArea'], result.coverageAreaList, parseReference{TFhirLocation});
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseInsurancePlanContact);
    if jsn.has('endpoint') then
      iterateArray(jsn.vArr['endpoint'], result.endpointList, parseReference{TFhirEndpoint});
    if jsn.has('network') then
      iterateArray(jsn.vArr['network'], result.networkList, parseReference{TFhirOrganization});
    if jsn.has('coverage') then
      iterateArray(jsn.vArr['coverage'], result.coverageList, parseInsurancePlanCoverage);
    if jsn.has('plan') then
      iterateArray(jsn.vArr['plan'], result.planList, parseInsurancePlanPlan);
end;

procedure TFHIRJsonComposer.ComposeInsurancePlan(json : TJSONWriter; name : string; elem : TFhirInsurancePlan; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') and (elem.type_List.Count > 0) then
  begin
    json.valueArray('type');
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(json, '', elem.type_List[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('alias') and (elem.aliasList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.aliasList.Count - 1 do
    begin
      ext := ext or ((elem.aliasList[i].id <> '') or (elem.aliasList[i].hasExtensionList) {no-comments or (elem.aliasList[i].hasComments)});
      val := val or (elem.aliasList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('alias');
      for i := 0 to elem.aliasList.Count - 1 do
        ComposeStringValue(json, '',elem.aliasList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_alias');
      for i := 0 to elem.aliasList.Count - 1 do
        ComposeStringProps(json, '',elem.aliasList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('period') then
    ComposePeriod(json, 'period', elem.period); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('ownedBy') then
    ComposeReference{TFhirOrganization}(json, 'ownedBy', elem.ownedBy); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('administeredBy') then
    ComposeReference{TFhirOrganization}(json, 'administeredBy', elem.administeredBy); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('coverageArea') and (elem.coverageAreaList.Count > 0) then
  begin
    json.valueArray('coverageArea');
    for i := 0 to elem.coverageAreaList.Count - 1 do
      ComposeReference{TFhirLocation}(json, '', elem.coverageAreaList[i]); {z - Reference(Location)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('contact') and (elem.contactList.Count > 0) then
  begin
    json.valueArray('contact');
    for i := 0 to elem.contactList.Count - 1 do
      ComposeInsurancePlanContact(json, '', elem.contactList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('endpoint') and (elem.endpointList.Count > 0) then
  begin
    json.valueArray('endpoint');
    for i := 0 to elem.endpointList.Count - 1 do
      ComposeReference{TFhirEndpoint}(json, '', elem.endpointList[i]); {z - Reference(Endpoint)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('network') and (elem.networkList.Count > 0) then
  begin
    json.valueArray('network');
    for i := 0 to elem.networkList.Count - 1 do
      ComposeReference{TFhirOrganization}(json, '', elem.networkList[i]); {z - Reference(Organization)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('coverage') and (elem.coverageList.Count > 0) then
  begin
    json.valueArray('coverage');
    for i := 0 to elem.coverageList.Count - 1 do
      ComposeInsurancePlanCoverage(json, '', elem.coverageList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('plan') and (elem.planList.Count > 0) then
  begin
    json.valueArray('plan');
    for i := 0 to elem.planList.Count - 1 do
      ComposeInsurancePlanPlan(json, '', elem.planList[i]); {z - }
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_INSURANCEPLAN}
{$IFDEF FHIR_INVOICE}
procedure TFHIRJsonParser.ParseInvoiceParticipant(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseInvoiceParticipant(jsn)); {2}
end;

function TFHIRJsonParser.ParseInvoiceParticipant(jsn : TJsonObject) : TFhirInvoiceParticipant;
begin
  result := TFhirInvoiceParticipant.create;
  try
    ParseInvoiceParticipantProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseInvoiceParticipantProperties(jsn : TJsonObject; result : TFhirInvoiceParticipant);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('role') then
        result.role := ParseCodeableConcept(jsn.vObj['role']);{q3}
    if jsn.has('actor') then
        result.actor := ParseReference{TFhirPractitioner}(jsn.vObj['actor']);{q3}
end;

procedure TFHIRJsonComposer.ComposeInvoiceParticipant(json : TJSONWriter; name : string; elem : TFhirInvoiceParticipant; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'role', elem.role); {a}
  ComposeReference{TFhirPractitioner}(json, 'actor', elem.actor); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseInvoiceLineItem(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseInvoiceLineItem(jsn)); {2}
end;

function TFHIRJsonParser.ParseInvoiceLineItem(jsn : TJsonObject) : TFhirInvoiceLineItem;
begin
  result := TFhirInvoiceLineItem.create;
  try
    ParseInvoiceLineItemProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseInvoiceLineItemProperties(jsn : TJsonObject; result : TFhirInvoiceLineItem);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('sequence') or jsn.has('_sequence') then
        result.sequenceElement := parsePositiveInt(jsn.node['sequence'], jsn.vObj['_sequence']);{q}
    if jsn.has('chargeItemReference') {a3} then
      result.chargeItem := ParseReference(jsn.vObj['chargeItemReference']);
    if jsn.has('chargeItemCodeableConcept') {a4} then
      result.chargeItem := ParseCodeableConcept(jsn.vObj['chargeItemCodeableConcept']);
    if jsn.has('priceComponent') then
      iterateArray(jsn.vArr['priceComponent'], result.priceComponentList, parseInvoiceLineItemPriceComponent);
end;

procedure TFHIRJsonComposer.ComposeInvoiceLineItem(json : TJSONWriter; name : string; elem : TFhirInvoiceLineItem; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveIntValue(json, 'sequence', elem.sequenceElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveIntProps(json, 'sequence', elem.sequenceElement, false);
  if (elem.chargeItem is TFhirReference) then
    ComposeReference(json, 'chargeItemReference', TFhirReference(elem.chargeItem))
  else if (elem.chargeItem is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'chargeItemCodeableConcept', TFhirCodeableConcept(elem.chargeItem)) ;
  if (SummaryOption in [soFull, soData]) and (elem.priceComponentList.Count > 0) then
  begin
    json.valueArray('priceComponent');
    for i := 0 to elem.priceComponentList.Count - 1 do
      ComposeInvoiceLineItemPriceComponent(json, '', elem.priceComponentList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseInvoiceLineItemPriceComponent(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseInvoiceLineItemPriceComponent(jsn)); {2}
end;

function TFHIRJsonParser.ParseInvoiceLineItemPriceComponent(jsn : TJsonObject) : TFhirInvoiceLineItemPriceComponent;
begin
  result := TFhirInvoiceLineItemPriceComponent.create;
  try
    ParseInvoiceLineItemPriceComponentProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseInvoiceLineItemPriceComponentProperties(jsn : TJsonObject; result : TFhirInvoiceLineItemPriceComponent);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn.node['type'], jsn.vObj['_type'], CODES_TFhirInvoicePriceComponentTypeEnum, SYSTEMS_TFhirInvoicePriceComponentTypeEnum);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('factor') or jsn.has('_factor') then
        result.factorElement := parseDecimal(jsn.node['factor'], jsn.vObj['_factor']);{q}
    if jsn.has('amount') then
        result.amount := ParseMoney(jsn.vObj['amount']);{q3}
end;

procedure TFHIRJsonComposer.ComposeInvoiceLineItemPriceComponent(json : TJSONWriter; name : string; elem : TFhirInvoiceLineItemPriceComponent; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirInvoicePriceComponentTypeEnum, false);
  ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirInvoicePriceComponentTypeEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalValue(json, 'factor', elem.factorElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalProps(json, 'factor', elem.factorElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(json, 'amount', elem.amount); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseInvoice(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseInvoice(jsn)); {2}
end;

function TFHIRJsonParser.ParseInvoice(jsn : TJsonObject) : TFhirInvoice;
begin
  result := TFhirInvoice.create;
  try
    ParseInvoiceProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseInvoiceProperties(jsn : TJsonObject; result : TFhirInvoice);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirInvoiceStatusEnum, SYSTEMS_TFhirInvoiceStatusEnum);
    if jsn.has('cancelledReason') or jsn.has('_cancelledReason') then
        result.cancelledReasonElement := parseString(jsn.node['cancelledReason'], jsn.vObj['_cancelledReason']);{q}
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirPatient}(jsn.vObj['subject']);{q3}
    if jsn.has('recipient') then
        result.recipient := ParseReference{TFhirOrganization}(jsn.vObj['recipient']);{q3}
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := parseDateTime(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('participant') then
      iterateArray(jsn.vArr['participant'], result.participantList, parseInvoiceParticipant);
    if jsn.has('issuer') then
        result.issuer := ParseReference{TFhirOrganization}(jsn.vObj['issuer']);{q3}
    if jsn.has('account') then
        result.account := ParseReference{TFhirAccount}(jsn.vObj['account']);{q3}
    if jsn.has('lineItem') then
      iterateArray(jsn.vArr['lineItem'], result.lineItemList, parseInvoiceLineItem);
    if jsn.has('totalPriceComponent') then
      iterateArray(jsn.vArr['totalPriceComponent'], result.totalPriceComponentList, parseInvoiceLineItemPriceComponent);
    if jsn.has('totalNet') then
        result.totalNet := ParseMoney(jsn.vObj['totalNet']);{q3}
    if jsn.has('totalGross') then
        result.totalGross := ParseMoney(jsn.vObj['totalGross']);{q3}
    if jsn.has('paymentTerms') or jsn.has('_paymentTerms') then
        result.paymentTermsElement := parseMarkdown(jsn.node['paymentTerms'], jsn.vObj['_paymentTerms']);{q}
    if jsn.has('note') then
      iterateArray(jsn.vArr['note'], result.noteList, parseAnnotation);
end;

procedure TFHIRJsonComposer.ComposeInvoice(json : TJSONWriter; name : string; elem : TFhirInvoice; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirInvoiceStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirInvoiceStatusEnum, false);
  if (SummaryOption in [soFull, soData]) and doCompose('cancelledReason') then
    ComposeStringValue(json, 'cancelledReason', elem.cancelledReasonElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('cancelledReason') then
    ComposeStringProps(json, 'cancelledReason', elem.cancelledReasonElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{TFhirPatient}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('recipient') then
    ComposeReference{TFhirOrganization}(json, 'recipient', elem.recipient); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('participant') and (elem.participantList.Count > 0) then
  begin
    json.valueArray('participant');
    for i := 0 to elem.participantList.Count - 1 do
      ComposeInvoiceParticipant(json, '', elem.participantList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('issuer') then
    ComposeReference{TFhirOrganization}(json, 'issuer', elem.issuer); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('account') then
    ComposeReference{TFhirAccount}(json, 'account', elem.account); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('lineItem') and (elem.lineItemList.Count > 0) then
  begin
    json.valueArray('lineItem');
    for i := 0 to elem.lineItemList.Count - 1 do
      ComposeInvoiceLineItem(json, '', elem.lineItemList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('totalPriceComponent') and (elem.totalPriceComponentList.Count > 0) then
  begin
    json.valueArray('totalPriceComponent');
    for i := 0 to elem.totalPriceComponentList.Count - 1 do
      ComposeInvoiceLineItemPriceComponent(json, '', elem.totalPriceComponentList[i]); {z - @Invoice.lineItem.priceComponent}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('totalNet') then
    ComposeMoney(json, 'totalNet', elem.totalNet); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('totalGross') then
    ComposeMoney(json, 'totalGross', elem.totalGross); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('paymentTerms') then
    ComposeMarkdownValue(json, 'paymentTerms', elem.paymentTermsElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('paymentTerms') then
    ComposeMarkdownProps(json, 'paymentTerms', elem.paymentTermsElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('note') and (elem.noteList.Count > 0) then
  begin
    json.valueArray('note');
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(json, '', elem.noteList[i]); {z - Annotation}
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_INVOICE}
{$IFDEF FHIR_LIBRARY}
procedure TFHIRJsonParser.ParseLibrary(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseLibrary(jsn)); {2}
end;

function TFHIRJsonParser.ParseLibrary(jsn : TJsonObject) : TFhirLibrary;
begin
  result := TFhirLibrary.create;
  try
    ParseLibraryProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseLibraryProperties(jsn : TJsonObject; result : TFhirLibrary);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := parseUri(jsn.node['url'], jsn.vObj['_url']);{q}
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := parseString(jsn.node['version'], jsn.vObj['_version']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('title') or jsn.has('_title') then
        result.titleElement := parseString(jsn.node['title'], jsn.vObj['_title']);{q}
    if jsn.has('subtitle') or jsn.has('_subtitle') then
        result.subtitleElement := parseString(jsn.node['subtitle'], jsn.vObj['_subtitle']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    if jsn.has('experimental') or jsn.has('_experimental') then
        result.experimentalElement := parseBoolean(jsn.node['experimental'], jsn.vObj['_experimental']);{q}
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('subjectCodeableConcept') {a4} then
      result.subject := ParseCodeableConcept(jsn.vObj['subjectCodeableConcept']);
    if jsn.has('subjectReference') {a3} then
      result.subject := ParseReference(jsn.vObj['subjectReference']);
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := parseDateTime(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('publisher') or jsn.has('_publisher') then
        result.publisherElement := parseString(jsn.node['publisher'], jsn.vObj['_publisher']);{q}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseContactDetail);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseMarkdown(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('useContext') then
      iterateArray(jsn.vArr['useContext'], result.useContextList, parseUsageContext);
    if jsn.has('jurisdiction') then
      iterateArray(jsn.vArr['jurisdiction'], result.jurisdictionList, parseCodeableConcept);
    if jsn.has('purpose') or jsn.has('_purpose') then
        result.purposeElement := parseMarkdown(jsn.node['purpose'], jsn.vObj['_purpose']);{q}
    if jsn.has('usage') or jsn.has('_usage') then
        result.usageElement := parseString(jsn.node['usage'], jsn.vObj['_usage']);{q}
    if jsn.has('copyright') or jsn.has('_copyright') then
        result.copyrightElement := parseMarkdown(jsn.node['copyright'], jsn.vObj['_copyright']);{q}
    if jsn.has('approvalDate') or jsn.has('_approvalDate') then
        result.approvalDateElement := parseDate(jsn.node['approvalDate'], jsn.vObj['_approvalDate']);{q}
    if jsn.has('lastReviewDate') or jsn.has('_lastReviewDate') then
        result.lastReviewDateElement := parseDate(jsn.node['lastReviewDate'], jsn.vObj['_lastReviewDate']);{q}
    if jsn.has('effectivePeriod') then
        result.effectivePeriod := ParsePeriod(jsn.vObj['effectivePeriod']);{q3}
    if jsn.has('topic') then
      iterateArray(jsn.vArr['topic'], result.topicList, parseCodeableConcept);
    if jsn.has('author') then
      iterateArray(jsn.vArr['author'], result.authorList, parseContactDetail);
    if jsn.has('editor') then
      iterateArray(jsn.vArr['editor'], result.editorList, parseContactDetail);
    if jsn.has('reviewer') then
      iterateArray(jsn.vArr['reviewer'], result.reviewerList, parseContactDetail);
    if jsn.has('endorser') then
      iterateArray(jsn.vArr['endorser'], result.endorserList, parseContactDetail);
    if jsn.has('relatedArtifact') then
      iterateArray(jsn.vArr['relatedArtifact'], result.relatedArtifactList, parseRelatedArtifact);
    if jsn.has('parameter') then
      iterateArray(jsn.vArr['parameter'], result.parameterList, parseParameterDefinition);
    if jsn.has('dataRequirement') then
      iterateArray(jsn.vArr['dataRequirement'], result.dataRequirementList, parseDataRequirement);
    if jsn.has('content') then
      iterateArray(jsn.vArr['content'], result.contentList, parseAttachment);
end;

procedure TFHIRJsonComposer.ComposeLibrary(json : TJSONWriter; name : string; elem : TFhirLibrary; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUriValue(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUriProps(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeStringValue(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeStringProps(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeStringValue(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeStringProps(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('subtitle') then
    ComposeStringValue(json, 'subtitle', elem.subtitleElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('subtitle') then
    ComposeStringProps(json, 'subtitle', elem.subtitleElement, false);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBooleanValue(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBooleanProps(json, 'experimental', elem.experimentalElement, false);
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) and (elem.subject is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'subjectCodeableConcept', TFhirCodeableConcept(elem.subject)) 
  else if (SummaryOption in [soFull, soData]) and (elem.subject is TFhirReference) then
    ComposeReference(json, 'subjectReference', TFhirReference(elem.subject));
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringValue(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringProps(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') and (elem.contactList.Count > 0) then
  begin
    json.valueArray('contact');
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(json, '', elem.contactList[i]); {z - ContactDetail}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeMarkdownValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeMarkdownProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') and (elem.useContextList.Count > 0) then
  begin
    json.valueArray('useContext');
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(json, '', elem.useContextList[i]); {z - UsageContext}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') and (elem.jurisdictionList.Count > 0) then
  begin
    json.valueArray('jurisdiction');
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.jurisdictionList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdownValue(json, 'purpose', elem.purposeElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdownProps(json, 'purpose', elem.purposeElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('usage') then
    ComposeStringValue(json, 'usage', elem.usageElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('usage') then
    ComposeStringProps(json, 'usage', elem.usageElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdownValue(json, 'copyright', elem.copyrightElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdownProps(json, 'copyright', elem.copyrightElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('approvalDate') then
    ComposeDateValue(json, 'approvalDate', elem.approvalDateElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('approvalDate') then
    ComposeDateProps(json, 'approvalDate', elem.approvalDateElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('lastReviewDate') then
    ComposeDateValue(json, 'lastReviewDate', elem.lastReviewDateElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('lastReviewDate') then
    ComposeDateProps(json, 'lastReviewDate', elem.lastReviewDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('effectivePeriod') then
    ComposePeriod(json, 'effectivePeriod', elem.effectivePeriod); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('topic') and (elem.topicList.Count > 0) then
  begin
    json.valueArray('topic');
    for i := 0 to elem.topicList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.topicList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('author') and (elem.authorList.Count > 0) then
  begin
    json.valueArray('author');
    for i := 0 to elem.authorList.Count - 1 do
      ComposeContactDetail(json, '', elem.authorList[i]); {z - ContactDetail}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('editor') and (elem.editorList.Count > 0) then
  begin
    json.valueArray('editor');
    for i := 0 to elem.editorList.Count - 1 do
      ComposeContactDetail(json, '', elem.editorList[i]); {z - ContactDetail}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('reviewer') and (elem.reviewerList.Count > 0) then
  begin
    json.valueArray('reviewer');
    for i := 0 to elem.reviewerList.Count - 1 do
      ComposeContactDetail(json, '', elem.reviewerList[i]); {z - ContactDetail}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('endorser') and (elem.endorserList.Count > 0) then
  begin
    json.valueArray('endorser');
    for i := 0 to elem.endorserList.Count - 1 do
      ComposeContactDetail(json, '', elem.endorserList[i]); {z - ContactDetail}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('relatedArtifact') and (elem.relatedArtifactList.Count > 0) then
  begin
    json.valueArray('relatedArtifact');
    for i := 0 to elem.relatedArtifactList.Count - 1 do
      ComposeRelatedArtifact(json, '', elem.relatedArtifactList[i]); {z - RelatedArtifact}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('parameter') and (elem.parameterList.Count > 0) then
  begin
    json.valueArray('parameter');
    for i := 0 to elem.parameterList.Count - 1 do
      ComposeParameterDefinition(json, '', elem.parameterList[i]); {z - ParameterDefinition}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('dataRequirement') and (elem.dataRequirementList.Count > 0) then
  begin
    json.valueArray('dataRequirement');
    for i := 0 to elem.dataRequirementList.Count - 1 do
      ComposeDataRequirement(json, '', elem.dataRequirementList[i]); {z - DataRequirement}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('content') and (elem.contentList.Count > 0) then
  begin
    json.valueArray('content');
    for i := 0 to elem.contentList.Count - 1 do
      ComposeAttachment(json, '', elem.contentList[i]); {z - Attachment}
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_LIBRARY}
{$IFDEF FHIR_LINKAGE}
procedure TFHIRJsonParser.ParseLinkageItem(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseLinkageItem(jsn)); {2}
end;

function TFHIRJsonParser.ParseLinkageItem(jsn : TJsonObject) : TFhirLinkageItem;
begin
  result := TFhirLinkageItem.create;
  try
    ParseLinkageItemProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseLinkageItemProperties(jsn : TJsonObject; result : TFhirLinkageItem);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn.node['type'], jsn.vObj['_type'], CODES_TFhirLinkageTypeEnum, SYSTEMS_TFhirLinkageTypeEnum);
    if jsn.has('resource') then
        result.resource := ParseReference{TFhirReference}(jsn.vObj['resource']);{q3}
end;

procedure TFHIRJsonComposer.ComposeLinkageItem(json : TJSONWriter; name : string; elem : TFhirLinkageItem; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirLinkageTypeEnum, false);
  ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirLinkageTypeEnum, false);
  ComposeReference{TFhirReference}(json, 'resource', elem.resource); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseLinkage(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseLinkage(jsn)); {2}
end;

function TFHIRJsonParser.ParseLinkage(jsn : TJsonObject) : TFhirLinkage;
begin
  result := TFhirLinkage.create;
  try
    ParseLinkageProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseLinkageProperties(jsn : TJsonObject; result : TFhirLinkage);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('active') or jsn.has('_active') then
        result.activeElement := parseBoolean(jsn.node['active'], jsn.vObj['_active']);{q}
    if jsn.has('author') then
        result.author := ParseReference{TFhirPractitioner}(jsn.vObj['author']);{q3}
    if jsn.has('item') then
      iterateArray(jsn.vArr['item'], result.itemList, parseLinkageItem);
end;

procedure TFHIRJsonComposer.ComposeLinkage(json : TJSONWriter; name : string; elem : TFhirLinkage; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('active') then
    ComposeBooleanValue(json, 'active', elem.activeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('active') then
    ComposeBooleanProps(json, 'active', elem.activeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('author') then
    ComposeReference{TFhirPractitioner}(json, 'author', elem.author); {a}
  if (elem.itemList.Count > 0) then
  begin
    json.valueArray('item');
    for i := 0 to elem.itemList.Count - 1 do
      ComposeLinkageItem(json, '', elem.itemList[i]); {z - }
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_LINKAGE}
{$IFDEF FHIR_LIST}
procedure TFHIRJsonParser.ParseListEntry(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseListEntry(jsn)); {2}
end;

function TFHIRJsonParser.ParseListEntry(jsn : TJsonObject) : TFhirListEntry;
begin
  result := TFhirListEntry.create;
  try
    ParseListEntryProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseListEntryProperties(jsn : TJsonObject; result : TFhirListEntry);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('flag') then
        result.flag := ParseCodeableConcept(jsn.vObj['flag']);{q3}
    if jsn.has('deleted') or jsn.has('_deleted') then
        result.deletedElement := parseBoolean(jsn.node['deleted'], jsn.vObj['_deleted']);{q}
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := parseDateTime(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('item') then
        result.item := ParseReference{TFhirReference}(jsn.vObj['item']);{q3}
end;

procedure TFHIRJsonComposer.ComposeListEntry(json : TJSONWriter; name : string; elem : TFhirListEntry; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'flag', elem.flag); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'deleted', elem.deletedElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'deleted', elem.deletedElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  ComposeReference{TFhirReference}(json, 'item', elem.item); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseList(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseList(jsn)); {2}
end;

function TFHIRJsonParser.ParseList(jsn : TJsonObject) : TFhirList;
begin
  result := TFhirList.create;
  try
    ParseListProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseListProperties(jsn : TJsonObject; result : TFhirList);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirListStatusEnum, SYSTEMS_TFhirListStatusEnum);
    if jsn.has('mode') or jsn.has('_mode')  then
      result.modeElement := parseEnum(jsn.path+'/mode', jsn.node['mode'], jsn.vObj['_mode'], CODES_TFhirListModeEnum, SYSTEMS_TFhirListModeEnum);
    if jsn.has('title') or jsn.has('_title') then
        result.titleElement := parseString(jsn.node['title'], jsn.vObj['_title']);{q}
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirPatient}(jsn.vObj['subject']);{q3}
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q3}
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := parseDateTime(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('source') then
        result.source := ParseReference{TFhirPractitioner}(jsn.vObj['source']);{q3}
    if jsn.has('orderedBy') then
        result.orderedBy := ParseCodeableConcept(jsn.vObj['orderedBy']);{q3}
    if jsn.has('note') then
      iterateArray(jsn.vArr['note'], result.noteList, parseAnnotation);
    if jsn.has('entry') then
      iterateArray(jsn.vArr['entry'], result.entryList, parseListEntry);
    if jsn.has('emptyReason') then
        result.emptyReason := ParseCodeableConcept(jsn.vObj['emptyReason']);{q3}
end;

procedure TFHIRJsonComposer.ComposeList(json : TJSONWriter; name : string; elem : TFhirList; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirListStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirListStatusEnum, false);
  ComposeEnumValue(json, 'mode', elem.ModeElement, CODES_TFhirListModeEnum, false);
  ComposeEnumProps(json, 'mode', elem.ModeElement, CODES_TFhirListModeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeStringValue(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeStringProps(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') then
    ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{TFhirPatient}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('source') then
    ComposeReference{TFhirPractitioner}(json, 'source', elem.source); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('orderedBy') then
    ComposeCodeableConcept(json, 'orderedBy', elem.orderedBy); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('note') and (elem.noteList.Count > 0) then
  begin
    json.valueArray('note');
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(json, '', elem.noteList[i]); {z - Annotation}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('entry') and (elem.entryList.Count > 0) then
  begin
    json.valueArray('entry');
    for i := 0 to elem.entryList.Count - 1 do
      ComposeListEntry(json, '', elem.entryList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('emptyReason') then
    ComposeCodeableConcept(json, 'emptyReason', elem.emptyReason); {a}
end;

{$ENDIF FHIR_LIST}
{$IFDEF FHIR_LOCATION}
procedure TFHIRJsonParser.ParseLocationPosition(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseLocationPosition(jsn)); {2}
end;

function TFHIRJsonParser.ParseLocationPosition(jsn : TJsonObject) : TFhirLocationPosition;
begin
  result := TFhirLocationPosition.create;
  try
    ParseLocationPositionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseLocationPositionProperties(jsn : TJsonObject; result : TFhirLocationPosition);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('longitude') or jsn.has('_longitude') then
        result.longitudeElement := parseDecimal(jsn.node['longitude'], jsn.vObj['_longitude']);{q}
    if jsn.has('latitude') or jsn.has('_latitude') then
        result.latitudeElement := parseDecimal(jsn.node['latitude'], jsn.vObj['_latitude']);{q}
    if jsn.has('altitude') or jsn.has('_altitude') then
        result.altitudeElement := parseDecimal(jsn.node['altitude'], jsn.vObj['_altitude']);{q}
end;

procedure TFHIRJsonComposer.ComposeLocationPosition(json : TJSONWriter; name : string; elem : TFhirLocationPosition; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeDecimalValue(json, 'longitude', elem.longitudeElement, false);
  ComposeDecimalProps(json, 'longitude', elem.longitudeElement, false);
  ComposeDecimalValue(json, 'latitude', elem.latitudeElement, false);
  ComposeDecimalProps(json, 'latitude', elem.latitudeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalValue(json, 'altitude', elem.altitudeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalProps(json, 'altitude', elem.altitudeElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseLocationHoursOfOperation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseLocationHoursOfOperation(jsn)); {2}
end;

function TFHIRJsonParser.ParseLocationHoursOfOperation(jsn : TJsonObject) : TFhirLocationHoursOfOperation;
begin
  result := TFhirLocationHoursOfOperation.create;
  try
    ParseLocationHoursOfOperationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseLocationHoursOfOperationProperties(jsn : TJsonObject; result : TFhirLocationHoursOfOperation);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('daysOfWeek') or jsn.has('_daysOfWeek') then
      iterateEnumArray(jsn.vArr['daysOfWeek'], jsn.vArr['_daysOfWeek'], jsn.path+'/daysOfWeek', result.daysOfWeekList, parseEnum, CODES_TFhirDaysOfWeekEnum, SYSTEMS_TFhirDaysOfWeekEnum);
    if jsn.has('allDay') or jsn.has('_allDay') then
        result.allDayElement := parseBoolean(jsn.node['allDay'], jsn.vObj['_allDay']);{q}
    if jsn.has('openingTime') or jsn.has('_openingTime') then
        result.openingTimeElement := parseTime(jsn.node['openingTime'], jsn.vObj['_openingTime']);{q}
    if jsn.has('closingTime') or jsn.has('_closingTime') then
        result.closingTimeElement := parseTime(jsn.node['closingTime'], jsn.vObj['_closingTime']);{q}
end;

procedure TFHIRJsonComposer.ComposeLocationHoursOfOperation(json : TJSONWriter; name : string; elem : TFhirLocationHoursOfOperation; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and (elem.daysOfWeekList.Count > 0) then
  begin
    val := false;
    ext := false;
    for i := 0 to elem.daysOfWeekList.Count - 1 do
    begin
      val := val or (elem.daysOfWeekList[i].hasPrimitiveValue);
      ext := ext or ((elem.daysOfWeekList[i].id <> '') or (elem.daysOfWeekList[i].hasExtensionList));
    end;
    if val then
    begin
      json.valueArray('daysOfWeek');
      for i := 0 to elem.daysOfWeekList.Count - 1 do
        ComposeEnumValue(json, '', elem.daysOfWeekList[i], CODES_TFhirDaysOfWeekEnum, true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_daysOfWeek');
      for i := 0 to elem.daysOfWeekList.Count - 1 do
        ComposeEnumProps(json, '', elem.daysOfWeekList[i], CODES_TFhirDaysOfWeekEnum, true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'allDay', elem.allDayElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'allDay', elem.allDayElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeTimeValue(json, 'openingTime', elem.openingTimeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeTimeProps(json, 'openingTime', elem.openingTimeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeTimeValue(json, 'closingTime', elem.closingTimeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeTimeProps(json, 'closingTime', elem.closingTimeElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseLocation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseLocation(jsn)); {2}
end;

function TFHIRJsonParser.ParseLocation(jsn : TJsonObject) : TFhirLocation;
begin
  result := TFhirLocation.create;
  try
    ParseLocationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseLocationProperties(jsn : TJsonObject; result : TFhirLocation);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirLocationStatusEnum, SYSTEMS_TFhirLocationStatusEnum);
    if jsn.has('operationalStatus') then
        result.operationalStatus := ParseCoding(jsn.vObj['operationalStatus']);{q3}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
      if jsn.has('alias') or jsn.has('_alias') then
      iteratePrimitiveArray(jsn.vArr['alias'], jsn.vArr['_alias'], result.aliasList, parseString);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('mode') or jsn.has('_mode')  then
      result.modeElement := parseEnum(jsn.path+'/mode', jsn.node['mode'], jsn.vObj['_mode'], CODES_TFhirLocationModeEnum, SYSTEMS_TFhirLocationModeEnum);
    if jsn.has('type') then
      iterateArray(jsn.vArr['type'], result.type_List, parseCodeableConcept);
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    if jsn.has('address') then
        result.address := ParseAddress(jsn.vObj['address']);{q3}
    if jsn.has('physicalType') then
        result.physicalType := ParseCodeableConcept(jsn.vObj['physicalType']);{q3}
    if jsn.has('position') then
        result.position := ParseLocationPosition(jsn.vObj['position']);{q3}
    if jsn.has('managingOrganization') then
        result.managingOrganization := ParseReference{TFhirOrganization}(jsn.vObj['managingOrganization']);{q3}
    if jsn.has('partOf') then
        result.partOf := ParseReference{TFhirLocation}(jsn.vObj['partOf']);{q3}
    if jsn.has('hoursOfOperation') then
      iterateArray(jsn.vArr['hoursOfOperation'], result.hoursOfOperationList, parseLocationHoursOfOperation);
    if jsn.has('availabilityExceptions') or jsn.has('_availabilityExceptions') then
        result.availabilityExceptionsElement := parseString(jsn.node['availabilityExceptions'], jsn.vObj['_availabilityExceptions']);{q}
    if jsn.has('endpoint') then
      iterateArray(jsn.vArr['endpoint'], result.endpointList, parseReference{TFhirEndpoint});
end;

procedure TFHIRJsonComposer.ComposeLocation(json : TJSONWriter; name : string; elem : TFhirLocation; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirLocationStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirLocationStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('operationalStatus') then
    ComposeCoding(json, 'operationalStatus', elem.operationalStatus); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('alias') and (elem.aliasList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.aliasList.Count - 1 do
    begin
      ext := ext or ((elem.aliasList[i].id <> '') or (elem.aliasList[i].hasExtensionList) {no-comments or (elem.aliasList[i].hasComments)});
      val := val or (elem.aliasList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('alias');
      for i := 0 to elem.aliasList.Count - 1 do
        ComposeStringValue(json, '',elem.aliasList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_alias');
      for i := 0 to elem.aliasList.Count - 1 do
        ComposeStringProps(json, '',elem.aliasList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('mode') then
    ComposeEnumValue(json, 'mode', elem.ModeElement, CODES_TFhirLocationModeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('mode') then
    ComposeEnumProps(json, 'mode', elem.ModeElement, CODES_TFhirLocationModeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') and (elem.type_List.Count > 0) then
  begin
    json.valueArray('type');
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(json, '', elem.type_List[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('telecom') and (elem.telecomList.Count > 0) then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '', elem.telecomList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('address') then
    ComposeAddress(json, 'address', elem.address); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('physicalType') then
    ComposeCodeableConcept(json, 'physicalType', elem.physicalType); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('position') then
    ComposeLocationPosition(json, 'position', elem.position); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('managingOrganization') then
    ComposeReference{TFhirOrganization}(json, 'managingOrganization', elem.managingOrganization); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('partOf') then
    ComposeReference{TFhirLocation}(json, 'partOf', elem.partOf); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('hoursOfOperation') and (elem.hoursOfOperationList.Count > 0) then
  begin
    json.valueArray('hoursOfOperation');
    for i := 0 to elem.hoursOfOperationList.Count - 1 do
      ComposeLocationHoursOfOperation(json, '', elem.hoursOfOperationList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('availabilityExceptions') then
    ComposeStringValue(json, 'availabilityExceptions', elem.availabilityExceptionsElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('availabilityExceptions') then
    ComposeStringProps(json, 'availabilityExceptions', elem.availabilityExceptionsElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('endpoint') and (elem.endpointList.Count > 0) then
  begin
    json.valueArray('endpoint');
    for i := 0 to elem.endpointList.Count - 1 do
      ComposeReference{TFhirEndpoint}(json, '', elem.endpointList[i]); {z - Reference(Endpoint)}
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_LOCATION}
{$IFDEF FHIR_MEASURE}
procedure TFHIRJsonParser.ParseMeasureGroup(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMeasureGroup(jsn)); {2}
end;

function TFHIRJsonParser.ParseMeasureGroup(jsn : TJsonObject) : TFhirMeasureGroup;
begin
  result := TFhirMeasureGroup.create;
  try
    ParseMeasureGroupProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMeasureGroupProperties(jsn : TJsonObject; result : TFhirMeasureGroup);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('population') then
      iterateArray(jsn.vArr['population'], result.populationList, parseMeasureGroupPopulation);
    if jsn.has('stratifier') then
      iterateArray(jsn.vArr['stratifier'], result.stratifierList, parseMeasureGroupStratifier);
end;

procedure TFHIRJsonComposer.ComposeMeasureGroup(json : TJSONWriter; name : string; elem : TFhirMeasureGroup; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.populationList.Count > 0) then
  begin
    json.valueArray('population');
    for i := 0 to elem.populationList.Count - 1 do
      ComposeMeasureGroupPopulation(json, '', elem.populationList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.stratifierList.Count > 0) then
  begin
    json.valueArray('stratifier');
    for i := 0 to elem.stratifierList.Count - 1 do
      ComposeMeasureGroupStratifier(json, '', elem.stratifierList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseMeasureGroupPopulation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMeasureGroupPopulation(jsn)); {2}
end;

function TFHIRJsonParser.ParseMeasureGroupPopulation(jsn : TJsonObject) : TFhirMeasureGroupPopulation;
begin
  result := TFhirMeasureGroupPopulation.create;
  try
    ParseMeasureGroupPopulationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMeasureGroupPopulationProperties(jsn : TJsonObject; result : TFhirMeasureGroupPopulation);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('criteria') then
        result.criteria := ParseExpression(jsn.vObj['criteria']);{q3}
end;

procedure TFHIRJsonComposer.ComposeMeasureGroupPopulation(json : TJSONWriter; name : string; elem : TFhirMeasureGroupPopulation; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  ComposeExpression(json, 'criteria', elem.criteria); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseMeasureGroupStratifier(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMeasureGroupStratifier(jsn)); {2}
end;

function TFHIRJsonParser.ParseMeasureGroupStratifier(jsn : TJsonObject) : TFhirMeasureGroupStratifier;
begin
  result := TFhirMeasureGroupStratifier.create;
  try
    ParseMeasureGroupStratifierProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMeasureGroupStratifierProperties(jsn : TJsonObject; result : TFhirMeasureGroupStratifier);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('criteria') then
        result.criteria := ParseExpression(jsn.vObj['criteria']);{q3}
    if jsn.has('component') then
      iterateArray(jsn.vArr['component'], result.componentList, parseMeasureGroupStratifierComponent);
end;

procedure TFHIRJsonComposer.ComposeMeasureGroupStratifier(json : TJSONWriter; name : string; elem : TFhirMeasureGroupStratifier; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeExpression(json, 'criteria', elem.criteria); {a}
  if (SummaryOption in [soFull, soData]) and (elem.componentList.Count > 0) then
  begin
    json.valueArray('component');
    for i := 0 to elem.componentList.Count - 1 do
      ComposeMeasureGroupStratifierComponent(json, '', elem.componentList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseMeasureGroupStratifierComponent(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMeasureGroupStratifierComponent(jsn)); {2}
end;

function TFHIRJsonParser.ParseMeasureGroupStratifierComponent(jsn : TJsonObject) : TFhirMeasureGroupStratifierComponent;
begin
  result := TFhirMeasureGroupStratifierComponent.create;
  try
    ParseMeasureGroupStratifierComponentProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMeasureGroupStratifierComponentProperties(jsn : TJsonObject; result : TFhirMeasureGroupStratifierComponent);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('criteria') then
        result.criteria := ParseExpression(jsn.vObj['criteria']);{q3}
end;

procedure TFHIRJsonComposer.ComposeMeasureGroupStratifierComponent(json : TJSONWriter; name : string; elem : TFhirMeasureGroupStratifierComponent; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  ComposeExpression(json, 'criteria', elem.criteria); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseMeasureSupplementalData(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMeasureSupplementalData(jsn)); {2}
end;

function TFHIRJsonParser.ParseMeasureSupplementalData(jsn : TJsonObject) : TFhirMeasureSupplementalData;
begin
  result := TFhirMeasureSupplementalData.create;
  try
    ParseMeasureSupplementalDataProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMeasureSupplementalDataProperties(jsn : TJsonObject; result : TFhirMeasureSupplementalData);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('usage') then
      iterateArray(jsn.vArr['usage'], result.usageList, parseCodeableConcept);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('criteria') then
        result.criteria := ParseExpression(jsn.vObj['criteria']);{q3}
end;

procedure TFHIRJsonComposer.ComposeMeasureSupplementalData(json : TJSONWriter; name : string; elem : TFhirMeasureSupplementalData; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soData]) and (elem.usageList.Count > 0) then
  begin
    json.valueArray('usage');
    for i := 0 to elem.usageList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.usageList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  ComposeExpression(json, 'criteria', elem.criteria); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseMeasure(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMeasure(jsn)); {2}
end;

function TFHIRJsonParser.ParseMeasure(jsn : TJsonObject) : TFhirMeasure;
begin
  result := TFhirMeasure.create;
  try
    ParseMeasureProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMeasureProperties(jsn : TJsonObject; result : TFhirMeasure);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := parseUri(jsn.node['url'], jsn.vObj['_url']);{q}
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := parseString(jsn.node['version'], jsn.vObj['_version']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('title') or jsn.has('_title') then
        result.titleElement := parseString(jsn.node['title'], jsn.vObj['_title']);{q}
    if jsn.has('subtitle') or jsn.has('_subtitle') then
        result.subtitleElement := parseString(jsn.node['subtitle'], jsn.vObj['_subtitle']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    if jsn.has('experimental') or jsn.has('_experimental') then
        result.experimentalElement := parseBoolean(jsn.node['experimental'], jsn.vObj['_experimental']);{q}
    if jsn.has('subjectCodeableConcept') {a4} then
      result.subject := ParseCodeableConcept(jsn.vObj['subjectCodeableConcept']);
    if jsn.has('subjectReference') {a3} then
      result.subject := ParseReference(jsn.vObj['subjectReference']);
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := parseDateTime(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('publisher') or jsn.has('_publisher') then
        result.publisherElement := parseString(jsn.node['publisher'], jsn.vObj['_publisher']);{q}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseContactDetail);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseMarkdown(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('useContext') then
      iterateArray(jsn.vArr['useContext'], result.useContextList, parseUsageContext);
    if jsn.has('jurisdiction') then
      iterateArray(jsn.vArr['jurisdiction'], result.jurisdictionList, parseCodeableConcept);
    if jsn.has('purpose') or jsn.has('_purpose') then
        result.purposeElement := parseMarkdown(jsn.node['purpose'], jsn.vObj['_purpose']);{q}
    if jsn.has('usage') or jsn.has('_usage') then
        result.usageElement := parseString(jsn.node['usage'], jsn.vObj['_usage']);{q}
    if jsn.has('copyright') or jsn.has('_copyright') then
        result.copyrightElement := parseMarkdown(jsn.node['copyright'], jsn.vObj['_copyright']);{q}
    if jsn.has('approvalDate') or jsn.has('_approvalDate') then
        result.approvalDateElement := parseDate(jsn.node['approvalDate'], jsn.vObj['_approvalDate']);{q}
    if jsn.has('lastReviewDate') or jsn.has('_lastReviewDate') then
        result.lastReviewDateElement := parseDate(jsn.node['lastReviewDate'], jsn.vObj['_lastReviewDate']);{q}
    if jsn.has('effectivePeriod') then
        result.effectivePeriod := ParsePeriod(jsn.vObj['effectivePeriod']);{q3}
    if jsn.has('topic') then
      iterateArray(jsn.vArr['topic'], result.topicList, parseCodeableConcept);
    if jsn.has('author') then
      iterateArray(jsn.vArr['author'], result.authorList, parseContactDetail);
    if jsn.has('editor') then
      iterateArray(jsn.vArr['editor'], result.editorList, parseContactDetail);
    if jsn.has('reviewer') then
      iterateArray(jsn.vArr['reviewer'], result.reviewerList, parseContactDetail);
    if jsn.has('endorser') then
      iterateArray(jsn.vArr['endorser'], result.endorserList, parseContactDetail);
    if jsn.has('relatedArtifact') then
      iterateArray(jsn.vArr['relatedArtifact'], result.relatedArtifactList, parseRelatedArtifact);
      if jsn.has('library') or jsn.has('_library') then
      iteratePrimitiveArray(jsn.vArr['library'], jsn.vArr['_library'], result.library_List, parseCanonical);
    if jsn.has('disclaimer') or jsn.has('_disclaimer') then
        result.disclaimerElement := parseMarkdown(jsn.node['disclaimer'], jsn.vObj['_disclaimer']);{q}
    if jsn.has('scoring') then
        result.scoring := ParseCodeableConcept(jsn.vObj['scoring']);{q3}
    if jsn.has('compositeScoring') then
        result.compositeScoring := ParseCodeableConcept(jsn.vObj['compositeScoring']);{q3}
    if jsn.has('type') then
      iterateArray(jsn.vArr['type'], result.type_List, parseCodeableConcept);
    if jsn.has('riskAdjustment') or jsn.has('_riskAdjustment') then
        result.riskAdjustmentElement := parseString(jsn.node['riskAdjustment'], jsn.vObj['_riskAdjustment']);{q}
    if jsn.has('rateAggregation') or jsn.has('_rateAggregation') then
        result.rateAggregationElement := parseString(jsn.node['rateAggregation'], jsn.vObj['_rateAggregation']);{q}
    if jsn.has('rationale') or jsn.has('_rationale') then
        result.rationaleElement := parseMarkdown(jsn.node['rationale'], jsn.vObj['_rationale']);{q}
    if jsn.has('clinicalRecommendationStatement') or jsn.has('_clinicalRecommendationStatement') then
        result.clinicalRecommendationStatementElement := parseMarkdown(jsn.node['clinicalRecommendationStatement'], jsn.vObj['_clinicalRecommendationStatement']);{q}
    if jsn.has('improvementNotation') then
        result.improvementNotation := ParseCodeableConcept(jsn.vObj['improvementNotation']);{q3}
      if jsn.has('definition') or jsn.has('_definition') then
      iteratePrimitiveArray(jsn.vArr['definition'], jsn.vArr['_definition'], result.definitionList, parseMarkdown);
    if jsn.has('guidance') or jsn.has('_guidance') then
        result.guidanceElement := parseMarkdown(jsn.node['guidance'], jsn.vObj['_guidance']);{q}
    if jsn.has('group') then
      iterateArray(jsn.vArr['group'], result.groupList, parseMeasureGroup);
    if jsn.has('supplementalData') then
      iterateArray(jsn.vArr['supplementalData'], result.supplementalDataList, parseMeasureSupplementalData);
end;

procedure TFHIRJsonComposer.ComposeMeasure(json : TJSONWriter; name : string; elem : TFhirMeasure; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUriValue(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUriProps(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeStringValue(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeStringProps(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeStringValue(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeStringProps(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('subtitle') then
    ComposeStringValue(json, 'subtitle', elem.subtitleElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('subtitle') then
    ComposeStringProps(json, 'subtitle', elem.subtitleElement, false);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBooleanValue(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBooleanProps(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.subject is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'subjectCodeableConcept', TFhirCodeableConcept(elem.subject)) 
  else if (SummaryOption in [soFull, soData]) and (elem.subject is TFhirReference) then
    ComposeReference(json, 'subjectReference', TFhirReference(elem.subject));
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringValue(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringProps(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') and (elem.contactList.Count > 0) then
  begin
    json.valueArray('contact');
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(json, '', elem.contactList[i]); {z - ContactDetail}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeMarkdownValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeMarkdownProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') and (elem.useContextList.Count > 0) then
  begin
    json.valueArray('useContext');
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(json, '', elem.useContextList[i]); {z - UsageContext}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') and (elem.jurisdictionList.Count > 0) then
  begin
    json.valueArray('jurisdiction');
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.jurisdictionList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdownValue(json, 'purpose', elem.purposeElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdownProps(json, 'purpose', elem.purposeElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('usage') then
    ComposeStringValue(json, 'usage', elem.usageElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('usage') then
    ComposeStringProps(json, 'usage', elem.usageElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdownValue(json, 'copyright', elem.copyrightElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdownProps(json, 'copyright', elem.copyrightElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('approvalDate') then
    ComposeDateValue(json, 'approvalDate', elem.approvalDateElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('approvalDate') then
    ComposeDateProps(json, 'approvalDate', elem.approvalDateElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('lastReviewDate') then
    ComposeDateValue(json, 'lastReviewDate', elem.lastReviewDateElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('lastReviewDate') then
    ComposeDateProps(json, 'lastReviewDate', elem.lastReviewDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('effectivePeriod') then
    ComposePeriod(json, 'effectivePeriod', elem.effectivePeriod); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('topic') and (elem.topicList.Count > 0) then
  begin
    json.valueArray('topic');
    for i := 0 to elem.topicList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.topicList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('author') and (elem.authorList.Count > 0) then
  begin
    json.valueArray('author');
    for i := 0 to elem.authorList.Count - 1 do
      ComposeContactDetail(json, '', elem.authorList[i]); {z - ContactDetail}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('editor') and (elem.editorList.Count > 0) then
  begin
    json.valueArray('editor');
    for i := 0 to elem.editorList.Count - 1 do
      ComposeContactDetail(json, '', elem.editorList[i]); {z - ContactDetail}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('reviewer') and (elem.reviewerList.Count > 0) then
  begin
    json.valueArray('reviewer');
    for i := 0 to elem.reviewerList.Count - 1 do
      ComposeContactDetail(json, '', elem.reviewerList[i]); {z - ContactDetail}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('endorser') and (elem.endorserList.Count > 0) then
  begin
    json.valueArray('endorser');
    for i := 0 to elem.endorserList.Count - 1 do
      ComposeContactDetail(json, '', elem.endorserList[i]); {z - ContactDetail}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('relatedArtifact') and (elem.relatedArtifactList.Count > 0) then
  begin
    json.valueArray('relatedArtifact');
    for i := 0 to elem.relatedArtifactList.Count - 1 do
      ComposeRelatedArtifact(json, '', elem.relatedArtifactList[i]); {z - RelatedArtifact}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('library_') and (elem.library_List.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.library_List.Count - 1 do
    begin
      ext := ext or ((elem.library_List[i].id <> '') or (elem.library_List[i].hasExtensionList) {no-comments or (elem.library_List[i].hasComments)});
      val := val or (elem.library_List[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('library');
      for i := 0 to elem.library_List.Count - 1 do
        ComposeCanonicalValue(json, '',elem.library_List[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_library');
      for i := 0 to elem.library_List.Count - 1 do
        ComposeCanonicalProps(json, '',elem.library_List[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('disclaimer') then
    ComposeMarkdownValue(json, 'disclaimer', elem.disclaimerElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('disclaimer') then
    ComposeMarkdownProps(json, 'disclaimer', elem.disclaimerElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('scoring') then
    ComposeCodeableConcept(json, 'scoring', elem.scoring); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('compositeScoring') then
    ComposeCodeableConcept(json, 'compositeScoring', elem.compositeScoring); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') and (elem.type_List.Count > 0) then
  begin
    json.valueArray('type');
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(json, '', elem.type_List[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('riskAdjustment') then
    ComposeStringValue(json, 'riskAdjustment', elem.riskAdjustmentElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('riskAdjustment') then
    ComposeStringProps(json, 'riskAdjustment', elem.riskAdjustmentElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('rateAggregation') then
    ComposeStringValue(json, 'rateAggregation', elem.rateAggregationElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('rateAggregation') then
    ComposeStringProps(json, 'rateAggregation', elem.rateAggregationElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('rationale') then
    ComposeMarkdownValue(json, 'rationale', elem.rationaleElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('rationale') then
    ComposeMarkdownProps(json, 'rationale', elem.rationaleElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('clinicalRecommendationStatement') then
    ComposeMarkdownValue(json, 'clinicalRecommendationStatement', elem.clinicalRecommendationStatementElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('clinicalRecommendationStatement') then
    ComposeMarkdownProps(json, 'clinicalRecommendationStatement', elem.clinicalRecommendationStatementElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('improvementNotation') then
    ComposeCodeableConcept(json, 'improvementNotation', elem.improvementNotation); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('definition') and (elem.definitionList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.definitionList.Count - 1 do
    begin
      ext := ext or ((elem.definitionList[i].id <> '') or (elem.definitionList[i].hasExtensionList) {no-comments or (elem.definitionList[i].hasComments)});
      val := val or (elem.definitionList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('definition');
      for i := 0 to elem.definitionList.Count - 1 do
        ComposeMarkdownValue(json, '',elem.definitionList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_definition');
      for i := 0 to elem.definitionList.Count - 1 do
        ComposeMarkdownProps(json, '',elem.definitionList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('guidance') then
    ComposeMarkdownValue(json, 'guidance', elem.guidanceElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('guidance') then
    ComposeMarkdownProps(json, 'guidance', elem.guidanceElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('group') and (elem.groupList.Count > 0) then
  begin
    json.valueArray('group');
    for i := 0 to elem.groupList.Count - 1 do
      ComposeMeasureGroup(json, '', elem.groupList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('supplementalData') and (elem.supplementalDataList.Count > 0) then
  begin
    json.valueArray('supplementalData');
    for i := 0 to elem.supplementalDataList.Count - 1 do
      ComposeMeasureSupplementalData(json, '', elem.supplementalDataList[i]); {z - }
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_MEASURE}
{$IFDEF FHIR_MEASUREREPORT}
procedure TFHIRJsonParser.ParseMeasureReportGroup(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMeasureReportGroup(jsn)); {2}
end;

function TFHIRJsonParser.ParseMeasureReportGroup(jsn : TJsonObject) : TFhirMeasureReportGroup;
begin
  result := TFhirMeasureReportGroup.create;
  try
    ParseMeasureReportGroupProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMeasureReportGroupProperties(jsn : TJsonObject; result : TFhirMeasureReportGroup);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('population') then
      iterateArray(jsn.vArr['population'], result.populationList, parseMeasureReportGroupPopulation);
    if jsn.has('measureScore') then
        result.measureScore := ParseQuantity(jsn.vObj['measureScore']);{q3}
    if jsn.has('stratifier') then
      iterateArray(jsn.vArr['stratifier'], result.stratifierList, parseMeasureReportGroupStratifier);
end;

procedure TFHIRJsonComposer.ComposeMeasureReportGroup(json : TJSONWriter; name : string; elem : TFhirMeasureReportGroup; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soData]) and (elem.populationList.Count > 0) then
  begin
    json.valueArray('population');
    for i := 0 to elem.populationList.Count - 1 do
      ComposeMeasureReportGroupPopulation(json, '', elem.populationList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(json, 'measureScore', elem.measureScore); {a}
  if (SummaryOption in [soFull, soData]) and (elem.stratifierList.Count > 0) then
  begin
    json.valueArray('stratifier');
    for i := 0 to elem.stratifierList.Count - 1 do
      ComposeMeasureReportGroupStratifier(json, '', elem.stratifierList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseMeasureReportGroupPopulation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMeasureReportGroupPopulation(jsn)); {2}
end;

function TFHIRJsonParser.ParseMeasureReportGroupPopulation(jsn : TJsonObject) : TFhirMeasureReportGroupPopulation;
begin
  result := TFhirMeasureReportGroupPopulation.create;
  try
    ParseMeasureReportGroupPopulationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMeasureReportGroupPopulationProperties(jsn : TJsonObject; result : TFhirMeasureReportGroupPopulation);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('count') or jsn.has('_count') then
        result.countElement := parseInteger(jsn.node['count'], jsn.vObj['_count']);{q}
    if jsn.has('subjectResults') then
        result.subjectResults := ParseReference{TFhirList}(jsn.vObj['subjectResults']);{q3}
end;

procedure TFHIRJsonComposer.ComposeMeasureReportGroupPopulation(json : TJSONWriter; name : string; elem : TFhirMeasureReportGroupPopulation; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeIntegerValue(json, 'count', elem.countElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIntegerProps(json, 'count', elem.countElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirList}(json, 'subjectResults', elem.subjectResults); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseMeasureReportGroupStratifier(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMeasureReportGroupStratifier(jsn)); {2}
end;

function TFHIRJsonParser.ParseMeasureReportGroupStratifier(jsn : TJsonObject) : TFhirMeasureReportGroupStratifier;
begin
  result := TFhirMeasureReportGroupStratifier.create;
  try
    ParseMeasureReportGroupStratifierProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMeasureReportGroupStratifierProperties(jsn : TJsonObject; result : TFhirMeasureReportGroupStratifier);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
      iterateArray(jsn.vArr['code'], result.codeList, parseCodeableConcept);
    if jsn.has('stratum') then
      iterateArray(jsn.vArr['stratum'], result.stratumList, parseMeasureReportGroupStratifierStratum);
end;

procedure TFHIRJsonComposer.ComposeMeasureReportGroupStratifier(json : TJSONWriter; name : string; elem : TFhirMeasureReportGroupStratifier; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and (elem.codeList.Count > 0) then
  begin
    json.valueArray('code');
    for i := 0 to elem.codeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.codeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.stratumList.Count > 0) then
  begin
    json.valueArray('stratum');
    for i := 0 to elem.stratumList.Count - 1 do
      ComposeMeasureReportGroupStratifierStratum(json, '', elem.stratumList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseMeasureReportGroupStratifierStratum(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMeasureReportGroupStratifierStratum(jsn)); {2}
end;

function TFHIRJsonParser.ParseMeasureReportGroupStratifierStratum(jsn : TJsonObject) : TFhirMeasureReportGroupStratifierStratum;
begin
  result := TFhirMeasureReportGroupStratifierStratum.create;
  try
    ParseMeasureReportGroupStratifierStratumProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMeasureReportGroupStratifierStratumProperties(jsn : TJsonObject; result : TFhirMeasureReportGroupStratifierStratum);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('value') then
        result.value := ParseCodeableConcept(jsn.vObj['value']);{q3}
    if jsn.has('component') then
      iterateArray(jsn.vArr['component'], result.componentList, parseMeasureReportGroupStratifierStratumComponent);
    if jsn.has('population') then
      iterateArray(jsn.vArr['population'], result.populationList, parseMeasureReportGroupStratifierStratumPopulation);
    if jsn.has('measureScore') then
        result.measureScore := ParseQuantity(jsn.vObj['measureScore']);{q3}
end;

procedure TFHIRJsonComposer.ComposeMeasureReportGroupStratifierStratum(json : TJSONWriter; name : string; elem : TFhirMeasureReportGroupStratifierStratum; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
  ComposeCodeableConcept(json, 'value', elem.value); {a}
  if (SummaryOption in [soFull, soData]) and (elem.componentList.Count > 0) then
  begin
    json.valueArray('component');
    for i := 0 to elem.componentList.Count - 1 do
      ComposeMeasureReportGroupStratifierStratumComponent(json, '', elem.componentList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.populationList.Count > 0) then
  begin
    json.valueArray('population');
    for i := 0 to elem.populationList.Count - 1 do
      ComposeMeasureReportGroupStratifierStratumPopulation(json, '', elem.populationList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'measureScore', elem.measureScore); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseMeasureReportGroupStratifierStratumComponent(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMeasureReportGroupStratifierStratumComponent(jsn)); {2}
end;

function TFHIRJsonParser.ParseMeasureReportGroupStratifierStratumComponent(jsn : TJsonObject) : TFhirMeasureReportGroupStratifierStratumComponent;
begin
  result := TFhirMeasureReportGroupStratifierStratumComponent.create;
  try
    ParseMeasureReportGroupStratifierStratumComponentProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMeasureReportGroupStratifierStratumComponentProperties(jsn : TJsonObject; result : TFhirMeasureReportGroupStratifierStratumComponent);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('value') then
        result.value := ParseCodeableConcept(jsn.vObj['value']);{q3}
end;

procedure TFHIRJsonComposer.ComposeMeasureReportGroupStratifierStratumComponent(json : TJSONWriter; name : string; elem : TFhirMeasureReportGroupStratifierStratumComponent; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  ComposeCodeableConcept(json, 'value', elem.value); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseMeasureReportGroupStratifierStratumPopulation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMeasureReportGroupStratifierStratumPopulation(jsn)); {2}
end;

function TFHIRJsonParser.ParseMeasureReportGroupStratifierStratumPopulation(jsn : TJsonObject) : TFhirMeasureReportGroupStratifierStratumPopulation;
begin
  result := TFhirMeasureReportGroupStratifierStratumPopulation.create;
  try
    ParseMeasureReportGroupStratifierStratumPopulationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMeasureReportGroupStratifierStratumPopulationProperties(jsn : TJsonObject; result : TFhirMeasureReportGroupStratifierStratumPopulation);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('count') or jsn.has('_count') then
        result.countElement := parseInteger(jsn.node['count'], jsn.vObj['_count']);{q}
    if jsn.has('subjectResults') then
        result.subjectResults := ParseReference{TFhirList}(jsn.vObj['subjectResults']);{q3}
end;

procedure TFHIRJsonComposer.ComposeMeasureReportGroupStratifierStratumPopulation(json : TJSONWriter; name : string; elem : TFhirMeasureReportGroupStratifierStratumPopulation; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeIntegerValue(json, 'count', elem.countElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIntegerProps(json, 'count', elem.countElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirList}(json, 'subjectResults', elem.subjectResults); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseMeasureReport(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMeasureReport(jsn)); {2}
end;

function TFHIRJsonParser.ParseMeasureReport(jsn : TJsonObject) : TFhirMeasureReport;
begin
  result := TFhirMeasureReport.create;
  try
    ParseMeasureReportProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMeasureReportProperties(jsn : TJsonObject; result : TFhirMeasureReport);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirMeasureReportStatusEnum, SYSTEMS_TFhirMeasureReportStatusEnum);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn.node['type'], jsn.vObj['_type'], CODES_TFhirMeasureReportTypeEnum, SYSTEMS_TFhirMeasureReportTypeEnum);
    if jsn.has('measure') or jsn.has('_measure') then
        result.measureElement := parseCanonical(jsn.node['measure'], jsn.vObj['_measure']);{q}
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirPatient}(jsn.vObj['subject']);{q3}
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := parseDateTime(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('reporter') then
        result.reporter := ParseReference{TFhirPractitioner}(jsn.vObj['reporter']);{q3}
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q3}
    if jsn.has('improvementNotation') then
        result.improvementNotation := ParseCodeableConcept(jsn.vObj['improvementNotation']);{q3}
    if jsn.has('group') then
      iterateArray(jsn.vArr['group'], result.groupList, parseMeasureReportGroup);
    if jsn.has('evaluatedResource') then
      iterateArray(jsn.vArr['evaluatedResource'], result.evaluatedResourceList, parseReference{TFhirReference});
end;

procedure TFHIRJsonComposer.ComposeMeasureReport(json : TJSONWriter; name : string; elem : TFhirMeasureReport; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirMeasureReportStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirMeasureReportStatusEnum, false);
  ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirMeasureReportTypeEnum, false);
  ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirMeasureReportTypeEnum, false);
  ComposeCanonicalValue(json, 'measure', elem.measureElement, false);
  ComposeCanonicalProps(json, 'measure', elem.measureElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{TFhirPatient}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reporter') then
    ComposeReference{TFhirPractitioner}(json, 'reporter', elem.reporter); {a}
  ComposePeriod(json, 'period', elem.period); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('improvementNotation') then
    ComposeCodeableConcept(json, 'improvementNotation', elem.improvementNotation); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('group') and (elem.groupList.Count > 0) then
  begin
    json.valueArray('group');
    for i := 0 to elem.groupList.Count - 1 do
      ComposeMeasureReportGroup(json, '', elem.groupList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('evaluatedResource') and (elem.evaluatedResourceList.Count > 0) then
  begin
    json.valueArray('evaluatedResource');
    for i := 0 to elem.evaluatedResourceList.Count - 1 do
      ComposeReference{TFhirReference}(json, '', elem.evaluatedResourceList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_MEASUREREPORT}
{$IFDEF FHIR_MEDIA}
procedure TFHIRJsonParser.ParseMedia(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedia(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedia(jsn : TJsonObject) : TFhirMedia;
begin
  result := TFhirMedia.create;
  try
    ParseMediaProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMediaProperties(jsn : TJsonObject; result : TFhirMedia);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('basedOn') then
      iterateArray(jsn.vArr['basedOn'], result.basedOnList, parseReference{TFhirServiceRequest});
    if jsn.has('partOf') then
      iterateArray(jsn.vArr['partOf'], result.partOfList, parseReference{TFhirReference});
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirEventStatusEnum, SYSTEMS_TFhirEventStatusEnum);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('modality') then
        result.modality := ParseCodeableConcept(jsn.vObj['modality']);{q3}
    if jsn.has('view') then
        result.view := ParseCodeableConcept(jsn.vObj['view']);{q3}
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirPatient}(jsn.vObj['subject']);{q3}
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q3}
    if jsn.has('createdPeriod') {a4} then
      result.created := ParsePeriod(jsn.vObj['createdPeriod']);
    if jsn.has('createdDateTime') or jsn.has('_createdDateTime') then
      result.created := parseDateTime(jsn.node['createdDateTime'], jsn.vObj['_createdDateTime']);
    if jsn.has('issued') or jsn.has('_issued') then
        result.issuedElement := parseInstant(jsn.node['issued'], jsn.vObj['_issued']);{q}
    if jsn.has('operator') then
        result.operator := ParseReference{TFhirPractitioner}(jsn.vObj['operator']);{q3}
    if jsn.has('reasonCode') then
      iterateArray(jsn.vArr['reasonCode'], result.reasonCodeList, parseCodeableConcept);
    if jsn.has('bodySite') then
        result.bodySite := ParseCodeableConcept(jsn.vObj['bodySite']);{q3}
    if jsn.has('deviceName') or jsn.has('_deviceName') then
        result.deviceNameElement := parseString(jsn.node['deviceName'], jsn.vObj['_deviceName']);{q}
    if jsn.has('device') then
        result.device := ParseReference{TFhirDevice}(jsn.vObj['device']);{q3}
    if jsn.has('height') or jsn.has('_height') then
        result.heightElement := parsePositiveInt(jsn.node['height'], jsn.vObj['_height']);{q}
    if jsn.has('width') or jsn.has('_width') then
        result.widthElement := parsePositiveInt(jsn.node['width'], jsn.vObj['_width']);{q}
    if jsn.has('frames') or jsn.has('_frames') then
        result.framesElement := parsePositiveInt(jsn.node['frames'], jsn.vObj['_frames']);{q}
    if jsn.has('duration') or jsn.has('_duration') then
        result.durationElement := parseDecimal(jsn.node['duration'], jsn.vObj['_duration']);{q}
    if jsn.has('content') then
        result.content := ParseAttachment(jsn.vObj['content']);{q3}
    if jsn.has('note') then
      iterateArray(jsn.vArr['note'], result.noteList, parseAnnotation);
end;

procedure TFHIRJsonComposer.ComposeMedia(json : TJSONWriter; name : string; elem : TFhirMedia; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('basedOn') and (elem.basedOnList.Count > 0) then
  begin
    json.valueArray('basedOn');
    for i := 0 to elem.basedOnList.Count - 1 do
      ComposeReference{TFhirServiceRequest}(json, '', elem.basedOnList[i]); {z - Reference(ServiceRequest)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('partOf') and (elem.partOfList.Count > 0) then
  begin
    json.valueArray('partOf');
    for i := 0 to elem.partOfList.Count - 1 do
      ComposeReference{TFhirReference}(json, '', elem.partOfList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirEventStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirEventStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('modality') then
    ComposeCodeableConcept(json, 'modality', elem.modality); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('view') then
    ComposeCodeableConcept(json, 'view', elem.view); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{TFhirPatient}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.created is TFhirPeriod) then 
    ComposePeriod(json, 'createdPeriod', TFhirPeriod(elem.created)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.created is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'createdDateTime', TFhirDateTime(elem.created), false);
    ComposeDateTimeProps(json, 'createdDateTime', TFhirDateTime(elem.created), false);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('issued') then
    ComposeInstantValue(json, 'issued', elem.issuedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('issued') then
    ComposeInstantProps(json, 'issued', elem.issuedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('operator') then
    ComposeReference{TFhirPractitioner}(json, 'operator', elem.operator); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonCode') and (elem.reasonCodeList.Count > 0) then
  begin
    json.valueArray('reasonCode');
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.reasonCodeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('bodySite') then
    ComposeCodeableConcept(json, 'bodySite', elem.bodySite); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('deviceName') then
    ComposeStringValue(json, 'deviceName', elem.deviceNameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('deviceName') then
    ComposeStringProps(json, 'deviceName', elem.deviceNameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('device') then
    ComposeReference{TFhirDevice}(json, 'device', elem.device); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('height') then
    ComposePositiveIntValue(json, 'height', elem.heightElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('height') then
    ComposePositiveIntProps(json, 'height', elem.heightElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('width') then
    ComposePositiveIntValue(json, 'width', elem.widthElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('width') then
    ComposePositiveIntProps(json, 'width', elem.widthElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('frames') then
    ComposePositiveIntValue(json, 'frames', elem.framesElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('frames') then
    ComposePositiveIntProps(json, 'frames', elem.framesElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('duration') then
    ComposeDecimalValue(json, 'duration', elem.durationElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('duration') then
    ComposeDecimalProps(json, 'duration', elem.durationElement, false);
  ComposeAttachment(json, 'content', elem.content); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('note') and (elem.noteList.Count > 0) then
  begin
    json.valueArray('note');
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(json, '', elem.noteList[i]); {z - Annotation}
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_MEDIA}
{$IFDEF FHIR_MEDICATION}
procedure TFHIRJsonParser.ParseMedicationIngredient(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationIngredient(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationIngredient(jsn : TJsonObject) : TFhirMedicationIngredient;
begin
  result := TFhirMedicationIngredient.create;
  try
    ParseMedicationIngredientProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicationIngredientProperties(jsn : TJsonObject; result : TFhirMedicationIngredient);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('itemCodeableConcept') {a4} then
      result.item := ParseCodeableConcept(jsn.vObj['itemCodeableConcept']);
    if jsn.has('itemReference') {a3} then
      result.item := ParseReference(jsn.vObj['itemReference']);
    if jsn.has('isActive') or jsn.has('_isActive') then
        result.isActiveElement := parseBoolean(jsn.node['isActive'], jsn.vObj['_isActive']);{q}
    if jsn.has('strength') then
        result.strength := ParseRatio(jsn.vObj['strength']);{q3}
end;

procedure TFHIRJsonComposer.ComposeMedicationIngredient(json : TJSONWriter; name : string; elem : TFhirMedicationIngredient; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (elem.item is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'itemCodeableConcept', TFhirCodeableConcept(elem.item)) 
  else if (elem.item is TFhirReference) then
    ComposeReference(json, 'itemReference', TFhirReference(elem.item));
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'isActive', elem.isActiveElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'isActive', elem.isActiveElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeRatio(json, 'strength', elem.strength); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseMedicationBatch(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationBatch(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationBatch(jsn : TJsonObject) : TFhirMedicationBatch;
begin
  result := TFhirMedicationBatch.create;
  try
    ParseMedicationBatchProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicationBatchProperties(jsn : TJsonObject; result : TFhirMedicationBatch);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('lotNumber') or jsn.has('_lotNumber') then
        result.lotNumberElement := parseString(jsn.node['lotNumber'], jsn.vObj['_lotNumber']);{q}
    if jsn.has('expirationDate') or jsn.has('_expirationDate') then
        result.expirationDateElement := parseDateTime(jsn.node['expirationDate'], jsn.vObj['_expirationDate']);{q}
end;

procedure TFHIRJsonComposer.ComposeMedicationBatch(json : TJSONWriter; name : string; elem : TFhirMedicationBatch; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'lotNumber', elem.lotNumberElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'lotNumber', elem.lotNumberElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTimeValue(json, 'expirationDate', elem.expirationDateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTimeProps(json, 'expirationDate', elem.expirationDateElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseMedication(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedication(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedication(jsn : TJsonObject) : TFhirMedication;
begin
  result := TFhirMedication.create;
  try
    ParseMedicationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicationProperties(jsn : TJsonObject; result : TFhirMedication);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirMedicationStatusEnum, SYSTEMS_TFhirMedicationStatusEnum);
    if jsn.has('manufacturer') then
        result.manufacturer := ParseReference{TFhirOrganization}(jsn.vObj['manufacturer']);{q3}
    if jsn.has('form') then
        result.form := ParseCodeableConcept(jsn.vObj['form']);{q3}
    if jsn.has('amount') then
        result.amount := ParseRatio(jsn.vObj['amount']);{q3}
    if jsn.has('ingredient') then
      iterateArray(jsn.vArr['ingredient'], result.ingredientList, parseMedicationIngredient);
    if jsn.has('batch') then
        result.batch := ParseMedicationBatch(jsn.vObj['batch']);{q3}
end;

procedure TFHIRJsonComposer.ComposeMedication(json : TJSONWriter; name : string; elem : TFhirMedication; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') then
    ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirMedicationStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirMedicationStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('manufacturer') then
    ComposeReference{TFhirOrganization}(json, 'manufacturer', elem.manufacturer); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('form') then
    ComposeCodeableConcept(json, 'form', elem.form); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('amount') then
    ComposeRatio(json, 'amount', elem.amount); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('ingredient') and (elem.ingredientList.Count > 0) then
  begin
    json.valueArray('ingredient');
    for i := 0 to elem.ingredientList.Count - 1 do
      ComposeMedicationIngredient(json, '', elem.ingredientList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('batch') then
    ComposeMedicationBatch(json, 'batch', elem.batch); {a}
end;

{$ENDIF FHIR_MEDICATION}
{$IFDEF FHIR_MEDICATIONADMINISTRATION}
procedure TFHIRJsonParser.ParseMedicationAdministrationPerformer(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationAdministrationPerformer(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationAdministrationPerformer(jsn : TJsonObject) : TFhirMedicationAdministrationPerformer;
begin
  result := TFhirMedicationAdministrationPerformer.create;
  try
    ParseMedicationAdministrationPerformerProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicationAdministrationPerformerProperties(jsn : TJsonObject; result : TFhirMedicationAdministrationPerformer);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('function') then
        result.function_ := ParseCodeableConcept(jsn.vObj['function']);{q3}
    if jsn.has('actor') then
        result.actor := ParseReference{TFhirPractitioner}(jsn.vObj['actor']);{q3}
end;

procedure TFHIRJsonComposer.ComposeMedicationAdministrationPerformer(json : TJSONWriter; name : string; elem : TFhirMedicationAdministrationPerformer; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'function', elem.function_); {a}
  ComposeReference{TFhirPractitioner}(json, 'actor', elem.actor); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseMedicationAdministrationDosage(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationAdministrationDosage(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationAdministrationDosage(jsn : TJsonObject) : TFhirMedicationAdministrationDosage;
begin
  result := TFhirMedicationAdministrationDosage.create;
  try
    ParseMedicationAdministrationDosageProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicationAdministrationDosageProperties(jsn : TJsonObject; result : TFhirMedicationAdministrationDosage);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('text') or jsn.has('_text') then
        result.textElement := parseString(jsn.node['text'], jsn.vObj['_text']);{q}
    if jsn.has('site') then
        result.site := ParseCodeableConcept(jsn.vObj['site']);{q3}
    if jsn.has('route') then
        result.route := ParseCodeableConcept(jsn.vObj['route']);{q3}
    if jsn.has('method') then
        result.method := ParseCodeableConcept(jsn.vObj['method']);{q3}
    if jsn.has('dose') then
        result.dose := ParseQuantity(jsn.vObj['dose']);{q3}
    if jsn.has('rateRatio') {a4} then
      result.rate := ParseRatio(jsn.vObj['rateRatio']);
    if jsn.has('rateQuantity') {a4} then
      result.rate := ParseQuantity(jsn.vObj['rateQuantity']);
end;

procedure TFHIRJsonComposer.ComposeMedicationAdministrationDosage(json : TJSONWriter; name : string; elem : TFhirMedicationAdministrationDosage; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'site', elem.site); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'route', elem.route); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'method', elem.method); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'dose', elem.dose); {a}
  if (SummaryOption in [soFull, soData]) and (elem.rate is TFhirRatio) then 
    ComposeRatio(json, 'rateRatio', TFhirRatio(elem.rate)) 
  else if (SummaryOption in [soFull, soData]) and (elem.rate is TFhirQuantity) then 
    ComposeQuantity(json, 'rateQuantity', TFhirQuantity(elem.rate)) ;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseMedicationAdministration(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationAdministration(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationAdministration(jsn : TJsonObject) : TFhirMedicationAdministration;
begin
  result := TFhirMedicationAdministration.create;
  try
    ParseMedicationAdministrationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicationAdministrationProperties(jsn : TJsonObject; result : TFhirMedicationAdministration);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
      if jsn.has('instantiates') or jsn.has('_instantiates') then
      iteratePrimitiveArray(jsn.vArr['instantiates'], jsn.vArr['_instantiates'], result.instantiatesList, parseUri);
    if jsn.has('partOf') then
      iterateArray(jsn.vArr['partOf'], result.partOfList, parseReference{TFhirMedicationAdministration});
    if jsn.has('status') or jsn.has('_status')  then
        result.statusElement := parseCode(jsn.node['status'], jsn.vObj['_status']);{q}
    if jsn.has('statusReason') then
      iterateArray(jsn.vArr['statusReason'], result.statusReasonList, parseCodeableConcept);
    if jsn.has('category') then
        result.category := ParseCodeableConcept(jsn.vObj['category']);{q3}
    if jsn.has('medicationCodeableConcept') {a4} then
      result.medication := ParseCodeableConcept(jsn.vObj['medicationCodeableConcept']);
    if jsn.has('medicationReference') {a3} then
      result.medication := ParseReference(jsn.vObj['medicationReference']);
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirPatient}(jsn.vObj['subject']);{q3}
    if jsn.has('context') then
        result.context := ParseReference{TFhirEncounter}(jsn.vObj['context']);{q3}
    if jsn.has('supportingInformation') then
      iterateArray(jsn.vArr['supportingInformation'], result.supportingInformationList, parseReference{TFhirReference});
    if jsn.has('effectivePeriod') {a4} then
      result.effective := ParsePeriod(jsn.vObj['effectivePeriod']);
    if jsn.has('effectiveDateTime') or jsn.has('_effectiveDateTime') then
      result.effective := parseDateTime(jsn.node['effectiveDateTime'], jsn.vObj['_effectiveDateTime']);
    if jsn.has('performer') then
      iterateArray(jsn.vArr['performer'], result.performerList, parseMedicationAdministrationPerformer);
    if jsn.has('reasonCode') then
      iterateArray(jsn.vArr['reasonCode'], result.reasonCodeList, parseCodeableConcept);
    if jsn.has('reasonReference') then
      iterateArray(jsn.vArr['reasonReference'], result.reasonReferenceList, parseReference{TFhirCondition});
    if jsn.has('request') then
        result.request := ParseReference{TFhirMedicationRequest}(jsn.vObj['request']);{q3}
    if jsn.has('device') then
      iterateArray(jsn.vArr['device'], result.deviceList, parseReference{TFhirDevice});
    if jsn.has('note') then
      iterateArray(jsn.vArr['note'], result.noteList, parseAnnotation);
    if jsn.has('dosage') then
        result.dosage := ParseMedicationAdministrationDosage(jsn.vObj['dosage']);{q3}
    if jsn.has('eventHistory') then
      iterateArray(jsn.vArr['eventHistory'], result.eventHistoryList, parseReference{TFhirProvenance});
end;

procedure TFHIRJsonComposer.ComposeMedicationAdministration(json : TJSONWriter; name : string; elem : TFhirMedicationAdministration; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('instantiates') and (elem.instantiatesList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.instantiatesList.Count - 1 do
    begin
      ext := ext or ((elem.instantiatesList[i].id <> '') or (elem.instantiatesList[i].hasExtensionList) {no-comments or (elem.instantiatesList[i].hasComments)});
      val := val or (elem.instantiatesList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('instantiates');
      for i := 0 to elem.instantiatesList.Count - 1 do
        ComposeUriValue(json, '',elem.instantiatesList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_instantiates');
      for i := 0 to elem.instantiatesList.Count - 1 do
        ComposeUriProps(json, '',elem.instantiatesList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('partOf') and (elem.partOfList.Count > 0) then
  begin
    json.valueArray('partOf');
    for i := 0 to elem.partOfList.Count - 1 do
      ComposeReference{TFhirMedicationAdministration}(json, '', elem.partOfList[i]); {z - Reference(MedicationAdministration)}
    json.FinishArray;
  end;
  ComposeCodeValue(json, 'status', elem.statusElement, false);
  ComposeCodeProps(json, 'status', elem.statusElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('statusReason') and (elem.statusReasonList.Count > 0) then
  begin
    json.valueArray('statusReason');
    for i := 0 to elem.statusReasonList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.statusReasonList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('category') then
    ComposeCodeableConcept(json, 'category', elem.category); {a}
  if (elem.medication is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'medicationCodeableConcept', TFhirCodeableConcept(elem.medication)) 
  else if (elem.medication is TFhirReference) then
    ComposeReference(json, 'medicationReference', TFhirReference(elem.medication));
  ComposeReference{TFhirPatient}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('context') then
    ComposeReference{TFhirEncounter}(json, 'context', elem.context); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('supportingInformation') and (elem.supportingInformationList.Count > 0) then
  begin
    json.valueArray('supportingInformation');
    for i := 0 to elem.supportingInformationList.Count - 1 do
      ComposeReference{TFhirReference}(json, '', elem.supportingInformationList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
  if (elem.effective is TFhirPeriod) then 
    ComposePeriod(json, 'effectivePeriod', TFhirPeriod(elem.effective)) 
  else if (elem.effective is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'effectiveDateTime', TFhirDateTime(elem.effective), false);
    ComposeDateTimeProps(json, 'effectiveDateTime', TFhirDateTime(elem.effective), false);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('performer') and (elem.performerList.Count > 0) then
  begin
    json.valueArray('performer');
    for i := 0 to elem.performerList.Count - 1 do
      ComposeMedicationAdministrationPerformer(json, '', elem.performerList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('reasonCode') and (elem.reasonCodeList.Count > 0) then
  begin
    json.valueArray('reasonCode');
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.reasonCodeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('reasonReference') and (elem.reasonReferenceList.Count > 0) then
  begin
    json.valueArray('reasonReference');
    for i := 0 to elem.reasonReferenceList.Count - 1 do
      ComposeReference{TFhirCondition}(json, '', elem.reasonReferenceList[i]); {z - Reference(Condition)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('request') then
    ComposeReference{TFhirMedicationRequest}(json, 'request', elem.request); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('device') and (elem.deviceList.Count > 0) then
  begin
    json.valueArray('device');
    for i := 0 to elem.deviceList.Count - 1 do
      ComposeReference{TFhirDevice}(json, '', elem.deviceList[i]); {z - Reference(Device)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('note') and (elem.noteList.Count > 0) then
  begin
    json.valueArray('note');
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(json, '', elem.noteList[i]); {z - Annotation}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('dosage') then
    ComposeMedicationAdministrationDosage(json, 'dosage', elem.dosage); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('eventHistory') and (elem.eventHistoryList.Count > 0) then
  begin
    json.valueArray('eventHistory');
    for i := 0 to elem.eventHistoryList.Count - 1 do
      ComposeReference{TFhirProvenance}(json, '', elem.eventHistoryList[i]); {z - Reference(Provenance)}
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_MEDICATIONADMINISTRATION}
{$IFDEF FHIR_MEDICATIONDISPENSE}
procedure TFHIRJsonParser.ParseMedicationDispensePerformer(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationDispensePerformer(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationDispensePerformer(jsn : TJsonObject) : TFhirMedicationDispensePerformer;
begin
  result := TFhirMedicationDispensePerformer.create;
  try
    ParseMedicationDispensePerformerProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicationDispensePerformerProperties(jsn : TJsonObject; result : TFhirMedicationDispensePerformer);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('function') then
        result.function_ := ParseCodeableConcept(jsn.vObj['function']);{q3}
    if jsn.has('actor') then
        result.actor := ParseReference{TFhirPractitioner}(jsn.vObj['actor']);{q3}
end;

procedure TFHIRJsonComposer.ComposeMedicationDispensePerformer(json : TJSONWriter; name : string; elem : TFhirMedicationDispensePerformer; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'function', elem.function_); {a}
  ComposeReference{TFhirPractitioner}(json, 'actor', elem.actor); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseMedicationDispenseSubstitution(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationDispenseSubstitution(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationDispenseSubstitution(jsn : TJsonObject) : TFhirMedicationDispenseSubstitution;
begin
  result := TFhirMedicationDispenseSubstitution.create;
  try
    ParseMedicationDispenseSubstitutionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicationDispenseSubstitutionProperties(jsn : TJsonObject; result : TFhirMedicationDispenseSubstitution);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('wasSubstituted') or jsn.has('_wasSubstituted') then
        result.wasSubstitutedElement := parseBoolean(jsn.node['wasSubstituted'], jsn.vObj['_wasSubstituted']);{q}
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('reason') then
      iterateArray(jsn.vArr['reason'], result.reasonList, parseCodeableConcept);
    if jsn.has('responsibleParty') then
      iterateArray(jsn.vArr['responsibleParty'], result.responsiblePartyList, parseReference{TFhirPractitioner});
end;

procedure TFHIRJsonComposer.ComposeMedicationDispenseSubstitution(json : TJSONWriter; name : string; elem : TFhirMedicationDispenseSubstitution; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeBooleanValue(json, 'wasSubstituted', elem.wasSubstitutedElement, false);
  ComposeBooleanProps(json, 'wasSubstituted', elem.wasSubstitutedElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) and (elem.reasonList.Count > 0) then
  begin
    json.valueArray('reason');
    for i := 0 to elem.reasonList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.reasonList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.responsiblePartyList.Count > 0) then
  begin
    json.valueArray('responsibleParty');
    for i := 0 to elem.responsiblePartyList.Count - 1 do
      ComposeReference{TFhirPractitioner}(json, '', elem.responsiblePartyList[i]); {z - Reference(Practitioner)}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseMedicationDispense(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationDispense(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationDispense(jsn : TJsonObject) : TFhirMedicationDispense;
begin
  result := TFhirMedicationDispense.create;
  try
    ParseMedicationDispenseProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicationDispenseProperties(jsn : TJsonObject; result : TFhirMedicationDispense);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('partOf') then
      iterateArray(jsn.vArr['partOf'], result.partOfList, parseReference{TFhirProcedure});
    if jsn.has('status') or jsn.has('_status')  then
        result.statusElement := parseCode(jsn.node['status'], jsn.vObj['_status']);{q}
    if jsn.has('statusReasonCodeableConcept') {a4} then
      result.statusReason := ParseCodeableConcept(jsn.vObj['statusReasonCodeableConcept']);
    if jsn.has('statusReasonReference') {a3} then
      result.statusReason := ParseReference(jsn.vObj['statusReasonReference']);
    if jsn.has('category') then
        result.category := ParseCodeableConcept(jsn.vObj['category']);{q3}
    if jsn.has('medicationCodeableConcept') {a4} then
      result.medication := ParseCodeableConcept(jsn.vObj['medicationCodeableConcept']);
    if jsn.has('medicationReference') {a3} then
      result.medication := ParseReference(jsn.vObj['medicationReference']);
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirPatient}(jsn.vObj['subject']);{q3}
    if jsn.has('context') then
        result.context := ParseReference{TFhirEncounter}(jsn.vObj['context']);{q3}
    if jsn.has('supportingInformation') then
      iterateArray(jsn.vArr['supportingInformation'], result.supportingInformationList, parseReference{TFhirReference});
    if jsn.has('performer') then
      iterateArray(jsn.vArr['performer'], result.performerList, parseMedicationDispensePerformer);
    if jsn.has('location') then
        result.location := ParseReference{TFhirLocation}(jsn.vObj['location']);{q3}
    if jsn.has('authorizingPrescription') then
      iterateArray(jsn.vArr['authorizingPrescription'], result.authorizingPrescriptionList, parseReference{TFhirMedicationRequest});
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q3}
    if jsn.has('daysSupply') then
        result.daysSupply := ParseQuantity(jsn.vObj['daysSupply']);{q3}
    if jsn.has('whenPrepared') or jsn.has('_whenPrepared') then
        result.whenPreparedElement := parseDateTime(jsn.node['whenPrepared'], jsn.vObj['_whenPrepared']);{q}
    if jsn.has('whenHandedOver') or jsn.has('_whenHandedOver') then
        result.whenHandedOverElement := parseDateTime(jsn.node['whenHandedOver'], jsn.vObj['_whenHandedOver']);{q}
    if jsn.has('destination') then
        result.destination := ParseReference{TFhirLocation}(jsn.vObj['destination']);{q3}
    if jsn.has('receiver') then
      iterateArray(jsn.vArr['receiver'], result.receiverList, parseReference{TFhirPatient});
    if jsn.has('note') then
      iterateArray(jsn.vArr['note'], result.noteList, parseAnnotation);
    if jsn.has('dosageInstruction') then
      iterateArray(jsn.vArr['dosageInstruction'], result.dosageInstructionList, parseDosage);
    if jsn.has('substitution') then
        result.substitution := ParseMedicationDispenseSubstitution(jsn.vObj['substitution']);{q3}
    if jsn.has('detectedIssue') then
      iterateArray(jsn.vArr['detectedIssue'], result.detectedIssueList, parseReference{TFhirDetectedIssue});
    if jsn.has('eventHistory') then
      iterateArray(jsn.vArr['eventHistory'], result.eventHistoryList, parseReference{TFhirProvenance});
end;

procedure TFHIRJsonComposer.ComposeMedicationDispense(json : TJSONWriter; name : string; elem : TFhirMedicationDispense; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('partOf') and (elem.partOfList.Count > 0) then
  begin
    json.valueArray('partOf');
    for i := 0 to elem.partOfList.Count - 1 do
      ComposeReference{TFhirProcedure}(json, '', elem.partOfList[i]); {z - Reference(Procedure)}
    json.FinishArray;
  end;
  ComposeCodeValue(json, 'status', elem.statusElement, false);
  ComposeCodeProps(json, 'status', elem.statusElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.statusReason is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'statusReasonCodeableConcept', TFhirCodeableConcept(elem.statusReason)) 
  else if (SummaryOption in [soFull, soData]) and (elem.statusReason is TFhirReference) then
    ComposeReference(json, 'statusReasonReference', TFhirReference(elem.statusReason));
  if (SummaryOption in [soFull, soData]) and doCompose('category') then
    ComposeCodeableConcept(json, 'category', elem.category); {a}
  if (elem.medication is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'medicationCodeableConcept', TFhirCodeableConcept(elem.medication)) 
  else if (elem.medication is TFhirReference) then
    ComposeReference(json, 'medicationReference', TFhirReference(elem.medication));
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{TFhirPatient}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('context') then
    ComposeReference{TFhirEncounter}(json, 'context', elem.context); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('supportingInformation') and (elem.supportingInformationList.Count > 0) then
  begin
    json.valueArray('supportingInformation');
    for i := 0 to elem.supportingInformationList.Count - 1 do
      ComposeReference{TFhirReference}(json, '', elem.supportingInformationList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('performer') and (elem.performerList.Count > 0) then
  begin
    json.valueArray('performer');
    for i := 0 to elem.performerList.Count - 1 do
      ComposeMedicationDispensePerformer(json, '', elem.performerList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('location') then
    ComposeReference{TFhirLocation}(json, 'location', elem.location); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('authorizingPrescription') and (elem.authorizingPrescriptionList.Count > 0) then
  begin
    json.valueArray('authorizingPrescription');
    for i := 0 to elem.authorizingPrescriptionList.Count - 1 do
      ComposeReference{TFhirMedicationRequest}(json, '', elem.authorizingPrescriptionList[i]); {z - Reference(MedicationRequest)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('type_') then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('quantity') then
    ComposeQuantity(json, 'quantity', elem.quantity); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('daysSupply') then
    ComposeQuantity(json, 'daysSupply', elem.daysSupply); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('whenPrepared') then
    ComposeDateTimeValue(json, 'whenPrepared', elem.whenPreparedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('whenPrepared') then
    ComposeDateTimeProps(json, 'whenPrepared', elem.whenPreparedElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('whenHandedOver') then
    ComposeDateTimeValue(json, 'whenHandedOver', elem.whenHandedOverElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('whenHandedOver') then
    ComposeDateTimeProps(json, 'whenHandedOver', elem.whenHandedOverElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('destination') then
    ComposeReference{TFhirLocation}(json, 'destination', elem.destination); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('receiver') and (elem.receiverList.Count > 0) then
  begin
    json.valueArray('receiver');
    for i := 0 to elem.receiverList.Count - 1 do
      ComposeReference{TFhirPatient}(json, '', elem.receiverList[i]); {z - Reference(Patient)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('note') and (elem.noteList.Count > 0) then
  begin
    json.valueArray('note');
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(json, '', elem.noteList[i]); {z - Annotation}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('dosageInstruction') and (elem.dosageInstructionList.Count > 0) then
  begin
    json.valueArray('dosageInstruction');
    for i := 0 to elem.dosageInstructionList.Count - 1 do
      ComposeDosage(json, '', elem.dosageInstructionList[i]); {z - Dosage}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('substitution') then
    ComposeMedicationDispenseSubstitution(json, 'substitution', elem.substitution); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('detectedIssue') and (elem.detectedIssueList.Count > 0) then
  begin
    json.valueArray('detectedIssue');
    for i := 0 to elem.detectedIssueList.Count - 1 do
      ComposeReference{TFhirDetectedIssue}(json, '', elem.detectedIssueList[i]); {z - Reference(DetectedIssue)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('eventHistory') and (elem.eventHistoryList.Count > 0) then
  begin
    json.valueArray('eventHistory');
    for i := 0 to elem.eventHistoryList.Count - 1 do
      ComposeReference{TFhirProvenance}(json, '', elem.eventHistoryList[i]); {z - Reference(Provenance)}
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_MEDICATIONDISPENSE}
{$IFDEF FHIR_MEDICATIONKNOWLEDGE}
procedure TFHIRJsonParser.ParseMedicationKnowledgeRelatedMedicationKnowledge(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationKnowledgeRelatedMedicationKnowledge(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationKnowledgeRelatedMedicationKnowledge(jsn : TJsonObject) : TFhirMedicationKnowledgeRelatedMedicationKnowledge;
begin
  result := TFhirMedicationKnowledgeRelatedMedicationKnowledge.create;
  try
    ParseMedicationKnowledgeRelatedMedicationKnowledgeProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicationKnowledgeRelatedMedicationKnowledgeProperties(jsn : TJsonObject; result : TFhirMedicationKnowledgeRelatedMedicationKnowledge);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('reference') then
      iterateArray(jsn.vArr['reference'], result.referenceList, parseReference{TFhirMedicationKnowledge});
end;

procedure TFHIRJsonComposer.ComposeMedicationKnowledgeRelatedMedicationKnowledge(json : TJSONWriter; name : string; elem : TFhirMedicationKnowledgeRelatedMedicationKnowledge; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (elem.referenceList.Count > 0) then
  begin
    json.valueArray('reference');
    for i := 0 to elem.referenceList.Count - 1 do
      ComposeReference{TFhirMedicationKnowledge}(json, '', elem.referenceList[i]); {z - Reference(MedicationKnowledge)}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseMedicationKnowledgeMonograph(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationKnowledgeMonograph(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationKnowledgeMonograph(jsn : TJsonObject) : TFhirMedicationKnowledgeMonograph;
begin
  result := TFhirMedicationKnowledgeMonograph.create;
  try
    ParseMedicationKnowledgeMonographProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicationKnowledgeMonographProperties(jsn : TJsonObject; result : TFhirMedicationKnowledgeMonograph);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('source') then
        result.source := ParseReference{TFhirDocumentReference}(jsn.vObj['source']);{q3}
end;

procedure TFHIRJsonComposer.ComposeMedicationKnowledgeMonograph(json : TJSONWriter; name : string; elem : TFhirMedicationKnowledgeMonograph; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirDocumentReference}(json, 'source', elem.source); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseMedicationKnowledgeIngredient(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationKnowledgeIngredient(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationKnowledgeIngredient(jsn : TJsonObject) : TFhirMedicationKnowledgeIngredient;
begin
  result := TFhirMedicationKnowledgeIngredient.create;
  try
    ParseMedicationKnowledgeIngredientProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicationKnowledgeIngredientProperties(jsn : TJsonObject; result : TFhirMedicationKnowledgeIngredient);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('itemCodeableConcept') {a4} then
      result.item := ParseCodeableConcept(jsn.vObj['itemCodeableConcept']);
    if jsn.has('itemReference') {a3} then
      result.item := ParseReference(jsn.vObj['itemReference']);
    if jsn.has('isActive') or jsn.has('_isActive') then
        result.isActiveElement := parseBoolean(jsn.node['isActive'], jsn.vObj['_isActive']);{q}
    if jsn.has('strength') then
        result.strength := ParseRatio(jsn.vObj['strength']);{q3}
end;

procedure TFHIRJsonComposer.ComposeMedicationKnowledgeIngredient(json : TJSONWriter; name : string; elem : TFhirMedicationKnowledgeIngredient; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (elem.item is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'itemCodeableConcept', TFhirCodeableConcept(elem.item)) 
  else if (elem.item is TFhirReference) then
    ComposeReference(json, 'itemReference', TFhirReference(elem.item));
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'isActive', elem.isActiveElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'isActive', elem.isActiveElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeRatio(json, 'strength', elem.strength); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseMedicationKnowledgeCost(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationKnowledgeCost(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationKnowledgeCost(jsn : TJsonObject) : TFhirMedicationKnowledgeCost;
begin
  result := TFhirMedicationKnowledgeCost.create;
  try
    ParseMedicationKnowledgeCostProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicationKnowledgeCostProperties(jsn : TJsonObject; result : TFhirMedicationKnowledgeCost);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('source') or jsn.has('_source') then
        result.sourceElement := parseString(jsn.node['source'], jsn.vObj['_source']);{q}
    if jsn.has('cost') then
        result.cost := ParseMoney(jsn.vObj['cost']);{q3}
end;

procedure TFHIRJsonComposer.ComposeMedicationKnowledgeCost(json : TJSONWriter; name : string; elem : TFhirMedicationKnowledgeCost; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'source', elem.sourceElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'source', elem.sourceElement, false);
  ComposeMoney(json, 'cost', elem.cost); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseMedicationKnowledgeMonitoringProgram(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationKnowledgeMonitoringProgram(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationKnowledgeMonitoringProgram(jsn : TJsonObject) : TFhirMedicationKnowledgeMonitoringProgram;
begin
  result := TFhirMedicationKnowledgeMonitoringProgram.create;
  try
    ParseMedicationKnowledgeMonitoringProgramProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicationKnowledgeMonitoringProgramProperties(jsn : TJsonObject; result : TFhirMedicationKnowledgeMonitoringProgram);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
end;

procedure TFHIRJsonComposer.ComposeMedicationKnowledgeMonitoringProgram(json : TJSONWriter; name : string; elem : TFhirMedicationKnowledgeMonitoringProgram; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseMedicationKnowledgeAdministrationGuidelines(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationKnowledgeAdministrationGuidelines(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationKnowledgeAdministrationGuidelines(jsn : TJsonObject) : TFhirMedicationKnowledgeAdministrationGuidelines;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelines.create;
  try
    ParseMedicationKnowledgeAdministrationGuidelinesProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicationKnowledgeAdministrationGuidelinesProperties(jsn : TJsonObject; result : TFhirMedicationKnowledgeAdministrationGuidelines);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('dosage') then
      iterateArray(jsn.vArr['dosage'], result.dosageList, parseMedicationKnowledgeAdministrationGuidelinesDosage);
    if jsn.has('indicationCodeableConcept') {a4} then
      result.indication := ParseCodeableConcept(jsn.vObj['indicationCodeableConcept']);
    if jsn.has('indicationReference') {a3} then
      result.indication := ParseReference(jsn.vObj['indicationReference']);
    if jsn.has('patientCharacteristics') then
      iterateArray(jsn.vArr['patientCharacteristics'], result.patientCharacteristicsList, parseMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics);
end;

procedure TFHIRJsonComposer.ComposeMedicationKnowledgeAdministrationGuidelines(json : TJSONWriter; name : string; elem : TFhirMedicationKnowledgeAdministrationGuidelines; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and (elem.dosageList.Count > 0) then
  begin
    json.valueArray('dosage');
    for i := 0 to elem.dosageList.Count - 1 do
      ComposeMedicationKnowledgeAdministrationGuidelinesDosage(json, '', elem.dosageList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.indication is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'indicationCodeableConcept', TFhirCodeableConcept(elem.indication)) 
  else if (SummaryOption in [soFull, soData]) and (elem.indication is TFhirReference) then
    ComposeReference(json, 'indicationReference', TFhirReference(elem.indication));
  if (SummaryOption in [soFull, soData]) and (elem.patientCharacteristicsList.Count > 0) then
  begin
    json.valueArray('patientCharacteristics');
    for i := 0 to elem.patientCharacteristicsList.Count - 1 do
      ComposeMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics(json, '', elem.patientCharacteristicsList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseMedicationKnowledgeAdministrationGuidelinesDosage(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationKnowledgeAdministrationGuidelinesDosage(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationKnowledgeAdministrationGuidelinesDosage(jsn : TJsonObject) : TFhirMedicationKnowledgeAdministrationGuidelinesDosage;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelinesDosage.create;
  try
    ParseMedicationKnowledgeAdministrationGuidelinesDosageProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicationKnowledgeAdministrationGuidelinesDosageProperties(jsn : TJsonObject; result : TFhirMedicationKnowledgeAdministrationGuidelinesDosage);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('dosage') then
      iterateArray(jsn.vArr['dosage'], result.dosageList, parseDosage);
end;

procedure TFHIRJsonComposer.ComposeMedicationKnowledgeAdministrationGuidelinesDosage(json : TJSONWriter; name : string; elem : TFhirMedicationKnowledgeAdministrationGuidelinesDosage; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (elem.dosageList.Count > 0) then
  begin
    json.valueArray('dosage');
    for i := 0 to elem.dosageList.Count - 1 do
      ComposeDosage(json, '', elem.dosageList[i]); {z - Dosage}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics(jsn : TJsonObject) : TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics.create;
  try
    ParseMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsProperties(jsn : TJsonObject; result : TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('characteristicCodeableConcept') {a4} then
      result.characteristic := ParseCodeableConcept(jsn.vObj['characteristicCodeableConcept']);
    if jsn.has('characteristicQuantity') {a4} then
      result.characteristic := ParseQuantity(jsn.vObj['characteristicQuantity']);
      if jsn.has('value') or jsn.has('_value') then
      iteratePrimitiveArray(jsn.vArr['value'], jsn.vArr['_value'], result.valueList, parseString);
end;

procedure TFHIRJsonComposer.ComposeMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics(json : TJSONWriter; name : string; elem : TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (elem.characteristic is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'characteristicCodeableConcept', TFhirCodeableConcept(elem.characteristic)) 
  else if (elem.characteristic is TFhirQuantity) then 
    ComposeQuantity(json, 'characteristicQuantity', TFhirQuantity(elem.characteristic)) ;
  if (SummaryOption in [soFull, soData]) and (elem.valueList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.valueList.Count - 1 do
    begin
      ext := ext or ((elem.valueList[i].id <> '') or (elem.valueList[i].hasExtensionList) {no-comments or (elem.valueList[i].hasComments)});
      val := val or (elem.valueList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('value');
      for i := 0 to elem.valueList.Count - 1 do
        ComposeStringValue(json, '',elem.valueList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_value');
      for i := 0 to elem.valueList.Count - 1 do
        ComposeStringProps(json, '',elem.valueList[i], true);
      json.FinishArray;
    end;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseMedicationKnowledgeMedicineClassification(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationKnowledgeMedicineClassification(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationKnowledgeMedicineClassification(jsn : TJsonObject) : TFhirMedicationKnowledgeMedicineClassification;
begin
  result := TFhirMedicationKnowledgeMedicineClassification.create;
  try
    ParseMedicationKnowledgeMedicineClassificationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicationKnowledgeMedicineClassificationProperties(jsn : TJsonObject; result : TFhirMedicationKnowledgeMedicineClassification);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('classification') then
      iterateArray(jsn.vArr['classification'], result.classificationList, parseCodeableConcept);
end;

procedure TFHIRJsonComposer.ComposeMedicationKnowledgeMedicineClassification(json : TJSONWriter; name : string; elem : TFhirMedicationKnowledgeMedicineClassification; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) and (elem.classificationList.Count > 0) then
  begin
    json.valueArray('classification');
    for i := 0 to elem.classificationList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.classificationList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseMedicationKnowledgePackaging(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationKnowledgePackaging(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationKnowledgePackaging(jsn : TJsonObject) : TFhirMedicationKnowledgePackaging;
begin
  result := TFhirMedicationKnowledgePackaging.create;
  try
    ParseMedicationKnowledgePackagingProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicationKnowledgePackagingProperties(jsn : TJsonObject; result : TFhirMedicationKnowledgePackaging);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q3}
end;

procedure TFHIRJsonComposer.ComposeMedicationKnowledgePackaging(json : TJSONWriter; name : string; elem : TFhirMedicationKnowledgePackaging; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'quantity', elem.quantity); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseMedicationKnowledgeDrugCharacteristic(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationKnowledgeDrugCharacteristic(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationKnowledgeDrugCharacteristic(jsn : TJsonObject) : TFhirMedicationKnowledgeDrugCharacteristic;
begin
  result := TFhirMedicationKnowledgeDrugCharacteristic.create;
  try
    ParseMedicationKnowledgeDrugCharacteristicProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicationKnowledgeDrugCharacteristicProperties(jsn : TJsonObject; result : TFhirMedicationKnowledgeDrugCharacteristic);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('valueCodeableConcept') {a4} then
      result.value := ParseCodeableConcept(jsn.vObj['valueCodeableConcept']);
    if jsn.has('valueQuantity') {a4} then
      result.value := ParseQuantity(jsn.vObj['valueQuantity']);
    if jsn.has('valueString') or jsn.has('_valueString') then
      result.value := parseString(jsn.node['valueString'], jsn.vObj['_valueString']);
    if jsn.has('valueBase64Binary') or jsn.has('_valueBase64Binary') then
      result.value := parseBase64Binary(jsn.node['valueBase64Binary'], jsn.vObj['_valueBase64Binary']);
end;

procedure TFHIRJsonComposer.ComposeMedicationKnowledgeDrugCharacteristic(json : TJSONWriter; name : string; elem : TFhirMedicationKnowledgeDrugCharacteristic; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) and (elem.value is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'valueCodeableConcept', TFhirCodeableConcept(elem.value)) 
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirQuantity) then 
    ComposeQuantity(json, 'valueQuantity', TFhirQuantity(elem.value)) 
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirString) then 
  begin
    ComposeStringValue(json, 'valueString', TFhirString(elem.value), false);
    ComposeStringProps(json, 'valueString', TFhirString(elem.value), false);
  end
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirBase64Binary) then 
  begin
    ComposeBase64BinaryValue(json, 'valueBase64Binary', TFhirBase64Binary(elem.value), false);
    ComposeBase64BinaryProps(json, 'valueBase64Binary', TFhirBase64Binary(elem.value), false);
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseMedicationKnowledgeRegulatory(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationKnowledgeRegulatory(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationKnowledgeRegulatory(jsn : TJsonObject) : TFhirMedicationKnowledgeRegulatory;
begin
  result := TFhirMedicationKnowledgeRegulatory.create;
  try
    ParseMedicationKnowledgeRegulatoryProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicationKnowledgeRegulatoryProperties(jsn : TJsonObject; result : TFhirMedicationKnowledgeRegulatory);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('regulatoryAuthority') then
        result.regulatoryAuthority := ParseReference{TFhirOrganization}(jsn.vObj['regulatoryAuthority']);{q3}
    if jsn.has('substitution') then
      iterateArray(jsn.vArr['substitution'], result.substitutionList, parseMedicationKnowledgeRegulatorySubstitution);
    if jsn.has('schedule') then
      iterateArray(jsn.vArr['schedule'], result.scheduleList, parseMedicationKnowledgeRegulatorySchedule);
    if jsn.has('maxDispense') then
        result.maxDispense := ParseMedicationKnowledgeRegulatoryMaxDispense(jsn.vObj['maxDispense']);{q3}
end;

procedure TFHIRJsonComposer.ComposeMedicationKnowledgeRegulatory(json : TJSONWriter; name : string; elem : TFhirMedicationKnowledgeRegulatory; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeReference{TFhirOrganization}(json, 'regulatoryAuthority', elem.regulatoryAuthority); {a}
  if (SummaryOption in [soFull, soData]) and (elem.substitutionList.Count > 0) then
  begin
    json.valueArray('substitution');
    for i := 0 to elem.substitutionList.Count - 1 do
      ComposeMedicationKnowledgeRegulatorySubstitution(json, '', elem.substitutionList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.scheduleList.Count > 0) then
  begin
    json.valueArray('schedule');
    for i := 0 to elem.scheduleList.Count - 1 do
      ComposeMedicationKnowledgeRegulatorySchedule(json, '', elem.scheduleList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeMedicationKnowledgeRegulatoryMaxDispense(json, 'maxDispense', elem.maxDispense); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseMedicationKnowledgeRegulatorySubstitution(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationKnowledgeRegulatorySubstitution(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationKnowledgeRegulatorySubstitution(jsn : TJsonObject) : TFhirMedicationKnowledgeRegulatorySubstitution;
begin
  result := TFhirMedicationKnowledgeRegulatorySubstitution.create;
  try
    ParseMedicationKnowledgeRegulatorySubstitutionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicationKnowledgeRegulatorySubstitutionProperties(jsn : TJsonObject; result : TFhirMedicationKnowledgeRegulatorySubstitution);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('allowed') or jsn.has('_allowed') then
        result.allowedElement := parseBoolean(jsn.node['allowed'], jsn.vObj['_allowed']);{q}
end;

procedure TFHIRJsonComposer.ComposeMedicationKnowledgeRegulatorySubstitution(json : TJSONWriter; name : string; elem : TFhirMedicationKnowledgeRegulatorySubstitution; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  ComposeBooleanValue(json, 'allowed', elem.allowedElement, false);
  ComposeBooleanProps(json, 'allowed', elem.allowedElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseMedicationKnowledgeRegulatorySchedule(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationKnowledgeRegulatorySchedule(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationKnowledgeRegulatorySchedule(jsn : TJsonObject) : TFhirMedicationKnowledgeRegulatorySchedule;
begin
  result := TFhirMedicationKnowledgeRegulatorySchedule.create;
  try
    ParseMedicationKnowledgeRegulatoryScheduleProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicationKnowledgeRegulatoryScheduleProperties(jsn : TJsonObject; result : TFhirMedicationKnowledgeRegulatorySchedule);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('schedule') then
        result.schedule := ParseCodeableConcept(jsn.vObj['schedule']);{q3}
end;

procedure TFHIRJsonComposer.ComposeMedicationKnowledgeRegulatorySchedule(json : TJSONWriter; name : string; elem : TFhirMedicationKnowledgeRegulatorySchedule; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'schedule', elem.schedule); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseMedicationKnowledgeRegulatoryMaxDispense(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationKnowledgeRegulatoryMaxDispense(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationKnowledgeRegulatoryMaxDispense(jsn : TJsonObject) : TFhirMedicationKnowledgeRegulatoryMaxDispense;
begin
  result := TFhirMedicationKnowledgeRegulatoryMaxDispense.create;
  try
    ParseMedicationKnowledgeRegulatoryMaxDispenseProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicationKnowledgeRegulatoryMaxDispenseProperties(jsn : TJsonObject; result : TFhirMedicationKnowledgeRegulatoryMaxDispense);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q3}
    if jsn.has('period') then
        result.period := ParseDuration(jsn.vObj['period']);{q3}
end;

procedure TFHIRJsonComposer.ComposeMedicationKnowledgeRegulatoryMaxDispense(json : TJSONWriter; name : string; elem : TFhirMedicationKnowledgeRegulatoryMaxDispense; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeQuantity(json, 'quantity', elem.quantity); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeDuration(json, 'period', elem.period); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseMedicationKnowledgeKinetics(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationKnowledgeKinetics(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationKnowledgeKinetics(jsn : TJsonObject) : TFhirMedicationKnowledgeKinetics;
begin
  result := TFhirMedicationKnowledgeKinetics.create;
  try
    ParseMedicationKnowledgeKineticsProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicationKnowledgeKineticsProperties(jsn : TJsonObject; result : TFhirMedicationKnowledgeKinetics);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('areaUnderCurve') then
      iterateArray(jsn.vArr['areaUnderCurve'], result.areaUnderCurveList, parseQuantity);
    if jsn.has('lethalDose50') then
      iterateArray(jsn.vArr['lethalDose50'], result.lethalDose50List, parseQuantity);
    if jsn.has('halfLifePeriod') then
        result.halfLifePeriod := ParseDuration(jsn.vObj['halfLifePeriod']);{q3}
end;

procedure TFHIRJsonComposer.ComposeMedicationKnowledgeKinetics(json : TJSONWriter; name : string; elem : TFhirMedicationKnowledgeKinetics; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and (elem.areaUnderCurveList.Count > 0) then
  begin
    json.valueArray('areaUnderCurve');
    for i := 0 to elem.areaUnderCurveList.Count - 1 do
      ComposeQuantity(json, '', elem.areaUnderCurveList[i]); {z - Quantity}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.lethalDose50List.Count > 0) then
  begin
    json.valueArray('lethalDose50');
    for i := 0 to elem.lethalDose50List.Count - 1 do
      ComposeQuantity(json, '', elem.lethalDose50List[i]); {z - Quantity}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeDuration(json, 'halfLifePeriod', elem.halfLifePeriod); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseMedicationKnowledge(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationKnowledge(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationKnowledge(jsn : TJsonObject) : TFhirMedicationKnowledge;
begin
  result := TFhirMedicationKnowledge.create;
  try
    ParseMedicationKnowledgeProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicationKnowledgeProperties(jsn : TJsonObject; result : TFhirMedicationKnowledge);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('status') or jsn.has('_status')  then
        result.statusElement := parseCode(jsn.node['status'], jsn.vObj['_status']);{q}
    if jsn.has('manufacturer') then
        result.manufacturer := ParseReference{TFhirOrganization}(jsn.vObj['manufacturer']);{q3}
    if jsn.has('doseForm') then
        result.doseForm := ParseCodeableConcept(jsn.vObj['doseForm']);{q3}
    if jsn.has('amount') then
        result.amount := ParseQuantity(jsn.vObj['amount']);{q3}
      if jsn.has('synonym') or jsn.has('_synonym') then
      iteratePrimitiveArray(jsn.vArr['synonym'], jsn.vArr['_synonym'], result.synonymList, parseString);
    if jsn.has('relatedMedicationKnowledge') then
      iterateArray(jsn.vArr['relatedMedicationKnowledge'], result.relatedMedicationKnowledgeList, parseMedicationKnowledgeRelatedMedicationKnowledge);
    if jsn.has('associatedMedication') then
      iterateArray(jsn.vArr['associatedMedication'], result.associatedMedicationList, parseReference{TFhirMedication});
    if jsn.has('productType') then
      iterateArray(jsn.vArr['productType'], result.productTypeList, parseCodeableConcept);
    if jsn.has('monograph') then
      iterateArray(jsn.vArr['monograph'], result.monographList, parseMedicationKnowledgeMonograph);
    if jsn.has('ingredient') then
      iterateArray(jsn.vArr['ingredient'], result.ingredientList, parseMedicationKnowledgeIngredient);
    if jsn.has('preparationInstruction') or jsn.has('_preparationInstruction') then
        result.preparationInstructionElement := parseMarkdown(jsn.node['preparationInstruction'], jsn.vObj['_preparationInstruction']);{q}
    if jsn.has('intendedRoute') then
      iterateArray(jsn.vArr['intendedRoute'], result.intendedRouteList, parseCodeableConcept);
    if jsn.has('cost') then
      iterateArray(jsn.vArr['cost'], result.costList, parseMedicationKnowledgeCost);
    if jsn.has('monitoringProgram') then
      iterateArray(jsn.vArr['monitoringProgram'], result.monitoringProgramList, parseMedicationKnowledgeMonitoringProgram);
    if jsn.has('administrationGuidelines') then
      iterateArray(jsn.vArr['administrationGuidelines'], result.administrationGuidelinesList, parseMedicationKnowledgeAdministrationGuidelines);
    if jsn.has('medicineClassification') then
      iterateArray(jsn.vArr['medicineClassification'], result.medicineClassificationList, parseMedicationKnowledgeMedicineClassification);
    if jsn.has('packaging') then
        result.packaging := ParseMedicationKnowledgePackaging(jsn.vObj['packaging']);{q3}
    if jsn.has('drugCharacteristic') then
      iterateArray(jsn.vArr['drugCharacteristic'], result.drugCharacteristicList, parseMedicationKnowledgeDrugCharacteristic);
    if jsn.has('contraindication') then
      iterateArray(jsn.vArr['contraindication'], result.contraindicationList, parseReference{TFhirDetectedIssue});
    if jsn.has('regulatory') then
      iterateArray(jsn.vArr['regulatory'], result.regulatoryList, parseMedicationKnowledgeRegulatory);
    if jsn.has('kinetics') then
      iterateArray(jsn.vArr['kinetics'], result.kineticsList, parseMedicationKnowledgeKinetics);
end;

procedure TFHIRJsonComposer.ComposeMedicationKnowledge(json : TJSONWriter; name : string; elem : TFhirMedicationKnowledge; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') then
    ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeCodeValue(json, 'status', elem.statusElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeCodeProps(json, 'status', elem.statusElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('manufacturer') then
    ComposeReference{TFhirOrganization}(json, 'manufacturer', elem.manufacturer); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('doseForm') then
    ComposeCodeableConcept(json, 'doseForm', elem.doseForm); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('amount') then
    ComposeQuantity(json, 'amount', elem.amount); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('synonym') and (elem.synonymList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.synonymList.Count - 1 do
    begin
      ext := ext or ((elem.synonymList[i].id <> '') or (elem.synonymList[i].hasExtensionList) {no-comments or (elem.synonymList[i].hasComments)});
      val := val or (elem.synonymList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('synonym');
      for i := 0 to elem.synonymList.Count - 1 do
        ComposeStringValue(json, '',elem.synonymList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_synonym');
      for i := 0 to elem.synonymList.Count - 1 do
        ComposeStringProps(json, '',elem.synonymList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('relatedMedicationKnowledge') and (elem.relatedMedicationKnowledgeList.Count > 0) then
  begin
    json.valueArray('relatedMedicationKnowledge');
    for i := 0 to elem.relatedMedicationKnowledgeList.Count - 1 do
      ComposeMedicationKnowledgeRelatedMedicationKnowledge(json, '', elem.relatedMedicationKnowledgeList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('associatedMedication') and (elem.associatedMedicationList.Count > 0) then
  begin
    json.valueArray('associatedMedication');
    for i := 0 to elem.associatedMedicationList.Count - 1 do
      ComposeReference{TFhirMedication}(json, '', elem.associatedMedicationList[i]); {z - Reference(Medication)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('productType') and (elem.productTypeList.Count > 0) then
  begin
    json.valueArray('productType');
    for i := 0 to elem.productTypeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.productTypeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('monograph') and (elem.monographList.Count > 0) then
  begin
    json.valueArray('monograph');
    for i := 0 to elem.monographList.Count - 1 do
      ComposeMedicationKnowledgeMonograph(json, '', elem.monographList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('ingredient') and (elem.ingredientList.Count > 0) then
  begin
    json.valueArray('ingredient');
    for i := 0 to elem.ingredientList.Count - 1 do
      ComposeMedicationKnowledgeIngredient(json, '', elem.ingredientList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('preparationInstruction') then
    ComposeMarkdownValue(json, 'preparationInstruction', elem.preparationInstructionElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('preparationInstruction') then
    ComposeMarkdownProps(json, 'preparationInstruction', elem.preparationInstructionElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('intendedRoute') and (elem.intendedRouteList.Count > 0) then
  begin
    json.valueArray('intendedRoute');
    for i := 0 to elem.intendedRouteList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.intendedRouteList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('cost') and (elem.costList.Count > 0) then
  begin
    json.valueArray('cost');
    for i := 0 to elem.costList.Count - 1 do
      ComposeMedicationKnowledgeCost(json, '', elem.costList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('monitoringProgram') and (elem.monitoringProgramList.Count > 0) then
  begin
    json.valueArray('monitoringProgram');
    for i := 0 to elem.monitoringProgramList.Count - 1 do
      ComposeMedicationKnowledgeMonitoringProgram(json, '', elem.monitoringProgramList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('administrationGuidelines') and (elem.administrationGuidelinesList.Count > 0) then
  begin
    json.valueArray('administrationGuidelines');
    for i := 0 to elem.administrationGuidelinesList.Count - 1 do
      ComposeMedicationKnowledgeAdministrationGuidelines(json, '', elem.administrationGuidelinesList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('medicineClassification') and (elem.medicineClassificationList.Count > 0) then
  begin
    json.valueArray('medicineClassification');
    for i := 0 to elem.medicineClassificationList.Count - 1 do
      ComposeMedicationKnowledgeMedicineClassification(json, '', elem.medicineClassificationList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('packaging') then
    ComposeMedicationKnowledgePackaging(json, 'packaging', elem.packaging); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('drugCharacteristic') and (elem.drugCharacteristicList.Count > 0) then
  begin
    json.valueArray('drugCharacteristic');
    for i := 0 to elem.drugCharacteristicList.Count - 1 do
      ComposeMedicationKnowledgeDrugCharacteristic(json, '', elem.drugCharacteristicList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('contraindication') and (elem.contraindicationList.Count > 0) then
  begin
    json.valueArray('contraindication');
    for i := 0 to elem.contraindicationList.Count - 1 do
      ComposeReference{TFhirDetectedIssue}(json, '', elem.contraindicationList[i]); {z - Reference(DetectedIssue)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('regulatory') and (elem.regulatoryList.Count > 0) then
  begin
    json.valueArray('regulatory');
    for i := 0 to elem.regulatoryList.Count - 1 do
      ComposeMedicationKnowledgeRegulatory(json, '', elem.regulatoryList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('kinetics') and (elem.kineticsList.Count > 0) then
  begin
    json.valueArray('kinetics');
    for i := 0 to elem.kineticsList.Count - 1 do
      ComposeMedicationKnowledgeKinetics(json, '', elem.kineticsList[i]); {z - }
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_MEDICATIONKNOWLEDGE}
{$IFDEF FHIR_MEDICATIONREQUEST}
procedure TFHIRJsonParser.ParseMedicationRequestDispenseRequest(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationRequestDispenseRequest(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationRequestDispenseRequest(jsn : TJsonObject) : TFhirMedicationRequestDispenseRequest;
begin
  result := TFhirMedicationRequestDispenseRequest.create;
  try
    ParseMedicationRequestDispenseRequestProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicationRequestDispenseRequestProperties(jsn : TJsonObject; result : TFhirMedicationRequestDispenseRequest);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('initialFill') then
        result.initialFill := ParseMedicationRequestDispenseRequestInitialFill(jsn.vObj['initialFill']);{q3}
    if jsn.has('dispenseInterval') then
        result.dispenseInterval := ParseDuration(jsn.vObj['dispenseInterval']);{q3}
    if jsn.has('validityPeriod') then
        result.validityPeriod := ParsePeriod(jsn.vObj['validityPeriod']);{q3}
    if jsn.has('numberOfRepeatsAllowed') or jsn.has('_numberOfRepeatsAllowed') then
        result.numberOfRepeatsAllowedElement := parseUnsignedInt(jsn.node['numberOfRepeatsAllowed'], jsn.vObj['_numberOfRepeatsAllowed']);{q}
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q3}
    if jsn.has('expectedSupplyDuration') then
        result.expectedSupplyDuration := ParseDuration(jsn.vObj['expectedSupplyDuration']);{q3}
    if jsn.has('performer') then
        result.performer := ParseReference{TFhirOrganization}(jsn.vObj['performer']);{q3}
end;

procedure TFHIRJsonComposer.ComposeMedicationRequestDispenseRequest(json : TJSONWriter; name : string; elem : TFhirMedicationRequestDispenseRequest; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeMedicationRequestDispenseRequestInitialFill(json, 'initialFill', elem.initialFill); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeDuration(json, 'dispenseInterval', elem.dispenseInterval); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(json, 'validityPeriod', elem.validityPeriod); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeUnsignedIntValue(json, 'numberOfRepeatsAllowed', elem.numberOfRepeatsAllowedElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeUnsignedIntProps(json, 'numberOfRepeatsAllowed', elem.numberOfRepeatsAllowedElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'quantity', elem.quantity); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeDuration(json, 'expectedSupplyDuration', elem.expectedSupplyDuration); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(json, 'performer', elem.performer); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseMedicationRequestDispenseRequestInitialFill(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationRequestDispenseRequestInitialFill(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationRequestDispenseRequestInitialFill(jsn : TJsonObject) : TFhirMedicationRequestDispenseRequestInitialFill;
begin
  result := TFhirMedicationRequestDispenseRequestInitialFill.create;
  try
    ParseMedicationRequestDispenseRequestInitialFillProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicationRequestDispenseRequestInitialFillProperties(jsn : TJsonObject; result : TFhirMedicationRequestDispenseRequestInitialFill);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q3}
    if jsn.has('duration') then
        result.duration := ParseDuration(jsn.vObj['duration']);{q3}
end;

procedure TFHIRJsonComposer.ComposeMedicationRequestDispenseRequestInitialFill(json : TJSONWriter; name : string; elem : TFhirMedicationRequestDispenseRequestInitialFill; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'quantity', elem.quantity); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeDuration(json, 'duration', elem.duration); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseMedicationRequestSubstitution(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationRequestSubstitution(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationRequestSubstitution(jsn : TJsonObject) : TFhirMedicationRequestSubstitution;
begin
  result := TFhirMedicationRequestSubstitution.create;
  try
    ParseMedicationRequestSubstitutionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicationRequestSubstitutionProperties(jsn : TJsonObject; result : TFhirMedicationRequestSubstitution);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('allowedCodeableConcept') {a4} then
      result.allowed := ParseCodeableConcept(jsn.vObj['allowedCodeableConcept']);
    if jsn.has('allowedBoolean') or jsn.has('_allowedBoolean') then
      result.allowed := parseBoolean(jsn.node['allowedBoolean'], jsn.vObj['_allowedBoolean']);
    if jsn.has('reason') then
        result.reason := ParseCodeableConcept(jsn.vObj['reason']);{q3}
end;

procedure TFHIRJsonComposer.ComposeMedicationRequestSubstitution(json : TJSONWriter; name : string; elem : TFhirMedicationRequestSubstitution; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (elem.allowed is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'allowedCodeableConcept', TFhirCodeableConcept(elem.allowed)) 
  else if (elem.allowed is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'allowedBoolean', TFhirBoolean(elem.allowed), false);
    ComposeBooleanProps(json, 'allowedBoolean', TFhirBoolean(elem.allowed), false);
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'reason', elem.reason); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseMedicationRequest(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationRequest(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationRequest(jsn : TJsonObject) : TFhirMedicationRequest;
begin
  result := TFhirMedicationRequest.create;
  try
    ParseMedicationRequestProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicationRequestProperties(jsn : TJsonObject; result : TFhirMedicationRequest);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirMedicationrequestStatusEnum, SYSTEMS_TFhirMedicationrequestStatusEnum);
    if jsn.has('statusReason') then
        result.statusReason := ParseCodeableConcept(jsn.vObj['statusReason']);{q3}
    if jsn.has('intent') or jsn.has('_intent')  then
      result.intentElement := parseEnum(jsn.path+'/intent', jsn.node['intent'], jsn.vObj['_intent'], CODES_TFhirMedicationrequestIntentEnum, SYSTEMS_TFhirMedicationrequestIntentEnum);
    if jsn.has('category') then
      iterateArray(jsn.vArr['category'], result.categoryList, parseCodeableConcept);
    if jsn.has('priority') or jsn.has('_priority')  then
      result.priorityElement := parseEnum(jsn.path+'/priority', jsn.node['priority'], jsn.vObj['_priority'], CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum);
    if jsn.has('doNotPerform') or jsn.has('_doNotPerform') then
        result.doNotPerformElement := parseBoolean(jsn.node['doNotPerform'], jsn.vObj['_doNotPerform']);{q}
    if jsn.has('reportedReference') {a3} then
      result.reported := ParseReference(jsn.vObj['reportedReference']);
    if jsn.has('reportedBoolean') or jsn.has('_reportedBoolean') then
      result.reported := parseBoolean(jsn.node['reportedBoolean'], jsn.vObj['_reportedBoolean']);
    if jsn.has('medicationCodeableConcept') {a4} then
      result.medication := ParseCodeableConcept(jsn.vObj['medicationCodeableConcept']);
    if jsn.has('medicationReference') {a3} then
      result.medication := ParseReference(jsn.vObj['medicationReference']);
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirPatient}(jsn.vObj['subject']);{q3}
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q3}
    if jsn.has('supportingInformation') then
      iterateArray(jsn.vArr['supportingInformation'], result.supportingInformationList, parseReference{TFhirReference});
    if jsn.has('authoredOn') or jsn.has('_authoredOn') then
        result.authoredOnElement := parseDateTime(jsn.node['authoredOn'], jsn.vObj['_authoredOn']);{q}
    if jsn.has('requester') then
        result.requester := ParseReference{TFhirPractitioner}(jsn.vObj['requester']);{q3}
    if jsn.has('performer') then
        result.performer := ParseReference{TFhirPractitioner}(jsn.vObj['performer']);{q3}
    if jsn.has('performerType') then
        result.performerType := ParseCodeableConcept(jsn.vObj['performerType']);{q3}
    if jsn.has('recorder') then
        result.recorder := ParseReference{TFhirPractitioner}(jsn.vObj['recorder']);{q3}
    if jsn.has('reasonCode') then
      iterateArray(jsn.vArr['reasonCode'], result.reasonCodeList, parseCodeableConcept);
    if jsn.has('reasonReference') then
      iterateArray(jsn.vArr['reasonReference'], result.reasonReferenceList, parseReference{TFhirCondition});
      if jsn.has('instantiatesCanonical') or jsn.has('_instantiatesCanonical') then
      iteratePrimitiveArray(jsn.vArr['instantiatesCanonical'], jsn.vArr['_instantiatesCanonical'], result.instantiatesCanonicalList, parseCanonical);
      if jsn.has('instantiatesUri') or jsn.has('_instantiatesUri') then
      iteratePrimitiveArray(jsn.vArr['instantiatesUri'], jsn.vArr['_instantiatesUri'], result.instantiatesUriList, parseUri);
    if jsn.has('basedOn') then
      iterateArray(jsn.vArr['basedOn'], result.basedOnList, parseReference{TFhirCarePlan});
    if jsn.has('groupIdentifier') then
        result.groupIdentifier := ParseIdentifier(jsn.vObj['groupIdentifier']);{q3}
    if jsn.has('courseOfTherapyType') then
        result.courseOfTherapyType := ParseCodeableConcept(jsn.vObj['courseOfTherapyType']);{q3}
    if jsn.has('insurance') then
      iterateArray(jsn.vArr['insurance'], result.insuranceList, parseReference{TFhirCoverage});
    if jsn.has('note') then
      iterateArray(jsn.vArr['note'], result.noteList, parseAnnotation);
    if jsn.has('dosageInstruction') then
      iterateArray(jsn.vArr['dosageInstruction'], result.dosageInstructionList, parseDosage);
    if jsn.has('dispenseRequest') then
        result.dispenseRequest := ParseMedicationRequestDispenseRequest(jsn.vObj['dispenseRequest']);{q3}
    if jsn.has('substitution') then
        result.substitution := ParseMedicationRequestSubstitution(jsn.vObj['substitution']);{q3}
    if jsn.has('priorPrescription') then
        result.priorPrescription := ParseReference{TFhirMedicationRequest}(jsn.vObj['priorPrescription']);{q3}
    if jsn.has('detectedIssue') then
      iterateArray(jsn.vArr['detectedIssue'], result.detectedIssueList, parseReference{TFhirDetectedIssue});
    if jsn.has('eventHistory') then
      iterateArray(jsn.vArr['eventHistory'], result.eventHistoryList, parseReference{TFhirProvenance});
end;

procedure TFHIRJsonComposer.ComposeMedicationRequest(json : TJSONWriter; name : string; elem : TFhirMedicationRequest; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirMedicationrequestStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirMedicationrequestStatusEnum, false);
  if (SummaryOption in [soFull, soData]) and doCompose('statusReason') then
    ComposeCodeableConcept(json, 'statusReason', elem.statusReason); {a}
  ComposeEnumValue(json, 'intent', elem.IntentElement, CODES_TFhirMedicationrequestIntentEnum, false);
  ComposeEnumProps(json, 'intent', elem.IntentElement, CODES_TFhirMedicationrequestIntentEnum, false);
  if (SummaryOption in [soFull, soData]) and doCompose('category') and (elem.categoryList.Count > 0) then
  begin
    json.valueArray('category');
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.categoryList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('priority') then
    ComposeEnumValue(json, 'priority', elem.PriorityElement, CODES_TFhirRequestPriorityEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('priority') then
    ComposeEnumProps(json, 'priority', elem.PriorityElement, CODES_TFhirRequestPriorityEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('doNotPerform') then
    ComposeBooleanValue(json, 'doNotPerform', elem.doNotPerformElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('doNotPerform') then
    ComposeBooleanProps(json, 'doNotPerform', elem.doNotPerformElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.reported is TFhirReference) then
    ComposeReference(json, 'reportedReference', TFhirReference(elem.reported))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.reported is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'reportedBoolean', TFhirBoolean(elem.reported), false);
    ComposeBooleanProps(json, 'reportedBoolean', TFhirBoolean(elem.reported), false);
  end;
  if (elem.medication is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'medicationCodeableConcept', TFhirCodeableConcept(elem.medication)) 
  else if (elem.medication is TFhirReference) then
    ComposeReference(json, 'medicationReference', TFhirReference(elem.medication));
  ComposeReference{TFhirPatient}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('supportingInformation') and (elem.supportingInformationList.Count > 0) then
  begin
    json.valueArray('supportingInformation');
    for i := 0 to elem.supportingInformationList.Count - 1 do
      ComposeReference{TFhirReference}(json, '', elem.supportingInformationList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('authoredOn') then
    ComposeDateTimeValue(json, 'authoredOn', elem.authoredOnElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('authoredOn') then
    ComposeDateTimeProps(json, 'authoredOn', elem.authoredOnElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requester') then
    ComposeReference{TFhirPractitioner}(json, 'requester', elem.requester); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('performer') then
    ComposeReference{TFhirPractitioner}(json, 'performer', elem.performer); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('performerType') then
    ComposeCodeableConcept(json, 'performerType', elem.performerType); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('recorder') then
    ComposeReference{TFhirPractitioner}(json, 'recorder', elem.recorder); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('reasonCode') and (elem.reasonCodeList.Count > 0) then
  begin
    json.valueArray('reasonCode');
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.reasonCodeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('reasonReference') and (elem.reasonReferenceList.Count > 0) then
  begin
    json.valueArray('reasonReference');
    for i := 0 to elem.reasonReferenceList.Count - 1 do
      ComposeReference{TFhirCondition}(json, '', elem.reasonReferenceList[i]); {z - Reference(Condition)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('instantiatesCanonical') and (elem.instantiatesCanonicalList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.instantiatesCanonicalList.Count - 1 do
    begin
      ext := ext or ((elem.instantiatesCanonicalList[i].id <> '') or (elem.instantiatesCanonicalList[i].hasExtensionList) {no-comments or (elem.instantiatesCanonicalList[i].hasComments)});
      val := val or (elem.instantiatesCanonicalList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('instantiatesCanonical');
      for i := 0 to elem.instantiatesCanonicalList.Count - 1 do
        ComposeCanonicalValue(json, '',elem.instantiatesCanonicalList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_instantiatesCanonical');
      for i := 0 to elem.instantiatesCanonicalList.Count - 1 do
        ComposeCanonicalProps(json, '',elem.instantiatesCanonicalList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('instantiatesUri') and (elem.instantiatesUriList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.instantiatesUriList.Count - 1 do
    begin
      ext := ext or ((elem.instantiatesUriList[i].id <> '') or (elem.instantiatesUriList[i].hasExtensionList) {no-comments or (elem.instantiatesUriList[i].hasComments)});
      val := val or (elem.instantiatesUriList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('instantiatesUri');
      for i := 0 to elem.instantiatesUriList.Count - 1 do
        ComposeUriValue(json, '',elem.instantiatesUriList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_instantiatesUri');
      for i := 0 to elem.instantiatesUriList.Count - 1 do
        ComposeUriProps(json, '',elem.instantiatesUriList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('basedOn') and (elem.basedOnList.Count > 0) then
  begin
    json.valueArray('basedOn');
    for i := 0 to elem.basedOnList.Count - 1 do
      ComposeReference{TFhirCarePlan}(json, '', elem.basedOnList[i]); {z - Reference(CarePlan)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('groupIdentifier') then
    ComposeIdentifier(json, 'groupIdentifier', elem.groupIdentifier); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('courseOfTherapyType') then
    ComposeCodeableConcept(json, 'courseOfTherapyType', elem.courseOfTherapyType); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('insurance') and (elem.insuranceList.Count > 0) then
  begin
    json.valueArray('insurance');
    for i := 0 to elem.insuranceList.Count - 1 do
      ComposeReference{TFhirCoverage}(json, '', elem.insuranceList[i]); {z - Reference(Coverage)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('note') and (elem.noteList.Count > 0) then
  begin
    json.valueArray('note');
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(json, '', elem.noteList[i]); {z - Annotation}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('dosageInstruction') and (elem.dosageInstructionList.Count > 0) then
  begin
    json.valueArray('dosageInstruction');
    for i := 0 to elem.dosageInstructionList.Count - 1 do
      ComposeDosage(json, '', elem.dosageInstructionList[i]); {z - Dosage}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('dispenseRequest') then
    ComposeMedicationRequestDispenseRequest(json, 'dispenseRequest', elem.dispenseRequest); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('substitution') then
    ComposeMedicationRequestSubstitution(json, 'substitution', elem.substitution); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('priorPrescription') then
    ComposeReference{TFhirMedicationRequest}(json, 'priorPrescription', elem.priorPrescription); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('detectedIssue') and (elem.detectedIssueList.Count > 0) then
  begin
    json.valueArray('detectedIssue');
    for i := 0 to elem.detectedIssueList.Count - 1 do
      ComposeReference{TFhirDetectedIssue}(json, '', elem.detectedIssueList[i]); {z - Reference(DetectedIssue)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('eventHistory') and (elem.eventHistoryList.Count > 0) then
  begin
    json.valueArray('eventHistory');
    for i := 0 to elem.eventHistoryList.Count - 1 do
      ComposeReference{TFhirProvenance}(json, '', elem.eventHistoryList[i]); {z - Reference(Provenance)}
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_MEDICATIONREQUEST}
{$IFDEF FHIR_MEDICATIONSTATEMENT}
procedure TFHIRJsonParser.ParseMedicationStatement(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationStatement(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationStatement(jsn : TJsonObject) : TFhirMedicationStatement;
begin
  result := TFhirMedicationStatement.create;
  try
    ParseMedicationStatementProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicationStatementProperties(jsn : TJsonObject; result : TFhirMedicationStatement);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('basedOn') then
      iterateArray(jsn.vArr['basedOn'], result.basedOnList, parseReference{TFhirMedicationRequest});
    if jsn.has('partOf') then
      iterateArray(jsn.vArr['partOf'], result.partOfList, parseReference{TFhirMedicationAdministration});
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirMedicationStatementStatusEnum, SYSTEMS_TFhirMedicationStatementStatusEnum);
    if jsn.has('statusReason') then
      iterateArray(jsn.vArr['statusReason'], result.statusReasonList, parseCodeableConcept);
    if jsn.has('category') then
        result.category := ParseCodeableConcept(jsn.vObj['category']);{q3}
    if jsn.has('medicationCodeableConcept') {a4} then
      result.medication := ParseCodeableConcept(jsn.vObj['medicationCodeableConcept']);
    if jsn.has('medicationReference') {a3} then
      result.medication := ParseReference(jsn.vObj['medicationReference']);
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirPatient}(jsn.vObj['subject']);{q3}
    if jsn.has('context') then
        result.context := ParseReference{TFhirEncounter}(jsn.vObj['context']);{q3}
    if jsn.has('effectivePeriod') {a4} then
      result.effective := ParsePeriod(jsn.vObj['effectivePeriod']);
    if jsn.has('effectiveDateTime') or jsn.has('_effectiveDateTime') then
      result.effective := parseDateTime(jsn.node['effectiveDateTime'], jsn.vObj['_effectiveDateTime']);
    if jsn.has('dateAsserted') or jsn.has('_dateAsserted') then
        result.dateAssertedElement := parseDateTime(jsn.node['dateAsserted'], jsn.vObj['_dateAsserted']);{q}
    if jsn.has('informationSource') then
        result.informationSource := ParseReference{TFhirPatient}(jsn.vObj['informationSource']);{q3}
    if jsn.has('derivedFrom') then
      iterateArray(jsn.vArr['derivedFrom'], result.derivedFromList, parseReference{TFhirReference});
    if jsn.has('reasonCode') then
      iterateArray(jsn.vArr['reasonCode'], result.reasonCodeList, parseCodeableConcept);
    if jsn.has('reasonReference') then
      iterateArray(jsn.vArr['reasonReference'], result.reasonReferenceList, parseReference{TFhirCondition});
    if jsn.has('note') then
      iterateArray(jsn.vArr['note'], result.noteList, parseAnnotation);
    if jsn.has('dosage') then
      iterateArray(jsn.vArr['dosage'], result.dosageList, parseDosage);
end;

procedure TFHIRJsonComposer.ComposeMedicationStatement(json : TJSONWriter; name : string; elem : TFhirMedicationStatement; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('basedOn') and (elem.basedOnList.Count > 0) then
  begin
    json.valueArray('basedOn');
    for i := 0 to elem.basedOnList.Count - 1 do
      ComposeReference{TFhirMedicationRequest}(json, '', elem.basedOnList[i]); {z - Reference(MedicationRequest)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('partOf') and (elem.partOfList.Count > 0) then
  begin
    json.valueArray('partOf');
    for i := 0 to elem.partOfList.Count - 1 do
      ComposeReference{TFhirMedicationAdministration}(json, '', elem.partOfList[i]); {z - Reference(MedicationAdministration)}
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirMedicationStatementStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirMedicationStatementStatusEnum, false);
  if (SummaryOption in [soFull, soData]) and doCompose('statusReason') and (elem.statusReasonList.Count > 0) then
  begin
    json.valueArray('statusReason');
    for i := 0 to elem.statusReasonList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.statusReasonList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    ComposeCodeableConcept(json, 'category', elem.category); {a}
  if (elem.medication is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'medicationCodeableConcept', TFhirCodeableConcept(elem.medication)) 
  else if (elem.medication is TFhirReference) then
    ComposeReference(json, 'medicationReference', TFhirReference(elem.medication));
  ComposeReference{TFhirPatient}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('context') then
    ComposeReference{TFhirEncounter}(json, 'context', elem.context); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.effective is TFhirPeriod) then 
    ComposePeriod(json, 'effectivePeriod', TFhirPeriod(elem.effective)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.effective is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'effectiveDateTime', TFhirDateTime(elem.effective), false);
    ComposeDateTimeProps(json, 'effectiveDateTime', TFhirDateTime(elem.effective), false);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dateAsserted') then
    ComposeDateTimeValue(json, 'dateAsserted', elem.dateAssertedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dateAsserted') then
    ComposeDateTimeProps(json, 'dateAsserted', elem.dateAssertedElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('informationSource') then
    ComposeReference{TFhirPatient}(json, 'informationSource', elem.informationSource); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('derivedFrom') and (elem.derivedFromList.Count > 0) then
  begin
    json.valueArray('derivedFrom');
    for i := 0 to elem.derivedFromList.Count - 1 do
      ComposeReference{TFhirReference}(json, '', elem.derivedFromList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('reasonCode') and (elem.reasonCodeList.Count > 0) then
  begin
    json.valueArray('reasonCode');
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.reasonCodeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('reasonReference') and (elem.reasonReferenceList.Count > 0) then
  begin
    json.valueArray('reasonReference');
    for i := 0 to elem.reasonReferenceList.Count - 1 do
      ComposeReference{TFhirCondition}(json, '', elem.reasonReferenceList[i]); {z - Reference(Condition)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('note') and (elem.noteList.Count > 0) then
  begin
    json.valueArray('note');
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(json, '', elem.noteList[i]); {z - Annotation}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('dosage') and (elem.dosageList.Count > 0) then
  begin
    json.valueArray('dosage');
    for i := 0 to elem.dosageList.Count - 1 do
      ComposeDosage(json, '', elem.dosageList[i]); {z - Dosage}
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_MEDICATIONSTATEMENT}
{$IFDEF FHIR_MEDICINALPRODUCT}
procedure TFHIRJsonParser.ParseMedicinalProductName(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicinalProductName(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicinalProductName(jsn : TJsonObject) : TFhirMedicinalProductName;
begin
  result := TFhirMedicinalProductName.create;
  try
    ParseMedicinalProductNameProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicinalProductNameProperties(jsn : TJsonObject; result : TFhirMedicinalProductName);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('productName') or jsn.has('_productName') then
        result.productNameElement := parseString(jsn.node['productName'], jsn.vObj['_productName']);{q}
    if jsn.has('namePart') then
      iterateArray(jsn.vArr['namePart'], result.namePartList, parseMedicinalProductNameNamePart);
    if jsn.has('countryLanguage') then
      iterateArray(jsn.vArr['countryLanguage'], result.countryLanguageList, parseMedicinalProductNameCountryLanguage);
end;

procedure TFHIRJsonComposer.ComposeMedicinalProductName(json : TJSONWriter; name : string; elem : TFhirMedicinalProductName; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'productName', elem.productNameElement, false);
  ComposeStringProps(json, 'productName', elem.productNameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.namePartList.Count > 0) then
  begin
    json.valueArray('namePart');
    for i := 0 to elem.namePartList.Count - 1 do
      ComposeMedicinalProductNameNamePart(json, '', elem.namePartList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.countryLanguageList.Count > 0) then
  begin
    json.valueArray('countryLanguage');
    for i := 0 to elem.countryLanguageList.Count - 1 do
      ComposeMedicinalProductNameCountryLanguage(json, '', elem.countryLanguageList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseMedicinalProductNameNamePart(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicinalProductNameNamePart(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicinalProductNameNamePart(jsn : TJsonObject) : TFhirMedicinalProductNameNamePart;
begin
  result := TFhirMedicinalProductNameNamePart.create;
  try
    ParseMedicinalProductNameNamePartProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicinalProductNameNamePartProperties(jsn : TJsonObject; result : TFhirMedicinalProductNameNamePart);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('part') or jsn.has('_part') then
        result.partElement := parseString(jsn.node['part'], jsn.vObj['_part']);{q}
    if jsn.has('type') then
        result.type_ := ParseCoding(jsn.vObj['type']);{q3}
end;

procedure TFHIRJsonComposer.ComposeMedicinalProductNameNamePart(json : TJSONWriter; name : string; elem : TFhirMedicinalProductNameNamePart; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'part', elem.partElement, false);
  ComposeStringProps(json, 'part', elem.partElement, false);
  ComposeCoding(json, 'type', elem.type_); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseMedicinalProductNameCountryLanguage(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicinalProductNameCountryLanguage(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicinalProductNameCountryLanguage(jsn : TJsonObject) : TFhirMedicinalProductNameCountryLanguage;
begin
  result := TFhirMedicinalProductNameCountryLanguage.create;
  try
    ParseMedicinalProductNameCountryLanguageProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicinalProductNameCountryLanguageProperties(jsn : TJsonObject; result : TFhirMedicinalProductNameCountryLanguage);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('country') then
        result.country := ParseCodeableConcept(jsn.vObj['country']);{q3}
    if jsn.has('jurisdiction') then
        result.jurisdiction := ParseCodeableConcept(jsn.vObj['jurisdiction']);{q3}
    if jsn.has('language') then
        result.language := ParseCodeableConcept(jsn.vObj['language']);{q3}
end;

procedure TFHIRJsonComposer.ComposeMedicinalProductNameCountryLanguage(json : TJSONWriter; name : string; elem : TFhirMedicinalProductNameCountryLanguage; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'country', elem.country); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'jurisdiction', elem.jurisdiction); {a}
  ComposeCodeableConcept(json, 'language', elem.language); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseMedicinalProductManufacturingBusinessOperation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicinalProductManufacturingBusinessOperation(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicinalProductManufacturingBusinessOperation(jsn : TJsonObject) : TFhirMedicinalProductManufacturingBusinessOperation;
begin
  result := TFhirMedicinalProductManufacturingBusinessOperation.create;
  try
    ParseMedicinalProductManufacturingBusinessOperationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicinalProductManufacturingBusinessOperationProperties(jsn : TJsonObject; result : TFhirMedicinalProductManufacturingBusinessOperation);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('operationType') then
        result.operationType := ParseCodeableConcept(jsn.vObj['operationType']);{q3}
    if jsn.has('authorisationReferenceNumber') then
        result.authorisationReferenceNumber := ParseIdentifier(jsn.vObj['authorisationReferenceNumber']);{q3}
    if jsn.has('effectiveDate') or jsn.has('_effectiveDate') then
        result.effectiveDateElement := parseDateTime(jsn.node['effectiveDate'], jsn.vObj['_effectiveDate']);{q}
    if jsn.has('confidentialityIndicator') then
        result.confidentialityIndicator := ParseCodeableConcept(jsn.vObj['confidentialityIndicator']);{q3}
    if jsn.has('manufacturer') then
      iterateArray(jsn.vArr['manufacturer'], result.manufacturerList, parseReference{TFhirOrganization});
    if jsn.has('regulator') then
        result.regulator := ParseReference{TFhirOrganization}(jsn.vObj['regulator']);{q3}
end;

procedure TFHIRJsonComposer.ComposeMedicinalProductManufacturingBusinessOperation(json : TJSONWriter; name : string; elem : TFhirMedicinalProductManufacturingBusinessOperation; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'operationType', elem.operationType); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(json, 'authorisationReferenceNumber', elem.authorisationReferenceNumber); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'effectiveDate', elem.effectiveDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'effectiveDate', elem.effectiveDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'confidentialityIndicator', elem.confidentialityIndicator); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.manufacturerList.Count > 0) then
  begin
    json.valueArray('manufacturer');
    for i := 0 to elem.manufacturerList.Count - 1 do
      ComposeReference{TFhirOrganization}(json, '', elem.manufacturerList[i]); {z - Reference(Organization)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(json, 'regulator', elem.regulator); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseMedicinalProductSpecialDesignation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicinalProductSpecialDesignation(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicinalProductSpecialDesignation(jsn : TJsonObject) : TFhirMedicinalProductSpecialDesignation;
begin
  result := TFhirMedicinalProductSpecialDesignation.create;
  try
    ParseMedicinalProductSpecialDesignationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicinalProductSpecialDesignationProperties(jsn : TJsonObject; result : TFhirMedicinalProductSpecialDesignation);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('intendedUse') then
        result.intendedUse := ParseCodeableConcept(jsn.vObj['intendedUse']);{q3}
    if jsn.has('indicationCodeableConcept') {a4} then
      result.indication := ParseCodeableConcept(jsn.vObj['indicationCodeableConcept']);
    if jsn.has('indicationReference') {a3} then
      result.indication := ParseReference(jsn.vObj['indicationReference']);
    if jsn.has('status') then
        result.status := ParseCodeableConcept(jsn.vObj['status']);{q3}
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := parseDateTime(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('species') then
        result.species := ParseCodeableConcept(jsn.vObj['species']);{q3}
end;

procedure TFHIRJsonComposer.ComposeMedicinalProductSpecialDesignation(json : TJSONWriter; name : string; elem : TFhirMedicinalProductSpecialDesignation; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'intendedUse', elem.intendedUse); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.indication is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'indicationCodeableConcept', TFhirCodeableConcept(elem.indication)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.indication is TFhirReference) then
    ComposeReference(json, 'indicationReference', TFhirReference(elem.indication));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'status', elem.status); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'species', elem.species); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseMedicinalProduct(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicinalProduct(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicinalProduct(jsn : TJsonObject) : TFhirMedicinalProduct;
begin
  result := TFhirMedicinalProduct.create;
  try
    ParseMedicinalProductProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicinalProductProperties(jsn : TJsonObject; result : TFhirMedicinalProduct);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('domain') then
        result.domain := ParseCoding(jsn.vObj['domain']);{q3}
    if jsn.has('combinedPharmaceuticalDoseForm') then
        result.combinedPharmaceuticalDoseForm := ParseCodeableConcept(jsn.vObj['combinedPharmaceuticalDoseForm']);{q3}
    if jsn.has('legalStatusOfSupply') then
        result.legalStatusOfSupply := ParseCodeableConcept(jsn.vObj['legalStatusOfSupply']);{q3}
    if jsn.has('additionalMonitoringIndicator') then
        result.additionalMonitoringIndicator := ParseCodeableConcept(jsn.vObj['additionalMonitoringIndicator']);{q3}
      if jsn.has('specialMeasures') or jsn.has('_specialMeasures') then
      iteratePrimitiveArray(jsn.vArr['specialMeasures'], jsn.vArr['_specialMeasures'], result.specialMeasuresList, parseString);
    if jsn.has('paediatricUseIndicator') then
        result.paediatricUseIndicator := ParseCodeableConcept(jsn.vObj['paediatricUseIndicator']);{q3}
    if jsn.has('productClassification') then
      iterateArray(jsn.vArr['productClassification'], result.productClassificationList, parseCodeableConcept);
    if jsn.has('marketingStatus') then
      iterateArray(jsn.vArr['marketingStatus'], result.marketingStatusList, parseMarketingStatus);
    if jsn.has('pharmaceuticalProduct') then
      iterateArray(jsn.vArr['pharmaceuticalProduct'], result.pharmaceuticalProductList, parseReference{TFhirMedicinalProductPharmaceutical});
    if jsn.has('packagedMedicinalProduct') then
      iterateArray(jsn.vArr['packagedMedicinalProduct'], result.packagedMedicinalProductList, parseReference{TFhirMedicinalProductPackaged});
    if jsn.has('attachedDocument') then
      iterateArray(jsn.vArr['attachedDocument'], result.attachedDocumentList, parseReference{TFhirDocumentReference});
    if jsn.has('masterFile') then
      iterateArray(jsn.vArr['masterFile'], result.masterFileList, parseReference{TFhirDocumentReference});
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseReference{TFhirOrganization});
    if jsn.has('clinicalTrial') then
      iterateArray(jsn.vArr['clinicalTrial'], result.clinicalTrialList, parseReference{TFhirResearchStudy});
    if jsn.has('name') then
      iterateArray(jsn.vArr['name'], result.nameList, parseMedicinalProductName);
    if jsn.has('crossReference') then
      iterateArray(jsn.vArr['crossReference'], result.crossReferenceList, parseIdentifier);
    if jsn.has('manufacturingBusinessOperation') then
      iterateArray(jsn.vArr['manufacturingBusinessOperation'], result.manufacturingBusinessOperationList, parseMedicinalProductManufacturingBusinessOperation);
    if jsn.has('specialDesignation') then
      iterateArray(jsn.vArr['specialDesignation'], result.specialDesignationList, parseMedicinalProductSpecialDesignation);
end;

procedure TFHIRJsonComposer.ComposeMedicinalProduct(json : TJSONWriter; name : string; elem : TFhirMedicinalProduct; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('domain') then
    ComposeCoding(json, 'domain', elem.domain); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('combinedPharmaceuticalDoseForm') then
    ComposeCodeableConcept(json, 'combinedPharmaceuticalDoseForm', elem.combinedPharmaceuticalDoseForm); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('legalStatusOfSupply') then
    ComposeCodeableConcept(json, 'legalStatusOfSupply', elem.legalStatusOfSupply); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('additionalMonitoringIndicator') then
    ComposeCodeableConcept(json, 'additionalMonitoringIndicator', elem.additionalMonitoringIndicator); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('specialMeasures') and (elem.specialMeasuresList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.specialMeasuresList.Count - 1 do
    begin
      ext := ext or ((elem.specialMeasuresList[i].id <> '') or (elem.specialMeasuresList[i].hasExtensionList) {no-comments or (elem.specialMeasuresList[i].hasComments)});
      val := val or (elem.specialMeasuresList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('specialMeasures');
      for i := 0 to elem.specialMeasuresList.Count - 1 do
        ComposeStringValue(json, '',elem.specialMeasuresList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_specialMeasures');
      for i := 0 to elem.specialMeasuresList.Count - 1 do
        ComposeStringProps(json, '',elem.specialMeasuresList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('paediatricUseIndicator') then
    ComposeCodeableConcept(json, 'paediatricUseIndicator', elem.paediatricUseIndicator); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('productClassification') and (elem.productClassificationList.Count > 0) then
  begin
    json.valueArray('productClassification');
    for i := 0 to elem.productClassificationList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.productClassificationList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('marketingStatus') and (elem.marketingStatusList.Count > 0) then
  begin
    json.valueArray('marketingStatus');
    for i := 0 to elem.marketingStatusList.Count - 1 do
      ComposeMarketingStatus(json, '', elem.marketingStatusList[i]); {z - MarketingStatus}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('pharmaceuticalProduct') and (elem.pharmaceuticalProductList.Count > 0) then
  begin
    json.valueArray('pharmaceuticalProduct');
    for i := 0 to elem.pharmaceuticalProductList.Count - 1 do
      ComposeReference{TFhirMedicinalProductPharmaceutical}(json, '', elem.pharmaceuticalProductList[i]); {z - Reference(MedicinalProductPharmaceutical)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('packagedMedicinalProduct') and (elem.packagedMedicinalProductList.Count > 0) then
  begin
    json.valueArray('packagedMedicinalProduct');
    for i := 0 to elem.packagedMedicinalProductList.Count - 1 do
      ComposeReference{TFhirMedicinalProductPackaged}(json, '', elem.packagedMedicinalProductList[i]); {z - Reference(MedicinalProductPackaged)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('attachedDocument') and (elem.attachedDocumentList.Count > 0) then
  begin
    json.valueArray('attachedDocument');
    for i := 0 to elem.attachedDocumentList.Count - 1 do
      ComposeReference{TFhirDocumentReference}(json, '', elem.attachedDocumentList[i]); {z - Reference(DocumentReference)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('masterFile') and (elem.masterFileList.Count > 0) then
  begin
    json.valueArray('masterFile');
    for i := 0 to elem.masterFileList.Count - 1 do
      ComposeReference{TFhirDocumentReference}(json, '', elem.masterFileList[i]); {z - Reference(DocumentReference)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') and (elem.contactList.Count > 0) then
  begin
    json.valueArray('contact');
    for i := 0 to elem.contactList.Count - 1 do
      ComposeReference{TFhirOrganization}(json, '', elem.contactList[i]); {z - Reference(Organization)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('clinicalTrial') and (elem.clinicalTrialList.Count > 0) then
  begin
    json.valueArray('clinicalTrial');
    for i := 0 to elem.clinicalTrialList.Count - 1 do
      ComposeReference{TFhirResearchStudy}(json, '', elem.clinicalTrialList[i]); {z - Reference(ResearchStudy)}
    json.FinishArray;
  end;
  if (elem.nameList.Count > 0) then
  begin
    json.valueArray('name');
    for i := 0 to elem.nameList.Count - 1 do
      ComposeMedicinalProductName(json, '', elem.nameList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('crossReference') and (elem.crossReferenceList.Count > 0) then
  begin
    json.valueArray('crossReference');
    for i := 0 to elem.crossReferenceList.Count - 1 do
      ComposeIdentifier(json, '', elem.crossReferenceList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('manufacturingBusinessOperation') and (elem.manufacturingBusinessOperationList.Count > 0) then
  begin
    json.valueArray('manufacturingBusinessOperation');
    for i := 0 to elem.manufacturingBusinessOperationList.Count - 1 do
      ComposeMedicinalProductManufacturingBusinessOperation(json, '', elem.manufacturingBusinessOperationList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('specialDesignation') and (elem.specialDesignationList.Count > 0) then
  begin
    json.valueArray('specialDesignation');
    for i := 0 to elem.specialDesignationList.Count - 1 do
      ComposeMedicinalProductSpecialDesignation(json, '', elem.specialDesignationList[i]); {z - }
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_MEDICINALPRODUCT}
{$IFDEF FHIR_MEDICINALPRODUCTAUTHORIZATION}
procedure TFHIRJsonParser.ParseMedicinalProductAuthorizationJurisdictionalAuthorization(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicinalProductAuthorizationJurisdictionalAuthorization(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicinalProductAuthorizationJurisdictionalAuthorization(jsn : TJsonObject) : TFhirMedicinalProductAuthorizationJurisdictionalAuthorization;
begin
  result := TFhirMedicinalProductAuthorizationJurisdictionalAuthorization.create;
  try
    ParseMedicinalProductAuthorizationJurisdictionalAuthorizationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicinalProductAuthorizationJurisdictionalAuthorizationProperties(jsn : TJsonObject; result : TFhirMedicinalProductAuthorizationJurisdictionalAuthorization);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('country') then
        result.country := ParseCodeableConcept(jsn.vObj['country']);{q3}
    if jsn.has('jurisdiction') then
      iterateArray(jsn.vArr['jurisdiction'], result.jurisdictionList, parseCodeableConcept);
    if jsn.has('legalStatusOfSupply') then
        result.legalStatusOfSupply := ParseCodeableConcept(jsn.vObj['legalStatusOfSupply']);{q3}
    if jsn.has('validityPeriod') then
        result.validityPeriod := ParsePeriod(jsn.vObj['validityPeriod']);{q3}
end;

procedure TFHIRJsonComposer.ComposeMedicinalProductAuthorizationJurisdictionalAuthorization(json : TJSONWriter; name : string; elem : TFhirMedicinalProductAuthorizationJurisdictionalAuthorization; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'country', elem.country); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.jurisdictionList.Count > 0) then
  begin
    json.valueArray('jurisdiction');
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.jurisdictionList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'legalStatusOfSupply', elem.legalStatusOfSupply); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(json, 'validityPeriod', elem.validityPeriod); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseMedicinalProductAuthorizationProcedure(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicinalProductAuthorizationProcedure(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicinalProductAuthorizationProcedure(jsn : TJsonObject) : TFhirMedicinalProductAuthorizationProcedure;
begin
  result := TFhirMedicinalProductAuthorizationProcedure.create;
  try
    ParseMedicinalProductAuthorizationProcedureProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicinalProductAuthorizationProcedureProperties(jsn : TJsonObject; result : TFhirMedicinalProductAuthorizationProcedure);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q3}
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('datePeriod') {a4} then
      result.date := ParsePeriod(jsn.vObj['datePeriod']);
    if jsn.has('dateDateTime') or jsn.has('_dateDateTime') then
      result.date := parseDateTime(jsn.node['dateDateTime'], jsn.vObj['_dateDateTime']);
    if jsn.has('application') then
      iterateArray(jsn.vArr['application'], result.applicationList, parseMedicinalProductAuthorizationProcedure);
end;

procedure TFHIRJsonComposer.ComposeMedicinalProductAuthorizationProcedure(json : TJSONWriter; name : string; elem : TFhirMedicinalProductAuthorizationProcedure; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.date is TFhirPeriod) then 
    ComposePeriod(json, 'datePeriod', TFhirPeriod(elem.date)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.date is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'dateDateTime', TFhirDateTime(elem.date), false);
    ComposeDateTimeProps(json, 'dateDateTime', TFhirDateTime(elem.date), false);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.applicationList.Count > 0) then
  begin
    json.valueArray('application');
    for i := 0 to elem.applicationList.Count - 1 do
      ComposeMedicinalProductAuthorizationProcedure(json, '', elem.applicationList[i]); {z - @MedicinalProductAuthorization.procedure}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseMedicinalProductAuthorization(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicinalProductAuthorization(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicinalProductAuthorization(jsn : TJsonObject) : TFhirMedicinalProductAuthorization;
begin
  result := TFhirMedicinalProductAuthorization.create;
  try
    ParseMedicinalProductAuthorizationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicinalProductAuthorizationProperties(jsn : TJsonObject; result : TFhirMedicinalProductAuthorization);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirMedicinalProduct}(jsn.vObj['subject']);{q3}
    if jsn.has('country') then
      iterateArray(jsn.vArr['country'], result.countryList, parseCodeableConcept);
    if jsn.has('jurisdiction') then
      iterateArray(jsn.vArr['jurisdiction'], result.jurisdictionList, parseCodeableConcept);
    if jsn.has('status') then
        result.status := ParseCodeableConcept(jsn.vObj['status']);{q3}
    if jsn.has('statusDate') or jsn.has('_statusDate') then
        result.statusDateElement := parseDateTime(jsn.node['statusDate'], jsn.vObj['_statusDate']);{q}
    if jsn.has('restoreDate') or jsn.has('_restoreDate') then
        result.restoreDateElement := parseDateTime(jsn.node['restoreDate'], jsn.vObj['_restoreDate']);{q}
    if jsn.has('validityPeriod') then
        result.validityPeriod := ParsePeriod(jsn.vObj['validityPeriod']);{q3}
    if jsn.has('dataExclusivityPeriod') then
        result.dataExclusivityPeriod := ParsePeriod(jsn.vObj['dataExclusivityPeriod']);{q3}
    if jsn.has('dateOfFirstAuthorization') or jsn.has('_dateOfFirstAuthorization') then
        result.dateOfFirstAuthorizationElement := parseDateTime(jsn.node['dateOfFirstAuthorization'], jsn.vObj['_dateOfFirstAuthorization']);{q}
    if jsn.has('internationalBirthDate') or jsn.has('_internationalBirthDate') then
        result.internationalBirthDateElement := parseDateTime(jsn.node['internationalBirthDate'], jsn.vObj['_internationalBirthDate']);{q}
    if jsn.has('legalBasis') then
        result.legalBasis := ParseCodeableConcept(jsn.vObj['legalBasis']);{q3}
    if jsn.has('jurisdictionalAuthorization') then
      iterateArray(jsn.vArr['jurisdictionalAuthorization'], result.jurisdictionalAuthorizationList, parseMedicinalProductAuthorizationJurisdictionalAuthorization);
    if jsn.has('holder') then
        result.holder := ParseReference{TFhirOrganization}(jsn.vObj['holder']);{q3}
    if jsn.has('regulator') then
        result.regulator := ParseReference{TFhirOrganization}(jsn.vObj['regulator']);{q3}
    if jsn.has('procedure') then
        result.procedure_ := ParseMedicinalProductAuthorizationProcedure(jsn.vObj['procedure']);{q3}
end;

procedure TFHIRJsonComposer.ComposeMedicinalProductAuthorization(json : TJSONWriter; name : string; elem : TFhirMedicinalProductAuthorization; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{TFhirMedicinalProduct}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('country') and (elem.countryList.Count > 0) then
  begin
    json.valueArray('country');
    for i := 0 to elem.countryList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.countryList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') and (elem.jurisdictionList.Count > 0) then
  begin
    json.valueArray('jurisdiction');
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.jurisdictionList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeCodeableConcept(json, 'status', elem.status); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('statusDate') then
    ComposeDateTimeValue(json, 'statusDate', elem.statusDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('statusDate') then
    ComposeDateTimeProps(json, 'statusDate', elem.statusDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('restoreDate') then
    ComposeDateTimeValue(json, 'restoreDate', elem.restoreDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('restoreDate') then
    ComposeDateTimeProps(json, 'restoreDate', elem.restoreDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('validityPeriod') then
    ComposePeriod(json, 'validityPeriod', elem.validityPeriod); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dataExclusivityPeriod') then
    ComposePeriod(json, 'dataExclusivityPeriod', elem.dataExclusivityPeriod); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dateOfFirstAuthorization') then
    ComposeDateTimeValue(json, 'dateOfFirstAuthorization', elem.dateOfFirstAuthorizationElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dateOfFirstAuthorization') then
    ComposeDateTimeProps(json, 'dateOfFirstAuthorization', elem.dateOfFirstAuthorizationElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('internationalBirthDate') then
    ComposeDateTimeValue(json, 'internationalBirthDate', elem.internationalBirthDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('internationalBirthDate') then
    ComposeDateTimeProps(json, 'internationalBirthDate', elem.internationalBirthDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('legalBasis') then
    ComposeCodeableConcept(json, 'legalBasis', elem.legalBasis); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdictionalAuthorization') and (elem.jurisdictionalAuthorizationList.Count > 0) then
  begin
    json.valueArray('jurisdictionalAuthorization');
    for i := 0 to elem.jurisdictionalAuthorizationList.Count - 1 do
      ComposeMedicinalProductAuthorizationJurisdictionalAuthorization(json, '', elem.jurisdictionalAuthorizationList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('holder') then
    ComposeReference{TFhirOrganization}(json, 'holder', elem.holder); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('regulator') then
    ComposeReference{TFhirOrganization}(json, 'regulator', elem.regulator); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('procedure_') then
    ComposeMedicinalProductAuthorizationProcedure(json, 'procedure', elem.procedure_); {a}
end;

{$ENDIF FHIR_MEDICINALPRODUCTAUTHORIZATION}
{$IFDEF FHIR_MEDICINALPRODUCTCONTRAINDICATION}
procedure TFHIRJsonParser.ParseMedicinalProductContraindicationOtherTherapy(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicinalProductContraindicationOtherTherapy(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicinalProductContraindicationOtherTherapy(jsn : TJsonObject) : TFhirMedicinalProductContraindicationOtherTherapy;
begin
  result := TFhirMedicinalProductContraindicationOtherTherapy.create;
  try
    ParseMedicinalProductContraindicationOtherTherapyProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicinalProductContraindicationOtherTherapyProperties(jsn : TJsonObject; result : TFhirMedicinalProductContraindicationOtherTherapy);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('therapyRelationshipType') then
        result.therapyRelationshipType := ParseCodeableConcept(jsn.vObj['therapyRelationshipType']);{q3}
    if jsn.has('medicationCodeableConcept') {a4} then
      result.medication := ParseCodeableConcept(jsn.vObj['medicationCodeableConcept']);
    if jsn.has('medicationReference') {a3} then
      result.medication := ParseReference(jsn.vObj['medicationReference']);
end;

procedure TFHIRJsonComposer.ComposeMedicinalProductContraindicationOtherTherapy(json : TJSONWriter; name : string; elem : TFhirMedicinalProductContraindicationOtherTherapy; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'therapyRelationshipType', elem.therapyRelationshipType); {a}
  if (elem.medication is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'medicationCodeableConcept', TFhirCodeableConcept(elem.medication)) 
  else if (elem.medication is TFhirReference) then
    ComposeReference(json, 'medicationReference', TFhirReference(elem.medication));
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseMedicinalProductContraindication(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicinalProductContraindication(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicinalProductContraindication(jsn : TJsonObject) : TFhirMedicinalProductContraindication;
begin
  result := TFhirMedicinalProductContraindication.create;
  try
    ParseMedicinalProductContraindicationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicinalProductContraindicationProperties(jsn : TJsonObject; result : TFhirMedicinalProductContraindication);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('subject') then
      iterateArray(jsn.vArr['subject'], result.subjectList, parseReference{TFhirMedicinalProduct});
    if jsn.has('disease') then
        result.disease := ParseCodeableConcept(jsn.vObj['disease']);{q3}
    if jsn.has('diseaseStatus') then
        result.diseaseStatus := ParseCodeableConcept(jsn.vObj['diseaseStatus']);{q3}
    if jsn.has('comorbidity') then
      iterateArray(jsn.vArr['comorbidity'], result.comorbidityList, parseCodeableConcept);
    if jsn.has('therapeuticIndication') then
      iterateArray(jsn.vArr['therapeuticIndication'], result.therapeuticIndicationList, parseReference{TFhirMedicinalProductIndication});
    if jsn.has('otherTherapy') then
      iterateArray(jsn.vArr['otherTherapy'], result.otherTherapyList, parseMedicinalProductContraindicationOtherTherapy);
    if jsn.has('population') then
      iterateArray(jsn.vArr['population'], result.populationList, parsePopulation);
end;

procedure TFHIRJsonComposer.ComposeMedicinalProductContraindication(json : TJSONWriter; name : string; elem : TFhirMedicinalProductContraindication; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') and (elem.subjectList.Count > 0) then
  begin
    json.valueArray('subject');
    for i := 0 to elem.subjectList.Count - 1 do
      ComposeReference{TFhirMedicinalProduct}(json, '', elem.subjectList[i]); {z - Reference(MedicinalProduct)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('disease') then
    ComposeCodeableConcept(json, 'disease', elem.disease); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('diseaseStatus') then
    ComposeCodeableConcept(json, 'diseaseStatus', elem.diseaseStatus); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('comorbidity') and (elem.comorbidityList.Count > 0) then
  begin
    json.valueArray('comorbidity');
    for i := 0 to elem.comorbidityList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.comorbidityList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('therapeuticIndication') and (elem.therapeuticIndicationList.Count > 0) then
  begin
    json.valueArray('therapeuticIndication');
    for i := 0 to elem.therapeuticIndicationList.Count - 1 do
      ComposeReference{TFhirMedicinalProductIndication}(json, '', elem.therapeuticIndicationList[i]); {z - Reference(MedicinalProductIndication)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('otherTherapy') and (elem.otherTherapyList.Count > 0) then
  begin
    json.valueArray('otherTherapy');
    for i := 0 to elem.otherTherapyList.Count - 1 do
      ComposeMedicinalProductContraindicationOtherTherapy(json, '', elem.otherTherapyList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('population') and (elem.populationList.Count > 0) then
  begin
    json.valueArray('population');
    for i := 0 to elem.populationList.Count - 1 do
      ComposePopulation(json, '', elem.populationList[i]); {z - Population}
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_MEDICINALPRODUCTCONTRAINDICATION}
{$IFDEF FHIR_MEDICINALPRODUCTINDICATION}
procedure TFHIRJsonParser.ParseMedicinalProductIndicationOtherTherapy(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicinalProductIndicationOtherTherapy(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicinalProductIndicationOtherTherapy(jsn : TJsonObject) : TFhirMedicinalProductIndicationOtherTherapy;
begin
  result := TFhirMedicinalProductIndicationOtherTherapy.create;
  try
    ParseMedicinalProductIndicationOtherTherapyProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicinalProductIndicationOtherTherapyProperties(jsn : TJsonObject; result : TFhirMedicinalProductIndicationOtherTherapy);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('therapyRelationshipType') then
        result.therapyRelationshipType := ParseCodeableConcept(jsn.vObj['therapyRelationshipType']);{q3}
    if jsn.has('medicationCodeableConcept') {a4} then
      result.medication := ParseCodeableConcept(jsn.vObj['medicationCodeableConcept']);
    if jsn.has('medicationReference') {a3} then
      result.medication := ParseReference(jsn.vObj['medicationReference']);
end;

procedure TFHIRJsonComposer.ComposeMedicinalProductIndicationOtherTherapy(json : TJSONWriter; name : string; elem : TFhirMedicinalProductIndicationOtherTherapy; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'therapyRelationshipType', elem.therapyRelationshipType); {a}
  if (elem.medication is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'medicationCodeableConcept', TFhirCodeableConcept(elem.medication)) 
  else if (elem.medication is TFhirReference) then
    ComposeReference(json, 'medicationReference', TFhirReference(elem.medication));
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseMedicinalProductIndication(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicinalProductIndication(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicinalProductIndication(jsn : TJsonObject) : TFhirMedicinalProductIndication;
begin
  result := TFhirMedicinalProductIndication.create;
  try
    ParseMedicinalProductIndicationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicinalProductIndicationProperties(jsn : TJsonObject; result : TFhirMedicinalProductIndication);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('subject') then
      iterateArray(jsn.vArr['subject'], result.subjectList, parseReference{TFhirMedicinalProduct});
    if jsn.has('diseaseSymptomProcedure') then
        result.diseaseSymptomProcedure := ParseCodeableConcept(jsn.vObj['diseaseSymptomProcedure']);{q3}
    if jsn.has('diseaseStatus') then
        result.diseaseStatus := ParseCodeableConcept(jsn.vObj['diseaseStatus']);{q3}
    if jsn.has('comorbidity') then
      iterateArray(jsn.vArr['comorbidity'], result.comorbidityList, parseCodeableConcept);
    if jsn.has('intendedEffect') then
        result.intendedEffect := ParseCodeableConcept(jsn.vObj['intendedEffect']);{q3}
    if jsn.has('duration') then
        result.duration := ParseQuantity(jsn.vObj['duration']);{q3}
    if jsn.has('otherTherapy') then
      iterateArray(jsn.vArr['otherTherapy'], result.otherTherapyList, parseMedicinalProductIndicationOtherTherapy);
    if jsn.has('undesirableEffect') then
      iterateArray(jsn.vArr['undesirableEffect'], result.undesirableEffectList, parseReference{TFhirMedicinalProductUndesirableEffect});
    if jsn.has('population') then
      iterateArray(jsn.vArr['population'], result.populationList, parsePopulation);
end;

procedure TFHIRJsonComposer.ComposeMedicinalProductIndication(json : TJSONWriter; name : string; elem : TFhirMedicinalProductIndication; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') and (elem.subjectList.Count > 0) then
  begin
    json.valueArray('subject');
    for i := 0 to elem.subjectList.Count - 1 do
      ComposeReference{TFhirMedicinalProduct}(json, '', elem.subjectList[i]); {z - Reference(MedicinalProduct)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('diseaseSymptomProcedure') then
    ComposeCodeableConcept(json, 'diseaseSymptomProcedure', elem.diseaseSymptomProcedure); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('diseaseStatus') then
    ComposeCodeableConcept(json, 'diseaseStatus', elem.diseaseStatus); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('comorbidity') and (elem.comorbidityList.Count > 0) then
  begin
    json.valueArray('comorbidity');
    for i := 0 to elem.comorbidityList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.comorbidityList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('intendedEffect') then
    ComposeCodeableConcept(json, 'intendedEffect', elem.intendedEffect); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('duration') then
    ComposeQuantity(json, 'duration', elem.duration); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('otherTherapy') and (elem.otherTherapyList.Count > 0) then
  begin
    json.valueArray('otherTherapy');
    for i := 0 to elem.otherTherapyList.Count - 1 do
      ComposeMedicinalProductIndicationOtherTherapy(json, '', elem.otherTherapyList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('undesirableEffect') and (elem.undesirableEffectList.Count > 0) then
  begin
    json.valueArray('undesirableEffect');
    for i := 0 to elem.undesirableEffectList.Count - 1 do
      ComposeReference{TFhirMedicinalProductUndesirableEffect}(json, '', elem.undesirableEffectList[i]); {z - Reference(MedicinalProductUndesirableEffect)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('population') and (elem.populationList.Count > 0) then
  begin
    json.valueArray('population');
    for i := 0 to elem.populationList.Count - 1 do
      ComposePopulation(json, '', elem.populationList[i]); {z - Population}
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_MEDICINALPRODUCTINDICATION}
{$IFDEF FHIR_MEDICINALPRODUCTINGREDIENT}
procedure TFHIRJsonParser.ParseMedicinalProductIngredientSpecifiedSubstance(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicinalProductIngredientSpecifiedSubstance(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicinalProductIngredientSpecifiedSubstance(jsn : TJsonObject) : TFhirMedicinalProductIngredientSpecifiedSubstance;
begin
  result := TFhirMedicinalProductIngredientSpecifiedSubstance.create;
  try
    ParseMedicinalProductIngredientSpecifiedSubstanceProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicinalProductIngredientSpecifiedSubstanceProperties(jsn : TJsonObject; result : TFhirMedicinalProductIngredientSpecifiedSubstance);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('group') then
        result.group := ParseCodeableConcept(jsn.vObj['group']);{q3}
    if jsn.has('confidentiality') then
        result.confidentiality := ParseCodeableConcept(jsn.vObj['confidentiality']);{q3}
    if jsn.has('strength') then
      iterateArray(jsn.vArr['strength'], result.strengthList, parseMedicinalProductIngredientSpecifiedSubstanceStrength);
end;

procedure TFHIRJsonComposer.ComposeMedicinalProductIngredientSpecifiedSubstance(json : TJSONWriter; name : string; elem : TFhirMedicinalProductIngredientSpecifiedSubstance; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  ComposeCodeableConcept(json, 'group', elem.group); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'confidentiality', elem.confidentiality); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.strengthList.Count > 0) then
  begin
    json.valueArray('strength');
    for i := 0 to elem.strengthList.Count - 1 do
      ComposeMedicinalProductIngredientSpecifiedSubstanceStrength(json, '', elem.strengthList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseMedicinalProductIngredientSpecifiedSubstanceStrength(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicinalProductIngredientSpecifiedSubstanceStrength(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicinalProductIngredientSpecifiedSubstanceStrength(jsn : TJsonObject) : TFhirMedicinalProductIngredientSpecifiedSubstanceStrength;
begin
  result := TFhirMedicinalProductIngredientSpecifiedSubstanceStrength.create;
  try
    ParseMedicinalProductIngredientSpecifiedSubstanceStrengthProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicinalProductIngredientSpecifiedSubstanceStrengthProperties(jsn : TJsonObject; result : TFhirMedicinalProductIngredientSpecifiedSubstanceStrength);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('presentation') then
        result.presentation := ParseRatio(jsn.vObj['presentation']);{q3}
    if jsn.has('presentationLowLimit') then
        result.presentationLowLimit := ParseRatio(jsn.vObj['presentationLowLimit']);{q3}
    if jsn.has('concentration') then
        result.concentration := ParseRatio(jsn.vObj['concentration']);{q3}
    if jsn.has('concentrationLowLimit') then
        result.concentrationLowLimit := ParseRatio(jsn.vObj['concentrationLowLimit']);{q3}
    if jsn.has('measurementPoint') or jsn.has('_measurementPoint') then
        result.measurementPointElement := parseString(jsn.node['measurementPoint'], jsn.vObj['_measurementPoint']);{q}
    if jsn.has('country') then
      iterateArray(jsn.vArr['country'], result.countryList, parseCodeableConcept);
    if jsn.has('referenceStrength') then
      iterateArray(jsn.vArr['referenceStrength'], result.referenceStrengthList, parseMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength);
end;

procedure TFHIRJsonComposer.ComposeMedicinalProductIngredientSpecifiedSubstanceStrength(json : TJSONWriter; name : string; elem : TFhirMedicinalProductIngredientSpecifiedSubstanceStrength; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeRatio(json, 'presentation', elem.presentation); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeRatio(json, 'presentationLowLimit', elem.presentationLowLimit); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeRatio(json, 'concentration', elem.concentration); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeRatio(json, 'concentrationLowLimit', elem.concentrationLowLimit); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'measurementPoint', elem.measurementPointElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'measurementPoint', elem.measurementPointElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.countryList.Count > 0) then
  begin
    json.valueArray('country');
    for i := 0 to elem.countryList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.countryList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.referenceStrengthList.Count > 0) then
  begin
    json.valueArray('referenceStrength');
    for i := 0 to elem.referenceStrengthList.Count - 1 do
      ComposeMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength(json, '', elem.referenceStrengthList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength(jsn : TJsonObject) : TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength;
begin
  result := TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength.create;
  try
    ParseMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrengthProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrengthProperties(jsn : TJsonObject; result : TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('substance') then
        result.substance := ParseCodeableConcept(jsn.vObj['substance']);{q3}
    if jsn.has('strength') then
        result.strength := ParseRatio(jsn.vObj['strength']);{q3}
    if jsn.has('strengthLowLimit') then
        result.strengthLowLimit := ParseRatio(jsn.vObj['strengthLowLimit']);{q3}
    if jsn.has('measurementPoint') or jsn.has('_measurementPoint') then
        result.measurementPointElement := parseString(jsn.node['measurementPoint'], jsn.vObj['_measurementPoint']);{q}
    if jsn.has('country') then
      iterateArray(jsn.vArr['country'], result.countryList, parseCodeableConcept);
end;

procedure TFHIRJsonComposer.ComposeMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength(json : TJSONWriter; name : string; elem : TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'substance', elem.substance); {a}
  ComposeRatio(json, 'strength', elem.strength); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeRatio(json, 'strengthLowLimit', elem.strengthLowLimit); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'measurementPoint', elem.measurementPointElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'measurementPoint', elem.measurementPointElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.countryList.Count > 0) then
  begin
    json.valueArray('country');
    for i := 0 to elem.countryList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.countryList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseMedicinalProductIngredientSubstance(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicinalProductIngredientSubstance(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicinalProductIngredientSubstance(jsn : TJsonObject) : TFhirMedicinalProductIngredientSubstance;
begin
  result := TFhirMedicinalProductIngredientSubstance.create;
  try
    ParseMedicinalProductIngredientSubstanceProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicinalProductIngredientSubstanceProperties(jsn : TJsonObject; result : TFhirMedicinalProductIngredientSubstance);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('strength') then
      iterateArray(jsn.vArr['strength'], result.strengthList, parseMedicinalProductIngredientSpecifiedSubstanceStrength);
end;

procedure TFHIRJsonComposer.ComposeMedicinalProductIngredientSubstance(json : TJSONWriter; name : string; elem : TFhirMedicinalProductIngredientSubstance; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.strengthList.Count > 0) then
  begin
    json.valueArray('strength');
    for i := 0 to elem.strengthList.Count - 1 do
      ComposeMedicinalProductIngredientSpecifiedSubstanceStrength(json, '', elem.strengthList[i]); {z - @MedicinalProductIngredient.specifiedSubstance.strength}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseMedicinalProductIngredient(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicinalProductIngredient(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicinalProductIngredient(jsn : TJsonObject) : TFhirMedicinalProductIngredient;
begin
  result := TFhirMedicinalProductIngredient.create;
  try
    ParseMedicinalProductIngredientProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicinalProductIngredientProperties(jsn : TJsonObject; result : TFhirMedicinalProductIngredient);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q3}
    if jsn.has('role') then
        result.role := ParseCodeableConcept(jsn.vObj['role']);{q3}
    if jsn.has('allergenicIndicator') or jsn.has('_allergenicIndicator') then
        result.allergenicIndicatorElement := parseBoolean(jsn.node['allergenicIndicator'], jsn.vObj['_allergenicIndicator']);{q}
    if jsn.has('manufacturer') then
      iterateArray(jsn.vArr['manufacturer'], result.manufacturerList, parseReference{TFhirOrganization});
    if jsn.has('specifiedSubstance') then
      iterateArray(jsn.vArr['specifiedSubstance'], result.specifiedSubstanceList, parseMedicinalProductIngredientSpecifiedSubstance);
    if jsn.has('substance') then
        result.substance := ParseMedicinalProductIngredientSubstance(jsn.vObj['substance']);{q3}
end;

procedure TFHIRJsonComposer.ComposeMedicinalProductIngredient(json : TJSONWriter; name : string; elem : TFhirMedicinalProductIngredient; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  ComposeCodeableConcept(json, 'role', elem.role); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('allergenicIndicator') then
    ComposeBooleanValue(json, 'allergenicIndicator', elem.allergenicIndicatorElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('allergenicIndicator') then
    ComposeBooleanProps(json, 'allergenicIndicator', elem.allergenicIndicatorElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('manufacturer') and (elem.manufacturerList.Count > 0) then
  begin
    json.valueArray('manufacturer');
    for i := 0 to elem.manufacturerList.Count - 1 do
      ComposeReference{TFhirOrganization}(json, '', elem.manufacturerList[i]); {z - Reference(Organization)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('specifiedSubstance') and (elem.specifiedSubstanceList.Count > 0) then
  begin
    json.valueArray('specifiedSubstance');
    for i := 0 to elem.specifiedSubstanceList.Count - 1 do
      ComposeMedicinalProductIngredientSpecifiedSubstance(json, '', elem.specifiedSubstanceList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('substance') then
    ComposeMedicinalProductIngredientSubstance(json, 'substance', elem.substance); {a}
end;

{$ENDIF FHIR_MEDICINALPRODUCTINGREDIENT}
{$IFDEF FHIR_MEDICINALPRODUCTINTERACTION}
procedure TFHIRJsonParser.ParseMedicinalProductInteractionInteractant(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicinalProductInteractionInteractant(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicinalProductInteractionInteractant(jsn : TJsonObject) : TFhirMedicinalProductInteractionInteractant;
begin
  result := TFhirMedicinalProductInteractionInteractant.create;
  try
    ParseMedicinalProductInteractionInteractantProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicinalProductInteractionInteractantProperties(jsn : TJsonObject; result : TFhirMedicinalProductInteractionInteractant);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('itemReference') {a3} then
      result.item := ParseReference(jsn.vObj['itemReference']);
    if jsn.has('itemCodeableConcept') {a4} then
      result.item := ParseCodeableConcept(jsn.vObj['itemCodeableConcept']);
end;

procedure TFHIRJsonComposer.ComposeMedicinalProductInteractionInteractant(json : TJSONWriter; name : string; elem : TFhirMedicinalProductInteractionInteractant; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (elem.item is TFhirReference) then
    ComposeReference(json, 'itemReference', TFhirReference(elem.item))
  else if (elem.item is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'itemCodeableConcept', TFhirCodeableConcept(elem.item)) ;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseMedicinalProductInteraction(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicinalProductInteraction(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicinalProductInteraction(jsn : TJsonObject) : TFhirMedicinalProductInteraction;
begin
  result := TFhirMedicinalProductInteraction.create;
  try
    ParseMedicinalProductInteractionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicinalProductInteractionProperties(jsn : TJsonObject; result : TFhirMedicinalProductInteraction);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('subject') then
      iterateArray(jsn.vArr['subject'], result.subjectList, parseReference{TFhirMedicinalProduct});
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('interactant') then
      iterateArray(jsn.vArr['interactant'], result.interactantList, parseMedicinalProductInteractionInteractant);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('effect') then
        result.effect := ParseCodeableConcept(jsn.vObj['effect']);{q3}
    if jsn.has('incidence') then
        result.incidence := ParseCodeableConcept(jsn.vObj['incidence']);{q3}
    if jsn.has('management') then
        result.management := ParseCodeableConcept(jsn.vObj['management']);{q3}
end;

procedure TFHIRJsonComposer.ComposeMedicinalProductInteraction(json : TJSONWriter; name : string; elem : TFhirMedicinalProductInteraction; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') and (elem.subjectList.Count > 0) then
  begin
    json.valueArray('subject');
    for i := 0 to elem.subjectList.Count - 1 do
      ComposeReference{TFhirMedicinalProduct}(json, '', elem.subjectList[i]); {z - Reference(MedicinalProduct)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('interactant') and (elem.interactantList.Count > 0) then
  begin
    json.valueArray('interactant');
    for i := 0 to elem.interactantList.Count - 1 do
      ComposeMedicinalProductInteractionInteractant(json, '', elem.interactantList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('effect') then
    ComposeCodeableConcept(json, 'effect', elem.effect); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('incidence') then
    ComposeCodeableConcept(json, 'incidence', elem.incidence); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('management') then
    ComposeCodeableConcept(json, 'management', elem.management); {a}
end;

{$ENDIF FHIR_MEDICINALPRODUCTINTERACTION}
{$IFDEF FHIR_MEDICINALPRODUCTMANUFACTURED}
procedure TFHIRJsonParser.ParseMedicinalProductManufactured(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicinalProductManufactured(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicinalProductManufactured(jsn : TJsonObject) : TFhirMedicinalProductManufactured;
begin
  result := TFhirMedicinalProductManufactured.create;
  try
    ParseMedicinalProductManufacturedProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicinalProductManufacturedProperties(jsn : TJsonObject; result : TFhirMedicinalProductManufactured);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('manufacturedDoseForm') then
        result.manufacturedDoseForm := ParseCodeableConcept(jsn.vObj['manufacturedDoseForm']);{q3}
    if jsn.has('unitOfPresentation') then
        result.unitOfPresentation := ParseCodeableConcept(jsn.vObj['unitOfPresentation']);{q3}
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q3}
    if jsn.has('manufacturer') then
      iterateArray(jsn.vArr['manufacturer'], result.manufacturerList, parseReference{TFhirOrganization});
    if jsn.has('ingredient') then
      iterateArray(jsn.vArr['ingredient'], result.ingredientList, parseReference{TFhirMedicinalProductIngredient});
    if jsn.has('physicalCharacteristics') then
        result.physicalCharacteristics := ParseProdCharacteristic(jsn.vObj['physicalCharacteristics']);{q3}
    if jsn.has('otherCharacteristics') then
      iterateArray(jsn.vArr['otherCharacteristics'], result.otherCharacteristicsList, parseCodeableConcept);
end;

procedure TFHIRJsonComposer.ComposeMedicinalProductManufactured(json : TJSONWriter; name : string; elem : TFhirMedicinalProductManufactured; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  ComposeCodeableConcept(json, 'manufacturedDoseForm', elem.manufacturedDoseForm); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('unitOfPresentation') then
    ComposeCodeableConcept(json, 'unitOfPresentation', elem.unitOfPresentation); {a}
    ComposeQuantity(json, 'quantity', elem.quantity); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('manufacturer') and (elem.manufacturerList.Count > 0) then
  begin
    json.valueArray('manufacturer');
    for i := 0 to elem.manufacturerList.Count - 1 do
      ComposeReference{TFhirOrganization}(json, '', elem.manufacturerList[i]); {z - Reference(Organization)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('ingredient') and (elem.ingredientList.Count > 0) then
  begin
    json.valueArray('ingredient');
    for i := 0 to elem.ingredientList.Count - 1 do
      ComposeReference{TFhirMedicinalProductIngredient}(json, '', elem.ingredientList[i]); {z - Reference(MedicinalProductIngredient)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('physicalCharacteristics') then
    ComposeProdCharacteristic(json, 'physicalCharacteristics', elem.physicalCharacteristics); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('otherCharacteristics') and (elem.otherCharacteristicsList.Count > 0) then
  begin
    json.valueArray('otherCharacteristics');
    for i := 0 to elem.otherCharacteristicsList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.otherCharacteristicsList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_MEDICINALPRODUCTMANUFACTURED}
{$IFDEF FHIR_MEDICINALPRODUCTPACKAGED}
procedure TFHIRJsonParser.ParseMedicinalProductPackagedBatchIdentifier(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicinalProductPackagedBatchIdentifier(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicinalProductPackagedBatchIdentifier(jsn : TJsonObject) : TFhirMedicinalProductPackagedBatchIdentifier;
begin
  result := TFhirMedicinalProductPackagedBatchIdentifier.create;
  try
    ParseMedicinalProductPackagedBatchIdentifierProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicinalProductPackagedBatchIdentifierProperties(jsn : TJsonObject; result : TFhirMedicinalProductPackagedBatchIdentifier);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('outerPackaging') then
        result.outerPackaging := ParseIdentifier(jsn.vObj['outerPackaging']);{q3}
    if jsn.has('immediatePackaging') then
        result.immediatePackaging := ParseIdentifier(jsn.vObj['immediatePackaging']);{q3}
end;

procedure TFHIRJsonComposer.ComposeMedicinalProductPackagedBatchIdentifier(json : TJSONWriter; name : string; elem : TFhirMedicinalProductPackagedBatchIdentifier; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeIdentifier(json, 'outerPackaging', elem.outerPackaging); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(json, 'immediatePackaging', elem.immediatePackaging); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseMedicinalProductPackagedPackageItem(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicinalProductPackagedPackageItem(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicinalProductPackagedPackageItem(jsn : TJsonObject) : TFhirMedicinalProductPackagedPackageItem;
begin
  result := TFhirMedicinalProductPackagedPackageItem.create;
  try
    ParseMedicinalProductPackagedPackageItemProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicinalProductPackagedPackageItemProperties(jsn : TJsonObject; result : TFhirMedicinalProductPackagedPackageItem);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q3}
    if jsn.has('material') then
      iterateArray(jsn.vArr['material'], result.materialList, parseCodeableConcept);
    if jsn.has('alternateMaterial') then
      iterateArray(jsn.vArr['alternateMaterial'], result.alternateMaterialList, parseCodeableConcept);
    if jsn.has('device') then
      iterateArray(jsn.vArr['device'], result.deviceList, parseReference{TFhirDeviceDefinition});
    if jsn.has('manufacturedItem') then
      iterateArray(jsn.vArr['manufacturedItem'], result.manufacturedItemList, parseReference{TFhirMedicinalProductManufactured});
    if jsn.has('packageItem') then
      iterateArray(jsn.vArr['packageItem'], result.packageItemList, parseMedicinalProductPackagedPackageItem);
    if jsn.has('physicalCharacteristics') then
        result.physicalCharacteristics := ParseProdCharacteristic(jsn.vObj['physicalCharacteristics']);{q3}
    if jsn.has('otherCharacteristics') then
      iterateArray(jsn.vArr['otherCharacteristics'], result.otherCharacteristicsList, parseCodeableConcept);
    if jsn.has('shelfLifeStorage') then
      iterateArray(jsn.vArr['shelfLifeStorage'], result.shelfLifeStorageList, parseProductShelfLife);
    if jsn.has('manufacturer') then
      iterateArray(jsn.vArr['manufacturer'], result.manufacturerList, parseReference{TFhirOrganization});
end;

procedure TFHIRJsonComposer.ComposeMedicinalProductPackagedPackageItem(json : TJSONWriter; name : string; elem : TFhirMedicinalProductPackagedPackageItem; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  ComposeQuantity(json, 'quantity', elem.quantity); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.materialList.Count > 0) then
  begin
    json.valueArray('material');
    for i := 0 to elem.materialList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.materialList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.alternateMaterialList.Count > 0) then
  begin
    json.valueArray('alternateMaterial');
    for i := 0 to elem.alternateMaterialList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.alternateMaterialList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.deviceList.Count > 0) then
  begin
    json.valueArray('device');
    for i := 0 to elem.deviceList.Count - 1 do
      ComposeReference{TFhirDeviceDefinition}(json, '', elem.deviceList[i]); {z - Reference(DeviceDefinition)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.manufacturedItemList.Count > 0) then
  begin
    json.valueArray('manufacturedItem');
    for i := 0 to elem.manufacturedItemList.Count - 1 do
      ComposeReference{TFhirMedicinalProductManufactured}(json, '', elem.manufacturedItemList[i]); {z - Reference(MedicinalProductManufactured)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.packageItemList.Count > 0) then
  begin
    json.valueArray('packageItem');
    for i := 0 to elem.packageItemList.Count - 1 do
      ComposeMedicinalProductPackagedPackageItem(json, '', elem.packageItemList[i]); {z - @MedicinalProductPackaged.packageItem}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeProdCharacteristic(json, 'physicalCharacteristics', elem.physicalCharacteristics); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.otherCharacteristicsList.Count > 0) then
  begin
    json.valueArray('otherCharacteristics');
    for i := 0 to elem.otherCharacteristicsList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.otherCharacteristicsList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.shelfLifeStorageList.Count > 0) then
  begin
    json.valueArray('shelfLifeStorage');
    for i := 0 to elem.shelfLifeStorageList.Count - 1 do
      ComposeProductShelfLife(json, '', elem.shelfLifeStorageList[i]); {z - ProductShelfLife}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.manufacturerList.Count > 0) then
  begin
    json.valueArray('manufacturer');
    for i := 0 to elem.manufacturerList.Count - 1 do
      ComposeReference{TFhirOrganization}(json, '', elem.manufacturerList[i]); {z - Reference(Organization)}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseMedicinalProductPackaged(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicinalProductPackaged(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicinalProductPackaged(jsn : TJsonObject) : TFhirMedicinalProductPackaged;
begin
  result := TFhirMedicinalProductPackaged.create;
  try
    ParseMedicinalProductPackagedProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicinalProductPackagedProperties(jsn : TJsonObject; result : TFhirMedicinalProductPackaged);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('subject') then
      iterateArray(jsn.vArr['subject'], result.subjectList, parseReference{TFhirMedicinalProduct});
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('legalStatusOfSupply') then
        result.legalStatusOfSupply := ParseCodeableConcept(jsn.vObj['legalStatusOfSupply']);{q3}
    if jsn.has('marketingStatus') then
      iterateArray(jsn.vArr['marketingStatus'], result.marketingStatusList, parseMarketingStatus);
    if jsn.has('marketingAuthorization') then
        result.marketingAuthorization := ParseReference{TFhirMedicinalProductAuthorization}(jsn.vObj['marketingAuthorization']);{q3}
    if jsn.has('manufacturer') then
      iterateArray(jsn.vArr['manufacturer'], result.manufacturerList, parseReference{TFhirOrganization});
    if jsn.has('batchIdentifier') then
      iterateArray(jsn.vArr['batchIdentifier'], result.batchIdentifierList, parseMedicinalProductPackagedBatchIdentifier);
    if jsn.has('packageItem') then
      iterateArray(jsn.vArr['packageItem'], result.packageItemList, parseMedicinalProductPackagedPackageItem);
end;

procedure TFHIRJsonComposer.ComposeMedicinalProductPackaged(json : TJSONWriter; name : string; elem : TFhirMedicinalProductPackaged; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') and (elem.subjectList.Count > 0) then
  begin
    json.valueArray('subject');
    for i := 0 to elem.subjectList.Count - 1 do
      ComposeReference{TFhirMedicinalProduct}(json, '', elem.subjectList[i]); {z - Reference(MedicinalProduct)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('legalStatusOfSupply') then
    ComposeCodeableConcept(json, 'legalStatusOfSupply', elem.legalStatusOfSupply); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('marketingStatus') and (elem.marketingStatusList.Count > 0) then
  begin
    json.valueArray('marketingStatus');
    for i := 0 to elem.marketingStatusList.Count - 1 do
      ComposeMarketingStatus(json, '', elem.marketingStatusList[i]); {z - MarketingStatus}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('marketingAuthorization') then
    ComposeReference{TFhirMedicinalProductAuthorization}(json, 'marketingAuthorization', elem.marketingAuthorization); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('manufacturer') and (elem.manufacturerList.Count > 0) then
  begin
    json.valueArray('manufacturer');
    for i := 0 to elem.manufacturerList.Count - 1 do
      ComposeReference{TFhirOrganization}(json, '', elem.manufacturerList[i]); {z - Reference(Organization)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('batchIdentifier') and (elem.batchIdentifierList.Count > 0) then
  begin
    json.valueArray('batchIdentifier');
    for i := 0 to elem.batchIdentifierList.Count - 1 do
      ComposeMedicinalProductPackagedBatchIdentifier(json, '', elem.batchIdentifierList[i]); {z - }
    json.FinishArray;
  end;
  if (elem.packageItemList.Count > 0) then
  begin
    json.valueArray('packageItem');
    for i := 0 to elem.packageItemList.Count - 1 do
      ComposeMedicinalProductPackagedPackageItem(json, '', elem.packageItemList[i]); {z - }
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_MEDICINALPRODUCTPACKAGED}
{$IFDEF FHIR_MEDICINALPRODUCTPHARMACEUTICAL}
procedure TFHIRJsonParser.ParseMedicinalProductPharmaceuticalCharacteristics(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicinalProductPharmaceuticalCharacteristics(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicinalProductPharmaceuticalCharacteristics(jsn : TJsonObject) : TFhirMedicinalProductPharmaceuticalCharacteristics;
begin
  result := TFhirMedicinalProductPharmaceuticalCharacteristics.create;
  try
    ParseMedicinalProductPharmaceuticalCharacteristicsProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicinalProductPharmaceuticalCharacteristicsProperties(jsn : TJsonObject; result : TFhirMedicinalProductPharmaceuticalCharacteristics);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('status') then
        result.status := ParseCodeableConcept(jsn.vObj['status']);{q3}
end;

procedure TFHIRJsonComposer.ComposeMedicinalProductPharmaceuticalCharacteristics(json : TJSONWriter; name : string; elem : TFhirMedicinalProductPharmaceuticalCharacteristics; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'status', elem.status); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseMedicinalProductPharmaceuticalRouteOfAdministration(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicinalProductPharmaceuticalRouteOfAdministration(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicinalProductPharmaceuticalRouteOfAdministration(jsn : TJsonObject) : TFhirMedicinalProductPharmaceuticalRouteOfAdministration;
begin
  result := TFhirMedicinalProductPharmaceuticalRouteOfAdministration.create;
  try
    ParseMedicinalProductPharmaceuticalRouteOfAdministrationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicinalProductPharmaceuticalRouteOfAdministrationProperties(jsn : TJsonObject; result : TFhirMedicinalProductPharmaceuticalRouteOfAdministration);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('firstDose') then
        result.firstDose := ParseQuantity(jsn.vObj['firstDose']);{q3}
    if jsn.has('maxSingleDose') then
        result.maxSingleDose := ParseQuantity(jsn.vObj['maxSingleDose']);{q3}
    if jsn.has('maxDosePerDay') then
        result.maxDosePerDay := ParseQuantity(jsn.vObj['maxDosePerDay']);{q3}
    if jsn.has('maxDosePerTreatmentPeriod') then
        result.maxDosePerTreatmentPeriod := ParseRatio(jsn.vObj['maxDosePerTreatmentPeriod']);{q3}
    if jsn.has('maxTreatmentPeriod') then
        result.maxTreatmentPeriod := ParseDuration(jsn.vObj['maxTreatmentPeriod']);{q3}
    if jsn.has('targetSpecies') then
      iterateArray(jsn.vArr['targetSpecies'], result.targetSpeciesList, parseMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies);
end;

procedure TFHIRJsonComposer.ComposeMedicinalProductPharmaceuticalRouteOfAdministration(json : TJSONWriter; name : string; elem : TFhirMedicinalProductPharmaceuticalRouteOfAdministration; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(json, 'firstDose', elem.firstDose); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(json, 'maxSingleDose', elem.maxSingleDose); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(json, 'maxDosePerDay', elem.maxDosePerDay); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeRatio(json, 'maxDosePerTreatmentPeriod', elem.maxDosePerTreatmentPeriod); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDuration(json, 'maxTreatmentPeriod', elem.maxTreatmentPeriod); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.targetSpeciesList.Count > 0) then
  begin
    json.valueArray('targetSpecies');
    for i := 0 to elem.targetSpeciesList.Count - 1 do
      ComposeMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies(json, '', elem.targetSpeciesList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies(jsn : TJsonObject) : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies;
begin
  result := TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies.create;
  try
    ParseMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesProperties(jsn : TJsonObject; result : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('withdrawalPeriod') then
      iterateArray(jsn.vArr['withdrawalPeriod'], result.withdrawalPeriodList, parseMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod);
end;

procedure TFHIRJsonComposer.ComposeMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies(json : TJSONWriter; name : string; elem : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.withdrawalPeriodList.Count > 0) then
  begin
    json.valueArray('withdrawalPeriod');
    for i := 0 to elem.withdrawalPeriodList.Count - 1 do
      ComposeMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod(json, '', elem.withdrawalPeriodList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod(jsn : TJsonObject) : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod;
begin
  result := TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod.create;
  try
    ParseMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriodProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriodProperties(jsn : TJsonObject; result : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('tissue') then
        result.tissue := ParseCodeableConcept(jsn.vObj['tissue']);{q3}
    if jsn.has('value') then
        result.value := ParseQuantity(jsn.vObj['value']);{q3}
    if jsn.has('supportingInformation') or jsn.has('_supportingInformation') then
        result.supportingInformationElement := parseString(jsn.node['supportingInformation'], jsn.vObj['_supportingInformation']);{q}
end;

procedure TFHIRJsonComposer.ComposeMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod(json : TJSONWriter; name : string; elem : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'tissue', elem.tissue); {a}
  ComposeQuantity(json, 'value', elem.value); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'supportingInformation', elem.supportingInformationElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'supportingInformation', elem.supportingInformationElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseMedicinalProductPharmaceutical(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicinalProductPharmaceutical(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicinalProductPharmaceutical(jsn : TJsonObject) : TFhirMedicinalProductPharmaceutical;
begin
  result := TFhirMedicinalProductPharmaceutical.create;
  try
    ParseMedicinalProductPharmaceuticalProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicinalProductPharmaceuticalProperties(jsn : TJsonObject; result : TFhirMedicinalProductPharmaceutical);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('administrableDoseForm') then
        result.administrableDoseForm := ParseCodeableConcept(jsn.vObj['administrableDoseForm']);{q3}
    if jsn.has('unitOfPresentation') then
        result.unitOfPresentation := ParseCodeableConcept(jsn.vObj['unitOfPresentation']);{q3}
    if jsn.has('ingredient') then
      iterateArray(jsn.vArr['ingredient'], result.ingredientList, parseReference{TFhirMedicinalProductIngredient});
    if jsn.has('device') then
      iterateArray(jsn.vArr['device'], result.deviceList, parseReference{TFhirDeviceDefinition});
    if jsn.has('characteristics') then
      iterateArray(jsn.vArr['characteristics'], result.characteristicsList, parseMedicinalProductPharmaceuticalCharacteristics);
    if jsn.has('routeOfAdministration') then
      iterateArray(jsn.vArr['routeOfAdministration'], result.routeOfAdministrationList, parseMedicinalProductPharmaceuticalRouteOfAdministration);
end;

procedure TFHIRJsonComposer.ComposeMedicinalProductPharmaceutical(json : TJSONWriter; name : string; elem : TFhirMedicinalProductPharmaceutical; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeCodeableConcept(json, 'administrableDoseForm', elem.administrableDoseForm); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('unitOfPresentation') then
    ComposeCodeableConcept(json, 'unitOfPresentation', elem.unitOfPresentation); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('ingredient') and (elem.ingredientList.Count > 0) then
  begin
    json.valueArray('ingredient');
    for i := 0 to elem.ingredientList.Count - 1 do
      ComposeReference{TFhirMedicinalProductIngredient}(json, '', elem.ingredientList[i]); {z - Reference(MedicinalProductIngredient)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('device') and (elem.deviceList.Count > 0) then
  begin
    json.valueArray('device');
    for i := 0 to elem.deviceList.Count - 1 do
      ComposeReference{TFhirDeviceDefinition}(json, '', elem.deviceList[i]); {z - Reference(DeviceDefinition)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('characteristics') and (elem.characteristicsList.Count > 0) then
  begin
    json.valueArray('characteristics');
    for i := 0 to elem.characteristicsList.Count - 1 do
      ComposeMedicinalProductPharmaceuticalCharacteristics(json, '', elem.characteristicsList[i]); {z - }
    json.FinishArray;
  end;
  if (elem.routeOfAdministrationList.Count > 0) then
  begin
    json.valueArray('routeOfAdministration');
    for i := 0 to elem.routeOfAdministrationList.Count - 1 do
      ComposeMedicinalProductPharmaceuticalRouteOfAdministration(json, '', elem.routeOfAdministrationList[i]); {z - }
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_MEDICINALPRODUCTPHARMACEUTICAL}
{$IFDEF FHIR_MEDICINALPRODUCTUNDESIRABLEEFFECT}
procedure TFHIRJsonParser.ParseMedicinalProductUndesirableEffect(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicinalProductUndesirableEffect(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicinalProductUndesirableEffect(jsn : TJsonObject) : TFhirMedicinalProductUndesirableEffect;
begin
  result := TFhirMedicinalProductUndesirableEffect.create;
  try
    ParseMedicinalProductUndesirableEffectProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicinalProductUndesirableEffectProperties(jsn : TJsonObject; result : TFhirMedicinalProductUndesirableEffect);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('subject') then
      iterateArray(jsn.vArr['subject'], result.subjectList, parseReference{TFhirMedicinalProduct});
    if jsn.has('symptomConditionEffect') then
        result.symptomConditionEffect := ParseCodeableConcept(jsn.vObj['symptomConditionEffect']);{q3}
    if jsn.has('classification') then
        result.classification := ParseCodeableConcept(jsn.vObj['classification']);{q3}
    if jsn.has('frequencyOfOccurrence') then
        result.frequencyOfOccurrence := ParseCodeableConcept(jsn.vObj['frequencyOfOccurrence']);{q3}
    if jsn.has('population') then
      iterateArray(jsn.vArr['population'], result.populationList, parsePopulation);
end;

procedure TFHIRJsonComposer.ComposeMedicinalProductUndesirableEffect(json : TJSONWriter; name : string; elem : TFhirMedicinalProductUndesirableEffect; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') and (elem.subjectList.Count > 0) then
  begin
    json.valueArray('subject');
    for i := 0 to elem.subjectList.Count - 1 do
      ComposeReference{TFhirMedicinalProduct}(json, '', elem.subjectList[i]); {z - Reference(MedicinalProduct)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('symptomConditionEffect') then
    ComposeCodeableConcept(json, 'symptomConditionEffect', elem.symptomConditionEffect); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('classification') then
    ComposeCodeableConcept(json, 'classification', elem.classification); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('frequencyOfOccurrence') then
    ComposeCodeableConcept(json, 'frequencyOfOccurrence', elem.frequencyOfOccurrence); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('population') and (elem.populationList.Count > 0) then
  begin
    json.valueArray('population');
    for i := 0 to elem.populationList.Count - 1 do
      ComposePopulation(json, '', elem.populationList[i]); {z - Population}
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_MEDICINALPRODUCTUNDESIRABLEEFFECT}
{$IFDEF FHIR_MESSAGEDEFINITION}
procedure TFHIRJsonParser.ParseMessageDefinitionFocus(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMessageDefinitionFocus(jsn)); {2}
end;

function TFHIRJsonParser.ParseMessageDefinitionFocus(jsn : TJsonObject) : TFhirMessageDefinitionFocus;
begin
  result := TFhirMessageDefinitionFocus.create;
  try
    ParseMessageDefinitionFocusProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMessageDefinitionFocusProperties(jsn : TJsonObject; result : TFhirMessageDefinitionFocus);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') or jsn.has('_code')  then
      result.codeElement := parseEnum(jsn.path+'/code', jsn.node['code'], jsn.vObj['_code'], CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum);
    if jsn.has('profile') or jsn.has('_profile') then
        result.profileElement := parseCanonical(jsn.node['profile'], jsn.vObj['_profile']);{q}
    if jsn.has('min') or jsn.has('_min') then
        result.minElement := parseUnsignedInt(jsn.node['min'], jsn.vObj['_min']);{q}
    if jsn.has('max') or jsn.has('_max') then
        result.maxElement := parseString(jsn.node['max'], jsn.vObj['_max']);{q}
end;

procedure TFHIRJsonComposer.ComposeMessageDefinitionFocus(json : TJSONWriter; name : string; elem : TFhirMessageDefinitionFocus; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'code', elem.CodeElement, CODES_TFhirResourceTypesEnum, false);
  ComposeEnumProps(json, 'code', elem.CodeElement, CODES_TFhirResourceTypesEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonicalValue(json, 'profile', elem.profileElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonicalProps(json, 'profile', elem.profileElement, false);
  ComposeUnsignedIntValue(json, 'min', elem.minElement, false);
  ComposeUnsignedIntProps(json, 'min', elem.minElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'max', elem.maxElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'max', elem.maxElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseMessageDefinitionAllowedResponse(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMessageDefinitionAllowedResponse(jsn)); {2}
end;

function TFHIRJsonParser.ParseMessageDefinitionAllowedResponse(jsn : TJsonObject) : TFhirMessageDefinitionAllowedResponse;
begin
  result := TFhirMessageDefinitionAllowedResponse.create;
  try
    ParseMessageDefinitionAllowedResponseProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMessageDefinitionAllowedResponseProperties(jsn : TJsonObject; result : TFhirMessageDefinitionAllowedResponse);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('message') or jsn.has('_message') then
        result.messageElement := parseCanonical(jsn.node['message'], jsn.vObj['_message']);{q}
    if jsn.has('situation') or jsn.has('_situation') then
        result.situationElement := parseMarkdown(jsn.node['situation'], jsn.vObj['_situation']);{q}
end;

procedure TFHIRJsonComposer.ComposeMessageDefinitionAllowedResponse(json : TJSONWriter; name : string; elem : TFhirMessageDefinitionAllowedResponse; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCanonicalValue(json, 'message', elem.messageElement, false);
  ComposeCanonicalProps(json, 'message', elem.messageElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdownValue(json, 'situation', elem.situationElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdownProps(json, 'situation', elem.situationElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseMessageDefinition(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMessageDefinition(jsn)); {2}
end;

function TFHIRJsonParser.ParseMessageDefinition(jsn : TJsonObject) : TFhirMessageDefinition;
begin
  result := TFhirMessageDefinition.create;
  try
    ParseMessageDefinitionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMessageDefinitionProperties(jsn : TJsonObject; result : TFhirMessageDefinition);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := parseUri(jsn.node['url'], jsn.vObj['_url']);{q}
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := parseString(jsn.node['version'], jsn.vObj['_version']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('title') or jsn.has('_title') then
        result.titleElement := parseString(jsn.node['title'], jsn.vObj['_title']);{q}
      if jsn.has('replaces') or jsn.has('_replaces') then
      iteratePrimitiveArray(jsn.vArr['replaces'], jsn.vArr['_replaces'], result.replacesList, parseCanonical);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    if jsn.has('experimental') or jsn.has('_experimental') then
        result.experimentalElement := parseBoolean(jsn.node['experimental'], jsn.vObj['_experimental']);{q}
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := parseDateTime(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('publisher') or jsn.has('_publisher') then
        result.publisherElement := parseString(jsn.node['publisher'], jsn.vObj['_publisher']);{q}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseContactDetail);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseMarkdown(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('useContext') then
      iterateArray(jsn.vArr['useContext'], result.useContextList, parseUsageContext);
    if jsn.has('jurisdiction') then
      iterateArray(jsn.vArr['jurisdiction'], result.jurisdictionList, parseCodeableConcept);
    if jsn.has('purpose') or jsn.has('_purpose') then
        result.purposeElement := parseMarkdown(jsn.node['purpose'], jsn.vObj['_purpose']);{q}
    if jsn.has('copyright') or jsn.has('_copyright') then
        result.copyrightElement := parseMarkdown(jsn.node['copyright'], jsn.vObj['_copyright']);{q}
    if jsn.has('base') or jsn.has('_base') then
        result.baseElement := parseCanonical(jsn.node['base'], jsn.vObj['_base']);{q}
      if jsn.has('parent') or jsn.has('_parent') then
      iteratePrimitiveArray(jsn.vArr['parent'], jsn.vArr['_parent'], result.parentList, parseCanonical);
    if jsn.has('eventCoding') {a4} then
      result.event := ParseCoding(jsn.vObj['eventCoding']);
    if jsn.has('eventUri') or jsn.has('_eventUri') then
      result.event := parseUri(jsn.node['eventUri'], jsn.vObj['_eventUri']);
    if jsn.has('category') or jsn.has('_category')  then
      result.categoryElement := parseEnum(jsn.path+'/category', jsn.node['category'], jsn.vObj['_category'], CODES_TFhirMessageSignificanceCategoryEnum, SYSTEMS_TFhirMessageSignificanceCategoryEnum);
    if jsn.has('focus') then
      iterateArray(jsn.vArr['focus'], result.focusList, parseMessageDefinitionFocus);
    if jsn.has('responseRequired') or jsn.has('_responseRequired')  then
      result.responseRequiredElement := parseEnum(jsn.path+'/responseRequired', jsn.node['responseRequired'], jsn.vObj['_responseRequired'], CODES_TFhirMessageheaderResponseRequestEnum, SYSTEMS_TFhirMessageheaderResponseRequestEnum);
    if jsn.has('allowedResponse') then
      iterateArray(jsn.vArr['allowedResponse'], result.allowedResponseList, parseMessageDefinitionAllowedResponse);
      if jsn.has('graph') or jsn.has('_graph') then
      iteratePrimitiveArray(jsn.vArr['graph'], jsn.vArr['_graph'], result.graphList, parseCanonical);
end;

procedure TFHIRJsonComposer.ComposeMessageDefinition(json : TJSONWriter; name : string; elem : TFhirMessageDefinition; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUriValue(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUriProps(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeStringValue(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeStringProps(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeStringValue(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeStringProps(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('replaces') and (elem.replacesList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.replacesList.Count - 1 do
    begin
      ext := ext or ((elem.replacesList[i].id <> '') or (elem.replacesList[i].hasExtensionList) {no-comments or (elem.replacesList[i].hasComments)});
      val := val or (elem.replacesList[i].hasPrimitiveValue);
    end;
    if val then
  begin
      json.valueArray('replaces');
      for i := 0 to elem.replacesList.Count - 1 do
        ComposeCanonicalValue(json, '',elem.replacesList[i], true);
    json.FinishArray;
  end;
    if ext then
  begin
      json.valueArray('_replaces');
      for i := 0 to elem.replacesList.Count - 1 do
        ComposeCanonicalProps(json, '',elem.replacesList[i], true);
    json.FinishArray;
  end;
  end;
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBooleanValue(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBooleanProps(json, 'experimental', elem.experimentalElement, false);
  ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringValue(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringProps(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') and (elem.contactList.Count > 0) then
  begin
    json.valueArray('contact');
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(json, '', elem.contactList[i]); {z - ContactDetail}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeMarkdownValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeMarkdownProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') and (elem.useContextList.Count > 0) then
  begin
    json.valueArray('useContext');
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(json, '', elem.useContextList[i]); {z - UsageContext}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') and (elem.jurisdictionList.Count > 0) then
  begin
    json.valueArray('jurisdiction');
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.jurisdictionList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('purpose') then
    ComposeMarkdownValue(json, 'purpose', elem.purposeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('purpose') then
    ComposeMarkdownProps(json, 'purpose', elem.purposeElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdownValue(json, 'copyright', elem.copyrightElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdownProps(json, 'copyright', elem.copyrightElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('base') then
    ComposeCanonicalValue(json, 'base', elem.baseElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('base') then
    ComposeCanonicalProps(json, 'base', elem.baseElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('parent') and (elem.parentList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.parentList.Count - 1 do
  begin
      ext := ext or ((elem.parentList[i].id <> '') or (elem.parentList[i].hasExtensionList) {no-comments or (elem.parentList[i].hasComments)});
      val := val or (elem.parentList[i].hasPrimitiveValue);
  end;
    if val then
  begin
      json.valueArray('parent');
      for i := 0 to elem.parentList.Count - 1 do
        ComposeCanonicalValue(json, '',elem.parentList[i], true);
    json.FinishArray;
  end;
    if ext then
  begin
      json.valueArray('_parent');
      for i := 0 to elem.parentList.Count - 1 do
        ComposeCanonicalProps(json, '',elem.parentList[i], true);
    json.FinishArray;
  end;
  end;
  if (elem.event is TFhirCoding) then 
    ComposeCoding(json, 'eventCoding', TFhirCoding(elem.event)) 
  else if (elem.event is TFhirUri) then 
  begin
    ComposeUriValue(json, 'eventUri', TFhirUri(elem.event), false);
    ComposeUriProps(json, 'eventUri', TFhirUri(elem.event), false);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    ComposeEnumValue(json, 'category', elem.CategoryElement, CODES_TFhirMessageSignificanceCategoryEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    ComposeEnumProps(json, 'category', elem.CategoryElement, CODES_TFhirMessageSignificanceCategoryEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('focus') and (elem.focusList.Count > 0) then
  begin
    json.valueArray('focus');
    for i := 0 to elem.focusList.Count - 1 do
      ComposeMessageDefinitionFocus(json, '', elem.focusList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('responseRequired') then
    ComposeEnumValue(json, 'responseRequired', elem.ResponseRequiredElement, CODES_TFhirMessageheaderResponseRequestEnum, false);
  if (SummaryOption in [soFull, soData]) and doCompose('responseRequired') then
    ComposeEnumProps(json, 'responseRequired', elem.ResponseRequiredElement, CODES_TFhirMessageheaderResponseRequestEnum, false);
  if (SummaryOption in [soFull, soData]) and doCompose('allowedResponse') and (elem.allowedResponseList.Count > 0) then
  begin
    json.valueArray('allowedResponse');
    for i := 0 to elem.allowedResponseList.Count - 1 do
      ComposeMessageDefinitionAllowedResponse(json, '', elem.allowedResponseList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('graph') and (elem.graphList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.graphList.Count - 1 do
    begin
      ext := ext or ((elem.graphList[i].id <> '') or (elem.graphList[i].hasExtensionList) {no-comments or (elem.graphList[i].hasComments)});
      val := val or (elem.graphList[i].hasPrimitiveValue);
    end;
    if val then
  begin
      json.valueArray('graph');
      for i := 0 to elem.graphList.Count - 1 do
        ComposeCanonicalValue(json, '',elem.graphList[i], true);
    json.FinishArray;
  end;
    if ext then
  begin
      json.valueArray('_graph');
      for i := 0 to elem.graphList.Count - 1 do
        ComposeCanonicalProps(json, '',elem.graphList[i], true);
    json.FinishArray;
  end;
  end;
end;

{$ENDIF FHIR_MESSAGEDEFINITION}
{$IFDEF FHIR_MESSAGEHEADER}
procedure TFHIRJsonParser.ParseMessageHeaderDestination(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMessageHeaderDestination(jsn)); {2}
end;

function TFHIRJsonParser.ParseMessageHeaderDestination(jsn : TJsonObject) : TFhirMessageHeaderDestination;
begin
  result := TFhirMessageHeaderDestination.create;
  try
    ParseMessageHeaderDestinationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMessageHeaderDestinationProperties(jsn : TJsonObject; result : TFhirMessageHeaderDestination);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('target') then
        result.target := ParseReference{TFhirDevice}(jsn.vObj['target']);{q3}
    if jsn.has('endpoint') or jsn.has('_endpoint') then
        result.endpointElement := parseUrl(jsn.node['endpoint'], jsn.vObj['_endpoint']);{q}
    if jsn.has('receiver') then
        result.receiver := ParseReference{TFhirPractitioner}(jsn.vObj['receiver']);{q3}
end;

procedure TFHIRJsonComposer.ComposeMessageHeaderDestination(json : TJSONWriter; name : string; elem : TFhirMessageHeaderDestination; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirDevice}(json, 'target', elem.target); {a}
  ComposeUrlValue(json, 'endpoint', elem.endpointElement, false);
  ComposeUrlProps(json, 'endpoint', elem.endpointElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(json, 'receiver', elem.receiver); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseMessageHeaderSource(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMessageHeaderSource(jsn)); {2}
end;

function TFHIRJsonParser.ParseMessageHeaderSource(jsn : TJsonObject) : TFhirMessageHeaderSource;
begin
  result := TFhirMessageHeaderSource.create;
  try
    ParseMessageHeaderSourceProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMessageHeaderSourceProperties(jsn : TJsonObject; result : TFhirMessageHeaderSource);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('software') or jsn.has('_software') then
        result.softwareElement := parseString(jsn.node['software'], jsn.vObj['_software']);{q}
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := parseString(jsn.node['version'], jsn.vObj['_version']);{q}
    if jsn.has('contact') then
        result.contact := ParseContactPoint(jsn.vObj['contact']);{q3}
    if jsn.has('endpoint') or jsn.has('_endpoint') then
        result.endpointElement := parseUrl(jsn.node['endpoint'], jsn.vObj['_endpoint']);{q}
end;

procedure TFHIRJsonComposer.ComposeMessageHeaderSource(json : TJSONWriter; name : string; elem : TFhirMessageHeaderSource; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'software', elem.softwareElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'software', elem.softwareElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeContactPoint(json, 'contact', elem.contact); {a}
  ComposeUrlValue(json, 'endpoint', elem.endpointElement, false);
  ComposeUrlProps(json, 'endpoint', elem.endpointElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseMessageHeaderResponse(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMessageHeaderResponse(jsn)); {2}
end;

function TFHIRJsonParser.ParseMessageHeaderResponse(jsn : TJsonObject) : TFhirMessageHeaderResponse;
begin
  result := TFhirMessageHeaderResponse.create;
  try
    ParseMessageHeaderResponseProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMessageHeaderResponseProperties(jsn : TJsonObject; result : TFhirMessageHeaderResponse);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identifier') or jsn.has('_identifier') then
        result.identifierElement := parseId(jsn.node['identifier'], jsn.vObj['_identifier']);{q}
    if jsn.has('code') or jsn.has('_code')  then
      result.codeElement := parseEnum(jsn.path+'/code', jsn.node['code'], jsn.vObj['_code'], CODES_TFhirResponseCodeEnum, SYSTEMS_TFhirResponseCodeEnum);
    if jsn.has('details') then
        result.details := ParseReference{TFhirOperationOutcome}(jsn.vObj['details']);{q3}
end;

procedure TFHIRJsonComposer.ComposeMessageHeaderResponse(json : TJSONWriter; name : string; elem : TFhirMessageHeaderResponse; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeIdValue(json, 'identifier', elem.identifierElement, false);
  ComposeIdProps(json, 'identifier', elem.identifierElement, false);
  ComposeEnumValue(json, 'code', elem.CodeElement, CODES_TFhirResponseCodeEnum, false);
  ComposeEnumProps(json, 'code', elem.CodeElement, CODES_TFhirResponseCodeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOperationOutcome}(json, 'details', elem.details); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseMessageHeader(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMessageHeader(jsn)); {2}
end;

function TFHIRJsonParser.ParseMessageHeader(jsn : TJsonObject) : TFhirMessageHeader;
begin
  result := TFhirMessageHeader.create;
  try
    ParseMessageHeaderProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMessageHeaderProperties(jsn : TJsonObject; result : TFhirMessageHeader);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('eventCoding') {a4} then
      result.event := ParseCoding(jsn.vObj['eventCoding']);
    if jsn.has('eventUri') or jsn.has('_eventUri') then
      result.event := parseUri(jsn.node['eventUri'], jsn.vObj['_eventUri']);
    if jsn.has('destination') then
      iterateArray(jsn.vArr['destination'], result.destinationList, parseMessageHeaderDestination);
    if jsn.has('sender') then
        result.sender := ParseReference{TFhirPractitioner}(jsn.vObj['sender']);{q3}
    if jsn.has('enterer') then
        result.enterer := ParseReference{TFhirPractitioner}(jsn.vObj['enterer']);{q3}
    if jsn.has('author') then
        result.author := ParseReference{TFhirPractitioner}(jsn.vObj['author']);{q3}
    if jsn.has('source') then
        result.source := ParseMessageHeaderSource(jsn.vObj['source']);{q3}
    if jsn.has('responsible') then
        result.responsible := ParseReference{TFhirPractitioner}(jsn.vObj['responsible']);{q3}
    if jsn.has('reason') then
        result.reason := ParseCodeableConcept(jsn.vObj['reason']);{q3}
    if jsn.has('response') then
        result.response := ParseMessageHeaderResponse(jsn.vObj['response']);{q3}
    if jsn.has('focus') then
      iterateArray(jsn.vArr['focus'], result.focusList, parseReference{TFhirReference});
    if jsn.has('definition') or jsn.has('_definition') then
        result.definitionElement := parseCanonical(jsn.node['definition'], jsn.vObj['_definition']);{q}
end;

procedure TFHIRJsonComposer.ComposeMessageHeader(json : TJSONWriter; name : string; elem : TFhirMessageHeader; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (elem.event is TFhirCoding) then 
    ComposeCoding(json, 'eventCoding', TFhirCoding(elem.event)) 
  else if (elem.event is TFhirUri) then 
  begin
    ComposeUriValue(json, 'eventUri', TFhirUri(elem.event), false);
    ComposeUriProps(json, 'eventUri', TFhirUri(elem.event), false);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('destination') and (elem.destinationList.Count > 0) then
  begin
    json.valueArray('destination');
    for i := 0 to elem.destinationList.Count - 1 do
      ComposeMessageHeaderDestination(json, '', elem.destinationList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('sender') then
    ComposeReference{TFhirPractitioner}(json, 'sender', elem.sender); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('enterer') then
    ComposeReference{TFhirPractitioner}(json, 'enterer', elem.enterer); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('author') then
    ComposeReference{TFhirPractitioner}(json, 'author', elem.author); {a}
  ComposeMessageHeaderSource(json, 'source', elem.source); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('responsible') then
    ComposeReference{TFhirPractitioner}(json, 'responsible', elem.responsible); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reason') then
    ComposeCodeableConcept(json, 'reason', elem.reason); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('response') then
    ComposeMessageHeaderResponse(json, 'response', elem.response); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('focus') and (elem.focusList.Count > 0) then
  begin
    json.valueArray('focus');
    for i := 0 to elem.focusList.Count - 1 do
      ComposeReference{TFhirReference}(json, '', elem.focusList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('definition') then
    ComposeCanonicalValue(json, 'definition', elem.definitionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('definition') then
    ComposeCanonicalProps(json, 'definition', elem.definitionElement, false);
end;

{$ENDIF FHIR_MESSAGEHEADER}
{$IFDEF FHIR_MOLECULARSEQUENCE}
procedure TFHIRJsonParser.ParseMolecularSequenceReferenceSeq(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMolecularSequenceReferenceSeq(jsn)); {2}
end;

function TFHIRJsonParser.ParseMolecularSequenceReferenceSeq(jsn : TJsonObject) : TFhirMolecularSequenceReferenceSeq;
begin
  result := TFhirMolecularSequenceReferenceSeq.create;
  try
    ParseMolecularSequenceReferenceSeqProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMolecularSequenceReferenceSeqProperties(jsn : TJsonObject; result : TFhirMolecularSequenceReferenceSeq);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('chromosome') then
        result.chromosome := ParseCodeableConcept(jsn.vObj['chromosome']);{q3}
    if jsn.has('genomeBuild') or jsn.has('_genomeBuild') then
        result.genomeBuildElement := parseString(jsn.node['genomeBuild'], jsn.vObj['_genomeBuild']);{q}
    if jsn.has('orientation') or jsn.has('_orientation')  then
      result.orientationElement := parseEnum(jsn.path+'/orientation', jsn.node['orientation'], jsn.vObj['_orientation'], CODES_TFhirOrientationTypeEnum, SYSTEMS_TFhirOrientationTypeEnum);
    if jsn.has('referenceSeqId') then
        result.referenceSeqId := ParseCodeableConcept(jsn.vObj['referenceSeqId']);{q3}
    if jsn.has('referenceSeqPointer') then
        result.referenceSeqPointer := ParseReference{TFhirMolecularSequence}(jsn.vObj['referenceSeqPointer']);{q3}
    if jsn.has('referenceSeqString') or jsn.has('_referenceSeqString') then
        result.referenceSeqStringElement := parseString(jsn.node['referenceSeqString'], jsn.vObj['_referenceSeqString']);{q}
    if jsn.has('strand') or jsn.has('_strand')  then
      result.strandElement := parseEnum(jsn.path+'/strand', jsn.node['strand'], jsn.vObj['_strand'], CODES_TFhirStrandTypeEnum, SYSTEMS_TFhirStrandTypeEnum);
    if jsn.has('windowStart') or jsn.has('_windowStart') then
        result.windowStartElement := parseInteger(jsn.node['windowStart'], jsn.vObj['_windowStart']);{q}
    if jsn.has('windowEnd') or jsn.has('_windowEnd') then
        result.windowEndElement := parseInteger(jsn.node['windowEnd'], jsn.vObj['_windowEnd']);{q}
end;

procedure TFHIRJsonComposer.ComposeMolecularSequenceReferenceSeq(json : TJSONWriter; name : string; elem : TFhirMolecularSequenceReferenceSeq; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'chromosome', elem.chromosome); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'genomeBuild', elem.genomeBuildElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'genomeBuild', elem.genomeBuildElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnumValue(json, 'orientation', elem.OrientationElement, CODES_TFhirOrientationTypeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnumProps(json, 'orientation', elem.OrientationElement, CODES_TFhirOrientationTypeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'referenceSeqId', elem.referenceSeqId); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirMolecularSequence}(json, 'referenceSeqPointer', elem.referenceSeqPointer); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'referenceSeqString', elem.referenceSeqStringElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'referenceSeqString', elem.referenceSeqStringElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnumValue(json, 'strand', elem.StrandElement, CODES_TFhirStrandTypeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnumProps(json, 'strand', elem.StrandElement, CODES_TFhirStrandTypeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIntegerValue(json, 'windowStart', elem.windowStartElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIntegerProps(json, 'windowStart', elem.windowStartElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIntegerValue(json, 'windowEnd', elem.windowEndElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIntegerProps(json, 'windowEnd', elem.windowEndElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseMolecularSequenceVariant(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMolecularSequenceVariant(jsn)); {2}
end;

function TFHIRJsonParser.ParseMolecularSequenceVariant(jsn : TJsonObject) : TFhirMolecularSequenceVariant;
begin
  result := TFhirMolecularSequenceVariant.create;
  try
    ParseMolecularSequenceVariantProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMolecularSequenceVariantProperties(jsn : TJsonObject; result : TFhirMolecularSequenceVariant);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('start') or jsn.has('_start') then
        result.startElement := parseInteger(jsn.node['start'], jsn.vObj['_start']);{q}
    if jsn.has('end') or jsn.has('_end') then
        result.end_Element := parseInteger(jsn.node['end'], jsn.vObj['_end']);{q}
    if jsn.has('observedAllele') or jsn.has('_observedAllele') then
        result.observedAlleleElement := parseString(jsn.node['observedAllele'], jsn.vObj['_observedAllele']);{q}
    if jsn.has('referenceAllele') or jsn.has('_referenceAllele') then
        result.referenceAlleleElement := parseString(jsn.node['referenceAllele'], jsn.vObj['_referenceAllele']);{q}
    if jsn.has('cigar') or jsn.has('_cigar') then
        result.cigarElement := parseString(jsn.node['cigar'], jsn.vObj['_cigar']);{q}
    if jsn.has('variantPointer') then
        result.variantPointer := ParseReference{TFhirObservation}(jsn.vObj['variantPointer']);{q3}
end;

procedure TFHIRJsonComposer.ComposeMolecularSequenceVariant(json : TJSONWriter; name : string; elem : TFhirMolecularSequenceVariant; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIntegerValue(json, 'start', elem.startElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIntegerProps(json, 'start', elem.startElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIntegerValue(json, 'end', elem.end_Element, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIntegerProps(json, 'end', elem.end_Element, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'observedAllele', elem.observedAlleleElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'observedAllele', elem.observedAlleleElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'referenceAllele', elem.referenceAlleleElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'referenceAllele', elem.referenceAlleleElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'cigar', elem.cigarElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'cigar', elem.cigarElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirObservation}(json, 'variantPointer', elem.variantPointer); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseMolecularSequenceQuality(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMolecularSequenceQuality(jsn)); {2}
end;

function TFHIRJsonParser.ParseMolecularSequenceQuality(jsn : TJsonObject) : TFhirMolecularSequenceQuality;
begin
  result := TFhirMolecularSequenceQuality.create;
  try
    ParseMolecularSequenceQualityProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMolecularSequenceQualityProperties(jsn : TJsonObject; result : TFhirMolecularSequenceQuality);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn.node['type'], jsn.vObj['_type'], CODES_TFhirQualityTypeEnum, SYSTEMS_TFhirQualityTypeEnum);
    if jsn.has('standardSequence') then
        result.standardSequence := ParseCodeableConcept(jsn.vObj['standardSequence']);{q3}
    if jsn.has('start') or jsn.has('_start') then
        result.startElement := parseInteger(jsn.node['start'], jsn.vObj['_start']);{q}
    if jsn.has('end') or jsn.has('_end') then
        result.end_Element := parseInteger(jsn.node['end'], jsn.vObj['_end']);{q}
    if jsn.has('score') then
        result.score := ParseQuantity(jsn.vObj['score']);{q3}
    if jsn.has('method') then
        result.method := ParseCodeableConcept(jsn.vObj['method']);{q3}
    if jsn.has('truthTP') or jsn.has('_truthTP') then
        result.truthTPElement := parseDecimal(jsn.node['truthTP'], jsn.vObj['_truthTP']);{q}
    if jsn.has('queryTP') or jsn.has('_queryTP') then
        result.queryTPElement := parseDecimal(jsn.node['queryTP'], jsn.vObj['_queryTP']);{q}
    if jsn.has('truthFN') or jsn.has('_truthFN') then
        result.truthFNElement := parseDecimal(jsn.node['truthFN'], jsn.vObj['_truthFN']);{q}
    if jsn.has('queryFP') or jsn.has('_queryFP') then
        result.queryFPElement := parseDecimal(jsn.node['queryFP'], jsn.vObj['_queryFP']);{q}
    if jsn.has('gtFP') or jsn.has('_gtFP') then
        result.gtFPElement := parseDecimal(jsn.node['gtFP'], jsn.vObj['_gtFP']);{q}
    if jsn.has('precision') or jsn.has('_precision') then
        result.precisionElement := parseDecimal(jsn.node['precision'], jsn.vObj['_precision']);{q}
    if jsn.has('recall') or jsn.has('_recall') then
        result.recallElement := parseDecimal(jsn.node['recall'], jsn.vObj['_recall']);{q}
    if jsn.has('fScore') or jsn.has('_fScore') then
        result.fScore_Element := parseDecimal(jsn.node['fScore'], jsn.vObj['_fScore']);{q}
    if jsn.has('roc') then
        result.roc := ParseMolecularSequenceQualityRoc(jsn.vObj['roc']);{q3}
end;

procedure TFHIRJsonComposer.ComposeMolecularSequenceQuality(json : TJSONWriter; name : string; elem : TFhirMolecularSequenceQuality; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirQualityTypeEnum, false);
  ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirQualityTypeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'standardSequence', elem.standardSequence); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIntegerValue(json, 'start', elem.startElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIntegerProps(json, 'start', elem.startElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIntegerValue(json, 'end', elem.end_Element, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIntegerProps(json, 'end', elem.end_Element, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(json, 'score', elem.score); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'method', elem.method); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalValue(json, 'truthTP', elem.truthTPElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalProps(json, 'truthTP', elem.truthTPElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalValue(json, 'queryTP', elem.queryTPElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalProps(json, 'queryTP', elem.queryTPElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalValue(json, 'truthFN', elem.truthFNElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalProps(json, 'truthFN', elem.truthFNElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalValue(json, 'queryFP', elem.queryFPElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalProps(json, 'queryFP', elem.queryFPElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalValue(json, 'gtFP', elem.gtFPElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalProps(json, 'gtFP', elem.gtFPElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalValue(json, 'precision', elem.precisionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalProps(json, 'precision', elem.precisionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalValue(json, 'recall', elem.recallElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalProps(json, 'recall', elem.recallElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalValue(json, 'fScore', elem.fScore_Element, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalProps(json, 'fScore', elem.fScore_Element, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMolecularSequenceQualityRoc(json, 'roc', elem.roc); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseMolecularSequenceQualityRoc(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMolecularSequenceQualityRoc(jsn)); {2}
end;

function TFHIRJsonParser.ParseMolecularSequenceQualityRoc(jsn : TJsonObject) : TFhirMolecularSequenceQualityRoc;
begin
  result := TFhirMolecularSequenceQualityRoc.create;
  try
    ParseMolecularSequenceQualityRocProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMolecularSequenceQualityRocProperties(jsn : TJsonObject; result : TFhirMolecularSequenceQualityRoc);
begin
    ParseBackboneElementProperties(jsn, result);
      if jsn.has('score') or jsn.has('_score') then
      iteratePrimitiveArray(jsn.vArr['score'], jsn.vArr['_score'], result.scoreList, parseInteger);
      if jsn.has('numTP') or jsn.has('_numTP') then
      iteratePrimitiveArray(jsn.vArr['numTP'], jsn.vArr['_numTP'], result.numTPList, parseInteger);
      if jsn.has('numFP') or jsn.has('_numFP') then
      iteratePrimitiveArray(jsn.vArr['numFP'], jsn.vArr['_numFP'], result.numFPList, parseInteger);
      if jsn.has('numFN') or jsn.has('_numFN') then
      iteratePrimitiveArray(jsn.vArr['numFN'], jsn.vArr['_numFN'], result.numFNList, parseInteger);
      if jsn.has('precision') or jsn.has('_precision') then
      iteratePrimitiveArray(jsn.vArr['precision'], jsn.vArr['_precision'], result.precisionList, parseDecimal);
      if jsn.has('sensitivity') or jsn.has('_sensitivity') then
      iteratePrimitiveArray(jsn.vArr['sensitivity'], jsn.vArr['_sensitivity'], result.sensitivityList, parseDecimal);
      if jsn.has('fMeasure') or jsn.has('_fMeasure') then
      iteratePrimitiveArray(jsn.vArr['fMeasure'], jsn.vArr['_fMeasure'], result.fMeasureList, parseDecimal);
end;

procedure TFHIRJsonComposer.ComposeMolecularSequenceQualityRoc(json : TJSONWriter; name : string; elem : TFhirMolecularSequenceQualityRoc; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.scoreList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.scoreList.Count - 1 do
    begin
      ext := ext or ((elem.scoreList[i].id <> '') or (elem.scoreList[i].hasExtensionList) {no-comments or (elem.scoreList[i].hasComments)});
      val := val or (elem.scoreList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('score');
      for i := 0 to elem.scoreList.Count - 1 do
        ComposeIntegerValue(json, '',elem.scoreList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_score');
      for i := 0 to elem.scoreList.Count - 1 do
        ComposeIntegerProps(json, '',elem.scoreList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.numTPList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.numTPList.Count - 1 do
    begin
      ext := ext or ((elem.numTPList[i].id <> '') or (elem.numTPList[i].hasExtensionList) {no-comments or (elem.numTPList[i].hasComments)});
      val := val or (elem.numTPList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('numTP');
      for i := 0 to elem.numTPList.Count - 1 do
        ComposeIntegerValue(json, '',elem.numTPList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_numTP');
      for i := 0 to elem.numTPList.Count - 1 do
        ComposeIntegerProps(json, '',elem.numTPList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.numFPList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.numFPList.Count - 1 do
    begin
      ext := ext or ((elem.numFPList[i].id <> '') or (elem.numFPList[i].hasExtensionList) {no-comments or (elem.numFPList[i].hasComments)});
      val := val or (elem.numFPList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('numFP');
      for i := 0 to elem.numFPList.Count - 1 do
        ComposeIntegerValue(json, '',elem.numFPList[i], true);
      json.FinishArray;
    end;
    if ext then
  begin
      json.valueArray('_numFP');
      for i := 0 to elem.numFPList.Count - 1 do
        ComposeIntegerProps(json, '',elem.numFPList[i], true);
    json.FinishArray;
  end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.numFNList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.numFNList.Count - 1 do
    begin
      ext := ext or ((elem.numFNList[i].id <> '') or (elem.numFNList[i].hasExtensionList) {no-comments or (elem.numFNList[i].hasComments)});
      val := val or (elem.numFNList[i].hasPrimitiveValue);
    end;
    if val then
  begin
      json.valueArray('numFN');
      for i := 0 to elem.numFNList.Count - 1 do
        ComposeIntegerValue(json, '',elem.numFNList[i], true);
    json.FinishArray;
  end;
    if ext then
  begin
      json.valueArray('_numFN');
      for i := 0 to elem.numFNList.Count - 1 do
        ComposeIntegerProps(json, '',elem.numFNList[i], true);
    json.FinishArray;
  end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.precisionList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.precisionList.Count - 1 do
    begin
      ext := ext or ((elem.precisionList[i].id <> '') or (elem.precisionList[i].hasExtensionList) {no-comments or (elem.precisionList[i].hasComments)});
      val := val or (elem.precisionList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('precision');
      for i := 0 to elem.precisionList.Count - 1 do
        ComposeDecimalValue(json, '',elem.precisionList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_precision');
      for i := 0 to elem.precisionList.Count - 1 do
        ComposeDecimalProps(json, '',elem.precisionList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.sensitivityList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.sensitivityList.Count - 1 do
  begin
      ext := ext or ((elem.sensitivityList[i].id <> '') or (elem.sensitivityList[i].hasExtensionList) {no-comments or (elem.sensitivityList[i].hasComments)});
      val := val or (elem.sensitivityList[i].hasPrimitiveValue);
  end;
    if val then
  begin
      json.valueArray('sensitivity');
      for i := 0 to elem.sensitivityList.Count - 1 do
        ComposeDecimalValue(json, '',elem.sensitivityList[i], true);
    json.FinishArray;
  end;
    if ext then
  begin
      json.valueArray('_sensitivity');
      for i := 0 to elem.sensitivityList.Count - 1 do
        ComposeDecimalProps(json, '',elem.sensitivityList[i], true);
    json.FinishArray;
  end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.fMeasureList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.fMeasureList.Count - 1 do
    begin
      ext := ext or ((elem.fMeasureList[i].id <> '') or (elem.fMeasureList[i].hasExtensionList) {no-comments or (elem.fMeasureList[i].hasComments)});
      val := val or (elem.fMeasureList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('fMeasure');
      for i := 0 to elem.fMeasureList.Count - 1 do
        ComposeDecimalValue(json, '',elem.fMeasureList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_fMeasure');
      for i := 0 to elem.fMeasureList.Count - 1 do
        ComposeDecimalProps(json, '',elem.fMeasureList[i], true);
      json.FinishArray;
    end;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseMolecularSequenceRepository(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMolecularSequenceRepository(jsn)); {2}
end;

function TFHIRJsonParser.ParseMolecularSequenceRepository(jsn : TJsonObject) : TFhirMolecularSequenceRepository;
begin
  result := TFhirMolecularSequenceRepository.create;
  try
    ParseMolecularSequenceRepositoryProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMolecularSequenceRepositoryProperties(jsn : TJsonObject; result : TFhirMolecularSequenceRepository);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn.node['type'], jsn.vObj['_type'], CODES_TFhirRepositoryTypeEnum, SYSTEMS_TFhirRepositoryTypeEnum);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := parseUri(jsn.node['url'], jsn.vObj['_url']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('datasetId') or jsn.has('_datasetId') then
        result.datasetIdElement := parseString(jsn.node['datasetId'], jsn.vObj['_datasetId']);{q}
    if jsn.has('variantsetId') or jsn.has('_variantsetId') then
        result.variantsetIdElement := parseString(jsn.node['variantsetId'], jsn.vObj['_variantsetId']);{q}
    if jsn.has('readsetId') or jsn.has('_readsetId') then
        result.readsetIdElement := parseString(jsn.node['readsetId'], jsn.vObj['_readsetId']);{q}
end;

procedure TFHIRJsonComposer.ComposeMolecularSequenceRepository(json : TJSONWriter; name : string; elem : TFhirMolecularSequenceRepository; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirRepositoryTypeEnum, false);
  ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirRepositoryTypeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUriValue(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUriProps(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'datasetId', elem.datasetIdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'datasetId', elem.datasetIdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'variantsetId', elem.variantsetIdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'variantsetId', elem.variantsetIdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'readsetId', elem.readsetIdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'readsetId', elem.readsetIdElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseMolecularSequenceStructureVariant(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMolecularSequenceStructureVariant(jsn)); {2}
end;

function TFHIRJsonParser.ParseMolecularSequenceStructureVariant(jsn : TJsonObject) : TFhirMolecularSequenceStructureVariant;
begin
  result := TFhirMolecularSequenceStructureVariant.create;
  try
    ParseMolecularSequenceStructureVariantProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMolecularSequenceStructureVariantProperties(jsn : TJsonObject; result : TFhirMolecularSequenceStructureVariant);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('variantType') then
        result.variantType := ParseCodeableConcept(jsn.vObj['variantType']);{q3}
    if jsn.has('exact') or jsn.has('_exact') then
        result.exactElement := parseBoolean(jsn.node['exact'], jsn.vObj['_exact']);{q}
    if jsn.has('length') or jsn.has('_length') then
        result.lengthElement := parseInteger(jsn.node['length'], jsn.vObj['_length']);{q}
    if jsn.has('outer') then
        result.outer := ParseMolecularSequenceStructureVariantOuter(jsn.vObj['outer']);{q3}
    if jsn.has('inner') then
        result.inner := ParseMolecularSequenceStructureVariantInner(jsn.vObj['inner']);{q3}
end;

procedure TFHIRJsonComposer.ComposeMolecularSequenceStructureVariant(json : TJSONWriter; name : string; elem : TFhirMolecularSequenceStructureVariant; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'variantType', elem.variantType); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBooleanValue(json, 'exact', elem.exactElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBooleanProps(json, 'exact', elem.exactElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIntegerValue(json, 'length', elem.lengthElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIntegerProps(json, 'length', elem.lengthElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMolecularSequenceStructureVariantOuter(json, 'outer', elem.outer); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeMolecularSequenceStructureVariantInner(json, 'inner', elem.inner); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseMolecularSequenceStructureVariantOuter(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMolecularSequenceStructureVariantOuter(jsn)); {2}
end;

function TFHIRJsonParser.ParseMolecularSequenceStructureVariantOuter(jsn : TJsonObject) : TFhirMolecularSequenceStructureVariantOuter;
begin
  result := TFhirMolecularSequenceStructureVariantOuter.create;
  try
    ParseMolecularSequenceStructureVariantOuterProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMolecularSequenceStructureVariantOuterProperties(jsn : TJsonObject; result : TFhirMolecularSequenceStructureVariantOuter);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('start') or jsn.has('_start') then
        result.startElement := parseInteger(jsn.node['start'], jsn.vObj['_start']);{q}
    if jsn.has('end') or jsn.has('_end') then
        result.end_Element := parseInteger(jsn.node['end'], jsn.vObj['_end']);{q}
end;

procedure TFHIRJsonComposer.ComposeMolecularSequenceStructureVariantOuter(json : TJSONWriter; name : string; elem : TFhirMolecularSequenceStructureVariantOuter; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIntegerValue(json, 'start', elem.startElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIntegerProps(json, 'start', elem.startElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIntegerValue(json, 'end', elem.end_Element, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIntegerProps(json, 'end', elem.end_Element, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseMolecularSequenceStructureVariantInner(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMolecularSequenceStructureVariantInner(jsn)); {2}
end;

function TFHIRJsonParser.ParseMolecularSequenceStructureVariantInner(jsn : TJsonObject) : TFhirMolecularSequenceStructureVariantInner;
begin
  result := TFhirMolecularSequenceStructureVariantInner.create;
  try
    ParseMolecularSequenceStructureVariantInnerProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMolecularSequenceStructureVariantInnerProperties(jsn : TJsonObject; result : TFhirMolecularSequenceStructureVariantInner);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('start') or jsn.has('_start') then
        result.startElement := parseInteger(jsn.node['start'], jsn.vObj['_start']);{q}
    if jsn.has('end') or jsn.has('_end') then
        result.end_Element := parseInteger(jsn.node['end'], jsn.vObj['_end']);{q}
end;

procedure TFHIRJsonComposer.ComposeMolecularSequenceStructureVariantInner(json : TJSONWriter; name : string; elem : TFhirMolecularSequenceStructureVariantInner; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIntegerValue(json, 'start', elem.startElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIntegerProps(json, 'start', elem.startElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIntegerValue(json, 'end', elem.end_Element, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIntegerProps(json, 'end', elem.end_Element, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseMolecularSequence(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMolecularSequence(jsn)); {2}
end;

function TFHIRJsonParser.ParseMolecularSequence(jsn : TJsonObject) : TFhirMolecularSequence;
begin
  result := TFhirMolecularSequence.create;
  try
    ParseMolecularSequenceProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMolecularSequenceProperties(jsn : TJsonObject; result : TFhirMolecularSequence);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn.node['type'], jsn.vObj['_type'], CODES_TFhirSequenceTypeEnum, SYSTEMS_TFhirSequenceTypeEnum);
    if jsn.has('coordinateSystem') or jsn.has('_coordinateSystem') then
        result.coordinateSystemElement := parseInteger(jsn.node['coordinateSystem'], jsn.vObj['_coordinateSystem']);{q}
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q3}
    if jsn.has('specimen') then
        result.specimen := ParseReference{TFhirSpecimen}(jsn.vObj['specimen']);{q3}
    if jsn.has('device') then
        result.device := ParseReference{TFhirDevice}(jsn.vObj['device']);{q3}
    if jsn.has('performer') then
        result.performer := ParseReference{TFhirOrganization}(jsn.vObj['performer']);{q3}
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q3}
    if jsn.has('referenceSeq') then
        result.referenceSeq := ParseMolecularSequenceReferenceSeq(jsn.vObj['referenceSeq']);{q3}
    if jsn.has('variant') then
      iterateArray(jsn.vArr['variant'], result.variantList, parseMolecularSequenceVariant);
    if jsn.has('observedSeq') or jsn.has('_observedSeq') then
        result.observedSeqElement := parseString(jsn.node['observedSeq'], jsn.vObj['_observedSeq']);{q}
    if jsn.has('quality') then
      iterateArray(jsn.vArr['quality'], result.qualityList, parseMolecularSequenceQuality);
    if jsn.has('readCoverage') or jsn.has('_readCoverage') then
        result.readCoverageElement := parseInteger(jsn.node['readCoverage'], jsn.vObj['_readCoverage']);{q}
    if jsn.has('repository') then
      iterateArray(jsn.vArr['repository'], result.repositoryList, parseMolecularSequenceRepository);
    if jsn.has('pointer') then
      iterateArray(jsn.vArr['pointer'], result.pointerList, parseReference{TFhirMolecularSequence});
    if jsn.has('structureVariant') then
      iterateArray(jsn.vArr['structureVariant'], result.structureVariantList, parseMolecularSequenceStructureVariant);
end;

procedure TFHIRJsonComposer.ComposeMolecularSequence(json : TJSONWriter; name : string; elem : TFhirMolecularSequence; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirSequenceTypeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirSequenceTypeEnum, false);
  ComposeIntegerValue(json, 'coordinateSystem', elem.coordinateSystemElement, false);
  ComposeIntegerProps(json, 'coordinateSystem', elem.coordinateSystemElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('patient') then
    ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('specimen') then
    ComposeReference{TFhirSpecimen}(json, 'specimen', elem.specimen); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('device') then
    ComposeReference{TFhirDevice}(json, 'device', elem.device); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('performer') then
    ComposeReference{TFhirOrganization}(json, 'performer', elem.performer); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('quantity') then
    ComposeQuantity(json, 'quantity', elem.quantity); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('referenceSeq') then
    ComposeMolecularSequenceReferenceSeq(json, 'referenceSeq', elem.referenceSeq); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('variant') and (elem.variantList.Count > 0) then
  begin
    json.valueArray('variant');
    for i := 0 to elem.variantList.Count - 1 do
      ComposeMolecularSequenceVariant(json, '', elem.variantList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('observedSeq') then
    ComposeStringValue(json, 'observedSeq', elem.observedSeqElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('observedSeq') then
    ComposeStringProps(json, 'observedSeq', elem.observedSeqElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('quality') and (elem.qualityList.Count > 0) then
  begin
    json.valueArray('quality');
    for i := 0 to elem.qualityList.Count - 1 do
      ComposeMolecularSequenceQuality(json, '', elem.qualityList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('readCoverage') then
    ComposeIntegerValue(json, 'readCoverage', elem.readCoverageElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('readCoverage') then
    ComposeIntegerProps(json, 'readCoverage', elem.readCoverageElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('repository') and (elem.repositoryList.Count > 0) then
  begin
    json.valueArray('repository');
    for i := 0 to elem.repositoryList.Count - 1 do
      ComposeMolecularSequenceRepository(json, '', elem.repositoryList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('pointer') and (elem.pointerList.Count > 0) then
  begin
    json.valueArray('pointer');
    for i := 0 to elem.pointerList.Count - 1 do
      ComposeReference{TFhirMolecularSequence}(json, '', elem.pointerList[i]); {z - Reference(MolecularSequence)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('structureVariant') and (elem.structureVariantList.Count > 0) then
  begin
    json.valueArray('structureVariant');
    for i := 0 to elem.structureVariantList.Count - 1 do
      ComposeMolecularSequenceStructureVariant(json, '', elem.structureVariantList[i]); {z - }
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_MOLECULARSEQUENCE}
{$IFDEF FHIR_NAMINGSYSTEM}
procedure TFHIRJsonParser.ParseNamingSystemUniqueId(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseNamingSystemUniqueId(jsn)); {2}
end;

function TFHIRJsonParser.ParseNamingSystemUniqueId(jsn : TJsonObject) : TFhirNamingSystemUniqueId;
begin
  result := TFhirNamingSystemUniqueId.create;
  try
    ParseNamingSystemUniqueIdProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseNamingSystemUniqueIdProperties(jsn : TJsonObject; result : TFhirNamingSystemUniqueId);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn.node['type'], jsn.vObj['_type'], CODES_TFhirNamingsystemIdentifierTypeEnum, SYSTEMS_TFhirNamingsystemIdentifierTypeEnum);
    if jsn.has('value') or jsn.has('_value') then
        result.valueElement := parseString(jsn.node['value'], jsn.vObj['_value']);{q}
    if jsn.has('preferred') or jsn.has('_preferred') then
        result.preferredElement := parseBoolean(jsn.node['preferred'], jsn.vObj['_preferred']);{q}
    if jsn.has('comment') or jsn.has('_comment') then
        result.commentElement := parseString(jsn.node['comment'], jsn.vObj['_comment']);{q}
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q3}
end;

procedure TFHIRJsonComposer.ComposeNamingSystemUniqueId(json : TJSONWriter; name : string; elem : TFhirNamingSystemUniqueId; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirNamingsystemIdentifierTypeEnum, false);
  ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirNamingsystemIdentifierTypeEnum, false);
  ComposeStringValue(json, 'value', elem.valueElement, false);
  ComposeStringProps(json, 'value', elem.valueElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'preferred', elem.preferredElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'preferred', elem.preferredElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'comment', elem.commentElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'comment', elem.commentElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(json, 'period', elem.period); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseNamingSystem(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseNamingSystem(jsn)); {2}
end;

function TFHIRJsonParser.ParseNamingSystem(jsn : TJsonObject) : TFhirNamingSystem;
begin
  result := TFhirNamingSystem.create;
  try
    ParseNamingSystemProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseNamingSystemProperties(jsn : TJsonObject; result : TFhirNamingSystem);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    if jsn.has('kind') or jsn.has('_kind')  then
      result.kindElement := parseEnum(jsn.path+'/kind', jsn.node['kind'], jsn.vObj['_kind'], CODES_TFhirNamingsystemTypeEnum, SYSTEMS_TFhirNamingsystemTypeEnum);
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := parseDateTime(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('publisher') or jsn.has('_publisher') then
        result.publisherElement := parseString(jsn.node['publisher'], jsn.vObj['_publisher']);{q}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseContactDetail);
    if jsn.has('responsible') or jsn.has('_responsible') then
        result.responsibleElement := parseString(jsn.node['responsible'], jsn.vObj['_responsible']);{q}
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseMarkdown(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('useContext') then
      iterateArray(jsn.vArr['useContext'], result.useContextList, parseUsageContext);
    if jsn.has('jurisdiction') then
      iterateArray(jsn.vArr['jurisdiction'], result.jurisdictionList, parseCodeableConcept);
    if jsn.has('usage') or jsn.has('_usage') then
        result.usageElement := parseString(jsn.node['usage'], jsn.vObj['_usage']);{q}
    if jsn.has('uniqueId') then
      iterateArray(jsn.vArr['uniqueId'], result.uniqueIdList, parseNamingSystemUniqueId);
end;

procedure TFHIRJsonComposer.ComposeNamingSystem(json : TJSONWriter; name : string; elem : TFhirNamingSystem; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  ComposeStringValue(json, 'name', elem.nameElement, false);
  ComposeStringProps(json, 'name', elem.nameElement, false);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, false);
  ComposeEnumValue(json, 'kind', elem.KindElement, CODES_TFhirNamingsystemTypeEnum, false);
  ComposeEnumProps(json, 'kind', elem.KindElement, CODES_TFhirNamingsystemTypeEnum, false);
  ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringValue(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringProps(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') and (elem.contactList.Count > 0) then
  begin
    json.valueArray('contact');
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(json, '', elem.contactList[i]); {z - ContactDetail}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('responsible') then
    ComposeStringValue(json, 'responsible', elem.responsibleElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('responsible') then
    ComposeStringProps(json, 'responsible', elem.responsibleElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('type_') then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdownValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdownProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') and (elem.useContextList.Count > 0) then
  begin
    json.valueArray('useContext');
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(json, '', elem.useContextList[i]); {z - UsageContext}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') and (elem.jurisdictionList.Count > 0) then
  begin
    json.valueArray('jurisdiction');
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.jurisdictionList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('usage') then
    ComposeStringValue(json, 'usage', elem.usageElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('usage') then
    ComposeStringProps(json, 'usage', elem.usageElement, false);
  if (elem.uniqueIdList.Count > 0) then
  begin
    json.valueArray('uniqueId');
    for i := 0 to elem.uniqueIdList.Count - 1 do
      ComposeNamingSystemUniqueId(json, '', elem.uniqueIdList[i]); {z - }
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_NAMINGSYSTEM}
{$IFDEF FHIR_NUTRITIONORDER}
procedure TFHIRJsonParser.ParseNutritionOrderOralDiet(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseNutritionOrderOralDiet(jsn)); {2}
end;

function TFHIRJsonParser.ParseNutritionOrderOralDiet(jsn : TJsonObject) : TFhirNutritionOrderOralDiet;
begin
  result := TFhirNutritionOrderOralDiet.create;
  try
    ParseNutritionOrderOralDietProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseNutritionOrderOralDietProperties(jsn : TJsonObject; result : TFhirNutritionOrderOralDiet);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
      iterateArray(jsn.vArr['type'], result.type_List, parseCodeableConcept);
    if jsn.has('schedule') then
      iterateArray(jsn.vArr['schedule'], result.scheduleList, parseTiming);
    if jsn.has('nutrient') then
      iterateArray(jsn.vArr['nutrient'], result.nutrientList, parseNutritionOrderOralDietNutrient);
    if jsn.has('texture') then
      iterateArray(jsn.vArr['texture'], result.textureList, parseNutritionOrderOralDietTexture);
    if jsn.has('fluidConsistencyType') then
      iterateArray(jsn.vArr['fluidConsistencyType'], result.fluidConsistencyTypeList, parseCodeableConcept);
    if jsn.has('instruction') or jsn.has('_instruction') then
        result.instructionElement := parseString(jsn.node['instruction'], jsn.vObj['_instruction']);{q}
end;

procedure TFHIRJsonComposer.ComposeNutritionOrderOralDiet(json : TJSONWriter; name : string; elem : TFhirNutritionOrderOralDiet; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.type_List.Count > 0) then
  begin
    json.valueArray('type');
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(json, '', elem.type_List[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.scheduleList.Count > 0) then
  begin
    json.valueArray('schedule');
    for i := 0 to elem.scheduleList.Count - 1 do
      ComposeTiming(json, '', elem.scheduleList[i]); {z - Timing}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.nutrientList.Count > 0) then
  begin
    json.valueArray('nutrient');
    for i := 0 to elem.nutrientList.Count - 1 do
      ComposeNutritionOrderOralDietNutrient(json, '', elem.nutrientList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.textureList.Count > 0) then
  begin
    json.valueArray('texture');
    for i := 0 to elem.textureList.Count - 1 do
      ComposeNutritionOrderOralDietTexture(json, '', elem.textureList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.fluidConsistencyTypeList.Count > 0) then
  begin
    json.valueArray('fluidConsistencyType');
    for i := 0 to elem.fluidConsistencyTypeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.fluidConsistencyTypeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'instruction', elem.instructionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'instruction', elem.instructionElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseNutritionOrderOralDietNutrient(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseNutritionOrderOralDietNutrient(jsn)); {2}
end;

function TFHIRJsonParser.ParseNutritionOrderOralDietNutrient(jsn : TJsonObject) : TFhirNutritionOrderOralDietNutrient;
begin
  result := TFhirNutritionOrderOralDietNutrient.create;
  try
    ParseNutritionOrderOralDietNutrientProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseNutritionOrderOralDietNutrientProperties(jsn : TJsonObject; result : TFhirNutritionOrderOralDietNutrient);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('modifier') then
        result.modifier := ParseCodeableConcept(jsn.vObj['modifier']);{q3}
    if jsn.has('amount') then
        result.amount := ParseQuantity(jsn.vObj['amount']);{q3}
end;

procedure TFHIRJsonComposer.ComposeNutritionOrderOralDietNutrient(json : TJSONWriter; name : string; elem : TFhirNutritionOrderOralDietNutrient; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'modifier', elem.modifier); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'amount', elem.amount); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseNutritionOrderOralDietTexture(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseNutritionOrderOralDietTexture(jsn)); {2}
end;

function TFHIRJsonParser.ParseNutritionOrderOralDietTexture(jsn : TJsonObject) : TFhirNutritionOrderOralDietTexture;
begin
  result := TFhirNutritionOrderOralDietTexture.create;
  try
    ParseNutritionOrderOralDietTextureProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseNutritionOrderOralDietTextureProperties(jsn : TJsonObject; result : TFhirNutritionOrderOralDietTexture);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('modifier') then
        result.modifier := ParseCodeableConcept(jsn.vObj['modifier']);{q3}
    if jsn.has('foodType') then
        result.foodType := ParseCodeableConcept(jsn.vObj['foodType']);{q3}
end;

procedure TFHIRJsonComposer.ComposeNutritionOrderOralDietTexture(json : TJSONWriter; name : string; elem : TFhirNutritionOrderOralDietTexture; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'modifier', elem.modifier); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'foodType', elem.foodType); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseNutritionOrderSupplement(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseNutritionOrderSupplement(jsn)); {2}
end;

function TFHIRJsonParser.ParseNutritionOrderSupplement(jsn : TJsonObject) : TFhirNutritionOrderSupplement;
begin
  result := TFhirNutritionOrderSupplement.create;
  try
    ParseNutritionOrderSupplementProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseNutritionOrderSupplementProperties(jsn : TJsonObject; result : TFhirNutritionOrderSupplement);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('productName') or jsn.has('_productName') then
        result.productNameElement := parseString(jsn.node['productName'], jsn.vObj['_productName']);{q}
    if jsn.has('schedule') then
      iterateArray(jsn.vArr['schedule'], result.scheduleList, parseTiming);
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q3}
    if jsn.has('instruction') or jsn.has('_instruction') then
        result.instructionElement := parseString(jsn.node['instruction'], jsn.vObj['_instruction']);{q}
end;

procedure TFHIRJsonComposer.ComposeNutritionOrderSupplement(json : TJSONWriter; name : string; elem : TFhirNutritionOrderSupplement; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'productName', elem.productNameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'productName', elem.productNameElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.scheduleList.Count > 0) then
  begin
    json.valueArray('schedule');
    for i := 0 to elem.scheduleList.Count - 1 do
      ComposeTiming(json, '', elem.scheduleList[i]); {z - Timing}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'quantity', elem.quantity); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'instruction', elem.instructionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'instruction', elem.instructionElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseNutritionOrderEnteralFormula(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseNutritionOrderEnteralFormula(jsn)); {2}
end;

function TFHIRJsonParser.ParseNutritionOrderEnteralFormula(jsn : TJsonObject) : TFhirNutritionOrderEnteralFormula;
begin
  result := TFhirNutritionOrderEnteralFormula.create;
  try
    ParseNutritionOrderEnteralFormulaProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseNutritionOrderEnteralFormulaProperties(jsn : TJsonObject; result : TFhirNutritionOrderEnteralFormula);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('baseFormulaType') then
        result.baseFormulaType := ParseCodeableConcept(jsn.vObj['baseFormulaType']);{q3}
    if jsn.has('baseFormulaProductName') or jsn.has('_baseFormulaProductName') then
        result.baseFormulaProductNameElement := parseString(jsn.node['baseFormulaProductName'], jsn.vObj['_baseFormulaProductName']);{q}
    if jsn.has('additiveType') then
        result.additiveType := ParseCodeableConcept(jsn.vObj['additiveType']);{q3}
    if jsn.has('additiveProductName') or jsn.has('_additiveProductName') then
        result.additiveProductNameElement := parseString(jsn.node['additiveProductName'], jsn.vObj['_additiveProductName']);{q}
    if jsn.has('caloricDensity') then
        result.caloricDensity := ParseQuantity(jsn.vObj['caloricDensity']);{q3}
    if jsn.has('routeofAdministration') then
        result.routeofAdministration := ParseCodeableConcept(jsn.vObj['routeofAdministration']);{q3}
    if jsn.has('administration') then
      iterateArray(jsn.vArr['administration'], result.administrationList, parseNutritionOrderEnteralFormulaAdministration);
    if jsn.has('maxVolumeToDeliver') then
        result.maxVolumeToDeliver := ParseQuantity(jsn.vObj['maxVolumeToDeliver']);{q3}
    if jsn.has('administrationInstruction') or jsn.has('_administrationInstruction') then
        result.administrationInstructionElement := parseString(jsn.node['administrationInstruction'], jsn.vObj['_administrationInstruction']);{q}
end;

procedure TFHIRJsonComposer.ComposeNutritionOrderEnteralFormula(json : TJSONWriter; name : string; elem : TFhirNutritionOrderEnteralFormula; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'baseFormulaType', elem.baseFormulaType); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'baseFormulaProductName', elem.baseFormulaProductNameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'baseFormulaProductName', elem.baseFormulaProductNameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'additiveType', elem.additiveType); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'additiveProductName', elem.additiveProductNameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'additiveProductName', elem.additiveProductNameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'caloricDensity', elem.caloricDensity); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'routeofAdministration', elem.routeofAdministration); {a}
  if (SummaryOption in [soFull, soData]) and (elem.administrationList.Count > 0) then
  begin
    json.valueArray('administration');
    for i := 0 to elem.administrationList.Count - 1 do
      ComposeNutritionOrderEnteralFormulaAdministration(json, '', elem.administrationList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'maxVolumeToDeliver', elem.maxVolumeToDeliver); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'administrationInstruction', elem.administrationInstructionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'administrationInstruction', elem.administrationInstructionElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseNutritionOrderEnteralFormulaAdministration(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseNutritionOrderEnteralFormulaAdministration(jsn)); {2}
end;

function TFHIRJsonParser.ParseNutritionOrderEnteralFormulaAdministration(jsn : TJsonObject) : TFhirNutritionOrderEnteralFormulaAdministration;
begin
  result := TFhirNutritionOrderEnteralFormulaAdministration.create;
  try
    ParseNutritionOrderEnteralFormulaAdministrationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseNutritionOrderEnteralFormulaAdministrationProperties(jsn : TJsonObject; result : TFhirNutritionOrderEnteralFormulaAdministration);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('schedule') then
        result.schedule := ParseTiming(jsn.vObj['schedule']);{q3}
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q3}
    if jsn.has('rateQuantity') {a4} then
      result.rate := ParseQuantity(jsn.vObj['rateQuantity']);
    if jsn.has('rateRatio') {a4} then
      result.rate := ParseRatio(jsn.vObj['rateRatio']);
end;

procedure TFHIRJsonComposer.ComposeNutritionOrderEnteralFormulaAdministration(json : TJSONWriter; name : string; elem : TFhirNutritionOrderEnteralFormulaAdministration; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeTiming(json, 'schedule', elem.schedule); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'quantity', elem.quantity); {a}
  if (SummaryOption in [soFull, soData]) and (elem.rate is TFhirQuantity) then 
    ComposeQuantity(json, 'rateQuantity', TFhirQuantity(elem.rate)) 
  else if (SummaryOption in [soFull, soData]) and (elem.rate is TFhirRatio) then 
    ComposeRatio(json, 'rateRatio', TFhirRatio(elem.rate)) ;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseNutritionOrder(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseNutritionOrder(jsn)); {2}
end;

function TFHIRJsonParser.ParseNutritionOrder(jsn : TJsonObject) : TFhirNutritionOrder;
begin
  result := TFhirNutritionOrder.create;
  try
    ParseNutritionOrderProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseNutritionOrderProperties(jsn : TJsonObject; result : TFhirNutritionOrder);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
      if jsn.has('instantiatesCanonical') or jsn.has('_instantiatesCanonical') then
      iteratePrimitiveArray(jsn.vArr['instantiatesCanonical'], jsn.vArr['_instantiatesCanonical'], result.instantiatesCanonicalList, parseCanonical);
      if jsn.has('instantiatesUri') or jsn.has('_instantiatesUri') then
      iteratePrimitiveArray(jsn.vArr['instantiatesUri'], jsn.vArr['_instantiatesUri'], result.instantiatesUriList, parseUri);
      if jsn.has('instantiates') or jsn.has('_instantiates') then
      iteratePrimitiveArray(jsn.vArr['instantiates'], jsn.vArr['_instantiates'], result.instantiatesList, parseUri);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirRequestStatusEnum, SYSTEMS_TFhirRequestStatusEnum);
    if jsn.has('intent') or jsn.has('_intent')  then
      result.intentElement := parseEnum(jsn.path+'/intent', jsn.node['intent'], jsn.vObj['_intent'], CODES_TFhirRequestIntentEnum, SYSTEMS_TFhirRequestIntentEnum);
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q3}
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q3}
    if jsn.has('dateTime') or jsn.has('_dateTime') then
        result.dateTimeElement := parseDateTime(jsn.node['dateTime'], jsn.vObj['_dateTime']);{q}
    if jsn.has('orderer') then
        result.orderer := ParseReference{TFhirPractitioner}(jsn.vObj['orderer']);{q3}
    if jsn.has('allergyIntolerance') then
      iterateArray(jsn.vArr['allergyIntolerance'], result.allergyIntoleranceList, parseReference{TFhirAllergyIntolerance});
    if jsn.has('foodPreferenceModifier') then
      iterateArray(jsn.vArr['foodPreferenceModifier'], result.foodPreferenceModifierList, parseCodeableConcept);
    if jsn.has('excludeFoodModifier') then
      iterateArray(jsn.vArr['excludeFoodModifier'], result.excludeFoodModifierList, parseCodeableConcept);
    if jsn.has('oralDiet') then
        result.oralDiet := ParseNutritionOrderOralDiet(jsn.vObj['oralDiet']);{q3}
    if jsn.has('supplement') then
      iterateArray(jsn.vArr['supplement'], result.supplementList, parseNutritionOrderSupplement);
    if jsn.has('enteralFormula') then
        result.enteralFormula := ParseNutritionOrderEnteralFormula(jsn.vObj['enteralFormula']);{q3}
    if jsn.has('note') then
      iterateArray(jsn.vArr['note'], result.noteList, parseAnnotation);
end;

procedure TFHIRJsonComposer.ComposeNutritionOrder(json : TJSONWriter; name : string; elem : TFhirNutritionOrder; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('instantiatesCanonical') and (elem.instantiatesCanonicalList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.instantiatesCanonicalList.Count - 1 do
    begin
      ext := ext or ((elem.instantiatesCanonicalList[i].id <> '') or (elem.instantiatesCanonicalList[i].hasExtensionList) {no-comments or (elem.instantiatesCanonicalList[i].hasComments)});
      val := val or (elem.instantiatesCanonicalList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('instantiatesCanonical');
      for i := 0 to elem.instantiatesCanonicalList.Count - 1 do
        ComposeCanonicalValue(json, '',elem.instantiatesCanonicalList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_instantiatesCanonical');
      for i := 0 to elem.instantiatesCanonicalList.Count - 1 do
        ComposeCanonicalProps(json, '',elem.instantiatesCanonicalList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('instantiatesUri') and (elem.instantiatesUriList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.instantiatesUriList.Count - 1 do
    begin
      ext := ext or ((elem.instantiatesUriList[i].id <> '') or (elem.instantiatesUriList[i].hasExtensionList) {no-comments or (elem.instantiatesUriList[i].hasComments)});
      val := val or (elem.instantiatesUriList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('instantiatesUri');
      for i := 0 to elem.instantiatesUriList.Count - 1 do
        ComposeUriValue(json, '',elem.instantiatesUriList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_instantiatesUri');
      for i := 0 to elem.instantiatesUriList.Count - 1 do
        ComposeUriProps(json, '',elem.instantiatesUriList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('instantiates') and (elem.instantiatesList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.instantiatesList.Count - 1 do
    begin
      ext := ext or ((elem.instantiatesList[i].id <> '') or (elem.instantiatesList[i].hasExtensionList) {no-comments or (elem.instantiatesList[i].hasComments)});
      val := val or (elem.instantiatesList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('instantiates');
      for i := 0 to elem.instantiatesList.Count - 1 do
        ComposeUriValue(json, '',elem.instantiatesList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_instantiates');
      for i := 0 to elem.instantiatesList.Count - 1 do
        ComposeUriProps(json, '',elem.instantiatesList[i], true);
      json.FinishArray;
    end;
  end;
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirRequestStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirRequestStatusEnum, false);
  ComposeEnumValue(json, 'intent', elem.IntentElement, CODES_TFhirRequestIntentEnum, false);
  ComposeEnumProps(json, 'intent', elem.IntentElement, CODES_TFhirRequestIntentEnum, false);
  ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  ComposeDateTimeValue(json, 'dateTime', elem.dateTimeElement, false);
  ComposeDateTimeProps(json, 'dateTime', elem.dateTimeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('orderer') then
    ComposeReference{TFhirPractitioner}(json, 'orderer', elem.orderer); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('allergyIntolerance') and (elem.allergyIntoleranceList.Count > 0) then
  begin
    json.valueArray('allergyIntolerance');
    for i := 0 to elem.allergyIntoleranceList.Count - 1 do
      ComposeReference{TFhirAllergyIntolerance}(json, '', elem.allergyIntoleranceList[i]); {z - Reference(AllergyIntolerance)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('foodPreferenceModifier') and (elem.foodPreferenceModifierList.Count > 0) then
  begin
    json.valueArray('foodPreferenceModifier');
    for i := 0 to elem.foodPreferenceModifierList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.foodPreferenceModifierList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('excludeFoodModifier') and (elem.excludeFoodModifierList.Count > 0) then
  begin
    json.valueArray('excludeFoodModifier');
    for i := 0 to elem.excludeFoodModifierList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.excludeFoodModifierList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('oralDiet') then
    ComposeNutritionOrderOralDiet(json, 'oralDiet', elem.oralDiet); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('supplement') and (elem.supplementList.Count > 0) then
  begin
    json.valueArray('supplement');
    for i := 0 to elem.supplementList.Count - 1 do
      ComposeNutritionOrderSupplement(json, '', elem.supplementList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('enteralFormula') then
    ComposeNutritionOrderEnteralFormula(json, 'enteralFormula', elem.enteralFormula); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('note') and (elem.noteList.Count > 0) then
  begin
    json.valueArray('note');
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(json, '', elem.noteList[i]); {z - Annotation}
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_NUTRITIONORDER}
{$IFDEF FHIR_OBSERVATION}
procedure TFHIRJsonParser.ParseObservationReferenceRange(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseObservationReferenceRange(jsn)); {2}
end;

function TFHIRJsonParser.ParseObservationReferenceRange(jsn : TJsonObject) : TFhirObservationReferenceRange;
begin
  result := TFhirObservationReferenceRange.create;
  try
    ParseObservationReferenceRangeProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseObservationReferenceRangeProperties(jsn : TJsonObject; result : TFhirObservationReferenceRange);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('low') then
        result.low := ParseQuantity(jsn.vObj['low']);{q3}
    if jsn.has('high') then
        result.high := ParseQuantity(jsn.vObj['high']);{q3}
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('appliesTo') then
      iterateArray(jsn.vArr['appliesTo'], result.appliesToList, parseCodeableConcept);
    if jsn.has('age') then
        result.age := ParseRange(jsn.vObj['age']);{q3}
    if jsn.has('text') or jsn.has('_text') then
        result.textElement := parseString(jsn.node['text'], jsn.vObj['_text']);{q}
end;

procedure TFHIRJsonComposer.ComposeObservationReferenceRange(json : TJSONWriter; name : string; elem : TFhirObservationReferenceRange; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'low', elem.low); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'high', elem.high); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) and (elem.appliesToList.Count > 0) then
  begin
    json.valueArray('appliesTo');
    for i := 0 to elem.appliesToList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.appliesToList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeRange(json, 'age', elem.age); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'text', elem.textElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseObservationComponent(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseObservationComponent(jsn)); {2}
end;

function TFHIRJsonParser.ParseObservationComponent(jsn : TJsonObject) : TFhirObservationComponent;
begin
  result := TFhirObservationComponent.create;
  try
    ParseObservationComponentProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseObservationComponentProperties(jsn : TJsonObject; result : TFhirObservationComponent);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('valueQuantity') {a4} then
      result.value := ParseQuantity(jsn.vObj['valueQuantity']);
    if jsn.has('valueCodeableConcept') {a4} then
      result.value := ParseCodeableConcept(jsn.vObj['valueCodeableConcept']);
    if jsn.has('valueRange') {a4} then
      result.value := ParseRange(jsn.vObj['valueRange']);
    if jsn.has('valueRatio') {a4} then
      result.value := ParseRatio(jsn.vObj['valueRatio']);
    if jsn.has('valueSampledData') {a4} then
      result.value := ParseSampledData(jsn.vObj['valueSampledData']);
    if jsn.has('valuePeriod') {a4} then
      result.value := ParsePeriod(jsn.vObj['valuePeriod']);
    if jsn.has('valueString') or jsn.has('_valueString') then
      result.value := parseString(jsn.node['valueString'], jsn.vObj['_valueString']);
    if jsn.has('valueBoolean') or jsn.has('_valueBoolean') then
      result.value := parseBoolean(jsn.node['valueBoolean'], jsn.vObj['_valueBoolean']);
    if jsn.has('valueInteger') or jsn.has('_valueInteger') then
      result.value := parseInteger(jsn.node['valueInteger'], jsn.vObj['_valueInteger']);
    if jsn.has('valueTime') or jsn.has('_valueTime') then
      result.value := parseTime(jsn.node['valueTime'], jsn.vObj['_valueTime']);
    if jsn.has('valueDateTime') or jsn.has('_valueDateTime') then
      result.value := parseDateTime(jsn.node['valueDateTime'], jsn.vObj['_valueDateTime']);
    if jsn.has('dataAbsentReason') then
        result.dataAbsentReason := ParseCodeableConcept(jsn.vObj['dataAbsentReason']);{q3}
    if jsn.has('interpretation') then
      iterateArray(jsn.vArr['interpretation'], result.interpretationList, parseCodeableConcept);
    if jsn.has('referenceRange') then
      iterateArray(jsn.vArr['referenceRange'], result.referenceRangeList, parseObservationReferenceRange);
end;

procedure TFHIRJsonComposer.ComposeObservationComponent(json : TJSONWriter; name : string; elem : TFhirObservationComponent; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirQuantity) then 
    ComposeQuantity(json, 'valueQuantity', TFhirQuantity(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'valueCodeableConcept', TFhirCodeableConcept(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirRange) then 
    ComposeRange(json, 'valueRange', TFhirRange(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirRatio) then 
    ComposeRatio(json, 'valueRatio', TFhirRatio(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirSampledData) then 
    ComposeSampledData(json, 'valueSampledData', TFhirSampledData(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirPeriod) then 
    ComposePeriod(json, 'valuePeriod', TFhirPeriod(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirString) then 
  begin
    ComposeStringValue(json, 'valueString', TFhirString(elem.value), false);
    ComposeStringProps(json, 'valueString', TFhirString(elem.value), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'valueBoolean', TFhirBoolean(elem.value), false);
    ComposeBooleanProps(json, 'valueBoolean', TFhirBoolean(elem.value), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirInteger) then 
  begin
    ComposeIntegerValue(json, 'valueInteger', TFhirInteger(elem.value), false);
    ComposeIntegerProps(json, 'valueInteger', TFhirInteger(elem.value), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirTime) then 
  begin
    ComposeTimeValue(json, 'valueTime', TFhirTime(elem.value), false);
    ComposeTimeProps(json, 'valueTime', TFhirTime(elem.value), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'valueDateTime', TFhirDateTime(elem.value), false);
    ComposeDateTimeProps(json, 'valueDateTime', TFhirDateTime(elem.value), false);
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'dataAbsentReason', elem.dataAbsentReason); {a}
  if (SummaryOption in [soFull, soData]) and (elem.interpretationList.Count > 0) then
  begin
    json.valueArray('interpretation');
    for i := 0 to elem.interpretationList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.interpretationList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.referenceRangeList.Count > 0) then
  begin
    json.valueArray('referenceRange');
    for i := 0 to elem.referenceRangeList.Count - 1 do
      ComposeObservationReferenceRange(json, '', elem.referenceRangeList[i]); {z - @Observation.referenceRange}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseObservation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseObservation(jsn)); {2}
end;

function TFHIRJsonParser.ParseObservation(jsn : TJsonObject) : TFhirObservation;
begin
  result := TFhirObservation.create;
  try
    ParseObservationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseObservationProperties(jsn : TJsonObject; result : TFhirObservation);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('basedOn') then
      iterateArray(jsn.vArr['basedOn'], result.basedOnList, parseReference{TFhirCarePlan});
    if jsn.has('partOf') then
      iterateArray(jsn.vArr['partOf'], result.partOfList, parseReference{TFhirMedicationAdministration});
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirObservationStatusEnum, SYSTEMS_TFhirObservationStatusEnum);
    if jsn.has('category') then
      iterateArray(jsn.vArr['category'], result.categoryList, parseCodeableConcept);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirPatient}(jsn.vObj['subject']);{q3}
    if jsn.has('focus') then
      iterateArray(jsn.vArr['focus'], result.focusList, parseReference{TFhirReference});
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q3}
    if jsn.has('effectivePeriod') {a4} then
      result.effective := ParsePeriod(jsn.vObj['effectivePeriod']);
    if jsn.has('effectiveTiming') {a4} then
      result.effective := ParseTiming(jsn.vObj['effectiveTiming']);
    if jsn.has('effectiveDateTime') or jsn.has('_effectiveDateTime') then
      result.effective := parseDateTime(jsn.node['effectiveDateTime'], jsn.vObj['_effectiveDateTime']);
    if jsn.has('effectiveInstant') or jsn.has('_effectiveInstant') then
      result.effective := parseInstant(jsn.node['effectiveInstant'], jsn.vObj['_effectiveInstant']);
    if jsn.has('issued') or jsn.has('_issued') then
        result.issuedElement := parseInstant(jsn.node['issued'], jsn.vObj['_issued']);{q}
    if jsn.has('performer') then
      iterateArray(jsn.vArr['performer'], result.performerList, parseReference{TFhirPractitioner});
    if jsn.has('valueQuantity') {a4} then
      result.value := ParseQuantity(jsn.vObj['valueQuantity']);
    if jsn.has('valueCodeableConcept') {a4} then
      result.value := ParseCodeableConcept(jsn.vObj['valueCodeableConcept']);
    if jsn.has('valueRange') {a4} then
      result.value := ParseRange(jsn.vObj['valueRange']);
    if jsn.has('valueRatio') {a4} then
      result.value := ParseRatio(jsn.vObj['valueRatio']);
    if jsn.has('valueSampledData') {a4} then
      result.value := ParseSampledData(jsn.vObj['valueSampledData']);
    if jsn.has('valuePeriod') {a4} then
      result.value := ParsePeriod(jsn.vObj['valuePeriod']);
    if jsn.has('valueString') or jsn.has('_valueString') then
      result.value := parseString(jsn.node['valueString'], jsn.vObj['_valueString']);
    if jsn.has('valueBoolean') or jsn.has('_valueBoolean') then
      result.value := parseBoolean(jsn.node['valueBoolean'], jsn.vObj['_valueBoolean']);
    if jsn.has('valueInteger') or jsn.has('_valueInteger') then
      result.value := parseInteger(jsn.node['valueInteger'], jsn.vObj['_valueInteger']);
    if jsn.has('valueTime') or jsn.has('_valueTime') then
      result.value := parseTime(jsn.node['valueTime'], jsn.vObj['_valueTime']);
    if jsn.has('valueDateTime') or jsn.has('_valueDateTime') then
      result.value := parseDateTime(jsn.node['valueDateTime'], jsn.vObj['_valueDateTime']);
    if jsn.has('dataAbsentReason') then
        result.dataAbsentReason := ParseCodeableConcept(jsn.vObj['dataAbsentReason']);{q3}
    if jsn.has('interpretation') then
      iterateArray(jsn.vArr['interpretation'], result.interpretationList, parseCodeableConcept);
    if jsn.has('note') then
      iterateArray(jsn.vArr['note'], result.noteList, parseAnnotation);
    if jsn.has('bodySite') then
        result.bodySite := ParseCodeableConcept(jsn.vObj['bodySite']);{q3}
    if jsn.has('method') then
        result.method := ParseCodeableConcept(jsn.vObj['method']);{q3}
    if jsn.has('specimen') then
        result.specimen := ParseReference{TFhirSpecimen}(jsn.vObj['specimen']);{q3}
    if jsn.has('device') then
        result.device := ParseReference{TFhirDevice}(jsn.vObj['device']);{q3}
    if jsn.has('referenceRange') then
      iterateArray(jsn.vArr['referenceRange'], result.referenceRangeList, parseObservationReferenceRange);
    if jsn.has('hasMember') then
      iterateArray(jsn.vArr['hasMember'], result.hasMemberList, parseReference{TFhirObservation});
    if jsn.has('derivedFrom') then
      iterateArray(jsn.vArr['derivedFrom'], result.derivedFromList, parseReference{TFhirDocumentReference});
    if jsn.has('component') then
      iterateArray(jsn.vArr['component'], result.componentList, parseObservationComponent);
end;

procedure TFHIRJsonComposer.ComposeObservation(json : TJSONWriter; name : string; elem : TFhirObservation; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('basedOn') and (elem.basedOnList.Count > 0) then
  begin
    json.valueArray('basedOn');
    for i := 0 to elem.basedOnList.Count - 1 do
      ComposeReference{TFhirCarePlan}(json, '', elem.basedOnList[i]); {z - Reference(CarePlan)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('partOf') and (elem.partOfList.Count > 0) then
  begin
    json.valueArray('partOf');
    for i := 0 to elem.partOfList.Count - 1 do
      ComposeReference{TFhirMedicationAdministration}(json, '', elem.partOfList[i]); {z - Reference(MedicationAdministration)}
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirObservationStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirObservationStatusEnum, false);
  if (SummaryOption in [soFull, soData]) and doCompose('category') and (elem.categoryList.Count > 0) then
  begin
    json.valueArray('category');
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.categoryList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{TFhirPatient}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('focus') and (elem.focusList.Count > 0) then
  begin
    json.valueArray('focus');
    for i := 0 to elem.focusList.Count - 1 do
      ComposeReference{TFhirReference}(json, '', elem.focusList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.effective is TFhirPeriod) then 
    ComposePeriod(json, 'effectivePeriod', TFhirPeriod(elem.effective)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.effective is TFhirTiming) then 
    ComposeTiming(json, 'effectiveTiming', TFhirTiming(elem.effective)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.effective is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'effectiveDateTime', TFhirDateTime(elem.effective), false);
    ComposeDateTimeProps(json, 'effectiveDateTime', TFhirDateTime(elem.effective), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.effective is TFhirInstant) then 
  begin
    ComposeInstantValue(json, 'effectiveInstant', TFhirInstant(elem.effective), false);
    ComposeInstantProps(json, 'effectiveInstant', TFhirInstant(elem.effective), false);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('issued') then
    ComposeInstantValue(json, 'issued', elem.issuedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('issued') then
    ComposeInstantProps(json, 'issued', elem.issuedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('performer') and (elem.performerList.Count > 0) then
  begin
    json.valueArray('performer');
    for i := 0 to elem.performerList.Count - 1 do
      ComposeReference{TFhirPractitioner}(json, '', elem.performerList[i]); {z - Reference(Practitioner)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirQuantity) then 
    ComposeQuantity(json, 'valueQuantity', TFhirQuantity(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'valueCodeableConcept', TFhirCodeableConcept(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirRange) then 
    ComposeRange(json, 'valueRange', TFhirRange(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirRatio) then 
    ComposeRatio(json, 'valueRatio', TFhirRatio(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirSampledData) then 
    ComposeSampledData(json, 'valueSampledData', TFhirSampledData(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirPeriod) then 
    ComposePeriod(json, 'valuePeriod', TFhirPeriod(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirString) then 
  begin
    ComposeStringValue(json, 'valueString', TFhirString(elem.value), false);
    ComposeStringProps(json, 'valueString', TFhirString(elem.value), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'valueBoolean', TFhirBoolean(elem.value), false);
    ComposeBooleanProps(json, 'valueBoolean', TFhirBoolean(elem.value), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirInteger) then 
  begin
    ComposeIntegerValue(json, 'valueInteger', TFhirInteger(elem.value), false);
    ComposeIntegerProps(json, 'valueInteger', TFhirInteger(elem.value), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirTime) then 
  begin
    ComposeTimeValue(json, 'valueTime', TFhirTime(elem.value), false);
    ComposeTimeProps(json, 'valueTime', TFhirTime(elem.value), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'valueDateTime', TFhirDateTime(elem.value), false);
    ComposeDateTimeProps(json, 'valueDateTime', TFhirDateTime(elem.value), false);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('dataAbsentReason') then
    ComposeCodeableConcept(json, 'dataAbsentReason', elem.dataAbsentReason); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('interpretation') and (elem.interpretationList.Count > 0) then
  begin
    json.valueArray('interpretation');
    for i := 0 to elem.interpretationList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.interpretationList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('note') and (elem.noteList.Count > 0) then
  begin
    json.valueArray('note');
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(json, '', elem.noteList[i]); {z - Annotation}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('bodySite') then
    ComposeCodeableConcept(json, 'bodySite', elem.bodySite); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('method') then
    ComposeCodeableConcept(json, 'method', elem.method); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('specimen') then
    ComposeReference{TFhirSpecimen}(json, 'specimen', elem.specimen); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('device') then
    ComposeReference{TFhirDevice}(json, 'device', elem.device); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('referenceRange') and (elem.referenceRangeList.Count > 0) then
  begin
    json.valueArray('referenceRange');
    for i := 0 to elem.referenceRangeList.Count - 1 do
      ComposeObservationReferenceRange(json, '', elem.referenceRangeList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('hasMember') and (elem.hasMemberList.Count > 0) then
  begin
    json.valueArray('hasMember');
    for i := 0 to elem.hasMemberList.Count - 1 do
      ComposeReference{TFhirObservation}(json, '', elem.hasMemberList[i]); {z - Reference(Observation)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('derivedFrom') and (elem.derivedFromList.Count > 0) then
  begin
    json.valueArray('derivedFrom');
    for i := 0 to elem.derivedFromList.Count - 1 do
      ComposeReference{TFhirDocumentReference}(json, '', elem.derivedFromList[i]); {z - Reference(DocumentReference)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('component') and (elem.componentList.Count > 0) then
  begin
    json.valueArray('component');
    for i := 0 to elem.componentList.Count - 1 do
      ComposeObservationComponent(json, '', elem.componentList[i]); {z - }
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_OBSERVATION}
{$IFDEF FHIR_OBSERVATIONDEFINITION}
procedure TFHIRJsonParser.ParseObservationDefinitionQuantitativeDetails(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseObservationDefinitionQuantitativeDetails(jsn)); {2}
end;

function TFHIRJsonParser.ParseObservationDefinitionQuantitativeDetails(jsn : TJsonObject) : TFhirObservationDefinitionQuantitativeDetails;
begin
  result := TFhirObservationDefinitionQuantitativeDetails.create;
  try
    ParseObservationDefinitionQuantitativeDetailsProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseObservationDefinitionQuantitativeDetailsProperties(jsn : TJsonObject; result : TFhirObservationDefinitionQuantitativeDetails);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('customaryUnit') then
        result.customaryUnit := ParseCodeableConcept(jsn.vObj['customaryUnit']);{q3}
    if jsn.has('unit') then
        result.unit_ := ParseCodeableConcept(jsn.vObj['unit']);{q3}
    if jsn.has('conversionFactor') or jsn.has('_conversionFactor') then
        result.conversionFactorElement := parseDecimal(jsn.node['conversionFactor'], jsn.vObj['_conversionFactor']);{q}
    if jsn.has('decimalPrecision') or jsn.has('_decimalPrecision') then
        result.decimalPrecisionElement := parseInteger(jsn.node['decimalPrecision'], jsn.vObj['_decimalPrecision']);{q}
end;

procedure TFHIRJsonComposer.ComposeObservationDefinitionQuantitativeDetails(json : TJSONWriter; name : string; elem : TFhirObservationDefinitionQuantitativeDetails; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'customaryUnit', elem.customaryUnit); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'unit', elem.unit_); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalValue(json, 'conversionFactor', elem.conversionFactorElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalProps(json, 'conversionFactor', elem.conversionFactorElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIntegerValue(json, 'decimalPrecision', elem.decimalPrecisionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIntegerProps(json, 'decimalPrecision', elem.decimalPrecisionElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseObservationDefinitionQualifiedInterval(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseObservationDefinitionQualifiedInterval(jsn)); {2}
end;

function TFHIRJsonParser.ParseObservationDefinitionQualifiedInterval(jsn : TJsonObject) : TFhirObservationDefinitionQualifiedInterval;
begin
  result := TFhirObservationDefinitionQualifiedInterval.create;
  try
    ParseObservationDefinitionQualifiedIntervalProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseObservationDefinitionQualifiedIntervalProperties(jsn : TJsonObject; result : TFhirObservationDefinitionQualifiedInterval);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('category') or jsn.has('_category')  then
      result.categoryElement := parseEnum(jsn.path+'/category', jsn.node['category'], jsn.vObj['_category'], CODES_TFhirObservationRangeCategoryEnum, SYSTEMS_TFhirObservationRangeCategoryEnum);
    if jsn.has('range') then
        result.range := ParseRange(jsn.vObj['range']);{q3}
    if jsn.has('context') then
        result.context := ParseCodeableConcept(jsn.vObj['context']);{q3}
    if jsn.has('appliesTo') then
      iterateArray(jsn.vArr['appliesTo'], result.appliesToList, parseCodeableConcept);
    if jsn.has('gender') or jsn.has('_gender')  then
      result.genderElement := parseEnum(jsn.path+'/gender', jsn.node['gender'], jsn.vObj['_gender'], CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum);
    if jsn.has('age') then
        result.age := ParseRange(jsn.vObj['age']);{q3}
    if jsn.has('gestationalAge') then
        result.gestationalAge := ParseRange(jsn.vObj['gestationalAge']);{q3}
    if jsn.has('condition') or jsn.has('_condition') then
        result.conditionElement := parseString(jsn.node['condition'], jsn.vObj['_condition']);{q}
end;

procedure TFHIRJsonComposer.ComposeObservationDefinitionQualifiedInterval(json : TJSONWriter; name : string; elem : TFhirObservationDefinitionQualifiedInterval; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumValue(json, 'category', elem.CategoryElement, CODES_TFhirObservationRangeCategoryEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumProps(json, 'category', elem.CategoryElement, CODES_TFhirObservationRangeCategoryEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeRange(json, 'range', elem.range); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'context', elem.context); {a}
  if (SummaryOption in [soFull, soData]) and (elem.appliesToList.Count > 0) then
  begin
    json.valueArray('appliesTo');
    for i := 0 to elem.appliesToList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.appliesToList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumValue(json, 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumProps(json, 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeRange(json, 'age', elem.age); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeRange(json, 'gestationalAge', elem.gestationalAge); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'condition', elem.conditionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'condition', elem.conditionElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseObservationDefinition(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseObservationDefinition(jsn)); {2}
end;

function TFHIRJsonParser.ParseObservationDefinition(jsn : TJsonObject) : TFhirObservationDefinition;
begin
  result := TFhirObservationDefinition.create;
  try
    ParseObservationDefinitionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseObservationDefinitionProperties(jsn : TJsonObject; result : TFhirObservationDefinition);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('category') then
      iterateArray(jsn.vArr['category'], result.categoryList, parseCodeableConcept);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('permittedDataType') or jsn.has('_permittedDataType') then
      iterateEnumArray(jsn.vArr['permittedDataType'], jsn.vArr['_permittedDataType'], jsn.path+'/permittedDataType', result.permittedDataTypeList, parseEnum, CODES_TFhirPermittedDataTypeEnum, SYSTEMS_TFhirPermittedDataTypeEnum);
    if jsn.has('multipleResultsAllowed') or jsn.has('_multipleResultsAllowed') then
        result.multipleResultsAllowedElement := parseBoolean(jsn.node['multipleResultsAllowed'], jsn.vObj['_multipleResultsAllowed']);{q}
    if jsn.has('method') then
        result.method := ParseCodeableConcept(jsn.vObj['method']);{q3}
    if jsn.has('preferredReportName') or jsn.has('_preferredReportName') then
        result.preferredReportNameElement := parseString(jsn.node['preferredReportName'], jsn.vObj['_preferredReportName']);{q}
    if jsn.has('quantitativeDetails') then
        result.quantitativeDetails := ParseObservationDefinitionQuantitativeDetails(jsn.vObj['quantitativeDetails']);{q3}
    if jsn.has('qualifiedInterval') then
      iterateArray(jsn.vArr['qualifiedInterval'], result.qualifiedIntervalList, parseObservationDefinitionQualifiedInterval);
    if jsn.has('validCodedValueSet') then
        result.validCodedValueSet := ParseReference{TFhirValueSet}(jsn.vObj['validCodedValueSet']);{q3}
    if jsn.has('normalCodedValueSet') then
        result.normalCodedValueSet := ParseReference{TFhirValueSet}(jsn.vObj['normalCodedValueSet']);{q3}
    if jsn.has('abnormalCodedValueSet') then
        result.abnormalCodedValueSet := ParseReference{TFhirValueSet}(jsn.vObj['abnormalCodedValueSet']);{q3}
    if jsn.has('criticalCodedValueSet') then
        result.criticalCodedValueSet := ParseReference{TFhirValueSet}(jsn.vObj['criticalCodedValueSet']);{q3}
end;

procedure TFHIRJsonComposer.ComposeObservationDefinition(json : TJSONWriter; name : string; elem : TFhirObservationDefinition; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') and (elem.categoryList.Count > 0) then
  begin
    json.valueArray('category');
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.categoryList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('permittedDataType') and (elem.permittedDataTypeList.Count > 0) then
  begin
    val := false;
    ext := false;
    for i := 0 to elem.permittedDataTypeList.Count - 1 do
    begin
      val := val or (elem.permittedDataTypeList[i].hasPrimitiveValue);
      ext := ext or ((elem.permittedDataTypeList[i].id <> '') or (elem.permittedDataTypeList[i].hasExtensionList));
    end;
    if val then
    begin
      json.valueArray('permittedDataType');
      for i := 0 to elem.permittedDataTypeList.Count - 1 do
        ComposeEnumValue(json, '', elem.permittedDataTypeList[i], CODES_TFhirPermittedDataTypeEnum, true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_permittedDataType');
      for i := 0 to elem.permittedDataTypeList.Count - 1 do
        ComposeEnumProps(json, '', elem.permittedDataTypeList[i], CODES_TFhirPermittedDataTypeEnum, true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('multipleResultsAllowed') then
    ComposeBooleanValue(json, 'multipleResultsAllowed', elem.multipleResultsAllowedElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('multipleResultsAllowed') then
    ComposeBooleanProps(json, 'multipleResultsAllowed', elem.multipleResultsAllowedElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('method') then
    ComposeCodeableConcept(json, 'method', elem.method); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('preferredReportName') then
    ComposeStringValue(json, 'preferredReportName', elem.preferredReportNameElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('preferredReportName') then
    ComposeStringProps(json, 'preferredReportName', elem.preferredReportNameElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('quantitativeDetails') then
    ComposeObservationDefinitionQuantitativeDetails(json, 'quantitativeDetails', elem.quantitativeDetails); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('qualifiedInterval') and (elem.qualifiedIntervalList.Count > 0) then
  begin
    json.valueArray('qualifiedInterval');
    for i := 0 to elem.qualifiedIntervalList.Count - 1 do
      ComposeObservationDefinitionQualifiedInterval(json, '', elem.qualifiedIntervalList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('validCodedValueSet') then
    ComposeReference{TFhirValueSet}(json, 'validCodedValueSet', elem.validCodedValueSet); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('normalCodedValueSet') then
    ComposeReference{TFhirValueSet}(json, 'normalCodedValueSet', elem.normalCodedValueSet); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('abnormalCodedValueSet') then
    ComposeReference{TFhirValueSet}(json, 'abnormalCodedValueSet', elem.abnormalCodedValueSet); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('criticalCodedValueSet') then
    ComposeReference{TFhirValueSet}(json, 'criticalCodedValueSet', elem.criticalCodedValueSet); {a}
end;

{$ENDIF FHIR_OBSERVATIONDEFINITION}
{$IFDEF FHIR_OPERATIONDEFINITION}
procedure TFHIRJsonParser.ParseOperationDefinitionParameter(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseOperationDefinitionParameter(jsn)); {2}
end;

function TFHIRJsonParser.ParseOperationDefinitionParameter(jsn : TJsonObject) : TFhirOperationDefinitionParameter;
begin
  result := TFhirOperationDefinitionParameter.create;
  try
    ParseOperationDefinitionParameterProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseOperationDefinitionParameterProperties(jsn : TJsonObject; result : TFhirOperationDefinitionParameter);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseCode(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('use') or jsn.has('_use')  then
      result.useElement := parseEnum(jsn.path+'/use', jsn.node['use'], jsn.vObj['_use'], CODES_TFhirOperationParameterUseEnum, SYSTEMS_TFhirOperationParameterUseEnum);
    if jsn.has('min') or jsn.has('_min') then
        result.minElement := parseInteger(jsn.node['min'], jsn.vObj['_min']);{q}
    if jsn.has('max') or jsn.has('_max') then
        result.maxElement := parseString(jsn.node['max'], jsn.vObj['_max']);{q}
    if jsn.has('documentation') or jsn.has('_documentation') then
        result.documentationElement := parseString(jsn.node['documentation'], jsn.vObj['_documentation']);{q}
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn.node['type'], jsn.vObj['_type'], CODES_TFhirAllTypesEnum, SYSTEMS_TFhirAllTypesEnum);
      if jsn.has('targetProfile') or jsn.has('_targetProfile') then
      iteratePrimitiveArray(jsn.vArr['targetProfile'], jsn.vArr['_targetProfile'], result.targetProfileList, parseCanonical);
    if jsn.has('searchType') or jsn.has('_searchType')  then
      result.searchTypeElement := parseEnum(jsn.path+'/searchType', jsn.node['searchType'], jsn.vObj['_searchType'], CODES_TFhirSearchParamTypeEnum, SYSTEMS_TFhirSearchParamTypeEnum);
    if jsn.has('binding') then
        result.binding := ParseOperationDefinitionParameterBinding(jsn.vObj['binding']);{q3}
    if jsn.has('referencedFrom') then
      iterateArray(jsn.vArr['referencedFrom'], result.referencedFromList, parseOperationDefinitionParameterReferencedFrom);
    if jsn.has('part') then
      iterateArray(jsn.vArr['part'], result.partList, parseOperationDefinitionParameter);
end;

procedure TFHIRJsonComposer.ComposeOperationDefinitionParameter(json : TJSONWriter; name : string; elem : TFhirOperationDefinitionParameter; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeValue(json, 'name', elem.nameElement, false);
  ComposeCodeProps(json, 'name', elem.nameElement, false);
  ComposeEnumValue(json, 'use', elem.UseElement, CODES_TFhirOperationParameterUseEnum, false);
  ComposeEnumProps(json, 'use', elem.UseElement, CODES_TFhirOperationParameterUseEnum, false);
  ComposeIntegerValue(json, 'min', elem.minElement, false);
  ComposeIntegerProps(json, 'min', elem.minElement, false);
  ComposeStringValue(json, 'max', elem.maxElement, false);
  ComposeStringProps(json, 'max', elem.maxElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'documentation', elem.documentationElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'documentation', elem.documentationElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirAllTypesEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirAllTypesEnum, false);
  if (SummaryOption in [soFull, soData]) and (elem.targetProfileList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.targetProfileList.Count - 1 do
    begin
      ext := ext or ((elem.targetProfileList[i].id <> '') or (elem.targetProfileList[i].hasExtensionList) {no-comments or (elem.targetProfileList[i].hasComments)});
      val := val or (elem.targetProfileList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('targetProfile');
      for i := 0 to elem.targetProfileList.Count - 1 do
        ComposeCanonicalValue(json, '',elem.targetProfileList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_targetProfile');
      for i := 0 to elem.targetProfileList.Count - 1 do
        ComposeCanonicalProps(json, '',elem.targetProfileList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumValue(json, 'searchType', elem.SearchTypeElement, CODES_TFhirSearchParamTypeEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumProps(json, 'searchType', elem.SearchTypeElement, CODES_TFhirSearchParamTypeEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeOperationDefinitionParameterBinding(json, 'binding', elem.binding); {a}
  if (SummaryOption in [soFull, soData]) and (elem.referencedFromList.Count > 0) then
  begin
    json.valueArray('referencedFrom');
    for i := 0 to elem.referencedFromList.Count - 1 do
      ComposeOperationDefinitionParameterReferencedFrom(json, '', elem.referencedFromList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.partList.Count > 0) then
  begin
    json.valueArray('part');
    for i := 0 to elem.partList.Count - 1 do
      ComposeOperationDefinitionParameter(json, '', elem.partList[i]); {z - @OperationDefinition.parameter}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseOperationDefinitionParameterBinding(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseOperationDefinitionParameterBinding(jsn)); {2}
end;

function TFHIRJsonParser.ParseOperationDefinitionParameterBinding(jsn : TJsonObject) : TFhirOperationDefinitionParameterBinding;
begin
  result := TFhirOperationDefinitionParameterBinding.create;
  try
    ParseOperationDefinitionParameterBindingProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseOperationDefinitionParameterBindingProperties(jsn : TJsonObject; result : TFhirOperationDefinitionParameterBinding);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('strength') or jsn.has('_strength')  then
      result.strengthElement := parseEnum(jsn.path+'/strength', jsn.node['strength'], jsn.vObj['_strength'], CODES_TFhirBindingStrengthEnum, SYSTEMS_TFhirBindingStrengthEnum);
    if jsn.has('valueSet') or jsn.has('_valueSet') then
        result.valueSetElement := parseCanonical(jsn.node['valueSet'], jsn.vObj['_valueSet']);{q}
end;

procedure TFHIRJsonComposer.ComposeOperationDefinitionParameterBinding(json : TJSONWriter; name : string; elem : TFhirOperationDefinitionParameterBinding; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'strength', elem.StrengthElement, CODES_TFhirBindingStrengthEnum, false);
  ComposeEnumProps(json, 'strength', elem.StrengthElement, CODES_TFhirBindingStrengthEnum, false);
  ComposeCanonicalValue(json, 'valueSet', elem.valueSetElement, false);
  ComposeCanonicalProps(json, 'valueSet', elem.valueSetElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseOperationDefinitionParameterReferencedFrom(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseOperationDefinitionParameterReferencedFrom(jsn)); {2}
end;

function TFHIRJsonParser.ParseOperationDefinitionParameterReferencedFrom(jsn : TJsonObject) : TFhirOperationDefinitionParameterReferencedFrom;
begin
  result := TFhirOperationDefinitionParameterReferencedFrom.create;
  try
    ParseOperationDefinitionParameterReferencedFromProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseOperationDefinitionParameterReferencedFromProperties(jsn : TJsonObject; result : TFhirOperationDefinitionParameterReferencedFrom);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('source') or jsn.has('_source') then
        result.sourceElement := parseString(jsn.node['source'], jsn.vObj['_source']);{q}
    if jsn.has('sourceId') or jsn.has('_sourceId') then
        result.sourceIdElement := parseString(jsn.node['sourceId'], jsn.vObj['_sourceId']);{q}
end;

procedure TFHIRJsonComposer.ComposeOperationDefinitionParameterReferencedFrom(json : TJSONWriter; name : string; elem : TFhirOperationDefinitionParameterReferencedFrom; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'source', elem.sourceElement, false);
  ComposeStringProps(json, 'source', elem.sourceElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'sourceId', elem.sourceIdElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'sourceId', elem.sourceIdElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseOperationDefinitionOverload(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseOperationDefinitionOverload(jsn)); {2}
end;

function TFHIRJsonParser.ParseOperationDefinitionOverload(jsn : TJsonObject) : TFhirOperationDefinitionOverload;
begin
  result := TFhirOperationDefinitionOverload.create;
  try
    ParseOperationDefinitionOverloadProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseOperationDefinitionOverloadProperties(jsn : TJsonObject; result : TFhirOperationDefinitionOverload);
begin
    ParseBackboneElementProperties(jsn, result);
      if jsn.has('parameterName') or jsn.has('_parameterName') then
      iteratePrimitiveArray(jsn.vArr['parameterName'], jsn.vArr['_parameterName'], result.parameterNameList, parseString);
    if jsn.has('comment') or jsn.has('_comment') then
        result.commentElement := parseString(jsn.node['comment'], jsn.vObj['_comment']);{q}
end;

procedure TFHIRJsonComposer.ComposeOperationDefinitionOverload(json : TJSONWriter; name : string; elem : TFhirOperationDefinitionOverload; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and (elem.parameterNameList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.parameterNameList.Count - 1 do
    begin
      ext := ext or ((elem.parameterNameList[i].id <> '') or (elem.parameterNameList[i].hasExtensionList) {no-comments or (elem.parameterNameList[i].hasComments)});
      val := val or (elem.parameterNameList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('parameterName');
      for i := 0 to elem.parameterNameList.Count - 1 do
        ComposeStringValue(json, '',elem.parameterNameList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_parameterName');
      for i := 0 to elem.parameterNameList.Count - 1 do
        ComposeStringProps(json, '',elem.parameterNameList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'comment', elem.commentElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'comment', elem.commentElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseOperationDefinition(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseOperationDefinition(jsn)); {2}
end;

function TFHIRJsonParser.ParseOperationDefinition(jsn : TJsonObject) : TFhirOperationDefinition;
begin
  result := TFhirOperationDefinition.create;
  try
    ParseOperationDefinitionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseOperationDefinitionProperties(jsn : TJsonObject; result : TFhirOperationDefinition);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := parseUri(jsn.node['url'], jsn.vObj['_url']);{q}
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := parseString(jsn.node['version'], jsn.vObj['_version']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('title') or jsn.has('_title') then
        result.titleElement := parseString(jsn.node['title'], jsn.vObj['_title']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    if jsn.has('kind') or jsn.has('_kind')  then
      result.kindElement := parseEnum(jsn.path+'/kind', jsn.node['kind'], jsn.vObj['_kind'], CODES_TFhirOperationKindEnum, SYSTEMS_TFhirOperationKindEnum);
    if jsn.has('experimental') or jsn.has('_experimental') then
        result.experimentalElement := parseBoolean(jsn.node['experimental'], jsn.vObj['_experimental']);{q}
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := parseDateTime(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('publisher') or jsn.has('_publisher') then
        result.publisherElement := parseString(jsn.node['publisher'], jsn.vObj['_publisher']);{q}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseContactDetail);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseMarkdown(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('useContext') then
      iterateArray(jsn.vArr['useContext'], result.useContextList, parseUsageContext);
    if jsn.has('jurisdiction') then
      iterateArray(jsn.vArr['jurisdiction'], result.jurisdictionList, parseCodeableConcept);
    if jsn.has('purpose') or jsn.has('_purpose') then
        result.purposeElement := parseMarkdown(jsn.node['purpose'], jsn.vObj['_purpose']);{q}
    if jsn.has('affectsState') or jsn.has('_affectsState') then
        result.affectsStateElement := parseBoolean(jsn.node['affectsState'], jsn.vObj['_affectsState']);{q}
    if jsn.has('code') or jsn.has('_code') then
        result.codeElement := parseCode(jsn.node['code'], jsn.vObj['_code']);{q}
    if jsn.has('comment') or jsn.has('_comment') then
        result.commentElement := parseMarkdown(jsn.node['comment'], jsn.vObj['_comment']);{q}
    if jsn.has('base') or jsn.has('_base') then
        result.baseElement := parseCanonical(jsn.node['base'], jsn.vObj['_base']);{q}
    if jsn.has('resource') or jsn.has('_resource') then
      iterateEnumArray(jsn.vArr['resource'], jsn.vArr['_resource'], jsn.path+'/resource', result.resource, parseEnum, CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum);
    if jsn.has('system') or jsn.has('_system') then
        result.systemElement := parseBoolean(jsn.node['system'], jsn.vObj['_system']);{q}
    if jsn.has('type') or jsn.has('_type') then
        result.type_Element := parseBoolean(jsn.node['type'], jsn.vObj['_type']);{q}
    if jsn.has('instance') or jsn.has('_instance') then
        result.instanceElement := parseBoolean(jsn.node['instance'], jsn.vObj['_instance']);{q}
    if jsn.has('inputProfile') or jsn.has('_inputProfile') then
        result.inputProfileElement := parseCanonical(jsn.node['inputProfile'], jsn.vObj['_inputProfile']);{q}
    if jsn.has('outputProfile') or jsn.has('_outputProfile') then
        result.outputProfileElement := parseCanonical(jsn.node['outputProfile'], jsn.vObj['_outputProfile']);{q}
    if jsn.has('parameter') then
      iterateArray(jsn.vArr['parameter'], result.parameterList, parseOperationDefinitionParameter);
    if jsn.has('overload') then
      iterateArray(jsn.vArr['overload'], result.overloadList, parseOperationDefinitionOverload);
end;

procedure TFHIRJsonComposer.ComposeOperationDefinition(json : TJSONWriter; name : string; elem : TFhirOperationDefinition; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUriValue(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUriProps(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeStringValue(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeStringProps(json, 'version', elem.versionElement, false);
  ComposeStringValue(json, 'name', elem.nameElement, false);
  ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeStringValue(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeStringProps(json, 'title', elem.titleElement, false);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, false);
  ComposeEnumValue(json, 'kind', elem.KindElement, CODES_TFhirOperationKindEnum, false);
  ComposeEnumProps(json, 'kind', elem.KindElement, CODES_TFhirOperationKindEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBooleanValue(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBooleanProps(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringValue(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringProps(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') and (elem.contactList.Count > 0) then
  begin
    json.valueArray('contact');
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(json, '', elem.contactList[i]); {z - ContactDetail}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdownValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdownProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') and (elem.useContextList.Count > 0) then
  begin
    json.valueArray('useContext');
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(json, '', elem.useContextList[i]); {z - UsageContext}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') and (elem.jurisdictionList.Count > 0) then
  begin
    json.valueArray('jurisdiction');
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.jurisdictionList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdownValue(json, 'purpose', elem.purposeElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdownProps(json, 'purpose', elem.purposeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('affectsState') then
    ComposeBooleanValue(json, 'affectsState', elem.affectsStateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('affectsState') then
    ComposeBooleanProps(json, 'affectsState', elem.affectsStateElement, false);
  ComposeCodeValue(json, 'code', elem.codeElement, false);
  ComposeCodeProps(json, 'code', elem.codeElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('comment') then
    ComposeMarkdownValue(json, 'comment', elem.commentElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('comment') then
    ComposeMarkdownProps(json, 'comment', elem.commentElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('base') then
    ComposeCanonicalValue(json, 'base', elem.baseElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('base') then
    ComposeCanonicalProps(json, 'base', elem.baseElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('resource') and (elem.resource.Count > 0) then
  begin
    val := false;
    ext := false;
    for i := 0 to elem.resource.Count - 1 do
    begin
      val := val or (elem.resource[i].hasPrimitiveValue);
      ext := ext or ((elem.resource[i].id <> '') or (elem.resource[i].hasExtensionList));
    end;
    if val then
    begin
      json.valueArray('resource');
      for i := 0 to elem.resource.Count - 1 do
        ComposeEnumValue(json, '', elem.resource[i], CODES_TFhirResourceTypesEnum, true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_resource');
      for i := 0 to elem.resource.Count - 1 do
        ComposeEnumProps(json, '', elem.resource[i], CODES_TFhirResourceTypesEnum, true);
      json.FinishArray;
    end;
  end;
  ComposeBooleanValue(json, 'system', elem.systemElement, false);
  ComposeBooleanProps(json, 'system', elem.systemElement, false);
  ComposeBooleanValue(json, 'type', elem.type_Element, false);
  ComposeBooleanProps(json, 'type', elem.type_Element, false);
  ComposeBooleanValue(json, 'instance', elem.instanceElement, false);
  ComposeBooleanProps(json, 'instance', elem.instanceElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('inputProfile') then
    ComposeCanonicalValue(json, 'inputProfile', elem.inputProfileElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('inputProfile') then
    ComposeCanonicalProps(json, 'inputProfile', elem.inputProfileElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('outputProfile') then
    ComposeCanonicalValue(json, 'outputProfile', elem.outputProfileElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('outputProfile') then
    ComposeCanonicalProps(json, 'outputProfile', elem.outputProfileElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('parameter') and (elem.parameterList.Count > 0) then
  begin
    json.valueArray('parameter');
    for i := 0 to elem.parameterList.Count - 1 do
      ComposeOperationDefinitionParameter(json, '', elem.parameterList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('overload') and (elem.overloadList.Count > 0) then
  begin
    json.valueArray('overload');
    for i := 0 to elem.overloadList.Count - 1 do
      ComposeOperationDefinitionOverload(json, '', elem.overloadList[i]); {z - }
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_OPERATIONDEFINITION}
{$IFDEF FHIR_OPERATIONOUTCOME}
procedure TFHIRJsonParser.ParseOperationOutcomeIssue(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseOperationOutcomeIssue(jsn)); {2}
end;

function TFHIRJsonParser.ParseOperationOutcomeIssue(jsn : TJsonObject) : TFhirOperationOutcomeIssue;
begin
  result := TFhirOperationOutcomeIssue.create;
  try
    ParseOperationOutcomeIssueProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseOperationOutcomeIssueProperties(jsn : TJsonObject; result : TFhirOperationOutcomeIssue);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('severity') or jsn.has('_severity')  then
      result.severityElement := parseEnum(jsn.path+'/severity', jsn.node['severity'], jsn.vObj['_severity'], CODES_TFhirIssueSeverityEnum, SYSTEMS_TFhirIssueSeverityEnum);
    if jsn.has('code') or jsn.has('_code')  then
      result.codeElement := parseEnum(jsn.path+'/code', jsn.node['code'], jsn.vObj['_code'], CODES_TFhirIssueTypeEnum, SYSTEMS_TFhirIssueTypeEnum);
    if jsn.has('details') then
        result.details := ParseCodeableConcept(jsn.vObj['details']);{q3}
    if jsn.has('diagnostics') or jsn.has('_diagnostics') then
        result.diagnosticsElement := parseString(jsn.node['diagnostics'], jsn.vObj['_diagnostics']);{q}
      if jsn.has('location') or jsn.has('_location') then
      iteratePrimitiveArray(jsn.vArr['location'], jsn.vArr['_location'], result.locationList, parseString);
      if jsn.has('expression') or jsn.has('_expression') then
      iteratePrimitiveArray(jsn.vArr['expression'], jsn.vArr['_expression'], result.expressionList, parseString);
end;

procedure TFHIRJsonComposer.ComposeOperationOutcomeIssue(json : TJSONWriter; name : string; elem : TFhirOperationOutcomeIssue; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'severity', elem.SeverityElement, CODES_TFhirIssueSeverityEnum, false);
  ComposeEnumProps(json, 'severity', elem.SeverityElement, CODES_TFhirIssueSeverityEnum, false);
  ComposeEnumValue(json, 'code', elem.CodeElement, CODES_TFhirIssueTypeEnum, false);
  ComposeEnumProps(json, 'code', elem.CodeElement, CODES_TFhirIssueTypeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'details', elem.details); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'diagnostics', elem.diagnosticsElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'diagnostics', elem.diagnosticsElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.locationList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.locationList.Count - 1 do
    begin
      ext := ext or ((elem.locationList[i].id <> '') or (elem.locationList[i].hasExtensionList) {no-comments or (elem.locationList[i].hasComments)});
      val := val or (elem.locationList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('location');
      for i := 0 to elem.locationList.Count - 1 do
        ComposeStringValue(json, '',elem.locationList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_location');
      for i := 0 to elem.locationList.Count - 1 do
        ComposeStringProps(json, '',elem.locationList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.expressionList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.expressionList.Count - 1 do
    begin
      ext := ext or ((elem.expressionList[i].id <> '') or (elem.expressionList[i].hasExtensionList) {no-comments or (elem.expressionList[i].hasComments)});
      val := val or (elem.expressionList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('expression');
      for i := 0 to elem.expressionList.Count - 1 do
        ComposeStringValue(json, '',elem.expressionList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_expression');
      for i := 0 to elem.expressionList.Count - 1 do
        ComposeStringProps(json, '',elem.expressionList[i], true);
      json.FinishArray;
    end;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseOperationOutcome(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseOperationOutcome(jsn)); {2}
end;

function TFHIRJsonParser.ParseOperationOutcome(jsn : TJsonObject) : TFhirOperationOutcome;
begin
  result := TFhirOperationOutcome.create;
  try
    ParseOperationOutcomeProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseOperationOutcomeProperties(jsn : TJsonObject; result : TFhirOperationOutcome);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('issue') then
      iterateArray(jsn.vArr['issue'], result.issueList, parseOperationOutcomeIssue);
end;

procedure TFHIRJsonComposer.ComposeOperationOutcome(json : TJSONWriter; name : string; elem : TFhirOperationOutcome; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (elem.issueList.Count > 0) then
  begin
    json.valueArray('issue');
    for i := 0 to elem.issueList.Count - 1 do
      ComposeOperationOutcomeIssue(json, '', elem.issueList[i]); {z - }
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_OPERATIONOUTCOME}
{$IFDEF FHIR_ORGANIZATION}
procedure TFHIRJsonParser.ParseOrganizationContact(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseOrganizationContact(jsn)); {2}
end;

function TFHIRJsonParser.ParseOrganizationContact(jsn : TJsonObject) : TFhirOrganizationContact;
begin
  result := TFhirOrganizationContact.create;
  try
    ParseOrganizationContactProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseOrganizationContactProperties(jsn : TJsonObject; result : TFhirOrganizationContact);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('purpose') then
        result.purpose := ParseCodeableConcept(jsn.vObj['purpose']);{q3}
    if jsn.has('name') then
        result.name := ParseHumanName(jsn.vObj['name']);{q3}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    if jsn.has('address') then
        result.address := ParseAddress(jsn.vObj['address']);{q3}
end;

procedure TFHIRJsonComposer.ComposeOrganizationContact(json : TJSONWriter; name : string; elem : TFhirOrganizationContact; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'purpose', elem.purpose); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeHumanName(json, 'name', elem.name); {a}
  if (SummaryOption in [soFull, soData]) and (elem.telecomList.Count > 0) then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '', elem.telecomList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeAddress(json, 'address', elem.address); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseOrganization(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseOrganization(jsn)); {2}
end;

function TFHIRJsonParser.ParseOrganization(jsn : TJsonObject) : TFhirOrganization;
begin
  result := TFhirOrganization.create;
  try
    ParseOrganizationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseOrganizationProperties(jsn : TJsonObject; result : TFhirOrganization);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('active') or jsn.has('_active') then
        result.activeElement := parseBoolean(jsn.node['active'], jsn.vObj['_active']);{q}
    if jsn.has('type') then
      iterateArray(jsn.vArr['type'], result.type_List, parseCodeableConcept);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
      if jsn.has('alias') or jsn.has('_alias') then
      iteratePrimitiveArray(jsn.vArr['alias'], jsn.vArr['_alias'], result.aliasList, parseString);
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    if jsn.has('address') then
      iterateArray(jsn.vArr['address'], result.addressList, parseAddress);
    if jsn.has('partOf') then
        result.partOf := ParseReference{TFhirOrganization}(jsn.vObj['partOf']);{q3}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseOrganizationContact);
    if jsn.has('endpoint') then
      iterateArray(jsn.vArr['endpoint'], result.endpointList, parseReference{TFhirEndpoint});
end;

procedure TFHIRJsonComposer.ComposeOrganization(json : TJSONWriter; name : string; elem : TFhirOrganization; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('active') then
    ComposeBooleanValue(json, 'active', elem.activeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('active') then
    ComposeBooleanProps(json, 'active', elem.activeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') and (elem.type_List.Count > 0) then
  begin
    json.valueArray('type');
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(json, '', elem.type_List[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('alias') and (elem.aliasList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.aliasList.Count - 1 do
    begin
      ext := ext or ((elem.aliasList[i].id <> '') or (elem.aliasList[i].hasExtensionList) {no-comments or (elem.aliasList[i].hasComments)});
      val := val or (elem.aliasList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('alias');
      for i := 0 to elem.aliasList.Count - 1 do
        ComposeStringValue(json, '',elem.aliasList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_alias');
      for i := 0 to elem.aliasList.Count - 1 do
        ComposeStringProps(json, '',elem.aliasList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('telecom') and (elem.telecomList.Count > 0) then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '', elem.telecomList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('address') and (elem.addressList.Count > 0) then
  begin
    json.valueArray('address');
    for i := 0 to elem.addressList.Count - 1 do
      ComposeAddress(json, '', elem.addressList[i]); {z - Address}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('partOf') then
    ComposeReference{TFhirOrganization}(json, 'partOf', elem.partOf); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('contact') and (elem.contactList.Count > 0) then
  begin
    json.valueArray('contact');
    for i := 0 to elem.contactList.Count - 1 do
      ComposeOrganizationContact(json, '', elem.contactList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('endpoint') and (elem.endpointList.Count > 0) then
  begin
    json.valueArray('endpoint');
    for i := 0 to elem.endpointList.Count - 1 do
      ComposeReference{TFhirEndpoint}(json, '', elem.endpointList[i]); {z - Reference(Endpoint)}
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_ORGANIZATION}
{$IFDEF FHIR_ORGANIZATIONAFFILIATION}
procedure TFHIRJsonParser.ParseOrganizationAffiliation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseOrganizationAffiliation(jsn)); {2}
end;

function TFHIRJsonParser.ParseOrganizationAffiliation(jsn : TJsonObject) : TFhirOrganizationAffiliation;
begin
  result := TFhirOrganizationAffiliation.create;
  try
    ParseOrganizationAffiliationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseOrganizationAffiliationProperties(jsn : TJsonObject; result : TFhirOrganizationAffiliation);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('active') or jsn.has('_active') then
        result.activeElement := parseBoolean(jsn.node['active'], jsn.vObj['_active']);{q}
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q3}
    if jsn.has('organization') then
        result.organization := ParseReference{TFhirOrganization}(jsn.vObj['organization']);{q3}
    if jsn.has('participatingOrganization') then
        result.participatingOrganization := ParseReference{TFhirOrganization}(jsn.vObj['participatingOrganization']);{q3}
    if jsn.has('network') then
      iterateArray(jsn.vArr['network'], result.networkList, parseReference{TFhirOrganization});
    if jsn.has('code') then
      iterateArray(jsn.vArr['code'], result.codeList, parseCodeableConcept);
    if jsn.has('specialty') then
      iterateArray(jsn.vArr['specialty'], result.specialtyList, parseCodeableConcept);
    if jsn.has('location') then
      iterateArray(jsn.vArr['location'], result.locationList, parseReference{TFhirLocation});
    if jsn.has('healthcareService') then
      iterateArray(jsn.vArr['healthcareService'], result.healthcareServiceList, parseReference{TFhirHealthcareService});
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    if jsn.has('endpoint') then
      iterateArray(jsn.vArr['endpoint'], result.endpointList, parseReference{TFhirEndpoint});
end;

procedure TFHIRJsonComposer.ComposeOrganizationAffiliation(json : TJSONWriter; name : string; elem : TFhirOrganizationAffiliation; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('active') then
    ComposeBooleanValue(json, 'active', elem.activeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('active') then
    ComposeBooleanProps(json, 'active', elem.activeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('period') then
    ComposePeriod(json, 'period', elem.period); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('organization') then
    ComposeReference{TFhirOrganization}(json, 'organization', elem.organization); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('participatingOrganization') then
    ComposeReference{TFhirOrganization}(json, 'participatingOrganization', elem.participatingOrganization); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('network') and (elem.networkList.Count > 0) then
  begin
    json.valueArray('network');
    for i := 0 to elem.networkList.Count - 1 do
      ComposeReference{TFhirOrganization}(json, '', elem.networkList[i]); {z - Reference(Organization)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') and (elem.codeList.Count > 0) then
  begin
    json.valueArray('code');
    for i := 0 to elem.codeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.codeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('specialty') and (elem.specialtyList.Count > 0) then
  begin
    json.valueArray('specialty');
    for i := 0 to elem.specialtyList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.specialtyList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('location') and (elem.locationList.Count > 0) then
  begin
    json.valueArray('location');
    for i := 0 to elem.locationList.Count - 1 do
      ComposeReference{TFhirLocation}(json, '', elem.locationList[i]); {z - Reference(Location)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('healthcareService') and (elem.healthcareServiceList.Count > 0) then
  begin
    json.valueArray('healthcareService');
    for i := 0 to elem.healthcareServiceList.Count - 1 do
      ComposeReference{TFhirHealthcareService}(json, '', elem.healthcareServiceList[i]); {z - Reference(HealthcareService)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('telecom') and (elem.telecomList.Count > 0) then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '', elem.telecomList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('endpoint') and (elem.endpointList.Count > 0) then
  begin
    json.valueArray('endpoint');
    for i := 0 to elem.endpointList.Count - 1 do
      ComposeReference{TFhirEndpoint}(json, '', elem.endpointList[i]); {z - Reference(Endpoint)}
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_ORGANIZATIONAFFILIATION}
{$IFDEF FHIR_PATIENT}
procedure TFHIRJsonParser.ParsePatientContact(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePatientContact(jsn)); {2}
end;

function TFHIRJsonParser.ParsePatientContact(jsn : TJsonObject) : TFhirPatientContact;
begin
  result := TFhirPatientContact.create;
  try
    ParsePatientContactProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParsePatientContactProperties(jsn : TJsonObject; result : TFhirPatientContact);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('relationship') then
      iterateArray(jsn.vArr['relationship'], result.relationshipList, parseCodeableConcept);
    if jsn.has('name') then
        result.name := ParseHumanName(jsn.vObj['name']);{q3}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    if jsn.has('address') then
        result.address := ParseAddress(jsn.vObj['address']);{q3}
    if jsn.has('gender') or jsn.has('_gender')  then
      result.genderElement := parseEnum(jsn.path+'/gender', jsn.node['gender'], jsn.vObj['_gender'], CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum);
    if jsn.has('organization') then
        result.organization := ParseReference{TFhirOrganization}(jsn.vObj['organization']);{q3}
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q3}
end;

procedure TFHIRJsonComposer.ComposePatientContact(json : TJSONWriter; name : string; elem : TFhirPatientContact; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and (elem.relationshipList.Count > 0) then
  begin
    json.valueArray('relationship');
    for i := 0 to elem.relationshipList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.relationshipList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeHumanName(json, 'name', elem.name); {a}
  if (SummaryOption in [soFull, soData]) and (elem.telecomList.Count > 0) then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '', elem.telecomList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeAddress(json, 'address', elem.address); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumValue(json, 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumProps(json, 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(json, 'organization', elem.organization); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(json, 'period', elem.period); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParsePatientCommunication(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePatientCommunication(jsn)); {2}
end;

function TFHIRJsonParser.ParsePatientCommunication(jsn : TJsonObject) : TFhirPatientCommunication;
begin
  result := TFhirPatientCommunication.create;
  try
    ParsePatientCommunicationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParsePatientCommunicationProperties(jsn : TJsonObject; result : TFhirPatientCommunication);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('language') then
        result.language := ParseCodeableConcept(jsn.vObj['language']);{q3}
    if jsn.has('preferred') or jsn.has('_preferred') then
        result.preferredElement := parseBoolean(jsn.node['preferred'], jsn.vObj['_preferred']);{q}
end;

procedure TFHIRJsonComposer.ComposePatientCommunication(json : TJSONWriter; name : string; elem : TFhirPatientCommunication; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'language', elem.language); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'preferred', elem.preferredElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'preferred', elem.preferredElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParsePatientLink(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePatientLink(jsn)); {2}
end;

function TFHIRJsonParser.ParsePatientLink(jsn : TJsonObject) : TFhirPatientLink;
begin
  result := TFhirPatientLink.create;
  try
    ParsePatientLinkProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParsePatientLinkProperties(jsn : TJsonObject; result : TFhirPatientLink);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('other') then
        result.other := ParseReference{TFhirPatient}(jsn.vObj['other']);{q3}
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn.node['type'], jsn.vObj['_type'], CODES_TFhirLinkTypeEnum, SYSTEMS_TFhirLinkTypeEnum);
end;

procedure TFHIRJsonComposer.ComposePatientLink(json : TJSONWriter; name : string; elem : TFhirPatientLink; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeReference{TFhirPatient}(json, 'other', elem.other); {a}
  ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirLinkTypeEnum, false);
  ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirLinkTypeEnum, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParsePatient(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePatient(jsn)); {2}
end;

function TFHIRJsonParser.ParsePatient(jsn : TJsonObject) : TFhirPatient;
begin
  result := TFhirPatient.create;
  try
    ParsePatientProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParsePatientProperties(jsn : TJsonObject; result : TFhirPatient);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('active') or jsn.has('_active') then
        result.activeElement := parseBoolean(jsn.node['active'], jsn.vObj['_active']);{q}
    if jsn.has('name') then
      iterateArray(jsn.vArr['name'], result.nameList, parseHumanName);
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    if jsn.has('gender') or jsn.has('_gender')  then
      result.genderElement := parseEnum(jsn.path+'/gender', jsn.node['gender'], jsn.vObj['_gender'], CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum);
    if jsn.has('birthDate') or jsn.has('_birthDate') then
        result.birthDateElement := parseDate(jsn.node['birthDate'], jsn.vObj['_birthDate']);{q}
    if jsn.has('deceasedBoolean') or jsn.has('_deceasedBoolean') then
      result.deceased := parseBoolean(jsn.node['deceasedBoolean'], jsn.vObj['_deceasedBoolean']);
    if jsn.has('deceasedDateTime') or jsn.has('_deceasedDateTime') then
      result.deceased := parseDateTime(jsn.node['deceasedDateTime'], jsn.vObj['_deceasedDateTime']);
    if jsn.has('address') then
      iterateArray(jsn.vArr['address'], result.addressList, parseAddress);
    if jsn.has('maritalStatus') then
        result.maritalStatus := ParseCodeableConcept(jsn.vObj['maritalStatus']);{q3}
    if jsn.has('multipleBirthBoolean') or jsn.has('_multipleBirthBoolean') then
      result.multipleBirth := parseBoolean(jsn.node['multipleBirthBoolean'], jsn.vObj['_multipleBirthBoolean']);
    if jsn.has('multipleBirthInteger') or jsn.has('_multipleBirthInteger') then
      result.multipleBirth := parseInteger(jsn.node['multipleBirthInteger'], jsn.vObj['_multipleBirthInteger']);
    if jsn.has('photo') then
      iterateArray(jsn.vArr['photo'], result.photoList, parseAttachment);
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parsePatientContact);
    if jsn.has('communication') then
      iterateArray(jsn.vArr['communication'], result.communicationList, parsePatientCommunication);
    if jsn.has('generalPractitioner') then
      iterateArray(jsn.vArr['generalPractitioner'], result.generalPractitionerList, parseReference{TFhirOrganization});
    if jsn.has('managingOrganization') then
        result.managingOrganization := ParseReference{TFhirOrganization}(jsn.vObj['managingOrganization']);{q3}
    if jsn.has('link') then
      iterateArray(jsn.vArr['link'], result.link_List, parsePatientLink);
end;

procedure TFHIRJsonComposer.ComposePatient(json : TJSONWriter; name : string; elem : TFhirPatient; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('active') then
    ComposeBooleanValue(json, 'active', elem.activeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('active') then
    ComposeBooleanProps(json, 'active', elem.activeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') and (elem.nameList.Count > 0) then
  begin
    json.valueArray('name');
    for i := 0 to elem.nameList.Count - 1 do
      ComposeHumanName(json, '', elem.nameList[i]); {z - HumanName}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('telecom') and (elem.telecomList.Count > 0) then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '', elem.telecomList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('gender') then
    ComposeEnumValue(json, 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('gender') then
    ComposeEnumProps(json, 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('birthDate') then
    ComposeDateValue(json, 'birthDate', elem.birthDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('birthDate') then
    ComposeDateProps(json, 'birthDate', elem.birthDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.deceased is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'deceasedBoolean', TFhirBoolean(elem.deceased), false);
    ComposeBooleanProps(json, 'deceasedBoolean', TFhirBoolean(elem.deceased), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.deceased is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'deceasedDateTime', TFhirDateTime(elem.deceased), false);
    ComposeDateTimeProps(json, 'deceasedDateTime', TFhirDateTime(elem.deceased), false);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('address') and (elem.addressList.Count > 0) then
  begin
    json.valueArray('address');
    for i := 0 to elem.addressList.Count - 1 do
      ComposeAddress(json, '', elem.addressList[i]); {z - Address}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('maritalStatus') then
    ComposeCodeableConcept(json, 'maritalStatus', elem.maritalStatus); {a}
  if (SummaryOption in [soFull, soData]) and (elem.multipleBirth is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'multipleBirthBoolean', TFhirBoolean(elem.multipleBirth), false);
    ComposeBooleanProps(json, 'multipleBirthBoolean', TFhirBoolean(elem.multipleBirth), false);
  end
  else if (SummaryOption in [soFull, soData]) and (elem.multipleBirth is TFhirInteger) then 
  begin
    ComposeIntegerValue(json, 'multipleBirthInteger', TFhirInteger(elem.multipleBirth), false);
    ComposeIntegerProps(json, 'multipleBirthInteger', TFhirInteger(elem.multipleBirth), false);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('photo') and (elem.photoList.Count > 0) then
  begin
    json.valueArray('photo');
    for i := 0 to elem.photoList.Count - 1 do
      ComposeAttachment(json, '', elem.photoList[i]); {z - Attachment}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('contact') and (elem.contactList.Count > 0) then
  begin
    json.valueArray('contact');
    for i := 0 to elem.contactList.Count - 1 do
      ComposePatientContact(json, '', elem.contactList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('communication') and (elem.communicationList.Count > 0) then
  begin
    json.valueArray('communication');
    for i := 0 to elem.communicationList.Count - 1 do
      ComposePatientCommunication(json, '', elem.communicationList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('generalPractitioner') and (elem.generalPractitionerList.Count > 0) then
  begin
    json.valueArray('generalPractitioner');
    for i := 0 to elem.generalPractitionerList.Count - 1 do
      ComposeReference{TFhirOrganization}(json, '', elem.generalPractitionerList[i]); {z - Reference(Organization)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('managingOrganization') then
    ComposeReference{TFhirOrganization}(json, 'managingOrganization', elem.managingOrganization); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('link_') and (elem.link_List.Count > 0) then
  begin
    json.valueArray('link');
    for i := 0 to elem.link_List.Count - 1 do
      ComposePatientLink(json, '', elem.link_List[i]); {z - }
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_PATIENT}
{$IFDEF FHIR_PAYMENTNOTICE}
procedure TFHIRJsonParser.ParsePaymentNotice(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePaymentNotice(jsn)); {2}
end;

function TFHIRJsonParser.ParsePaymentNotice(jsn : TJsonObject) : TFhirPaymentNotice;
begin
  result := TFhirPaymentNotice.create;
  try
    ParsePaymentNoticeProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParsePaymentNoticeProperties(jsn : TJsonObject; result : TFhirPaymentNotice);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirFmStatusEnum, SYSTEMS_TFhirFmStatusEnum);
    if jsn.has('request') then
        result.request := ParseReference{TFhirReference}(jsn.vObj['request']);{q3}
    if jsn.has('response') then
        result.response := ParseReference{TFhirReference}(jsn.vObj['response']);{q3}
    if jsn.has('created') or jsn.has('_created') then
        result.createdElement := parseDateTime(jsn.node['created'], jsn.vObj['_created']);{q}
    if jsn.has('provider') then
        result.provider := ParseReference{TFhirPractitioner}(jsn.vObj['provider']);{q3}
    if jsn.has('payment') then
        result.payment := ParseReference{TFhirPaymentReconciliation}(jsn.vObj['payment']);{q3}
    if jsn.has('paymentDate') or jsn.has('_paymentDate') then
        result.paymentDateElement := parseDate(jsn.node['paymentDate'], jsn.vObj['_paymentDate']);{q}
    if jsn.has('payee') then
        result.payee := ParseReference{TFhirPractitioner}(jsn.vObj['payee']);{q3}
    if jsn.has('recipient') then
        result.recipient := ParseReference{TFhirOrganization}(jsn.vObj['recipient']);{q3}
    if jsn.has('amount') then
        result.amount := ParseMoney(jsn.vObj['amount']);{q3}
    if jsn.has('paymentStatus') then
        result.paymentStatus := ParseCodeableConcept(jsn.vObj['paymentStatus']);{q3}
end;

procedure TFHIRJsonComposer.ComposePaymentNotice(json : TJSONWriter; name : string; elem : TFhirPaymentNotice; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirFmStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirFmStatusEnum, false);
  if (SummaryOption in [soFull, soData]) and doCompose('request') then
    ComposeReference{TFhirReference}(json, 'request', elem.request); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('response') then
    ComposeReference{TFhirReference}(json, 'response', elem.response); {a}
    ComposeDateTimeValue(json, 'created', elem.createdElement, false);
    ComposeDateTimeProps(json, 'created', elem.createdElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('provider') then
    ComposeReference{TFhirPractitioner}(json, 'provider', elem.provider); {a}
  ComposeReference{TFhirPaymentReconciliation}(json, 'payment', elem.payment); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('paymentDate') then
    ComposeDateValue(json, 'paymentDate', elem.paymentDateElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('paymentDate') then
    ComposeDateProps(json, 'paymentDate', elem.paymentDateElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('payee') then
    ComposeReference{TFhirPractitioner}(json, 'payee', elem.payee); {a}
  ComposeReference{TFhirOrganization}(json, 'recipient', elem.recipient); {a}
  ComposeMoney(json, 'amount', elem.amount); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('paymentStatus') then
    ComposeCodeableConcept(json, 'paymentStatus', elem.paymentStatus); {a}
end;

{$ENDIF FHIR_PAYMENTNOTICE}
{$IFDEF FHIR_PAYMENTRECONCILIATION}
procedure TFHIRJsonParser.ParsePaymentReconciliationDetail(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePaymentReconciliationDetail(jsn)); {2}
end;

function TFHIRJsonParser.ParsePaymentReconciliationDetail(jsn : TJsonObject) : TFhirPaymentReconciliationDetail;
begin
  result := TFhirPaymentReconciliationDetail.create;
  try
    ParsePaymentReconciliationDetailProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParsePaymentReconciliationDetailProperties(jsn : TJsonObject; result : TFhirPaymentReconciliationDetail);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q3}
    if jsn.has('predecessor') then
        result.predecessor := ParseIdentifier(jsn.vObj['predecessor']);{q3}
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('request') then
        result.request := ParseReference{TFhirReference}(jsn.vObj['request']);{q3}
    if jsn.has('submitter') then
        result.submitter := ParseReference{TFhirPractitioner}(jsn.vObj['submitter']);{q3}
    if jsn.has('response') then
        result.response := ParseReference{TFhirReference}(jsn.vObj['response']);{q3}
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := parseDate(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('responsible') then
        result.responsible := ParseReference{TFhirPractitionerRole}(jsn.vObj['responsible']);{q3}
    if jsn.has('payee') then
        result.payee := ParseReference{TFhirPractitioner}(jsn.vObj['payee']);{q3}
    if jsn.has('amount') then
        result.amount := ParseMoney(jsn.vObj['amount']);{q3}
end;

procedure TFHIRJsonComposer.ComposePaymentReconciliationDetail(json : TJSONWriter; name : string; elem : TFhirPaymentReconciliationDetail; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(json, 'predecessor', elem.predecessor); {a}
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirReference}(json, 'request', elem.request); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirPractitioner}(json, 'submitter', elem.submitter); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirReference}(json, 'response', elem.response); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeDateValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirPractitionerRole}(json, 'responsible', elem.responsible); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirPractitioner}(json, 'payee', elem.payee); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeMoney(json, 'amount', elem.amount); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParsePaymentReconciliationProcessNote(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePaymentReconciliationProcessNote(jsn)); {2}
end;

function TFHIRJsonParser.ParsePaymentReconciliationProcessNote(jsn : TJsonObject) : TFhirPaymentReconciliationProcessNote;
begin
  result := TFhirPaymentReconciliationProcessNote.create;
  try
    ParsePaymentReconciliationProcessNoteProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParsePaymentReconciliationProcessNoteProperties(jsn : TJsonObject; result : TFhirPaymentReconciliationProcessNote);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn.node['type'], jsn.vObj['_type'], CODES_TFhirNoteTypeEnum, SYSTEMS_TFhirNoteTypeEnum);
    if jsn.has('text') or jsn.has('_text') then
        result.textElement := parseString(jsn.node['text'], jsn.vObj['_text']);{q}
end;

procedure TFHIRJsonComposer.ComposePaymentReconciliationProcessNote(json : TJSONWriter; name : string; elem : TFhirPaymentReconciliationProcessNote; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirNoteTypeEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirNoteTypeEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'text', elem.textElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParsePaymentReconciliation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePaymentReconciliation(jsn)); {2}
end;

function TFHIRJsonParser.ParsePaymentReconciliation(jsn : TJsonObject) : TFhirPaymentReconciliation;
begin
  result := TFhirPaymentReconciliation.create;
  try
    ParsePaymentReconciliationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParsePaymentReconciliationProperties(jsn : TJsonObject; result : TFhirPaymentReconciliation);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirFmStatusEnum, SYSTEMS_TFhirFmStatusEnum);
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q3}
    if jsn.has('created') or jsn.has('_created') then
        result.createdElement := parseDateTime(jsn.node['created'], jsn.vObj['_created']);{q}
    if jsn.has('paymentIssuer') then
        result.paymentIssuer := ParseReference{TFhirOrganization}(jsn.vObj['paymentIssuer']);{q3}
    if jsn.has('request') then
        result.request := ParseReference{TFhirTask}(jsn.vObj['request']);{q3}
    if jsn.has('requestor') then
        result.requestor := ParseReference{TFhirPractitioner}(jsn.vObj['requestor']);{q3}
    if jsn.has('outcome') or jsn.has('_outcome')  then
      result.outcomeElement := parseEnum(jsn.path+'/outcome', jsn.node['outcome'], jsn.vObj['_outcome'], CODES_TFhirRemittanceOutcomeEnum, SYSTEMS_TFhirRemittanceOutcomeEnum);
    if jsn.has('disposition') or jsn.has('_disposition') then
        result.dispositionElement := parseString(jsn.node['disposition'], jsn.vObj['_disposition']);{q}
    if jsn.has('paymentDate') or jsn.has('_paymentDate') then
        result.paymentDateElement := parseDate(jsn.node['paymentDate'], jsn.vObj['_paymentDate']);{q}
    if jsn.has('paymentAmount') then
        result.paymentAmount := ParseMoney(jsn.vObj['paymentAmount']);{q3}
    if jsn.has('paymentIdentifier') then
        result.paymentIdentifier := ParseIdentifier(jsn.vObj['paymentIdentifier']);{q3}
    if jsn.has('detail') then
      iterateArray(jsn.vArr['detail'], result.detailList, parsePaymentReconciliationDetail);
    if jsn.has('formCode') then
        result.formCode := ParseCodeableConcept(jsn.vObj['formCode']);{q3}
    if jsn.has('processNote') then
      iterateArray(jsn.vArr['processNote'], result.processNoteList, parsePaymentReconciliationProcessNote);
end;

procedure TFHIRJsonComposer.ComposePaymentReconciliation(json : TJSONWriter; name : string; elem : TFhirPaymentReconciliation; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirFmStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirFmStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('period') then
    ComposePeriod(json, 'period', elem.period); {a}
    ComposeDateTimeValue(json, 'created', elem.createdElement, false);
    ComposeDateTimeProps(json, 'created', elem.createdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('paymentIssuer') then
    ComposeReference{TFhirOrganization}(json, 'paymentIssuer', elem.paymentIssuer); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('request') then
    ComposeReference{TFhirTask}(json, 'request', elem.request); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('requestor') then
    ComposeReference{TFhirPractitioner}(json, 'requestor', elem.requestor); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('outcome') then
    ComposeEnumValue(json, 'outcome', elem.OutcomeElement, CODES_TFhirRemittanceOutcomeEnum, false);
  if (SummaryOption in [soFull, soData]) and doCompose('outcome') then
    ComposeEnumProps(json, 'outcome', elem.OutcomeElement, CODES_TFhirRemittanceOutcomeEnum, false);
  if (SummaryOption in [soFull, soData]) and doCompose('disposition') then
    ComposeStringValue(json, 'disposition', elem.dispositionElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('disposition') then
    ComposeStringProps(json, 'disposition', elem.dispositionElement, false);
  ComposeDateValue(json, 'paymentDate', elem.paymentDateElement, false);
  ComposeDateProps(json, 'paymentDate', elem.paymentDateElement, false);
  ComposeMoney(json, 'paymentAmount', elem.paymentAmount); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('paymentIdentifier') then
    ComposeIdentifier(json, 'paymentIdentifier', elem.paymentIdentifier); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('detail') and (elem.detailList.Count > 0) then
  begin
    json.valueArray('detail');
    for i := 0 to elem.detailList.Count - 1 do
      ComposePaymentReconciliationDetail(json, '', elem.detailList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('formCode') then
    ComposeCodeableConcept(json, 'formCode', elem.formCode); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('processNote') and (elem.processNoteList.Count > 0) then
  begin
    json.valueArray('processNote');
    for i := 0 to elem.processNoteList.Count - 1 do
      ComposePaymentReconciliationProcessNote(json, '', elem.processNoteList[i]); {z - }
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_PAYMENTRECONCILIATION}
{$IFDEF FHIR_PERSON}
procedure TFHIRJsonParser.ParsePersonLink(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePersonLink(jsn)); {2}
end;

function TFHIRJsonParser.ParsePersonLink(jsn : TJsonObject) : TFhirPersonLink;
begin
  result := TFhirPersonLink.create;
  try
    ParsePersonLinkProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParsePersonLinkProperties(jsn : TJsonObject; result : TFhirPersonLink);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('target') then
        result.target := ParseReference{TFhirPatient}(jsn.vObj['target']);{q3}
    if jsn.has('assurance') or jsn.has('_assurance')  then
      result.assuranceElement := parseEnum(jsn.path+'/assurance', jsn.node['assurance'], jsn.vObj['_assurance'], CODES_TFhirIdentityAssuranceLevelEnum, SYSTEMS_TFhirIdentityAssuranceLevelEnum);
end;

procedure TFHIRJsonComposer.ComposePersonLink(json : TJSONWriter; name : string; elem : TFhirPersonLink; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeReference{TFhirPatient}(json, 'target', elem.target); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumValue(json, 'assurance', elem.AssuranceElement, CODES_TFhirIdentityAssuranceLevelEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumProps(json, 'assurance', elem.AssuranceElement, CODES_TFhirIdentityAssuranceLevelEnum, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParsePerson(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePerson(jsn)); {2}
end;

function TFHIRJsonParser.ParsePerson(jsn : TJsonObject) : TFhirPerson;
begin
  result := TFhirPerson.create;
  try
    ParsePersonProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParsePersonProperties(jsn : TJsonObject; result : TFhirPerson);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('name') then
      iterateArray(jsn.vArr['name'], result.nameList, parseHumanName);
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    if jsn.has('gender') or jsn.has('_gender')  then
      result.genderElement := parseEnum(jsn.path+'/gender', jsn.node['gender'], jsn.vObj['_gender'], CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum);
    if jsn.has('birthDate') or jsn.has('_birthDate') then
        result.birthDateElement := parseDate(jsn.node['birthDate'], jsn.vObj['_birthDate']);{q}
    if jsn.has('address') then
      iterateArray(jsn.vArr['address'], result.addressList, parseAddress);
    if jsn.has('photo') then
        result.photo := ParseAttachment(jsn.vObj['photo']);{q3}
    if jsn.has('managingOrganization') then
        result.managingOrganization := ParseReference{TFhirOrganization}(jsn.vObj['managingOrganization']);{q3}
    if jsn.has('active') or jsn.has('_active') then
        result.activeElement := parseBoolean(jsn.node['active'], jsn.vObj['_active']);{q}
    if jsn.has('link') then
      iterateArray(jsn.vArr['link'], result.link_List, parsePersonLink);
end;

procedure TFHIRJsonComposer.ComposePerson(json : TJSONWriter; name : string; elem : TFhirPerson; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') and (elem.nameList.Count > 0) then
  begin
    json.valueArray('name');
    for i := 0 to elem.nameList.Count - 1 do
      ComposeHumanName(json, '', elem.nameList[i]); {z - HumanName}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('telecom') and (elem.telecomList.Count > 0) then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '', elem.telecomList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('gender') then
    ComposeEnumValue(json, 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('gender') then
    ComposeEnumProps(json, 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('birthDate') then
    ComposeDateValue(json, 'birthDate', elem.birthDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('birthDate') then
    ComposeDateProps(json, 'birthDate', elem.birthDateElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('address') and (elem.addressList.Count > 0) then
  begin
    json.valueArray('address');
    for i := 0 to elem.addressList.Count - 1 do
      ComposeAddress(json, '', elem.addressList[i]); {z - Address}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('photo') then
    ComposeAttachment(json, 'photo', elem.photo); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('managingOrganization') then
    ComposeReference{TFhirOrganization}(json, 'managingOrganization', elem.managingOrganization); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('active') then
    ComposeBooleanValue(json, 'active', elem.activeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('active') then
    ComposeBooleanProps(json, 'active', elem.activeElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('link_') and (elem.link_List.Count > 0) then
  begin
    json.valueArray('link');
    for i := 0 to elem.link_List.Count - 1 do
      ComposePersonLink(json, '', elem.link_List[i]); {z - }
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_PERSON}
{$IFDEF FHIR_PLANDEFINITION}
procedure TFHIRJsonParser.ParsePlanDefinitionGoal(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePlanDefinitionGoal(jsn)); {2}
end;

function TFHIRJsonParser.ParsePlanDefinitionGoal(jsn : TJsonObject) : TFhirPlanDefinitionGoal;
begin
  result := TFhirPlanDefinitionGoal.create;
  try
    ParsePlanDefinitionGoalProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParsePlanDefinitionGoalProperties(jsn : TJsonObject; result : TFhirPlanDefinitionGoal);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('category') then
        result.category := ParseCodeableConcept(jsn.vObj['category']);{q3}
    if jsn.has('description') then
        result.description := ParseCodeableConcept(jsn.vObj['description']);{q3}
    if jsn.has('priority') then
        result.priority := ParseCodeableConcept(jsn.vObj['priority']);{q3}
    if jsn.has('start') then
        result.start := ParseCodeableConcept(jsn.vObj['start']);{q3}
    if jsn.has('addresses') then
      iterateArray(jsn.vArr['addresses'], result.addressesList, parseCodeableConcept);
    if jsn.has('documentation') then
      iterateArray(jsn.vArr['documentation'], result.documentationList, parseRelatedArtifact);
    if jsn.has('target') then
      iterateArray(jsn.vArr['target'], result.targetList, parsePlanDefinitionGoalTarget);
end;

procedure TFHIRJsonComposer.ComposePlanDefinitionGoal(json : TJSONWriter; name : string; elem : TFhirPlanDefinitionGoal; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'category', elem.category); {a}
  ComposeCodeableConcept(json, 'description', elem.description); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'priority', elem.priority); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'start', elem.start); {a}
  if (SummaryOption in [soFull, soData]) and (elem.addressesList.Count > 0) then
  begin
    json.valueArray('addresses');
    for i := 0 to elem.addressesList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.addressesList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.documentationList.Count > 0) then
  begin
    json.valueArray('documentation');
    for i := 0 to elem.documentationList.Count - 1 do
      ComposeRelatedArtifact(json, '', elem.documentationList[i]); {z - RelatedArtifact}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.targetList.Count > 0) then
  begin
    json.valueArray('target');
    for i := 0 to elem.targetList.Count - 1 do
      ComposePlanDefinitionGoalTarget(json, '', elem.targetList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParsePlanDefinitionGoalTarget(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePlanDefinitionGoalTarget(jsn)); {2}
end;

function TFHIRJsonParser.ParsePlanDefinitionGoalTarget(jsn : TJsonObject) : TFhirPlanDefinitionGoalTarget;
begin
  result := TFhirPlanDefinitionGoalTarget.create;
  try
    ParsePlanDefinitionGoalTargetProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParsePlanDefinitionGoalTargetProperties(jsn : TJsonObject; result : TFhirPlanDefinitionGoalTarget);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('measure') then
        result.measure := ParseCodeableConcept(jsn.vObj['measure']);{q3}
    if jsn.has('detailQuantity') {a4} then
      result.detail := ParseQuantity(jsn.vObj['detailQuantity']);
    if jsn.has('detailRange') {a4} then
      result.detail := ParseRange(jsn.vObj['detailRange']);
    if jsn.has('detailCodeableConcept') {a4} then
      result.detail := ParseCodeableConcept(jsn.vObj['detailCodeableConcept']);
    if jsn.has('due') then
        result.due := ParseDuration(jsn.vObj['due']);{q3}
end;

procedure TFHIRJsonComposer.ComposePlanDefinitionGoalTarget(json : TJSONWriter; name : string; elem : TFhirPlanDefinitionGoalTarget; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'measure', elem.measure); {a}
  if (SummaryOption in [soFull, soData]) and (elem.detail is TFhirQuantity) then 
    ComposeQuantity(json, 'detailQuantity', TFhirQuantity(elem.detail)) 
  else if (SummaryOption in [soFull, soData]) and (elem.detail is TFhirRange) then 
    ComposeRange(json, 'detailRange', TFhirRange(elem.detail)) 
  else if (SummaryOption in [soFull, soData]) and (elem.detail is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'detailCodeableConcept', TFhirCodeableConcept(elem.detail)) ;
  if (SummaryOption in [soFull, soData]) then
    ComposeDuration(json, 'due', elem.due); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParsePlanDefinitionAction(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePlanDefinitionAction(jsn)); {2}
end;

function TFHIRJsonParser.ParsePlanDefinitionAction(jsn : TJsonObject) : TFhirPlanDefinitionAction;
begin
  result := TFhirPlanDefinitionAction.create;
  try
    ParsePlanDefinitionActionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParsePlanDefinitionActionProperties(jsn : TJsonObject; result : TFhirPlanDefinitionAction);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('prefix') or jsn.has('_prefix') then
        result.prefixElement := parseString(jsn.node['prefix'], jsn.vObj['_prefix']);{q}
    if jsn.has('title') or jsn.has('_title') then
        result.titleElement := parseString(jsn.node['title'], jsn.vObj['_title']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('textEquivalent') or jsn.has('_textEquivalent') then
        result.textEquivalentElement := parseString(jsn.node['textEquivalent'], jsn.vObj['_textEquivalent']);{q}
    if jsn.has('priority') or jsn.has('_priority')  then
      result.priorityElement := parseEnum(jsn.path+'/priority', jsn.node['priority'], jsn.vObj['_priority'], CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum);
    if jsn.has('code') then
      iterateArray(jsn.vArr['code'], result.codeList, parseCodeableConcept);
    if jsn.has('reason') then
      iterateArray(jsn.vArr['reason'], result.reasonList, parseCodeableConcept);
    if jsn.has('documentation') then
      iterateArray(jsn.vArr['documentation'], result.documentationList, parseRelatedArtifact);
      if jsn.has('goalId') or jsn.has('_goalId') then
      iteratePrimitiveArray(jsn.vArr['goalId'], jsn.vArr['_goalId'], result.goalIdList, parseId);
    if jsn.has('subjectCodeableConcept') {a4} then
      result.subject := ParseCodeableConcept(jsn.vObj['subjectCodeableConcept']);
    if jsn.has('subjectReference') {a3} then
      result.subject := ParseReference(jsn.vObj['subjectReference']);
    if jsn.has('trigger') then
      iterateArray(jsn.vArr['trigger'], result.triggerList, parseTriggerDefinition);
    if jsn.has('condition') then
      iterateArray(jsn.vArr['condition'], result.conditionList, parsePlanDefinitionActionCondition);
    if jsn.has('input') then
      iterateArray(jsn.vArr['input'], result.inputList, parseDataRequirement);
    if jsn.has('output') then
      iterateArray(jsn.vArr['output'], result.outputList, parseDataRequirement);
    if jsn.has('relatedAction') then
      iterateArray(jsn.vArr['relatedAction'], result.relatedActionList, parsePlanDefinitionActionRelatedAction);
    if jsn.has('timingAge') {a4} then
      result.timing := ParseAge(jsn.vObj['timingAge']);
    if jsn.has('timingPeriod') {a4} then
      result.timing := ParsePeriod(jsn.vObj['timingPeriod']);
    if jsn.has('timingDuration') {a4} then
      result.timing := ParseDuration(jsn.vObj['timingDuration']);
    if jsn.has('timingRange') {a4} then
      result.timing := ParseRange(jsn.vObj['timingRange']);
    if jsn.has('timingTiming') {a4} then
      result.timing := ParseTiming(jsn.vObj['timingTiming']);
    if jsn.has('timingDateTime') or jsn.has('_timingDateTime') then
      result.timing := parseDateTime(jsn.node['timingDateTime'], jsn.vObj['_timingDateTime']);
    if jsn.has('participant') then
      iterateArray(jsn.vArr['participant'], result.participantList, parsePlanDefinitionActionParticipant);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('groupingBehavior') or jsn.has('_groupingBehavior')  then
      result.groupingBehaviorElement := parseEnum(jsn.path+'/groupingBehavior', jsn.node['groupingBehavior'], jsn.vObj['_groupingBehavior'], CODES_TFhirActionGroupingBehaviorEnum, SYSTEMS_TFhirActionGroupingBehaviorEnum);
    if jsn.has('selectionBehavior') or jsn.has('_selectionBehavior')  then
      result.selectionBehaviorElement := parseEnum(jsn.path+'/selectionBehavior', jsn.node['selectionBehavior'], jsn.vObj['_selectionBehavior'], CODES_TFhirActionSelectionBehaviorEnum, SYSTEMS_TFhirActionSelectionBehaviorEnum);
    if jsn.has('requiredBehavior') or jsn.has('_requiredBehavior')  then
      result.requiredBehaviorElement := parseEnum(jsn.path+'/requiredBehavior', jsn.node['requiredBehavior'], jsn.vObj['_requiredBehavior'], CODES_TFhirActionRequiredBehaviorEnum, SYSTEMS_TFhirActionRequiredBehaviorEnum);
    if jsn.has('precheckBehavior') or jsn.has('_precheckBehavior')  then
      result.precheckBehaviorElement := parseEnum(jsn.path+'/precheckBehavior', jsn.node['precheckBehavior'], jsn.vObj['_precheckBehavior'], CODES_TFhirActionPrecheckBehaviorEnum, SYSTEMS_TFhirActionPrecheckBehaviorEnum);
    if jsn.has('cardinalityBehavior') or jsn.has('_cardinalityBehavior')  then
      result.cardinalityBehaviorElement := parseEnum(jsn.path+'/cardinalityBehavior', jsn.node['cardinalityBehavior'], jsn.vObj['_cardinalityBehavior'], CODES_TFhirActionCardinalityBehaviorEnum, SYSTEMS_TFhirActionCardinalityBehaviorEnum);
    if jsn.has('definitionCanonical') or jsn.has('_definitionCanonical') then
      result.definition := parseCanonical(jsn.node['definitionCanonical'], jsn.vObj['_definitionCanonical']);
    if jsn.has('definitionUri') or jsn.has('_definitionUri') then
      result.definition := parseUri(jsn.node['definitionUri'], jsn.vObj['_definitionUri']);
    if jsn.has('transform') or jsn.has('_transform') then
        result.transformElement := parseCanonical(jsn.node['transform'], jsn.vObj['_transform']);{q}
    if jsn.has('dynamicValue') then
      iterateArray(jsn.vArr['dynamicValue'], result.dynamicValueList, parsePlanDefinitionActionDynamicValue);
    if jsn.has('action') then
      iterateArray(jsn.vArr['action'], result.actionList, parsePlanDefinitionAction);
end;

procedure TFHIRJsonComposer.ComposePlanDefinitionAction(json : TJSONWriter; name : string; elem : TFhirPlanDefinitionAction; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'prefix', elem.prefixElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'prefix', elem.prefixElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'textEquivalent', elem.textEquivalentElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'textEquivalent', elem.textEquivalentElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumValue(json, 'priority', elem.PriorityElement, CODES_TFhirRequestPriorityEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumProps(json, 'priority', elem.PriorityElement, CODES_TFhirRequestPriorityEnum, false);
  if (SummaryOption in [soFull, soData]) and (elem.codeList.Count > 0) then
  begin
    json.valueArray('code');
    for i := 0 to elem.codeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.codeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.reasonList.Count > 0) then
  begin
    json.valueArray('reason');
    for i := 0 to elem.reasonList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.reasonList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.documentationList.Count > 0) then
  begin
    json.valueArray('documentation');
    for i := 0 to elem.documentationList.Count - 1 do
      ComposeRelatedArtifact(json, '', elem.documentationList[i]); {z - RelatedArtifact}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.goalIdList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.goalIdList.Count - 1 do
    begin
      ext := ext or ((elem.goalIdList[i].id <> '') or (elem.goalIdList[i].hasExtensionList) {no-comments or (elem.goalIdList[i].hasComments)});
      val := val or (elem.goalIdList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('goalId');
      for i := 0 to elem.goalIdList.Count - 1 do
        ComposeIdValue(json, '',elem.goalIdList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_goalId');
      for i := 0 to elem.goalIdList.Count - 1 do
        ComposeIdProps(json, '',elem.goalIdList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.subject is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'subjectCodeableConcept', TFhirCodeableConcept(elem.subject)) 
  else if (SummaryOption in [soFull, soData]) and (elem.subject is TFhirReference) then
    ComposeReference(json, 'subjectReference', TFhirReference(elem.subject));
  if (SummaryOption in [soFull, soData]) and (elem.triggerList.Count > 0) then
  begin
    json.valueArray('trigger');
    for i := 0 to elem.triggerList.Count - 1 do
      ComposeTriggerDefinition(json, '', elem.triggerList[i]); {z - TriggerDefinition}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.conditionList.Count > 0) then
  begin
    json.valueArray('condition');
    for i := 0 to elem.conditionList.Count - 1 do
      ComposePlanDefinitionActionCondition(json, '', elem.conditionList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.inputList.Count > 0) then
  begin
    json.valueArray('input');
    for i := 0 to elem.inputList.Count - 1 do
      ComposeDataRequirement(json, '', elem.inputList[i]); {z - DataRequirement}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.outputList.Count > 0) then
  begin
    json.valueArray('output');
    for i := 0 to elem.outputList.Count - 1 do
      ComposeDataRequirement(json, '', elem.outputList[i]); {z - DataRequirement}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.relatedActionList.Count > 0) then
  begin
    json.valueArray('relatedAction');
    for i := 0 to elem.relatedActionList.Count - 1 do
      ComposePlanDefinitionActionRelatedAction(json, '', elem.relatedActionList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirAge) then 
    ComposeAge(json, 'timingAge', TFhirAge(elem.timing)) 
  else if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirPeriod) then 
    ComposePeriod(json, 'timingPeriod', TFhirPeriod(elem.timing)) 
  else if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirDuration) then 
    ComposeDuration(json, 'timingDuration', TFhirDuration(elem.timing)) 
  else if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirRange) then 
    ComposeRange(json, 'timingRange', TFhirRange(elem.timing)) 
  else if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirTiming) then 
    ComposeTiming(json, 'timingTiming', TFhirTiming(elem.timing)) 
  else if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'timingDateTime', TFhirDateTime(elem.timing), false);
    ComposeDateTimeProps(json, 'timingDateTime', TFhirDateTime(elem.timing), false);
  end;
  if (SummaryOption in [soFull, soData]) and (elem.participantList.Count > 0) then
  begin
    json.valueArray('participant');
    for i := 0 to elem.participantList.Count - 1 do
      ComposePlanDefinitionActionParticipant(json, '', elem.participantList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumValue(json, 'groupingBehavior', elem.GroupingBehaviorElement, CODES_TFhirActionGroupingBehaviorEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumProps(json, 'groupingBehavior', elem.GroupingBehaviorElement, CODES_TFhirActionGroupingBehaviorEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumValue(json, 'selectionBehavior', elem.SelectionBehaviorElement, CODES_TFhirActionSelectionBehaviorEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumProps(json, 'selectionBehavior', elem.SelectionBehaviorElement, CODES_TFhirActionSelectionBehaviorEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumValue(json, 'requiredBehavior', elem.RequiredBehaviorElement, CODES_TFhirActionRequiredBehaviorEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumProps(json, 'requiredBehavior', elem.RequiredBehaviorElement, CODES_TFhirActionRequiredBehaviorEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumValue(json, 'precheckBehavior', elem.PrecheckBehaviorElement, CODES_TFhirActionPrecheckBehaviorEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumProps(json, 'precheckBehavior', elem.PrecheckBehaviorElement, CODES_TFhirActionPrecheckBehaviorEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumValue(json, 'cardinalityBehavior', elem.CardinalityBehaviorElement, CODES_TFhirActionCardinalityBehaviorEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumProps(json, 'cardinalityBehavior', elem.CardinalityBehaviorElement, CODES_TFhirActionCardinalityBehaviorEnum, false);
  if (SummaryOption in [soFull, soData]) and (elem.definition is TFhirCanonical) then 
  begin
    ComposeCanonicalValue(json, 'definitionCanonical', TFhirCanonical(elem.definition), false);
    ComposeCanonicalProps(json, 'definitionCanonical', TFhirCanonical(elem.definition), false);
  end
  else if (SummaryOption in [soFull, soData]) and (elem.definition is TFhirUri) then 
  begin
    ComposeUriValue(json, 'definitionUri', TFhirUri(elem.definition), false);
    ComposeUriProps(json, 'definitionUri', TFhirUri(elem.definition), false);
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonicalValue(json, 'transform', elem.transformElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonicalProps(json, 'transform', elem.transformElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.dynamicValueList.Count > 0) then
  begin
    json.valueArray('dynamicValue');
    for i := 0 to elem.dynamicValueList.Count - 1 do
      ComposePlanDefinitionActionDynamicValue(json, '', elem.dynamicValueList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.actionList.Count > 0) then
  begin
    json.valueArray('action');
    for i := 0 to elem.actionList.Count - 1 do
      ComposePlanDefinitionAction(json, '', elem.actionList[i]); {z - @PlanDefinition.action}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParsePlanDefinitionActionCondition(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePlanDefinitionActionCondition(jsn)); {2}
end;

function TFHIRJsonParser.ParsePlanDefinitionActionCondition(jsn : TJsonObject) : TFhirPlanDefinitionActionCondition;
begin
  result := TFhirPlanDefinitionActionCondition.create;
  try
    ParsePlanDefinitionActionConditionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParsePlanDefinitionActionConditionProperties(jsn : TJsonObject; result : TFhirPlanDefinitionActionCondition);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('kind') or jsn.has('_kind')  then
      result.kindElement := parseEnum(jsn.path+'/kind', jsn.node['kind'], jsn.vObj['_kind'], CODES_TFhirActionConditionKindEnum, SYSTEMS_TFhirActionConditionKindEnum);
    if jsn.has('expression') then
        result.expression := ParseExpression(jsn.vObj['expression']);{q3}
end;

procedure TFHIRJsonComposer.ComposePlanDefinitionActionCondition(json : TJSONWriter; name : string; elem : TFhirPlanDefinitionActionCondition; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'kind', elem.KindElement, CODES_TFhirActionConditionKindEnum, false);
  ComposeEnumProps(json, 'kind', elem.KindElement, CODES_TFhirActionConditionKindEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeExpression(json, 'expression', elem.expression); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParsePlanDefinitionActionRelatedAction(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePlanDefinitionActionRelatedAction(jsn)); {2}
end;

function TFHIRJsonParser.ParsePlanDefinitionActionRelatedAction(jsn : TJsonObject) : TFhirPlanDefinitionActionRelatedAction;
begin
  result := TFhirPlanDefinitionActionRelatedAction.create;
  try
    ParsePlanDefinitionActionRelatedActionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParsePlanDefinitionActionRelatedActionProperties(jsn : TJsonObject; result : TFhirPlanDefinitionActionRelatedAction);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('actionId') or jsn.has('_actionId') then
        result.actionIdElement := parseId(jsn.node['actionId'], jsn.vObj['_actionId']);{q}
    if jsn.has('relationship') or jsn.has('_relationship')  then
      result.relationshipElement := parseEnum(jsn.path+'/relationship', jsn.node['relationship'], jsn.vObj['_relationship'], CODES_TFhirActionRelationshipTypeEnum, SYSTEMS_TFhirActionRelationshipTypeEnum);
    if jsn.has('offsetDuration') {a4} then
      result.offset := ParseDuration(jsn.vObj['offsetDuration']);
    if jsn.has('offsetRange') {a4} then
      result.offset := ParseRange(jsn.vObj['offsetRange']);
end;

procedure TFHIRJsonComposer.ComposePlanDefinitionActionRelatedAction(json : TJSONWriter; name : string; elem : TFhirPlanDefinitionActionRelatedAction; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeIdValue(json, 'actionId', elem.actionIdElement, false);
  ComposeIdProps(json, 'actionId', elem.actionIdElement, false);
  ComposeEnumValue(json, 'relationship', elem.RelationshipElement, CODES_TFhirActionRelationshipTypeEnum, false);
  ComposeEnumProps(json, 'relationship', elem.RelationshipElement, CODES_TFhirActionRelationshipTypeEnum, false);
  if (SummaryOption in [soFull, soData]) and (elem.offset is TFhirDuration) then 
    ComposeDuration(json, 'offsetDuration', TFhirDuration(elem.offset)) 
  else if (SummaryOption in [soFull, soData]) and (elem.offset is TFhirRange) then 
    ComposeRange(json, 'offsetRange', TFhirRange(elem.offset)) ;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParsePlanDefinitionActionParticipant(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePlanDefinitionActionParticipant(jsn)); {2}
end;

function TFHIRJsonParser.ParsePlanDefinitionActionParticipant(jsn : TJsonObject) : TFhirPlanDefinitionActionParticipant;
begin
  result := TFhirPlanDefinitionActionParticipant.create;
  try
    ParsePlanDefinitionActionParticipantProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParsePlanDefinitionActionParticipantProperties(jsn : TJsonObject; result : TFhirPlanDefinitionActionParticipant);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn.node['type'], jsn.vObj['_type'], CODES_TFhirActionParticipantTypeEnum, SYSTEMS_TFhirActionParticipantTypeEnum);
    if jsn.has('role') then
        result.role := ParseCodeableConcept(jsn.vObj['role']);{q3}
end;

procedure TFHIRJsonComposer.ComposePlanDefinitionActionParticipant(json : TJSONWriter; name : string; elem : TFhirPlanDefinitionActionParticipant; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirActionParticipantTypeEnum, false);
  ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirActionParticipantTypeEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'role', elem.role); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParsePlanDefinitionActionDynamicValue(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePlanDefinitionActionDynamicValue(jsn)); {2}
end;

function TFHIRJsonParser.ParsePlanDefinitionActionDynamicValue(jsn : TJsonObject) : TFhirPlanDefinitionActionDynamicValue;
begin
  result := TFhirPlanDefinitionActionDynamicValue.create;
  try
    ParsePlanDefinitionActionDynamicValueProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParsePlanDefinitionActionDynamicValueProperties(jsn : TJsonObject; result : TFhirPlanDefinitionActionDynamicValue);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('path') or jsn.has('_path') then
        result.pathElement := parseString(jsn.node['path'], jsn.vObj['_path']);{q}
    if jsn.has('expression') then
        result.expression := ParseExpression(jsn.vObj['expression']);{q3}
end;

procedure TFHIRJsonComposer.ComposePlanDefinitionActionDynamicValue(json : TJSONWriter; name : string; elem : TFhirPlanDefinitionActionDynamicValue; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'path', elem.pathElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'path', elem.pathElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeExpression(json, 'expression', elem.expression); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParsePlanDefinition(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePlanDefinition(jsn)); {2}
end;

function TFHIRJsonParser.ParsePlanDefinition(jsn : TJsonObject) : TFhirPlanDefinition;
begin
  result := TFhirPlanDefinition.create;
  try
    ParsePlanDefinitionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParsePlanDefinitionProperties(jsn : TJsonObject; result : TFhirPlanDefinition);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := parseUri(jsn.node['url'], jsn.vObj['_url']);{q}
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := parseString(jsn.node['version'], jsn.vObj['_version']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('title') or jsn.has('_title') then
        result.titleElement := parseString(jsn.node['title'], jsn.vObj['_title']);{q}
    if jsn.has('subtitle') or jsn.has('_subtitle') then
        result.subtitleElement := parseString(jsn.node['subtitle'], jsn.vObj['_subtitle']);{q}
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    if jsn.has('experimental') or jsn.has('_experimental') then
        result.experimentalElement := parseBoolean(jsn.node['experimental'], jsn.vObj['_experimental']);{q}
    if jsn.has('subjectCodeableConcept') {a4} then
      result.subject := ParseCodeableConcept(jsn.vObj['subjectCodeableConcept']);
    if jsn.has('subjectReference') {a3} then
      result.subject := ParseReference(jsn.vObj['subjectReference']);
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := parseDateTime(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('publisher') or jsn.has('_publisher') then
        result.publisherElement := parseString(jsn.node['publisher'], jsn.vObj['_publisher']);{q}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseContactDetail);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseMarkdown(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('useContext') then
      iterateArray(jsn.vArr['useContext'], result.useContextList, parseUsageContext);
    if jsn.has('jurisdiction') then
      iterateArray(jsn.vArr['jurisdiction'], result.jurisdictionList, parseCodeableConcept);
    if jsn.has('purpose') or jsn.has('_purpose') then
        result.purposeElement := parseMarkdown(jsn.node['purpose'], jsn.vObj['_purpose']);{q}
    if jsn.has('usage') or jsn.has('_usage') then
        result.usageElement := parseString(jsn.node['usage'], jsn.vObj['_usage']);{q}
    if jsn.has('copyright') or jsn.has('_copyright') then
        result.copyrightElement := parseMarkdown(jsn.node['copyright'], jsn.vObj['_copyright']);{q}
    if jsn.has('approvalDate') or jsn.has('_approvalDate') then
        result.approvalDateElement := parseDate(jsn.node['approvalDate'], jsn.vObj['_approvalDate']);{q}
    if jsn.has('lastReviewDate') or jsn.has('_lastReviewDate') then
        result.lastReviewDateElement := parseDate(jsn.node['lastReviewDate'], jsn.vObj['_lastReviewDate']);{q}
    if jsn.has('effectivePeriod') then
        result.effectivePeriod := ParsePeriod(jsn.vObj['effectivePeriod']);{q3}
    if jsn.has('topic') then
      iterateArray(jsn.vArr['topic'], result.topicList, parseCodeableConcept);
    if jsn.has('author') then
      iterateArray(jsn.vArr['author'], result.authorList, parseContactDetail);
    if jsn.has('editor') then
      iterateArray(jsn.vArr['editor'], result.editorList, parseContactDetail);
    if jsn.has('reviewer') then
      iterateArray(jsn.vArr['reviewer'], result.reviewerList, parseContactDetail);
    if jsn.has('endorser') then
      iterateArray(jsn.vArr['endorser'], result.endorserList, parseContactDetail);
    if jsn.has('relatedArtifact') then
      iterateArray(jsn.vArr['relatedArtifact'], result.relatedArtifactList, parseRelatedArtifact);
      if jsn.has('library') or jsn.has('_library') then
      iteratePrimitiveArray(jsn.vArr['library'], jsn.vArr['_library'], result.library_List, parseCanonical);
    if jsn.has('goal') then
      iterateArray(jsn.vArr['goal'], result.goalList, parsePlanDefinitionGoal);
    if jsn.has('action') then
      iterateArray(jsn.vArr['action'], result.actionList, parsePlanDefinitionAction);
end;

procedure TFHIRJsonComposer.ComposePlanDefinition(json : TJSONWriter; name : string; elem : TFhirPlanDefinition; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUriValue(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUriProps(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeStringValue(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeStringProps(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeStringValue(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeStringProps(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('subtitle') then
    ComposeStringValue(json, 'subtitle', elem.subtitleElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('subtitle') then
    ComposeStringProps(json, 'subtitle', elem.subtitleElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBooleanValue(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBooleanProps(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.subject is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'subjectCodeableConcept', TFhirCodeableConcept(elem.subject)) 
  else if (SummaryOption in [soFull, soData]) and (elem.subject is TFhirReference) then
    ComposeReference(json, 'subjectReference', TFhirReference(elem.subject));
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringValue(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringProps(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') and (elem.contactList.Count > 0) then
  begin
    json.valueArray('contact');
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(json, '', elem.contactList[i]); {z - ContactDetail}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeMarkdownValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeMarkdownProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') and (elem.useContextList.Count > 0) then
  begin
    json.valueArray('useContext');
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(json, '', elem.useContextList[i]); {z - UsageContext}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') and (elem.jurisdictionList.Count > 0) then
  begin
    json.valueArray('jurisdiction');
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.jurisdictionList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdownValue(json, 'purpose', elem.purposeElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdownProps(json, 'purpose', elem.purposeElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('usage') then
    ComposeStringValue(json, 'usage', elem.usageElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('usage') then
    ComposeStringProps(json, 'usage', elem.usageElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdownValue(json, 'copyright', elem.copyrightElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdownProps(json, 'copyright', elem.copyrightElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('approvalDate') then
    ComposeDateValue(json, 'approvalDate', elem.approvalDateElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('approvalDate') then
    ComposeDateProps(json, 'approvalDate', elem.approvalDateElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('lastReviewDate') then
    ComposeDateValue(json, 'lastReviewDate', elem.lastReviewDateElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('lastReviewDate') then
    ComposeDateProps(json, 'lastReviewDate', elem.lastReviewDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('effectivePeriod') then
    ComposePeriod(json, 'effectivePeriod', elem.effectivePeriod); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('topic') and (elem.topicList.Count > 0) then
  begin
    json.valueArray('topic');
    for i := 0 to elem.topicList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.topicList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('author') and (elem.authorList.Count > 0) then
  begin
    json.valueArray('author');
    for i := 0 to elem.authorList.Count - 1 do
      ComposeContactDetail(json, '', elem.authorList[i]); {z - ContactDetail}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('editor') and (elem.editorList.Count > 0) then
  begin
    json.valueArray('editor');
    for i := 0 to elem.editorList.Count - 1 do
      ComposeContactDetail(json, '', elem.editorList[i]); {z - ContactDetail}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('reviewer') and (elem.reviewerList.Count > 0) then
  begin
    json.valueArray('reviewer');
    for i := 0 to elem.reviewerList.Count - 1 do
      ComposeContactDetail(json, '', elem.reviewerList[i]); {z - ContactDetail}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('endorser') and (elem.endorserList.Count > 0) then
  begin
    json.valueArray('endorser');
    for i := 0 to elem.endorserList.Count - 1 do
      ComposeContactDetail(json, '', elem.endorserList[i]); {z - ContactDetail}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('relatedArtifact') and (elem.relatedArtifactList.Count > 0) then
  begin
    json.valueArray('relatedArtifact');
    for i := 0 to elem.relatedArtifactList.Count - 1 do
      ComposeRelatedArtifact(json, '', elem.relatedArtifactList[i]); {z - RelatedArtifact}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('library_') and (elem.library_List.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.library_List.Count - 1 do
    begin
      ext := ext or ((elem.library_List[i].id <> '') or (elem.library_List[i].hasExtensionList) {no-comments or (elem.library_List[i].hasComments)});
      val := val or (elem.library_List[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('library');
      for i := 0 to elem.library_List.Count - 1 do
        ComposeCanonicalValue(json, '',elem.library_List[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_library');
      for i := 0 to elem.library_List.Count - 1 do
        ComposeCanonicalProps(json, '',elem.library_List[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('goal') and (elem.goalList.Count > 0) then
  begin
    json.valueArray('goal');
    for i := 0 to elem.goalList.Count - 1 do
      ComposePlanDefinitionGoal(json, '', elem.goalList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('action') and (elem.actionList.Count > 0) then
  begin
    json.valueArray('action');
    for i := 0 to elem.actionList.Count - 1 do
      ComposePlanDefinitionAction(json, '', elem.actionList[i]); {z - }
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_PLANDEFINITION}
{$IFDEF FHIR_PRACTITIONER}
procedure TFHIRJsonParser.ParsePractitionerQualification(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePractitionerQualification(jsn)); {2}
end;

function TFHIRJsonParser.ParsePractitionerQualification(jsn : TJsonObject) : TFhirPractitionerQualification;
begin
  result := TFhirPractitionerQualification.create;
  try
    ParsePractitionerQualificationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParsePractitionerQualificationProperties(jsn : TJsonObject; result : TFhirPractitionerQualification);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q3}
    if jsn.has('issuer') then
        result.issuer := ParseReference{TFhirOrganization}(jsn.vObj['issuer']);{q3}
end;

procedure TFHIRJsonComposer.ComposePractitionerQualification(json : TJSONWriter; name : string; elem : TFhirPractitionerQualification; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(json, 'period', elem.period); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(json, 'issuer', elem.issuer); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParsePractitioner(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePractitioner(jsn)); {2}
end;

function TFHIRJsonParser.ParsePractitioner(jsn : TJsonObject) : TFhirPractitioner;
begin
  result := TFhirPractitioner.create;
  try
    ParsePractitionerProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParsePractitionerProperties(jsn : TJsonObject; result : TFhirPractitioner);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('active') or jsn.has('_active') then
        result.activeElement := parseBoolean(jsn.node['active'], jsn.vObj['_active']);{q}
    if jsn.has('name') then
      iterateArray(jsn.vArr['name'], result.nameList, parseHumanName);
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    if jsn.has('address') then
      iterateArray(jsn.vArr['address'], result.addressList, parseAddress);
    if jsn.has('gender') or jsn.has('_gender')  then
      result.genderElement := parseEnum(jsn.path+'/gender', jsn.node['gender'], jsn.vObj['_gender'], CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum);
    if jsn.has('birthDate') or jsn.has('_birthDate') then
        result.birthDateElement := parseDate(jsn.node['birthDate'], jsn.vObj['_birthDate']);{q}
    if jsn.has('photo') then
      iterateArray(jsn.vArr['photo'], result.photoList, parseAttachment);
    if jsn.has('qualification') then
      iterateArray(jsn.vArr['qualification'], result.qualificationList, parsePractitionerQualification);
    if jsn.has('communication') then
      iterateArray(jsn.vArr['communication'], result.communicationList, parseCodeableConcept);
end;

procedure TFHIRJsonComposer.ComposePractitioner(json : TJSONWriter; name : string; elem : TFhirPractitioner; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('active') then
    ComposeBooleanValue(json, 'active', elem.activeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('active') then
    ComposeBooleanProps(json, 'active', elem.activeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') and (elem.nameList.Count > 0) then
  begin
    json.valueArray('name');
    for i := 0 to elem.nameList.Count - 1 do
      ComposeHumanName(json, '', elem.nameList[i]); {z - HumanName}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('telecom') and (elem.telecomList.Count > 0) then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '', elem.telecomList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('address') and (elem.addressList.Count > 0) then
  begin
    json.valueArray('address');
    for i := 0 to elem.addressList.Count - 1 do
      ComposeAddress(json, '', elem.addressList[i]); {z - Address}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('gender') then
    ComposeEnumValue(json, 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('gender') then
    ComposeEnumProps(json, 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('birthDate') then
    ComposeDateValue(json, 'birthDate', elem.birthDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('birthDate') then
    ComposeDateProps(json, 'birthDate', elem.birthDateElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('photo') and (elem.photoList.Count > 0) then
  begin
    json.valueArray('photo');
    for i := 0 to elem.photoList.Count - 1 do
      ComposeAttachment(json, '', elem.photoList[i]); {z - Attachment}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('qualification') and (elem.qualificationList.Count > 0) then
  begin
    json.valueArray('qualification');
    for i := 0 to elem.qualificationList.Count - 1 do
      ComposePractitionerQualification(json, '', elem.qualificationList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('communication') and (elem.communicationList.Count > 0) then
  begin
    json.valueArray('communication');
    for i := 0 to elem.communicationList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.communicationList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_PRACTITIONER}
{$IFDEF FHIR_PRACTITIONERROLE}
procedure TFHIRJsonParser.ParsePractitionerRoleAvailableTime(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePractitionerRoleAvailableTime(jsn)); {2}
end;

function TFHIRJsonParser.ParsePractitionerRoleAvailableTime(jsn : TJsonObject) : TFhirPractitionerRoleAvailableTime;
begin
  result := TFhirPractitionerRoleAvailableTime.create;
  try
    ParsePractitionerRoleAvailableTimeProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParsePractitionerRoleAvailableTimeProperties(jsn : TJsonObject; result : TFhirPractitionerRoleAvailableTime);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('daysOfWeek') or jsn.has('_daysOfWeek') then
      iterateEnumArray(jsn.vArr['daysOfWeek'], jsn.vArr['_daysOfWeek'], jsn.path+'/daysOfWeek', result.daysOfWeekList, parseEnum, CODES_TFhirDaysOfWeekEnum, SYSTEMS_TFhirDaysOfWeekEnum);
    if jsn.has('allDay') or jsn.has('_allDay') then
        result.allDayElement := parseBoolean(jsn.node['allDay'], jsn.vObj['_allDay']);{q}
    if jsn.has('availableStartTime') or jsn.has('_availableStartTime') then
        result.availableStartTimeElement := parseTime(jsn.node['availableStartTime'], jsn.vObj['_availableStartTime']);{q}
    if jsn.has('availableEndTime') or jsn.has('_availableEndTime') then
        result.availableEndTimeElement := parseTime(jsn.node['availableEndTime'], jsn.vObj['_availableEndTime']);{q}
end;

procedure TFHIRJsonComposer.ComposePractitionerRoleAvailableTime(json : TJSONWriter; name : string; elem : TFhirPractitionerRoleAvailableTime; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and (elem.daysOfWeekList.Count > 0) then
  begin
    val := false;
    ext := false;
    for i := 0 to elem.daysOfWeekList.Count - 1 do
    begin
      val := val or (elem.daysOfWeekList[i].hasPrimitiveValue);
      ext := ext or ((elem.daysOfWeekList[i].id <> '') or (elem.daysOfWeekList[i].hasExtensionList));
    end;
    if val then
    begin
      json.valueArray('daysOfWeek');
      for i := 0 to elem.daysOfWeekList.Count - 1 do
        ComposeEnumValue(json, '', elem.daysOfWeekList[i], CODES_TFhirDaysOfWeekEnum, true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_daysOfWeek');
      for i := 0 to elem.daysOfWeekList.Count - 1 do
        ComposeEnumProps(json, '', elem.daysOfWeekList[i], CODES_TFhirDaysOfWeekEnum, true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'allDay', elem.allDayElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'allDay', elem.allDayElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeTimeValue(json, 'availableStartTime', elem.availableStartTimeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeTimeProps(json, 'availableStartTime', elem.availableStartTimeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeTimeValue(json, 'availableEndTime', elem.availableEndTimeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeTimeProps(json, 'availableEndTime', elem.availableEndTimeElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParsePractitionerRoleNotAvailable(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePractitionerRoleNotAvailable(jsn)); {2}
end;

function TFHIRJsonParser.ParsePractitionerRoleNotAvailable(jsn : TJsonObject) : TFhirPractitionerRoleNotAvailable;
begin
  result := TFhirPractitionerRoleNotAvailable.create;
  try
    ParsePractitionerRoleNotAvailableProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParsePractitionerRoleNotAvailableProperties(jsn : TJsonObject; result : TFhirPractitionerRoleNotAvailable);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('during') then
        result.during := ParsePeriod(jsn.vObj['during']);{q3}
end;

procedure TFHIRJsonComposer.ComposePractitionerRoleNotAvailable(json : TJSONWriter; name : string; elem : TFhirPractitionerRoleNotAvailable; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'description', elem.descriptionElement, false);
  ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(json, 'during', elem.during); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParsePractitionerRole(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePractitionerRole(jsn)); {2}
end;

function TFHIRJsonParser.ParsePractitionerRole(jsn : TJsonObject) : TFhirPractitionerRole;
begin
  result := TFhirPractitionerRole.create;
  try
    ParsePractitionerRoleProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParsePractitionerRoleProperties(jsn : TJsonObject; result : TFhirPractitionerRole);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('active') or jsn.has('_active') then
        result.activeElement := parseBoolean(jsn.node['active'], jsn.vObj['_active']);{q}
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q3}
    if jsn.has('practitioner') then
        result.practitioner := ParseReference{TFhirPractitioner}(jsn.vObj['practitioner']);{q3}
    if jsn.has('organization') then
        result.organization := ParseReference{TFhirOrganization}(jsn.vObj['organization']);{q3}
    if jsn.has('code') then
      iterateArray(jsn.vArr['code'], result.codeList, parseCodeableConcept);
    if jsn.has('specialty') then
      iterateArray(jsn.vArr['specialty'], result.specialtyList, parseCodeableConcept);
    if jsn.has('location') then
      iterateArray(jsn.vArr['location'], result.locationList, parseReference{TFhirLocation});
    if jsn.has('healthcareService') then
      iterateArray(jsn.vArr['healthcareService'], result.healthcareServiceList, parseReference{TFhirHealthcareService});
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    if jsn.has('availableTime') then
      iterateArray(jsn.vArr['availableTime'], result.availableTimeList, parsePractitionerRoleAvailableTime);
    if jsn.has('notAvailable') then
      iterateArray(jsn.vArr['notAvailable'], result.notAvailableList, parsePractitionerRoleNotAvailable);
    if jsn.has('availabilityExceptions') or jsn.has('_availabilityExceptions') then
        result.availabilityExceptionsElement := parseString(jsn.node['availabilityExceptions'], jsn.vObj['_availabilityExceptions']);{q}
    if jsn.has('endpoint') then
      iterateArray(jsn.vArr['endpoint'], result.endpointList, parseReference{TFhirEndpoint});
end;

procedure TFHIRJsonComposer.ComposePractitionerRole(json : TJSONWriter; name : string; elem : TFhirPractitionerRole; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('active') then
    ComposeBooleanValue(json, 'active', elem.activeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('active') then
    ComposeBooleanProps(json, 'active', elem.activeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('period') then
    ComposePeriod(json, 'period', elem.period); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('practitioner') then
    ComposeReference{TFhirPractitioner}(json, 'practitioner', elem.practitioner); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('organization') then
    ComposeReference{TFhirOrganization}(json, 'organization', elem.organization); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') and (elem.codeList.Count > 0) then
  begin
    json.valueArray('code');
    for i := 0 to elem.codeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.codeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('specialty') and (elem.specialtyList.Count > 0) then
  begin
    json.valueArray('specialty');
    for i := 0 to elem.specialtyList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.specialtyList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('location') and (elem.locationList.Count > 0) then
  begin
    json.valueArray('location');
    for i := 0 to elem.locationList.Count - 1 do
      ComposeReference{TFhirLocation}(json, '', elem.locationList[i]); {z - Reference(Location)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('healthcareService') and (elem.healthcareServiceList.Count > 0) then
  begin
    json.valueArray('healthcareService');
    for i := 0 to elem.healthcareServiceList.Count - 1 do
      ComposeReference{TFhirHealthcareService}(json, '', elem.healthcareServiceList[i]); {z - Reference(HealthcareService)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('telecom') and (elem.telecomList.Count > 0) then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '', elem.telecomList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('availableTime') and (elem.availableTimeList.Count > 0) then
  begin
    json.valueArray('availableTime');
    for i := 0 to elem.availableTimeList.Count - 1 do
      ComposePractitionerRoleAvailableTime(json, '', elem.availableTimeList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('notAvailable') and (elem.notAvailableList.Count > 0) then
  begin
    json.valueArray('notAvailable');
    for i := 0 to elem.notAvailableList.Count - 1 do
      ComposePractitionerRoleNotAvailable(json, '', elem.notAvailableList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('availabilityExceptions') then
    ComposeStringValue(json, 'availabilityExceptions', elem.availabilityExceptionsElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('availabilityExceptions') then
    ComposeStringProps(json, 'availabilityExceptions', elem.availabilityExceptionsElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('endpoint') and (elem.endpointList.Count > 0) then
  begin
    json.valueArray('endpoint');
    for i := 0 to elem.endpointList.Count - 1 do
      ComposeReference{TFhirEndpoint}(json, '', elem.endpointList[i]); {z - Reference(Endpoint)}
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_PRACTITIONERROLE}
{$IFDEF FHIR_PROCEDURE}
procedure TFHIRJsonParser.ParseProcedurePerformer(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProcedurePerformer(jsn)); {2}
end;

function TFHIRJsonParser.ParseProcedurePerformer(jsn : TJsonObject) : TFhirProcedurePerformer;
begin
  result := TFhirProcedurePerformer.create;
  try
    ParseProcedurePerformerProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseProcedurePerformerProperties(jsn : TJsonObject; result : TFhirProcedurePerformer);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('function') then
        result.function_ := ParseCodeableConcept(jsn.vObj['function']);{q3}
    if jsn.has('actor') then
        result.actor := ParseReference{TFhirPractitioner}(jsn.vObj['actor']);{q3}
    if jsn.has('onBehalfOf') then
        result.onBehalfOf := ParseReference{TFhirOrganization}(jsn.vObj['onBehalfOf']);{q3}
end;

procedure TFHIRJsonComposer.ComposeProcedurePerformer(json : TJSONWriter; name : string; elem : TFhirProcedurePerformer; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'function', elem.function_); {a}
  ComposeReference{TFhirPractitioner}(json, 'actor', elem.actor); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(json, 'onBehalfOf', elem.onBehalfOf); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseProcedureFocalDevice(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProcedureFocalDevice(jsn)); {2}
end;

function TFHIRJsonParser.ParseProcedureFocalDevice(jsn : TJsonObject) : TFhirProcedureFocalDevice;
begin
  result := TFhirProcedureFocalDevice.create;
  try
    ParseProcedureFocalDeviceProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseProcedureFocalDeviceProperties(jsn : TJsonObject; result : TFhirProcedureFocalDevice);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('action') then
        result.action := ParseCodeableConcept(jsn.vObj['action']);{q3}
    if jsn.has('manipulated') then
        result.manipulated := ParseReference{TFhirDevice}(jsn.vObj['manipulated']);{q3}
end;

procedure TFHIRJsonComposer.ComposeProcedureFocalDevice(json : TJSONWriter; name : string; elem : TFhirProcedureFocalDevice; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'action', elem.action); {a}
  ComposeReference{TFhirDevice}(json, 'manipulated', elem.manipulated); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseProcedure(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProcedure(jsn)); {2}
end;

function TFHIRJsonParser.ParseProcedure(jsn : TJsonObject) : TFhirProcedure;
begin
  result := TFhirProcedure.create;
  try
    ParseProcedureProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseProcedureProperties(jsn : TJsonObject; result : TFhirProcedure);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
      if jsn.has('instantiatesCanonical') or jsn.has('_instantiatesCanonical') then
      iteratePrimitiveArray(jsn.vArr['instantiatesCanonical'], jsn.vArr['_instantiatesCanonical'], result.instantiatesCanonicalList, parseCanonical);
      if jsn.has('instantiatesUri') or jsn.has('_instantiatesUri') then
      iteratePrimitiveArray(jsn.vArr['instantiatesUri'], jsn.vArr['_instantiatesUri'], result.instantiatesUriList, parseUri);
    if jsn.has('basedOn') then
      iterateArray(jsn.vArr['basedOn'], result.basedOnList, parseReference{TFhirCarePlan});
    if jsn.has('partOf') then
      iterateArray(jsn.vArr['partOf'], result.partOfList, parseReference{TFhirProcedure});
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirEventStatusEnum, SYSTEMS_TFhirEventStatusEnum);
    if jsn.has('statusReason') then
        result.statusReason := ParseCodeableConcept(jsn.vObj['statusReason']);{q3}
    if jsn.has('category') then
        result.category := ParseCodeableConcept(jsn.vObj['category']);{q3}
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirPatient}(jsn.vObj['subject']);{q3}
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q3}
    if jsn.has('performedPeriod') {a4} then
      result.performed := ParsePeriod(jsn.vObj['performedPeriod']);
    if jsn.has('performedAge') {a4} then
      result.performed := ParseAge(jsn.vObj['performedAge']);
    if jsn.has('performedRange') {a4} then
      result.performed := ParseRange(jsn.vObj['performedRange']);
    if jsn.has('performedDateTime') or jsn.has('_performedDateTime') then
      result.performed := parseDateTime(jsn.node['performedDateTime'], jsn.vObj['_performedDateTime']);
    if jsn.has('performedString') or jsn.has('_performedString') then
      result.performed := parseString(jsn.node['performedString'], jsn.vObj['_performedString']);
    if jsn.has('recorder') then
        result.recorder := ParseReference{TFhirPatient}(jsn.vObj['recorder']);{q3}
    if jsn.has('asserter') then
        result.asserter := ParseReference{TFhirPatient}(jsn.vObj['asserter']);{q3}
    if jsn.has('performer') then
      iterateArray(jsn.vArr['performer'], result.performerList, parseProcedurePerformer);
    if jsn.has('location') then
        result.location := ParseReference{TFhirLocation}(jsn.vObj['location']);{q3}
    if jsn.has('reasonCode') then
      iterateArray(jsn.vArr['reasonCode'], result.reasonCodeList, parseCodeableConcept);
    if jsn.has('reasonReference') then
      iterateArray(jsn.vArr['reasonReference'], result.reasonReferenceList, parseReference{TFhirCondition});
    if jsn.has('bodySite') then
      iterateArray(jsn.vArr['bodySite'], result.bodySiteList, parseCodeableConcept);
    if jsn.has('outcome') then
        result.outcome := ParseCodeableConcept(jsn.vObj['outcome']);{q3}
    if jsn.has('report') then
      iterateArray(jsn.vArr['report'], result.reportList, parseReference{TFhirDiagnosticReport});
    if jsn.has('complication') then
      iterateArray(jsn.vArr['complication'], result.complicationList, parseCodeableConcept);
    if jsn.has('complicationDetail') then
      iterateArray(jsn.vArr['complicationDetail'], result.complicationDetailList, parseReference{TFhirCondition});
    if jsn.has('followUp') then
      iterateArray(jsn.vArr['followUp'], result.followUpList, parseCodeableConcept);
    if jsn.has('note') then
      iterateArray(jsn.vArr['note'], result.noteList, parseAnnotation);
    if jsn.has('focalDevice') then
      iterateArray(jsn.vArr['focalDevice'], result.focalDeviceList, parseProcedureFocalDevice);
    if jsn.has('usedReference') then
      iterateArray(jsn.vArr['usedReference'], result.usedReferenceList, parseReference{TFhirDevice});
    if jsn.has('usedCode') then
      iterateArray(jsn.vArr['usedCode'], result.usedCodeList, parseCodeableConcept);
end;

procedure TFHIRJsonComposer.ComposeProcedure(json : TJSONWriter; name : string; elem : TFhirProcedure; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('instantiatesCanonical') and (elem.instantiatesCanonicalList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.instantiatesCanonicalList.Count - 1 do
    begin
      ext := ext or ((elem.instantiatesCanonicalList[i].id <> '') or (elem.instantiatesCanonicalList[i].hasExtensionList) {no-comments or (elem.instantiatesCanonicalList[i].hasComments)});
      val := val or (elem.instantiatesCanonicalList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('instantiatesCanonical');
      for i := 0 to elem.instantiatesCanonicalList.Count - 1 do
        ComposeCanonicalValue(json, '',elem.instantiatesCanonicalList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_instantiatesCanonical');
      for i := 0 to elem.instantiatesCanonicalList.Count - 1 do
        ComposeCanonicalProps(json, '',elem.instantiatesCanonicalList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('instantiatesUri') and (elem.instantiatesUriList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.instantiatesUriList.Count - 1 do
    begin
      ext := ext or ((elem.instantiatesUriList[i].id <> '') or (elem.instantiatesUriList[i].hasExtensionList) {no-comments or (elem.instantiatesUriList[i].hasComments)});
      val := val or (elem.instantiatesUriList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('instantiatesUri');
      for i := 0 to elem.instantiatesUriList.Count - 1 do
        ComposeUriValue(json, '',elem.instantiatesUriList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_instantiatesUri');
      for i := 0 to elem.instantiatesUriList.Count - 1 do
        ComposeUriProps(json, '',elem.instantiatesUriList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('basedOn') and (elem.basedOnList.Count > 0) then
  begin
    json.valueArray('basedOn');
    for i := 0 to elem.basedOnList.Count - 1 do
      ComposeReference{TFhirCarePlan}(json, '', elem.basedOnList[i]); {z - Reference(CarePlan)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('partOf') and (elem.partOfList.Count > 0) then
  begin
    json.valueArray('partOf');
    for i := 0 to elem.partOfList.Count - 1 do
      ComposeReference{TFhirProcedure}(json, '', elem.partOfList[i]); {z - Reference(Procedure)}
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirEventStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirEventStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('statusReason') then
    ComposeCodeableConcept(json, 'statusReason', elem.statusReason); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    ComposeCodeableConcept(json, 'category', elem.category); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') then
    ComposeCodeableConcept(json, 'code', elem.code); {a}
  ComposeReference{TFhirPatient}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.performed is TFhirPeriod) then 
    ComposePeriod(json, 'performedPeriod', TFhirPeriod(elem.performed)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.performed is TFhirAge) then 
    ComposeAge(json, 'performedAge', TFhirAge(elem.performed)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.performed is TFhirRange) then 
    ComposeRange(json, 'performedRange', TFhirRange(elem.performed)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.performed is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'performedDateTime', TFhirDateTime(elem.performed), false);
    ComposeDateTimeProps(json, 'performedDateTime', TFhirDateTime(elem.performed), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.performed is TFhirString) then 
  begin
    ComposeStringValue(json, 'performedString', TFhirString(elem.performed), false);
    ComposeStringProps(json, 'performedString', TFhirString(elem.performed), false);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('recorder') then
    ComposeReference{TFhirPatient}(json, 'recorder', elem.recorder); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('asserter') then
    ComposeReference{TFhirPatient}(json, 'asserter', elem.asserter); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('performer') and (elem.performerList.Count > 0) then
  begin
    json.valueArray('performer');
    for i := 0 to elem.performerList.Count - 1 do
      ComposeProcedurePerformer(json, '', elem.performerList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('location') then
    ComposeReference{TFhirLocation}(json, 'location', elem.location); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonCode') and (elem.reasonCodeList.Count > 0) then
  begin
    json.valueArray('reasonCode');
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.reasonCodeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonReference') and (elem.reasonReferenceList.Count > 0) then
  begin
    json.valueArray('reasonReference');
    for i := 0 to elem.reasonReferenceList.Count - 1 do
      ComposeReference{TFhirCondition}(json, '', elem.reasonReferenceList[i]); {z - Reference(Condition)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('bodySite') and (elem.bodySiteList.Count > 0) then
  begin
    json.valueArray('bodySite');
    for i := 0 to elem.bodySiteList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.bodySiteList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('outcome') then
    ComposeCodeableConcept(json, 'outcome', elem.outcome); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('report') and (elem.reportList.Count > 0) then
  begin
    json.valueArray('report');
    for i := 0 to elem.reportList.Count - 1 do
      ComposeReference{TFhirDiagnosticReport}(json, '', elem.reportList[i]); {z - Reference(DiagnosticReport)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('complication') and (elem.complicationList.Count > 0) then
  begin
    json.valueArray('complication');
    for i := 0 to elem.complicationList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.complicationList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('complicationDetail') and (elem.complicationDetailList.Count > 0) then
  begin
    json.valueArray('complicationDetail');
    for i := 0 to elem.complicationDetailList.Count - 1 do
      ComposeReference{TFhirCondition}(json, '', elem.complicationDetailList[i]); {z - Reference(Condition)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('followUp') and (elem.followUpList.Count > 0) then
  begin
    json.valueArray('followUp');
    for i := 0 to elem.followUpList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.followUpList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('note') and (elem.noteList.Count > 0) then
  begin
    json.valueArray('note');
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(json, '', elem.noteList[i]); {z - Annotation}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('focalDevice') and (elem.focalDeviceList.Count > 0) then
  begin
    json.valueArray('focalDevice');
    for i := 0 to elem.focalDeviceList.Count - 1 do
      ComposeProcedureFocalDevice(json, '', elem.focalDeviceList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('usedReference') and (elem.usedReferenceList.Count > 0) then
  begin
    json.valueArray('usedReference');
    for i := 0 to elem.usedReferenceList.Count - 1 do
      ComposeReference{TFhirDevice}(json, '', elem.usedReferenceList[i]); {z - Reference(Device)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('usedCode') and (elem.usedCodeList.Count > 0) then
  begin
    json.valueArray('usedCode');
    for i := 0 to elem.usedCodeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.usedCodeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_PROCEDURE}
{$IFDEF FHIR_PROVENANCE}
procedure TFHIRJsonParser.ParseProvenanceAgent(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProvenanceAgent(jsn)); {2}
end;

function TFHIRJsonParser.ParseProvenanceAgent(jsn : TJsonObject) : TFhirProvenanceAgent;
begin
  result := TFhirProvenanceAgent.create;
  try
    ParseProvenanceAgentProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseProvenanceAgentProperties(jsn : TJsonObject; result : TFhirProvenanceAgent);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('role') then
      iterateArray(jsn.vArr['role'], result.roleList, parseCodeableConcept);
    if jsn.has('who') then
        result.who := ParseReference{TFhirPractitioner}(jsn.vObj['who']);{q3}
    if jsn.has('onBehalfOf') then
        result.onBehalfOf := ParseReference{TFhirPractitioner}(jsn.vObj['onBehalfOf']);{q3}
end;

procedure TFHIRJsonComposer.ComposeProvenanceAgent(json : TJSONWriter; name : string; elem : TFhirProvenanceAgent; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) and (elem.roleList.Count > 0) then
  begin
    json.valueArray('role');
    for i := 0 to elem.roleList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.roleList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  ComposeReference{TFhirPractitioner}(json, 'who', elem.who); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirPractitioner}(json, 'onBehalfOf', elem.onBehalfOf); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseProvenanceEntity(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProvenanceEntity(jsn)); {2}
end;

function TFHIRJsonParser.ParseProvenanceEntity(jsn : TJsonObject) : TFhirProvenanceEntity;
begin
  result := TFhirProvenanceEntity.create;
  try
    ParseProvenanceEntityProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseProvenanceEntityProperties(jsn : TJsonObject; result : TFhirProvenanceEntity);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('role') or jsn.has('_role')  then
      result.roleElement := parseEnum(jsn.path+'/role', jsn.node['role'], jsn.vObj['_role'], CODES_TFhirProvenanceEntityRoleEnum, SYSTEMS_TFhirProvenanceEntityRoleEnum);
    if jsn.has('what') then
        result.what := ParseReference{TFhirReference}(jsn.vObj['what']);{q3}
    if jsn.has('agent') then
      iterateArray(jsn.vArr['agent'], result.agentList, parseProvenanceAgent);
end;

procedure TFHIRJsonComposer.ComposeProvenanceEntity(json : TJSONWriter; name : string; elem : TFhirProvenanceEntity; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'role', elem.RoleElement, CODES_TFhirProvenanceEntityRoleEnum, false);
  ComposeEnumProps(json, 'role', elem.RoleElement, CODES_TFhirProvenanceEntityRoleEnum, false);
  ComposeReference{TFhirReference}(json, 'what', elem.what); {a}
  if (SummaryOption in [soFull, soData]) and (elem.agentList.Count > 0) then
  begin
    json.valueArray('agent');
    for i := 0 to elem.agentList.Count - 1 do
      ComposeProvenanceAgent(json, '', elem.agentList[i]); {z - @Provenance.agent}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseProvenance(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProvenance(jsn)); {2}
end;

function TFHIRJsonParser.ParseProvenance(jsn : TJsonObject) : TFhirProvenance;
begin
  result := TFhirProvenance.create;
  try
    ParseProvenanceProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseProvenanceProperties(jsn : TJsonObject; result : TFhirProvenance);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('target') then
      iterateArray(jsn.vArr['target'], result.targetList, parseReference{TFhirReference});
    if jsn.has('occurredPeriod') {a4} then
      result.occurred := ParsePeriod(jsn.vObj['occurredPeriod']);
    if jsn.has('occurredDateTime') or jsn.has('_occurredDateTime') then
      result.occurred := parseDateTime(jsn.node['occurredDateTime'], jsn.vObj['_occurredDateTime']);
    if jsn.has('recorded') or jsn.has('_recorded') then
        result.recordedElement := parseInstant(jsn.node['recorded'], jsn.vObj['_recorded']);{q}
      if jsn.has('policy') or jsn.has('_policy') then
      iteratePrimitiveArray(jsn.vArr['policy'], jsn.vArr['_policy'], result.policyList, parseUri);
    if jsn.has('location') then
        result.location := ParseReference{TFhirLocation}(jsn.vObj['location']);{q3}
    if jsn.has('reason') then
      iterateArray(jsn.vArr['reason'], result.reasonList, parseCodeableConcept);
    if jsn.has('activity') then
        result.activity := ParseCodeableConcept(jsn.vObj['activity']);{q3}
    if jsn.has('agent') then
      iterateArray(jsn.vArr['agent'], result.agentList, parseProvenanceAgent);
    if jsn.has('entity') then
      iterateArray(jsn.vArr['entity'], result.entityList, parseProvenanceEntity);
    if jsn.has('signature') then
      iterateArray(jsn.vArr['signature'], result.signatureList, parseSignature);
end;

procedure TFHIRJsonComposer.ComposeProvenance(json : TJSONWriter; name : string; elem : TFhirProvenance; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (elem.targetList.Count > 0) then
  begin
    json.valueArray('target');
    for i := 0 to elem.targetList.Count - 1 do
      ComposeReference{TFhirReference}(json, '', elem.targetList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.occurred is TFhirPeriod) then 
    ComposePeriod(json, 'occurredPeriod', TFhirPeriod(elem.occurred)) 
  else if (SummaryOption in [soFull, soData]) and (elem.occurred is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'occurredDateTime', TFhirDateTime(elem.occurred), false);
    ComposeDateTimeProps(json, 'occurredDateTime', TFhirDateTime(elem.occurred), false);
  end;
  ComposeInstantValue(json, 'recorded', elem.recordedElement, false);
  ComposeInstantProps(json, 'recorded', elem.recordedElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('policy') and (elem.policyList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.policyList.Count - 1 do
    begin
      ext := ext or ((elem.policyList[i].id <> '') or (elem.policyList[i].hasExtensionList) {no-comments or (elem.policyList[i].hasComments)});
      val := val or (elem.policyList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('policy');
      for i := 0 to elem.policyList.Count - 1 do
        ComposeUriValue(json, '',elem.policyList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_policy');
      for i := 0 to elem.policyList.Count - 1 do
        ComposeUriProps(json, '',elem.policyList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('location') then
    ComposeReference{TFhirLocation}(json, 'location', elem.location); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('reason') and (elem.reasonList.Count > 0) then
  begin
    json.valueArray('reason');
    for i := 0 to elem.reasonList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.reasonList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('activity') then
    ComposeCodeableConcept(json, 'activity', elem.activity); {a}
  if (elem.agentList.Count > 0) then
  begin
    json.valueArray('agent');
    for i := 0 to elem.agentList.Count - 1 do
      ComposeProvenanceAgent(json, '', elem.agentList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('entity') and (elem.entityList.Count > 0) then
  begin
    json.valueArray('entity');
    for i := 0 to elem.entityList.Count - 1 do
      ComposeProvenanceEntity(json, '', elem.entityList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('signature') and (elem.signatureList.Count > 0) then
  begin
    json.valueArray('signature');
    for i := 0 to elem.signatureList.Count - 1 do
      ComposeSignature(json, '', elem.signatureList[i]); {z - Signature}
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_PROVENANCE}
{$IFDEF FHIR_QUESTIONNAIRE}
procedure TFHIRJsonParser.ParseQuestionnaireItem(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseQuestionnaireItem(jsn)); {2}
end;

function TFHIRJsonParser.ParseQuestionnaireItem(jsn : TJsonObject) : TFhirQuestionnaireItem;
begin
  result := TFhirQuestionnaireItem.create;
  try
    ParseQuestionnaireItemProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseQuestionnaireItemProperties(jsn : TJsonObject; result : TFhirQuestionnaireItem);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('linkId') or jsn.has('_linkId') then
        result.linkIdElement := parseString(jsn.node['linkId'], jsn.vObj['_linkId']);{q}
    if jsn.has('definition') or jsn.has('_definition') then
        result.definitionElement := parseUri(jsn.node['definition'], jsn.vObj['_definition']);{q}
    if jsn.has('code') then
      iterateArray(jsn.vArr['code'], result.codeList, parseCoding);
    if jsn.has('prefix') or jsn.has('_prefix') then
        result.prefixElement := parseString(jsn.node['prefix'], jsn.vObj['_prefix']);{q}
    if jsn.has('text') or jsn.has('_text') then
        result.textElement := parseString(jsn.node['text'], jsn.vObj['_text']);{q}
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn.node['type'], jsn.vObj['_type'], CODES_TFhirItemTypeEnum, SYSTEMS_TFhirItemTypeEnum);
    if jsn.has('enableWhen') then
      iterateArray(jsn.vArr['enableWhen'], result.enableWhenList, parseQuestionnaireItemEnableWhen);
    if jsn.has('enableBehavior') or jsn.has('_enableBehavior')  then
      result.enableBehaviorElement := parseEnum(jsn.path+'/enableBehavior', jsn.node['enableBehavior'], jsn.vObj['_enableBehavior'], CODES_TFhirQuestionnaireEnableBehaviorEnum, SYSTEMS_TFhirQuestionnaireEnableBehaviorEnum);
    if jsn.has('required') or jsn.has('_required') then
        result.requiredElement := parseBoolean(jsn.node['required'], jsn.vObj['_required']);{q}
    if jsn.has('repeats') or jsn.has('_repeats') then
        result.repeatsElement := parseBoolean(jsn.node['repeats'], jsn.vObj['_repeats']);{q}
    if jsn.has('readOnly') or jsn.has('_readOnly') then
        result.readOnlyElement := parseBoolean(jsn.node['readOnly'], jsn.vObj['_readOnly']);{q}
    if jsn.has('maxLength') or jsn.has('_maxLength') then
        result.maxLengthElement := parseInteger(jsn.node['maxLength'], jsn.vObj['_maxLength']);{q}
    if jsn.has('answerValueSet') or jsn.has('_answerValueSet') then
        result.answerValueSetElement := parseCanonical(jsn.node['answerValueSet'], jsn.vObj['_answerValueSet']);{q}
    if jsn.has('answerOption') then
      iterateArray(jsn.vArr['answerOption'], result.answerOptionList, parseQuestionnaireItemAnswerOption);
    if jsn.has('initial') then
      iterateArray(jsn.vArr['initial'], result.initialList, parseQuestionnaireItemInitial);
    if jsn.has('item') then
      iterateArray(jsn.vArr['item'], result.itemList, parseQuestionnaireItem);
end;

procedure TFHIRJsonComposer.ComposeQuestionnaireItem(json : TJSONWriter; name : string; elem : TFhirQuestionnaireItem; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'linkId', elem.linkIdElement, false);
  ComposeStringProps(json, 'linkId', elem.linkIdElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeUriValue(json, 'definition', elem.definitionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeUriProps(json, 'definition', elem.definitionElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.codeList.Count > 0) then
  begin
    json.valueArray('code');
    for i := 0 to elem.codeList.Count - 1 do
      ComposeCoding(json, '', elem.codeList[i]); {z - Coding}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'prefix', elem.prefixElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'prefix', elem.prefixElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'text', elem.textElement, false);
  ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirItemTypeEnum, false);
  ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirItemTypeEnum, false);
  if (SummaryOption in [soFull, soData]) and (elem.enableWhenList.Count > 0) then
  begin
    json.valueArray('enableWhen');
    for i := 0 to elem.enableWhenList.Count - 1 do
      ComposeQuestionnaireItemEnableWhen(json, '', elem.enableWhenList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumValue(json, 'enableBehavior', elem.EnableBehaviorElement, CODES_TFhirQuestionnaireEnableBehaviorEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumProps(json, 'enableBehavior', elem.EnableBehaviorElement, CODES_TFhirQuestionnaireEnableBehaviorEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'required', elem.requiredElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'required', elem.requiredElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'repeats', elem.repeatsElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'repeats', elem.repeatsElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'readOnly', elem.readOnlyElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'readOnly', elem.readOnlyElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIntegerValue(json, 'maxLength', elem.maxLengthElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIntegerProps(json, 'maxLength', elem.maxLengthElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonicalValue(json, 'answerValueSet', elem.answerValueSetElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonicalProps(json, 'answerValueSet', elem.answerValueSetElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.answerOptionList.Count > 0) then
  begin
    json.valueArray('answerOption');
    for i := 0 to elem.answerOptionList.Count - 1 do
      ComposeQuestionnaireItemAnswerOption(json, '', elem.answerOptionList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.initialList.Count > 0) then
  begin
    json.valueArray('initial');
    for i := 0 to elem.initialList.Count - 1 do
      ComposeQuestionnaireItemInitial(json, '', elem.initialList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.itemList.Count > 0) then
  begin
    json.valueArray('item');
    for i := 0 to elem.itemList.Count - 1 do
      ComposeQuestionnaireItem(json, '', elem.itemList[i]); {z - @Questionnaire.item}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseQuestionnaireItemEnableWhen(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseQuestionnaireItemEnableWhen(jsn)); {2}
end;

function TFHIRJsonParser.ParseQuestionnaireItemEnableWhen(jsn : TJsonObject) : TFhirQuestionnaireItemEnableWhen;
begin
  result := TFhirQuestionnaireItemEnableWhen.create;
  try
    ParseQuestionnaireItemEnableWhenProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseQuestionnaireItemEnableWhenProperties(jsn : TJsonObject; result : TFhirQuestionnaireItemEnableWhen);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('question') or jsn.has('_question') then
        result.questionElement := parseString(jsn.node['question'], jsn.vObj['_question']);{q}
    if jsn.has('operator') or jsn.has('_operator')  then
      result.operatorElement := parseEnum(jsn.path+'/operator', jsn.node['operator'], jsn.vObj['_operator'], CODES_TFhirQuestionnaireEnableOperatorEnum, SYSTEMS_TFhirQuestionnaireEnableOperatorEnum);
    if jsn.has('answerCoding') {a4} then
      result.answer := ParseCoding(jsn.vObj['answerCoding']);
    if jsn.has('answerQuantity') {a4} then
      result.answer := ParseQuantity(jsn.vObj['answerQuantity']);
    if jsn.has('answerReference') {a3} then
      result.answer := ParseReference(jsn.vObj['answerReference']);
    if jsn.has('answerBoolean') or jsn.has('_answerBoolean') then
      result.answer := parseBoolean(jsn.node['answerBoolean'], jsn.vObj['_answerBoolean']);
    if jsn.has('answerDecimal') or jsn.has('_answerDecimal') then
      result.answer := parseDecimal(jsn.node['answerDecimal'], jsn.vObj['_answerDecimal']);
    if jsn.has('answerInteger') or jsn.has('_answerInteger') then
      result.answer := parseInteger(jsn.node['answerInteger'], jsn.vObj['_answerInteger']);
    if jsn.has('answerDate') or jsn.has('_answerDate') then
      result.answer := parseDate(jsn.node['answerDate'], jsn.vObj['_answerDate']);
    if jsn.has('answerDateTime') or jsn.has('_answerDateTime') then
      result.answer := parseDateTime(jsn.node['answerDateTime'], jsn.vObj['_answerDateTime']);
    if jsn.has('answerTime') or jsn.has('_answerTime') then
      result.answer := parseTime(jsn.node['answerTime'], jsn.vObj['_answerTime']);
    if jsn.has('answerString') or jsn.has('_answerString') then
      result.answer := parseString(jsn.node['answerString'], jsn.vObj['_answerString']);
end;

procedure TFHIRJsonComposer.ComposeQuestionnaireItemEnableWhen(json : TJSONWriter; name : string; elem : TFhirQuestionnaireItemEnableWhen; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'question', elem.questionElement, false);
  ComposeStringProps(json, 'question', elem.questionElement, false);
  ComposeEnumValue(json, 'operator', elem.OperatorElement, CODES_TFhirQuestionnaireEnableOperatorEnum, false);
  ComposeEnumProps(json, 'operator', elem.OperatorElement, CODES_TFhirQuestionnaireEnableOperatorEnum, false);
  if (elem.answer is TFhirCoding) then 
    ComposeCoding(json, 'answerCoding', TFhirCoding(elem.answer)) 
  else if (elem.answer is TFhirQuantity) then 
    ComposeQuantity(json, 'answerQuantity', TFhirQuantity(elem.answer)) 
  else if (elem.answer is TFhirReference) then
    ComposeReference(json, 'answerReference', TFhirReference(elem.answer))
  else if (elem.answer is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'answerBoolean', TFhirBoolean(elem.answer), false);
    ComposeBooleanProps(json, 'answerBoolean', TFhirBoolean(elem.answer), false);
  end
  else if (elem.answer is TFhirDecimal) then 
  begin
    ComposeDecimalValue(json, 'answerDecimal', TFhirDecimal(elem.answer), false);
    ComposeDecimalProps(json, 'answerDecimal', TFhirDecimal(elem.answer), false);
  end
  else if (elem.answer is TFhirInteger) then 
  begin
    ComposeIntegerValue(json, 'answerInteger', TFhirInteger(elem.answer), false);
    ComposeIntegerProps(json, 'answerInteger', TFhirInteger(elem.answer), false);
  end
  else if (elem.answer is TFhirDate) then 
  begin
    ComposeDateValue(json, 'answerDate', TFhirDate(elem.answer), false);
    ComposeDateProps(json, 'answerDate', TFhirDate(elem.answer), false);
  end
  else if (elem.answer is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'answerDateTime', TFhirDateTime(elem.answer), false);
    ComposeDateTimeProps(json, 'answerDateTime', TFhirDateTime(elem.answer), false);
  end
  else if (elem.answer is TFhirTime) then 
  begin
    ComposeTimeValue(json, 'answerTime', TFhirTime(elem.answer), false);
    ComposeTimeProps(json, 'answerTime', TFhirTime(elem.answer), false);
  end
  else if (elem.answer is TFhirString) then 
  begin
    ComposeStringValue(json, 'answerString', TFhirString(elem.answer), false);
    ComposeStringProps(json, 'answerString', TFhirString(elem.answer), false);
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseQuestionnaireItemAnswerOption(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseQuestionnaireItemAnswerOption(jsn)); {2}
end;

function TFHIRJsonParser.ParseQuestionnaireItemAnswerOption(jsn : TJsonObject) : TFhirQuestionnaireItemAnswerOption;
begin
  result := TFhirQuestionnaireItemAnswerOption.create;
  try
    ParseQuestionnaireItemAnswerOptionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseQuestionnaireItemAnswerOptionProperties(jsn : TJsonObject; result : TFhirQuestionnaireItemAnswerOption);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('valueCoding') {a4} then
      result.value := ParseCoding(jsn.vObj['valueCoding']);
    if jsn.has('valueReference') {a3} then
      result.value := ParseReference(jsn.vObj['valueReference']);
    if jsn.has('valueInteger') or jsn.has('_valueInteger') then
      result.value := parseInteger(jsn.node['valueInteger'], jsn.vObj['_valueInteger']);
    if jsn.has('valueDate') or jsn.has('_valueDate') then
      result.value := parseDate(jsn.node['valueDate'], jsn.vObj['_valueDate']);
    if jsn.has('valueTime') or jsn.has('_valueTime') then
      result.value := parseTime(jsn.node['valueTime'], jsn.vObj['_valueTime']);
    if jsn.has('valueString') or jsn.has('_valueString') then
      result.value := parseString(jsn.node['valueString'], jsn.vObj['_valueString']);
    if jsn.has('initialSelected') or jsn.has('_initialSelected') then
        result.initialSelectedElement := parseBoolean(jsn.node['initialSelected'], jsn.vObj['_initialSelected']);{q}
end;

procedure TFHIRJsonComposer.ComposeQuestionnaireItemAnswerOption(json : TJSONWriter; name : string; elem : TFhirQuestionnaireItemAnswerOption; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (elem.value is TFhirCoding) then 
    ComposeCoding(json, 'valueCoding', TFhirCoding(elem.value)) 
  else if (elem.value is TFhirReference) then
    ComposeReference(json, 'valueReference', TFhirReference(elem.value))
  else if (elem.value is TFhirInteger) then 
  begin
    ComposeIntegerValue(json, 'valueInteger', TFhirInteger(elem.value), false);
    ComposeIntegerProps(json, 'valueInteger', TFhirInteger(elem.value), false);
  end
  else if (elem.value is TFhirDate) then 
  begin
    ComposeDateValue(json, 'valueDate', TFhirDate(elem.value), false);
    ComposeDateProps(json, 'valueDate', TFhirDate(elem.value), false);
  end
  else if (elem.value is TFhirTime) then 
  begin
    ComposeTimeValue(json, 'valueTime', TFhirTime(elem.value), false);
    ComposeTimeProps(json, 'valueTime', TFhirTime(elem.value), false);
  end
  else if (elem.value is TFhirString) then 
  begin
    ComposeStringValue(json, 'valueString', TFhirString(elem.value), false);
    ComposeStringProps(json, 'valueString', TFhirString(elem.value), false);
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'initialSelected', elem.initialSelectedElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'initialSelected', elem.initialSelectedElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseQuestionnaireItemInitial(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseQuestionnaireItemInitial(jsn)); {2}
end;

function TFHIRJsonParser.ParseQuestionnaireItemInitial(jsn : TJsonObject) : TFhirQuestionnaireItemInitial;
begin
  result := TFhirQuestionnaireItemInitial.create;
  try
    ParseQuestionnaireItemInitialProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseQuestionnaireItemInitialProperties(jsn : TJsonObject; result : TFhirQuestionnaireItemInitial);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('valueAttachment') {a4} then
      result.value := ParseAttachment(jsn.vObj['valueAttachment']);
    if jsn.has('valueCoding') {a4} then
      result.value := ParseCoding(jsn.vObj['valueCoding']);
    if jsn.has('valueQuantity') {a4} then
      result.value := ParseQuantity(jsn.vObj['valueQuantity']);
    if jsn.has('valueReference') {a3} then
      result.value := ParseReference(jsn.vObj['valueReference']);
    if jsn.has('valueBoolean') or jsn.has('_valueBoolean') then
      result.value := parseBoolean(jsn.node['valueBoolean'], jsn.vObj['_valueBoolean']);
    if jsn.has('valueDecimal') or jsn.has('_valueDecimal') then
      result.value := parseDecimal(jsn.node['valueDecimal'], jsn.vObj['_valueDecimal']);
    if jsn.has('valueInteger') or jsn.has('_valueInteger') then
      result.value := parseInteger(jsn.node['valueInteger'], jsn.vObj['_valueInteger']);
    if jsn.has('valueDate') or jsn.has('_valueDate') then
      result.value := parseDate(jsn.node['valueDate'], jsn.vObj['_valueDate']);
    if jsn.has('valueDateTime') or jsn.has('_valueDateTime') then
      result.value := parseDateTime(jsn.node['valueDateTime'], jsn.vObj['_valueDateTime']);
    if jsn.has('valueTime') or jsn.has('_valueTime') then
      result.value := parseTime(jsn.node['valueTime'], jsn.vObj['_valueTime']);
    if jsn.has('valueString') or jsn.has('_valueString') then
      result.value := parseString(jsn.node['valueString'], jsn.vObj['_valueString']);
    if jsn.has('valueUri') or jsn.has('_valueUri') then
      result.value := parseUri(jsn.node['valueUri'], jsn.vObj['_valueUri']);
end;

procedure TFHIRJsonComposer.ComposeQuestionnaireItemInitial(json : TJSONWriter; name : string; elem : TFhirQuestionnaireItemInitial; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (elem.value is TFhirAttachment) then 
    ComposeAttachment(json, 'valueAttachment', TFhirAttachment(elem.value)) 
  else if (elem.value is TFhirCoding) then 
    ComposeCoding(json, 'valueCoding', TFhirCoding(elem.value)) 
  else if (elem.value is TFhirQuantity) then 
    ComposeQuantity(json, 'valueQuantity', TFhirQuantity(elem.value)) 
  else if (elem.value is TFhirReference) then
    ComposeReference(json, 'valueReference', TFhirReference(elem.value))
  else if (elem.value is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'valueBoolean', TFhirBoolean(elem.value), false);
    ComposeBooleanProps(json, 'valueBoolean', TFhirBoolean(elem.value), false);
  end
  else if (elem.value is TFhirDecimal) then 
  begin
    ComposeDecimalValue(json, 'valueDecimal', TFhirDecimal(elem.value), false);
    ComposeDecimalProps(json, 'valueDecimal', TFhirDecimal(elem.value), false);
  end
  else if (elem.value is TFhirInteger) then 
  begin
    ComposeIntegerValue(json, 'valueInteger', TFhirInteger(elem.value), false);
    ComposeIntegerProps(json, 'valueInteger', TFhirInteger(elem.value), false);
  end
  else if (elem.value is TFhirDate) then 
  begin
    ComposeDateValue(json, 'valueDate', TFhirDate(elem.value), false);
    ComposeDateProps(json, 'valueDate', TFhirDate(elem.value), false);
  end
  else if (elem.value is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'valueDateTime', TFhirDateTime(elem.value), false);
    ComposeDateTimeProps(json, 'valueDateTime', TFhirDateTime(elem.value), false);
  end
  else if (elem.value is TFhirTime) then 
  begin
    ComposeTimeValue(json, 'valueTime', TFhirTime(elem.value), false);
    ComposeTimeProps(json, 'valueTime', TFhirTime(elem.value), false);
  end
  else if (elem.value is TFhirString) then 
  begin
    ComposeStringValue(json, 'valueString', TFhirString(elem.value), false);
    ComposeStringProps(json, 'valueString', TFhirString(elem.value), false);
  end
  else if (elem.value is TFhirUri) then 
  begin
    ComposeUriValue(json, 'valueUri', TFhirUri(elem.value), false);
    ComposeUriProps(json, 'valueUri', TFhirUri(elem.value), false);
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseQuestionnaire(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseQuestionnaire(jsn)); {2}
end;

function TFHIRJsonParser.ParseQuestionnaire(jsn : TJsonObject) : TFhirQuestionnaire;
begin
  result := TFhirQuestionnaire.create;
  try
    ParseQuestionnaireProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseQuestionnaireProperties(jsn : TJsonObject; result : TFhirQuestionnaire);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := parseUri(jsn.node['url'], jsn.vObj['_url']);{q}
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := parseString(jsn.node['version'], jsn.vObj['_version']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('title') or jsn.has('_title') then
        result.titleElement := parseString(jsn.node['title'], jsn.vObj['_title']);{q}
      if jsn.has('derivedFrom') or jsn.has('_derivedFrom') then
      iteratePrimitiveArray(jsn.vArr['derivedFrom'], jsn.vArr['_derivedFrom'], result.derivedFromList, parseCanonical);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    if jsn.has('experimental') or jsn.has('_experimental') then
        result.experimentalElement := parseBoolean(jsn.node['experimental'], jsn.vObj['_experimental']);{q}
    if jsn.has('subjectType') or jsn.has('_subjectType') then
      iterateEnumArray(jsn.vArr['subjectType'], jsn.vArr['_subjectType'], jsn.path+'/subjectType', result.subjectType, parseEnum, CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum);
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := parseDateTime(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('publisher') or jsn.has('_publisher') then
        result.publisherElement := parseString(jsn.node['publisher'], jsn.vObj['_publisher']);{q}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseContactDetail);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseMarkdown(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('useContext') then
      iterateArray(jsn.vArr['useContext'], result.useContextList, parseUsageContext);
    if jsn.has('jurisdiction') then
      iterateArray(jsn.vArr['jurisdiction'], result.jurisdictionList, parseCodeableConcept);
    if jsn.has('purpose') or jsn.has('_purpose') then
        result.purposeElement := parseMarkdown(jsn.node['purpose'], jsn.vObj['_purpose']);{q}
    if jsn.has('copyright') or jsn.has('_copyright') then
        result.copyrightElement := parseMarkdown(jsn.node['copyright'], jsn.vObj['_copyright']);{q}
    if jsn.has('approvalDate') or jsn.has('_approvalDate') then
        result.approvalDateElement := parseDate(jsn.node['approvalDate'], jsn.vObj['_approvalDate']);{q}
    if jsn.has('lastReviewDate') or jsn.has('_lastReviewDate') then
        result.lastReviewDateElement := parseDate(jsn.node['lastReviewDate'], jsn.vObj['_lastReviewDate']);{q}
    if jsn.has('effectivePeriod') then
        result.effectivePeriod := ParsePeriod(jsn.vObj['effectivePeriod']);{q3}
    if jsn.has('code') then
      iterateArray(jsn.vArr['code'], result.codeList, parseCoding);
    if jsn.has('item') then
      iterateArray(jsn.vArr['item'], result.itemList, parseQuestionnaireItem);
end;

procedure TFHIRJsonComposer.ComposeQuestionnaire(json : TJSONWriter; name : string; elem : TFhirQuestionnaire; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUriValue(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUriProps(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeStringValue(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeStringProps(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeStringValue(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeStringProps(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('derivedFrom') and (elem.derivedFromList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.derivedFromList.Count - 1 do
    begin
      ext := ext or ((elem.derivedFromList[i].id <> '') or (elem.derivedFromList[i].hasExtensionList) {no-comments or (elem.derivedFromList[i].hasComments)});
      val := val or (elem.derivedFromList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('derivedFrom');
      for i := 0 to elem.derivedFromList.Count - 1 do
        ComposeCanonicalValue(json, '',elem.derivedFromList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_derivedFrom');
      for i := 0 to elem.derivedFromList.Count - 1 do
        ComposeCanonicalProps(json, '',elem.derivedFromList[i], true);
      json.FinishArray;
    end;
  end;
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBooleanValue(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBooleanProps(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subjectType') and (elem.subjectType.Count > 0) then
  begin
    val := false;
    ext := false;
    for i := 0 to elem.subjectType.Count - 1 do
    begin
      val := val or (elem.subjectType[i].hasPrimitiveValue);
      ext := ext or ((elem.subjectType[i].id <> '') or (elem.subjectType[i].hasExtensionList));
    end;
    if val then
    begin
      json.valueArray('subjectType');
      for i := 0 to elem.subjectType.Count - 1 do
        ComposeEnumValue(json, '', elem.subjectType[i], CODES_TFhirResourceTypesEnum, true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_subjectType');
      for i := 0 to elem.subjectType.Count - 1 do
        ComposeEnumProps(json, '', elem.subjectType[i], CODES_TFhirResourceTypesEnum, true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringValue(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringProps(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') and (elem.contactList.Count > 0) then
  begin
    json.valueArray('contact');
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(json, '', elem.contactList[i]); {z - ContactDetail}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdownValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdownProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') and (elem.useContextList.Count > 0) then
  begin
    json.valueArray('useContext');
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(json, '', elem.useContextList[i]); {z - UsageContext}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') and (elem.jurisdictionList.Count > 0) then
  begin
    json.valueArray('jurisdiction');
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.jurisdictionList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdownValue(json, 'purpose', elem.purposeElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdownProps(json, 'purpose', elem.purposeElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdownValue(json, 'copyright', elem.copyrightElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdownProps(json, 'copyright', elem.copyrightElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('approvalDate') then
    ComposeDateValue(json, 'approvalDate', elem.approvalDateElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('approvalDate') then
    ComposeDateProps(json, 'approvalDate', elem.approvalDateElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('lastReviewDate') then
    ComposeDateValue(json, 'lastReviewDate', elem.lastReviewDateElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('lastReviewDate') then
    ComposeDateProps(json, 'lastReviewDate', elem.lastReviewDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('effectivePeriod') then
    ComposePeriod(json, 'effectivePeriod', elem.effectivePeriod); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') and (elem.codeList.Count > 0) then
  begin
    json.valueArray('code');
    for i := 0 to elem.codeList.Count - 1 do
      ComposeCoding(json, '', elem.codeList[i]); {z - Coding}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('item') and (elem.itemList.Count > 0) then
  begin
    json.valueArray('item');
    for i := 0 to elem.itemList.Count - 1 do
      ComposeQuestionnaireItem(json, '', elem.itemList[i]); {z - }
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_QUESTIONNAIRE}
{$IFDEF FHIR_QUESTIONNAIRERESPONSE}
procedure TFHIRJsonParser.ParseQuestionnaireResponseItem(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseQuestionnaireResponseItem(jsn)); {2}
end;

function TFHIRJsonParser.ParseQuestionnaireResponseItem(jsn : TJsonObject) : TFhirQuestionnaireResponseItem;
begin
  result := TFhirQuestionnaireResponseItem.create;
  try
    ParseQuestionnaireResponseItemProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseQuestionnaireResponseItemProperties(jsn : TJsonObject; result : TFhirQuestionnaireResponseItem);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('linkId') or jsn.has('_linkId') then
        result.linkIdElement := parseString(jsn.node['linkId'], jsn.vObj['_linkId']);{q}
    if jsn.has('definition') or jsn.has('_definition') then
        result.definitionElement := parseUri(jsn.node['definition'], jsn.vObj['_definition']);{q}
    if jsn.has('text') or jsn.has('_text') then
        result.textElement := parseString(jsn.node['text'], jsn.vObj['_text']);{q}
    if jsn.has('answer') then
      iterateArray(jsn.vArr['answer'], result.answerList, parseQuestionnaireResponseItemAnswer);
    if jsn.has('item') then
      iterateArray(jsn.vArr['item'], result.itemList, parseQuestionnaireResponseItem);
end;

procedure TFHIRJsonComposer.ComposeQuestionnaireResponseItem(json : TJSONWriter; name : string; elem : TFhirQuestionnaireResponseItem; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'linkId', elem.linkIdElement, false);
  ComposeStringProps(json, 'linkId', elem.linkIdElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeUriValue(json, 'definition', elem.definitionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeUriProps(json, 'definition', elem.definitionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.answerList.Count > 0) then
  begin
    json.valueArray('answer');
    for i := 0 to elem.answerList.Count - 1 do
      ComposeQuestionnaireResponseItemAnswer(json, '', elem.answerList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.itemList.Count > 0) then
  begin
    json.valueArray('item');
    for i := 0 to elem.itemList.Count - 1 do
      ComposeQuestionnaireResponseItem(json, '', elem.itemList[i]); {z - @QuestionnaireResponse.item}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseQuestionnaireResponseItemAnswer(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseQuestionnaireResponseItemAnswer(jsn)); {2}
end;

function TFHIRJsonParser.ParseQuestionnaireResponseItemAnswer(jsn : TJsonObject) : TFhirQuestionnaireResponseItemAnswer;
begin
  result := TFhirQuestionnaireResponseItemAnswer.create;
  try
    ParseQuestionnaireResponseItemAnswerProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseQuestionnaireResponseItemAnswerProperties(jsn : TJsonObject; result : TFhirQuestionnaireResponseItemAnswer);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('valueAttachment') {a4} then
      result.value := ParseAttachment(jsn.vObj['valueAttachment']);
    if jsn.has('valueCoding') {a4} then
      result.value := ParseCoding(jsn.vObj['valueCoding']);
    if jsn.has('valueQuantity') {a4} then
      result.value := ParseQuantity(jsn.vObj['valueQuantity']);
    if jsn.has('valueReference') {a3} then
      result.value := ParseReference(jsn.vObj['valueReference']);
    if jsn.has('valueBoolean') or jsn.has('_valueBoolean') then
      result.value := parseBoolean(jsn.node['valueBoolean'], jsn.vObj['_valueBoolean']);
    if jsn.has('valueDecimal') or jsn.has('_valueDecimal') then
      result.value := parseDecimal(jsn.node['valueDecimal'], jsn.vObj['_valueDecimal']);
    if jsn.has('valueInteger') or jsn.has('_valueInteger') then
      result.value := parseInteger(jsn.node['valueInteger'], jsn.vObj['_valueInteger']);
    if jsn.has('valueDate') or jsn.has('_valueDate') then
      result.value := parseDate(jsn.node['valueDate'], jsn.vObj['_valueDate']);
    if jsn.has('valueDateTime') or jsn.has('_valueDateTime') then
      result.value := parseDateTime(jsn.node['valueDateTime'], jsn.vObj['_valueDateTime']);
    if jsn.has('valueTime') or jsn.has('_valueTime') then
      result.value := parseTime(jsn.node['valueTime'], jsn.vObj['_valueTime']);
    if jsn.has('valueString') or jsn.has('_valueString') then
      result.value := parseString(jsn.node['valueString'], jsn.vObj['_valueString']);
    if jsn.has('valueUri') or jsn.has('_valueUri') then
      result.value := parseUri(jsn.node['valueUri'], jsn.vObj['_valueUri']);
    if jsn.has('item') then
      iterateArray(jsn.vArr['item'], result.itemList, parseQuestionnaireResponseItem);
end;

procedure TFHIRJsonComposer.ComposeQuestionnaireResponseItemAnswer(json : TJSONWriter; name : string; elem : TFhirQuestionnaireResponseItemAnswer; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and (elem.value is TFhirAttachment) then 
    ComposeAttachment(json, 'valueAttachment', TFhirAttachment(elem.value)) 
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirCoding) then 
    ComposeCoding(json, 'valueCoding', TFhirCoding(elem.value)) 
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirQuantity) then 
    ComposeQuantity(json, 'valueQuantity', TFhirQuantity(elem.value)) 
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirReference) then
    ComposeReference(json, 'valueReference', TFhirReference(elem.value))
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'valueBoolean', TFhirBoolean(elem.value), false);
    ComposeBooleanProps(json, 'valueBoolean', TFhirBoolean(elem.value), false);
  end
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirDecimal) then 
  begin
    ComposeDecimalValue(json, 'valueDecimal', TFhirDecimal(elem.value), false);
    ComposeDecimalProps(json, 'valueDecimal', TFhirDecimal(elem.value), false);
  end
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirInteger) then 
  begin
    ComposeIntegerValue(json, 'valueInteger', TFhirInteger(elem.value), false);
    ComposeIntegerProps(json, 'valueInteger', TFhirInteger(elem.value), false);
  end
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirDate) then 
  begin
    ComposeDateValue(json, 'valueDate', TFhirDate(elem.value), false);
    ComposeDateProps(json, 'valueDate', TFhirDate(elem.value), false);
  end
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'valueDateTime', TFhirDateTime(elem.value), false);
    ComposeDateTimeProps(json, 'valueDateTime', TFhirDateTime(elem.value), false);
  end
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirTime) then 
  begin
    ComposeTimeValue(json, 'valueTime', TFhirTime(elem.value), false);
    ComposeTimeProps(json, 'valueTime', TFhirTime(elem.value), false);
  end
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirString) then 
  begin
    ComposeStringValue(json, 'valueString', TFhirString(elem.value), false);
    ComposeStringProps(json, 'valueString', TFhirString(elem.value), false);
  end
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirUri) then 
  begin
    ComposeUriValue(json, 'valueUri', TFhirUri(elem.value), false);
    ComposeUriProps(json, 'valueUri', TFhirUri(elem.value), false);
  end;
  if (SummaryOption in [soFull, soData]) and (elem.itemList.Count > 0) then
  begin
    json.valueArray('item');
    for i := 0 to elem.itemList.Count - 1 do
      ComposeQuestionnaireResponseItem(json, '', elem.itemList[i]); {z - @QuestionnaireResponse.item}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseQuestionnaireResponse(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseQuestionnaireResponse(jsn)); {2}
end;

function TFHIRJsonParser.ParseQuestionnaireResponse(jsn : TJsonObject) : TFhirQuestionnaireResponse;
begin
  result := TFhirQuestionnaireResponse.create;
  try
    ParseQuestionnaireResponseProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseQuestionnaireResponseProperties(jsn : TJsonObject; result : TFhirQuestionnaireResponse);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q3}
    if jsn.has('basedOn') then
      iterateArray(jsn.vArr['basedOn'], result.basedOnList, parseReference{TFhirCarePlan});
    if jsn.has('partOf') then
      iterateArray(jsn.vArr['partOf'], result.partOfList, parseReference{TFhirObservation});
    if jsn.has('questionnaire') or jsn.has('_questionnaire') then
        result.questionnaireElement := parseCanonical(jsn.node['questionnaire'], jsn.vObj['_questionnaire']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirQuestionnaireAnswersStatusEnum, SYSTEMS_TFhirQuestionnaireAnswersStatusEnum);
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirReference}(jsn.vObj['subject']);{q3}
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q3}
    if jsn.has('authored') or jsn.has('_authored') then
        result.authoredElement := parseDateTime(jsn.node['authored'], jsn.vObj['_authored']);{q}
    if jsn.has('author') then
        result.author := ParseReference{TFhirDevice}(jsn.vObj['author']);{q3}
    if jsn.has('source') then
        result.source := ParseReference{TFhirPatient}(jsn.vObj['source']);{q3}
    if jsn.has('item') then
      iterateArray(jsn.vArr['item'], result.itemList, parseQuestionnaireResponseItem);
end;

procedure TFHIRJsonComposer.ComposeQuestionnaireResponse(json : TJSONWriter; name : string; elem : TFhirQuestionnaireResponse; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('basedOn') and (elem.basedOnList.Count > 0) then
  begin
    json.valueArray('basedOn');
    for i := 0 to elem.basedOnList.Count - 1 do
      ComposeReference{TFhirCarePlan}(json, '', elem.basedOnList[i]); {z - Reference(CarePlan)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('partOf') and (elem.partOfList.Count > 0) then
  begin
    json.valueArray('partOf');
    for i := 0 to elem.partOfList.Count - 1 do
      ComposeReference{TFhirObservation}(json, '', elem.partOfList[i]); {z - Reference(Observation)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('questionnaire') then
    ComposeCanonicalValue(json, 'questionnaire', elem.questionnaireElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('questionnaire') then
    ComposeCanonicalProps(json, 'questionnaire', elem.questionnaireElement, false);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirQuestionnaireAnswersStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirQuestionnaireAnswersStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{TFhirReference}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('authored') then
    ComposeDateTimeValue(json, 'authored', elem.authoredElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('authored') then
    ComposeDateTimeProps(json, 'authored', elem.authoredElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('author') then
    ComposeReference{TFhirDevice}(json, 'author', elem.author); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('source') then
    ComposeReference{TFhirPatient}(json, 'source', elem.source); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('item') and (elem.itemList.Count > 0) then
  begin
    json.valueArray('item');
    for i := 0 to elem.itemList.Count - 1 do
      ComposeQuestionnaireResponseItem(json, '', elem.itemList[i]); {z - }
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_QUESTIONNAIRERESPONSE}
{$IFDEF FHIR_RELATEDPERSON}
procedure TFHIRJsonParser.ParseRelatedPersonCommunication(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseRelatedPersonCommunication(jsn)); {2}
end;

function TFHIRJsonParser.ParseRelatedPersonCommunication(jsn : TJsonObject) : TFhirRelatedPersonCommunication;
begin
  result := TFhirRelatedPersonCommunication.create;
  try
    ParseRelatedPersonCommunicationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseRelatedPersonCommunicationProperties(jsn : TJsonObject; result : TFhirRelatedPersonCommunication);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('language') then
        result.language := ParseCodeableConcept(jsn.vObj['language']);{q3}
    if jsn.has('preferred') or jsn.has('_preferred') then
        result.preferredElement := parseBoolean(jsn.node['preferred'], jsn.vObj['_preferred']);{q}
end;

procedure TFHIRJsonComposer.ComposeRelatedPersonCommunication(json : TJSONWriter; name : string; elem : TFhirRelatedPersonCommunication; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'language', elem.language); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'preferred', elem.preferredElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'preferred', elem.preferredElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseRelatedPerson(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseRelatedPerson(jsn)); {2}
end;

function TFHIRJsonParser.ParseRelatedPerson(jsn : TJsonObject) : TFhirRelatedPerson;
begin
  result := TFhirRelatedPerson.create;
  try
    ParseRelatedPersonProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseRelatedPersonProperties(jsn : TJsonObject; result : TFhirRelatedPerson);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('active') or jsn.has('_active') then
        result.activeElement := parseBoolean(jsn.node['active'], jsn.vObj['_active']);{q}
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q3}
    if jsn.has('relationship') then
      iterateArray(jsn.vArr['relationship'], result.relationshipList, parseCodeableConcept);
    if jsn.has('name') then
      iterateArray(jsn.vArr['name'], result.nameList, parseHumanName);
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    if jsn.has('gender') or jsn.has('_gender')  then
      result.genderElement := parseEnum(jsn.path+'/gender', jsn.node['gender'], jsn.vObj['_gender'], CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum);
    if jsn.has('birthDate') or jsn.has('_birthDate') then
        result.birthDateElement := parseDate(jsn.node['birthDate'], jsn.vObj['_birthDate']);{q}
    if jsn.has('address') then
      iterateArray(jsn.vArr['address'], result.addressList, parseAddress);
    if jsn.has('photo') then
      iterateArray(jsn.vArr['photo'], result.photoList, parseAttachment);
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q3}
    if jsn.has('communication') then
      iterateArray(jsn.vArr['communication'], result.communicationList, parseRelatedPersonCommunication);
end;

procedure TFHIRJsonComposer.ComposeRelatedPerson(json : TJSONWriter; name : string; elem : TFhirRelatedPerson; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('active') then
    ComposeBooleanValue(json, 'active', elem.activeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('active') then
    ComposeBooleanProps(json, 'active', elem.activeElement, false);
  ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('relationship') and (elem.relationshipList.Count > 0) then
  begin
    json.valueArray('relationship');
    for i := 0 to elem.relationshipList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.relationshipList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') and (elem.nameList.Count > 0) then
  begin
    json.valueArray('name');
    for i := 0 to elem.nameList.Count - 1 do
      ComposeHumanName(json, '', elem.nameList[i]); {z - HumanName}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('telecom') and (elem.telecomList.Count > 0) then
  begin
    json.valueArray('telecom');
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '', elem.telecomList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('gender') then
    ComposeEnumValue(json, 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('gender') then
    ComposeEnumProps(json, 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('birthDate') then
    ComposeDateValue(json, 'birthDate', elem.birthDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('birthDate') then
    ComposeDateProps(json, 'birthDate', elem.birthDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('address') and (elem.addressList.Count > 0) then
  begin
    json.valueArray('address');
    for i := 0 to elem.addressList.Count - 1 do
      ComposeAddress(json, '', elem.addressList[i]); {z - Address}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('photo') and (elem.photoList.Count > 0) then
  begin
    json.valueArray('photo');
    for i := 0 to elem.photoList.Count - 1 do
      ComposeAttachment(json, '', elem.photoList[i]); {z - Attachment}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('period') then
    ComposePeriod(json, 'period', elem.period); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('communication') and (elem.communicationList.Count > 0) then
  begin
    json.valueArray('communication');
    for i := 0 to elem.communicationList.Count - 1 do
      ComposeRelatedPersonCommunication(json, '', elem.communicationList[i]); {z - }
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_RELATEDPERSON}
{$IFDEF FHIR_REQUESTGROUP}
procedure TFHIRJsonParser.ParseRequestGroupAction(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseRequestGroupAction(jsn)); {2}
end;

function TFHIRJsonParser.ParseRequestGroupAction(jsn : TJsonObject) : TFhirRequestGroupAction;
begin
  result := TFhirRequestGroupAction.create;
  try
    ParseRequestGroupActionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseRequestGroupActionProperties(jsn : TJsonObject; result : TFhirRequestGroupAction);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('prefix') or jsn.has('_prefix') then
        result.prefixElement := parseString(jsn.node['prefix'], jsn.vObj['_prefix']);{q}
    if jsn.has('title') or jsn.has('_title') then
        result.titleElement := parseString(jsn.node['title'], jsn.vObj['_title']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('textEquivalent') or jsn.has('_textEquivalent') then
        result.textEquivalentElement := parseString(jsn.node['textEquivalent'], jsn.vObj['_textEquivalent']);{q}
    if jsn.has('priority') or jsn.has('_priority')  then
      result.priorityElement := parseEnum(jsn.path+'/priority', jsn.node['priority'], jsn.vObj['_priority'], CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum);
    if jsn.has('code') then
      iterateArray(jsn.vArr['code'], result.codeList, parseCodeableConcept);
    if jsn.has('documentation') then
      iterateArray(jsn.vArr['documentation'], result.documentationList, parseRelatedArtifact);
    if jsn.has('condition') then
      iterateArray(jsn.vArr['condition'], result.conditionList, parseRequestGroupActionCondition);
    if jsn.has('relatedAction') then
      iterateArray(jsn.vArr['relatedAction'], result.relatedActionList, parseRequestGroupActionRelatedAction);
    if jsn.has('timingAge') {a4} then
      result.timing := ParseAge(jsn.vObj['timingAge']);
    if jsn.has('timingPeriod') {a4} then
      result.timing := ParsePeriod(jsn.vObj['timingPeriod']);
    if jsn.has('timingDuration') {a4} then
      result.timing := ParseDuration(jsn.vObj['timingDuration']);
    if jsn.has('timingRange') {a4} then
      result.timing := ParseRange(jsn.vObj['timingRange']);
    if jsn.has('timingTiming') {a4} then
      result.timing := ParseTiming(jsn.vObj['timingTiming']);
    if jsn.has('timingDateTime') or jsn.has('_timingDateTime') then
      result.timing := parseDateTime(jsn.node['timingDateTime'], jsn.vObj['_timingDateTime']);
    if jsn.has('participant') then
      iterateArray(jsn.vArr['participant'], result.participantList, parseReference{TFhirPatient});
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('groupingBehavior') or jsn.has('_groupingBehavior')  then
      result.groupingBehaviorElement := parseEnum(jsn.path+'/groupingBehavior', jsn.node['groupingBehavior'], jsn.vObj['_groupingBehavior'], CODES_TFhirActionGroupingBehaviorEnum, SYSTEMS_TFhirActionGroupingBehaviorEnum);
    if jsn.has('selectionBehavior') or jsn.has('_selectionBehavior')  then
      result.selectionBehaviorElement := parseEnum(jsn.path+'/selectionBehavior', jsn.node['selectionBehavior'], jsn.vObj['_selectionBehavior'], CODES_TFhirActionSelectionBehaviorEnum, SYSTEMS_TFhirActionSelectionBehaviorEnum);
    if jsn.has('requiredBehavior') or jsn.has('_requiredBehavior')  then
      result.requiredBehaviorElement := parseEnum(jsn.path+'/requiredBehavior', jsn.node['requiredBehavior'], jsn.vObj['_requiredBehavior'], CODES_TFhirActionRequiredBehaviorEnum, SYSTEMS_TFhirActionRequiredBehaviorEnum);
    if jsn.has('precheckBehavior') or jsn.has('_precheckBehavior')  then
      result.precheckBehaviorElement := parseEnum(jsn.path+'/precheckBehavior', jsn.node['precheckBehavior'], jsn.vObj['_precheckBehavior'], CODES_TFhirActionPrecheckBehaviorEnum, SYSTEMS_TFhirActionPrecheckBehaviorEnum);
    if jsn.has('cardinalityBehavior') or jsn.has('_cardinalityBehavior')  then
      result.cardinalityBehaviorElement := parseEnum(jsn.path+'/cardinalityBehavior', jsn.node['cardinalityBehavior'], jsn.vObj['_cardinalityBehavior'], CODES_TFhirActionCardinalityBehaviorEnum, SYSTEMS_TFhirActionCardinalityBehaviorEnum);
    if jsn.has('resource') then
        result.resource := ParseReference{TFhirReference}(jsn.vObj['resource']);{q3}
    if jsn.has('action') then
      iterateArray(jsn.vArr['action'], result.actionList, parseRequestGroupAction);
end;

procedure TFHIRJsonComposer.ComposeRequestGroupAction(json : TJSONWriter; name : string; elem : TFhirRequestGroupAction; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'prefix', elem.prefixElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'prefix', elem.prefixElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'textEquivalent', elem.textEquivalentElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'textEquivalent', elem.textEquivalentElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumValue(json, 'priority', elem.PriorityElement, CODES_TFhirRequestPriorityEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumProps(json, 'priority', elem.PriorityElement, CODES_TFhirRequestPriorityEnum, false);
  if (SummaryOption in [soFull, soData]) and (elem.codeList.Count > 0) then
  begin
    json.valueArray('code');
    for i := 0 to elem.codeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.codeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.documentationList.Count > 0) then
  begin
    json.valueArray('documentation');
    for i := 0 to elem.documentationList.Count - 1 do
      ComposeRelatedArtifact(json, '', elem.documentationList[i]); {z - RelatedArtifact}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.conditionList.Count > 0) then
  begin
    json.valueArray('condition');
    for i := 0 to elem.conditionList.Count - 1 do
      ComposeRequestGroupActionCondition(json, '', elem.conditionList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.relatedActionList.Count > 0) then
  begin
    json.valueArray('relatedAction');
    for i := 0 to elem.relatedActionList.Count - 1 do
      ComposeRequestGroupActionRelatedAction(json, '', elem.relatedActionList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirAge) then 
    ComposeAge(json, 'timingAge', TFhirAge(elem.timing)) 
  else if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirPeriod) then 
    ComposePeriod(json, 'timingPeriod', TFhirPeriod(elem.timing)) 
  else if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirDuration) then 
    ComposeDuration(json, 'timingDuration', TFhirDuration(elem.timing)) 
  else if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirRange) then 
    ComposeRange(json, 'timingRange', TFhirRange(elem.timing)) 
  else if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirTiming) then 
    ComposeTiming(json, 'timingTiming', TFhirTiming(elem.timing)) 
  else if (SummaryOption in [soFull, soData]) and (elem.timing is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'timingDateTime', TFhirDateTime(elem.timing), false);
    ComposeDateTimeProps(json, 'timingDateTime', TFhirDateTime(elem.timing), false);
  end;
  if (SummaryOption in [soFull, soData]) and (elem.participantList.Count > 0) then
  begin
    json.valueArray('participant');
    for i := 0 to elem.participantList.Count - 1 do
      ComposeReference{TFhirPatient}(json, '', elem.participantList[i]); {z - Reference(Patient)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumValue(json, 'groupingBehavior', elem.GroupingBehaviorElement, CODES_TFhirActionGroupingBehaviorEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumProps(json, 'groupingBehavior', elem.GroupingBehaviorElement, CODES_TFhirActionGroupingBehaviorEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumValue(json, 'selectionBehavior', elem.SelectionBehaviorElement, CODES_TFhirActionSelectionBehaviorEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumProps(json, 'selectionBehavior', elem.SelectionBehaviorElement, CODES_TFhirActionSelectionBehaviorEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumValue(json, 'requiredBehavior', elem.RequiredBehaviorElement, CODES_TFhirActionRequiredBehaviorEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumProps(json, 'requiredBehavior', elem.RequiredBehaviorElement, CODES_TFhirActionRequiredBehaviorEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumValue(json, 'precheckBehavior', elem.PrecheckBehaviorElement, CODES_TFhirActionPrecheckBehaviorEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumProps(json, 'precheckBehavior', elem.PrecheckBehaviorElement, CODES_TFhirActionPrecheckBehaviorEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumValue(json, 'cardinalityBehavior', elem.CardinalityBehaviorElement, CODES_TFhirActionCardinalityBehaviorEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumProps(json, 'cardinalityBehavior', elem.CardinalityBehaviorElement, CODES_TFhirActionCardinalityBehaviorEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirReference}(json, 'resource', elem.resource); {a}
  if (SummaryOption in [soFull, soData]) and (elem.actionList.Count > 0) then
  begin
    json.valueArray('action');
    for i := 0 to elem.actionList.Count - 1 do
      ComposeRequestGroupAction(json, '', elem.actionList[i]); {z - @RequestGroup.action}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseRequestGroupActionCondition(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseRequestGroupActionCondition(jsn)); {2}
end;

function TFHIRJsonParser.ParseRequestGroupActionCondition(jsn : TJsonObject) : TFhirRequestGroupActionCondition;
begin
  result := TFhirRequestGroupActionCondition.create;
  try
    ParseRequestGroupActionConditionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseRequestGroupActionConditionProperties(jsn : TJsonObject; result : TFhirRequestGroupActionCondition);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('kind') or jsn.has('_kind')  then
      result.kindElement := parseEnum(jsn.path+'/kind', jsn.node['kind'], jsn.vObj['_kind'], CODES_TFhirActionConditionKindEnum, SYSTEMS_TFhirActionConditionKindEnum);
    if jsn.has('expression') then
        result.expression := ParseExpression(jsn.vObj['expression']);{q3}
end;

procedure TFHIRJsonComposer.ComposeRequestGroupActionCondition(json : TJSONWriter; name : string; elem : TFhirRequestGroupActionCondition; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'kind', elem.KindElement, CODES_TFhirActionConditionKindEnum, false);
  ComposeEnumProps(json, 'kind', elem.KindElement, CODES_TFhirActionConditionKindEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeExpression(json, 'expression', elem.expression); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseRequestGroupActionRelatedAction(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseRequestGroupActionRelatedAction(jsn)); {2}
end;

function TFHIRJsonParser.ParseRequestGroupActionRelatedAction(jsn : TJsonObject) : TFhirRequestGroupActionRelatedAction;
begin
  result := TFhirRequestGroupActionRelatedAction.create;
  try
    ParseRequestGroupActionRelatedActionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseRequestGroupActionRelatedActionProperties(jsn : TJsonObject; result : TFhirRequestGroupActionRelatedAction);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('actionId') or jsn.has('_actionId') then
        result.actionIdElement := parseId(jsn.node['actionId'], jsn.vObj['_actionId']);{q}
    if jsn.has('relationship') or jsn.has('_relationship')  then
      result.relationshipElement := parseEnum(jsn.path+'/relationship', jsn.node['relationship'], jsn.vObj['_relationship'], CODES_TFhirActionRelationshipTypeEnum, SYSTEMS_TFhirActionRelationshipTypeEnum);
    if jsn.has('offsetDuration') {a4} then
      result.offset := ParseDuration(jsn.vObj['offsetDuration']);
    if jsn.has('offsetRange') {a4} then
      result.offset := ParseRange(jsn.vObj['offsetRange']);
end;

procedure TFHIRJsonComposer.ComposeRequestGroupActionRelatedAction(json : TJSONWriter; name : string; elem : TFhirRequestGroupActionRelatedAction; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeIdValue(json, 'actionId', elem.actionIdElement, false);
  ComposeIdProps(json, 'actionId', elem.actionIdElement, false);
  ComposeEnumValue(json, 'relationship', elem.RelationshipElement, CODES_TFhirActionRelationshipTypeEnum, false);
  ComposeEnumProps(json, 'relationship', elem.RelationshipElement, CODES_TFhirActionRelationshipTypeEnum, false);
  if (SummaryOption in [soFull, soData]) and (elem.offset is TFhirDuration) then 
    ComposeDuration(json, 'offsetDuration', TFhirDuration(elem.offset)) 
  else if (SummaryOption in [soFull, soData]) and (elem.offset is TFhirRange) then 
    ComposeRange(json, 'offsetRange', TFhirRange(elem.offset)) ;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseRequestGroup(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseRequestGroup(jsn)); {2}
end;

function TFHIRJsonParser.ParseRequestGroup(jsn : TJsonObject) : TFhirRequestGroup;
begin
  result := TFhirRequestGroup.create;
  try
    ParseRequestGroupProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseRequestGroupProperties(jsn : TJsonObject; result : TFhirRequestGroup);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
      if jsn.has('instantiatesCanonical') or jsn.has('_instantiatesCanonical') then
      iteratePrimitiveArray(jsn.vArr['instantiatesCanonical'], jsn.vArr['_instantiatesCanonical'], result.instantiatesCanonicalList, parseCanonical);
      if jsn.has('instantiatesUri') or jsn.has('_instantiatesUri') then
      iteratePrimitiveArray(jsn.vArr['instantiatesUri'], jsn.vArr['_instantiatesUri'], result.instantiatesUriList, parseUri);
    if jsn.has('basedOn') then
      iterateArray(jsn.vArr['basedOn'], result.basedOnList, parseReference{TFhirReference});
    if jsn.has('replaces') then
      iterateArray(jsn.vArr['replaces'], result.replacesList, parseReference{TFhirReference});
    if jsn.has('groupIdentifier') then
        result.groupIdentifier := ParseIdentifier(jsn.vObj['groupIdentifier']);{q3}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirRequestStatusEnum, SYSTEMS_TFhirRequestStatusEnum);
    if jsn.has('intent') or jsn.has('_intent')  then
      result.intentElement := parseEnum(jsn.path+'/intent', jsn.node['intent'], jsn.vObj['_intent'], CODES_TFhirRequestIntentEnum, SYSTEMS_TFhirRequestIntentEnum);
    if jsn.has('priority') or jsn.has('_priority')  then
      result.priorityElement := parseEnum(jsn.path+'/priority', jsn.node['priority'], jsn.vObj['_priority'], CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirPatient}(jsn.vObj['subject']);{q3}
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q3}
    if jsn.has('authoredOn') or jsn.has('_authoredOn') then
        result.authoredOnElement := parseDateTime(jsn.node['authoredOn'], jsn.vObj['_authoredOn']);{q}
    if jsn.has('author') then
        result.author := ParseReference{TFhirDevice}(jsn.vObj['author']);{q3}
    if jsn.has('reasonCode') then
      iterateArray(jsn.vArr['reasonCode'], result.reasonCodeList, parseCodeableConcept);
    if jsn.has('reasonReference') then
      iterateArray(jsn.vArr['reasonReference'], result.reasonReferenceList, parseReference{TFhirCondition});
    if jsn.has('note') then
      iterateArray(jsn.vArr['note'], result.noteList, parseAnnotation);
    if jsn.has('action') then
      iterateArray(jsn.vArr['action'], result.actionList, parseRequestGroupAction);
end;

procedure TFHIRJsonComposer.ComposeRequestGroup(json : TJSONWriter; name : string; elem : TFhirRequestGroup; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('instantiatesCanonical') and (elem.instantiatesCanonicalList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.instantiatesCanonicalList.Count - 1 do
    begin
      ext := ext or ((elem.instantiatesCanonicalList[i].id <> '') or (elem.instantiatesCanonicalList[i].hasExtensionList) {no-comments or (elem.instantiatesCanonicalList[i].hasComments)});
      val := val or (elem.instantiatesCanonicalList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('instantiatesCanonical');
      for i := 0 to elem.instantiatesCanonicalList.Count - 1 do
        ComposeCanonicalValue(json, '',elem.instantiatesCanonicalList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_instantiatesCanonical');
      for i := 0 to elem.instantiatesCanonicalList.Count - 1 do
        ComposeCanonicalProps(json, '',elem.instantiatesCanonicalList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('instantiatesUri') and (elem.instantiatesUriList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.instantiatesUriList.Count - 1 do
    begin
      ext := ext or ((elem.instantiatesUriList[i].id <> '') or (elem.instantiatesUriList[i].hasExtensionList) {no-comments or (elem.instantiatesUriList[i].hasComments)});
      val := val or (elem.instantiatesUriList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('instantiatesUri');
      for i := 0 to elem.instantiatesUriList.Count - 1 do
        ComposeUriValue(json, '',elem.instantiatesUriList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_instantiatesUri');
      for i := 0 to elem.instantiatesUriList.Count - 1 do
        ComposeUriProps(json, '',elem.instantiatesUriList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('basedOn') and (elem.basedOnList.Count > 0) then
  begin
    json.valueArray('basedOn');
    for i := 0 to elem.basedOnList.Count - 1 do
      ComposeReference{TFhirReference}(json, '', elem.basedOnList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('replaces') and (elem.replacesList.Count > 0) then
  begin
    json.valueArray('replaces');
    for i := 0 to elem.replacesList.Count - 1 do
      ComposeReference{TFhirReference}(json, '', elem.replacesList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('groupIdentifier') then
    ComposeIdentifier(json, 'groupIdentifier', elem.groupIdentifier); {a}
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirRequestStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirRequestStatusEnum, false);
  ComposeEnumValue(json, 'intent', elem.IntentElement, CODES_TFhirRequestIntentEnum, false);
  ComposeEnumProps(json, 'intent', elem.IntentElement, CODES_TFhirRequestIntentEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('priority') then
    ComposeEnumValue(json, 'priority', elem.PriorityElement, CODES_TFhirRequestPriorityEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('priority') then
    ComposeEnumProps(json, 'priority', elem.PriorityElement, CODES_TFhirRequestPriorityEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') then
    ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('subject') then
    ComposeReference{TFhirPatient}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('authoredOn') then
    ComposeDateTimeValue(json, 'authoredOn', elem.authoredOnElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('authoredOn') then
    ComposeDateTimeProps(json, 'authoredOn', elem.authoredOnElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('author') then
    ComposeReference{TFhirDevice}(json, 'author', elem.author); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('reasonCode') and (elem.reasonCodeList.Count > 0) then
  begin
    json.valueArray('reasonCode');
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.reasonCodeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('reasonReference') and (elem.reasonReferenceList.Count > 0) then
  begin
    json.valueArray('reasonReference');
    for i := 0 to elem.reasonReferenceList.Count - 1 do
      ComposeReference{TFhirCondition}(json, '', elem.reasonReferenceList[i]); {z - Reference(Condition)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('note') and (elem.noteList.Count > 0) then
  begin
    json.valueArray('note');
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(json, '', elem.noteList[i]); {z - Annotation}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('action') and (elem.actionList.Count > 0) then
  begin
    json.valueArray('action');
    for i := 0 to elem.actionList.Count - 1 do
      ComposeRequestGroupAction(json, '', elem.actionList[i]); {z - }
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_REQUESTGROUP}
{$IFDEF FHIR_RESEARCHDEFINITION}
procedure TFHIRJsonParser.ParseResearchDefinition(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseResearchDefinition(jsn)); {2}
end;

function TFHIRJsonParser.ParseResearchDefinition(jsn : TJsonObject) : TFhirResearchDefinition;
begin
  result := TFhirResearchDefinition.create;
  try
    ParseResearchDefinitionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseResearchDefinitionProperties(jsn : TJsonObject; result : TFhirResearchDefinition);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := parseUri(jsn.node['url'], jsn.vObj['_url']);{q}
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := parseString(jsn.node['version'], jsn.vObj['_version']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('title') or jsn.has('_title') then
        result.titleElement := parseString(jsn.node['title'], jsn.vObj['_title']);{q}
    if jsn.has('shortTitle') or jsn.has('_shortTitle') then
        result.shortTitleElement := parseString(jsn.node['shortTitle'], jsn.vObj['_shortTitle']);{q}
    if jsn.has('subtitle') or jsn.has('_subtitle') then
        result.subtitleElement := parseString(jsn.node['subtitle'], jsn.vObj['_subtitle']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    if jsn.has('experimental') or jsn.has('_experimental') then
        result.experimentalElement := parseBoolean(jsn.node['experimental'], jsn.vObj['_experimental']);{q}
    if jsn.has('subjectCodeableConcept') {a4} then
      result.subject := ParseCodeableConcept(jsn.vObj['subjectCodeableConcept']);
    if jsn.has('subjectReference') {a3} then
      result.subject := ParseReference(jsn.vObj['subjectReference']);
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := parseDateTime(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('publisher') or jsn.has('_publisher') then
        result.publisherElement := parseString(jsn.node['publisher'], jsn.vObj['_publisher']);{q}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseContactDetail);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseMarkdown(jsn.node['description'], jsn.vObj['_description']);{q}
      if jsn.has('comment') or jsn.has('_comment') then
      iteratePrimitiveArray(jsn.vArr['comment'], jsn.vArr['_comment'], result.commentList, parseString);
    if jsn.has('useContext') then
      iterateArray(jsn.vArr['useContext'], result.useContextList, parseUsageContext);
    if jsn.has('jurisdiction') then
      iterateArray(jsn.vArr['jurisdiction'], result.jurisdictionList, parseCodeableConcept);
    if jsn.has('purpose') or jsn.has('_purpose') then
        result.purposeElement := parseMarkdown(jsn.node['purpose'], jsn.vObj['_purpose']);{q}
    if jsn.has('usage') or jsn.has('_usage') then
        result.usageElement := parseString(jsn.node['usage'], jsn.vObj['_usage']);{q}
    if jsn.has('copyright') or jsn.has('_copyright') then
        result.copyrightElement := parseMarkdown(jsn.node['copyright'], jsn.vObj['_copyright']);{q}
    if jsn.has('approvalDate') or jsn.has('_approvalDate') then
        result.approvalDateElement := parseDate(jsn.node['approvalDate'], jsn.vObj['_approvalDate']);{q}
    if jsn.has('lastReviewDate') or jsn.has('_lastReviewDate') then
        result.lastReviewDateElement := parseDate(jsn.node['lastReviewDate'], jsn.vObj['_lastReviewDate']);{q}
    if jsn.has('effectivePeriod') then
        result.effectivePeriod := ParsePeriod(jsn.vObj['effectivePeriod']);{q3}
    if jsn.has('topic') then
      iterateArray(jsn.vArr['topic'], result.topicList, parseCodeableConcept);
    if jsn.has('author') then
      iterateArray(jsn.vArr['author'], result.authorList, parseContactDetail);
    if jsn.has('editor') then
      iterateArray(jsn.vArr['editor'], result.editorList, parseContactDetail);
    if jsn.has('reviewer') then
      iterateArray(jsn.vArr['reviewer'], result.reviewerList, parseContactDetail);
    if jsn.has('endorser') then
      iterateArray(jsn.vArr['endorser'], result.endorserList, parseContactDetail);
    if jsn.has('relatedArtifact') then
      iterateArray(jsn.vArr['relatedArtifact'], result.relatedArtifactList, parseRelatedArtifact);
      if jsn.has('library') or jsn.has('_library') then
      iteratePrimitiveArray(jsn.vArr['library'], jsn.vArr['_library'], result.library_List, parseCanonical);
    if jsn.has('population') then
        result.population := ParseReference{TFhirResearchElementDefinition}(jsn.vObj['population']);{q3}
    if jsn.has('exposure') then
        result.exposure := ParseReference{TFhirResearchElementDefinition}(jsn.vObj['exposure']);{q3}
    if jsn.has('exposureAlternative') then
        result.exposureAlternative := ParseReference{TFhirResearchElementDefinition}(jsn.vObj['exposureAlternative']);{q3}
    if jsn.has('outcome') then
        result.outcome := ParseReference{TFhirResearchElementDefinition}(jsn.vObj['outcome']);{q3}
end;

procedure TFHIRJsonComposer.ComposeResearchDefinition(json : TJSONWriter; name : string; elem : TFhirResearchDefinition; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUriValue(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUriProps(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeStringValue(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeStringProps(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeStringValue(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeStringProps(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('shortTitle') then
    ComposeStringValue(json, 'shortTitle', elem.shortTitleElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('shortTitle') then
    ComposeStringProps(json, 'shortTitle', elem.shortTitleElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('subtitle') then
    ComposeStringValue(json, 'subtitle', elem.subtitleElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('subtitle') then
    ComposeStringProps(json, 'subtitle', elem.subtitleElement, false);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBooleanValue(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBooleanProps(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.subject is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'subjectCodeableConcept', TFhirCodeableConcept(elem.subject)) 
  else if (SummaryOption in [soFull, soData]) and (elem.subject is TFhirReference) then
    ComposeReference(json, 'subjectReference', TFhirReference(elem.subject));
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringValue(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringProps(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') and (elem.contactList.Count > 0) then
  begin
    json.valueArray('contact');
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(json, '', elem.contactList[i]); {z - ContactDetail}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeMarkdownValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeMarkdownProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('comment') and (elem.commentList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.commentList.Count - 1 do
    begin
      ext := ext or ((elem.commentList[i].id <> '') or (elem.commentList[i].hasExtensionList) {no-comments or (elem.commentList[i].hasComments)});
      val := val or (elem.commentList[i].hasPrimitiveValue);
    end;
    if val then
  begin
      json.valueArray('comment');
      for i := 0 to elem.commentList.Count - 1 do
        ComposeStringValue(json, '',elem.commentList[i], true);
    json.FinishArray;
  end;
    if ext then
  begin
      json.valueArray('_comment');
      for i := 0 to elem.commentList.Count - 1 do
        ComposeStringProps(json, '',elem.commentList[i], true);
    json.FinishArray;
  end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') and (elem.useContextList.Count > 0) then
  begin
    json.valueArray('useContext');
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(json, '', elem.useContextList[i]); {z - UsageContext}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') and (elem.jurisdictionList.Count > 0) then
  begin
    json.valueArray('jurisdiction');
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.jurisdictionList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdownValue(json, 'purpose', elem.purposeElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdownProps(json, 'purpose', elem.purposeElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('usage') then
    ComposeStringValue(json, 'usage', elem.usageElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('usage') then
    ComposeStringProps(json, 'usage', elem.usageElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdownValue(json, 'copyright', elem.copyrightElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdownProps(json, 'copyright', elem.copyrightElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('approvalDate') then
    ComposeDateValue(json, 'approvalDate', elem.approvalDateElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('approvalDate') then
    ComposeDateProps(json, 'approvalDate', elem.approvalDateElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('lastReviewDate') then
    ComposeDateValue(json, 'lastReviewDate', elem.lastReviewDateElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('lastReviewDate') then
    ComposeDateProps(json, 'lastReviewDate', elem.lastReviewDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('effectivePeriod') then
    ComposePeriod(json, 'effectivePeriod', elem.effectivePeriod); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('topic') and (elem.topicList.Count > 0) then
  begin
    json.valueArray('topic');
    for i := 0 to elem.topicList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.topicList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('author') and (elem.authorList.Count > 0) then
  begin
    json.valueArray('author');
    for i := 0 to elem.authorList.Count - 1 do
      ComposeContactDetail(json, '', elem.authorList[i]); {z - ContactDetail}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('editor') and (elem.editorList.Count > 0) then
  begin
    json.valueArray('editor');
    for i := 0 to elem.editorList.Count - 1 do
      ComposeContactDetail(json, '', elem.editorList[i]); {z - ContactDetail}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('reviewer') and (elem.reviewerList.Count > 0) then
  begin
    json.valueArray('reviewer');
    for i := 0 to elem.reviewerList.Count - 1 do
      ComposeContactDetail(json, '', elem.reviewerList[i]); {z - ContactDetail}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('endorser') and (elem.endorserList.Count > 0) then
  begin
    json.valueArray('endorser');
    for i := 0 to elem.endorserList.Count - 1 do
      ComposeContactDetail(json, '', elem.endorserList[i]); {z - ContactDetail}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('relatedArtifact') and (elem.relatedArtifactList.Count > 0) then
  begin
    json.valueArray('relatedArtifact');
    for i := 0 to elem.relatedArtifactList.Count - 1 do
      ComposeRelatedArtifact(json, '', elem.relatedArtifactList[i]); {z - RelatedArtifact}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('library_') and (elem.library_List.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.library_List.Count - 1 do
  begin
      ext := ext or ((elem.library_List[i].id <> '') or (elem.library_List[i].hasExtensionList) {no-comments or (elem.library_List[i].hasComments)});
      val := val or (elem.library_List[i].hasPrimitiveValue);
  end;
    if val then
  begin
      json.valueArray('library');
      for i := 0 to elem.library_List.Count - 1 do
        ComposeCanonicalValue(json, '',elem.library_List[i], true);
    json.FinishArray;
  end;
    if ext then
  begin
      json.valueArray('_library');
      for i := 0 to elem.library_List.Count - 1 do
        ComposeCanonicalProps(json, '',elem.library_List[i], true);
    json.FinishArray;
  end;
  end;
  ComposeReference{TFhirResearchElementDefinition}(json, 'population', elem.population); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('exposure') then
    ComposeReference{TFhirResearchElementDefinition}(json, 'exposure', elem.exposure); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('exposureAlternative') then
    ComposeReference{TFhirResearchElementDefinition}(json, 'exposureAlternative', elem.exposureAlternative); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('outcome') then
    ComposeReference{TFhirResearchElementDefinition}(json, 'outcome', elem.outcome); {a}
end;

{$ENDIF FHIR_RESEARCHDEFINITION}
{$IFDEF FHIR_RESEARCHELEMENTDEFINITION}
procedure TFHIRJsonParser.ParseResearchElementDefinitionCharacteristic(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseResearchElementDefinitionCharacteristic(jsn)); {2}
end;

function TFHIRJsonParser.ParseResearchElementDefinitionCharacteristic(jsn : TJsonObject) : TFhirResearchElementDefinitionCharacteristic;
begin
  result := TFhirResearchElementDefinitionCharacteristic.create;
  try
    ParseResearchElementDefinitionCharacteristicProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseResearchElementDefinitionCharacteristicProperties(jsn : TJsonObject; result : TFhirResearchElementDefinitionCharacteristic);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('definitionCodeableConcept') {a4} then
      result.definition := ParseCodeableConcept(jsn.vObj['definitionCodeableConcept']);
    if jsn.has('definitionCanonical') or jsn.has('_definitionCanonical') then
      result.definition := parseCanonical(jsn.node['definitionCanonical'], jsn.vObj['_definitionCanonical']);
    if jsn.has('definitionExpression') {a4} then
      result.definition := ParseExpression(jsn.vObj['definitionExpression']);
    if jsn.has('definitionDataRequirement') {a4} then
      result.definition := ParseDataRequirement(jsn.vObj['definitionDataRequirement']);
    if jsn.has('usageContext') then
      iterateArray(jsn.vArr['usageContext'], result.usageContextList, parseUsageContext);
    if jsn.has('exclude') or jsn.has('_exclude') then
        result.excludeElement := parseBoolean(jsn.node['exclude'], jsn.vObj['_exclude']);{q}
    if jsn.has('unitOfMeasure') then
        result.unitOfMeasure := ParseCodeableConcept(jsn.vObj['unitOfMeasure']);{q3}
    if jsn.has('studyEffectiveDescription') or jsn.has('_studyEffectiveDescription') then
        result.studyEffectiveDescriptionElement := parseString(jsn.node['studyEffectiveDescription'], jsn.vObj['_studyEffectiveDescription']);{q}
    if jsn.has('studyEffectivePeriod') {a4} then
      result.studyEffective := ParsePeriod(jsn.vObj['studyEffectivePeriod']);
    if jsn.has('studyEffectiveDuration') {a4} then
      result.studyEffective := ParseDuration(jsn.vObj['studyEffectiveDuration']);
    if jsn.has('studyEffectiveTiming') {a4} then
      result.studyEffective := ParseTiming(jsn.vObj['studyEffectiveTiming']);
    if jsn.has('studyEffectiveDateTime') or jsn.has('_studyEffectiveDateTime') then
      result.studyEffective := parseDateTime(jsn.node['studyEffectiveDateTime'], jsn.vObj['_studyEffectiveDateTime']);
    if jsn.has('studyEffectiveTimeFromStart') then
        result.studyEffectiveTimeFromStart := ParseDuration(jsn.vObj['studyEffectiveTimeFromStart']);{q3}
    if jsn.has('studyEffectiveGroupMeasure') or jsn.has('_studyEffectiveGroupMeasure')  then
      result.studyEffectiveGroupMeasureElement := parseEnum(jsn.path+'/studyEffectiveGroupMeasure', jsn.node['studyEffectiveGroupMeasure'], jsn.vObj['_studyEffectiveGroupMeasure'], CODES_TFhirGroupMeasureEnum, SYSTEMS_TFhirGroupMeasureEnum);
    if jsn.has('participantEffectiveDescription') or jsn.has('_participantEffectiveDescription') then
        result.participantEffectiveDescriptionElement := parseString(jsn.node['participantEffectiveDescription'], jsn.vObj['_participantEffectiveDescription']);{q}
    if jsn.has('participantEffectivePeriod') {a4} then
      result.participantEffective := ParsePeriod(jsn.vObj['participantEffectivePeriod']);
    if jsn.has('participantEffectiveDuration') {a4} then
      result.participantEffective := ParseDuration(jsn.vObj['participantEffectiveDuration']);
    if jsn.has('participantEffectiveTiming') {a4} then
      result.participantEffective := ParseTiming(jsn.vObj['participantEffectiveTiming']);
    if jsn.has('participantEffectiveDateTime') or jsn.has('_participantEffectiveDateTime') then
      result.participantEffective := parseDateTime(jsn.node['participantEffectiveDateTime'], jsn.vObj['_participantEffectiveDateTime']);
    if jsn.has('participantEffectiveTimeFromStart') then
        result.participantEffectiveTimeFromStart := ParseDuration(jsn.vObj['participantEffectiveTimeFromStart']);{q3}
    if jsn.has('participantEffectiveGroupMeasure') or jsn.has('_participantEffectiveGroupMeasure')  then
      result.participantEffectiveGroupMeasureElement := parseEnum(jsn.path+'/participantEffectiveGroupMeasure', jsn.node['participantEffectiveGroupMeasure'], jsn.vObj['_participantEffectiveGroupMeasure'], CODES_TFhirGroupMeasureEnum, SYSTEMS_TFhirGroupMeasureEnum);
end;

procedure TFHIRJsonComposer.ComposeResearchElementDefinitionCharacteristic(json : TJSONWriter; name : string; elem : TFhirResearchElementDefinitionCharacteristic; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (elem.definition is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'definitionCodeableConcept', TFhirCodeableConcept(elem.definition)) 
  else if (elem.definition is TFhirCanonical) then 
  begin
    ComposeCanonicalValue(json, 'definitionCanonical', TFhirCanonical(elem.definition), false);
    ComposeCanonicalProps(json, 'definitionCanonical', TFhirCanonical(elem.definition), false);
  end
  else if (elem.definition is TFhirExpression) then 
    ComposeExpression(json, 'definitionExpression', TFhirExpression(elem.definition)) 
  else if (elem.definition is TFhirDataRequirement) then 
    ComposeDataRequirement(json, 'definitionDataRequirement', TFhirDataRequirement(elem.definition)) ;
  if (SummaryOption in [soFull, soData]) and (elem.usageContextList.Count > 0) then
  begin
    json.valueArray('usageContext');
    for i := 0 to elem.usageContextList.Count - 1 do
      ComposeUsageContext(json, '', elem.usageContextList[i]); {z - UsageContext}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'exclude', elem.excludeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'exclude', elem.excludeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'unitOfMeasure', elem.unitOfMeasure); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'studyEffectiveDescription', elem.studyEffectiveDescriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'studyEffectiveDescription', elem.studyEffectiveDescriptionElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.studyEffective is TFhirPeriod) then 
    ComposePeriod(json, 'studyEffectivePeriod', TFhirPeriod(elem.studyEffective)) 
  else if (SummaryOption in [soFull, soData]) and (elem.studyEffective is TFhirDuration) then 
    ComposeDuration(json, 'studyEffectiveDuration', TFhirDuration(elem.studyEffective)) 
  else if (SummaryOption in [soFull, soData]) and (elem.studyEffective is TFhirTiming) then 
    ComposeTiming(json, 'studyEffectiveTiming', TFhirTiming(elem.studyEffective)) 
  else if (SummaryOption in [soFull, soData]) and (elem.studyEffective is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'studyEffectiveDateTime', TFhirDateTime(elem.studyEffective), false);
    ComposeDateTimeProps(json, 'studyEffectiveDateTime', TFhirDateTime(elem.studyEffective), false);
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeDuration(json, 'studyEffectiveTimeFromStart', elem.studyEffectiveTimeFromStart); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumValue(json, 'studyEffectiveGroupMeasure', elem.StudyEffectiveGroupMeasureElement, CODES_TFhirGroupMeasureEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumProps(json, 'studyEffectiveGroupMeasure', elem.StudyEffectiveGroupMeasureElement, CODES_TFhirGroupMeasureEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'participantEffectiveDescription', elem.participantEffectiveDescriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'participantEffectiveDescription', elem.participantEffectiveDescriptionElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.participantEffective is TFhirPeriod) then 
    ComposePeriod(json, 'participantEffectivePeriod', TFhirPeriod(elem.participantEffective)) 
  else if (SummaryOption in [soFull, soData]) and (elem.participantEffective is TFhirDuration) then 
    ComposeDuration(json, 'participantEffectiveDuration', TFhirDuration(elem.participantEffective)) 
  else if (SummaryOption in [soFull, soData]) and (elem.participantEffective is TFhirTiming) then 
    ComposeTiming(json, 'participantEffectiveTiming', TFhirTiming(elem.participantEffective)) 
  else if (SummaryOption in [soFull, soData]) and (elem.participantEffective is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'participantEffectiveDateTime', TFhirDateTime(elem.participantEffective), false);
    ComposeDateTimeProps(json, 'participantEffectiveDateTime', TFhirDateTime(elem.participantEffective), false);
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeDuration(json, 'participantEffectiveTimeFromStart', elem.participantEffectiveTimeFromStart); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumValue(json, 'participantEffectiveGroupMeasure', elem.ParticipantEffectiveGroupMeasureElement, CODES_TFhirGroupMeasureEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumProps(json, 'participantEffectiveGroupMeasure', elem.ParticipantEffectiveGroupMeasureElement, CODES_TFhirGroupMeasureEnum, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseResearchElementDefinition(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseResearchElementDefinition(jsn)); {2}
end;

function TFHIRJsonParser.ParseResearchElementDefinition(jsn : TJsonObject) : TFhirResearchElementDefinition;
begin
  result := TFhirResearchElementDefinition.create;
  try
    ParseResearchElementDefinitionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseResearchElementDefinitionProperties(jsn : TJsonObject; result : TFhirResearchElementDefinition);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := parseUri(jsn.node['url'], jsn.vObj['_url']);{q}
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := parseString(jsn.node['version'], jsn.vObj['_version']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('title') or jsn.has('_title') then
        result.titleElement := parseString(jsn.node['title'], jsn.vObj['_title']);{q}
    if jsn.has('shortTitle') or jsn.has('_shortTitle') then
        result.shortTitleElement := parseString(jsn.node['shortTitle'], jsn.vObj['_shortTitle']);{q}
    if jsn.has('subtitle') or jsn.has('_subtitle') then
        result.subtitleElement := parseString(jsn.node['subtitle'], jsn.vObj['_subtitle']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    if jsn.has('experimental') or jsn.has('_experimental') then
        result.experimentalElement := parseBoolean(jsn.node['experimental'], jsn.vObj['_experimental']);{q}
    if jsn.has('subjectCodeableConcept') {a4} then
      result.subject := ParseCodeableConcept(jsn.vObj['subjectCodeableConcept']);
    if jsn.has('subjectReference') {a3} then
      result.subject := ParseReference(jsn.vObj['subjectReference']);
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := parseDateTime(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('publisher') or jsn.has('_publisher') then
        result.publisherElement := parseString(jsn.node['publisher'], jsn.vObj['_publisher']);{q}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseContactDetail);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseMarkdown(jsn.node['description'], jsn.vObj['_description']);{q}
      if jsn.has('comment') or jsn.has('_comment') then
      iteratePrimitiveArray(jsn.vArr['comment'], jsn.vArr['_comment'], result.commentList, parseString);
    if jsn.has('useContext') then
      iterateArray(jsn.vArr['useContext'], result.useContextList, parseUsageContext);
    if jsn.has('jurisdiction') then
      iterateArray(jsn.vArr['jurisdiction'], result.jurisdictionList, parseCodeableConcept);
    if jsn.has('purpose') or jsn.has('_purpose') then
        result.purposeElement := parseMarkdown(jsn.node['purpose'], jsn.vObj['_purpose']);{q}
    if jsn.has('usage') or jsn.has('_usage') then
        result.usageElement := parseString(jsn.node['usage'], jsn.vObj['_usage']);{q}
    if jsn.has('copyright') or jsn.has('_copyright') then
        result.copyrightElement := parseMarkdown(jsn.node['copyright'], jsn.vObj['_copyright']);{q}
    if jsn.has('approvalDate') or jsn.has('_approvalDate') then
        result.approvalDateElement := parseDate(jsn.node['approvalDate'], jsn.vObj['_approvalDate']);{q}
    if jsn.has('lastReviewDate') or jsn.has('_lastReviewDate') then
        result.lastReviewDateElement := parseDate(jsn.node['lastReviewDate'], jsn.vObj['_lastReviewDate']);{q}
    if jsn.has('effectivePeriod') then
        result.effectivePeriod := ParsePeriod(jsn.vObj['effectivePeriod']);{q3}
    if jsn.has('topic') then
      iterateArray(jsn.vArr['topic'], result.topicList, parseCodeableConcept);
    if jsn.has('author') then
      iterateArray(jsn.vArr['author'], result.authorList, parseContactDetail);
    if jsn.has('editor') then
      iterateArray(jsn.vArr['editor'], result.editorList, parseContactDetail);
    if jsn.has('reviewer') then
      iterateArray(jsn.vArr['reviewer'], result.reviewerList, parseContactDetail);
    if jsn.has('endorser') then
      iterateArray(jsn.vArr['endorser'], result.endorserList, parseContactDetail);
    if jsn.has('relatedArtifact') then
      iterateArray(jsn.vArr['relatedArtifact'], result.relatedArtifactList, parseRelatedArtifact);
      if jsn.has('library') or jsn.has('_library') then
      iteratePrimitiveArray(jsn.vArr['library'], jsn.vArr['_library'], result.library_List, parseCanonical);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn.node['type'], jsn.vObj['_type'], CODES_TFhirResearchElementTypeEnum, SYSTEMS_TFhirResearchElementTypeEnum);
    if jsn.has('variableType') or jsn.has('_variableType')  then
      result.variableTypeElement := parseEnum(jsn.path+'/variableType', jsn.node['variableType'], jsn.vObj['_variableType'], CODES_TFhirVariableTypeEnum, SYSTEMS_TFhirVariableTypeEnum);
    if jsn.has('characteristic') then
      iterateArray(jsn.vArr['characteristic'], result.characteristicList, parseResearchElementDefinitionCharacteristic);
end;

procedure TFHIRJsonComposer.ComposeResearchElementDefinition(json : TJSONWriter; name : string; elem : TFhirResearchElementDefinition; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
  ComposeUriValue(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
  ComposeUriProps(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeStringValue(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeStringProps(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
  ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
  ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeStringValue(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeStringProps(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('shortTitle') then
    ComposeStringValue(json, 'shortTitle', elem.shortTitleElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('shortTitle') then
    ComposeStringProps(json, 'shortTitle', elem.shortTitleElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('subtitle') then
    ComposeStringValue(json, 'subtitle', elem.subtitleElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('subtitle') then
    ComposeStringProps(json, 'subtitle', elem.subtitleElement, false);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBooleanValue(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBooleanProps(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.subject is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'subjectCodeableConcept', TFhirCodeableConcept(elem.subject)) 
  else if (SummaryOption in [soFull, soData]) and (elem.subject is TFhirReference) then
    ComposeReference(json, 'subjectReference', TFhirReference(elem.subject));
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringValue(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringProps(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') and (elem.contactList.Count > 0) then
  begin
    json.valueArray('contact');
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(json, '', elem.contactList[i]); {z - ContactDetail}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
  ComposeMarkdownValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
  ComposeMarkdownProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('comment') and (elem.commentList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.commentList.Count - 1 do
    begin
      ext := ext or ((elem.commentList[i].id <> '') or (elem.commentList[i].hasExtensionList) {no-comments or (elem.commentList[i].hasComments)});
      val := val or (elem.commentList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('comment');
      for i := 0 to elem.commentList.Count - 1 do
        ComposeStringValue(json, '',elem.commentList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_comment');
      for i := 0 to elem.commentList.Count - 1 do
        ComposeStringProps(json, '',elem.commentList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') and (elem.useContextList.Count > 0) then
  begin
    json.valueArray('useContext');
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(json, '', elem.useContextList[i]); {z - UsageContext}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') and (elem.jurisdictionList.Count > 0) then
  begin
    json.valueArray('jurisdiction');
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.jurisdictionList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdownValue(json, 'purpose', elem.purposeElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdownProps(json, 'purpose', elem.purposeElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('usage') then
    ComposeStringValue(json, 'usage', elem.usageElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('usage') then
    ComposeStringProps(json, 'usage', elem.usageElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdownValue(json, 'copyright', elem.copyrightElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdownProps(json, 'copyright', elem.copyrightElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('approvalDate') then
    ComposeDateValue(json, 'approvalDate', elem.approvalDateElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('approvalDate') then
    ComposeDateProps(json, 'approvalDate', elem.approvalDateElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('lastReviewDate') then
    ComposeDateValue(json, 'lastReviewDate', elem.lastReviewDateElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('lastReviewDate') then
    ComposeDateProps(json, 'lastReviewDate', elem.lastReviewDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('effectivePeriod') then
    ComposePeriod(json, 'effectivePeriod', elem.effectivePeriod); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('topic') and (elem.topicList.Count > 0) then
  begin
    json.valueArray('topic');
    for i := 0 to elem.topicList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.topicList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('author') and (elem.authorList.Count > 0) then
    begin
    json.valueArray('author');
    for i := 0 to elem.authorList.Count - 1 do
      ComposeContactDetail(json, '', elem.authorList[i]); {z - ContactDetail}
    json.FinishArray;
    end;
  if (SummaryOption in [soFull, soData]) and doCompose('editor') and (elem.editorList.Count > 0) then
    begin
    json.valueArray('editor');
    for i := 0 to elem.editorList.Count - 1 do
      ComposeContactDetail(json, '', elem.editorList[i]); {z - ContactDetail}
      json.FinishArray;
    end;
  if (SummaryOption in [soFull, soData]) and doCompose('reviewer') and (elem.reviewerList.Count > 0) then
    begin
    json.valueArray('reviewer');
    for i := 0 to elem.reviewerList.Count - 1 do
      ComposeContactDetail(json, '', elem.reviewerList[i]); {z - ContactDetail}
      json.FinishArray;
    end;
  if (SummaryOption in [soFull, soData]) and doCompose('endorser') and (elem.endorserList.Count > 0) then
  begin
    json.valueArray('endorser');
    for i := 0 to elem.endorserList.Count - 1 do
      ComposeContactDetail(json, '', elem.endorserList[i]); {z - ContactDetail}
      json.FinishArray;
    end;
  if (SummaryOption in [soFull, soData]) and doCompose('relatedArtifact') and (elem.relatedArtifactList.Count > 0) then
    begin
    json.valueArray('relatedArtifact');
    for i := 0 to elem.relatedArtifactList.Count - 1 do
      ComposeRelatedArtifact(json, '', elem.relatedArtifactList[i]); {z - RelatedArtifact}
      json.FinishArray;
    end;
  if (SummaryOption in [soFull, soData]) and doCompose('library_') and (elem.library_List.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.library_List.Count - 1 do
    begin
      ext := ext or ((elem.library_List[i].id <> '') or (elem.library_List[i].hasExtensionList) {no-comments or (elem.library_List[i].hasComments)});
      val := val or (elem.library_List[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('library');
      for i := 0 to elem.library_List.Count - 1 do
        ComposeCanonicalValue(json, '',elem.library_List[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_library');
      for i := 0 to elem.library_List.Count - 1 do
        ComposeCanonicalProps(json, '',elem.library_List[i], true);
      json.FinishArray;
    end;
  end;
  ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirResearchElementTypeEnum, false);
  ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirResearchElementTypeEnum, false);
  if (SummaryOption in [soFull, soData]) and doCompose('variableType') then
    ComposeEnumValue(json, 'variableType', elem.VariableTypeElement, CODES_TFhirVariableTypeEnum, false);
  if (SummaryOption in [soFull, soData]) and doCompose('variableType') then
    ComposeEnumProps(json, 'variableType', elem.VariableTypeElement, CODES_TFhirVariableTypeEnum, false);
  if (elem.characteristicList.Count > 0) then
  begin
    json.valueArray('characteristic');
    for i := 0 to elem.characteristicList.Count - 1 do
      ComposeResearchElementDefinitionCharacteristic(json, '', elem.characteristicList[i]); {z - }
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_RESEARCHELEMENTDEFINITION}
{$IFDEF FHIR_RESEARCHSTUDY}
procedure TFHIRJsonParser.ParseResearchStudyArm(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseResearchStudyArm(jsn)); {2}
end;

function TFHIRJsonParser.ParseResearchStudyArm(jsn : TJsonObject) : TFhirResearchStudyArm;
begin
  result := TFhirResearchStudyArm.create;
  try
    ParseResearchStudyArmProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseResearchStudyArmProperties(jsn : TJsonObject; result : TFhirResearchStudyArm);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseString(jsn.node['description'], jsn.vObj['_description']);{q}
end;

procedure TFHIRJsonComposer.ComposeResearchStudyArm(json : TJSONWriter; name : string; elem : TFhirResearchStudyArm; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'name', elem.nameElement, false);
  ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseResearchStudyObjective(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseResearchStudyObjective(jsn)); {2}
end;

function TFHIRJsonParser.ParseResearchStudyObjective(jsn : TJsonObject) : TFhirResearchStudyObjective;
begin
  result := TFhirResearchStudyObjective.create;
  try
    ParseResearchStudyObjectiveProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseResearchStudyObjectiveProperties(jsn : TJsonObject; result : TFhirResearchStudyObjective);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
end;

procedure TFHIRJsonComposer.ComposeResearchStudyObjective(json : TJSONWriter; name : string; elem : TFhirResearchStudyObjective; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseResearchStudy(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseResearchStudy(jsn)); {2}
end;

function TFHIRJsonParser.ParseResearchStudy(jsn : TJsonObject) : TFhirResearchStudy;
begin
  result := TFhirResearchStudy.create;
  try
    ParseResearchStudyProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseResearchStudyProperties(jsn : TJsonObject; result : TFhirResearchStudy);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('title') or jsn.has('_title') then
        result.titleElement := parseString(jsn.node['title'], jsn.vObj['_title']);{q}
    if jsn.has('protocol') then
      iterateArray(jsn.vArr['protocol'], result.protocolList, parseReference{TFhirPlanDefinition});
    if jsn.has('partOf') then
      iterateArray(jsn.vArr['partOf'], result.partOfList, parseReference{TFhirResearchStudy});
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirResearchStudyStatusEnum, SYSTEMS_TFhirResearchStudyStatusEnum);
    if jsn.has('primaryPurposeType') then
        result.primaryPurposeType := ParseCodeableConcept(jsn.vObj['primaryPurposeType']);{q3}
    if jsn.has('phase') then
        result.phase := ParseCodeableConcept(jsn.vObj['phase']);{q3}
    if jsn.has('category') then
      iterateArray(jsn.vArr['category'], result.categoryList, parseCodeableConcept);
    if jsn.has('focus') then
      iterateArray(jsn.vArr['focus'], result.focusList, parseCodeableConcept);
    if jsn.has('condition') then
      iterateArray(jsn.vArr['condition'], result.conditionList, parseCodeableConcept);
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseContactDetail);
    if jsn.has('relatedArtifact') then
      iterateArray(jsn.vArr['relatedArtifact'], result.relatedArtifactList, parseRelatedArtifact);
    if jsn.has('keyword') then
      iterateArray(jsn.vArr['keyword'], result.keywordList, parseCodeableConcept);
    if jsn.has('location') then
      iterateArray(jsn.vArr['location'], result.locationList, parseCodeableConcept);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseMarkdown(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('enrollment') then
      iterateArray(jsn.vArr['enrollment'], result.enrollmentList, parseReference{TFhirGroup});
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q3}
    if jsn.has('sponsor') then
        result.sponsor := ParseReference{TFhirOrganization}(jsn.vObj['sponsor']);{q3}
    if jsn.has('principalInvestigator') then
        result.principalInvestigator := ParseReference{TFhirPractitioner}(jsn.vObj['principalInvestigator']);{q3}
    if jsn.has('site') then
      iterateArray(jsn.vArr['site'], result.siteList, parseReference{TFhirLocation});
    if jsn.has('reasonStopped') then
        result.reasonStopped := ParseCodeableConcept(jsn.vObj['reasonStopped']);{q3}
    if jsn.has('note') then
      iterateArray(jsn.vArr['note'], result.noteList, parseAnnotation);
    if jsn.has('arm') then
      iterateArray(jsn.vArr['arm'], result.armList, parseResearchStudyArm);
    if jsn.has('objective') then
      iterateArray(jsn.vArr['objective'], result.objectiveList, parseResearchStudyObjective);
end;

procedure TFHIRJsonComposer.ComposeResearchStudy(json : TJSONWriter; name : string; elem : TFhirResearchStudy; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeStringValue(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeStringProps(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('protocol') and (elem.protocolList.Count > 0) then
    begin
    json.valueArray('protocol');
    for i := 0 to elem.protocolList.Count - 1 do
      ComposeReference{TFhirPlanDefinition}(json, '', elem.protocolList[i]); {z - Reference(PlanDefinition)}
    json.FinishArray;
    end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('partOf') and (elem.partOfList.Count > 0) then
    begin
    json.valueArray('partOf');
    for i := 0 to elem.partOfList.Count - 1 do
      ComposeReference{TFhirResearchStudy}(json, '', elem.partOfList[i]); {z - Reference(ResearchStudy)}
      json.FinishArray;
    end;
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirResearchStudyStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirResearchStudyStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('primaryPurposeType') then
    ComposeCodeableConcept(json, 'primaryPurposeType', elem.primaryPurposeType); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('phase') then
    ComposeCodeableConcept(json, 'phase', elem.phase); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') and (elem.categoryList.Count > 0) then
    begin
    json.valueArray('category');
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.categoryList[i]); {z - CodeableConcept}
      json.FinishArray;
    end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('focus') and (elem.focusList.Count > 0) then
  begin
    json.valueArray('focus');
    for i := 0 to elem.focusList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.focusList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('condition') and (elem.conditionList.Count > 0) then
  begin
    json.valueArray('condition');
    for i := 0 to elem.conditionList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.conditionList[i]); {z - CodeableConcept}
    json.FinishArray;
    end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') and (elem.contactList.Count > 0) then
    begin
    json.valueArray('contact');
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(json, '', elem.contactList[i]); {z - ContactDetail}
      json.FinishArray;
    end;
  if (SummaryOption in [soFull, soData]) and doCompose('relatedArtifact') and (elem.relatedArtifactList.Count > 0) then
    begin
    json.valueArray('relatedArtifact');
    for i := 0 to elem.relatedArtifactList.Count - 1 do
      ComposeRelatedArtifact(json, '', elem.relatedArtifactList[i]); {z - RelatedArtifact}
      json.FinishArray;
    end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('keyword') and (elem.keywordList.Count > 0) then
  begin
    json.valueArray('keyword');
    for i := 0 to elem.keywordList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.keywordList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('location') and (elem.locationList.Count > 0) then
    begin
    json.valueArray('location');
    for i := 0 to elem.locationList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.locationList[i]); {z - CodeableConcept}
    json.FinishArray;
    end;
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdownValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdownProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('enrollment') and (elem.enrollmentList.Count > 0) then
    begin
    json.valueArray('enrollment');
    for i := 0 to elem.enrollmentList.Count - 1 do
      ComposeReference{TFhirGroup}(json, '', elem.enrollmentList[i]); {z - Reference(Group)}
      json.FinishArray;
    end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('period') then
    ComposePeriod(json, 'period', elem.period); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('sponsor') then
    ComposeReference{TFhirOrganization}(json, 'sponsor', elem.sponsor); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('principalInvestigator') then
    ComposeReference{TFhirPractitioner}(json, 'principalInvestigator', elem.principalInvestigator); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('site') and (elem.siteList.Count > 0) then
    begin
    json.valueArray('site');
    for i := 0 to elem.siteList.Count - 1 do
      ComposeReference{TFhirLocation}(json, '', elem.siteList[i]); {z - Reference(Location)}
      json.FinishArray;
    end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonStopped') then
    ComposeCodeableConcept(json, 'reasonStopped', elem.reasonStopped); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('note') and (elem.noteList.Count > 0) then
  begin
    json.valueArray('note');
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(json, '', elem.noteList[i]); {z - Annotation}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('arm') and (elem.armList.Count > 0) then
  begin
    json.valueArray('arm');
    for i := 0 to elem.armList.Count - 1 do
      ComposeResearchStudyArm(json, '', elem.armList[i]); {z - }
    json.FinishArray;
    end;
  if (SummaryOption in [soFull, soData]) and doCompose('objective') and (elem.objectiveList.Count > 0) then
    begin
    json.valueArray('objective');
    for i := 0 to elem.objectiveList.Count - 1 do
      ComposeResearchStudyObjective(json, '', elem.objectiveList[i]); {z - }
      json.FinishArray;
    end;
end;

{$ENDIF FHIR_RESEARCHSTUDY}
{$IFDEF FHIR_RESEARCHSUBJECT}
procedure TFHIRJsonParser.ParseResearchSubject(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseResearchSubject(jsn)); {2}
end;

function TFHIRJsonParser.ParseResearchSubject(jsn : TJsonObject) : TFhirResearchSubject;
begin
  result := TFhirResearchSubject.create;
  try
    ParseResearchSubjectProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseResearchSubjectProperties(jsn : TJsonObject; result : TFhirResearchSubject);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirResearchSubjectStatusEnum, SYSTEMS_TFhirResearchSubjectStatusEnum);
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q3}
    if jsn.has('study') then
        result.study := ParseReference{TFhirResearchStudy}(jsn.vObj['study']);{q3}
    if jsn.has('individual') then
        result.individual := ParseReference{TFhirPatient}(jsn.vObj['individual']);{q3}
    if jsn.has('assignedArm') or jsn.has('_assignedArm') then
        result.assignedArmElement := parseString(jsn.node['assignedArm'], jsn.vObj['_assignedArm']);{q}
    if jsn.has('actualArm') or jsn.has('_actualArm') then
        result.actualArmElement := parseString(jsn.node['actualArm'], jsn.vObj['_actualArm']);{q}
    if jsn.has('consent') then
        result.consent := ParseReference{TFhirConsent}(jsn.vObj['consent']);{q3}
end;

procedure TFHIRJsonComposer.ComposeResearchSubject(json : TJSONWriter; name : string; elem : TFhirResearchSubject; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
    begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
      json.FinishArray;
    end;
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirResearchSubjectStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirResearchSubjectStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('period') then
    ComposePeriod(json, 'period', elem.period); {a}
  ComposeReference{TFhirResearchStudy}(json, 'study', elem.study); {a}
  ComposeReference{TFhirPatient}(json, 'individual', elem.individual); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('assignedArm') then
    ComposeStringValue(json, 'assignedArm', elem.assignedArmElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('assignedArm') then
    ComposeStringProps(json, 'assignedArm', elem.assignedArmElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('actualArm') then
    ComposeStringValue(json, 'actualArm', elem.actualArmElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('actualArm') then
    ComposeStringProps(json, 'actualArm', elem.actualArmElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('consent') then
    ComposeReference{TFhirConsent}(json, 'consent', elem.consent); {a}
end;

{$ENDIF FHIR_RESEARCHSUBJECT}
{$IFDEF FHIR_RISKASSESSMENT}
procedure TFHIRJsonParser.ParseRiskAssessmentPrediction(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseRiskAssessmentPrediction(jsn)); {2}
end;

function TFHIRJsonParser.ParseRiskAssessmentPrediction(jsn : TJsonObject) : TFhirRiskAssessmentPrediction;
begin
  result := TFhirRiskAssessmentPrediction.create;
  try
    ParseRiskAssessmentPredictionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseRiskAssessmentPredictionProperties(jsn : TJsonObject; result : TFhirRiskAssessmentPrediction);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('outcome') then
        result.outcome := ParseCodeableConcept(jsn.vObj['outcome']);{q3}
    if jsn.has('probabilityRange') {a4} then
      result.probability := ParseRange(jsn.vObj['probabilityRange']);
    if jsn.has('probabilityDecimal') or jsn.has('_probabilityDecimal') then
      result.probability := parseDecimal(jsn.node['probabilityDecimal'], jsn.vObj['_probabilityDecimal']);
    if jsn.has('qualitativeRisk') then
        result.qualitativeRisk := ParseCodeableConcept(jsn.vObj['qualitativeRisk']);{q3}
    if jsn.has('relativeRisk') or jsn.has('_relativeRisk') then
        result.relativeRiskElement := parseDecimal(jsn.node['relativeRisk'], jsn.vObj['_relativeRisk']);{q}
    if jsn.has('whenPeriod') {a4} then
      result.when := ParsePeriod(jsn.vObj['whenPeriod']);
    if jsn.has('whenRange') {a4} then
      result.when := ParseRange(jsn.vObj['whenRange']);
    if jsn.has('rationale') or jsn.has('_rationale') then
        result.rationaleElement := parseString(jsn.node['rationale'], jsn.vObj['_rationale']);{q}
end;

procedure TFHIRJsonComposer.ComposeRiskAssessmentPrediction(json : TJSONWriter; name : string; elem : TFhirRiskAssessmentPrediction; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'outcome', elem.outcome); {a}
  if (SummaryOption in [soFull, soData]) and (elem.probability is TFhirRange) then 
    ComposeRange(json, 'probabilityRange', TFhirRange(elem.probability)) 
  else if (SummaryOption in [soFull, soData]) and (elem.probability is TFhirDecimal) then 
  begin
    ComposeDecimalValue(json, 'probabilityDecimal', TFhirDecimal(elem.probability), false);
    ComposeDecimalProps(json, 'probabilityDecimal', TFhirDecimal(elem.probability), false);
    end;
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'qualitativeRisk', elem.qualitativeRisk); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalValue(json, 'relativeRisk', elem.relativeRiskElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalProps(json, 'relativeRisk', elem.relativeRiskElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.when is TFhirPeriod) then 
    ComposePeriod(json, 'whenPeriod', TFhirPeriod(elem.when)) 
  else if (SummaryOption in [soFull, soData]) and (elem.when is TFhirRange) then 
    ComposeRange(json, 'whenRange', TFhirRange(elem.when)) ;
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'rationale', elem.rationaleElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'rationale', elem.rationaleElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseRiskAssessment(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseRiskAssessment(jsn)); {2}
end;

function TFHIRJsonParser.ParseRiskAssessment(jsn : TJsonObject) : TFhirRiskAssessment;
begin
  result := TFhirRiskAssessment.create;
  try
    ParseRiskAssessmentProperties(jsn, result);
    result.link;
  finally
    result.free;
    end;
end;

procedure TFHIRJsonParser.ParseRiskAssessmentProperties(jsn : TJsonObject; result : TFhirRiskAssessment);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('basedOn') then
        result.basedOn := ParseReference{TFhirReference}(jsn.vObj['basedOn']);{q3}
    if jsn.has('parent') then
        result.parent := ParseReference{TFhirReference}(jsn.vObj['parent']);{q3}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirObservationStatusEnum, SYSTEMS_TFhirObservationStatusEnum);
    if jsn.has('method') then
        result.method := ParseCodeableConcept(jsn.vObj['method']);{q3}
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirPatient}(jsn.vObj['subject']);{q3}
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q3}
    if jsn.has('occurrencePeriod') {a4} then
      result.occurrence := ParsePeriod(jsn.vObj['occurrencePeriod']);
    if jsn.has('occurrenceDateTime') or jsn.has('_occurrenceDateTime') then
      result.occurrence := parseDateTime(jsn.node['occurrenceDateTime'], jsn.vObj['_occurrenceDateTime']);
    if jsn.has('condition') then
        result.condition := ParseReference{TFhirCondition}(jsn.vObj['condition']);{q3}
    if jsn.has('performer') then
        result.performer := ParseReference{TFhirPractitioner}(jsn.vObj['performer']);{q3}
    if jsn.has('reasonCode') then
      iterateArray(jsn.vArr['reasonCode'], result.reasonCodeList, parseCodeableConcept);
    if jsn.has('reasonReference') then
      iterateArray(jsn.vArr['reasonReference'], result.reasonReferenceList, parseReference{TFhirCondition});
    if jsn.has('basis') then
      iterateArray(jsn.vArr['basis'], result.basisList, parseReference{TFhirReference});
    if jsn.has('prediction') then
      iterateArray(jsn.vArr['prediction'], result.predictionList, parseRiskAssessmentPrediction);
    if jsn.has('mitigation') or jsn.has('_mitigation') then
        result.mitigationElement := parseString(jsn.node['mitigation'], jsn.vObj['_mitigation']);{q}
    if jsn.has('note') then
      iterateArray(jsn.vArr['note'], result.noteList, parseAnnotation);
end;

procedure TFHIRJsonComposer.ComposeRiskAssessment(json : TJSONWriter; name : string; elem : TFhirRiskAssessment; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
    begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
      json.FinishArray;
    end;
  if (SummaryOption in [soFull, soData]) and doCompose('basedOn') then
    ComposeReference{TFhirReference}(json, 'basedOn', elem.basedOn); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('parent') then
    ComposeReference{TFhirReference}(json, 'parent', elem.parent); {a}
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirObservationStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirObservationStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('method') then
    ComposeCodeableConcept(json, 'method', elem.method); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') then
    ComposeCodeableConcept(json, 'code', elem.code); {a}
  ComposeReference{TFhirPatient}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirPeriod) then 
    ComposePeriod(json, 'occurrencePeriod', TFhirPeriod(elem.occurrence)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'occurrenceDateTime', TFhirDateTime(elem.occurrence), false);
    ComposeDateTimeProps(json, 'occurrenceDateTime', TFhirDateTime(elem.occurrence), false);
    end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('condition') then
    ComposeReference{TFhirCondition}(json, 'condition', elem.condition); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('performer') then
    ComposeReference{TFhirPractitioner}(json, 'performer', elem.performer); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('reasonCode') and (elem.reasonCodeList.Count > 0) then
    begin
    json.valueArray('reasonCode');
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.reasonCodeList[i]); {z - CodeableConcept}
      json.FinishArray;
    end;
  if (SummaryOption in [soFull, soData]) and doCompose('reasonReference') and (elem.reasonReferenceList.Count > 0) then
    begin
    json.valueArray('reasonReference');
    for i := 0 to elem.reasonReferenceList.Count - 1 do
      ComposeReference{TFhirCondition}(json, '', elem.reasonReferenceList[i]); {z - Reference(Condition)}
      json.FinishArray;
    end;
  if (SummaryOption in [soFull, soData]) and doCompose('basis') and (elem.basisList.Count > 0) then
  begin
    json.valueArray('basis');
    for i := 0 to elem.basisList.Count - 1 do
      ComposeReference{TFhirReference}(json, '', elem.basisList[i]); {z - Reference(Any)}
    json.FinishArray;
    end;
  if (SummaryOption in [soFull, soData]) and doCompose('prediction') and (elem.predictionList.Count > 0) then
    begin
    json.valueArray('prediction');
    for i := 0 to elem.predictionList.Count - 1 do
      ComposeRiskAssessmentPrediction(json, '', elem.predictionList[i]); {z - }
      json.FinishArray;
    end;
  if (SummaryOption in [soFull, soData]) and doCompose('mitigation') then
    ComposeStringValue(json, 'mitigation', elem.mitigationElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('mitigation') then
    ComposeStringProps(json, 'mitigation', elem.mitigationElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('note') and (elem.noteList.Count > 0) then
    begin
    json.valueArray('note');
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(json, '', elem.noteList[i]); {z - Annotation}
      json.FinishArray;
    end;
end;

{$ENDIF FHIR_RISKASSESSMENT}
{$IFDEF FHIR_RISKEVIDENCESYNTHESIS}
procedure TFHIRJsonParser.ParseRiskEvidenceSynthesisSampleSize(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseRiskEvidenceSynthesisSampleSize(jsn)); {2}
end;

function TFHIRJsonParser.ParseRiskEvidenceSynthesisSampleSize(jsn : TJsonObject) : TFhirRiskEvidenceSynthesisSampleSize;
begin
  result := TFhirRiskEvidenceSynthesisSampleSize.create;
  try
    ParseRiskEvidenceSynthesisSampleSizeProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseRiskEvidenceSynthesisSampleSizeProperties(jsn : TJsonObject; result : TFhirRiskEvidenceSynthesisSampleSize);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('numberOfStudies') or jsn.has('_numberOfStudies') then
        result.numberOfStudiesElement := parseInteger(jsn.node['numberOfStudies'], jsn.vObj['_numberOfStudies']);{q}
    if jsn.has('numberOfParticipants') or jsn.has('_numberOfParticipants') then
        result.numberOfParticipantsElement := parseInteger(jsn.node['numberOfParticipants'], jsn.vObj['_numberOfParticipants']);{q}
end;

procedure TFHIRJsonComposer.ComposeRiskEvidenceSynthesisSampleSize(json : TJSONWriter; name : string; elem : TFhirRiskEvidenceSynthesisSampleSize; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIntegerValue(json, 'numberOfStudies', elem.numberOfStudiesElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIntegerProps(json, 'numberOfStudies', elem.numberOfStudiesElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIntegerValue(json, 'numberOfParticipants', elem.numberOfParticipantsElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIntegerProps(json, 'numberOfParticipants', elem.numberOfParticipantsElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseRiskEvidenceSynthesisRiskEstimate(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseRiskEvidenceSynthesisRiskEstimate(jsn)); {2}
end;

function TFHIRJsonParser.ParseRiskEvidenceSynthesisRiskEstimate(jsn : TJsonObject) : TFhirRiskEvidenceSynthesisRiskEstimate;
begin
  result := TFhirRiskEvidenceSynthesisRiskEstimate.create;
  try
    ParseRiskEvidenceSynthesisRiskEstimateProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseRiskEvidenceSynthesisRiskEstimateProperties(jsn : TJsonObject; result : TFhirRiskEvidenceSynthesisRiskEstimate);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('value') or jsn.has('_value') then
        result.valueElement := parseDecimal(jsn.node['value'], jsn.vObj['_value']);{q}
    if jsn.has('unitOfMeasure') then
        result.unitOfMeasure := ParseCodeableConcept(jsn.vObj['unitOfMeasure']);{q3}
    if jsn.has('denominatorCount') or jsn.has('_denominatorCount') then
        result.denominatorCountElement := parseInteger(jsn.node['denominatorCount'], jsn.vObj['_denominatorCount']);{q}
    if jsn.has('numeratorCount') or jsn.has('_numeratorCount') then
        result.numeratorCountElement := parseInteger(jsn.node['numeratorCount'], jsn.vObj['_numeratorCount']);{q}
    if jsn.has('precisionEstimate') then
      iterateArray(jsn.vArr['precisionEstimate'], result.precisionEstimateList, parseRiskEvidenceSynthesisRiskEstimatePrecisionEstimate);
end;

procedure TFHIRJsonComposer.ComposeRiskEvidenceSynthesisRiskEstimate(json : TJSONWriter; name : string; elem : TFhirRiskEvidenceSynthesisRiskEstimate; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalValue(json, 'value', elem.valueElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalProps(json, 'value', elem.valueElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'unitOfMeasure', elem.unitOfMeasure); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeIntegerValue(json, 'denominatorCount', elem.denominatorCountElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIntegerProps(json, 'denominatorCount', elem.denominatorCountElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIntegerValue(json, 'numeratorCount', elem.numeratorCountElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIntegerProps(json, 'numeratorCount', elem.numeratorCountElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.precisionEstimateList.Count > 0) then
  begin
    json.valueArray('precisionEstimate');
    for i := 0 to elem.precisionEstimateList.Count - 1 do
      ComposeRiskEvidenceSynthesisRiskEstimatePrecisionEstimate(json, '', elem.precisionEstimateList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseRiskEvidenceSynthesisRiskEstimatePrecisionEstimate(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseRiskEvidenceSynthesisRiskEstimatePrecisionEstimate(jsn)); {2}
end;

function TFHIRJsonParser.ParseRiskEvidenceSynthesisRiskEstimatePrecisionEstimate(jsn : TJsonObject) : TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate;
begin
  result := TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate.create;
  try
    ParseRiskEvidenceSynthesisRiskEstimatePrecisionEstimateProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseRiskEvidenceSynthesisRiskEstimatePrecisionEstimateProperties(jsn : TJsonObject; result : TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('level') or jsn.has('_level') then
        result.levelElement := parseDecimal(jsn.node['level'], jsn.vObj['_level']);{q}
    if jsn.has('from') or jsn.has('_from') then
        result.fromElement := parseDecimal(jsn.node['from'], jsn.vObj['_from']);{q}
    if jsn.has('to') or jsn.has('_to') then
        result.to_Element := parseDecimal(jsn.node['to'], jsn.vObj['_to']);{q}
end;

procedure TFHIRJsonComposer.ComposeRiskEvidenceSynthesisRiskEstimatePrecisionEstimate(json : TJSONWriter; name : string; elem : TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalValue(json, 'level', elem.levelElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalProps(json, 'level', elem.levelElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalValue(json, 'from', elem.fromElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalProps(json, 'from', elem.fromElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalValue(json, 'to', elem.to_Element, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalProps(json, 'to', elem.to_Element, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseRiskEvidenceSynthesisCertainty(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseRiskEvidenceSynthesisCertainty(jsn)); {2}
end;

function TFHIRJsonParser.ParseRiskEvidenceSynthesisCertainty(jsn : TJsonObject) : TFhirRiskEvidenceSynthesisCertainty;
begin
  result := TFhirRiskEvidenceSynthesisCertainty.create;
  try
    ParseRiskEvidenceSynthesisCertaintyProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseRiskEvidenceSynthesisCertaintyProperties(jsn : TJsonObject; result : TFhirRiskEvidenceSynthesisCertainty);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('rating') then
      iterateArray(jsn.vArr['rating'], result.ratingList, parseCodeableConcept);
    if jsn.has('note') then
      iterateArray(jsn.vArr['note'], result.noteList, parseAnnotation);
    if jsn.has('certaintySubcomponent') then
      iterateArray(jsn.vArr['certaintySubcomponent'], result.certaintySubcomponentList, parseRiskEvidenceSynthesisCertaintyCertaintySubcomponent);
end;

procedure TFHIRJsonComposer.ComposeRiskEvidenceSynthesisCertainty(json : TJSONWriter; name : string; elem : TFhirRiskEvidenceSynthesisCertainty; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and (elem.ratingList.Count > 0) then
  begin
    json.valueArray('rating');
    for i := 0 to elem.ratingList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.ratingList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.noteList.Count > 0) then
  begin
    json.valueArray('note');
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(json, '', elem.noteList[i]); {z - Annotation}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.certaintySubcomponentList.Count > 0) then
  begin
    json.valueArray('certaintySubcomponent');
    for i := 0 to elem.certaintySubcomponentList.Count - 1 do
      ComposeRiskEvidenceSynthesisCertaintyCertaintySubcomponent(json, '', elem.certaintySubcomponentList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseRiskEvidenceSynthesisCertaintyCertaintySubcomponent(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseRiskEvidenceSynthesisCertaintyCertaintySubcomponent(jsn)); {2}
end;

function TFHIRJsonParser.ParseRiskEvidenceSynthesisCertaintyCertaintySubcomponent(jsn : TJsonObject) : TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent;
begin
  result := TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent.create;
  try
    ParseRiskEvidenceSynthesisCertaintyCertaintySubcomponentProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseRiskEvidenceSynthesisCertaintyCertaintySubcomponentProperties(jsn : TJsonObject; result : TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('rating') then
      iterateArray(jsn.vArr['rating'], result.ratingList, parseCodeableConcept);
    if jsn.has('note') then
      iterateArray(jsn.vArr['note'], result.noteList, parseAnnotation);
end;

procedure TFHIRJsonComposer.ComposeRiskEvidenceSynthesisCertaintyCertaintySubcomponent(json : TJSONWriter; name : string; elem : TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) and (elem.ratingList.Count > 0) then
  begin
    json.valueArray('rating');
    for i := 0 to elem.ratingList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.ratingList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.noteList.Count > 0) then
  begin
    json.valueArray('note');
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(json, '', elem.noteList[i]); {z - Annotation}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseRiskEvidenceSynthesis(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseRiskEvidenceSynthesis(jsn)); {2}
end;

function TFHIRJsonParser.ParseRiskEvidenceSynthesis(jsn : TJsonObject) : TFhirRiskEvidenceSynthesis;
begin
  result := TFhirRiskEvidenceSynthesis.create;
  try
    ParseRiskEvidenceSynthesisProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseRiskEvidenceSynthesisProperties(jsn : TJsonObject; result : TFhirRiskEvidenceSynthesis);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := parseUri(jsn.node['url'], jsn.vObj['_url']);{q}
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := parseString(jsn.node['version'], jsn.vObj['_version']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('title') or jsn.has('_title') then
        result.titleElement := parseString(jsn.node['title'], jsn.vObj['_title']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := parseDateTime(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('publisher') or jsn.has('_publisher') then
        result.publisherElement := parseString(jsn.node['publisher'], jsn.vObj['_publisher']);{q}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseContactDetail);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseMarkdown(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('note') then
      iterateArray(jsn.vArr['note'], result.noteList, parseAnnotation);
    if jsn.has('useContext') then
      iterateArray(jsn.vArr['useContext'], result.useContextList, parseUsageContext);
    if jsn.has('jurisdiction') then
      iterateArray(jsn.vArr['jurisdiction'], result.jurisdictionList, parseCodeableConcept);
    if jsn.has('copyright') or jsn.has('_copyright') then
        result.copyrightElement := parseMarkdown(jsn.node['copyright'], jsn.vObj['_copyright']);{q}
    if jsn.has('approvalDate') or jsn.has('_approvalDate') then
        result.approvalDateElement := parseDate(jsn.node['approvalDate'], jsn.vObj['_approvalDate']);{q}
    if jsn.has('lastReviewDate') or jsn.has('_lastReviewDate') then
        result.lastReviewDateElement := parseDate(jsn.node['lastReviewDate'], jsn.vObj['_lastReviewDate']);{q}
    if jsn.has('effectivePeriod') then
        result.effectivePeriod := ParsePeriod(jsn.vObj['effectivePeriod']);{q3}
    if jsn.has('topic') then
      iterateArray(jsn.vArr['topic'], result.topicList, parseCodeableConcept);
    if jsn.has('author') then
      iterateArray(jsn.vArr['author'], result.authorList, parseContactDetail);
    if jsn.has('editor') then
      iterateArray(jsn.vArr['editor'], result.editorList, parseContactDetail);
    if jsn.has('reviewer') then
      iterateArray(jsn.vArr['reviewer'], result.reviewerList, parseContactDetail);
    if jsn.has('endorser') then
      iterateArray(jsn.vArr['endorser'], result.endorserList, parseContactDetail);
    if jsn.has('relatedArtifact') then
      iterateArray(jsn.vArr['relatedArtifact'], result.relatedArtifactList, parseRelatedArtifact);
    if jsn.has('synthesisType') then
        result.synthesisType := ParseCodeableConcept(jsn.vObj['synthesisType']);{q3}
    if jsn.has('studyType') then
        result.studyType := ParseCodeableConcept(jsn.vObj['studyType']);{q3}
    if jsn.has('population') then
        result.population := ParseReference{TFhirEvidenceVariable}(jsn.vObj['population']);{q3}
    if jsn.has('exposure') then
        result.exposure := ParseReference{TFhirEvidenceVariable}(jsn.vObj['exposure']);{q3}
    if jsn.has('outcome') then
        result.outcome := ParseReference{TFhirEvidenceVariable}(jsn.vObj['outcome']);{q3}
    if jsn.has('sampleSize') then
        result.sampleSize := ParseRiskEvidenceSynthesisSampleSize(jsn.vObj['sampleSize']);{q3}
    if jsn.has('riskEstimate') then
        result.riskEstimate := ParseRiskEvidenceSynthesisRiskEstimate(jsn.vObj['riskEstimate']);{q3}
    if jsn.has('certainty') then
      iterateArray(jsn.vArr['certainty'], result.certaintyList, parseRiskEvidenceSynthesisCertainty);
end;

procedure TFHIRJsonComposer.ComposeRiskEvidenceSynthesis(json : TJSONWriter; name : string; elem : TFhirRiskEvidenceSynthesis; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUriValue(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUriProps(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeStringValue(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeStringProps(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeStringValue(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeStringProps(json, 'title', elem.titleElement, false);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringValue(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringProps(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') and (elem.contactList.Count > 0) then
  begin
    json.valueArray('contact');
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(json, '', elem.contactList[i]); {z - ContactDetail}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeMarkdownValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeMarkdownProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('note') and (elem.noteList.Count > 0) then
  begin
    json.valueArray('note');
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(json, '', elem.noteList[i]); {z - Annotation}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') and (elem.useContextList.Count > 0) then
  begin
    json.valueArray('useContext');
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(json, '', elem.useContextList[i]); {z - UsageContext}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') and (elem.jurisdictionList.Count > 0) then
  begin
    json.valueArray('jurisdiction');
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.jurisdictionList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdownValue(json, 'copyright', elem.copyrightElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdownProps(json, 'copyright', elem.copyrightElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('approvalDate') then
    ComposeDateValue(json, 'approvalDate', elem.approvalDateElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('approvalDate') then
    ComposeDateProps(json, 'approvalDate', elem.approvalDateElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('lastReviewDate') then
    ComposeDateValue(json, 'lastReviewDate', elem.lastReviewDateElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('lastReviewDate') then
    ComposeDateProps(json, 'lastReviewDate', elem.lastReviewDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('effectivePeriod') then
    ComposePeriod(json, 'effectivePeriod', elem.effectivePeriod); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('topic') and (elem.topicList.Count > 0) then
  begin
    json.valueArray('topic');
    for i := 0 to elem.topicList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.topicList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('author') and (elem.authorList.Count > 0) then
  begin
    json.valueArray('author');
    for i := 0 to elem.authorList.Count - 1 do
      ComposeContactDetail(json, '', elem.authorList[i]); {z - ContactDetail}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('editor') and (elem.editorList.Count > 0) then
  begin
    json.valueArray('editor');
    for i := 0 to elem.editorList.Count - 1 do
      ComposeContactDetail(json, '', elem.editorList[i]); {z - ContactDetail}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('reviewer') and (elem.reviewerList.Count > 0) then
  begin
    json.valueArray('reviewer');
    for i := 0 to elem.reviewerList.Count - 1 do
      ComposeContactDetail(json, '', elem.reviewerList[i]); {z - ContactDetail}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('endorser') and (elem.endorserList.Count > 0) then
  begin
    json.valueArray('endorser');
    for i := 0 to elem.endorserList.Count - 1 do
      ComposeContactDetail(json, '', elem.endorserList[i]); {z - ContactDetail}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('relatedArtifact') and (elem.relatedArtifactList.Count > 0) then
  begin
    json.valueArray('relatedArtifact');
    for i := 0 to elem.relatedArtifactList.Count - 1 do
      ComposeRelatedArtifact(json, '', elem.relatedArtifactList[i]); {z - RelatedArtifact}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('synthesisType') then
    ComposeCodeableConcept(json, 'synthesisType', elem.synthesisType); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('studyType') then
    ComposeCodeableConcept(json, 'studyType', elem.studyType); {a}
  ComposeReference{TFhirEvidenceVariable}(json, 'population', elem.population); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('exposure') then
    ComposeReference{TFhirEvidenceVariable}(json, 'exposure', elem.exposure); {a}
  ComposeReference{TFhirEvidenceVariable}(json, 'outcome', elem.outcome); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('sampleSize') then
    ComposeRiskEvidenceSynthesisSampleSize(json, 'sampleSize', elem.sampleSize); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('riskEstimate') then
    ComposeRiskEvidenceSynthesisRiskEstimate(json, 'riskEstimate', elem.riskEstimate); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('certainty') and (elem.certaintyList.Count > 0) then
  begin
    json.valueArray('certainty');
    for i := 0 to elem.certaintyList.Count - 1 do
      ComposeRiskEvidenceSynthesisCertainty(json, '', elem.certaintyList[i]); {z - }
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_RISKEVIDENCESYNTHESIS}
{$IFDEF FHIR_SCHEDULE}
procedure TFHIRJsonParser.ParseSchedule(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSchedule(jsn)); {2}
end;

function TFHIRJsonParser.ParseSchedule(jsn : TJsonObject) : TFhirSchedule;
begin
  result := TFhirSchedule.create;
  try
    ParseScheduleProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseScheduleProperties(jsn : TJsonObject; result : TFhirSchedule);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('active') or jsn.has('_active') then
        result.activeElement := parseBoolean(jsn.node['active'], jsn.vObj['_active']);{q}
    if jsn.has('serviceCategory') then
      iterateArray(jsn.vArr['serviceCategory'], result.serviceCategoryList, parseCodeableConcept);
    if jsn.has('serviceType') then
      iterateArray(jsn.vArr['serviceType'], result.serviceTypeList, parseCodeableConcept);
    if jsn.has('specialty') then
      iterateArray(jsn.vArr['specialty'], result.specialtyList, parseCodeableConcept);
    if jsn.has('actor') then
      iterateArray(jsn.vArr['actor'], result.actorList, parseReference{TFhirPatient});
    if jsn.has('planningHorizon') then
        result.planningHorizon := ParsePeriod(jsn.vObj['planningHorizon']);{q3}
    if jsn.has('comment') or jsn.has('_comment') then
        result.commentElement := parseString(jsn.node['comment'], jsn.vObj['_comment']);{q}
end;

procedure TFHIRJsonComposer.ComposeSchedule(json : TJSONWriter; name : string; elem : TFhirSchedule; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('active') then
    ComposeBooleanValue(json, 'active', elem.activeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('active') then
    ComposeBooleanProps(json, 'active', elem.activeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('serviceCategory') and (elem.serviceCategoryList.Count > 0) then
  begin
    json.valueArray('serviceCategory');
    for i := 0 to elem.serviceCategoryList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.serviceCategoryList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('serviceType') and (elem.serviceTypeList.Count > 0) then
  begin
    json.valueArray('serviceType');
    for i := 0 to elem.serviceTypeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.serviceTypeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('specialty') and (elem.specialtyList.Count > 0) then
  begin
    json.valueArray('specialty');
    for i := 0 to elem.specialtyList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.specialtyList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (elem.actorList.Count > 0) then
  begin
    json.valueArray('actor');
    for i := 0 to elem.actorList.Count - 1 do
      ComposeReference{TFhirPatient}(json, '', elem.actorList[i]); {z - Reference(Patient)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('planningHorizon') then
    ComposePeriod(json, 'planningHorizon', elem.planningHorizon); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('comment') then
    ComposeStringValue(json, 'comment', elem.commentElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('comment') then
    ComposeStringProps(json, 'comment', elem.commentElement, false);
end;

{$ENDIF FHIR_SCHEDULE}
{$IFDEF FHIR_SEARCHPARAMETER}
procedure TFHIRJsonParser.ParseSearchParameterComponent(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSearchParameterComponent(jsn)); {2}
end;

function TFHIRJsonParser.ParseSearchParameterComponent(jsn : TJsonObject) : TFhirSearchParameterComponent;
begin
  result := TFhirSearchParameterComponent.create;
  try
    ParseSearchParameterComponentProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSearchParameterComponentProperties(jsn : TJsonObject; result : TFhirSearchParameterComponent);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('definition') or jsn.has('_definition') then
        result.definitionElement := parseCanonical(jsn.node['definition'], jsn.vObj['_definition']);{q}
    if jsn.has('expression') or jsn.has('_expression') then
        result.expressionElement := parseString(jsn.node['expression'], jsn.vObj['_expression']);{q}
end;

procedure TFHIRJsonComposer.ComposeSearchParameterComponent(json : TJSONWriter; name : string; elem : TFhirSearchParameterComponent; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCanonicalValue(json, 'definition', elem.definitionElement, false);
  ComposeCanonicalProps(json, 'definition', elem.definitionElement, false);
  ComposeStringValue(json, 'expression', elem.expressionElement, false);
  ComposeStringProps(json, 'expression', elem.expressionElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseSearchParameter(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSearchParameter(jsn)); {2}
end;

function TFHIRJsonParser.ParseSearchParameter(jsn : TJsonObject) : TFhirSearchParameter;
begin
  result := TFhirSearchParameter.create;
  try
    ParseSearchParameterProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSearchParameterProperties(jsn : TJsonObject; result : TFhirSearchParameter);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := parseUri(jsn.node['url'], jsn.vObj['_url']);{q}
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := parseString(jsn.node['version'], jsn.vObj['_version']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('derivedFrom') or jsn.has('_derivedFrom') then
        result.derivedFromElement := parseCanonical(jsn.node['derivedFrom'], jsn.vObj['_derivedFrom']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    if jsn.has('experimental') or jsn.has('_experimental') then
        result.experimentalElement := parseBoolean(jsn.node['experimental'], jsn.vObj['_experimental']);{q}
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := parseDateTime(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('publisher') or jsn.has('_publisher') then
        result.publisherElement := parseString(jsn.node['publisher'], jsn.vObj['_publisher']);{q}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseContactDetail);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseMarkdown(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('useContext') then
      iterateArray(jsn.vArr['useContext'], result.useContextList, parseUsageContext);
    if jsn.has('jurisdiction') then
      iterateArray(jsn.vArr['jurisdiction'], result.jurisdictionList, parseCodeableConcept);
    if jsn.has('purpose') or jsn.has('_purpose') then
        result.purposeElement := parseMarkdown(jsn.node['purpose'], jsn.vObj['_purpose']);{q}
    if jsn.has('code') or jsn.has('_code') then
        result.codeElement := parseCode(jsn.node['code'], jsn.vObj['_code']);{q}
    if jsn.has('base') or jsn.has('_base') then
      iterateEnumArray(jsn.vArr['base'], jsn.vArr['_base'], jsn.path+'/base', result.base, parseEnum, CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn.node['type'], jsn.vObj['_type'], CODES_TFhirSearchParamTypeEnum, SYSTEMS_TFhirSearchParamTypeEnum);
    if jsn.has('expression') or jsn.has('_expression') then
        result.expressionElement := parseString(jsn.node['expression'], jsn.vObj['_expression']);{q}
    if jsn.has('xpath') or jsn.has('_xpath') then
        result.xpathElement := parseString(jsn.node['xpath'], jsn.vObj['_xpath']);{q}
    if jsn.has('xpathUsage') or jsn.has('_xpathUsage')  then
      result.xpathUsageElement := parseEnum(jsn.path+'/xpathUsage', jsn.node['xpathUsage'], jsn.vObj['_xpathUsage'], CODES_TFhirSearchXpathUsageEnum, SYSTEMS_TFhirSearchXpathUsageEnum);
    if jsn.has('target') or jsn.has('_target') then
      iterateEnumArray(jsn.vArr['target'], jsn.vArr['_target'], jsn.path+'/target', result.target, parseEnum, CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum);
    if jsn.has('multipleOr') or jsn.has('_multipleOr') then
        result.multipleOrElement := parseBoolean(jsn.node['multipleOr'], jsn.vObj['_multipleOr']);{q}
    if jsn.has('multipleAnd') or jsn.has('_multipleAnd') then
        result.multipleAndElement := parseBoolean(jsn.node['multipleAnd'], jsn.vObj['_multipleAnd']);{q}
    if jsn.has('comparator') or jsn.has('_comparator') then
      iterateEnumArray(jsn.vArr['comparator'], jsn.vArr['_comparator'], jsn.path+'/comparator', result.comparatorList, parseEnum, CODES_TFhirSearchComparatorEnum, SYSTEMS_TFhirSearchComparatorEnum);
    if jsn.has('modifier') or jsn.has('_modifier') then
      iterateEnumArray(jsn.vArr['modifier'], jsn.vArr['_modifier'], jsn.path+'/modifier', result.modifierList, parseEnum, CODES_TFhirSearchModifierCodeEnum, SYSTEMS_TFhirSearchModifierCodeEnum);
      if jsn.has('chain') or jsn.has('_chain') then
      iteratePrimitiveArray(jsn.vArr['chain'], jsn.vArr['_chain'], result.chainList, parseString);
    if jsn.has('component') then
      iterateArray(jsn.vArr['component'], result.componentList, parseSearchParameterComponent);
end;

procedure TFHIRJsonComposer.ComposeSearchParameter(json : TJSONWriter; name : string; elem : TFhirSearchParameter; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  ComposeUriValue(json, 'url', elem.urlElement, false);
  ComposeUriProps(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeStringValue(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeStringProps(json, 'version', elem.versionElement, false);
  ComposeStringValue(json, 'name', elem.nameElement, false);
  ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('derivedFrom') then
    ComposeCanonicalValue(json, 'derivedFrom', elem.derivedFromElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('derivedFrom') then
    ComposeCanonicalProps(json, 'derivedFrom', elem.derivedFromElement, false);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBooleanValue(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBooleanProps(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringValue(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringProps(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') and (elem.contactList.Count > 0) then
  begin
    json.valueArray('contact');
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(json, '', elem.contactList[i]); {z - ContactDetail}
    json.FinishArray;
  end;
  ComposeMarkdownValue(json, 'description', elem.descriptionElement, false);
  ComposeMarkdownProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') and (elem.useContextList.Count > 0) then
  begin
    json.valueArray('useContext');
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(json, '', elem.useContextList[i]); {z - UsageContext}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') and (elem.jurisdictionList.Count > 0) then
  begin
    json.valueArray('jurisdiction');
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.jurisdictionList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdownValue(json, 'purpose', elem.purposeElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdownProps(json, 'purpose', elem.purposeElement, false);
  ComposeCodeValue(json, 'code', elem.codeElement, false);
  ComposeCodeProps(json, 'code', elem.codeElement, false);
  if (elem.base.Count > 0) then
  begin
    val := false;
    ext := false;
    for i := 0 to elem.base.Count - 1 do
    begin
      val := val or (elem.base[i].hasPrimitiveValue);
      ext := ext or ((elem.base[i].id <> '') or (elem.base[i].hasExtensionList));
    end;
    if val then
    begin
      json.valueArray('base');
      for i := 0 to elem.base.Count - 1 do
        ComposeEnumValue(json, '', elem.base[i], CODES_TFhirResourceTypesEnum, true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_base');
      for i := 0 to elem.base.Count - 1 do
        ComposeEnumProps(json, '', elem.base[i], CODES_TFhirResourceTypesEnum, true);
      json.FinishArray;
    end;
  end;
  ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirSearchParamTypeEnum, false);
  ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirSearchParamTypeEnum, false);
  if (SummaryOption in [soFull, soData]) and doCompose('expression') then
    ComposeStringValue(json, 'expression', elem.expressionElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('expression') then
    ComposeStringProps(json, 'expression', elem.expressionElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('xpath') then
    ComposeStringValue(json, 'xpath', elem.xpathElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('xpath') then
    ComposeStringProps(json, 'xpath', elem.xpathElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('xpathUsage') then
    ComposeEnumValue(json, 'xpathUsage', elem.XpathUsageElement, CODES_TFhirSearchXpathUsageEnum, false);
  if (SummaryOption in [soFull, soData]) and doCompose('xpathUsage') then
    ComposeEnumProps(json, 'xpathUsage', elem.XpathUsageElement, CODES_TFhirSearchXpathUsageEnum, false);
  if (SummaryOption in [soFull, soData]) and doCompose('target') and (elem.target.Count > 0) then
  begin
    val := false;
    ext := false;
    for i := 0 to elem.target.Count - 1 do
    begin
      val := val or (elem.target[i].hasPrimitiveValue);
      ext := ext or ((elem.target[i].id <> '') or (elem.target[i].hasExtensionList));
    end;
    if val then
    begin
      json.valueArray('target');
      for i := 0 to elem.target.Count - 1 do
        ComposeEnumValue(json, '', elem.target[i], CODES_TFhirResourceTypesEnum, true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_target');
      for i := 0 to elem.target.Count - 1 do
        ComposeEnumProps(json, '', elem.target[i], CODES_TFhirResourceTypesEnum, true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('multipleOr') then
    ComposeBooleanValue(json, 'multipleOr', elem.multipleOrElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('multipleOr') then
    ComposeBooleanProps(json, 'multipleOr', elem.multipleOrElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('multipleAnd') then
    ComposeBooleanValue(json, 'multipleAnd', elem.multipleAndElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('multipleAnd') then
    ComposeBooleanProps(json, 'multipleAnd', elem.multipleAndElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('comparator') and (elem.comparatorList.Count > 0) then
  begin
    val := false;
    ext := false;
    for i := 0 to elem.comparatorList.Count - 1 do
    begin
      val := val or (elem.comparatorList[i].hasPrimitiveValue);
      ext := ext or ((elem.comparatorList[i].id <> '') or (elem.comparatorList[i].hasExtensionList));
  end;
    if val then
    begin
      json.valueArray('comparator');
      for i := 0 to elem.comparatorList.Count - 1 do
        ComposeEnumValue(json, '', elem.comparatorList[i], CODES_TFhirSearchComparatorEnum, true);
      json.FinishArray;
  end;
    if ext then
  begin
      json.valueArray('_comparator');
      for i := 0 to elem.comparatorList.Count - 1 do
        ComposeEnumProps(json, '', elem.comparatorList[i], CODES_TFhirSearchComparatorEnum, true);
    json.FinishArray;
  end;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('modifier') and (elem.modifierList.Count > 0) then
  begin
    val := false;
    ext := false;
    for i := 0 to elem.modifierList.Count - 1 do
    begin
      val := val or (elem.modifierList[i].hasPrimitiveValue);
      ext := ext or ((elem.modifierList[i].id <> '') or (elem.modifierList[i].hasExtensionList));
    end;
    if val then
  begin
      json.valueArray('modifier');
      for i := 0 to elem.modifierList.Count - 1 do
        ComposeEnumValue(json, '', elem.modifierList[i], CODES_TFhirSearchModifierCodeEnum, true);
    json.FinishArray;
  end;
    if ext then
  begin
      json.valueArray('_modifier');
      for i := 0 to elem.modifierList.Count - 1 do
        ComposeEnumProps(json, '', elem.modifierList[i], CODES_TFhirSearchModifierCodeEnum, true);
    json.FinishArray;
  end;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('chain') and (elem.chainList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.chainList.Count - 1 do
    begin
      ext := ext or ((elem.chainList[i].id <> '') or (elem.chainList[i].hasExtensionList) {no-comments or (elem.chainList[i].hasComments)});
      val := val or (elem.chainList[i].hasPrimitiveValue);
    end;
    if val then
  begin
      json.valueArray('chain');
      for i := 0 to elem.chainList.Count - 1 do
        ComposeStringValue(json, '',elem.chainList[i], true);
    json.FinishArray;
  end;
    if ext then
  begin
      json.valueArray('_chain');
      for i := 0 to elem.chainList.Count - 1 do
        ComposeStringProps(json, '',elem.chainList[i], true);
    json.FinishArray;
  end;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('component') and (elem.componentList.Count > 0) then
  begin
    json.valueArray('component');
    for i := 0 to elem.componentList.Count - 1 do
      ComposeSearchParameterComponent(json, '', elem.componentList[i]); {z - }
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_SEARCHPARAMETER}
{$IFDEF FHIR_SERVICEREQUEST}
procedure TFHIRJsonParser.ParseServiceRequest(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseServiceRequest(jsn)); {2}
end;

function TFHIRJsonParser.ParseServiceRequest(jsn : TJsonObject) : TFhirServiceRequest;
begin
  result := TFhirServiceRequest.create;
  try
    ParseServiceRequestProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseServiceRequestProperties(jsn : TJsonObject; result : TFhirServiceRequest);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
      if jsn.has('instantiatesCanonical') or jsn.has('_instantiatesCanonical') then
      iteratePrimitiveArray(jsn.vArr['instantiatesCanonical'], jsn.vArr['_instantiatesCanonical'], result.instantiatesCanonicalList, parseCanonical);
      if jsn.has('instantiatesUri') or jsn.has('_instantiatesUri') then
      iteratePrimitiveArray(jsn.vArr['instantiatesUri'], jsn.vArr['_instantiatesUri'], result.instantiatesUriList, parseUri);
    if jsn.has('basedOn') then
      iterateArray(jsn.vArr['basedOn'], result.basedOnList, parseReference{TFhirCarePlan});
    if jsn.has('replaces') then
      iterateArray(jsn.vArr['replaces'], result.replacesList, parseReference{TFhirServiceRequest});
    if jsn.has('requisition') then
        result.requisition := ParseIdentifier(jsn.vObj['requisition']);{q3}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirRequestStatusEnum, SYSTEMS_TFhirRequestStatusEnum);
    if jsn.has('intent') or jsn.has('_intent')  then
      result.intentElement := parseEnum(jsn.path+'/intent', jsn.node['intent'], jsn.vObj['_intent'], CODES_TFhirRequestIntentEnum, SYSTEMS_TFhirRequestIntentEnum);
    if jsn.has('category') then
      iterateArray(jsn.vArr['category'], result.categoryList, parseCodeableConcept);
    if jsn.has('priority') or jsn.has('_priority')  then
      result.priorityElement := parseEnum(jsn.path+'/priority', jsn.node['priority'], jsn.vObj['_priority'], CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum);
    if jsn.has('doNotPerform') or jsn.has('_doNotPerform') then
        result.doNotPerformElement := parseBoolean(jsn.node['doNotPerform'], jsn.vObj['_doNotPerform']);{q}
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('orderDetail') then
      iterateArray(jsn.vArr['orderDetail'], result.orderDetailList, parseCodeableConcept);
    if jsn.has('quantityQuantity') {a4} then
      result.quantity := ParseQuantity(jsn.vObj['quantityQuantity']);
    if jsn.has('quantityRatio') {a4} then
      result.quantity := ParseRatio(jsn.vObj['quantityRatio']);
    if jsn.has('quantityRange') {a4} then
      result.quantity := ParseRange(jsn.vObj['quantityRange']);
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirPatient}(jsn.vObj['subject']);{q3}
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q3}
    if jsn.has('occurrencePeriod') {a4} then
      result.occurrence := ParsePeriod(jsn.vObj['occurrencePeriod']);
    if jsn.has('occurrenceTiming') {a4} then
      result.occurrence := ParseTiming(jsn.vObj['occurrenceTiming']);
    if jsn.has('occurrenceDateTime') or jsn.has('_occurrenceDateTime') then
      result.occurrence := parseDateTime(jsn.node['occurrenceDateTime'], jsn.vObj['_occurrenceDateTime']);
    if jsn.has('asNeededCodeableConcept') {a4} then
      result.asNeeded := ParseCodeableConcept(jsn.vObj['asNeededCodeableConcept']);
    if jsn.has('asNeededBoolean') or jsn.has('_asNeededBoolean') then
      result.asNeeded := parseBoolean(jsn.node['asNeededBoolean'], jsn.vObj['_asNeededBoolean']);
    if jsn.has('authoredOn') or jsn.has('_authoredOn') then
        result.authoredOnElement := parseDateTime(jsn.node['authoredOn'], jsn.vObj['_authoredOn']);{q}
    if jsn.has('requester') then
        result.requester := ParseReference{TFhirPractitioner}(jsn.vObj['requester']);{q3}
    if jsn.has('performerType') then
        result.performerType := ParseCodeableConcept(jsn.vObj['performerType']);{q3}
    if jsn.has('performer') then
      iterateArray(jsn.vArr['performer'], result.performerList, parseReference{TFhirPractitioner});
    if jsn.has('locationCode') then
      iterateArray(jsn.vArr['locationCode'], result.locationCodeList, parseCodeableConcept);
    if jsn.has('locationReference') then
      iterateArray(jsn.vArr['locationReference'], result.locationReferenceList, parseReference{TFhirLocation});
    if jsn.has('reasonCode') then
      iterateArray(jsn.vArr['reasonCode'], result.reasonCodeList, parseCodeableConcept);
    if jsn.has('reasonReference') then
      iterateArray(jsn.vArr['reasonReference'], result.reasonReferenceList, parseReference{TFhirCondition});
    if jsn.has('insurance') then
      iterateArray(jsn.vArr['insurance'], result.insuranceList, parseReference{TFhirCoverage});
    if jsn.has('supportingInfo') then
      iterateArray(jsn.vArr['supportingInfo'], result.supportingInfoList, parseReference{TFhirReference});
    if jsn.has('specimen') then
      iterateArray(jsn.vArr['specimen'], result.specimenList, parseReference{TFhirSpecimen});
    if jsn.has('bodySite') then
      iterateArray(jsn.vArr['bodySite'], result.bodySiteList, parseCodeableConcept);
    if jsn.has('note') then
      iterateArray(jsn.vArr['note'], result.noteList, parseAnnotation);
    if jsn.has('patientInstruction') or jsn.has('_patientInstruction') then
        result.patientInstructionElement := parseString(jsn.node['patientInstruction'], jsn.vObj['_patientInstruction']);{q}
    if jsn.has('relevantHistory') then
      iterateArray(jsn.vArr['relevantHistory'], result.relevantHistoryList, parseReference{TFhirProvenance});
end;

procedure TFHIRJsonComposer.ComposeServiceRequest(json : TJSONWriter; name : string; elem : TFhirServiceRequest; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('instantiatesCanonical') and (elem.instantiatesCanonicalList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.instantiatesCanonicalList.Count - 1 do
    begin
      ext := ext or ((elem.instantiatesCanonicalList[i].id <> '') or (elem.instantiatesCanonicalList[i].hasExtensionList) {no-comments or (elem.instantiatesCanonicalList[i].hasComments)});
      val := val or (elem.instantiatesCanonicalList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('instantiatesCanonical');
      for i := 0 to elem.instantiatesCanonicalList.Count - 1 do
        ComposeCanonicalValue(json, '',elem.instantiatesCanonicalList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_instantiatesCanonical');
      for i := 0 to elem.instantiatesCanonicalList.Count - 1 do
        ComposeCanonicalProps(json, '',elem.instantiatesCanonicalList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('instantiatesUri') and (elem.instantiatesUriList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.instantiatesUriList.Count - 1 do
    begin
      ext := ext or ((elem.instantiatesUriList[i].id <> '') or (elem.instantiatesUriList[i].hasExtensionList) {no-comments or (elem.instantiatesUriList[i].hasComments)});
      val := val or (elem.instantiatesUriList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('instantiatesUri');
      for i := 0 to elem.instantiatesUriList.Count - 1 do
        ComposeUriValue(json, '',elem.instantiatesUriList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_instantiatesUri');
      for i := 0 to elem.instantiatesUriList.Count - 1 do
        ComposeUriProps(json, '',elem.instantiatesUriList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('basedOn') and (elem.basedOnList.Count > 0) then
  begin
    json.valueArray('basedOn');
    for i := 0 to elem.basedOnList.Count - 1 do
      ComposeReference{TFhirCarePlan}(json, '', elem.basedOnList[i]); {z - Reference(CarePlan)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('replaces') and (elem.replacesList.Count > 0) then
  begin
    json.valueArray('replaces');
    for i := 0 to elem.replacesList.Count - 1 do
      ComposeReference{TFhirServiceRequest}(json, '', elem.replacesList[i]); {z - Reference(ServiceRequest)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requisition') then
    ComposeIdentifier(json, 'requisition', elem.requisition); {a}
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirRequestStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirRequestStatusEnum, false);
  ComposeEnumValue(json, 'intent', elem.IntentElement, CODES_TFhirRequestIntentEnum, false);
  ComposeEnumProps(json, 'intent', elem.IntentElement, CODES_TFhirRequestIntentEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') and (elem.categoryList.Count > 0) then
  begin
    json.valueArray('category');
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.categoryList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('priority') then
    ComposeEnumValue(json, 'priority', elem.PriorityElement, CODES_TFhirRequestPriorityEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('priority') then
    ComposeEnumProps(json, 'priority', elem.PriorityElement, CODES_TFhirRequestPriorityEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('doNotPerform') then
    ComposeBooleanValue(json, 'doNotPerform', elem.doNotPerformElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('doNotPerform') then
    ComposeBooleanProps(json, 'doNotPerform', elem.doNotPerformElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') then
    ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('orderDetail') and (elem.orderDetailList.Count > 0) then
  begin
    json.valueArray('orderDetail');
    for i := 0 to elem.orderDetailList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.orderDetailList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.quantity is TFhirQuantity) then 
    ComposeQuantity(json, 'quantityQuantity', TFhirQuantity(elem.quantity)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.quantity is TFhirRatio) then 
    ComposeRatio(json, 'quantityRatio', TFhirRatio(elem.quantity)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.quantity is TFhirRange) then 
    ComposeRange(json, 'quantityRange', TFhirRange(elem.quantity)) ;
  ComposeReference{TFhirPatient}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirPeriod) then 
    ComposePeriod(json, 'occurrencePeriod', TFhirPeriod(elem.occurrence)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirTiming) then 
    ComposeTiming(json, 'occurrenceTiming', TFhirTiming(elem.occurrence)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'occurrenceDateTime', TFhirDateTime(elem.occurrence), false);
    ComposeDateTimeProps(json, 'occurrenceDateTime', TFhirDateTime(elem.occurrence), false);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.asNeeded is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'asNeededCodeableConcept', TFhirCodeableConcept(elem.asNeeded)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.asNeeded is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'asNeededBoolean', TFhirBoolean(elem.asNeeded), false);
    ComposeBooleanProps(json, 'asNeededBoolean', TFhirBoolean(elem.asNeeded), false);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('authoredOn') then
    ComposeDateTimeValue(json, 'authoredOn', elem.authoredOnElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('authoredOn') then
    ComposeDateTimeProps(json, 'authoredOn', elem.authoredOnElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requester') then
    ComposeReference{TFhirPractitioner}(json, 'requester', elem.requester); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('performerType') then
    ComposeCodeableConcept(json, 'performerType', elem.performerType); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('performer') and (elem.performerList.Count > 0) then
  begin
    json.valueArray('performer');
    for i := 0 to elem.performerList.Count - 1 do
      ComposeReference{TFhirPractitioner}(json, '', elem.performerList[i]); {z - Reference(Practitioner)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('locationCode') and (elem.locationCodeList.Count > 0) then
  begin
    json.valueArray('locationCode');
    for i := 0 to elem.locationCodeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.locationCodeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('locationReference') and (elem.locationReferenceList.Count > 0) then
  begin
    json.valueArray('locationReference');
    for i := 0 to elem.locationReferenceList.Count - 1 do
      ComposeReference{TFhirLocation}(json, '', elem.locationReferenceList[i]); {z - Reference(Location)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonCode') and (elem.reasonCodeList.Count > 0) then
  begin
    json.valueArray('reasonCode');
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.reasonCodeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonReference') and (elem.reasonReferenceList.Count > 0) then
  begin
    json.valueArray('reasonReference');
    for i := 0 to elem.reasonReferenceList.Count - 1 do
      ComposeReference{TFhirCondition}(json, '', elem.reasonReferenceList[i]); {z - Reference(Condition)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('insurance') and (elem.insuranceList.Count > 0) then
  begin
    json.valueArray('insurance');
    for i := 0 to elem.insuranceList.Count - 1 do
      ComposeReference{TFhirCoverage}(json, '', elem.insuranceList[i]); {z - Reference(Coverage)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('supportingInfo') and (elem.supportingInfoList.Count > 0) then
  begin
    json.valueArray('supportingInfo');
    for i := 0 to elem.supportingInfoList.Count - 1 do
      ComposeReference{TFhirReference}(json, '', elem.supportingInfoList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('specimen') and (elem.specimenList.Count > 0) then
  begin
    json.valueArray('specimen');
    for i := 0 to elem.specimenList.Count - 1 do
      ComposeReference{TFhirSpecimen}(json, '', elem.specimenList[i]); {z - Reference(Specimen)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('bodySite') and (elem.bodySiteList.Count > 0) then
  begin
    json.valueArray('bodySite');
    for i := 0 to elem.bodySiteList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.bodySiteList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('note') and (elem.noteList.Count > 0) then
  begin
    json.valueArray('note');
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(json, '', elem.noteList[i]); {z - Annotation}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('patientInstruction') then
    ComposeStringValue(json, 'patientInstruction', elem.patientInstructionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('patientInstruction') then
    ComposeStringProps(json, 'patientInstruction', elem.patientInstructionElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('relevantHistory') and (elem.relevantHistoryList.Count > 0) then
  begin
    json.valueArray('relevantHistory');
    for i := 0 to elem.relevantHistoryList.Count - 1 do
      ComposeReference{TFhirProvenance}(json, '', elem.relevantHistoryList[i]); {z - Reference(Provenance)}
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_SERVICEREQUEST}
{$IFDEF FHIR_SLOT}
procedure TFHIRJsonParser.ParseSlot(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSlot(jsn)); {2}
end;

function TFHIRJsonParser.ParseSlot(jsn : TJsonObject) : TFhirSlot;
begin
  result := TFhirSlot.create;
  try
    ParseSlotProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSlotProperties(jsn : TJsonObject; result : TFhirSlot);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('serviceCategory') then
      iterateArray(jsn.vArr['serviceCategory'], result.serviceCategoryList, parseCodeableConcept);
    if jsn.has('serviceType') then
      iterateArray(jsn.vArr['serviceType'], result.serviceTypeList, parseCodeableConcept);
    if jsn.has('specialty') then
      iterateArray(jsn.vArr['specialty'], result.specialtyList, parseCodeableConcept);
    if jsn.has('appointmentType') then
        result.appointmentType := ParseCodeableConcept(jsn.vObj['appointmentType']);{q3}
    if jsn.has('schedule') then
        result.schedule := ParseReference{TFhirSchedule}(jsn.vObj['schedule']);{q3}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirSlotstatusEnum, SYSTEMS_TFhirSlotstatusEnum);
    if jsn.has('start') or jsn.has('_start') then
        result.startElement := parseInstant(jsn.node['start'], jsn.vObj['_start']);{q}
    if jsn.has('end') or jsn.has('_end') then
        result.end_Element := parseInstant(jsn.node['end'], jsn.vObj['_end']);{q}
    if jsn.has('overbooked') or jsn.has('_overbooked') then
        result.overbookedElement := parseBoolean(jsn.node['overbooked'], jsn.vObj['_overbooked']);{q}
    if jsn.has('comment') or jsn.has('_comment') then
        result.commentElement := parseString(jsn.node['comment'], jsn.vObj['_comment']);{q}
end;

procedure TFHIRJsonComposer.ComposeSlot(json : TJSONWriter; name : string; elem : TFhirSlot; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('serviceCategory') and (elem.serviceCategoryList.Count > 0) then
  begin
    json.valueArray('serviceCategory');
    for i := 0 to elem.serviceCategoryList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.serviceCategoryList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('serviceType') and (elem.serviceTypeList.Count > 0) then
  begin
    json.valueArray('serviceType');
    for i := 0 to elem.serviceTypeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.serviceTypeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('specialty') and (elem.specialtyList.Count > 0) then
  begin
    json.valueArray('specialty');
    for i := 0 to elem.specialtyList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.specialtyList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('appointmentType') then
    ComposeCodeableConcept(json, 'appointmentType', elem.appointmentType); {a}
  ComposeReference{TFhirSchedule}(json, 'schedule', elem.schedule); {a}
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirSlotstatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirSlotstatusEnum, false);
  ComposeInstantValue(json, 'start', elem.startElement, false);
  ComposeInstantProps(json, 'start', elem.startElement, false);
  ComposeInstantValue(json, 'end', elem.end_Element, false);
  ComposeInstantProps(json, 'end', elem.end_Element, false);
  if (SummaryOption in [soFull, soData]) and doCompose('overbooked') then
    ComposeBooleanValue(json, 'overbooked', elem.overbookedElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('overbooked') then
    ComposeBooleanProps(json, 'overbooked', elem.overbookedElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('comment') then
    ComposeStringValue(json, 'comment', elem.commentElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('comment') then
    ComposeStringProps(json, 'comment', elem.commentElement, false);
end;

{$ENDIF FHIR_SLOT}
{$IFDEF FHIR_SPECIMEN}
procedure TFHIRJsonParser.ParseSpecimenCollection(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSpecimenCollection(jsn)); {2}
end;

function TFHIRJsonParser.ParseSpecimenCollection(jsn : TJsonObject) : TFhirSpecimenCollection;
begin
  result := TFhirSpecimenCollection.create;
  try
    ParseSpecimenCollectionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSpecimenCollectionProperties(jsn : TJsonObject; result : TFhirSpecimenCollection);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('collector') then
        result.collector := ParseReference{TFhirPractitioner}(jsn.vObj['collector']);{q3}
    if jsn.has('collectedPeriod') {a4} then
      result.collected := ParsePeriod(jsn.vObj['collectedPeriod']);
    if jsn.has('collectedDateTime') or jsn.has('_collectedDateTime') then
      result.collected := parseDateTime(jsn.node['collectedDateTime'], jsn.vObj['_collectedDateTime']);
    if jsn.has('duration') then
        result.duration := ParseDuration(jsn.vObj['duration']);{q3}
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q3}
    if jsn.has('method') then
        result.method := ParseCodeableConcept(jsn.vObj['method']);{q3}
    if jsn.has('bodySite') then
        result.bodySite := ParseCodeableConcept(jsn.vObj['bodySite']);{q3}
    if jsn.has('fastingStatusCodeableConcept') {a4} then
      result.fastingStatus := ParseCodeableConcept(jsn.vObj['fastingStatusCodeableConcept']);
    if jsn.has('fastingStatusDuration') {a4} then
      result.fastingStatus := ParseDuration(jsn.vObj['fastingStatusDuration']);
end;

procedure TFHIRJsonComposer.ComposeSpecimenCollection(json : TJSONWriter; name : string; elem : TFhirSpecimenCollection; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(json, 'collector', elem.collector); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.collected is TFhirPeriod) then 
    ComposePeriod(json, 'collectedPeriod', TFhirPeriod(elem.collected)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.collected is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'collectedDateTime', TFhirDateTime(elem.collected), false);
    ComposeDateTimeProps(json, 'collectedDateTime', TFhirDateTime(elem.collected), false);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDuration(json, 'duration', elem.duration); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'quantity', elem.quantity); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'method', elem.method); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'bodySite', elem.bodySite); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.fastingStatus is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'fastingStatusCodeableConcept', TFhirCodeableConcept(elem.fastingStatus)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.fastingStatus is TFhirDuration) then 
    ComposeDuration(json, 'fastingStatusDuration', TFhirDuration(elem.fastingStatus)) ;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseSpecimenProcessing(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSpecimenProcessing(jsn)); {2}
end;

function TFHIRJsonParser.ParseSpecimenProcessing(jsn : TJsonObject) : TFhirSpecimenProcessing;
begin
  result := TFhirSpecimenProcessing.create;
  try
    ParseSpecimenProcessingProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSpecimenProcessingProperties(jsn : TJsonObject; result : TFhirSpecimenProcessing);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('procedure') then
        result.procedure_ := ParseCodeableConcept(jsn.vObj['procedure']);{q3}
    if jsn.has('additive') then
      iterateArray(jsn.vArr['additive'], result.additiveList, parseReference{TFhirSubstance});
    if jsn.has('timePeriod') {a4} then
      result.time := ParsePeriod(jsn.vObj['timePeriod']);
    if jsn.has('timeDateTime') or jsn.has('_timeDateTime') then
      result.time := parseDateTime(jsn.node['timeDateTime'], jsn.vObj['_timeDateTime']);
end;

procedure TFHIRJsonComposer.ComposeSpecimenProcessing(json : TJSONWriter; name : string; elem : TFhirSpecimenProcessing; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'procedure', elem.procedure_); {a}
  if (SummaryOption in [soFull, soData]) and (elem.additiveList.Count > 0) then
  begin
    json.valueArray('additive');
    for i := 0 to elem.additiveList.Count - 1 do
      ComposeReference{TFhirSubstance}(json, '', elem.additiveList[i]); {z - Reference(Substance)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.time is TFhirPeriod) then 
    ComposePeriod(json, 'timePeriod', TFhirPeriod(elem.time)) 
  else if (SummaryOption in [soFull, soData]) and (elem.time is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'timeDateTime', TFhirDateTime(elem.time), false);
    ComposeDateTimeProps(json, 'timeDateTime', TFhirDateTime(elem.time), false);
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseSpecimenContainer(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSpecimenContainer(jsn)); {2}
end;

function TFHIRJsonParser.ParseSpecimenContainer(jsn : TJsonObject) : TFhirSpecimenContainer;
begin
  result := TFhirSpecimenContainer.create;
  try
    ParseSpecimenContainerProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSpecimenContainerProperties(jsn : TJsonObject; result : TFhirSpecimenContainer);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('capacity') then
        result.capacity := ParseQuantity(jsn.vObj['capacity']);{q3}
    if jsn.has('specimenQuantity') then
        result.specimenQuantity := ParseQuantity(jsn.vObj['specimenQuantity']);{q3}
    if jsn.has('additiveCodeableConcept') {a4} then
      result.additive := ParseCodeableConcept(jsn.vObj['additiveCodeableConcept']);
    if jsn.has('additiveReference') {a3} then
      result.additive := ParseReference(jsn.vObj['additiveReference']);
end;

procedure TFHIRJsonComposer.ComposeSpecimenContainer(json : TJSONWriter; name : string; elem : TFhirSpecimenContainer; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'capacity', elem.capacity); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'specimenQuantity', elem.specimenQuantity); {a}
  if (SummaryOption in [soFull, soData]) and (elem.additive is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'additiveCodeableConcept', TFhirCodeableConcept(elem.additive)) 
  else if (SummaryOption in [soFull, soData]) and (elem.additive is TFhirReference) then
    ComposeReference(json, 'additiveReference', TFhirReference(elem.additive));
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseSpecimen(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSpecimen(jsn)); {2}
end;

function TFHIRJsonParser.ParseSpecimen(jsn : TJsonObject) : TFhirSpecimen;
begin
  result := TFhirSpecimen.create;
  try
    ParseSpecimenProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSpecimenProperties(jsn : TJsonObject; result : TFhirSpecimen);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('accessionIdentifier') then
        result.accessionIdentifier := ParseIdentifier(jsn.vObj['accessionIdentifier']);{q3}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirSpecimenStatusEnum, SYSTEMS_TFhirSpecimenStatusEnum);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirPatient}(jsn.vObj['subject']);{q3}
    if jsn.has('receivedTime') or jsn.has('_receivedTime') then
        result.receivedTimeElement := parseDateTime(jsn.node['receivedTime'], jsn.vObj['_receivedTime']);{q}
    if jsn.has('parent') then
      iterateArray(jsn.vArr['parent'], result.parentList, parseReference{TFhirSpecimen});
    if jsn.has('request') then
      iterateArray(jsn.vArr['request'], result.requestList, parseReference{TFhirServiceRequest});
    if jsn.has('collection') then
        result.collection := ParseSpecimenCollection(jsn.vObj['collection']);{q3}
    if jsn.has('processing') then
      iterateArray(jsn.vArr['processing'], result.processingList, parseSpecimenProcessing);
    if jsn.has('container') then
      iterateArray(jsn.vArr['container'], result.containerList, parseSpecimenContainer);
    if jsn.has('condition') then
      iterateArray(jsn.vArr['condition'], result.conditionList, parseCodeableConcept);
    if jsn.has('note') then
      iterateArray(jsn.vArr['note'], result.noteList, parseAnnotation);
end;

procedure TFHIRJsonComposer.ComposeSpecimen(json : TJSONWriter; name : string; elem : TFhirSpecimen; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('accessionIdentifier') then
    ComposeIdentifier(json, 'accessionIdentifier', elem.accessionIdentifier); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirSpecimenStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirSpecimenStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{TFhirPatient}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('receivedTime') then
    ComposeDateTimeValue(json, 'receivedTime', elem.receivedTimeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('receivedTime') then
    ComposeDateTimeProps(json, 'receivedTime', elem.receivedTimeElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('parent') and (elem.parentList.Count > 0) then
  begin
    json.valueArray('parent');
    for i := 0 to elem.parentList.Count - 1 do
      ComposeReference{TFhirSpecimen}(json, '', elem.parentList[i]); {z - Reference(Specimen)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('request') and (elem.requestList.Count > 0) then
  begin
    json.valueArray('request');
    for i := 0 to elem.requestList.Count - 1 do
      ComposeReference{TFhirServiceRequest}(json, '', elem.requestList[i]); {z - Reference(ServiceRequest)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('collection') then
    ComposeSpecimenCollection(json, 'collection', elem.collection); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('processing') and (elem.processingList.Count > 0) then
  begin
    json.valueArray('processing');
    for i := 0 to elem.processingList.Count - 1 do
      ComposeSpecimenProcessing(json, '', elem.processingList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('container') and (elem.containerList.Count > 0) then
  begin
    json.valueArray('container');
    for i := 0 to elem.containerList.Count - 1 do
      ComposeSpecimenContainer(json, '', elem.containerList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('condition') and (elem.conditionList.Count > 0) then
  begin
    json.valueArray('condition');
    for i := 0 to elem.conditionList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.conditionList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('note') and (elem.noteList.Count > 0) then
  begin
    json.valueArray('note');
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(json, '', elem.noteList[i]); {z - Annotation}
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_SPECIMEN}
{$IFDEF FHIR_SPECIMENDEFINITION}
procedure TFHIRJsonParser.ParseSpecimenDefinitionTypeTested(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSpecimenDefinitionTypeTested(jsn)); {2}
end;

function TFHIRJsonParser.ParseSpecimenDefinitionTypeTested(jsn : TJsonObject) : TFhirSpecimenDefinitionTypeTested;
begin
  result := TFhirSpecimenDefinitionTypeTested.create;
  try
    ParseSpecimenDefinitionTypeTestedProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSpecimenDefinitionTypeTestedProperties(jsn : TJsonObject; result : TFhirSpecimenDefinitionTypeTested);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('isDerived') or jsn.has('_isDerived') then
        result.isDerivedElement := parseBoolean(jsn.node['isDerived'], jsn.vObj['_isDerived']);{q}
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('preference') or jsn.has('_preference')  then
      result.preferenceElement := parseEnum(jsn.path+'/preference', jsn.node['preference'], jsn.vObj['_preference'], CODES_TFhirSpecimenContainedPreferenceEnum, SYSTEMS_TFhirSpecimenContainedPreferenceEnum);
    if jsn.has('container') then
        result.container := ParseSpecimenDefinitionTypeTestedContainer(jsn.vObj['container']);{q3}
    if jsn.has('requirement') or jsn.has('_requirement') then
        result.requirementElement := parseString(jsn.node['requirement'], jsn.vObj['_requirement']);{q}
    if jsn.has('retentionTime') then
        result.retentionTime := ParseDuration(jsn.vObj['retentionTime']);{q3}
    if jsn.has('rejectionCriterion') then
      iterateArray(jsn.vArr['rejectionCriterion'], result.rejectionCriterionList, parseCodeableConcept);
    if jsn.has('handling') then
      iterateArray(jsn.vArr['handling'], result.handlingList, parseSpecimenDefinitionTypeTestedHandling);
end;

procedure TFHIRJsonComposer.ComposeSpecimenDefinitionTypeTested(json : TJSONWriter; name : string; elem : TFhirSpecimenDefinitionTypeTested; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
  ComposeBooleanValue(json, 'isDerived', elem.isDerivedElement, false);
  if (SummaryOption in [soFull, soData]) then
  ComposeBooleanProps(json, 'isDerived', elem.isDerivedElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  ComposeEnumValue(json, 'preference', elem.PreferenceElement, CODES_TFhirSpecimenContainedPreferenceEnum, false);
  ComposeEnumProps(json, 'preference', elem.PreferenceElement, CODES_TFhirSpecimenContainedPreferenceEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeSpecimenDefinitionTypeTestedContainer(json, 'container', elem.container); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'requirement', elem.requirementElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'requirement', elem.requirementElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDuration(json, 'retentionTime', elem.retentionTime); {a}
  if (SummaryOption in [soFull, soData]) and (elem.rejectionCriterionList.Count > 0) then
  begin
    json.valueArray('rejectionCriterion');
    for i := 0 to elem.rejectionCriterionList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.rejectionCriterionList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.handlingList.Count > 0) then
  begin
    json.valueArray('handling');
    for i := 0 to elem.handlingList.Count - 1 do
      ComposeSpecimenDefinitionTypeTestedHandling(json, '', elem.handlingList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseSpecimenDefinitionTypeTestedContainer(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSpecimenDefinitionTypeTestedContainer(jsn)); {2}
end;

function TFHIRJsonParser.ParseSpecimenDefinitionTypeTestedContainer(jsn : TJsonObject) : TFhirSpecimenDefinitionTypeTestedContainer;
begin
  result := TFhirSpecimenDefinitionTypeTestedContainer.create;
  try
    ParseSpecimenDefinitionTypeTestedContainerProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSpecimenDefinitionTypeTestedContainerProperties(jsn : TJsonObject; result : TFhirSpecimenDefinitionTypeTestedContainer);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('material') then
        result.material := ParseCodeableConcept(jsn.vObj['material']);{q3}
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('cap') then
        result.cap := ParseCodeableConcept(jsn.vObj['cap']);{q3}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('capacity') then
        result.capacity := ParseQuantity(jsn.vObj['capacity']);{q3}
    if jsn.has('minimumVolumeQuantity') {a4} then
      result.minimumVolume := ParseQuantity(jsn.vObj['minimumVolumeQuantity']);
    if jsn.has('minimumVolumeString') or jsn.has('_minimumVolumeString') then
      result.minimumVolume := parseString(jsn.node['minimumVolumeString'], jsn.vObj['_minimumVolumeString']);
    if jsn.has('additive') then
      iterateArray(jsn.vArr['additive'], result.additiveList, parseSpecimenDefinitionTypeTestedContainerAdditive);
    if jsn.has('preparation') or jsn.has('_preparation') then
        result.preparationElement := parseString(jsn.node['preparation'], jsn.vObj['_preparation']);{q}
end;

procedure TFHIRJsonComposer.ComposeSpecimenDefinitionTypeTestedContainer(json : TJSONWriter; name : string; elem : TFhirSpecimenDefinitionTypeTestedContainer; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'material', elem.material); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'cap', elem.cap); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'capacity', elem.capacity); {a}
  if (SummaryOption in [soFull, soData]) and (elem.minimumVolume is TFhirQuantity) then 
    ComposeQuantity(json, 'minimumVolumeQuantity', TFhirQuantity(elem.minimumVolume)) 
  else if (SummaryOption in [soFull, soData]) and (elem.minimumVolume is TFhirString) then 
  begin
    ComposeStringValue(json, 'minimumVolumeString', TFhirString(elem.minimumVolume), false);
    ComposeStringProps(json, 'minimumVolumeString', TFhirString(elem.minimumVolume), false);
  end;
  if (SummaryOption in [soFull, soData]) and (elem.additiveList.Count > 0) then
  begin
    json.valueArray('additive');
    for i := 0 to elem.additiveList.Count - 1 do
      ComposeSpecimenDefinitionTypeTestedContainerAdditive(json, '', elem.additiveList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'preparation', elem.preparationElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'preparation', elem.preparationElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseSpecimenDefinitionTypeTestedContainerAdditive(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSpecimenDefinitionTypeTestedContainerAdditive(jsn)); {2}
end;

function TFHIRJsonParser.ParseSpecimenDefinitionTypeTestedContainerAdditive(jsn : TJsonObject) : TFhirSpecimenDefinitionTypeTestedContainerAdditive;
begin
  result := TFhirSpecimenDefinitionTypeTestedContainerAdditive.create;
  try
    ParseSpecimenDefinitionTypeTestedContainerAdditiveProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSpecimenDefinitionTypeTestedContainerAdditiveProperties(jsn : TJsonObject; result : TFhirSpecimenDefinitionTypeTestedContainerAdditive);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('additiveCodeableConcept') {a4} then
      result.additive := ParseCodeableConcept(jsn.vObj['additiveCodeableConcept']);
    if jsn.has('additiveReference') {a3} then
      result.additive := ParseReference(jsn.vObj['additiveReference']);
end;

procedure TFHIRJsonComposer.ComposeSpecimenDefinitionTypeTestedContainerAdditive(json : TJSONWriter; name : string; elem : TFhirSpecimenDefinitionTypeTestedContainerAdditive; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (elem.additive is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'additiveCodeableConcept', TFhirCodeableConcept(elem.additive)) 
  else if (elem.additive is TFhirReference) then
    ComposeReference(json, 'additiveReference', TFhirReference(elem.additive));
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseSpecimenDefinitionTypeTestedHandling(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSpecimenDefinitionTypeTestedHandling(jsn)); {2}
end;

function TFHIRJsonParser.ParseSpecimenDefinitionTypeTestedHandling(jsn : TJsonObject) : TFhirSpecimenDefinitionTypeTestedHandling;
begin
  result := TFhirSpecimenDefinitionTypeTestedHandling.create;
  try
    ParseSpecimenDefinitionTypeTestedHandlingProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSpecimenDefinitionTypeTestedHandlingProperties(jsn : TJsonObject; result : TFhirSpecimenDefinitionTypeTestedHandling);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('temperatureQualifier') then
        result.temperatureQualifier := ParseCodeableConcept(jsn.vObj['temperatureQualifier']);{q3}
    if jsn.has('temperatureRange') then
        result.temperatureRange := ParseRange(jsn.vObj['temperatureRange']);{q3}
    if jsn.has('maxDuration') then
        result.maxDuration := ParseDuration(jsn.vObj['maxDuration']);{q3}
    if jsn.has('instruction') or jsn.has('_instruction') then
        result.instructionElement := parseString(jsn.node['instruction'], jsn.vObj['_instruction']);{q}
end;

procedure TFHIRJsonComposer.ComposeSpecimenDefinitionTypeTestedHandling(json : TJSONWriter; name : string; elem : TFhirSpecimenDefinitionTypeTestedHandling; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'temperatureQualifier', elem.temperatureQualifier); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeRange(json, 'temperatureRange', elem.temperatureRange); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeDuration(json, 'maxDuration', elem.maxDuration); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'instruction', elem.instructionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'instruction', elem.instructionElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseSpecimenDefinition(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSpecimenDefinition(jsn)); {2}
end;

function TFHIRJsonParser.ParseSpecimenDefinition(jsn : TJsonObject) : TFhirSpecimenDefinition;
begin
  result := TFhirSpecimenDefinition.create;
  try
    ParseSpecimenDefinitionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSpecimenDefinitionProperties(jsn : TJsonObject; result : TFhirSpecimenDefinition);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q3}
    if jsn.has('typeCollected') then
        result.typeCollected := ParseCodeableConcept(jsn.vObj['typeCollected']);{q3}
    if jsn.has('patientPreparation') then
      iterateArray(jsn.vArr['patientPreparation'], result.patientPreparationList, parseCodeableConcept);
    if jsn.has('timeAspect') or jsn.has('_timeAspect') then
        result.timeAspectElement := parseString(jsn.node['timeAspect'], jsn.vObj['_timeAspect']);{q}
    if jsn.has('collection') then
      iterateArray(jsn.vArr['collection'], result.collectionList, parseCodeableConcept);
    if jsn.has('typeTested') then
      iterateArray(jsn.vArr['typeTested'], result.typeTestedList, parseSpecimenDefinitionTypeTested);
end;

procedure TFHIRJsonComposer.ComposeSpecimenDefinition(json : TJSONWriter; name : string; elem : TFhirSpecimenDefinition; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('typeCollected') then
    ComposeCodeableConcept(json, 'typeCollected', elem.typeCollected); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('patientPreparation') and (elem.patientPreparationList.Count > 0) then
  begin
    json.valueArray('patientPreparation');
    for i := 0 to elem.patientPreparationList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.patientPreparationList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('timeAspect') then
    ComposeStringValue(json, 'timeAspect', elem.timeAspectElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('timeAspect') then
    ComposeStringProps(json, 'timeAspect', elem.timeAspectElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('collection') and (elem.collectionList.Count > 0) then
  begin
    json.valueArray('collection');
    for i := 0 to elem.collectionList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.collectionList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('typeTested') and (elem.typeTestedList.Count > 0) then
  begin
    json.valueArray('typeTested');
    for i := 0 to elem.typeTestedList.Count - 1 do
      ComposeSpecimenDefinitionTypeTested(json, '', elem.typeTestedList[i]); {z - }
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_SPECIMENDEFINITION}
{$IFDEF FHIR_STRUCTUREDEFINITION}
procedure TFHIRJsonParser.ParseStructureDefinitionMapping(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseStructureDefinitionMapping(jsn)); {2}
end;

function TFHIRJsonParser.ParseStructureDefinitionMapping(jsn : TJsonObject) : TFhirStructureDefinitionMapping;
begin
  result := TFhirStructureDefinitionMapping.create;
  try
    ParseStructureDefinitionMappingProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseStructureDefinitionMappingProperties(jsn : TJsonObject; result : TFhirStructureDefinitionMapping);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identity') or jsn.has('_identity') then
        result.identityElement := parseId(jsn.node['identity'], jsn.vObj['_identity']);{q}
    if jsn.has('uri') or jsn.has('_uri') then
        result.uriElement := parseUri(jsn.node['uri'], jsn.vObj['_uri']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('comment') or jsn.has('_comment') then
        result.commentElement := parseString(jsn.node['comment'], jsn.vObj['_comment']);{q}
end;

procedure TFHIRJsonComposer.ComposeStructureDefinitionMapping(json : TJSONWriter; name : string; elem : TFhirStructureDefinitionMapping; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeIdValue(json, 'identity', elem.identityElement, false);
  ComposeIdProps(json, 'identity', elem.identityElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeUriValue(json, 'uri', elem.uriElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeUriProps(json, 'uri', elem.uriElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'comment', elem.commentElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'comment', elem.commentElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseStructureDefinitionContext(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseStructureDefinitionContext(jsn)); {2}
end;

function TFHIRJsonParser.ParseStructureDefinitionContext(jsn : TJsonObject) : TFhirStructureDefinitionContext;
begin
  result := TFhirStructureDefinitionContext.create;
  try
    ParseStructureDefinitionContextProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseStructureDefinitionContextProperties(jsn : TJsonObject; result : TFhirStructureDefinitionContext);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn.node['type'], jsn.vObj['_type'], CODES_TFhirExtensionContextTypeEnum, SYSTEMS_TFhirExtensionContextTypeEnum);
    if jsn.has('expression') or jsn.has('_expression') then
        result.expressionElement := parseString(jsn.node['expression'], jsn.vObj['_expression']);{q}
end;

procedure TFHIRJsonComposer.ComposeStructureDefinitionContext(json : TJSONWriter; name : string; elem : TFhirStructureDefinitionContext; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirExtensionContextTypeEnum, false);
  ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirExtensionContextTypeEnum, false);
  ComposeStringValue(json, 'expression', elem.expressionElement, false);
  ComposeStringProps(json, 'expression', elem.expressionElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseStructureDefinitionSnapshot(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseStructureDefinitionSnapshot(jsn)); {2}
end;

function TFHIRJsonParser.ParseStructureDefinitionSnapshot(jsn : TJsonObject) : TFhirStructureDefinitionSnapshot;
begin
  result := TFhirStructureDefinitionSnapshot.create;
  try
    ParseStructureDefinitionSnapshotProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseStructureDefinitionSnapshotProperties(jsn : TJsonObject; result : TFhirStructureDefinitionSnapshot);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('element') then
      iterateArray(jsn.vArr['element'], result.elementList, parseElementDefinition);
end;

procedure TFHIRJsonComposer.ComposeStructureDefinitionSnapshot(json : TJSONWriter; name : string; elem : TFhirStructureDefinitionSnapshot; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (elem.elementList.Count > 0) then
  begin
    json.valueArray('element');
    for i := 0 to elem.elementList.Count - 1 do
      ComposeElementDefinition(json, '', elem.elementList[i]); {z - ElementDefinition}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseStructureDefinitionDifferential(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseStructureDefinitionDifferential(jsn)); {2}
end;

function TFHIRJsonParser.ParseStructureDefinitionDifferential(jsn : TJsonObject) : TFhirStructureDefinitionDifferential;
begin
  result := TFhirStructureDefinitionDifferential.create;
  try
    ParseStructureDefinitionDifferentialProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseStructureDefinitionDifferentialProperties(jsn : TJsonObject; result : TFhirStructureDefinitionDifferential);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('element') then
      iterateArray(jsn.vArr['element'], result.elementList, parseElementDefinition);
end;

procedure TFHIRJsonComposer.ComposeStructureDefinitionDifferential(json : TJSONWriter; name : string; elem : TFhirStructureDefinitionDifferential; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (elem.elementList.Count > 0) then
  begin
    json.valueArray('element');
    for i := 0 to elem.elementList.Count - 1 do
      ComposeElementDefinition(json, '', elem.elementList[i]); {z - ElementDefinition}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseStructureDefinition(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseStructureDefinition(jsn)); {2}
end;

function TFHIRJsonParser.ParseStructureDefinition(jsn : TJsonObject) : TFhirStructureDefinition;
begin
  result := TFhirStructureDefinition.create;
  try
    ParseStructureDefinitionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseStructureDefinitionProperties(jsn : TJsonObject; result : TFhirStructureDefinition);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := parseUri(jsn.node['url'], jsn.vObj['_url']);{q}
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := parseString(jsn.node['version'], jsn.vObj['_version']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('title') or jsn.has('_title') then
        result.titleElement := parseString(jsn.node['title'], jsn.vObj['_title']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    if jsn.has('experimental') or jsn.has('_experimental') then
        result.experimentalElement := parseBoolean(jsn.node['experimental'], jsn.vObj['_experimental']);{q}
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := parseDateTime(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('publisher') or jsn.has('_publisher') then
        result.publisherElement := parseString(jsn.node['publisher'], jsn.vObj['_publisher']);{q}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseContactDetail);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseMarkdown(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('useContext') then
      iterateArray(jsn.vArr['useContext'], result.useContextList, parseUsageContext);
    if jsn.has('jurisdiction') then
      iterateArray(jsn.vArr['jurisdiction'], result.jurisdictionList, parseCodeableConcept);
    if jsn.has('purpose') or jsn.has('_purpose') then
        result.purposeElement := parseMarkdown(jsn.node['purpose'], jsn.vObj['_purpose']);{q}
    if jsn.has('copyright') or jsn.has('_copyright') then
        result.copyrightElement := parseMarkdown(jsn.node['copyright'], jsn.vObj['_copyright']);{q}
    if jsn.has('keyword') then
      iterateArray(jsn.vArr['keyword'], result.keywordList, parseCoding);
    if jsn.has('fhirVersion') or jsn.has('_fhirVersion') then
      result.fhirVersionElement := parseEnum(jsn.path+'/fhirVersion', jsn.node['fhirVersion'], jsn.vObj['_fhirVersion'], CODES_TFhirFHIRVersionEnum, SYSTEMS_TFhirFHIRVersionEnum);
    if jsn.has('mapping') then
      iterateArray(jsn.vArr['mapping'], result.mappingList, parseStructureDefinitionMapping);
    if jsn.has('kind') or jsn.has('_kind')  then
      result.kindElement := parseEnum(jsn.path+'/kind', jsn.node['kind'], jsn.vObj['_kind'], CODES_TFhirStructureDefinitionKindEnum, SYSTEMS_TFhirStructureDefinitionKindEnum);
    if jsn.has('abstract') or jsn.has('_abstract') then
        result.abstractElement := parseBoolean(jsn.node['abstract'], jsn.vObj['_abstract']);{q}
    if jsn.has('context') then
      iterateArray(jsn.vArr['context'], result.contextList, parseStructureDefinitionContext);
      if jsn.has('contextInvariant') or jsn.has('_contextInvariant') then
      iteratePrimitiveArray(jsn.vArr['contextInvariant'], jsn.vArr['_contextInvariant'], result.contextInvariantList, parseString);
    if jsn.has('type') or jsn.has('_type') then
        result.type_Element := parseUri(jsn.node['type'], jsn.vObj['_type']);{q}
    if jsn.has('baseDefinition') or jsn.has('_baseDefinition') then
        result.baseDefinitionElement := parseCanonical(jsn.node['baseDefinition'], jsn.vObj['_baseDefinition']);{q}
    if jsn.has('derivation') or jsn.has('_derivation')  then
      result.derivationElement := parseEnum(jsn.path+'/derivation', jsn.node['derivation'], jsn.vObj['_derivation'], CODES_TFhirTypeDerivationRuleEnum, SYSTEMS_TFhirTypeDerivationRuleEnum);
    if jsn.has('snapshot') then
        result.snapshot := ParseStructureDefinitionSnapshot(jsn.vObj['snapshot']);{q3}
    if jsn.has('differential') then
        result.differential := ParseStructureDefinitionDifferential(jsn.vObj['differential']);{q3}
end;

procedure TFHIRJsonComposer.ComposeStructureDefinition(json : TJSONWriter; name : string; elem : TFhirStructureDefinition; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  ComposeUriValue(json, 'url', elem.urlElement, false);
  ComposeUriProps(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeStringValue(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeStringProps(json, 'version', elem.versionElement, false);
  ComposeStringValue(json, 'name', elem.nameElement, false);
  ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeStringValue(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeStringProps(json, 'title', elem.titleElement, false);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBooleanValue(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBooleanProps(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringValue(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringProps(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') and (elem.contactList.Count > 0) then
  begin
    json.valueArray('contact');
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(json, '', elem.contactList[i]); {z - ContactDetail}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdownValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdownProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') and (elem.useContextList.Count > 0) then
  begin
    json.valueArray('useContext');
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(json, '', elem.useContextList[i]); {z - UsageContext}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') and (elem.jurisdictionList.Count > 0) then
  begin
    json.valueArray('jurisdiction');
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.jurisdictionList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdownValue(json, 'purpose', elem.purposeElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdownProps(json, 'purpose', elem.purposeElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdownValue(json, 'copyright', elem.copyrightElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdownProps(json, 'copyright', elem.copyrightElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('keyword') and (elem.keywordList.Count > 0) then
  begin
    json.valueArray('keyword');
    for i := 0 to elem.keywordList.Count - 1 do
      ComposeCoding(json, '', elem.keywordList[i]); {z - Coding}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('fhirVersion') then
    ComposeEnumValue(json, 'fhirVersion', elem.FhirVersionElement, CODES_TFhirFHIRVersionEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('fhirVersion') then
    ComposeEnumProps(json, 'fhirVersion', elem.FhirVersionElement, CODES_TFhirFHIRVersionEnum, false);
  if (SummaryOption in [soFull, soData]) and doCompose('mapping') and (elem.mappingList.Count > 0) then
  begin
    json.valueArray('mapping');
    for i := 0 to elem.mappingList.Count - 1 do
      ComposeStructureDefinitionMapping(json, '', elem.mappingList[i]); {z - }
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'kind', elem.KindElement, CODES_TFhirStructureDefinitionKindEnum, false);
  ComposeEnumProps(json, 'kind', elem.KindElement, CODES_TFhirStructureDefinitionKindEnum, false);
  ComposeBooleanValue(json, 'abstract', elem.abstractElement, false);
  ComposeBooleanProps(json, 'abstract', elem.abstractElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('context') and (elem.contextList.Count > 0) then
  begin
    json.valueArray('context');
    for i := 0 to elem.contextList.Count - 1 do
      ComposeStructureDefinitionContext(json, '', elem.contextList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contextInvariant') and (elem.contextInvariantList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.contextInvariantList.Count - 1 do
    begin
      ext := ext or ((elem.contextInvariantList[i].id <> '') or (elem.contextInvariantList[i].hasExtensionList) {no-comments or (elem.contextInvariantList[i].hasComments)});
      val := val or (elem.contextInvariantList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('contextInvariant');
      for i := 0 to elem.contextInvariantList.Count - 1 do
        ComposeStringValue(json, '',elem.contextInvariantList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_contextInvariant');
      for i := 0 to elem.contextInvariantList.Count - 1 do
        ComposeStringProps(json, '',elem.contextInvariantList[i], true);
      json.FinishArray;
    end;
  end;
  ComposeUriValue(json, 'type', elem.type_Element, false);
  ComposeUriProps(json, 'type', elem.type_Element, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('baseDefinition') then
    ComposeCanonicalValue(json, 'baseDefinition', elem.baseDefinitionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('baseDefinition') then
    ComposeCanonicalProps(json, 'baseDefinition', elem.baseDefinitionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('derivation') then
    ComposeEnumValue(json, 'derivation', elem.DerivationElement, CODES_TFhirTypeDerivationRuleEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('derivation') then
    ComposeEnumProps(json, 'derivation', elem.DerivationElement, CODES_TFhirTypeDerivationRuleEnum, false);
  if (SummaryOption in [soFull, soData]) and doCompose('snapshot') then
    ComposeStructureDefinitionSnapshot(json, 'snapshot', elem.snapshot); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('differential') then
    ComposeStructureDefinitionDifferential(json, 'differential', elem.differential); {a}
end;

{$ENDIF FHIR_STRUCTUREDEFINITION}
{$IFDEF FHIR_STRUCTUREMAP}
procedure TFHIRJsonParser.ParseStructureMapStructure(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseStructureMapStructure(jsn)); {2}
end;

function TFHIRJsonParser.ParseStructureMapStructure(jsn : TJsonObject) : TFhirStructureMapStructure;
begin
  result := TFhirStructureMapStructure.create;
  try
    ParseStructureMapStructureProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseStructureMapStructureProperties(jsn : TJsonObject; result : TFhirStructureMapStructure);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := parseCanonical(jsn.node['url'], jsn.vObj['_url']);{q}
    if jsn.has('mode') or jsn.has('_mode')  then
      result.modeElement := parseEnum(jsn.path+'/mode', jsn.node['mode'], jsn.vObj['_mode'], CODES_TFhirMapModelModeEnum, SYSTEMS_TFhirMapModelModeEnum);
    if jsn.has('alias') or jsn.has('_alias') then
        result.aliasElement := parseString(jsn.node['alias'], jsn.vObj['_alias']);{q}
    if jsn.has('documentation') or jsn.has('_documentation') then
        result.documentationElement := parseString(jsn.node['documentation'], jsn.vObj['_documentation']);{q}
end;

procedure TFHIRJsonComposer.ComposeStructureMapStructure(json : TJSONWriter; name : string; elem : TFhirStructureMapStructure; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCanonicalValue(json, 'url', elem.urlElement, false);
  ComposeCanonicalProps(json, 'url', elem.urlElement, false);
  ComposeEnumValue(json, 'mode', elem.ModeElement, CODES_TFhirMapModelModeEnum, false);
  ComposeEnumProps(json, 'mode', elem.ModeElement, CODES_TFhirMapModelModeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'alias', elem.aliasElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'alias', elem.aliasElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'documentation', elem.documentationElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'documentation', elem.documentationElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseStructureMapGroup(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseStructureMapGroup(jsn)); {2}
end;

function TFHIRJsonParser.ParseStructureMapGroup(jsn : TJsonObject) : TFhirStructureMapGroup;
begin
  result := TFhirStructureMapGroup.create;
  try
    ParseStructureMapGroupProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseStructureMapGroupProperties(jsn : TJsonObject; result : TFhirStructureMapGroup);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseId(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('extends') or jsn.has('_extends') then
        result.extendsElement := parseId(jsn.node['extends'], jsn.vObj['_extends']);{q}
    if jsn.has('typeMode') or jsn.has('_typeMode')  then
      result.typeModeElement := parseEnum(jsn.path+'/typeMode', jsn.node['typeMode'], jsn.vObj['_typeMode'], CODES_TFhirMapGroupTypeModeEnum, SYSTEMS_TFhirMapGroupTypeModeEnum);
    if jsn.has('documentation') or jsn.has('_documentation') then
        result.documentationElement := parseString(jsn.node['documentation'], jsn.vObj['_documentation']);{q}
    if jsn.has('input') then
      iterateArray(jsn.vArr['input'], result.inputList, parseStructureMapGroupInput);
    if jsn.has('rule') then
      iterateArray(jsn.vArr['rule'], result.ruleList, parseStructureMapGroupRule);
end;

procedure TFHIRJsonComposer.ComposeStructureMapGroup(json : TJSONWriter; name : string; elem : TFhirStructureMapGroup; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeIdValue(json, 'name', elem.nameElement, false);
  ComposeIdProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdValue(json, 'extends', elem.extendsElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdProps(json, 'extends', elem.extendsElement, false);
  ComposeEnumValue(json, 'typeMode', elem.TypeModeElement, CODES_TFhirMapGroupTypeModeEnum, false);
  ComposeEnumProps(json, 'typeMode', elem.TypeModeElement, CODES_TFhirMapGroupTypeModeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'documentation', elem.documentationElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'documentation', elem.documentationElement, false);
  if (elem.inputList.Count > 0) then
  begin
    json.valueArray('input');
    for i := 0 to elem.inputList.Count - 1 do
      ComposeStructureMapGroupInput(json, '', elem.inputList[i]); {z - }
    json.FinishArray;
  end;
  if (elem.ruleList.Count > 0) then
  begin
    json.valueArray('rule');
    for i := 0 to elem.ruleList.Count - 1 do
      ComposeStructureMapGroupRule(json, '', elem.ruleList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseStructureMapGroupInput(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseStructureMapGroupInput(jsn)); {2}
end;

function TFHIRJsonParser.ParseStructureMapGroupInput(jsn : TJsonObject) : TFhirStructureMapGroupInput;
begin
  result := TFhirStructureMapGroupInput.create;
  try
    ParseStructureMapGroupInputProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseStructureMapGroupInputProperties(jsn : TJsonObject; result : TFhirStructureMapGroupInput);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseId(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('type') or jsn.has('_type') then
        result.type_Element := parseString(jsn.node['type'], jsn.vObj['_type']);{q}
    if jsn.has('mode') or jsn.has('_mode')  then
      result.modeElement := parseEnum(jsn.path+'/mode', jsn.node['mode'], jsn.vObj['_mode'], CODES_TFhirMapInputModeEnum, SYSTEMS_TFhirMapInputModeEnum);
    if jsn.has('documentation') or jsn.has('_documentation') then
        result.documentationElement := parseString(jsn.node['documentation'], jsn.vObj['_documentation']);{q}
end;

procedure TFHIRJsonComposer.ComposeStructureMapGroupInput(json : TJSONWriter; name : string; elem : TFhirStructureMapGroupInput; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeIdValue(json, 'name', elem.nameElement, false);
  ComposeIdProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'type', elem.type_Element, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'type', elem.type_Element, false);
  ComposeEnumValue(json, 'mode', elem.ModeElement, CODES_TFhirMapInputModeEnum, false);
  ComposeEnumProps(json, 'mode', elem.ModeElement, CODES_TFhirMapInputModeEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'documentation', elem.documentationElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'documentation', elem.documentationElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseStructureMapGroupRule(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseStructureMapGroupRule(jsn)); {2}
end;

function TFHIRJsonParser.ParseStructureMapGroupRule(jsn : TJsonObject) : TFhirStructureMapGroupRule;
begin
  result := TFhirStructureMapGroupRule.create;
  try
    ParseStructureMapGroupRuleProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseStructureMapGroupRuleProperties(jsn : TJsonObject; result : TFhirStructureMapGroupRule);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseId(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('source') then
      iterateArray(jsn.vArr['source'], result.sourceList, parseStructureMapGroupRuleSource);
    if jsn.has('target') then
      iterateArray(jsn.vArr['target'], result.targetList, parseStructureMapGroupRuleTarget);
    if jsn.has('rule') then
      iterateArray(jsn.vArr['rule'], result.ruleList, parseStructureMapGroupRule);
    if jsn.has('dependent') then
      iterateArray(jsn.vArr['dependent'], result.dependentList, parseStructureMapGroupRuleDependent);
    if jsn.has('documentation') or jsn.has('_documentation') then
        result.documentationElement := parseString(jsn.node['documentation'], jsn.vObj['_documentation']);{q}
end;

procedure TFHIRJsonComposer.ComposeStructureMapGroupRule(json : TJSONWriter; name : string; elem : TFhirStructureMapGroupRule; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeIdValue(json, 'name', elem.nameElement, false);
  ComposeIdProps(json, 'name', elem.nameElement, false);
  if (elem.sourceList.Count > 0) then
  begin
    json.valueArray('source');
    for i := 0 to elem.sourceList.Count - 1 do
      ComposeStructureMapGroupRuleSource(json, '', elem.sourceList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.targetList.Count > 0) then
  begin
    json.valueArray('target');
    for i := 0 to elem.targetList.Count - 1 do
      ComposeStructureMapGroupRuleTarget(json, '', elem.targetList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.ruleList.Count > 0) then
  begin
    json.valueArray('rule');
    for i := 0 to elem.ruleList.Count - 1 do
      ComposeStructureMapGroupRule(json, '', elem.ruleList[i]); {z - @StructureMap.group.rule}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.dependentList.Count > 0) then
  begin
    json.valueArray('dependent');
    for i := 0 to elem.dependentList.Count - 1 do
      ComposeStructureMapGroupRuleDependent(json, '', elem.dependentList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'documentation', elem.documentationElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'documentation', elem.documentationElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseStructureMapGroupRuleSource(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseStructureMapGroupRuleSource(jsn)); {2}
end;

function TFHIRJsonParser.ParseStructureMapGroupRuleSource(jsn : TJsonObject) : TFhirStructureMapGroupRuleSource;
begin
  result := TFhirStructureMapGroupRuleSource.create;
  try
    ParseStructureMapGroupRuleSourceProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseStructureMapGroupRuleSourceProperties(jsn : TJsonObject; result : TFhirStructureMapGroupRuleSource);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('context') or jsn.has('_context') then
        result.contextElement := parseId(jsn.node['context'], jsn.vObj['_context']);{q}
    if jsn.has('min') or jsn.has('_min') then
        result.minElement := parseInteger(jsn.node['min'], jsn.vObj['_min']);{q}
    if jsn.has('max') or jsn.has('_max') then
        result.maxElement := parseString(jsn.node['max'], jsn.vObj['_max']);{q}
    if jsn.has('type') or jsn.has('_type') then
        result.type_Element := parseString(jsn.node['type'], jsn.vObj['_type']);{q}
    if jsn.has('defaultValueCanonical') or jsn.has('_defaultValueCanonical') then
      result.defaultValue := parseCanonical(jsn.node['defaultValueCanonical'], jsn.vObj['_defaultValueCanonical']);
    if jsn.has('defaultValueCode') or jsn.has('_defaultValueCode') then
      result.defaultValue := parseCode(jsn.node['defaultValueCode'], jsn.vObj['_defaultValueCode']);
    if jsn.has('defaultValueId') or jsn.has('_defaultValueId') then
      result.defaultValue := parseId(jsn.node['defaultValueId'], jsn.vObj['_defaultValueId']);
    if jsn.has('defaultValueMarkdown') or jsn.has('_defaultValueMarkdown') then
      result.defaultValue := parseMarkdown(jsn.node['defaultValueMarkdown'], jsn.vObj['_defaultValueMarkdown']);
    if jsn.has('defaultValueOid') or jsn.has('_defaultValueOid') then
      result.defaultValue := parseOid(jsn.node['defaultValueOid'], jsn.vObj['_defaultValueOid']);
    if jsn.has('defaultValuePositiveInt') or jsn.has('_defaultValuePositiveInt') then
      result.defaultValue := parsePositiveInt(jsn.node['defaultValuePositiveInt'], jsn.vObj['_defaultValuePositiveInt']);
    if jsn.has('defaultValueUnsignedInt') or jsn.has('_defaultValueUnsignedInt') then
      result.defaultValue := parseUnsignedInt(jsn.node['defaultValueUnsignedInt'], jsn.vObj['_defaultValueUnsignedInt']);
    if jsn.has('defaultValueUrl') or jsn.has('_defaultValueUrl') then
      result.defaultValue := parseUrl(jsn.node['defaultValueUrl'], jsn.vObj['_defaultValueUrl']);
    if jsn.has('defaultValueUuid') or jsn.has('_defaultValueUuid') then
      result.defaultValue := parseUuid(jsn.node['defaultValueUuid'], jsn.vObj['_defaultValueUuid']);
    if jsn.has('defaultValueAddress') {a4} then
      result.defaultValue := ParseAddress(jsn.vObj['defaultValueAddress']);
    if jsn.has('defaultValueAge') {a4} then
      result.defaultValue := ParseAge(jsn.vObj['defaultValueAge']);
    if jsn.has('defaultValueAnnotation') {a4} then
      result.defaultValue := ParseAnnotation(jsn.vObj['defaultValueAnnotation']);
    if jsn.has('defaultValueAttachment') {a4} then
      result.defaultValue := ParseAttachment(jsn.vObj['defaultValueAttachment']);
    if jsn.has('defaultValueCodeableConcept') {a4} then
      result.defaultValue := ParseCodeableConcept(jsn.vObj['defaultValueCodeableConcept']);
    if jsn.has('defaultValueCoding') {a4} then
      result.defaultValue := ParseCoding(jsn.vObj['defaultValueCoding']);
    if jsn.has('defaultValueContactPoint') {a4} then
      result.defaultValue := ParseContactPoint(jsn.vObj['defaultValueContactPoint']);
    if jsn.has('defaultValueCount') {a4} then
      result.defaultValue := ParseCount(jsn.vObj['defaultValueCount']);
    if jsn.has('defaultValueDistance') {a4} then
      result.defaultValue := ParseDistance(jsn.vObj['defaultValueDistance']);
    if jsn.has('defaultValueDuration') {a4} then
      result.defaultValue := ParseDuration(jsn.vObj['defaultValueDuration']);
    if jsn.has('defaultValueHumanName') {a4} then
      result.defaultValue := ParseHumanName(jsn.vObj['defaultValueHumanName']);
    if jsn.has('defaultValueIdentifier') {a4} then
      result.defaultValue := ParseIdentifier(jsn.vObj['defaultValueIdentifier']);
    if jsn.has('defaultValueMoney') {a4} then
      result.defaultValue := ParseMoney(jsn.vObj['defaultValueMoney']);
    if jsn.has('defaultValuePeriod') {a4} then
      result.defaultValue := ParsePeriod(jsn.vObj['defaultValuePeriod']);
    if jsn.has('defaultValueQuantity') {a4} then
      result.defaultValue := ParseQuantity(jsn.vObj['defaultValueQuantity']);
    if jsn.has('defaultValueRange') {a4} then
      result.defaultValue := ParseRange(jsn.vObj['defaultValueRange']);
    if jsn.has('defaultValueRatio') {a4} then
      result.defaultValue := ParseRatio(jsn.vObj['defaultValueRatio']);
    if jsn.has('defaultValueReference') {a4} then
      result.defaultValue := ParseReference(jsn.vObj['defaultValueReference']);
    if jsn.has('defaultValueSampledData') {a4} then
      result.defaultValue := ParseSampledData(jsn.vObj['defaultValueSampledData']);
    if jsn.has('defaultValueSignature') {a4} then
      result.defaultValue := ParseSignature(jsn.vObj['defaultValueSignature']);
    if jsn.has('defaultValueTiming') {a4} then
      result.defaultValue := ParseTiming(jsn.vObj['defaultValueTiming']);
    if jsn.has('defaultValueContactDetail') {a4} then
      result.defaultValue := ParseContactDetail(jsn.vObj['defaultValueContactDetail']);
    if jsn.has('defaultValueContributor') {a4} then
      result.defaultValue := ParseContributor(jsn.vObj['defaultValueContributor']);
    if jsn.has('defaultValueDataRequirement') {a4} then
      result.defaultValue := ParseDataRequirement(jsn.vObj['defaultValueDataRequirement']);
    if jsn.has('defaultValueExpression') {a4} then
      result.defaultValue := ParseExpression(jsn.vObj['defaultValueExpression']);
    if jsn.has('defaultValueParameterDefinition') {a4} then
      result.defaultValue := ParseParameterDefinition(jsn.vObj['defaultValueParameterDefinition']);
    if jsn.has('defaultValueRelatedArtifact') {a4} then
      result.defaultValue := ParseRelatedArtifact(jsn.vObj['defaultValueRelatedArtifact']);
    if jsn.has('defaultValueTriggerDefinition') {a4} then
      result.defaultValue := ParseTriggerDefinition(jsn.vObj['defaultValueTriggerDefinition']);
    if jsn.has('defaultValueUsageContext') {a4} then
      result.defaultValue := ParseUsageContext(jsn.vObj['defaultValueUsageContext']);
    if jsn.has('defaultValueDosage') {a4} then
      result.defaultValue := ParseDosage(jsn.vObj['defaultValueDosage']);
    if jsn.has('defaultValueBase64Binary') or jsn.has('_defaultValueBase64Binary') then
      result.defaultValue := parseBase64Binary(jsn.node['defaultValueBase64Binary'], jsn.vObj['_defaultValueBase64Binary']);
    if jsn.has('defaultValueBoolean') or jsn.has('_defaultValueBoolean') then
      result.defaultValue := parseBoolean(jsn.node['defaultValueBoolean'], jsn.vObj['_defaultValueBoolean']);
    if jsn.has('defaultValueDate') or jsn.has('_defaultValueDate') then
      result.defaultValue := parseDate(jsn.node['defaultValueDate'], jsn.vObj['_defaultValueDate']);
    if jsn.has('defaultValueDateTime') or jsn.has('_defaultValueDateTime') then
      result.defaultValue := parseDateTime(jsn.node['defaultValueDateTime'], jsn.vObj['_defaultValueDateTime']);
    if jsn.has('defaultValueDecimal') or jsn.has('_defaultValueDecimal') then
      result.defaultValue := parseDecimal(jsn.node['defaultValueDecimal'], jsn.vObj['_defaultValueDecimal']);
    if jsn.has('defaultValueInstant') or jsn.has('_defaultValueInstant') then
      result.defaultValue := parseInstant(jsn.node['defaultValueInstant'], jsn.vObj['_defaultValueInstant']);
    if jsn.has('defaultValueInteger') or jsn.has('_defaultValueInteger') then
      result.defaultValue := parseInteger(jsn.node['defaultValueInteger'], jsn.vObj['_defaultValueInteger']);
    if jsn.has('defaultValueString') or jsn.has('_defaultValueString') then
      result.defaultValue := parseString(jsn.node['defaultValueString'], jsn.vObj['_defaultValueString']);
    if jsn.has('defaultValueTime') or jsn.has('_defaultValueTime') then
      result.defaultValue := parseTime(jsn.node['defaultValueTime'], jsn.vObj['_defaultValueTime']);
    if jsn.has('defaultValueUri') or jsn.has('_defaultValueUri') then
      result.defaultValue := parseUri(jsn.node['defaultValueUri'], jsn.vObj['_defaultValueUri']);
    if jsn.has('element') or jsn.has('_element') then
        result.elementElement := parseString(jsn.node['element'], jsn.vObj['_element']);{q}
    if jsn.has('listMode') or jsn.has('_listMode')  then
      result.listModeElement := parseEnum(jsn.path+'/listMode', jsn.node['listMode'], jsn.vObj['_listMode'], CODES_TFhirMapSourceListModeEnum, SYSTEMS_TFhirMapSourceListModeEnum);
    if jsn.has('variable') or jsn.has('_variable') then
        result.variableElement := parseId(jsn.node['variable'], jsn.vObj['_variable']);{q}
    if jsn.has('condition') or jsn.has('_condition') then
        result.conditionElement := parseString(jsn.node['condition'], jsn.vObj['_condition']);{q}
    if jsn.has('check') or jsn.has('_check') then
        result.checkElement := parseString(jsn.node['check'], jsn.vObj['_check']);{q}
    if jsn.has('logMessage') or jsn.has('_logMessage') then
        result.logMessageElement := parseString(jsn.node['logMessage'], jsn.vObj['_logMessage']);{q}
end;

procedure TFHIRJsonComposer.ComposeStructureMapGroupRuleSource(json : TJSONWriter; name : string; elem : TFhirStructureMapGroupRuleSource; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeIdValue(json, 'context', elem.contextElement, false);
  ComposeIdProps(json, 'context', elem.contextElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIntegerValue(json, 'min', elem.minElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIntegerProps(json, 'min', elem.minElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'max', elem.maxElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'max', elem.maxElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'type', elem.type_Element, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'type', elem.type_Element, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirCanonical) then 
  begin
    ComposeCanonicalValue(json, 'defaultValueCanonical', TFhirCanonical(elem.defaultValue), false);
    ComposeCanonicalProps(json, 'defaultValueCanonical', TFhirCanonical(elem.defaultValue), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirCode) then 
  begin
    ComposeCodeValue(json, 'defaultValueCode', TFhirCode(elem.defaultValue), false);
    ComposeCodeProps(json, 'defaultValueCode', TFhirCode(elem.defaultValue), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirId) then 
  begin
    ComposeIdValue(json, 'defaultValueId', TFhirId(elem.defaultValue), false);
    ComposeIdProps(json, 'defaultValueId', TFhirId(elem.defaultValue), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirMarkdown) then 
  begin
    ComposeMarkdownValue(json, 'defaultValueMarkdown', TFhirMarkdown(elem.defaultValue), false);
    ComposeMarkdownProps(json, 'defaultValueMarkdown', TFhirMarkdown(elem.defaultValue), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirOid) then 
  begin
    ComposeOidValue(json, 'defaultValueOid', TFhirOid(elem.defaultValue), false);
    ComposeOidProps(json, 'defaultValueOid', TFhirOid(elem.defaultValue), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirPositiveInt) then 
  begin
    ComposePositiveIntValue(json, 'defaultValuePositiveInt', TFhirPositiveInt(elem.defaultValue), false);
    ComposePositiveIntProps(json, 'defaultValuePositiveInt', TFhirPositiveInt(elem.defaultValue), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirUnsignedInt) then 
  begin
    ComposeUnsignedIntValue(json, 'defaultValueUnsignedInt', TFhirUnsignedInt(elem.defaultValue), false);
    ComposeUnsignedIntProps(json, 'defaultValueUnsignedInt', TFhirUnsignedInt(elem.defaultValue), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirUrl) then 
  begin
    ComposeUrlValue(json, 'defaultValueUrl', TFhirUrl(elem.defaultValue), false);
    ComposeUrlProps(json, 'defaultValueUrl', TFhirUrl(elem.defaultValue), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirUuid) then 
  begin
    ComposeUuidValue(json, 'defaultValueUuid', TFhirUuid(elem.defaultValue), false);
    ComposeUuidProps(json, 'defaultValueUuid', TFhirUuid(elem.defaultValue), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirAddress) then 
    ComposeAddress(json, 'defaultValueAddress', TFhirAddress(elem.defaultValue)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirAge) then 
    ComposeAge(json, 'defaultValueAge', TFhirAge(elem.defaultValue)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirAnnotation) then 
    ComposeAnnotation(json, 'defaultValueAnnotation', TFhirAnnotation(elem.defaultValue)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirAttachment) then 
    ComposeAttachment(json, 'defaultValueAttachment', TFhirAttachment(elem.defaultValue)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'defaultValueCodeableConcept', TFhirCodeableConcept(elem.defaultValue)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirCoding) then 
    ComposeCoding(json, 'defaultValueCoding', TFhirCoding(elem.defaultValue)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirContactPoint) then 
    ComposeContactPoint(json, 'defaultValueContactPoint', TFhirContactPoint(elem.defaultValue)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirCount) then 
    ComposeCount(json, 'defaultValueCount', TFhirCount(elem.defaultValue)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirDistance) then 
    ComposeDistance(json, 'defaultValueDistance', TFhirDistance(elem.defaultValue)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirDuration) then 
    ComposeDuration(json, 'defaultValueDuration', TFhirDuration(elem.defaultValue)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirHumanName) then 
    ComposeHumanName(json, 'defaultValueHumanName', TFhirHumanName(elem.defaultValue)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirIdentifier) then 
    ComposeIdentifier(json, 'defaultValueIdentifier', TFhirIdentifier(elem.defaultValue)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirMoney) then 
    ComposeMoney(json, 'defaultValueMoney', TFhirMoney(elem.defaultValue)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirPeriod) then 
    ComposePeriod(json, 'defaultValuePeriod', TFhirPeriod(elem.defaultValue)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirQuantity) then 
    ComposeQuantity(json, 'defaultValueQuantity', TFhirQuantity(elem.defaultValue)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirRange) then 
    ComposeRange(json, 'defaultValueRange', TFhirRange(elem.defaultValue)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirRatio) then 
    ComposeRatio(json, 'defaultValueRatio', TFhirRatio(elem.defaultValue)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirReference) then 
    ComposeReference(json, 'defaultValueReference', TFhirReference(elem.defaultValue)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirSampledData) then 
    ComposeSampledData(json, 'defaultValueSampledData', TFhirSampledData(elem.defaultValue)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirSignature) then 
    ComposeSignature(json, 'defaultValueSignature', TFhirSignature(elem.defaultValue)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirTiming) then 
    ComposeTiming(json, 'defaultValueTiming', TFhirTiming(elem.defaultValue)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirContactDetail) then 
    ComposeContactDetail(json, 'defaultValueContactDetail', TFhirContactDetail(elem.defaultValue)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirContributor) then 
    ComposeContributor(json, 'defaultValueContributor', TFhirContributor(elem.defaultValue)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirDataRequirement) then 
    ComposeDataRequirement(json, 'defaultValueDataRequirement', TFhirDataRequirement(elem.defaultValue)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirExpression) then 
    ComposeExpression(json, 'defaultValueExpression', TFhirExpression(elem.defaultValue)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirParameterDefinition) then 
    ComposeParameterDefinition(json, 'defaultValueParameterDefinition', TFhirParameterDefinition(elem.defaultValue)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirRelatedArtifact) then 
    ComposeRelatedArtifact(json, 'defaultValueRelatedArtifact', TFhirRelatedArtifact(elem.defaultValue)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirTriggerDefinition) then 
    ComposeTriggerDefinition(json, 'defaultValueTriggerDefinition', TFhirTriggerDefinition(elem.defaultValue)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirUsageContext) then 
    ComposeUsageContext(json, 'defaultValueUsageContext', TFhirUsageContext(elem.defaultValue)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirDosage) then 
    ComposeDosage(json, 'defaultValueDosage', TFhirDosage(elem.defaultValue)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirBase64Binary) then 
  begin
    ComposeBase64BinaryValue(json, 'defaultValueBase64Binary', TFhirBase64Binary(elem.defaultValue), false);
    ComposeBase64BinaryProps(json, 'defaultValueBase64Binary', TFhirBase64Binary(elem.defaultValue), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'defaultValueBoolean', TFhirBoolean(elem.defaultValue), false);
    ComposeBooleanProps(json, 'defaultValueBoolean', TFhirBoolean(elem.defaultValue), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirDate) then 
  begin
    ComposeDateValue(json, 'defaultValueDate', TFhirDate(elem.defaultValue), false);
    ComposeDateProps(json, 'defaultValueDate', TFhirDate(elem.defaultValue), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'defaultValueDateTime', TFhirDateTime(elem.defaultValue), false);
    ComposeDateTimeProps(json, 'defaultValueDateTime', TFhirDateTime(elem.defaultValue), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirDecimal) then 
  begin
    ComposeDecimalValue(json, 'defaultValueDecimal', TFhirDecimal(elem.defaultValue), false);
    ComposeDecimalProps(json, 'defaultValueDecimal', TFhirDecimal(elem.defaultValue), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirInstant) then 
  begin
    ComposeInstantValue(json, 'defaultValueInstant', TFhirInstant(elem.defaultValue), false);
    ComposeInstantProps(json, 'defaultValueInstant', TFhirInstant(elem.defaultValue), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirInteger) then 
  begin
    ComposeIntegerValue(json, 'defaultValueInteger', TFhirInteger(elem.defaultValue), false);
    ComposeIntegerProps(json, 'defaultValueInteger', TFhirInteger(elem.defaultValue), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirString) then 
  begin
    ComposeStringValue(json, 'defaultValueString', TFhirString(elem.defaultValue), false);
    ComposeStringProps(json, 'defaultValueString', TFhirString(elem.defaultValue), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirTime) then 
  begin
    ComposeTimeValue(json, 'defaultValueTime', TFhirTime(elem.defaultValue), false);
    ComposeTimeProps(json, 'defaultValueTime', TFhirTime(elem.defaultValue), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.defaultValue is TFhirUri) then 
  begin
    ComposeUriValue(json, 'defaultValueUri', TFhirUri(elem.defaultValue), false);
    ComposeUriProps(json, 'defaultValueUri', TFhirUri(elem.defaultValue), false);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'element', elem.elementElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'element', elem.elementElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnumValue(json, 'listMode', elem.ListModeElement, CODES_TFhirMapSourceListModeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnumProps(json, 'listMode', elem.ListModeElement, CODES_TFhirMapSourceListModeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdValue(json, 'variable', elem.variableElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdProps(json, 'variable', elem.variableElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'condition', elem.conditionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'condition', elem.conditionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'check', elem.checkElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'check', elem.checkElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'logMessage', elem.logMessageElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'logMessage', elem.logMessageElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseStructureMapGroupRuleTarget(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseStructureMapGroupRuleTarget(jsn)); {2}
end;

function TFHIRJsonParser.ParseStructureMapGroupRuleTarget(jsn : TJsonObject) : TFhirStructureMapGroupRuleTarget;
begin
  result := TFhirStructureMapGroupRuleTarget.create;
  try
    ParseStructureMapGroupRuleTargetProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseStructureMapGroupRuleTargetProperties(jsn : TJsonObject; result : TFhirStructureMapGroupRuleTarget);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('context') or jsn.has('_context') then
        result.contextElement := parseId(jsn.node['context'], jsn.vObj['_context']);{q}
    if jsn.has('contextType') or jsn.has('_contextType')  then
      result.contextTypeElement := parseEnum(jsn.path+'/contextType', jsn.node['contextType'], jsn.vObj['_contextType'], CODES_TFhirMapContextTypeEnum, SYSTEMS_TFhirMapContextTypeEnum);
    if jsn.has('element') or jsn.has('_element') then
        result.elementElement := parseString(jsn.node['element'], jsn.vObj['_element']);{q}
    if jsn.has('variable') or jsn.has('_variable') then
        result.variableElement := parseId(jsn.node['variable'], jsn.vObj['_variable']);{q}
    if jsn.has('listMode') or jsn.has('_listMode') then
      iterateEnumArray(jsn.vArr['listMode'], jsn.vArr['_listMode'], jsn.path+'/listMode', result.listModeList, parseEnum, CODES_TFhirMapTargetListModeEnum, SYSTEMS_TFhirMapTargetListModeEnum);
    if jsn.has('listRuleId') or jsn.has('_listRuleId') then
        result.listRuleIdElement := parseId(jsn.node['listRuleId'], jsn.vObj['_listRuleId']);{q}
    if jsn.has('transform') or jsn.has('_transform')  then
      result.transformElement := parseEnum(jsn.path+'/transform', jsn.node['transform'], jsn.vObj['_transform'], CODES_TFhirMapTransformEnum, SYSTEMS_TFhirMapTransformEnum);
    if jsn.has('parameter') then
      iterateArray(jsn.vArr['parameter'], result.parameterList, parseStructureMapGroupRuleTargetParameter);
end;

procedure TFHIRJsonComposer.ComposeStructureMapGroupRuleTarget(json : TJSONWriter; name : string; elem : TFhirStructureMapGroupRuleTarget; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdValue(json, 'context', elem.contextElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdProps(json, 'context', elem.contextElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnumValue(json, 'contextType', elem.ContextTypeElement, CODES_TFhirMapContextTypeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnumProps(json, 'contextType', elem.ContextTypeElement, CODES_TFhirMapContextTypeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'element', elem.elementElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'element', elem.elementElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdValue(json, 'variable', elem.variableElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdProps(json, 'variable', elem.variableElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.listModeList.Count > 0) then
  begin
    val := false;
    ext := false;
    for i := 0 to elem.listModeList.Count - 1 do
    begin
      val := val or (elem.listModeList[i].hasPrimitiveValue);
      ext := ext or ((elem.listModeList[i].id <> '') or (elem.listModeList[i].hasExtensionList));
    end;
    if val then
    begin
      json.valueArray('listMode');
      for i := 0 to elem.listModeList.Count - 1 do
        ComposeEnumValue(json, '', elem.listModeList[i], CODES_TFhirMapTargetListModeEnum, true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_listMode');
      for i := 0 to elem.listModeList.Count - 1 do
        ComposeEnumProps(json, '', elem.listModeList[i], CODES_TFhirMapTargetListModeEnum, true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdValue(json, 'listRuleId', elem.listRuleIdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdProps(json, 'listRuleId', elem.listRuleIdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnumValue(json, 'transform', elem.TransformElement, CODES_TFhirMapTransformEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnumProps(json, 'transform', elem.TransformElement, CODES_TFhirMapTransformEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.parameterList.Count > 0) then
  begin
    json.valueArray('parameter');
    for i := 0 to elem.parameterList.Count - 1 do
      ComposeStructureMapGroupRuleTargetParameter(json, '', elem.parameterList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseStructureMapGroupRuleTargetParameter(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseStructureMapGroupRuleTargetParameter(jsn)); {2}
end;

function TFHIRJsonParser.ParseStructureMapGroupRuleTargetParameter(jsn : TJsonObject) : TFhirStructureMapGroupRuleTargetParameter;
begin
  result := TFhirStructureMapGroupRuleTargetParameter.create;
  try
    ParseStructureMapGroupRuleTargetParameterProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseStructureMapGroupRuleTargetParameterProperties(jsn : TJsonObject; result : TFhirStructureMapGroupRuleTargetParameter);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('valueId') or jsn.has('_valueId') then
      result.value := parseId(jsn.node['valueId'], jsn.vObj['_valueId']);
    if jsn.has('valueString') or jsn.has('_valueString') then
      result.value := parseString(jsn.node['valueString'], jsn.vObj['_valueString']);
    if jsn.has('valueBoolean') or jsn.has('_valueBoolean') then
      result.value := parseBoolean(jsn.node['valueBoolean'], jsn.vObj['_valueBoolean']);
    if jsn.has('valueInteger') or jsn.has('_valueInteger') then
      result.value := parseInteger(jsn.node['valueInteger'], jsn.vObj['_valueInteger']);
    if jsn.has('valueDecimal') or jsn.has('_valueDecimal') then
      result.value := parseDecimal(jsn.node['valueDecimal'], jsn.vObj['_valueDecimal']);
end;

procedure TFHIRJsonComposer.ComposeStructureMapGroupRuleTargetParameter(json : TJSONWriter; name : string; elem : TFhirStructureMapGroupRuleTargetParameter; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (elem.value is TFhirId) then 
  begin
    ComposeIdValue(json, 'valueId', TFhirId(elem.value), false);
    ComposeIdProps(json, 'valueId', TFhirId(elem.value), false);
  end
  else if (elem.value is TFhirString) then 
  begin
    ComposeStringValue(json, 'valueString', TFhirString(elem.value), false);
    ComposeStringProps(json, 'valueString', TFhirString(elem.value), false);
  end
  else if (elem.value is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'valueBoolean', TFhirBoolean(elem.value), false);
    ComposeBooleanProps(json, 'valueBoolean', TFhirBoolean(elem.value), false);
  end
  else if (elem.value is TFhirInteger) then 
  begin
    ComposeIntegerValue(json, 'valueInteger', TFhirInteger(elem.value), false);
    ComposeIntegerProps(json, 'valueInteger', TFhirInteger(elem.value), false);
  end
  else if (elem.value is TFhirDecimal) then 
  begin
    ComposeDecimalValue(json, 'valueDecimal', TFhirDecimal(elem.value), false);
    ComposeDecimalProps(json, 'valueDecimal', TFhirDecimal(elem.value), false);
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseStructureMapGroupRuleDependent(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseStructureMapGroupRuleDependent(jsn)); {2}
end;

function TFHIRJsonParser.ParseStructureMapGroupRuleDependent(jsn : TJsonObject) : TFhirStructureMapGroupRuleDependent;
begin
  result := TFhirStructureMapGroupRuleDependent.create;
  try
    ParseStructureMapGroupRuleDependentProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseStructureMapGroupRuleDependentProperties(jsn : TJsonObject; result : TFhirStructureMapGroupRuleDependent);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseId(jsn.node['name'], jsn.vObj['_name']);{q}
      if jsn.has('variable') or jsn.has('_variable') then
      iteratePrimitiveArray(jsn.vArr['variable'], jsn.vArr['_variable'], result.variableList, parseString);
end;

procedure TFHIRJsonComposer.ComposeStructureMapGroupRuleDependent(json : TJSONWriter; name : string; elem : TFhirStructureMapGroupRuleDependent; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeIdValue(json, 'name', elem.nameElement, false);
  ComposeIdProps(json, 'name', elem.nameElement, false);
  if (elem.variableList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.variableList.Count - 1 do
    begin
      ext := ext or ((elem.variableList[i].id <> '') or (elem.variableList[i].hasExtensionList) {no-comments or (elem.variableList[i].hasComments)});
      val := val or (elem.variableList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('variable');
      for i := 0 to elem.variableList.Count - 1 do
        ComposeStringValue(json, '',elem.variableList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_variable');
      for i := 0 to elem.variableList.Count - 1 do
        ComposeStringProps(json, '',elem.variableList[i], true);
      json.FinishArray;
    end;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseStructureMap(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseStructureMap(jsn)); {2}
end;

function TFHIRJsonParser.ParseStructureMap(jsn : TJsonObject) : TFhirStructureMap;
begin
  result := TFhirStructureMap.create;
  try
    ParseStructureMapProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseStructureMapProperties(jsn : TJsonObject; result : TFhirStructureMap);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := parseUri(jsn.node['url'], jsn.vObj['_url']);{q}
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := parseString(jsn.node['version'], jsn.vObj['_version']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('title') or jsn.has('_title') then
        result.titleElement := parseString(jsn.node['title'], jsn.vObj['_title']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    if jsn.has('experimental') or jsn.has('_experimental') then
        result.experimentalElement := parseBoolean(jsn.node['experimental'], jsn.vObj['_experimental']);{q}
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := parseDateTime(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('publisher') or jsn.has('_publisher') then
        result.publisherElement := parseString(jsn.node['publisher'], jsn.vObj['_publisher']);{q}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseContactDetail);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseMarkdown(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('useContext') then
      iterateArray(jsn.vArr['useContext'], result.useContextList, parseUsageContext);
    if jsn.has('jurisdiction') then
      iterateArray(jsn.vArr['jurisdiction'], result.jurisdictionList, parseCodeableConcept);
    if jsn.has('purpose') or jsn.has('_purpose') then
        result.purposeElement := parseMarkdown(jsn.node['purpose'], jsn.vObj['_purpose']);{q}
    if jsn.has('copyright') or jsn.has('_copyright') then
        result.copyrightElement := parseMarkdown(jsn.node['copyright'], jsn.vObj['_copyright']);{q}
    if jsn.has('structure') then
      iterateArray(jsn.vArr['structure'], result.structureList, parseStructureMapStructure);
      if jsn.has('import') or jsn.has('_import') then
      iteratePrimitiveArray(jsn.vArr['import'], jsn.vArr['_import'], result.importList, parseCanonical);
    if jsn.has('group') then
      iterateArray(jsn.vArr['group'], result.groupList, parseStructureMapGroup);
end;

procedure TFHIRJsonComposer.ComposeStructureMap(json : TJSONWriter; name : string; elem : TFhirStructureMap; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  ComposeUriValue(json, 'url', elem.urlElement, false);
  ComposeUriProps(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeStringValue(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeStringProps(json, 'version', elem.versionElement, false);
  ComposeStringValue(json, 'name', elem.nameElement, false);
  ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeStringValue(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeStringProps(json, 'title', elem.titleElement, false);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBooleanValue(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBooleanProps(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringValue(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringProps(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') and (elem.contactList.Count > 0) then
  begin
    json.valueArray('contact');
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(json, '', elem.contactList[i]); {z - ContactDetail}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdownValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdownProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') and (elem.useContextList.Count > 0) then
  begin
    json.valueArray('useContext');
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(json, '', elem.useContextList[i]); {z - UsageContext}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') and (elem.jurisdictionList.Count > 0) then
  begin
    json.valueArray('jurisdiction');
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.jurisdictionList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdownValue(json, 'purpose', elem.purposeElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdownProps(json, 'purpose', elem.purposeElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdownValue(json, 'copyright', elem.copyrightElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdownProps(json, 'copyright', elem.copyrightElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('structure') and (elem.structureList.Count > 0) then
  begin
    json.valueArray('structure');
    for i := 0 to elem.structureList.Count - 1 do
      ComposeStructureMapStructure(json, '', elem.structureList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('import') and (elem.importList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.importList.Count - 1 do
    begin
      ext := ext or ((elem.importList[i].id <> '') or (elem.importList[i].hasExtensionList) {no-comments or (elem.importList[i].hasComments)});
      val := val or (elem.importList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('import');
      for i := 0 to elem.importList.Count - 1 do
        ComposeCanonicalValue(json, '',elem.importList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_import');
      for i := 0 to elem.importList.Count - 1 do
        ComposeCanonicalProps(json, '',elem.importList[i], true);
      json.FinishArray;
    end;
  end;
  if (elem.groupList.Count > 0) then
  begin
    json.valueArray('group');
    for i := 0 to elem.groupList.Count - 1 do
      ComposeStructureMapGroup(json, '', elem.groupList[i]); {z - }
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_STRUCTUREMAP}
{$IFDEF FHIR_SUBSCRIPTION}
procedure TFHIRJsonParser.ParseSubscriptionChannel(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSubscriptionChannel(jsn)); {2}
end;

function TFHIRJsonParser.ParseSubscriptionChannel(jsn : TJsonObject) : TFhirSubscriptionChannel;
begin
  result := TFhirSubscriptionChannel.create;
  try
    ParseSubscriptionChannelProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSubscriptionChannelProperties(jsn : TJsonObject; result : TFhirSubscriptionChannel);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn.node['type'], jsn.vObj['_type'], CODES_TFhirSubscriptionChannelTypeEnum, SYSTEMS_TFhirSubscriptionChannelTypeEnum);
    if jsn.has('endpoint') or jsn.has('_endpoint') then
        result.endpointElement := parseUrl(jsn.node['endpoint'], jsn.vObj['_endpoint']);{q}
    if jsn.has('payload') or jsn.has('_payload') then
        result.payloadElement := parseCode(jsn.node['payload'], jsn.vObj['_payload']);{q}
      if jsn.has('header') or jsn.has('_header') then
      iteratePrimitiveArray(jsn.vArr['header'], jsn.vArr['_header'], result.headerList, parseString);
end;

procedure TFHIRJsonComposer.ComposeSubscriptionChannel(json : TJSONWriter; name : string; elem : TFhirSubscriptionChannel; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirSubscriptionChannelTypeEnum, false);
  ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirSubscriptionChannelTypeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUrlValue(json, 'endpoint', elem.endpointElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUrlProps(json, 'endpoint', elem.endpointElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeValue(json, 'payload', elem.payloadElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeProps(json, 'payload', elem.payloadElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.headerList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.headerList.Count - 1 do
    begin
      ext := ext or ((elem.headerList[i].id <> '') or (elem.headerList[i].hasExtensionList) {no-comments or (elem.headerList[i].hasComments)});
      val := val or (elem.headerList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('header');
      for i := 0 to elem.headerList.Count - 1 do
        ComposeStringValue(json, '',elem.headerList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_header');
      for i := 0 to elem.headerList.Count - 1 do
        ComposeStringProps(json, '',elem.headerList[i], true);
      json.FinishArray;
    end;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseSubscription(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSubscription(jsn)); {2}
end;

function TFHIRJsonParser.ParseSubscription(jsn : TJsonObject) : TFhirSubscription;
begin
  result := TFhirSubscription.create;
  try
    ParseSubscriptionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSubscriptionProperties(jsn : TJsonObject; result : TFhirSubscription);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirSubscriptionStatusEnum, SYSTEMS_TFhirSubscriptionStatusEnum);
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseContactPoint);
    if jsn.has('end') or jsn.has('_end') then
        result.end_Element := parseInstant(jsn.node['end'], jsn.vObj['_end']);{q}
    if jsn.has('reason') or jsn.has('_reason') then
        result.reasonElement := parseString(jsn.node['reason'], jsn.vObj['_reason']);{q}
    if jsn.has('criteria') or jsn.has('_criteria') then
        result.criteriaElement := parseString(jsn.node['criteria'], jsn.vObj['_criteria']);{q}
    if jsn.has('error') or jsn.has('_error') then
        result.errorElement := parseString(jsn.node['error'], jsn.vObj['_error']);{q}
    if jsn.has('channel') then
        result.channel := ParseSubscriptionChannel(jsn.vObj['channel']);{q3}
end;

procedure TFHIRJsonComposer.ComposeSubscription(json : TJSONWriter; name : string; elem : TFhirSubscription; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirSubscriptionStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirSubscriptionStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') and (elem.contactList.Count > 0) then
  begin
    json.valueArray('contact');
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactPoint(json, '', elem.contactList[i]); {z - ContactPoint}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('end_') then
    ComposeInstantValue(json, 'end', elem.end_Element, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('end_') then
    ComposeInstantProps(json, 'end', elem.end_Element, false);
  ComposeStringValue(json, 'reason', elem.reasonElement, false);
  ComposeStringProps(json, 'reason', elem.reasonElement, false);
  ComposeStringValue(json, 'criteria', elem.criteriaElement, false);
  ComposeStringProps(json, 'criteria', elem.criteriaElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('error') then
    ComposeStringValue(json, 'error', elem.errorElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('error') then
    ComposeStringProps(json, 'error', elem.errorElement, false);
  ComposeSubscriptionChannel(json, 'channel', elem.channel); {a}
end;

{$ENDIF FHIR_SUBSCRIPTION}
{$IFDEF FHIR_SUBSTANCE}
procedure TFHIRJsonParser.ParseSubstanceInstance(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSubstanceInstance(jsn)); {2}
end;

function TFHIRJsonParser.ParseSubstanceInstance(jsn : TJsonObject) : TFhirSubstanceInstance;
begin
  result := TFhirSubstanceInstance.create;
  try
    ParseSubstanceInstanceProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSubstanceInstanceProperties(jsn : TJsonObject; result : TFhirSubstanceInstance);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q3}
    if jsn.has('expiry') or jsn.has('_expiry') then
        result.expiryElement := parseDateTime(jsn.node['expiry'], jsn.vObj['_expiry']);{q}
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q3}
end;

procedure TFHIRJsonComposer.ComposeSubstanceInstance(json : TJSONWriter; name : string; elem : TFhirSubstanceInstance; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'expiry', elem.expiryElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'expiry', elem.expiryElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(json, 'quantity', elem.quantity); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseSubstanceIngredient(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSubstanceIngredient(jsn)); {2}
end;

function TFHIRJsonParser.ParseSubstanceIngredient(jsn : TJsonObject) : TFhirSubstanceIngredient;
begin
  result := TFhirSubstanceIngredient.create;
  try
    ParseSubstanceIngredientProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSubstanceIngredientProperties(jsn : TJsonObject; result : TFhirSubstanceIngredient);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('quantity') then
        result.quantity := ParseRatio(jsn.vObj['quantity']);{q3}
    if jsn.has('substanceCodeableConcept') {a4} then
      result.substance := ParseCodeableConcept(jsn.vObj['substanceCodeableConcept']);
    if jsn.has('substanceReference') {a3} then
      result.substance := ParseReference(jsn.vObj['substanceReference']);
end;

procedure TFHIRJsonComposer.ComposeSubstanceIngredient(json : TJSONWriter; name : string; elem : TFhirSubstanceIngredient; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeRatio(json, 'quantity', elem.quantity); {a}
  if (elem.substance is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'substanceCodeableConcept', TFhirCodeableConcept(elem.substance)) 
  else if (elem.substance is TFhirReference) then
    ComposeReference(json, 'substanceReference', TFhirReference(elem.substance));
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseSubstance(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSubstance(jsn)); {2}
end;

function TFHIRJsonParser.ParseSubstance(jsn : TJsonObject) : TFhirSubstance;
begin
  result := TFhirSubstance.create;
  try
    ParseSubstanceProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSubstanceProperties(jsn : TJsonObject; result : TFhirSubstance);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirSubstanceStatusEnum, SYSTEMS_TFhirSubstanceStatusEnum);
    if jsn.has('category') then
      iterateArray(jsn.vArr['category'], result.categoryList, parseCodeableConcept);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('instance') then
      iterateArray(jsn.vArr['instance'], result.instanceList, parseSubstanceInstance);
    if jsn.has('ingredient') then
      iterateArray(jsn.vArr['ingredient'], result.ingredientList, parseSubstanceIngredient);
end;

procedure TFHIRJsonComposer.ComposeSubstance(json : TJSONWriter; name : string; elem : TFhirSubstance; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirSubstanceStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirSubstanceStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') and (elem.categoryList.Count > 0) then
  begin
    json.valueArray('category');
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.categoryList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('instance') and (elem.instanceList.Count > 0) then
  begin
    json.valueArray('instance');
    for i := 0 to elem.instanceList.Count - 1 do
      ComposeSubstanceInstance(json, '', elem.instanceList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('ingredient') and (elem.ingredientList.Count > 0) then
  begin
    json.valueArray('ingredient');
    for i := 0 to elem.ingredientList.Count - 1 do
      ComposeSubstanceIngredient(json, '', elem.ingredientList[i]); {z - }
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_SUBSTANCE}
{$IFDEF FHIR_SUBSTANCENUCLEICACID}
procedure TFHIRJsonParser.ParseSubstanceNucleicAcidSubunit(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSubstanceNucleicAcidSubunit(jsn)); {2}
end;

function TFHIRJsonParser.ParseSubstanceNucleicAcidSubunit(jsn : TJsonObject) : TFhirSubstanceNucleicAcidSubunit;
begin
  result := TFhirSubstanceNucleicAcidSubunit.create;
  try
    ParseSubstanceNucleicAcidSubunitProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSubstanceNucleicAcidSubunitProperties(jsn : TJsonObject; result : TFhirSubstanceNucleicAcidSubunit);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('subunit') or jsn.has('_subunit') then
        result.subunitElement := parseInteger(jsn.node['subunit'], jsn.vObj['_subunit']);{q}
    if jsn.has('sequence') or jsn.has('_sequence') then
        result.sequenceElement := parseString(jsn.node['sequence'], jsn.vObj['_sequence']);{q}
    if jsn.has('length') or jsn.has('_length') then
        result.lengthElement := parseInteger(jsn.node['length'], jsn.vObj['_length']);{q}
    if jsn.has('sequenceAttachment') then
        result.sequenceAttachment := ParseAttachment(jsn.vObj['sequenceAttachment']);{q3}
    if jsn.has('fivePrime') then
        result.fivePrime := ParseCodeableConcept(jsn.vObj['fivePrime']);{q3}
    if jsn.has('threePrime') then
        result.threePrime := ParseCodeableConcept(jsn.vObj['threePrime']);{q3}
    if jsn.has('linkage') then
      iterateArray(jsn.vArr['linkage'], result.linkageList, parseSubstanceNucleicAcidSubunitLinkage);
    if jsn.has('sugar') then
      iterateArray(jsn.vArr['sugar'], result.sugarList, parseSubstanceNucleicAcidSubunitSugar);
end;

procedure TFHIRJsonComposer.ComposeSubstanceNucleicAcidSubunit(json : TJSONWriter; name : string; elem : TFhirSubstanceNucleicAcidSubunit; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIntegerValue(json, 'subunit', elem.subunitElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIntegerProps(json, 'subunit', elem.subunitElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'sequence', elem.sequenceElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'sequence', elem.sequenceElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIntegerValue(json, 'length', elem.lengthElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIntegerProps(json, 'length', elem.lengthElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeAttachment(json, 'sequenceAttachment', elem.sequenceAttachment); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'fivePrime', elem.fivePrime); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'threePrime', elem.threePrime); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.linkageList.Count > 0) then
  begin
    json.valueArray('linkage');
    for i := 0 to elem.linkageList.Count - 1 do
      ComposeSubstanceNucleicAcidSubunitLinkage(json, '', elem.linkageList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.sugarList.Count > 0) then
  begin
    json.valueArray('sugar');
    for i := 0 to elem.sugarList.Count - 1 do
      ComposeSubstanceNucleicAcidSubunitSugar(json, '', elem.sugarList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseSubstanceNucleicAcidSubunitLinkage(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSubstanceNucleicAcidSubunitLinkage(jsn)); {2}
end;

function TFHIRJsonParser.ParseSubstanceNucleicAcidSubunitLinkage(jsn : TJsonObject) : TFhirSubstanceNucleicAcidSubunitLinkage;
begin
  result := TFhirSubstanceNucleicAcidSubunitLinkage.create;
  try
    ParseSubstanceNucleicAcidSubunitLinkageProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSubstanceNucleicAcidSubunitLinkageProperties(jsn : TJsonObject; result : TFhirSubstanceNucleicAcidSubunitLinkage);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('connectivity') or jsn.has('_connectivity') then
        result.connectivityElement := parseString(jsn.node['connectivity'], jsn.vObj['_connectivity']);{q}
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q3}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('residueSite') or jsn.has('_residueSite') then
        result.residueSiteElement := parseString(jsn.node['residueSite'], jsn.vObj['_residueSite']);{q}
end;

procedure TFHIRJsonComposer.ComposeSubstanceNucleicAcidSubunitLinkage(json : TJSONWriter; name : string; elem : TFhirSubstanceNucleicAcidSubunitLinkage; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'connectivity', elem.connectivityElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'connectivity', elem.connectivityElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'residueSite', elem.residueSiteElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'residueSite', elem.residueSiteElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseSubstanceNucleicAcidSubunitSugar(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSubstanceNucleicAcidSubunitSugar(jsn)); {2}
end;

function TFHIRJsonParser.ParseSubstanceNucleicAcidSubunitSugar(jsn : TJsonObject) : TFhirSubstanceNucleicAcidSubunitSugar;
begin
  result := TFhirSubstanceNucleicAcidSubunitSugar.create;
  try
    ParseSubstanceNucleicAcidSubunitSugarProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSubstanceNucleicAcidSubunitSugarProperties(jsn : TJsonObject; result : TFhirSubstanceNucleicAcidSubunitSugar);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q3}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('residueSite') or jsn.has('_residueSite') then
        result.residueSiteElement := parseString(jsn.node['residueSite'], jsn.vObj['_residueSite']);{q}
end;

procedure TFHIRJsonComposer.ComposeSubstanceNucleicAcidSubunitSugar(json : TJSONWriter; name : string; elem : TFhirSubstanceNucleicAcidSubunitSugar; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'residueSite', elem.residueSiteElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'residueSite', elem.residueSiteElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseSubstanceNucleicAcid(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSubstanceNucleicAcid(jsn)); {2}
end;

function TFHIRJsonParser.ParseSubstanceNucleicAcid(jsn : TJsonObject) : TFhirSubstanceNucleicAcid;
begin
  result := TFhirSubstanceNucleicAcid.create;
  try
    ParseSubstanceNucleicAcidProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSubstanceNucleicAcidProperties(jsn : TJsonObject; result : TFhirSubstanceNucleicAcid);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('sequenceType') then
        result.sequenceType := ParseCodeableConcept(jsn.vObj['sequenceType']);{q3}
    if jsn.has('numberOfSubunits') or jsn.has('_numberOfSubunits') then
        result.numberOfSubunitsElement := parseInteger(jsn.node['numberOfSubunits'], jsn.vObj['_numberOfSubunits']);{q}
    if jsn.has('areaOfHybridisation') or jsn.has('_areaOfHybridisation') then
        result.areaOfHybridisationElement := parseString(jsn.node['areaOfHybridisation'], jsn.vObj['_areaOfHybridisation']);{q}
    if jsn.has('oligoNucleotideType') then
        result.oligoNucleotideType := ParseCodeableConcept(jsn.vObj['oligoNucleotideType']);{q3}
    if jsn.has('subunit') then
      iterateArray(jsn.vArr['subunit'], result.subunitList, parseSubstanceNucleicAcidSubunit);
end;

procedure TFHIRJsonComposer.ComposeSubstanceNucleicAcid(json : TJSONWriter; name : string; elem : TFhirSubstanceNucleicAcid; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('sequenceType') then
    ComposeCodeableConcept(json, 'sequenceType', elem.sequenceType); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('numberOfSubunits') then
    ComposeIntegerValue(json, 'numberOfSubunits', elem.numberOfSubunitsElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('numberOfSubunits') then
    ComposeIntegerProps(json, 'numberOfSubunits', elem.numberOfSubunitsElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('areaOfHybridisation') then
    ComposeStringValue(json, 'areaOfHybridisation', elem.areaOfHybridisationElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('areaOfHybridisation') then
    ComposeStringProps(json, 'areaOfHybridisation', elem.areaOfHybridisationElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('oligoNucleotideType') then
    ComposeCodeableConcept(json, 'oligoNucleotideType', elem.oligoNucleotideType); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subunit') and (elem.subunitList.Count > 0) then
  begin
    json.valueArray('subunit');
    for i := 0 to elem.subunitList.Count - 1 do
      ComposeSubstanceNucleicAcidSubunit(json, '', elem.subunitList[i]); {z - }
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_SUBSTANCENUCLEICACID}
{$IFDEF FHIR_SUBSTANCEPOLYMER}
procedure TFHIRJsonParser.ParseSubstancePolymerMonomerSet(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSubstancePolymerMonomerSet(jsn)); {2}
end;

function TFHIRJsonParser.ParseSubstancePolymerMonomerSet(jsn : TJsonObject) : TFhirSubstancePolymerMonomerSet;
begin
  result := TFhirSubstancePolymerMonomerSet.create;
  try
    ParseSubstancePolymerMonomerSetProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSubstancePolymerMonomerSetProperties(jsn : TJsonObject; result : TFhirSubstancePolymerMonomerSet);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('ratioType') then
        result.ratioType := ParseCodeableConcept(jsn.vObj['ratioType']);{q3}
    if jsn.has('startingMaterial') then
      iterateArray(jsn.vArr['startingMaterial'], result.startingMaterialList, parseSubstancePolymerMonomerSetStartingMaterial);
end;

procedure TFHIRJsonComposer.ComposeSubstancePolymerMonomerSet(json : TJSONWriter; name : string; elem : TFhirSubstancePolymerMonomerSet; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'ratioType', elem.ratioType); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.startingMaterialList.Count > 0) then
  begin
    json.valueArray('startingMaterial');
    for i := 0 to elem.startingMaterialList.Count - 1 do
      ComposeSubstancePolymerMonomerSetStartingMaterial(json, '', elem.startingMaterialList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseSubstancePolymerMonomerSetStartingMaterial(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSubstancePolymerMonomerSetStartingMaterial(jsn)); {2}
end;

function TFHIRJsonParser.ParseSubstancePolymerMonomerSetStartingMaterial(jsn : TJsonObject) : TFhirSubstancePolymerMonomerSetStartingMaterial;
begin
  result := TFhirSubstancePolymerMonomerSetStartingMaterial.create;
  try
    ParseSubstancePolymerMonomerSetStartingMaterialProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSubstancePolymerMonomerSetStartingMaterialProperties(jsn : TJsonObject; result : TFhirSubstancePolymerMonomerSetStartingMaterial);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('material') then
        result.material := ParseCodeableConcept(jsn.vObj['material']);{q3}
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('isDefining') or jsn.has('_isDefining') then
        result.isDefiningElement := parseBoolean(jsn.node['isDefining'], jsn.vObj['_isDefining']);{q}
    if jsn.has('amount') then
        result.amount := ParseSubstanceAmount(jsn.vObj['amount']);{q3}
end;

procedure TFHIRJsonComposer.ComposeSubstancePolymerMonomerSetStartingMaterial(json : TJSONWriter; name : string; elem : TFhirSubstancePolymerMonomerSetStartingMaterial; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'material', elem.material); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBooleanValue(json, 'isDefining', elem.isDefiningElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBooleanProps(json, 'isDefining', elem.isDefiningElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeSubstanceAmount(json, 'amount', elem.amount); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseSubstancePolymerRepeat(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSubstancePolymerRepeat(jsn)); {2}
end;

function TFHIRJsonParser.ParseSubstancePolymerRepeat(jsn : TJsonObject) : TFhirSubstancePolymerRepeat;
begin
  result := TFhirSubstancePolymerRepeat.create;
  try
    ParseSubstancePolymerRepeatProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSubstancePolymerRepeatProperties(jsn : TJsonObject; result : TFhirSubstancePolymerRepeat);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('numberOfUnits') or jsn.has('_numberOfUnits') then
        result.numberOfUnitsElement := parseInteger(jsn.node['numberOfUnits'], jsn.vObj['_numberOfUnits']);{q}
    if jsn.has('averageMolecularFormula') or jsn.has('_averageMolecularFormula') then
        result.averageMolecularFormulaElement := parseString(jsn.node['averageMolecularFormula'], jsn.vObj['_averageMolecularFormula']);{q}
    if jsn.has('repeatUnitAmountType') then
        result.repeatUnitAmountType := ParseCodeableConcept(jsn.vObj['repeatUnitAmountType']);{q3}
    if jsn.has('repeatUnit') then
      iterateArray(jsn.vArr['repeatUnit'], result.repeatUnitList, parseSubstancePolymerRepeatRepeatUnit);
end;

procedure TFHIRJsonComposer.ComposeSubstancePolymerRepeat(json : TJSONWriter; name : string; elem : TFhirSubstancePolymerRepeat; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIntegerValue(json, 'numberOfUnits', elem.numberOfUnitsElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIntegerProps(json, 'numberOfUnits', elem.numberOfUnitsElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'averageMolecularFormula', elem.averageMolecularFormulaElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'averageMolecularFormula', elem.averageMolecularFormulaElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'repeatUnitAmountType', elem.repeatUnitAmountType); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.repeatUnitList.Count > 0) then
  begin
    json.valueArray('repeatUnit');
    for i := 0 to elem.repeatUnitList.Count - 1 do
      ComposeSubstancePolymerRepeatRepeatUnit(json, '', elem.repeatUnitList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseSubstancePolymerRepeatRepeatUnit(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSubstancePolymerRepeatRepeatUnit(jsn)); {2}
end;

function TFHIRJsonParser.ParseSubstancePolymerRepeatRepeatUnit(jsn : TJsonObject) : TFhirSubstancePolymerRepeatRepeatUnit;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnit.create;
  try
    ParseSubstancePolymerRepeatRepeatUnitProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSubstancePolymerRepeatRepeatUnitProperties(jsn : TJsonObject; result : TFhirSubstancePolymerRepeatRepeatUnit);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('orientationOfPolymerisation') then
        result.orientationOfPolymerisation := ParseCodeableConcept(jsn.vObj['orientationOfPolymerisation']);{q3}
    if jsn.has('repeatUnit') or jsn.has('_repeatUnit') then
        result.repeatUnitElement := parseString(jsn.node['repeatUnit'], jsn.vObj['_repeatUnit']);{q}
    if jsn.has('amount') then
        result.amount := ParseSubstanceAmount(jsn.vObj['amount']);{q3}
    if jsn.has('degreeOfPolymerisation') then
      iterateArray(jsn.vArr['degreeOfPolymerisation'], result.degreeOfPolymerisationList, parseSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation);
    if jsn.has('structuralRepresentation') then
      iterateArray(jsn.vArr['structuralRepresentation'], result.structuralRepresentationList, parseSubstancePolymerRepeatRepeatUnitStructuralRepresentation);
end;

procedure TFHIRJsonComposer.ComposeSubstancePolymerRepeatRepeatUnit(json : TJSONWriter; name : string; elem : TFhirSubstancePolymerRepeatRepeatUnit; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'orientationOfPolymerisation', elem.orientationOfPolymerisation); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'repeatUnit', elem.repeatUnitElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'repeatUnit', elem.repeatUnitElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeSubstanceAmount(json, 'amount', elem.amount); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.degreeOfPolymerisationList.Count > 0) then
  begin
    json.valueArray('degreeOfPolymerisation');
    for i := 0 to elem.degreeOfPolymerisationList.Count - 1 do
      ComposeSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation(json, '', elem.degreeOfPolymerisationList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.structuralRepresentationList.Count > 0) then
  begin
    json.valueArray('structuralRepresentation');
    for i := 0 to elem.structuralRepresentationList.Count - 1 do
      ComposeSubstancePolymerRepeatRepeatUnitStructuralRepresentation(json, '', elem.structuralRepresentationList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation(jsn)); {2}
end;

function TFHIRJsonParser.ParseSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation(jsn : TJsonObject) : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.create;
  try
    ParseSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationProperties(jsn : TJsonObject; result : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('degree') then
        result.degree := ParseCodeableConcept(jsn.vObj['degree']);{q3}
    if jsn.has('amount') then
        result.amount := ParseSubstanceAmount(jsn.vObj['amount']);{q3}
end;

procedure TFHIRJsonComposer.ComposeSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation(json : TJSONWriter; name : string; elem : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'degree', elem.degree); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeSubstanceAmount(json, 'amount', elem.amount); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseSubstancePolymerRepeatRepeatUnitStructuralRepresentation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSubstancePolymerRepeatRepeatUnitStructuralRepresentation(jsn)); {2}
end;

function TFHIRJsonParser.ParseSubstancePolymerRepeatRepeatUnitStructuralRepresentation(jsn : TJsonObject) : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.create;
  try
    ParseSubstancePolymerRepeatRepeatUnitStructuralRepresentationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSubstancePolymerRepeatRepeatUnitStructuralRepresentationProperties(jsn : TJsonObject; result : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('representation') or jsn.has('_representation') then
        result.representationElement := parseString(jsn.node['representation'], jsn.vObj['_representation']);{q}
    if jsn.has('attachment') then
        result.attachment := ParseAttachment(jsn.vObj['attachment']);{q3}
end;

procedure TFHIRJsonComposer.ComposeSubstancePolymerRepeatRepeatUnitStructuralRepresentation(json : TJSONWriter; name : string; elem : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'representation', elem.representationElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'representation', elem.representationElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeAttachment(json, 'attachment', elem.attachment); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseSubstancePolymer(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSubstancePolymer(jsn)); {2}
end;

function TFHIRJsonParser.ParseSubstancePolymer(jsn : TJsonObject) : TFhirSubstancePolymer;
begin
  result := TFhirSubstancePolymer.create;
  try
    ParseSubstancePolymerProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSubstancePolymerProperties(jsn : TJsonObject; result : TFhirSubstancePolymer);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('class') then
        result.class_ := ParseCodeableConcept(jsn.vObj['class']);{q3}
    if jsn.has('geometry') then
        result.geometry := ParseCodeableConcept(jsn.vObj['geometry']);{q3}
    if jsn.has('copolymerConnectivity') then
      iterateArray(jsn.vArr['copolymerConnectivity'], result.copolymerConnectivityList, parseCodeableConcept);
      if jsn.has('modification') or jsn.has('_modification') then
      iteratePrimitiveArray(jsn.vArr['modification'], jsn.vArr['_modification'], result.modificationList, parseString);
    if jsn.has('monomerSet') then
      iterateArray(jsn.vArr['monomerSet'], result.monomerSetList, parseSubstancePolymerMonomerSet);
    if jsn.has('repeat') then
      iterateArray(jsn.vArr['repeat'], result.repeat_List, parseSubstancePolymerRepeat);
end;

procedure TFHIRJsonComposer.ComposeSubstancePolymer(json : TJSONWriter; name : string; elem : TFhirSubstancePolymer; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('class_') then
    ComposeCodeableConcept(json, 'class', elem.class_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('geometry') then
    ComposeCodeableConcept(json, 'geometry', elem.geometry); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('copolymerConnectivity') and (elem.copolymerConnectivityList.Count > 0) then
  begin
    json.valueArray('copolymerConnectivity');
    for i := 0 to elem.copolymerConnectivityList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.copolymerConnectivityList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('modification') and (elem.modificationList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.modificationList.Count - 1 do
    begin
      ext := ext or ((elem.modificationList[i].id <> '') or (elem.modificationList[i].hasExtensionList) {no-comments or (elem.modificationList[i].hasComments)});
      val := val or (elem.modificationList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('modification');
      for i := 0 to elem.modificationList.Count - 1 do
        ComposeStringValue(json, '',elem.modificationList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_modification');
      for i := 0 to elem.modificationList.Count - 1 do
        ComposeStringProps(json, '',elem.modificationList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('monomerSet') and (elem.monomerSetList.Count > 0) then
  begin
    json.valueArray('monomerSet');
    for i := 0 to elem.monomerSetList.Count - 1 do
      ComposeSubstancePolymerMonomerSet(json, '', elem.monomerSetList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('repeat_') and (elem.repeat_List.Count > 0) then
  begin
    json.valueArray('repeat');
    for i := 0 to elem.repeat_List.Count - 1 do
      ComposeSubstancePolymerRepeat(json, '', elem.repeat_List[i]); {z - }
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_SUBSTANCEPOLYMER}
{$IFDEF FHIR_SUBSTANCEPROTEIN}
procedure TFHIRJsonParser.ParseSubstanceProteinSubunit(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSubstanceProteinSubunit(jsn)); {2}
end;

function TFHIRJsonParser.ParseSubstanceProteinSubunit(jsn : TJsonObject) : TFhirSubstanceProteinSubunit;
begin
  result := TFhirSubstanceProteinSubunit.create;
  try
    ParseSubstanceProteinSubunitProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSubstanceProteinSubunitProperties(jsn : TJsonObject; result : TFhirSubstanceProteinSubunit);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('subunit') or jsn.has('_subunit') then
        result.subunitElement := parseInteger(jsn.node['subunit'], jsn.vObj['_subunit']);{q}
    if jsn.has('sequence') or jsn.has('_sequence') then
        result.sequenceElement := parseString(jsn.node['sequence'], jsn.vObj['_sequence']);{q}
    if jsn.has('length') or jsn.has('_length') then
        result.lengthElement := parseInteger(jsn.node['length'], jsn.vObj['_length']);{q}
    if jsn.has('sequenceAttachment') then
        result.sequenceAttachment := ParseAttachment(jsn.vObj['sequenceAttachment']);{q3}
    if jsn.has('nTerminalModificationId') then
        result.nTerminalModificationId := ParseIdentifier(jsn.vObj['nTerminalModificationId']);{q3}
    if jsn.has('nTerminalModification') or jsn.has('_nTerminalModification') then
        result.nTerminalModificationElement := parseString(jsn.node['nTerminalModification'], jsn.vObj['_nTerminalModification']);{q}
    if jsn.has('cTerminalModificationId') then
        result.cTerminalModificationId := ParseIdentifier(jsn.vObj['cTerminalModificationId']);{q3}
    if jsn.has('cTerminalModification') or jsn.has('_cTerminalModification') then
        result.cTerminalModificationElement := parseString(jsn.node['cTerminalModification'], jsn.vObj['_cTerminalModification']);{q}
end;

procedure TFHIRJsonComposer.ComposeSubstanceProteinSubunit(json : TJSONWriter; name : string; elem : TFhirSubstanceProteinSubunit; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIntegerValue(json, 'subunit', elem.subunitElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIntegerProps(json, 'subunit', elem.subunitElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'sequence', elem.sequenceElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'sequence', elem.sequenceElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIntegerValue(json, 'length', elem.lengthElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIntegerProps(json, 'length', elem.lengthElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeAttachment(json, 'sequenceAttachment', elem.sequenceAttachment); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(json, 'nTerminalModificationId', elem.nTerminalModificationId); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'nTerminalModification', elem.nTerminalModificationElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'nTerminalModification', elem.nTerminalModificationElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(json, 'cTerminalModificationId', elem.cTerminalModificationId); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'cTerminalModification', elem.cTerminalModificationElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'cTerminalModification', elem.cTerminalModificationElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseSubstanceProtein(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSubstanceProtein(jsn)); {2}
end;

function TFHIRJsonParser.ParseSubstanceProtein(jsn : TJsonObject) : TFhirSubstanceProtein;
begin
  result := TFhirSubstanceProtein.create;
  try
    ParseSubstanceProteinProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSubstanceProteinProperties(jsn : TJsonObject; result : TFhirSubstanceProtein);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('sequenceType') then
        result.sequenceType := ParseCodeableConcept(jsn.vObj['sequenceType']);{q3}
    if jsn.has('numberOfSubunits') or jsn.has('_numberOfSubunits') then
        result.numberOfSubunitsElement := parseInteger(jsn.node['numberOfSubunits'], jsn.vObj['_numberOfSubunits']);{q}
      if jsn.has('disulfideLinkage') or jsn.has('_disulfideLinkage') then
      iteratePrimitiveArray(jsn.vArr['disulfideLinkage'], jsn.vArr['_disulfideLinkage'], result.disulfideLinkageList, parseString);
    if jsn.has('subunit') then
      iterateArray(jsn.vArr['subunit'], result.subunitList, parseSubstanceProteinSubunit);
end;

procedure TFHIRJsonComposer.ComposeSubstanceProtein(json : TJSONWriter; name : string; elem : TFhirSubstanceProtein; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('sequenceType') then
    ComposeCodeableConcept(json, 'sequenceType', elem.sequenceType); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('numberOfSubunits') then
    ComposeIntegerValue(json, 'numberOfSubunits', elem.numberOfSubunitsElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('numberOfSubunits') then
    ComposeIntegerProps(json, 'numberOfSubunits', elem.numberOfSubunitsElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('disulfideLinkage') and (elem.disulfideLinkageList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.disulfideLinkageList.Count - 1 do
    begin
      ext := ext or ((elem.disulfideLinkageList[i].id <> '') or (elem.disulfideLinkageList[i].hasExtensionList) {no-comments or (elem.disulfideLinkageList[i].hasComments)});
      val := val or (elem.disulfideLinkageList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('disulfideLinkage');
      for i := 0 to elem.disulfideLinkageList.Count - 1 do
        ComposeStringValue(json, '',elem.disulfideLinkageList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_disulfideLinkage');
      for i := 0 to elem.disulfideLinkageList.Count - 1 do
        ComposeStringProps(json, '',elem.disulfideLinkageList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subunit') and (elem.subunitList.Count > 0) then
  begin
    json.valueArray('subunit');
    for i := 0 to elem.subunitList.Count - 1 do
      ComposeSubstanceProteinSubunit(json, '', elem.subunitList[i]); {z - }
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_SUBSTANCEPROTEIN}
{$IFDEF FHIR_SUBSTANCEREFERENCEINFORMATION}
procedure TFHIRJsonParser.ParseSubstanceReferenceInformationGene(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSubstanceReferenceInformationGene(jsn)); {2}
end;

function TFHIRJsonParser.ParseSubstanceReferenceInformationGene(jsn : TJsonObject) : TFhirSubstanceReferenceInformationGene;
begin
  result := TFhirSubstanceReferenceInformationGene.create;
  try
    ParseSubstanceReferenceInformationGeneProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSubstanceReferenceInformationGeneProperties(jsn : TJsonObject; result : TFhirSubstanceReferenceInformationGene);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('geneSequenceOrigin') then
        result.geneSequenceOrigin := ParseCodeableConcept(jsn.vObj['geneSequenceOrigin']);{q3}
    if jsn.has('gene') then
        result.gene := ParseCodeableConcept(jsn.vObj['gene']);{q3}
    if jsn.has('source') then
      iterateArray(jsn.vArr['source'], result.sourceList, parseReference{TFhirDocumentReference});
end;

procedure TFHIRJsonComposer.ComposeSubstanceReferenceInformationGene(json : TJSONWriter; name : string; elem : TFhirSubstanceReferenceInformationGene; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'geneSequenceOrigin', elem.geneSequenceOrigin); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'gene', elem.gene); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.sourceList.Count > 0) then
  begin
    json.valueArray('source');
    for i := 0 to elem.sourceList.Count - 1 do
      ComposeReference{TFhirDocumentReference}(json, '', elem.sourceList[i]); {z - Reference(DocumentReference)}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseSubstanceReferenceInformationGeneElement(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSubstanceReferenceInformationGeneElement(jsn)); {2}
end;

function TFHIRJsonParser.ParseSubstanceReferenceInformationGeneElement(jsn : TJsonObject) : TFhirSubstanceReferenceInformationGeneElement;
begin
  result := TFhirSubstanceReferenceInformationGeneElement.create;
  try
    ParseSubstanceReferenceInformationGeneElementProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSubstanceReferenceInformationGeneElementProperties(jsn : TJsonObject; result : TFhirSubstanceReferenceInformationGeneElement);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('element') then
        result.element := ParseIdentifier(jsn.vObj['element']);{q3}
    if jsn.has('source') then
      iterateArray(jsn.vArr['source'], result.sourceList, parseReference{TFhirDocumentReference});
end;

procedure TFHIRJsonComposer.ComposeSubstanceReferenceInformationGeneElement(json : TJSONWriter; name : string; elem : TFhirSubstanceReferenceInformationGeneElement; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(json, 'element', elem.element); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.sourceList.Count > 0) then
  begin
    json.valueArray('source');
    for i := 0 to elem.sourceList.Count - 1 do
      ComposeReference{TFhirDocumentReference}(json, '', elem.sourceList[i]); {z - Reference(DocumentReference)}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseSubstanceReferenceInformationClassification(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSubstanceReferenceInformationClassification(jsn)); {2}
end;

function TFHIRJsonParser.ParseSubstanceReferenceInformationClassification(jsn : TJsonObject) : TFhirSubstanceReferenceInformationClassification;
begin
  result := TFhirSubstanceReferenceInformationClassification.create;
  try
    ParseSubstanceReferenceInformationClassificationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSubstanceReferenceInformationClassificationProperties(jsn : TJsonObject; result : TFhirSubstanceReferenceInformationClassification);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('domain') then
        result.domain := ParseCodeableConcept(jsn.vObj['domain']);{q3}
    if jsn.has('classification') then
        result.classification := ParseCodeableConcept(jsn.vObj['classification']);{q3}
    if jsn.has('subtype') then
      iterateArray(jsn.vArr['subtype'], result.subtypeList, parseCodeableConcept);
    if jsn.has('source') then
      iterateArray(jsn.vArr['source'], result.sourceList, parseReference{TFhirDocumentReference});
end;

procedure TFHIRJsonComposer.ComposeSubstanceReferenceInformationClassification(json : TJSONWriter; name : string; elem : TFhirSubstanceReferenceInformationClassification; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'domain', elem.domain); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'classification', elem.classification); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.subtypeList.Count > 0) then
  begin
    json.valueArray('subtype');
    for i := 0 to elem.subtypeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.subtypeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.sourceList.Count > 0) then
  begin
    json.valueArray('source');
    for i := 0 to elem.sourceList.Count - 1 do
      ComposeReference{TFhirDocumentReference}(json, '', elem.sourceList[i]); {z - Reference(DocumentReference)}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseSubstanceReferenceInformationTarget(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSubstanceReferenceInformationTarget(jsn)); {2}
end;

function TFHIRJsonParser.ParseSubstanceReferenceInformationTarget(jsn : TJsonObject) : TFhirSubstanceReferenceInformationTarget;
begin
  result := TFhirSubstanceReferenceInformationTarget.create;
  try
    ParseSubstanceReferenceInformationTargetProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSubstanceReferenceInformationTargetProperties(jsn : TJsonObject; result : TFhirSubstanceReferenceInformationTarget);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('target') then
        result.target := ParseIdentifier(jsn.vObj['target']);{q3}
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('interaction') then
        result.interaction := ParseCodeableConcept(jsn.vObj['interaction']);{q3}
    if jsn.has('organism') then
        result.organism := ParseCodeableConcept(jsn.vObj['organism']);{q3}
    if jsn.has('organismType') then
        result.organismType := ParseCodeableConcept(jsn.vObj['organismType']);{q3}
    if jsn.has('amountQuantity') {a4} then
      result.amount := ParseQuantity(jsn.vObj['amountQuantity']);
    if jsn.has('amountRange') {a4} then
      result.amount := ParseRange(jsn.vObj['amountRange']);
    if jsn.has('amountString') or jsn.has('_amountString') then
      result.amount := parseString(jsn.node['amountString'], jsn.vObj['_amountString']);
    if jsn.has('amountType') then
        result.amountType := ParseCodeableConcept(jsn.vObj['amountType']);{q3}
    if jsn.has('source') then
      iterateArray(jsn.vArr['source'], result.sourceList, parseReference{TFhirDocumentReference});
end;

procedure TFHIRJsonComposer.ComposeSubstanceReferenceInformationTarget(json : TJSONWriter; name : string; elem : TFhirSubstanceReferenceInformationTarget; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(json, 'target', elem.target); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'interaction', elem.interaction); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'organism', elem.organism); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'organismType', elem.organismType); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.amount is TFhirQuantity) then 
    ComposeQuantity(json, 'amountQuantity', TFhirQuantity(elem.amount)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.amount is TFhirRange) then 
    ComposeRange(json, 'amountRange', TFhirRange(elem.amount)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.amount is TFhirString) then 
  begin
    ComposeStringValue(json, 'amountString', TFhirString(elem.amount), false);
    ComposeStringProps(json, 'amountString', TFhirString(elem.amount), false);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'amountType', elem.amountType); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.sourceList.Count > 0) then
  begin
    json.valueArray('source');
    for i := 0 to elem.sourceList.Count - 1 do
      ComposeReference{TFhirDocumentReference}(json, '', elem.sourceList[i]); {z - Reference(DocumentReference)}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseSubstanceReferenceInformation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSubstanceReferenceInformation(jsn)); {2}
end;

function TFHIRJsonParser.ParseSubstanceReferenceInformation(jsn : TJsonObject) : TFhirSubstanceReferenceInformation;
begin
  result := TFhirSubstanceReferenceInformation.create;
  try
    ParseSubstanceReferenceInformationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSubstanceReferenceInformationProperties(jsn : TJsonObject; result : TFhirSubstanceReferenceInformation);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('comment') or jsn.has('_comment') then
        result.commentElement := parseString(jsn.node['comment'], jsn.vObj['_comment']);{q}
    if jsn.has('gene') then
      iterateArray(jsn.vArr['gene'], result.geneList, parseSubstanceReferenceInformationGene);
    if jsn.has('geneElement') then
      iterateArray(jsn.vArr['geneElement'], result.geneElementList, parseSubstanceReferenceInformationGeneElement);
    if jsn.has('classification') then
      iterateArray(jsn.vArr['classification'], result.classificationList, parseSubstanceReferenceInformationClassification);
    if jsn.has('target') then
      iterateArray(jsn.vArr['target'], result.targetList, parseSubstanceReferenceInformationTarget);
end;

procedure TFHIRJsonComposer.ComposeSubstanceReferenceInformation(json : TJSONWriter; name : string; elem : TFhirSubstanceReferenceInformation; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('comment') then
    ComposeStringValue(json, 'comment', elem.commentElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('comment') then
    ComposeStringProps(json, 'comment', elem.commentElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('gene') and (elem.geneList.Count > 0) then
  begin
    json.valueArray('gene');
    for i := 0 to elem.geneList.Count - 1 do
      ComposeSubstanceReferenceInformationGene(json, '', elem.geneList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('geneElement') and (elem.geneElementList.Count > 0) then
  begin
    json.valueArray('geneElement');
    for i := 0 to elem.geneElementList.Count - 1 do
      ComposeSubstanceReferenceInformationGeneElement(json, '', elem.geneElementList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('classification') and (elem.classificationList.Count > 0) then
  begin
    json.valueArray('classification');
    for i := 0 to elem.classificationList.Count - 1 do
      ComposeSubstanceReferenceInformationClassification(json, '', elem.classificationList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('target') and (elem.targetList.Count > 0) then
  begin
    json.valueArray('target');
    for i := 0 to elem.targetList.Count - 1 do
      ComposeSubstanceReferenceInformationTarget(json, '', elem.targetList[i]); {z - }
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_SUBSTANCEREFERENCEINFORMATION}
{$IFDEF FHIR_SUBSTANCESOURCEMATERIAL}
procedure TFHIRJsonParser.ParseSubstanceSourceMaterialFractionDescription(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSubstanceSourceMaterialFractionDescription(jsn)); {2}
end;

function TFHIRJsonParser.ParseSubstanceSourceMaterialFractionDescription(jsn : TJsonObject) : TFhirSubstanceSourceMaterialFractionDescription;
begin
  result := TFhirSubstanceSourceMaterialFractionDescription.create;
  try
    ParseSubstanceSourceMaterialFractionDescriptionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSubstanceSourceMaterialFractionDescriptionProperties(jsn : TJsonObject; result : TFhirSubstanceSourceMaterialFractionDescription);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('fraction') or jsn.has('_fraction') then
        result.fractionElement := parseString(jsn.node['fraction'], jsn.vObj['_fraction']);{q}
    if jsn.has('materialType') then
        result.materialType := ParseCodeableConcept(jsn.vObj['materialType']);{q3}
end;

procedure TFHIRJsonComposer.ComposeSubstanceSourceMaterialFractionDescription(json : TJSONWriter; name : string; elem : TFhirSubstanceSourceMaterialFractionDescription; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'fraction', elem.fractionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'fraction', elem.fractionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'materialType', elem.materialType); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseSubstanceSourceMaterialOrganism(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSubstanceSourceMaterialOrganism(jsn)); {2}
end;

function TFHIRJsonParser.ParseSubstanceSourceMaterialOrganism(jsn : TJsonObject) : TFhirSubstanceSourceMaterialOrganism;
begin
  result := TFhirSubstanceSourceMaterialOrganism.create;
  try
    ParseSubstanceSourceMaterialOrganismProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSubstanceSourceMaterialOrganismProperties(jsn : TJsonObject; result : TFhirSubstanceSourceMaterialOrganism);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('family') then
        result.family := ParseCodeableConcept(jsn.vObj['family']);{q3}
    if jsn.has('genus') then
        result.genus := ParseCodeableConcept(jsn.vObj['genus']);{q3}
    if jsn.has('species') then
        result.species := ParseCodeableConcept(jsn.vObj['species']);{q3}
    if jsn.has('intraspecificType') then
        result.intraspecificType := ParseCodeableConcept(jsn.vObj['intraspecificType']);{q3}
    if jsn.has('intraspecificDescription') or jsn.has('_intraspecificDescription') then
        result.intraspecificDescriptionElement := parseString(jsn.node['intraspecificDescription'], jsn.vObj['_intraspecificDescription']);{q}
    if jsn.has('author') then
      iterateArray(jsn.vArr['author'], result.authorList, parseSubstanceSourceMaterialOrganismAuthor);
    if jsn.has('hybrid') then
        result.hybrid := ParseSubstanceSourceMaterialOrganismHybrid(jsn.vObj['hybrid']);{q3}
    if jsn.has('organismGeneral') then
        result.organismGeneral := ParseSubstanceSourceMaterialOrganismOrganismGeneral(jsn.vObj['organismGeneral']);{q3}
end;

procedure TFHIRJsonComposer.ComposeSubstanceSourceMaterialOrganism(json : TJSONWriter; name : string; elem : TFhirSubstanceSourceMaterialOrganism; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'family', elem.family); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'genus', elem.genus); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'species', elem.species); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'intraspecificType', elem.intraspecificType); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'intraspecificDescription', elem.intraspecificDescriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'intraspecificDescription', elem.intraspecificDescriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.authorList.Count > 0) then
  begin
    json.valueArray('author');
    for i := 0 to elem.authorList.Count - 1 do
      ComposeSubstanceSourceMaterialOrganismAuthor(json, '', elem.authorList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeSubstanceSourceMaterialOrganismHybrid(json, 'hybrid', elem.hybrid); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeSubstanceSourceMaterialOrganismOrganismGeneral(json, 'organismGeneral', elem.organismGeneral); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseSubstanceSourceMaterialOrganismAuthor(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSubstanceSourceMaterialOrganismAuthor(jsn)); {2}
end;

function TFHIRJsonParser.ParseSubstanceSourceMaterialOrganismAuthor(jsn : TJsonObject) : TFhirSubstanceSourceMaterialOrganismAuthor;
begin
  result := TFhirSubstanceSourceMaterialOrganismAuthor.create;
  try
    ParseSubstanceSourceMaterialOrganismAuthorProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSubstanceSourceMaterialOrganismAuthorProperties(jsn : TJsonObject; result : TFhirSubstanceSourceMaterialOrganismAuthor);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('authorType') then
        result.authorType := ParseCodeableConcept(jsn.vObj['authorType']);{q3}
    if jsn.has('authorDescription') or jsn.has('_authorDescription') then
        result.authorDescriptionElement := parseString(jsn.node['authorDescription'], jsn.vObj['_authorDescription']);{q}
end;

procedure TFHIRJsonComposer.ComposeSubstanceSourceMaterialOrganismAuthor(json : TJSONWriter; name : string; elem : TFhirSubstanceSourceMaterialOrganismAuthor; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'authorType', elem.authorType); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'authorDescription', elem.authorDescriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'authorDescription', elem.authorDescriptionElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseSubstanceSourceMaterialOrganismHybrid(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSubstanceSourceMaterialOrganismHybrid(jsn)); {2}
end;

function TFHIRJsonParser.ParseSubstanceSourceMaterialOrganismHybrid(jsn : TJsonObject) : TFhirSubstanceSourceMaterialOrganismHybrid;
begin
  result := TFhirSubstanceSourceMaterialOrganismHybrid.create;
  try
    ParseSubstanceSourceMaterialOrganismHybridProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSubstanceSourceMaterialOrganismHybridProperties(jsn : TJsonObject; result : TFhirSubstanceSourceMaterialOrganismHybrid);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('maternalOrganismId') or jsn.has('_maternalOrganismId') then
        result.maternalOrganismIdElement := parseString(jsn.node['maternalOrganismId'], jsn.vObj['_maternalOrganismId']);{q}
    if jsn.has('maternalOrganismName') or jsn.has('_maternalOrganismName') then
        result.maternalOrganismNameElement := parseString(jsn.node['maternalOrganismName'], jsn.vObj['_maternalOrganismName']);{q}
    if jsn.has('paternalOrganismId') or jsn.has('_paternalOrganismId') then
        result.paternalOrganismIdElement := parseString(jsn.node['paternalOrganismId'], jsn.vObj['_paternalOrganismId']);{q}
    if jsn.has('paternalOrganismName') or jsn.has('_paternalOrganismName') then
        result.paternalOrganismNameElement := parseString(jsn.node['paternalOrganismName'], jsn.vObj['_paternalOrganismName']);{q}
    if jsn.has('hybridType') then
        result.hybridType := ParseCodeableConcept(jsn.vObj['hybridType']);{q3}
end;

procedure TFHIRJsonComposer.ComposeSubstanceSourceMaterialOrganismHybrid(json : TJSONWriter; name : string; elem : TFhirSubstanceSourceMaterialOrganismHybrid; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'maternalOrganismId', elem.maternalOrganismIdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'maternalOrganismId', elem.maternalOrganismIdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'maternalOrganismName', elem.maternalOrganismNameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'maternalOrganismName', elem.maternalOrganismNameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'paternalOrganismId', elem.paternalOrganismIdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'paternalOrganismId', elem.paternalOrganismIdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'paternalOrganismName', elem.paternalOrganismNameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'paternalOrganismName', elem.paternalOrganismNameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'hybridType', elem.hybridType); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseSubstanceSourceMaterialOrganismOrganismGeneral(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSubstanceSourceMaterialOrganismOrganismGeneral(jsn)); {2}
end;

function TFHIRJsonParser.ParseSubstanceSourceMaterialOrganismOrganismGeneral(jsn : TJsonObject) : TFhirSubstanceSourceMaterialOrganismOrganismGeneral;
begin
  result := TFhirSubstanceSourceMaterialOrganismOrganismGeneral.create;
  try
    ParseSubstanceSourceMaterialOrganismOrganismGeneralProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSubstanceSourceMaterialOrganismOrganismGeneralProperties(jsn : TJsonObject; result : TFhirSubstanceSourceMaterialOrganismOrganismGeneral);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('kingdom') then
        result.kingdom := ParseCodeableConcept(jsn.vObj['kingdom']);{q3}
    if jsn.has('phylum') then
        result.phylum := ParseCodeableConcept(jsn.vObj['phylum']);{q3}
    if jsn.has('class') then
        result.class_ := ParseCodeableConcept(jsn.vObj['class']);{q3}
    if jsn.has('order') then
        result.order := ParseCodeableConcept(jsn.vObj['order']);{q3}
end;

procedure TFHIRJsonComposer.ComposeSubstanceSourceMaterialOrganismOrganismGeneral(json : TJSONWriter; name : string; elem : TFhirSubstanceSourceMaterialOrganismOrganismGeneral; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'kingdom', elem.kingdom); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'phylum', elem.phylum); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'class', elem.class_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'order', elem.order); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseSubstanceSourceMaterialPartDescription(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSubstanceSourceMaterialPartDescription(jsn)); {2}
end;

function TFHIRJsonParser.ParseSubstanceSourceMaterialPartDescription(jsn : TJsonObject) : TFhirSubstanceSourceMaterialPartDescription;
begin
  result := TFhirSubstanceSourceMaterialPartDescription.create;
  try
    ParseSubstanceSourceMaterialPartDescriptionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSubstanceSourceMaterialPartDescriptionProperties(jsn : TJsonObject; result : TFhirSubstanceSourceMaterialPartDescription);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('part') then
        result.part := ParseCodeableConcept(jsn.vObj['part']);{q3}
    if jsn.has('partLocation') then
        result.partLocation := ParseCodeableConcept(jsn.vObj['partLocation']);{q3}
end;

procedure TFHIRJsonComposer.ComposeSubstanceSourceMaterialPartDescription(json : TJSONWriter; name : string; elem : TFhirSubstanceSourceMaterialPartDescription; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'part', elem.part); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'partLocation', elem.partLocation); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseSubstanceSourceMaterial(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSubstanceSourceMaterial(jsn)); {2}
end;

function TFHIRJsonParser.ParseSubstanceSourceMaterial(jsn : TJsonObject) : TFhirSubstanceSourceMaterial;
begin
  result := TFhirSubstanceSourceMaterial.create;
  try
    ParseSubstanceSourceMaterialProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSubstanceSourceMaterialProperties(jsn : TJsonObject; result : TFhirSubstanceSourceMaterial);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('sourceMaterialClass') then
        result.sourceMaterialClass := ParseCodeableConcept(jsn.vObj['sourceMaterialClass']);{q3}
    if jsn.has('sourceMaterialType') then
        result.sourceMaterialType := ParseCodeableConcept(jsn.vObj['sourceMaterialType']);{q3}
    if jsn.has('sourceMaterialState') then
        result.sourceMaterialState := ParseCodeableConcept(jsn.vObj['sourceMaterialState']);{q3}
    if jsn.has('organismId') then
        result.organismId := ParseIdentifier(jsn.vObj['organismId']);{q3}
    if jsn.has('organismName') or jsn.has('_organismName') then
        result.organismNameElement := parseString(jsn.node['organismName'], jsn.vObj['_organismName']);{q}
    if jsn.has('parentSubstanceId') then
      iterateArray(jsn.vArr['parentSubstanceId'], result.parentSubstanceIdList, parseIdentifier);
      if jsn.has('parentSubstanceName') or jsn.has('_parentSubstanceName') then
      iteratePrimitiveArray(jsn.vArr['parentSubstanceName'], jsn.vArr['_parentSubstanceName'], result.parentSubstanceNameList, parseString);
    if jsn.has('countryOfOrigin') then
      iterateArray(jsn.vArr['countryOfOrigin'], result.countryOfOriginList, parseCodeableConcept);
      if jsn.has('geographicalLocation') or jsn.has('_geographicalLocation') then
      iteratePrimitiveArray(jsn.vArr['geographicalLocation'], jsn.vArr['_geographicalLocation'], result.geographicalLocationList, parseString);
    if jsn.has('developmentStage') then
        result.developmentStage := ParseCodeableConcept(jsn.vObj['developmentStage']);{q3}
    if jsn.has('fractionDescription') then
      iterateArray(jsn.vArr['fractionDescription'], result.fractionDescriptionList, parseSubstanceSourceMaterialFractionDescription);
    if jsn.has('organism') then
        result.organism := ParseSubstanceSourceMaterialOrganism(jsn.vObj['organism']);{q3}
    if jsn.has('partDescription') then
      iterateArray(jsn.vArr['partDescription'], result.partDescriptionList, parseSubstanceSourceMaterialPartDescription);
end;

procedure TFHIRJsonComposer.ComposeSubstanceSourceMaterial(json : TJSONWriter; name : string; elem : TFhirSubstanceSourceMaterial; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('sourceMaterialClass') then
    ComposeCodeableConcept(json, 'sourceMaterialClass', elem.sourceMaterialClass); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('sourceMaterialType') then
    ComposeCodeableConcept(json, 'sourceMaterialType', elem.sourceMaterialType); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('sourceMaterialState') then
    ComposeCodeableConcept(json, 'sourceMaterialState', elem.sourceMaterialState); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('organismId') then
    ComposeIdentifier(json, 'organismId', elem.organismId); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('organismName') then
    ComposeStringValue(json, 'organismName', elem.organismNameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('organismName') then
    ComposeStringProps(json, 'organismName', elem.organismNameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('parentSubstanceId') and (elem.parentSubstanceIdList.Count > 0) then
  begin
    json.valueArray('parentSubstanceId');
    for i := 0 to elem.parentSubstanceIdList.Count - 1 do
      ComposeIdentifier(json, '', elem.parentSubstanceIdList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('parentSubstanceName') and (elem.parentSubstanceNameList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.parentSubstanceNameList.Count - 1 do
    begin
      ext := ext or ((elem.parentSubstanceNameList[i].id <> '') or (elem.parentSubstanceNameList[i].hasExtensionList) {no-comments or (elem.parentSubstanceNameList[i].hasComments)});
      val := val or (elem.parentSubstanceNameList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('parentSubstanceName');
      for i := 0 to elem.parentSubstanceNameList.Count - 1 do
        ComposeStringValue(json, '',elem.parentSubstanceNameList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_parentSubstanceName');
      for i := 0 to elem.parentSubstanceNameList.Count - 1 do
        ComposeStringProps(json, '',elem.parentSubstanceNameList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('countryOfOrigin') and (elem.countryOfOriginList.Count > 0) then
  begin
    json.valueArray('countryOfOrigin');
    for i := 0 to elem.countryOfOriginList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.countryOfOriginList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('geographicalLocation') and (elem.geographicalLocationList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.geographicalLocationList.Count - 1 do
    begin
      ext := ext or ((elem.geographicalLocationList[i].id <> '') or (elem.geographicalLocationList[i].hasExtensionList) {no-comments or (elem.geographicalLocationList[i].hasComments)});
      val := val or (elem.geographicalLocationList[i].hasPrimitiveValue);
    end;
    if val then
  begin
      json.valueArray('geographicalLocation');
      for i := 0 to elem.geographicalLocationList.Count - 1 do
        ComposeStringValue(json, '',elem.geographicalLocationList[i], true);
    json.FinishArray;
  end;
    if ext then
  begin
      json.valueArray('_geographicalLocation');
      for i := 0 to elem.geographicalLocationList.Count - 1 do
        ComposeStringProps(json, '',elem.geographicalLocationList[i], true);
    json.FinishArray;
  end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('developmentStage') then
    ComposeCodeableConcept(json, 'developmentStage', elem.developmentStage); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('fractionDescription') and (elem.fractionDescriptionList.Count > 0) then
  begin
    json.valueArray('fractionDescription');
    for i := 0 to elem.fractionDescriptionList.Count - 1 do
      ComposeSubstanceSourceMaterialFractionDescription(json, '', elem.fractionDescriptionList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('organism') then
    ComposeSubstanceSourceMaterialOrganism(json, 'organism', elem.organism); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('partDescription') and (elem.partDescriptionList.Count > 0) then
  begin
    json.valueArray('partDescription');
    for i := 0 to elem.partDescriptionList.Count - 1 do
      ComposeSubstanceSourceMaterialPartDescription(json, '', elem.partDescriptionList[i]); {z - }
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_SUBSTANCESOURCEMATERIAL}
{$IFDEF FHIR_SUBSTANCESPECIFICATION}
procedure TFHIRJsonParser.ParseSubstanceSpecificationMoiety(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSubstanceSpecificationMoiety(jsn)); {2}
end;

function TFHIRJsonParser.ParseSubstanceSpecificationMoiety(jsn : TJsonObject) : TFhirSubstanceSpecificationMoiety;
begin
  result := TFhirSubstanceSpecificationMoiety.create;
  try
    ParseSubstanceSpecificationMoietyProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSubstanceSpecificationMoietyProperties(jsn : TJsonObject; result : TFhirSubstanceSpecificationMoiety);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('role') then
        result.role := ParseCodeableConcept(jsn.vObj['role']);{q3}
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q3}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('stereochemistry') then
        result.stereochemistry := ParseCodeableConcept(jsn.vObj['stereochemistry']);{q3}
    if jsn.has('opticalActivity') then
        result.opticalActivity := ParseCodeableConcept(jsn.vObj['opticalActivity']);{q3}
    if jsn.has('molecularFormula') or jsn.has('_molecularFormula') then
        result.molecularFormulaElement := parseString(jsn.node['molecularFormula'], jsn.vObj['_molecularFormula']);{q}
    if jsn.has('amountQuantity') {a4} then
      result.amount := ParseQuantity(jsn.vObj['amountQuantity']);
    if jsn.has('amountString') or jsn.has('_amountString') then
      result.amount := parseString(jsn.node['amountString'], jsn.vObj['_amountString']);
end;

procedure TFHIRJsonComposer.ComposeSubstanceSpecificationMoiety(json : TJSONWriter; name : string; elem : TFhirSubstanceSpecificationMoiety; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'role', elem.role); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'stereochemistry', elem.stereochemistry); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'opticalActivity', elem.opticalActivity); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'molecularFormula', elem.molecularFormulaElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'molecularFormula', elem.molecularFormulaElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.amount is TFhirQuantity) then 
    ComposeQuantity(json, 'amountQuantity', TFhirQuantity(elem.amount)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.amount is TFhirString) then 
  begin
    ComposeStringValue(json, 'amountString', TFhirString(elem.amount), false);
    ComposeStringProps(json, 'amountString', TFhirString(elem.amount), false);
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseSubstanceSpecificationProperty(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSubstanceSpecificationProperty(jsn)); {2}
end;

function TFHIRJsonParser.ParseSubstanceSpecificationProperty(jsn : TJsonObject) : TFhirSubstanceSpecificationProperty;
begin
  result := TFhirSubstanceSpecificationProperty.create;
  try
    ParseSubstanceSpecificationPropertyProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSubstanceSpecificationPropertyProperties(jsn : TJsonObject; result : TFhirSubstanceSpecificationProperty);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('category') then
        result.category := ParseCodeableConcept(jsn.vObj['category']);{q3}
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('parameters') or jsn.has('_parameters') then
        result.parametersElement := parseString(jsn.node['parameters'], jsn.vObj['_parameters']);{q}
    if jsn.has('definingSubstanceReference') {a3} then
      result.definingSubstance := ParseReference(jsn.vObj['definingSubstanceReference']);
    if jsn.has('definingSubstanceCodeableConcept') {a4} then
      result.definingSubstance := ParseCodeableConcept(jsn.vObj['definingSubstanceCodeableConcept']);
    if jsn.has('amountQuantity') {a4} then
      result.amount := ParseQuantity(jsn.vObj['amountQuantity']);
    if jsn.has('amountString') or jsn.has('_amountString') then
      result.amount := parseString(jsn.node['amountString'], jsn.vObj['_amountString']);
end;

procedure TFHIRJsonComposer.ComposeSubstanceSpecificationProperty(json : TJSONWriter; name : string; elem : TFhirSubstanceSpecificationProperty; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'category', elem.category); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'parameters', elem.parametersElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'parameters', elem.parametersElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.definingSubstance is TFhirReference) then
    ComposeReference(json, 'definingSubstanceReference', TFhirReference(elem.definingSubstance))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.definingSubstance is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'definingSubstanceCodeableConcept', TFhirCodeableConcept(elem.definingSubstance)) ;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.amount is TFhirQuantity) then 
    ComposeQuantity(json, 'amountQuantity', TFhirQuantity(elem.amount)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.amount is TFhirString) then 
  begin
    ComposeStringValue(json, 'amountString', TFhirString(elem.amount), false);
    ComposeStringProps(json, 'amountString', TFhirString(elem.amount), false);
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseSubstanceSpecificationStructure(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSubstanceSpecificationStructure(jsn)); {2}
end;

function TFHIRJsonParser.ParseSubstanceSpecificationStructure(jsn : TJsonObject) : TFhirSubstanceSpecificationStructure;
begin
  result := TFhirSubstanceSpecificationStructure.create;
  try
    ParseSubstanceSpecificationStructureProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSubstanceSpecificationStructureProperties(jsn : TJsonObject; result : TFhirSubstanceSpecificationStructure);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('stereochemistry') then
        result.stereochemistry := ParseCodeableConcept(jsn.vObj['stereochemistry']);{q3}
    if jsn.has('opticalActivity') then
        result.opticalActivity := ParseCodeableConcept(jsn.vObj['opticalActivity']);{q3}
    if jsn.has('molecularFormula') or jsn.has('_molecularFormula') then
        result.molecularFormulaElement := parseString(jsn.node['molecularFormula'], jsn.vObj['_molecularFormula']);{q}
    if jsn.has('molecularFormulaByMoiety') or jsn.has('_molecularFormulaByMoiety') then
        result.molecularFormulaByMoietyElement := parseString(jsn.node['molecularFormulaByMoiety'], jsn.vObj['_molecularFormulaByMoiety']);{q}
    if jsn.has('isotope') then
      iterateArray(jsn.vArr['isotope'], result.isotopeList, parseSubstanceSpecificationStructureIsotope);
    if jsn.has('molecularWeight') then
        result.molecularWeight := ParseSubstanceSpecificationStructureIsotopeMolecularWeight(jsn.vObj['molecularWeight']);{q3}
    if jsn.has('source') then
      iterateArray(jsn.vArr['source'], result.sourceList, parseReference{TFhirDocumentReference});
    if jsn.has('representation') then
      iterateArray(jsn.vArr['representation'], result.representationList, parseSubstanceSpecificationStructureRepresentation);
end;

procedure TFHIRJsonComposer.ComposeSubstanceSpecificationStructure(json : TJSONWriter; name : string; elem : TFhirSubstanceSpecificationStructure; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'stereochemistry', elem.stereochemistry); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'opticalActivity', elem.opticalActivity); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'molecularFormula', elem.molecularFormulaElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'molecularFormula', elem.molecularFormulaElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'molecularFormulaByMoiety', elem.molecularFormulaByMoietyElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'molecularFormulaByMoiety', elem.molecularFormulaByMoietyElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.isotopeList.Count > 0) then
  begin
    json.valueArray('isotope');
    for i := 0 to elem.isotopeList.Count - 1 do
      ComposeSubstanceSpecificationStructureIsotope(json, '', elem.isotopeList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeSubstanceSpecificationStructureIsotopeMolecularWeight(json, 'molecularWeight', elem.molecularWeight); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.sourceList.Count > 0) then
  begin
    json.valueArray('source');
    for i := 0 to elem.sourceList.Count - 1 do
      ComposeReference{TFhirDocumentReference}(json, '', elem.sourceList[i]); {z - Reference(DocumentReference)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.representationList.Count > 0) then
  begin
    json.valueArray('representation');
    for i := 0 to elem.representationList.Count - 1 do
      ComposeSubstanceSpecificationStructureRepresentation(json, '', elem.representationList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseSubstanceSpecificationStructureIsotope(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSubstanceSpecificationStructureIsotope(jsn)); {2}
end;

function TFHIRJsonParser.ParseSubstanceSpecificationStructureIsotope(jsn : TJsonObject) : TFhirSubstanceSpecificationStructureIsotope;
begin
  result := TFhirSubstanceSpecificationStructureIsotope.create;
  try
    ParseSubstanceSpecificationStructureIsotopeProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSubstanceSpecificationStructureIsotopeProperties(jsn : TJsonObject; result : TFhirSubstanceSpecificationStructureIsotope);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q3}
    if jsn.has('name') then
        result.name := ParseCodeableConcept(jsn.vObj['name']);{q3}
    if jsn.has('substitution') then
        result.substitution := ParseCodeableConcept(jsn.vObj['substitution']);{q3}
    if jsn.has('halfLife') then
        result.halfLife := ParseQuantity(jsn.vObj['halfLife']);{q3}
    if jsn.has('molecularWeight') then
        result.molecularWeight := ParseSubstanceSpecificationStructureIsotopeMolecularWeight(jsn.vObj['molecularWeight']);{q3}
end;

procedure TFHIRJsonComposer.ComposeSubstanceSpecificationStructureIsotope(json : TJSONWriter; name : string; elem : TFhirSubstanceSpecificationStructureIsotope; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'name', elem.name); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'substitution', elem.substitution); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(json, 'halfLife', elem.halfLife); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeSubstanceSpecificationStructureIsotopeMolecularWeight(json, 'molecularWeight', elem.molecularWeight); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseSubstanceSpecificationStructureIsotopeMolecularWeight(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSubstanceSpecificationStructureIsotopeMolecularWeight(jsn)); {2}
end;

function TFHIRJsonParser.ParseSubstanceSpecificationStructureIsotopeMolecularWeight(jsn : TJsonObject) : TFhirSubstanceSpecificationStructureIsotopeMolecularWeight;
begin
  result := TFhirSubstanceSpecificationStructureIsotopeMolecularWeight.create;
  try
    ParseSubstanceSpecificationStructureIsotopeMolecularWeightProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSubstanceSpecificationStructureIsotopeMolecularWeightProperties(jsn : TJsonObject; result : TFhirSubstanceSpecificationStructureIsotopeMolecularWeight);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('method') then
        result.method := ParseCodeableConcept(jsn.vObj['method']);{q3}
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('amount') then
        result.amount := ParseQuantity(jsn.vObj['amount']);{q3}
end;

procedure TFHIRJsonComposer.ComposeSubstanceSpecificationStructureIsotopeMolecularWeight(json : TJSONWriter; name : string; elem : TFhirSubstanceSpecificationStructureIsotopeMolecularWeight; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'method', elem.method); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(json, 'amount', elem.amount); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseSubstanceSpecificationStructureRepresentation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSubstanceSpecificationStructureRepresentation(jsn)); {2}
end;

function TFHIRJsonParser.ParseSubstanceSpecificationStructureRepresentation(jsn : TJsonObject) : TFhirSubstanceSpecificationStructureRepresentation;
begin
  result := TFhirSubstanceSpecificationStructureRepresentation.create;
  try
    ParseSubstanceSpecificationStructureRepresentationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSubstanceSpecificationStructureRepresentationProperties(jsn : TJsonObject; result : TFhirSubstanceSpecificationStructureRepresentation);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('representation') or jsn.has('_representation') then
        result.representationElement := parseString(jsn.node['representation'], jsn.vObj['_representation']);{q}
    if jsn.has('attachment') then
        result.attachment := ParseAttachment(jsn.vObj['attachment']);{q3}
end;

procedure TFHIRJsonComposer.ComposeSubstanceSpecificationStructureRepresentation(json : TJSONWriter; name : string; elem : TFhirSubstanceSpecificationStructureRepresentation; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'representation', elem.representationElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'representation', elem.representationElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeAttachment(json, 'attachment', elem.attachment); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseSubstanceSpecificationCode(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSubstanceSpecificationCode(jsn)); {2}
end;

function TFHIRJsonParser.ParseSubstanceSpecificationCode(jsn : TJsonObject) : TFhirSubstanceSpecificationCode;
begin
  result := TFhirSubstanceSpecificationCode.create;
  try
    ParseSubstanceSpecificationCodeProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSubstanceSpecificationCodeProperties(jsn : TJsonObject; result : TFhirSubstanceSpecificationCode);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('status') then
        result.status := ParseCodeableConcept(jsn.vObj['status']);{q3}
    if jsn.has('statusDate') or jsn.has('_statusDate') then
        result.statusDateElement := parseDateTime(jsn.node['statusDate'], jsn.vObj['_statusDate']);{q}
    if jsn.has('comment') or jsn.has('_comment') then
        result.commentElement := parseString(jsn.node['comment'], jsn.vObj['_comment']);{q}
    if jsn.has('source') then
      iterateArray(jsn.vArr['source'], result.sourceList, parseReference{TFhirDocumentReference});
end;

procedure TFHIRJsonComposer.ComposeSubstanceSpecificationCode(json : TJSONWriter; name : string; elem : TFhirSubstanceSpecificationCode; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'status', elem.status); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'statusDate', elem.statusDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'statusDate', elem.statusDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'comment', elem.commentElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'comment', elem.commentElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.sourceList.Count > 0) then
  begin
    json.valueArray('source');
    for i := 0 to elem.sourceList.Count - 1 do
      ComposeReference{TFhirDocumentReference}(json, '', elem.sourceList[i]); {z - Reference(DocumentReference)}
      json.FinishArray;
    end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseSubstanceSpecificationName(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSubstanceSpecificationName(jsn)); {2}
end;

function TFHIRJsonParser.ParseSubstanceSpecificationName(jsn : TJsonObject) : TFhirSubstanceSpecificationName;
begin
  result := TFhirSubstanceSpecificationName.create;
  try
    ParseSubstanceSpecificationNameProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSubstanceSpecificationNameProperties(jsn : TJsonObject; result : TFhirSubstanceSpecificationName);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('status') then
        result.status := ParseCodeableConcept(jsn.vObj['status']);{q3}
    if jsn.has('preferred') or jsn.has('_preferred') then
        result.preferredElement := parseBoolean(jsn.node['preferred'], jsn.vObj['_preferred']);{q}
    if jsn.has('language') then
      iterateArray(jsn.vArr['language'], result.languageList, parseCodeableConcept);
    if jsn.has('domain') then
      iterateArray(jsn.vArr['domain'], result.domainList, parseCodeableConcept);
    if jsn.has('jurisdiction') then
      iterateArray(jsn.vArr['jurisdiction'], result.jurisdictionList, parseCodeableConcept);
    if jsn.has('synonym') then
      iterateArray(jsn.vArr['synonym'], result.synonymList, parseSubstanceSpecificationName);
    if jsn.has('translation') then
      iterateArray(jsn.vArr['translation'], result.translationList, parseSubstanceSpecificationName);
    if jsn.has('official') then
      iterateArray(jsn.vArr['official'], result.officialList, parseSubstanceSpecificationNameOfficial);
    if jsn.has('source') then
      iterateArray(jsn.vArr['source'], result.sourceList, parseReference{TFhirDocumentReference});
end;

procedure TFHIRJsonComposer.ComposeSubstanceSpecificationName(json : TJSONWriter; name : string; elem : TFhirSubstanceSpecificationName; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
    ComposeStringValue(json, 'name', elem.nameElement, false);
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'status', elem.status); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBooleanValue(json, 'preferred', elem.preferredElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBooleanProps(json, 'preferred', elem.preferredElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.languageList.Count > 0) then
  begin
    json.valueArray('language');
    for i := 0 to elem.languageList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.languageList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.domainList.Count > 0) then
  begin
    json.valueArray('domain');
    for i := 0 to elem.domainList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.domainList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.jurisdictionList.Count > 0) then
  begin
    json.valueArray('jurisdiction');
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.jurisdictionList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.synonymList.Count > 0) then
  begin
    json.valueArray('synonym');
    for i := 0 to elem.synonymList.Count - 1 do
      ComposeSubstanceSpecificationName(json, '', elem.synonymList[i]); {z - @SubstanceSpecification.name}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.translationList.Count > 0) then
  begin
    json.valueArray('translation');
    for i := 0 to elem.translationList.Count - 1 do
      ComposeSubstanceSpecificationName(json, '', elem.translationList[i]); {z - @SubstanceSpecification.name}
    json.FinishArray;
    end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.officialList.Count > 0) then
    begin
    json.valueArray('official');
    for i := 0 to elem.officialList.Count - 1 do
      ComposeSubstanceSpecificationNameOfficial(json, '', elem.officialList[i]); {z - }
      json.FinishArray;
    end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.sourceList.Count > 0) then
    begin
    json.valueArray('source');
    for i := 0 to elem.sourceList.Count - 1 do
      ComposeReference{TFhirDocumentReference}(json, '', elem.sourceList[i]); {z - Reference(DocumentReference)}
      json.FinishArray;
    end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseSubstanceSpecificationNameOfficial(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSubstanceSpecificationNameOfficial(jsn)); {2}
end;

function TFHIRJsonParser.ParseSubstanceSpecificationNameOfficial(jsn : TJsonObject) : TFhirSubstanceSpecificationNameOfficial;
begin
  result := TFhirSubstanceSpecificationNameOfficial.create;
  try
    ParseSubstanceSpecificationNameOfficialProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSubstanceSpecificationNameOfficialProperties(jsn : TJsonObject; result : TFhirSubstanceSpecificationNameOfficial);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('authority') then
        result.authority := ParseCodeableConcept(jsn.vObj['authority']);{q3}
    if jsn.has('status') then
        result.status := ParseCodeableConcept(jsn.vObj['status']);{q3}
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := parseDateTime(jsn.node['date'], jsn.vObj['_date']);{q}
end;

procedure TFHIRJsonComposer.ComposeSubstanceSpecificationNameOfficial(json : TJSONWriter; name : string; elem : TFhirSubstanceSpecificationNameOfficial; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'authority', elem.authority); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'status', elem.status); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseSubstanceSpecificationRelationship(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSubstanceSpecificationRelationship(jsn)); {2}
end;

function TFHIRJsonParser.ParseSubstanceSpecificationRelationship(jsn : TJsonObject) : TFhirSubstanceSpecificationRelationship;
begin
  result := TFhirSubstanceSpecificationRelationship.create;
  try
    ParseSubstanceSpecificationRelationshipProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSubstanceSpecificationRelationshipProperties(jsn : TJsonObject; result : TFhirSubstanceSpecificationRelationship);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('substanceReference') {a3} then
      result.substance := ParseReference(jsn.vObj['substanceReference']);
    if jsn.has('substanceCodeableConcept') {a4} then
      result.substance := ParseCodeableConcept(jsn.vObj['substanceCodeableConcept']);
    if jsn.has('relationship') then
        result.relationship := ParseCodeableConcept(jsn.vObj['relationship']);{q3}
    if jsn.has('isDefining') or jsn.has('_isDefining') then
        result.isDefiningElement := parseBoolean(jsn.node['isDefining'], jsn.vObj['_isDefining']);{q}
    if jsn.has('amountQuantity') {a4} then
      result.amount := ParseQuantity(jsn.vObj['amountQuantity']);
    if jsn.has('amountRange') {a4} then
      result.amount := ParseRange(jsn.vObj['amountRange']);
    if jsn.has('amountRatio') {a4} then
      result.amount := ParseRatio(jsn.vObj['amountRatio']);
    if jsn.has('amountString') or jsn.has('_amountString') then
      result.amount := parseString(jsn.node['amountString'], jsn.vObj['_amountString']);
    if jsn.has('amountRatioLowLimit') then
        result.amountRatioLowLimit := ParseRatio(jsn.vObj['amountRatioLowLimit']);{q3}
    if jsn.has('amountType') then
        result.amountType := ParseCodeableConcept(jsn.vObj['amountType']);{q3}
    if jsn.has('source') then
      iterateArray(jsn.vArr['source'], result.sourceList, parseReference{TFhirDocumentReference});
end;

procedure TFHIRJsonComposer.ComposeSubstanceSpecificationRelationship(json : TJSONWriter; name : string; elem : TFhirSubstanceSpecificationRelationship; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.substance is TFhirReference) then
    ComposeReference(json, 'substanceReference', TFhirReference(elem.substance))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.substance is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'substanceCodeableConcept', TFhirCodeableConcept(elem.substance)) ;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'relationship', elem.relationship); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBooleanValue(json, 'isDefining', elem.isDefiningElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBooleanProps(json, 'isDefining', elem.isDefiningElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.amount is TFhirQuantity) then 
    ComposeQuantity(json, 'amountQuantity', TFhirQuantity(elem.amount)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.amount is TFhirRange) then 
    ComposeRange(json, 'amountRange', TFhirRange(elem.amount)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.amount is TFhirRatio) then 
    ComposeRatio(json, 'amountRatio', TFhirRatio(elem.amount)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.amount is TFhirString) then 
  begin
    ComposeStringValue(json, 'amountString', TFhirString(elem.amount), false);
    ComposeStringProps(json, 'amountString', TFhirString(elem.amount), false);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeRatio(json, 'amountRatioLowLimit', elem.amountRatioLowLimit); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'amountType', elem.amountType); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.sourceList.Count > 0) then
  begin
    json.valueArray('source');
    for i := 0 to elem.sourceList.Count - 1 do
      ComposeReference{TFhirDocumentReference}(json, '', elem.sourceList[i]); {z - Reference(DocumentReference)}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseSubstanceSpecification(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSubstanceSpecification(jsn)); {2}
end;

function TFHIRJsonParser.ParseSubstanceSpecification(jsn : TJsonObject) : TFhirSubstanceSpecification;
begin
  result := TFhirSubstanceSpecification.create;
  try
    ParseSubstanceSpecificationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSubstanceSpecificationProperties(jsn : TJsonObject; result : TFhirSubstanceSpecification);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q3}
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('status') then
        result.status := ParseCodeableConcept(jsn.vObj['status']);{q3}
    if jsn.has('domain') then
        result.domain := ParseCodeableConcept(jsn.vObj['domain']);{q3}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('source') then
      iterateArray(jsn.vArr['source'], result.sourceList, parseReference{TFhirDocumentReference});
    if jsn.has('comment') or jsn.has('_comment') then
        result.commentElement := parseString(jsn.node['comment'], jsn.vObj['_comment']);{q}
    if jsn.has('moiety') then
      iterateArray(jsn.vArr['moiety'], result.moietyList, parseSubstanceSpecificationMoiety);
    if jsn.has('property') then
      iterateArray(jsn.vArr['property'], result.property_List, parseSubstanceSpecificationProperty);
    if jsn.has('referenceInformation') then
        result.referenceInformation := ParseReference{TFhirSubstanceReferenceInformation}(jsn.vObj['referenceInformation']);{q3}
    if jsn.has('structure') then
        result.structure := ParseSubstanceSpecificationStructure(jsn.vObj['structure']);{q3}
    if jsn.has('code') then
      iterateArray(jsn.vArr['code'], result.codeList, parseSubstanceSpecificationCode);
    if jsn.has('name') then
      iterateArray(jsn.vArr['name'], result.nameList, parseSubstanceSpecificationName);
    if jsn.has('molecularWeight') then
      iterateArray(jsn.vArr['molecularWeight'], result.molecularWeightList, parseSubstanceSpecificationStructureIsotopeMolecularWeight);
    if jsn.has('relationship') then
      iterateArray(jsn.vArr['relationship'], result.relationshipList, parseSubstanceSpecificationRelationship);
    if jsn.has('nucleicAcid') then
        result.nucleicAcid := ParseReference{TFhirSubstanceNucleicAcid}(jsn.vObj['nucleicAcid']);{q3}
    if jsn.has('polymer') then
        result.polymer := ParseReference{TFhirSubstancePolymer}(jsn.vObj['polymer']);{q3}
    if jsn.has('protein') then
        result.protein := ParseReference{TFhirSubstanceProtein}(jsn.vObj['protein']);{q3}
    if jsn.has('sourceMaterial') then
        result.sourceMaterial := ParseReference{TFhirSubstanceSourceMaterial}(jsn.vObj['sourceMaterial']);{q3}
end;

procedure TFHIRJsonComposer.ComposeSubstanceSpecification(json : TJSONWriter; name : string; elem : TFhirSubstanceSpecification; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeCodeableConcept(json, 'status', elem.status); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('domain') then
    ComposeCodeableConcept(json, 'domain', elem.domain); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('source') and (elem.sourceList.Count > 0) then
  begin
    json.valueArray('source');
    for i := 0 to elem.sourceList.Count - 1 do
      ComposeReference{TFhirDocumentReference}(json, '', elem.sourceList[i]); {z - Reference(DocumentReference)}
      json.FinishArray;
    end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('comment') then
    ComposeStringValue(json, 'comment', elem.commentElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('comment') then
    ComposeStringProps(json, 'comment', elem.commentElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('moiety') and (elem.moietyList.Count > 0) then
  begin
    json.valueArray('moiety');
    for i := 0 to elem.moietyList.Count - 1 do
      ComposeSubstanceSpecificationMoiety(json, '', elem.moietyList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('property_') and (elem.property_List.Count > 0) then
  begin
    json.valueArray('property');
    for i := 0 to elem.property_List.Count - 1 do
      ComposeSubstanceSpecificationProperty(json, '', elem.property_List[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('referenceInformation') then
    ComposeReference{TFhirSubstanceReferenceInformation}(json, 'referenceInformation', elem.referenceInformation); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('structure') then
    ComposeSubstanceSpecificationStructure(json, 'structure', elem.structure); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') and (elem.codeList.Count > 0) then
  begin
    json.valueArray('code');
    for i := 0 to elem.codeList.Count - 1 do
      ComposeSubstanceSpecificationCode(json, '', elem.codeList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') and (elem.nameList.Count > 0) then
  begin
    json.valueArray('name');
    for i := 0 to elem.nameList.Count - 1 do
      ComposeSubstanceSpecificationName(json, '', elem.nameList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('molecularWeight') and (elem.molecularWeightList.Count > 0) then
  begin
    json.valueArray('molecularWeight');
    for i := 0 to elem.molecularWeightList.Count - 1 do
      ComposeSubstanceSpecificationStructureIsotopeMolecularWeight(json, '', elem.molecularWeightList[i]); {z - @SubstanceSpecification.structure.isotope.molecularWeight}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('relationship') and (elem.relationshipList.Count > 0) then
  begin
    json.valueArray('relationship');
    for i := 0 to elem.relationshipList.Count - 1 do
      ComposeSubstanceSpecificationRelationship(json, '', elem.relationshipList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('nucleicAcid') then
    ComposeReference{TFhirSubstanceNucleicAcid}(json, 'nucleicAcid', elem.nucleicAcid); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('polymer') then
    ComposeReference{TFhirSubstancePolymer}(json, 'polymer', elem.polymer); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('protein') then
    ComposeReference{TFhirSubstanceProtein}(json, 'protein', elem.protein); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('sourceMaterial') then
    ComposeReference{TFhirSubstanceSourceMaterial}(json, 'sourceMaterial', elem.sourceMaterial); {a}
end;

{$ENDIF FHIR_SUBSTANCESPECIFICATION}
{$IFDEF FHIR_SUPPLYDELIVERY}
procedure TFHIRJsonParser.ParseSupplyDeliverySuppliedItem(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSupplyDeliverySuppliedItem(jsn)); {2}
end;

function TFHIRJsonParser.ParseSupplyDeliverySuppliedItem(jsn : TJsonObject) : TFhirSupplyDeliverySuppliedItem;
begin
  result := TFhirSupplyDeliverySuppliedItem.create;
  try
    ParseSupplyDeliverySuppliedItemProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSupplyDeliverySuppliedItemProperties(jsn : TJsonObject; result : TFhirSupplyDeliverySuppliedItem);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q3}
    if jsn.has('itemCodeableConcept') {a4} then
      result.item := ParseCodeableConcept(jsn.vObj['itemCodeableConcept']);
    if jsn.has('itemReference') {a3} then
      result.item := ParseReference(jsn.vObj['itemReference']);
end;

procedure TFHIRJsonComposer.ComposeSupplyDeliverySuppliedItem(json : TJSONWriter; name : string; elem : TFhirSupplyDeliverySuppliedItem; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'quantity', elem.quantity); {a}
  if (SummaryOption in [soFull, soData]) and (elem.item is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'itemCodeableConcept', TFhirCodeableConcept(elem.item)) 
  else if (SummaryOption in [soFull, soData]) and (elem.item is TFhirReference) then
    ComposeReference(json, 'itemReference', TFhirReference(elem.item));
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseSupplyDelivery(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSupplyDelivery(jsn)); {2}
end;

function TFHIRJsonParser.ParseSupplyDelivery(jsn : TJsonObject) : TFhirSupplyDelivery;
begin
  result := TFhirSupplyDelivery.create;
  try
    ParseSupplyDeliveryProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSupplyDeliveryProperties(jsn : TJsonObject; result : TFhirSupplyDelivery);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('basedOn') then
      iterateArray(jsn.vArr['basedOn'], result.basedOnList, parseReference{TFhirSupplyRequest});
    if jsn.has('partOf') then
      iterateArray(jsn.vArr['partOf'], result.partOfList, parseReference{TFhirSupplyDelivery});
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirSupplydeliveryStatusEnum, SYSTEMS_TFhirSupplydeliveryStatusEnum);
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q3}
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('suppliedItem') then
        result.suppliedItem := ParseSupplyDeliverySuppliedItem(jsn.vObj['suppliedItem']);{q3}
    if jsn.has('occurrencePeriod') {a4} then
      result.occurrence := ParsePeriod(jsn.vObj['occurrencePeriod']);
    if jsn.has('occurrenceTiming') {a4} then
      result.occurrence := ParseTiming(jsn.vObj['occurrenceTiming']);
    if jsn.has('occurrenceDateTime') or jsn.has('_occurrenceDateTime') then
      result.occurrence := parseDateTime(jsn.node['occurrenceDateTime'], jsn.vObj['_occurrenceDateTime']);
    if jsn.has('supplier') then
        result.supplier := ParseReference{TFhirPractitioner}(jsn.vObj['supplier']);{q3}
    if jsn.has('destination') then
        result.destination := ParseReference{TFhirLocation}(jsn.vObj['destination']);{q3}
    if jsn.has('receiver') then
      iterateArray(jsn.vArr['receiver'], result.receiverList, parseReference{TFhirPractitioner});
end;

procedure TFHIRJsonComposer.ComposeSupplyDelivery(json : TJSONWriter; name : string; elem : TFhirSupplyDelivery; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('basedOn') and (elem.basedOnList.Count > 0) then
  begin
    json.valueArray('basedOn');
    for i := 0 to elem.basedOnList.Count - 1 do
      ComposeReference{TFhirSupplyRequest}(json, '', elem.basedOnList[i]); {z - Reference(SupplyRequest)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('partOf') and (elem.partOfList.Count > 0) then
  begin
    json.valueArray('partOf');
    for i := 0 to elem.partOfList.Count - 1 do
      ComposeReference{TFhirSupplyDelivery}(json, '', elem.partOfList[i]); {z - Reference(SupplyDelivery)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirSupplydeliveryStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirSupplydeliveryStatusEnum, false);
  if (SummaryOption in [soFull, soData]) and doCompose('patient') then
    ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('type_') then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('suppliedItem') then
    ComposeSupplyDeliverySuppliedItem(json, 'suppliedItem', elem.suppliedItem); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirPeriod) then 
    ComposePeriod(json, 'occurrencePeriod', TFhirPeriod(elem.occurrence)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirTiming) then 
    ComposeTiming(json, 'occurrenceTiming', TFhirTiming(elem.occurrence)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'occurrenceDateTime', TFhirDateTime(elem.occurrence), false);
    ComposeDateTimeProps(json, 'occurrenceDateTime', TFhirDateTime(elem.occurrence), false);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('supplier') then
    ComposeReference{TFhirPractitioner}(json, 'supplier', elem.supplier); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('destination') then
    ComposeReference{TFhirLocation}(json, 'destination', elem.destination); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('receiver') and (elem.receiverList.Count > 0) then
  begin
    json.valueArray('receiver');
    for i := 0 to elem.receiverList.Count - 1 do
      ComposeReference{TFhirPractitioner}(json, '', elem.receiverList[i]); {z - Reference(Practitioner)}
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_SUPPLYDELIVERY}
{$IFDEF FHIR_SUPPLYREQUEST}
procedure TFHIRJsonParser.ParseSupplyRequestParameter(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSupplyRequestParameter(jsn)); {2}
end;

function TFHIRJsonParser.ParseSupplyRequestParameter(jsn : TJsonObject) : TFhirSupplyRequestParameter;
begin
  result := TFhirSupplyRequestParameter.create;
  try
    ParseSupplyRequestParameterProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSupplyRequestParameterProperties(jsn : TJsonObject; result : TFhirSupplyRequestParameter);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('valueCodeableConcept') {a4} then
      result.value := ParseCodeableConcept(jsn.vObj['valueCodeableConcept']);
    if jsn.has('valueQuantity') {a4} then
      result.value := ParseQuantity(jsn.vObj['valueQuantity']);
    if jsn.has('valueRange') {a4} then
      result.value := ParseRange(jsn.vObj['valueRange']);
    if jsn.has('valueBoolean') or jsn.has('_valueBoolean') then
      result.value := parseBoolean(jsn.node['valueBoolean'], jsn.vObj['_valueBoolean']);
end;

procedure TFHIRJsonComposer.ComposeSupplyRequestParameter(json : TJSONWriter; name : string; elem : TFhirSupplyRequestParameter; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soData]) and (elem.value is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'valueCodeableConcept', TFhirCodeableConcept(elem.value)) 
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirQuantity) then 
    ComposeQuantity(json, 'valueQuantity', TFhirQuantity(elem.value)) 
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirRange) then 
    ComposeRange(json, 'valueRange', TFhirRange(elem.value)) 
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'valueBoolean', TFhirBoolean(elem.value), false);
    ComposeBooleanProps(json, 'valueBoolean', TFhirBoolean(elem.value), false);
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseSupplyRequest(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSupplyRequest(jsn)); {2}
end;

function TFHIRJsonParser.ParseSupplyRequest(jsn : TJsonObject) : TFhirSupplyRequest;
begin
  result := TFhirSupplyRequest.create;
  try
    ParseSupplyRequestProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSupplyRequestProperties(jsn : TJsonObject; result : TFhirSupplyRequest);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirSupplyrequestStatusEnum, SYSTEMS_TFhirSupplyrequestStatusEnum);
    if jsn.has('category') then
        result.category := ParseCodeableConcept(jsn.vObj['category']);{q3}
    if jsn.has('priority') or jsn.has('_priority')  then
      result.priorityElement := parseEnum(jsn.path+'/priority', jsn.node['priority'], jsn.vObj['_priority'], CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum);
    if jsn.has('itemCodeableConcept') {a4} then
      result.item := ParseCodeableConcept(jsn.vObj['itemCodeableConcept']);
    if jsn.has('itemReference') {a3} then
      result.item := ParseReference(jsn.vObj['itemReference']);
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q3}
    if jsn.has('parameter') then
      iterateArray(jsn.vArr['parameter'], result.parameterList, parseSupplyRequestParameter);
    if jsn.has('occurrencePeriod') {a4} then
      result.occurrence := ParsePeriod(jsn.vObj['occurrencePeriod']);
    if jsn.has('occurrenceTiming') {a4} then
      result.occurrence := ParseTiming(jsn.vObj['occurrenceTiming']);
    if jsn.has('occurrenceDateTime') or jsn.has('_occurrenceDateTime') then
      result.occurrence := parseDateTime(jsn.node['occurrenceDateTime'], jsn.vObj['_occurrenceDateTime']);
    if jsn.has('authoredOn') or jsn.has('_authoredOn') then
        result.authoredOnElement := parseDateTime(jsn.node['authoredOn'], jsn.vObj['_authoredOn']);{q}
    if jsn.has('requester') then
        result.requester := ParseReference{TFhirPractitioner}(jsn.vObj['requester']);{q3}
    if jsn.has('supplier') then
      iterateArray(jsn.vArr['supplier'], result.supplierList, parseReference{TFhirOrganization});
    if jsn.has('reasonCode') then
      iterateArray(jsn.vArr['reasonCode'], result.reasonCodeList, parseCodeableConcept);
    if jsn.has('reasonReference') then
      iterateArray(jsn.vArr['reasonReference'], result.reasonReferenceList, parseReference{TFhirCondition});
    if jsn.has('deliverFrom') then
        result.deliverFrom := ParseReference{TFhirOrganization}(jsn.vObj['deliverFrom']);{q3}
    if jsn.has('deliverTo') then
        result.deliverTo := ParseReference{TFhirOrganization}(jsn.vObj['deliverTo']);{q3}
end;

procedure TFHIRJsonComposer.ComposeSupplyRequest(json : TJSONWriter; name : string; elem : TFhirSupplyRequest; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirSupplyrequestStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirSupplyrequestStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    ComposeCodeableConcept(json, 'category', elem.category); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('priority') then
    ComposeEnumValue(json, 'priority', elem.PriorityElement, CODES_TFhirRequestPriorityEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('priority') then
    ComposeEnumProps(json, 'priority', elem.PriorityElement, CODES_TFhirRequestPriorityEnum, false);
  if (elem.item is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'itemCodeableConcept', TFhirCodeableConcept(elem.item)) 
  else if (elem.item is TFhirReference) then
    ComposeReference(json, 'itemReference', TFhirReference(elem.item));
  ComposeQuantity(json, 'quantity', elem.quantity); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('parameter') and (elem.parameterList.Count > 0) then
  begin
    json.valueArray('parameter');
    for i := 0 to elem.parameterList.Count - 1 do
      ComposeSupplyRequestParameter(json, '', elem.parameterList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirPeriod) then 
    ComposePeriod(json, 'occurrencePeriod', TFhirPeriod(elem.occurrence)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirTiming) then 
    ComposeTiming(json, 'occurrenceTiming', TFhirTiming(elem.occurrence)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.occurrence is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'occurrenceDateTime', TFhirDateTime(elem.occurrence), false);
    ComposeDateTimeProps(json, 'occurrenceDateTime', TFhirDateTime(elem.occurrence), false);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('authoredOn') then
    ComposeDateTimeValue(json, 'authoredOn', elem.authoredOnElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('authoredOn') then
    ComposeDateTimeProps(json, 'authoredOn', elem.authoredOnElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requester') then
    ComposeReference{TFhirPractitioner}(json, 'requester', elem.requester); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('supplier') and (elem.supplierList.Count > 0) then
  begin
    json.valueArray('supplier');
    for i := 0 to elem.supplierList.Count - 1 do
      ComposeReference{TFhirOrganization}(json, '', elem.supplierList[i]); {z - Reference(Organization)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('reasonCode') and (elem.reasonCodeList.Count > 0) then
  begin
    json.valueArray('reasonCode');
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.reasonCodeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('reasonReference') and (elem.reasonReferenceList.Count > 0) then
  begin
    json.valueArray('reasonReference');
    for i := 0 to elem.reasonReferenceList.Count - 1 do
      ComposeReference{TFhirCondition}(json, '', elem.reasonReferenceList[i]); {z - Reference(Condition)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('deliverFrom') then
    ComposeReference{TFhirOrganization}(json, 'deliverFrom', elem.deliverFrom); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('deliverTo') then
    ComposeReference{TFhirOrganization}(json, 'deliverTo', elem.deliverTo); {a}
end;

{$ENDIF FHIR_SUPPLYREQUEST}
{$IFDEF FHIR_TASK}
procedure TFHIRJsonParser.ParseTaskRestriction(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTaskRestriction(jsn)); {2}
end;

function TFHIRJsonParser.ParseTaskRestriction(jsn : TJsonObject) : TFhirTaskRestriction;
begin
  result := TFhirTaskRestriction.create;
  try
    ParseTaskRestrictionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseTaskRestrictionProperties(jsn : TJsonObject; result : TFhirTaskRestriction);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('repetitions') or jsn.has('_repetitions') then
        result.repetitionsElement := parsePositiveInt(jsn.node['repetitions'], jsn.vObj['_repetitions']);{q}
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q3}
    if jsn.has('recipient') then
      iterateArray(jsn.vArr['recipient'], result.recipientList, parseReference{TFhirPatient});
end;

procedure TFHIRJsonComposer.ComposeTaskRestriction(json : TJSONWriter; name : string; elem : TFhirTaskRestriction; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveIntValue(json, 'repetitions', elem.repetitionsElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveIntProps(json, 'repetitions', elem.repetitionsElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(json, 'period', elem.period); {a}
  if (SummaryOption in [soFull, soData]) and (elem.recipientList.Count > 0) then
  begin
    json.valueArray('recipient');
    for i := 0 to elem.recipientList.Count - 1 do
      ComposeReference{TFhirPatient}(json, '', elem.recipientList[i]); {z - Reference(Patient)}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseTaskInput(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTaskInput(jsn)); {2}
end;

function TFHIRJsonParser.ParseTaskInput(jsn : TJsonObject) : TFhirTaskInput;
begin
  result := TFhirTaskInput.create;
  try
    ParseTaskInputProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseTaskInputProperties(jsn : TJsonObject; result : TFhirTaskInput);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('valueCanonical') or jsn.has('_valueCanonical') then
      result.value := parseCanonical(jsn.node['valueCanonical'], jsn.vObj['_valueCanonical']);
    if jsn.has('valueCode') or jsn.has('_valueCode') then
      result.value := parseCode(jsn.node['valueCode'], jsn.vObj['_valueCode']);
    if jsn.has('valueId') or jsn.has('_valueId') then
      result.value := parseId(jsn.node['valueId'], jsn.vObj['_valueId']);
    if jsn.has('valueMarkdown') or jsn.has('_valueMarkdown') then
      result.value := parseMarkdown(jsn.node['valueMarkdown'], jsn.vObj['_valueMarkdown']);
    if jsn.has('valueOid') or jsn.has('_valueOid') then
      result.value := parseOid(jsn.node['valueOid'], jsn.vObj['_valueOid']);
    if jsn.has('valuePositiveInt') or jsn.has('_valuePositiveInt') then
      result.value := parsePositiveInt(jsn.node['valuePositiveInt'], jsn.vObj['_valuePositiveInt']);
    if jsn.has('valueUnsignedInt') or jsn.has('_valueUnsignedInt') then
      result.value := parseUnsignedInt(jsn.node['valueUnsignedInt'], jsn.vObj['_valueUnsignedInt']);
    if jsn.has('valueUrl') or jsn.has('_valueUrl') then
      result.value := parseUrl(jsn.node['valueUrl'], jsn.vObj['_valueUrl']);
    if jsn.has('valueUuid') or jsn.has('_valueUuid') then
      result.value := parseUuid(jsn.node['valueUuid'], jsn.vObj['_valueUuid']);
    if jsn.has('valueAddress') {a4} then
      result.value := ParseAddress(jsn.vObj['valueAddress']);
    if jsn.has('valueAge') {a4} then
      result.value := ParseAge(jsn.vObj['valueAge']);
    if jsn.has('valueAnnotation') {a4} then
      result.value := ParseAnnotation(jsn.vObj['valueAnnotation']);
    if jsn.has('valueAttachment') {a4} then
      result.value := ParseAttachment(jsn.vObj['valueAttachment']);
    if jsn.has('valueCodeableConcept') {a4} then
      result.value := ParseCodeableConcept(jsn.vObj['valueCodeableConcept']);
    if jsn.has('valueCoding') {a4} then
      result.value := ParseCoding(jsn.vObj['valueCoding']);
    if jsn.has('valueContactPoint') {a4} then
      result.value := ParseContactPoint(jsn.vObj['valueContactPoint']);
    if jsn.has('valueCount') {a4} then
      result.value := ParseCount(jsn.vObj['valueCount']);
    if jsn.has('valueDistance') {a4} then
      result.value := ParseDistance(jsn.vObj['valueDistance']);
    if jsn.has('valueDuration') {a4} then
      result.value := ParseDuration(jsn.vObj['valueDuration']);
    if jsn.has('valueHumanName') {a4} then
      result.value := ParseHumanName(jsn.vObj['valueHumanName']);
    if jsn.has('valueIdentifier') {a4} then
      result.value := ParseIdentifier(jsn.vObj['valueIdentifier']);
    if jsn.has('valueMoney') {a4} then
      result.value := ParseMoney(jsn.vObj['valueMoney']);
    if jsn.has('valuePeriod') {a4} then
      result.value := ParsePeriod(jsn.vObj['valuePeriod']);
    if jsn.has('valueQuantity') {a4} then
      result.value := ParseQuantity(jsn.vObj['valueQuantity']);
    if jsn.has('valueRange') {a4} then
      result.value := ParseRange(jsn.vObj['valueRange']);
    if jsn.has('valueRatio') {a4} then
      result.value := ParseRatio(jsn.vObj['valueRatio']);
    if jsn.has('valueReference') {a4} then
      result.value := ParseReference(jsn.vObj['valueReference']);
    if jsn.has('valueSampledData') {a4} then
      result.value := ParseSampledData(jsn.vObj['valueSampledData']);
    if jsn.has('valueSignature') {a4} then
      result.value := ParseSignature(jsn.vObj['valueSignature']);
    if jsn.has('valueTiming') {a4} then
      result.value := ParseTiming(jsn.vObj['valueTiming']);
    if jsn.has('valueContactDetail') {a4} then
      result.value := ParseContactDetail(jsn.vObj['valueContactDetail']);
    if jsn.has('valueContributor') {a4} then
      result.value := ParseContributor(jsn.vObj['valueContributor']);
    if jsn.has('valueDataRequirement') {a4} then
      result.value := ParseDataRequirement(jsn.vObj['valueDataRequirement']);
    if jsn.has('valueExpression') {a4} then
      result.value := ParseExpression(jsn.vObj['valueExpression']);
    if jsn.has('valueParameterDefinition') {a4} then
      result.value := ParseParameterDefinition(jsn.vObj['valueParameterDefinition']);
    if jsn.has('valueRelatedArtifact') {a4} then
      result.value := ParseRelatedArtifact(jsn.vObj['valueRelatedArtifact']);
    if jsn.has('valueTriggerDefinition') {a4} then
      result.value := ParseTriggerDefinition(jsn.vObj['valueTriggerDefinition']);
    if jsn.has('valueUsageContext') {a4} then
      result.value := ParseUsageContext(jsn.vObj['valueUsageContext']);
    if jsn.has('valueDosage') {a4} then
      result.value := ParseDosage(jsn.vObj['valueDosage']);
    if jsn.has('valueBase64Binary') or jsn.has('_valueBase64Binary') then
      result.value := parseBase64Binary(jsn.node['valueBase64Binary'], jsn.vObj['_valueBase64Binary']);
    if jsn.has('valueBoolean') or jsn.has('_valueBoolean') then
      result.value := parseBoolean(jsn.node['valueBoolean'], jsn.vObj['_valueBoolean']);
    if jsn.has('valueDate') or jsn.has('_valueDate') then
      result.value := parseDate(jsn.node['valueDate'], jsn.vObj['_valueDate']);
    if jsn.has('valueDateTime') or jsn.has('_valueDateTime') then
      result.value := parseDateTime(jsn.node['valueDateTime'], jsn.vObj['_valueDateTime']);
    if jsn.has('valueDecimal') or jsn.has('_valueDecimal') then
      result.value := parseDecimal(jsn.node['valueDecimal'], jsn.vObj['_valueDecimal']);
    if jsn.has('valueInstant') or jsn.has('_valueInstant') then
      result.value := parseInstant(jsn.node['valueInstant'], jsn.vObj['_valueInstant']);
    if jsn.has('valueInteger') or jsn.has('_valueInteger') then
      result.value := parseInteger(jsn.node['valueInteger'], jsn.vObj['_valueInteger']);
    if jsn.has('valueString') or jsn.has('_valueString') then
      result.value := parseString(jsn.node['valueString'], jsn.vObj['_valueString']);
    if jsn.has('valueTime') or jsn.has('_valueTime') then
      result.value := parseTime(jsn.node['valueTime'], jsn.vObj['_valueTime']);
    if jsn.has('valueUri') or jsn.has('_valueUri') then
      result.value := parseUri(jsn.node['valueUri'], jsn.vObj['_valueUri']);
end;

procedure TFHIRJsonComposer.ComposeTaskInput(json : TJSONWriter; name : string; elem : TFhirTaskInput; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (elem.value is TFhirCanonical) then 
  begin
    ComposeCanonicalValue(json, 'valueCanonical', TFhirCanonical(elem.value), false);
    ComposeCanonicalProps(json, 'valueCanonical', TFhirCanonical(elem.value), false);
  end
  else if (elem.value is TFhirCode) then 
  begin
    ComposeCodeValue(json, 'valueCode', TFhirCode(elem.value), false);
    ComposeCodeProps(json, 'valueCode', TFhirCode(elem.value), false);
  end
  else if (elem.value is TFhirId) then 
  begin
    ComposeIdValue(json, 'valueId', TFhirId(elem.value), false);
    ComposeIdProps(json, 'valueId', TFhirId(elem.value), false);
  end
  else if (elem.value is TFhirMarkdown) then 
  begin
    ComposeMarkdownValue(json, 'valueMarkdown', TFhirMarkdown(elem.value), false);
    ComposeMarkdownProps(json, 'valueMarkdown', TFhirMarkdown(elem.value), false);
  end
  else if (elem.value is TFhirOid) then 
  begin
    ComposeOidValue(json, 'valueOid', TFhirOid(elem.value), false);
    ComposeOidProps(json, 'valueOid', TFhirOid(elem.value), false);
  end
  else if (elem.value is TFhirPositiveInt) then 
  begin
    ComposePositiveIntValue(json, 'valuePositiveInt', TFhirPositiveInt(elem.value), false);
    ComposePositiveIntProps(json, 'valuePositiveInt', TFhirPositiveInt(elem.value), false);
  end
  else if (elem.value is TFhirUnsignedInt) then 
  begin
    ComposeUnsignedIntValue(json, 'valueUnsignedInt', TFhirUnsignedInt(elem.value), false);
    ComposeUnsignedIntProps(json, 'valueUnsignedInt', TFhirUnsignedInt(elem.value), false);
  end
  else if (elem.value is TFhirUrl) then 
  begin
    ComposeUrlValue(json, 'valueUrl', TFhirUrl(elem.value), false);
    ComposeUrlProps(json, 'valueUrl', TFhirUrl(elem.value), false);
  end
  else if (elem.value is TFhirUuid) then 
  begin
    ComposeUuidValue(json, 'valueUuid', TFhirUuid(elem.value), false);
    ComposeUuidProps(json, 'valueUuid', TFhirUuid(elem.value), false);
  end
  else if (elem.value is TFhirAddress) then 
    ComposeAddress(json, 'valueAddress', TFhirAddress(elem.value)) 
  else if (elem.value is TFhirAge) then 
    ComposeAge(json, 'valueAge', TFhirAge(elem.value)) 
  else if (elem.value is TFhirAnnotation) then 
    ComposeAnnotation(json, 'valueAnnotation', TFhirAnnotation(elem.value)) 
  else if (elem.value is TFhirAttachment) then 
    ComposeAttachment(json, 'valueAttachment', TFhirAttachment(elem.value)) 
  else if (elem.value is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'valueCodeableConcept', TFhirCodeableConcept(elem.value)) 
  else if (elem.value is TFhirCoding) then 
    ComposeCoding(json, 'valueCoding', TFhirCoding(elem.value)) 
  else if (elem.value is TFhirContactPoint) then 
    ComposeContactPoint(json, 'valueContactPoint', TFhirContactPoint(elem.value)) 
  else if (elem.value is TFhirCount) then 
    ComposeCount(json, 'valueCount', TFhirCount(elem.value)) 
  else if (elem.value is TFhirDistance) then 
    ComposeDistance(json, 'valueDistance', TFhirDistance(elem.value)) 
  else if (elem.value is TFhirDuration) then 
    ComposeDuration(json, 'valueDuration', TFhirDuration(elem.value)) 
  else if (elem.value is TFhirHumanName) then 
    ComposeHumanName(json, 'valueHumanName', TFhirHumanName(elem.value)) 
  else if (elem.value is TFhirIdentifier) then 
    ComposeIdentifier(json, 'valueIdentifier', TFhirIdentifier(elem.value)) 
  else if (elem.value is TFhirMoney) then 
    ComposeMoney(json, 'valueMoney', TFhirMoney(elem.value)) 
  else if (elem.value is TFhirPeriod) then 
    ComposePeriod(json, 'valuePeriod', TFhirPeriod(elem.value)) 
  else if (elem.value is TFhirQuantity) then 
    ComposeQuantity(json, 'valueQuantity', TFhirQuantity(elem.value)) 
  else if (elem.value is TFhirRange) then 
    ComposeRange(json, 'valueRange', TFhirRange(elem.value)) 
  else if (elem.value is TFhirRatio) then 
    ComposeRatio(json, 'valueRatio', TFhirRatio(elem.value)) 
  else if (elem.value is TFhirReference) then 
    ComposeReference(json, 'valueReference', TFhirReference(elem.value)) 
  else if (elem.value is TFhirSampledData) then 
    ComposeSampledData(json, 'valueSampledData', TFhirSampledData(elem.value)) 
  else if (elem.value is TFhirSignature) then 
    ComposeSignature(json, 'valueSignature', TFhirSignature(elem.value)) 
  else if (elem.value is TFhirTiming) then 
    ComposeTiming(json, 'valueTiming', TFhirTiming(elem.value)) 
  else if (elem.value is TFhirContactDetail) then 
    ComposeContactDetail(json, 'valueContactDetail', TFhirContactDetail(elem.value)) 
  else if (elem.value is TFhirContributor) then 
    ComposeContributor(json, 'valueContributor', TFhirContributor(elem.value)) 
  else if (elem.value is TFhirDataRequirement) then 
    ComposeDataRequirement(json, 'valueDataRequirement', TFhirDataRequirement(elem.value)) 
  else if (elem.value is TFhirExpression) then 
    ComposeExpression(json, 'valueExpression', TFhirExpression(elem.value)) 
  else if (elem.value is TFhirParameterDefinition) then 
    ComposeParameterDefinition(json, 'valueParameterDefinition', TFhirParameterDefinition(elem.value)) 
  else if (elem.value is TFhirRelatedArtifact) then 
    ComposeRelatedArtifact(json, 'valueRelatedArtifact', TFhirRelatedArtifact(elem.value)) 
  else if (elem.value is TFhirTriggerDefinition) then 
    ComposeTriggerDefinition(json, 'valueTriggerDefinition', TFhirTriggerDefinition(elem.value)) 
  else if (elem.value is TFhirUsageContext) then 
    ComposeUsageContext(json, 'valueUsageContext', TFhirUsageContext(elem.value)) 
  else if (elem.value is TFhirDosage) then 
    ComposeDosage(json, 'valueDosage', TFhirDosage(elem.value)) 
  else if (elem.value is TFhirBase64Binary) then 
  begin
    ComposeBase64BinaryValue(json, 'valueBase64Binary', TFhirBase64Binary(elem.value), false);
    ComposeBase64BinaryProps(json, 'valueBase64Binary', TFhirBase64Binary(elem.value), false);
  end
  else if (elem.value is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'valueBoolean', TFhirBoolean(elem.value), false);
    ComposeBooleanProps(json, 'valueBoolean', TFhirBoolean(elem.value), false);
  end
  else if (elem.value is TFhirDate) then 
  begin
    ComposeDateValue(json, 'valueDate', TFhirDate(elem.value), false);
    ComposeDateProps(json, 'valueDate', TFhirDate(elem.value), false);
  end
  else if (elem.value is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'valueDateTime', TFhirDateTime(elem.value), false);
    ComposeDateTimeProps(json, 'valueDateTime', TFhirDateTime(elem.value), false);
  end
  else if (elem.value is TFhirDecimal) then 
  begin
    ComposeDecimalValue(json, 'valueDecimal', TFhirDecimal(elem.value), false);
    ComposeDecimalProps(json, 'valueDecimal', TFhirDecimal(elem.value), false);
  end
  else if (elem.value is TFhirInstant) then 
  begin
    ComposeInstantValue(json, 'valueInstant', TFhirInstant(elem.value), false);
    ComposeInstantProps(json, 'valueInstant', TFhirInstant(elem.value), false);
  end
  else if (elem.value is TFhirInteger) then 
  begin
    ComposeIntegerValue(json, 'valueInteger', TFhirInteger(elem.value), false);
    ComposeIntegerProps(json, 'valueInteger', TFhirInteger(elem.value), false);
  end
  else if (elem.value is TFhirString) then 
  begin
    ComposeStringValue(json, 'valueString', TFhirString(elem.value), false);
    ComposeStringProps(json, 'valueString', TFhirString(elem.value), false);
  end
  else if (elem.value is TFhirTime) then 
  begin
    ComposeTimeValue(json, 'valueTime', TFhirTime(elem.value), false);
    ComposeTimeProps(json, 'valueTime', TFhirTime(elem.value), false);
  end
  else if (elem.value is TFhirUri) then 
  begin
    ComposeUriValue(json, 'valueUri', TFhirUri(elem.value), false);
    ComposeUriProps(json, 'valueUri', TFhirUri(elem.value), false);
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseTaskOutput(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTaskOutput(jsn)); {2}
end;

function TFHIRJsonParser.ParseTaskOutput(jsn : TJsonObject) : TFhirTaskOutput;
begin
  result := TFhirTaskOutput.create;
  try
    ParseTaskOutputProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseTaskOutputProperties(jsn : TJsonObject; result : TFhirTaskOutput);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('valueCanonical') or jsn.has('_valueCanonical') then
      result.value := parseCanonical(jsn.node['valueCanonical'], jsn.vObj['_valueCanonical']);
    if jsn.has('valueCode') or jsn.has('_valueCode') then
      result.value := parseCode(jsn.node['valueCode'], jsn.vObj['_valueCode']);
    if jsn.has('valueId') or jsn.has('_valueId') then
      result.value := parseId(jsn.node['valueId'], jsn.vObj['_valueId']);
    if jsn.has('valueMarkdown') or jsn.has('_valueMarkdown') then
      result.value := parseMarkdown(jsn.node['valueMarkdown'], jsn.vObj['_valueMarkdown']);
    if jsn.has('valueOid') or jsn.has('_valueOid') then
      result.value := parseOid(jsn.node['valueOid'], jsn.vObj['_valueOid']);
    if jsn.has('valuePositiveInt') or jsn.has('_valuePositiveInt') then
      result.value := parsePositiveInt(jsn.node['valuePositiveInt'], jsn.vObj['_valuePositiveInt']);
    if jsn.has('valueUnsignedInt') or jsn.has('_valueUnsignedInt') then
      result.value := parseUnsignedInt(jsn.node['valueUnsignedInt'], jsn.vObj['_valueUnsignedInt']);
    if jsn.has('valueUrl') or jsn.has('_valueUrl') then
      result.value := parseUrl(jsn.node['valueUrl'], jsn.vObj['_valueUrl']);
    if jsn.has('valueUuid') or jsn.has('_valueUuid') then
      result.value := parseUuid(jsn.node['valueUuid'], jsn.vObj['_valueUuid']);
    if jsn.has('valueAddress') {a4} then
      result.value := ParseAddress(jsn.vObj['valueAddress']);
    if jsn.has('valueAge') {a4} then
      result.value := ParseAge(jsn.vObj['valueAge']);
    if jsn.has('valueAnnotation') {a4} then
      result.value := ParseAnnotation(jsn.vObj['valueAnnotation']);
    if jsn.has('valueAttachment') {a4} then
      result.value := ParseAttachment(jsn.vObj['valueAttachment']);
    if jsn.has('valueCodeableConcept') {a4} then
      result.value := ParseCodeableConcept(jsn.vObj['valueCodeableConcept']);
    if jsn.has('valueCoding') {a4} then
      result.value := ParseCoding(jsn.vObj['valueCoding']);
    if jsn.has('valueContactPoint') {a4} then
      result.value := ParseContactPoint(jsn.vObj['valueContactPoint']);
    if jsn.has('valueCount') {a4} then
      result.value := ParseCount(jsn.vObj['valueCount']);
    if jsn.has('valueDistance') {a4} then
      result.value := ParseDistance(jsn.vObj['valueDistance']);
    if jsn.has('valueDuration') {a4} then
      result.value := ParseDuration(jsn.vObj['valueDuration']);
    if jsn.has('valueHumanName') {a4} then
      result.value := ParseHumanName(jsn.vObj['valueHumanName']);
    if jsn.has('valueIdentifier') {a4} then
      result.value := ParseIdentifier(jsn.vObj['valueIdentifier']);
    if jsn.has('valueMoney') {a4} then
      result.value := ParseMoney(jsn.vObj['valueMoney']);
    if jsn.has('valuePeriod') {a4} then
      result.value := ParsePeriod(jsn.vObj['valuePeriod']);
    if jsn.has('valueQuantity') {a4} then
      result.value := ParseQuantity(jsn.vObj['valueQuantity']);
    if jsn.has('valueRange') {a4} then
      result.value := ParseRange(jsn.vObj['valueRange']);
    if jsn.has('valueRatio') {a4} then
      result.value := ParseRatio(jsn.vObj['valueRatio']);
    if jsn.has('valueReference') {a4} then
      result.value := ParseReference(jsn.vObj['valueReference']);
    if jsn.has('valueSampledData') {a4} then
      result.value := ParseSampledData(jsn.vObj['valueSampledData']);
    if jsn.has('valueSignature') {a4} then
      result.value := ParseSignature(jsn.vObj['valueSignature']);
    if jsn.has('valueTiming') {a4} then
      result.value := ParseTiming(jsn.vObj['valueTiming']);
    if jsn.has('valueContactDetail') {a4} then
      result.value := ParseContactDetail(jsn.vObj['valueContactDetail']);
    if jsn.has('valueContributor') {a4} then
      result.value := ParseContributor(jsn.vObj['valueContributor']);
    if jsn.has('valueDataRequirement') {a4} then
      result.value := ParseDataRequirement(jsn.vObj['valueDataRequirement']);
    if jsn.has('valueExpression') {a4} then
      result.value := ParseExpression(jsn.vObj['valueExpression']);
    if jsn.has('valueParameterDefinition') {a4} then
      result.value := ParseParameterDefinition(jsn.vObj['valueParameterDefinition']);
    if jsn.has('valueRelatedArtifact') {a4} then
      result.value := ParseRelatedArtifact(jsn.vObj['valueRelatedArtifact']);
    if jsn.has('valueTriggerDefinition') {a4} then
      result.value := ParseTriggerDefinition(jsn.vObj['valueTriggerDefinition']);
    if jsn.has('valueUsageContext') {a4} then
      result.value := ParseUsageContext(jsn.vObj['valueUsageContext']);
    if jsn.has('valueDosage') {a4} then
      result.value := ParseDosage(jsn.vObj['valueDosage']);
    if jsn.has('valueBase64Binary') or jsn.has('_valueBase64Binary') then
      result.value := parseBase64Binary(jsn.node['valueBase64Binary'], jsn.vObj['_valueBase64Binary']);
    if jsn.has('valueBoolean') or jsn.has('_valueBoolean') then
      result.value := parseBoolean(jsn.node['valueBoolean'], jsn.vObj['_valueBoolean']);
    if jsn.has('valueDate') or jsn.has('_valueDate') then
      result.value := parseDate(jsn.node['valueDate'], jsn.vObj['_valueDate']);
    if jsn.has('valueDateTime') or jsn.has('_valueDateTime') then
      result.value := parseDateTime(jsn.node['valueDateTime'], jsn.vObj['_valueDateTime']);
    if jsn.has('valueDecimal') or jsn.has('_valueDecimal') then
      result.value := parseDecimal(jsn.node['valueDecimal'], jsn.vObj['_valueDecimal']);
    if jsn.has('valueInstant') or jsn.has('_valueInstant') then
      result.value := parseInstant(jsn.node['valueInstant'], jsn.vObj['_valueInstant']);
    if jsn.has('valueInteger') or jsn.has('_valueInteger') then
      result.value := parseInteger(jsn.node['valueInteger'], jsn.vObj['_valueInteger']);
    if jsn.has('valueString') or jsn.has('_valueString') then
      result.value := parseString(jsn.node['valueString'], jsn.vObj['_valueString']);
    if jsn.has('valueTime') or jsn.has('_valueTime') then
      result.value := parseTime(jsn.node['valueTime'], jsn.vObj['_valueTime']);
    if jsn.has('valueUri') or jsn.has('_valueUri') then
      result.value := parseUri(jsn.node['valueUri'], jsn.vObj['_valueUri']);
end;

procedure TFHIRJsonComposer.ComposeTaskOutput(json : TJSONWriter; name : string; elem : TFhirTaskOutput; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (elem.value is TFhirCanonical) then 
  begin
    ComposeCanonicalValue(json, 'valueCanonical', TFhirCanonical(elem.value), false);
    ComposeCanonicalProps(json, 'valueCanonical', TFhirCanonical(elem.value), false);
  end
  else if (elem.value is TFhirCode) then 
  begin
    ComposeCodeValue(json, 'valueCode', TFhirCode(elem.value), false);
    ComposeCodeProps(json, 'valueCode', TFhirCode(elem.value), false);
  end
  else if (elem.value is TFhirId) then 
  begin
    ComposeIdValue(json, 'valueId', TFhirId(elem.value), false);
    ComposeIdProps(json, 'valueId', TFhirId(elem.value), false);
  end
  else if (elem.value is TFhirMarkdown) then 
  begin
    ComposeMarkdownValue(json, 'valueMarkdown', TFhirMarkdown(elem.value), false);
    ComposeMarkdownProps(json, 'valueMarkdown', TFhirMarkdown(elem.value), false);
  end
  else if (elem.value is TFhirOid) then 
  begin
    ComposeOidValue(json, 'valueOid', TFhirOid(elem.value), false);
    ComposeOidProps(json, 'valueOid', TFhirOid(elem.value), false);
  end
  else if (elem.value is TFhirPositiveInt) then 
  begin
    ComposePositiveIntValue(json, 'valuePositiveInt', TFhirPositiveInt(elem.value), false);
    ComposePositiveIntProps(json, 'valuePositiveInt', TFhirPositiveInt(elem.value), false);
  end
  else if (elem.value is TFhirUnsignedInt) then 
  begin
    ComposeUnsignedIntValue(json, 'valueUnsignedInt', TFhirUnsignedInt(elem.value), false);
    ComposeUnsignedIntProps(json, 'valueUnsignedInt', TFhirUnsignedInt(elem.value), false);
  end
  else if (elem.value is TFhirUrl) then 
  begin
    ComposeUrlValue(json, 'valueUrl', TFhirUrl(elem.value), false);
    ComposeUrlProps(json, 'valueUrl', TFhirUrl(elem.value), false);
  end
  else if (elem.value is TFhirUuid) then 
  begin
    ComposeUuidValue(json, 'valueUuid', TFhirUuid(elem.value), false);
    ComposeUuidProps(json, 'valueUuid', TFhirUuid(elem.value), false);
  end
  else if (elem.value is TFhirAddress) then 
    ComposeAddress(json, 'valueAddress', TFhirAddress(elem.value)) 
  else if (elem.value is TFhirAge) then 
    ComposeAge(json, 'valueAge', TFhirAge(elem.value)) 
  else if (elem.value is TFhirAnnotation) then 
    ComposeAnnotation(json, 'valueAnnotation', TFhirAnnotation(elem.value)) 
  else if (elem.value is TFhirAttachment) then 
    ComposeAttachment(json, 'valueAttachment', TFhirAttachment(elem.value)) 
  else if (elem.value is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'valueCodeableConcept', TFhirCodeableConcept(elem.value)) 
  else if (elem.value is TFhirCoding) then 
    ComposeCoding(json, 'valueCoding', TFhirCoding(elem.value)) 
  else if (elem.value is TFhirContactPoint) then 
    ComposeContactPoint(json, 'valueContactPoint', TFhirContactPoint(elem.value)) 
  else if (elem.value is TFhirCount) then 
    ComposeCount(json, 'valueCount', TFhirCount(elem.value)) 
  else if (elem.value is TFhirDistance) then 
    ComposeDistance(json, 'valueDistance', TFhirDistance(elem.value)) 
  else if (elem.value is TFhirDuration) then 
    ComposeDuration(json, 'valueDuration', TFhirDuration(elem.value)) 
  else if (elem.value is TFhirHumanName) then 
    ComposeHumanName(json, 'valueHumanName', TFhirHumanName(elem.value)) 
  else if (elem.value is TFhirIdentifier) then 
    ComposeIdentifier(json, 'valueIdentifier', TFhirIdentifier(elem.value)) 
  else if (elem.value is TFhirMoney) then 
    ComposeMoney(json, 'valueMoney', TFhirMoney(elem.value)) 
  else if (elem.value is TFhirPeriod) then 
    ComposePeriod(json, 'valuePeriod', TFhirPeriod(elem.value)) 
  else if (elem.value is TFhirQuantity) then 
    ComposeQuantity(json, 'valueQuantity', TFhirQuantity(elem.value)) 
  else if (elem.value is TFhirRange) then 
    ComposeRange(json, 'valueRange', TFhirRange(elem.value)) 
  else if (elem.value is TFhirRatio) then 
    ComposeRatio(json, 'valueRatio', TFhirRatio(elem.value)) 
  else if (elem.value is TFhirReference) then 
    ComposeReference(json, 'valueReference', TFhirReference(elem.value)) 
  else if (elem.value is TFhirSampledData) then 
    ComposeSampledData(json, 'valueSampledData', TFhirSampledData(elem.value)) 
  else if (elem.value is TFhirSignature) then 
    ComposeSignature(json, 'valueSignature', TFhirSignature(elem.value)) 
  else if (elem.value is TFhirTiming) then 
    ComposeTiming(json, 'valueTiming', TFhirTiming(elem.value)) 
  else if (elem.value is TFhirContactDetail) then 
    ComposeContactDetail(json, 'valueContactDetail', TFhirContactDetail(elem.value)) 
  else if (elem.value is TFhirContributor) then 
    ComposeContributor(json, 'valueContributor', TFhirContributor(elem.value)) 
  else if (elem.value is TFhirDataRequirement) then 
    ComposeDataRequirement(json, 'valueDataRequirement', TFhirDataRequirement(elem.value)) 
  else if (elem.value is TFhirExpression) then 
    ComposeExpression(json, 'valueExpression', TFhirExpression(elem.value)) 
  else if (elem.value is TFhirParameterDefinition) then 
    ComposeParameterDefinition(json, 'valueParameterDefinition', TFhirParameterDefinition(elem.value)) 
  else if (elem.value is TFhirRelatedArtifact) then 
    ComposeRelatedArtifact(json, 'valueRelatedArtifact', TFhirRelatedArtifact(elem.value)) 
  else if (elem.value is TFhirTriggerDefinition) then 
    ComposeTriggerDefinition(json, 'valueTriggerDefinition', TFhirTriggerDefinition(elem.value)) 
  else if (elem.value is TFhirUsageContext) then 
    ComposeUsageContext(json, 'valueUsageContext', TFhirUsageContext(elem.value)) 
  else if (elem.value is TFhirDosage) then 
    ComposeDosage(json, 'valueDosage', TFhirDosage(elem.value)) 
  else if (elem.value is TFhirBase64Binary) then 
  begin
    ComposeBase64BinaryValue(json, 'valueBase64Binary', TFhirBase64Binary(elem.value), false);
    ComposeBase64BinaryProps(json, 'valueBase64Binary', TFhirBase64Binary(elem.value), false);
  end
  else if (elem.value is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'valueBoolean', TFhirBoolean(elem.value), false);
    ComposeBooleanProps(json, 'valueBoolean', TFhirBoolean(elem.value), false);
  end
  else if (elem.value is TFhirDate) then 
  begin
    ComposeDateValue(json, 'valueDate', TFhirDate(elem.value), false);
    ComposeDateProps(json, 'valueDate', TFhirDate(elem.value), false);
  end
  else if (elem.value is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'valueDateTime', TFhirDateTime(elem.value), false);
    ComposeDateTimeProps(json, 'valueDateTime', TFhirDateTime(elem.value), false);
  end
  else if (elem.value is TFhirDecimal) then 
  begin
    ComposeDecimalValue(json, 'valueDecimal', TFhirDecimal(elem.value), false);
    ComposeDecimalProps(json, 'valueDecimal', TFhirDecimal(elem.value), false);
  end
  else if (elem.value is TFhirInstant) then 
  begin
    ComposeInstantValue(json, 'valueInstant', TFhirInstant(elem.value), false);
    ComposeInstantProps(json, 'valueInstant', TFhirInstant(elem.value), false);
  end
  else if (elem.value is TFhirInteger) then 
  begin
    ComposeIntegerValue(json, 'valueInteger', TFhirInteger(elem.value), false);
    ComposeIntegerProps(json, 'valueInteger', TFhirInteger(elem.value), false);
  end
  else if (elem.value is TFhirString) then 
  begin
    ComposeStringValue(json, 'valueString', TFhirString(elem.value), false);
    ComposeStringProps(json, 'valueString', TFhirString(elem.value), false);
  end
  else if (elem.value is TFhirTime) then 
  begin
    ComposeTimeValue(json, 'valueTime', TFhirTime(elem.value), false);
    ComposeTimeProps(json, 'valueTime', TFhirTime(elem.value), false);
  end
  else if (elem.value is TFhirUri) then 
  begin
    ComposeUriValue(json, 'valueUri', TFhirUri(elem.value), false);
    ComposeUriProps(json, 'valueUri', TFhirUri(elem.value), false);
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseTask(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTask(jsn)); {2}
end;

function TFHIRJsonParser.ParseTask(jsn : TJsonObject) : TFhirTask;
begin
  result := TFhirTask.create;
  try
    ParseTaskProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseTaskProperties(jsn : TJsonObject; result : TFhirTask);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('instantiatesCanonical') or jsn.has('_instantiatesCanonical') then
        result.instantiatesCanonicalElement := parseCanonical(jsn.node['instantiatesCanonical'], jsn.vObj['_instantiatesCanonical']);{q}
    if jsn.has('instantiatesUri') or jsn.has('_instantiatesUri') then
        result.instantiatesUriElement := parseUri(jsn.node['instantiatesUri'], jsn.vObj['_instantiatesUri']);{q}
    if jsn.has('basedOn') then
      iterateArray(jsn.vArr['basedOn'], result.basedOnList, parseReference{TFhirReference});
    if jsn.has('groupIdentifier') then
        result.groupIdentifier := ParseIdentifier(jsn.vObj['groupIdentifier']);{q3}
    if jsn.has('partOf') then
      iterateArray(jsn.vArr['partOf'], result.partOfList, parseReference{TFhirTask});
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirTaskStatusEnum, SYSTEMS_TFhirTaskStatusEnum);
    if jsn.has('statusReason') then
        result.statusReason := ParseCodeableConcept(jsn.vObj['statusReason']);{q3}
    if jsn.has('businessStatus') then
        result.businessStatus := ParseCodeableConcept(jsn.vObj['businessStatus']);{q3}
    if jsn.has('intent') or jsn.has('_intent')  then
      result.intentElement := parseEnum(jsn.path+'/intent', jsn.node['intent'], jsn.vObj['_intent'], CODES_TFhirTaskIntentEnum, SYSTEMS_TFhirTaskIntentEnum);
    if jsn.has('priority') or jsn.has('_priority')  then
      result.priorityElement := parseEnum(jsn.path+'/priority', jsn.node['priority'], jsn.vObj['_priority'], CODES_TFhirRequestPriorityEnum, SYSTEMS_TFhirRequestPriorityEnum);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('focus') then
        result.focus := ParseReference{TFhirReference}(jsn.vObj['focus']);{q3}
    if jsn.has('for') then
        result.for_ := ParseReference{TFhirReference}(jsn.vObj['for']);{q3}
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q3}
    if jsn.has('executionPeriod') then
        result.executionPeriod := ParsePeriod(jsn.vObj['executionPeriod']);{q3}
    if jsn.has('authoredOn') or jsn.has('_authoredOn') then
        result.authoredOnElement := parseDateTime(jsn.node['authoredOn'], jsn.vObj['_authoredOn']);{q}
    if jsn.has('lastModified') or jsn.has('_lastModified') then
        result.lastModifiedElement := parseDateTime(jsn.node['lastModified'], jsn.vObj['_lastModified']);{q}
    if jsn.has('requester') then
        result.requester := ParseReference{TFhirDevice}(jsn.vObj['requester']);{q3}
    if jsn.has('performerType') then
      iterateArray(jsn.vArr['performerType'], result.performerTypeList, parseCodeableConcept);
    if jsn.has('owner') then
        result.owner := ParseReference{TFhirPractitioner}(jsn.vObj['owner']);{q3}
    if jsn.has('location') then
        result.location := ParseReference{TFhirLocation}(jsn.vObj['location']);{q3}
    if jsn.has('reasonCode') then
        result.reasonCode := ParseCodeableConcept(jsn.vObj['reasonCode']);{q3}
    if jsn.has('reasonReference') then
        result.reasonReference := ParseReference{TFhirReference}(jsn.vObj['reasonReference']);{q3}
    if jsn.has('insurance') then
      iterateArray(jsn.vArr['insurance'], result.insuranceList, parseReference{TFhirCoverage});
    if jsn.has('note') then
      iterateArray(jsn.vArr['note'], result.noteList, parseAnnotation);
    if jsn.has('relevantHistory') then
      iterateArray(jsn.vArr['relevantHistory'], result.relevantHistoryList, parseReference{TFhirProvenance});
    if jsn.has('restriction') then
        result.restriction := ParseTaskRestriction(jsn.vObj['restriction']);{q3}
    if jsn.has('input') then
      iterateArray(jsn.vArr['input'], result.inputList, parseTaskInput);
    if jsn.has('output') then
      iterateArray(jsn.vArr['output'], result.outputList, parseTaskOutput);
end;

procedure TFHIRJsonComposer.ComposeTask(json : TJSONWriter; name : string; elem : TFhirTask; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('instantiatesCanonical') then
    ComposeCanonicalValue(json, 'instantiatesCanonical', elem.instantiatesCanonicalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('instantiatesCanonical') then
    ComposeCanonicalProps(json, 'instantiatesCanonical', elem.instantiatesCanonicalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('instantiatesUri') then
    ComposeUriValue(json, 'instantiatesUri', elem.instantiatesUriElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('instantiatesUri') then
    ComposeUriProps(json, 'instantiatesUri', elem.instantiatesUriElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('basedOn') and (elem.basedOnList.Count > 0) then
  begin
    json.valueArray('basedOn');
    for i := 0 to elem.basedOnList.Count - 1 do
      ComposeReference{TFhirReference}(json, '', elem.basedOnList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('groupIdentifier') then
    ComposeIdentifier(json, 'groupIdentifier', elem.groupIdentifier); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('partOf') and (elem.partOfList.Count > 0) then
  begin
    json.valueArray('partOf');
    for i := 0 to elem.partOfList.Count - 1 do
      ComposeReference{TFhirTask}(json, '', elem.partOfList[i]); {z - Reference(Task)}
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirTaskStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirTaskStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('statusReason') then
    ComposeCodeableConcept(json, 'statusReason', elem.statusReason); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('businessStatus') then
    ComposeCodeableConcept(json, 'businessStatus', elem.businessStatus); {a}
  ComposeEnumValue(json, 'intent', elem.IntentElement, CODES_TFhirTaskIntentEnum, false);
  ComposeEnumProps(json, 'intent', elem.IntentElement, CODES_TFhirTaskIntentEnum, false);
  if (SummaryOption in [soFull, soData]) and doCompose('priority') then
    ComposeEnumValue(json, 'priority', elem.PriorityElement, CODES_TFhirRequestPriorityEnum, false);
  if (SummaryOption in [soFull, soData]) and doCompose('priority') then
    ComposeEnumProps(json, 'priority', elem.PriorityElement, CODES_TFhirRequestPriorityEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') then
    ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('focus') then
    ComposeReference{TFhirReference}(json, 'focus', elem.focus); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('for_') then
    ComposeReference{TFhirReference}(json, 'for', elem.for_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('executionPeriod') then
    ComposePeriod(json, 'executionPeriod', elem.executionPeriod); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('authoredOn') then
    ComposeDateTimeValue(json, 'authoredOn', elem.authoredOnElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('authoredOn') then
    ComposeDateTimeProps(json, 'authoredOn', elem.authoredOnElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('lastModified') then
    ComposeDateTimeValue(json, 'lastModified', elem.lastModifiedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('lastModified') then
    ComposeDateTimeProps(json, 'lastModified', elem.lastModifiedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requester') then
    ComposeReference{TFhirDevice}(json, 'requester', elem.requester); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('performerType') and (elem.performerTypeList.Count > 0) then
  begin
    json.valueArray('performerType');
    for i := 0 to elem.performerTypeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.performerTypeList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('owner') then
    ComposeReference{TFhirPractitioner}(json, 'owner', elem.owner); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('location') then
    ComposeReference{TFhirLocation}(json, 'location', elem.location); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('reasonCode') then
    ComposeCodeableConcept(json, 'reasonCode', elem.reasonCode); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('reasonReference') then
    ComposeReference{TFhirReference}(json, 'reasonReference', elem.reasonReference); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('insurance') and (elem.insuranceList.Count > 0) then
  begin
    json.valueArray('insurance');
    for i := 0 to elem.insuranceList.Count - 1 do
      ComposeReference{TFhirCoverage}(json, '', elem.insuranceList[i]); {z - Reference(Coverage)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('note') and (elem.noteList.Count > 0) then
  begin
    json.valueArray('note');
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(json, '', elem.noteList[i]); {z - Annotation}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('relevantHistory') and (elem.relevantHistoryList.Count > 0) then
  begin
    json.valueArray('relevantHistory');
    for i := 0 to elem.relevantHistoryList.Count - 1 do
      ComposeReference{TFhirProvenance}(json, '', elem.relevantHistoryList[i]); {z - Reference(Provenance)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('restriction') then
    ComposeTaskRestriction(json, 'restriction', elem.restriction); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('input') and (elem.inputList.Count > 0) then
  begin
    json.valueArray('input');
    for i := 0 to elem.inputList.Count - 1 do
      ComposeTaskInput(json, '', elem.inputList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('output') and (elem.outputList.Count > 0) then
  begin
    json.valueArray('output');
    for i := 0 to elem.outputList.Count - 1 do
      ComposeTaskOutput(json, '', elem.outputList[i]); {z - }
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_TASK}
{$IFDEF FHIR_TERMINOLOGYCAPABILITIES}
procedure TFHIRJsonParser.ParseTerminologyCapabilitiesSoftware(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTerminologyCapabilitiesSoftware(jsn)); {2}
end;

function TFHIRJsonParser.ParseTerminologyCapabilitiesSoftware(jsn : TJsonObject) : TFhirTerminologyCapabilitiesSoftware;
begin
  result := TFhirTerminologyCapabilitiesSoftware.create;
  try
    ParseTerminologyCapabilitiesSoftwareProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseTerminologyCapabilitiesSoftwareProperties(jsn : TJsonObject; result : TFhirTerminologyCapabilitiesSoftware);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := parseString(jsn.node['version'], jsn.vObj['_version']);{q}
end;

procedure TFHIRJsonComposer.ComposeTerminologyCapabilitiesSoftware(json : TJSONWriter; name : string; elem : TFhirTerminologyCapabilitiesSoftware; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'name', elem.nameElement, false);
  ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'version', elem.versionElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseTerminologyCapabilitiesImplementation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTerminologyCapabilitiesImplementation(jsn)); {2}
end;

function TFHIRJsonParser.ParseTerminologyCapabilitiesImplementation(jsn : TJsonObject) : TFhirTerminologyCapabilitiesImplementation;
begin
  result := TFhirTerminologyCapabilitiesImplementation.create;
  try
    ParseTerminologyCapabilitiesImplementationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseTerminologyCapabilitiesImplementationProperties(jsn : TJsonObject; result : TFhirTerminologyCapabilitiesImplementation);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := parseUrl(jsn.node['url'], jsn.vObj['_url']);{q}
end;

procedure TFHIRJsonComposer.ComposeTerminologyCapabilitiesImplementation(json : TJSONWriter; name : string; elem : TFhirTerminologyCapabilitiesImplementation; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'description', elem.descriptionElement, false);
  ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUrlValue(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUrlProps(json, 'url', elem.urlElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseTerminologyCapabilitiesCodeSystem(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTerminologyCapabilitiesCodeSystem(jsn)); {2}
end;

function TFHIRJsonParser.ParseTerminologyCapabilitiesCodeSystem(jsn : TJsonObject) : TFhirTerminologyCapabilitiesCodeSystem;
begin
  result := TFhirTerminologyCapabilitiesCodeSystem.create;
  try
    ParseTerminologyCapabilitiesCodeSystemProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseTerminologyCapabilitiesCodeSystemProperties(jsn : TJsonObject; result : TFhirTerminologyCapabilitiesCodeSystem);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('uri') or jsn.has('_uri') then
        result.uriElement := parseCanonical(jsn.node['uri'], jsn.vObj['_uri']);{q}
    if jsn.has('version') then
      iterateArray(jsn.vArr['version'], result.versionList, parseTerminologyCapabilitiesCodeSystemVersion);
    if jsn.has('subsumption') or jsn.has('_subsumption') then
        result.subsumptionElement := parseBoolean(jsn.node['subsumption'], jsn.vObj['_subsumption']);{q}
end;

procedure TFHIRJsonComposer.ComposeTerminologyCapabilitiesCodeSystem(json : TJSONWriter; name : string; elem : TFhirTerminologyCapabilitiesCodeSystem; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonicalValue(json, 'uri', elem.uriElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCanonicalProps(json, 'uri', elem.uriElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.versionList.Count > 0) then
  begin
    json.valueArray('version');
    for i := 0 to elem.versionList.Count - 1 do
      ComposeTerminologyCapabilitiesCodeSystemVersion(json, '', elem.versionList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'subsumption', elem.subsumptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'subsumption', elem.subsumptionElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseTerminologyCapabilitiesCodeSystemVersion(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTerminologyCapabilitiesCodeSystemVersion(jsn)); {2}
end;

function TFHIRJsonParser.ParseTerminologyCapabilitiesCodeSystemVersion(jsn : TJsonObject) : TFhirTerminologyCapabilitiesCodeSystemVersion;
begin
  result := TFhirTerminologyCapabilitiesCodeSystemVersion.create;
  try
    ParseTerminologyCapabilitiesCodeSystemVersionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseTerminologyCapabilitiesCodeSystemVersionProperties(jsn : TJsonObject; result : TFhirTerminologyCapabilitiesCodeSystemVersion);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') or jsn.has('_code') then
        result.codeElement := parseString(jsn.node['code'], jsn.vObj['_code']);{q}
    if jsn.has('isDefault') or jsn.has('_isDefault') then
        result.isDefaultElement := parseBoolean(jsn.node['isDefault'], jsn.vObj['_isDefault']);{q}
    if jsn.has('compositional') or jsn.has('_compositional') then
        result.compositionalElement := parseBoolean(jsn.node['compositional'], jsn.vObj['_compositional']);{q}
      if jsn.has('language') or jsn.has('_language') then
      iteratePrimitiveArray(jsn.vArr['language'], jsn.vArr['_language'], result.languageList, parseCode);
    if jsn.has('filter') then
      iterateArray(jsn.vArr['filter'], result.filterList, parseTerminologyCapabilitiesCodeSystemVersionFilter);
      if jsn.has('property') or jsn.has('_property') then
      iteratePrimitiveArray(jsn.vArr['property'], jsn.vArr['_property'], result.property_List, parseCode);
end;

procedure TFHIRJsonComposer.ComposeTerminologyCapabilitiesCodeSystemVersion(json : TJSONWriter; name : string; elem : TFhirTerminologyCapabilitiesCodeSystemVersion; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'code', elem.codeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'code', elem.codeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBooleanValue(json, 'isDefault', elem.isDefaultElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBooleanProps(json, 'isDefault', elem.isDefaultElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'compositional', elem.compositionalElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'compositional', elem.compositionalElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.languageList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.languageList.Count - 1 do
    begin
      ext := ext or ((elem.languageList[i].id <> '') or (elem.languageList[i].hasExtensionList) {no-comments or (elem.languageList[i].hasComments)});
      val := val or (elem.languageList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('language');
      for i := 0 to elem.languageList.Count - 1 do
        ComposeCodeValue(json, '',elem.languageList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_language');
      for i := 0 to elem.languageList.Count - 1 do
        ComposeCodeProps(json, '',elem.languageList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.filterList.Count > 0) then
  begin
    json.valueArray('filter');
    for i := 0 to elem.filterList.Count - 1 do
      ComposeTerminologyCapabilitiesCodeSystemVersionFilter(json, '', elem.filterList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.property_List.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.property_List.Count - 1 do
    begin
      ext := ext or ((elem.property_List[i].id <> '') or (elem.property_List[i].hasExtensionList) {no-comments or (elem.property_List[i].hasComments)});
      val := val or (elem.property_List[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('property');
      for i := 0 to elem.property_List.Count - 1 do
        ComposeCodeValue(json, '',elem.property_List[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_property');
      for i := 0 to elem.property_List.Count - 1 do
        ComposeCodeProps(json, '',elem.property_List[i], true);
      json.FinishArray;
    end;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseTerminologyCapabilitiesCodeSystemVersionFilter(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTerminologyCapabilitiesCodeSystemVersionFilter(jsn)); {2}
end;

function TFHIRJsonParser.ParseTerminologyCapabilitiesCodeSystemVersionFilter(jsn : TJsonObject) : TFhirTerminologyCapabilitiesCodeSystemVersionFilter;
begin
  result := TFhirTerminologyCapabilitiesCodeSystemVersionFilter.create;
  try
    ParseTerminologyCapabilitiesCodeSystemVersionFilterProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseTerminologyCapabilitiesCodeSystemVersionFilterProperties(jsn : TJsonObject; result : TFhirTerminologyCapabilitiesCodeSystemVersionFilter);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') or jsn.has('_code') then
        result.codeElement := parseCode(jsn.node['code'], jsn.vObj['_code']);{q}
      if jsn.has('op') or jsn.has('_op') then
      iteratePrimitiveArray(jsn.vArr['op'], jsn.vArr['_op'], result.opList, parseCode);
end;

procedure TFHIRJsonComposer.ComposeTerminologyCapabilitiesCodeSystemVersionFilter(json : TJSONWriter; name : string; elem : TFhirTerminologyCapabilitiesCodeSystemVersionFilter; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeValue(json, 'code', elem.codeElement, false);
  ComposeCodeProps(json, 'code', elem.codeElement, false);
  if (elem.opList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.opList.Count - 1 do
    begin
      ext := ext or ((elem.opList[i].id <> '') or (elem.opList[i].hasExtensionList) {no-comments or (elem.opList[i].hasComments)});
      val := val or (elem.opList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('op');
      for i := 0 to elem.opList.Count - 1 do
        ComposeCodeValue(json, '',elem.opList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_op');
      for i := 0 to elem.opList.Count - 1 do
        ComposeCodeProps(json, '',elem.opList[i], true);
      json.FinishArray;
    end;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseTerminologyCapabilitiesExpansion(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTerminologyCapabilitiesExpansion(jsn)); {2}
end;

function TFHIRJsonParser.ParseTerminologyCapabilitiesExpansion(jsn : TJsonObject) : TFhirTerminologyCapabilitiesExpansion;
begin
  result := TFhirTerminologyCapabilitiesExpansion.create;
  try
    ParseTerminologyCapabilitiesExpansionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseTerminologyCapabilitiesExpansionProperties(jsn : TJsonObject; result : TFhirTerminologyCapabilitiesExpansion);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('hierarchical') or jsn.has('_hierarchical') then
        result.hierarchicalElement := parseBoolean(jsn.node['hierarchical'], jsn.vObj['_hierarchical']);{q}
    if jsn.has('paging') or jsn.has('_paging') then
        result.pagingElement := parseBoolean(jsn.node['paging'], jsn.vObj['_paging']);{q}
    if jsn.has('incomplete') or jsn.has('_incomplete') then
        result.incompleteElement := parseBoolean(jsn.node['incomplete'], jsn.vObj['_incomplete']);{q}
    if jsn.has('parameter') then
      iterateArray(jsn.vArr['parameter'], result.parameterList, parseTerminologyCapabilitiesExpansionParameter);
    if jsn.has('textFilter') or jsn.has('_textFilter') then
        result.textFilterElement := parseMarkdown(jsn.node['textFilter'], jsn.vObj['_textFilter']);{q}
end;

procedure TFHIRJsonComposer.ComposeTerminologyCapabilitiesExpansion(json : TJSONWriter; name : string; elem : TFhirTerminologyCapabilitiesExpansion; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'hierarchical', elem.hierarchicalElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'hierarchical', elem.hierarchicalElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'paging', elem.pagingElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'paging', elem.pagingElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'incomplete', elem.incompleteElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'incomplete', elem.incompleteElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.parameterList.Count > 0) then
  begin
    json.valueArray('parameter');
    for i := 0 to elem.parameterList.Count - 1 do
      ComposeTerminologyCapabilitiesExpansionParameter(json, '', elem.parameterList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdownValue(json, 'textFilter', elem.textFilterElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdownProps(json, 'textFilter', elem.textFilterElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseTerminologyCapabilitiesExpansionParameter(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTerminologyCapabilitiesExpansionParameter(jsn)); {2}
end;

function TFHIRJsonParser.ParseTerminologyCapabilitiesExpansionParameter(jsn : TJsonObject) : TFhirTerminologyCapabilitiesExpansionParameter;
begin
  result := TFhirTerminologyCapabilitiesExpansionParameter.create;
  try
    ParseTerminologyCapabilitiesExpansionParameterProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseTerminologyCapabilitiesExpansionParameterProperties(jsn : TJsonObject; result : TFhirTerminologyCapabilitiesExpansionParameter);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseCode(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('documentation') or jsn.has('_documentation') then
        result.documentationElement := parseString(jsn.node['documentation'], jsn.vObj['_documentation']);{q}
end;

procedure TFHIRJsonComposer.ComposeTerminologyCapabilitiesExpansionParameter(json : TJSONWriter; name : string; elem : TFhirTerminologyCapabilitiesExpansionParameter; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeValue(json, 'name', elem.nameElement, false);
  ComposeCodeProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'documentation', elem.documentationElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'documentation', elem.documentationElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseTerminologyCapabilitiesValidateCode(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTerminologyCapabilitiesValidateCode(jsn)); {2}
end;

function TFHIRJsonParser.ParseTerminologyCapabilitiesValidateCode(jsn : TJsonObject) : TFhirTerminologyCapabilitiesValidateCode;
begin
  result := TFhirTerminologyCapabilitiesValidateCode.create;
  try
    ParseTerminologyCapabilitiesValidateCodeProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseTerminologyCapabilitiesValidateCodeProperties(jsn : TJsonObject; result : TFhirTerminologyCapabilitiesValidateCode);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('translations') or jsn.has('_translations') then
        result.translationsElement := parseBoolean(jsn.node['translations'], jsn.vObj['_translations']);{q}
end;

procedure TFHIRJsonComposer.ComposeTerminologyCapabilitiesValidateCode(json : TJSONWriter; name : string; elem : TFhirTerminologyCapabilitiesValidateCode; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeBooleanValue(json, 'translations', elem.translationsElement, false);
  ComposeBooleanProps(json, 'translations', elem.translationsElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseTerminologyCapabilitiesTranslation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTerminologyCapabilitiesTranslation(jsn)); {2}
end;

function TFHIRJsonParser.ParseTerminologyCapabilitiesTranslation(jsn : TJsonObject) : TFhirTerminologyCapabilitiesTranslation;
begin
  result := TFhirTerminologyCapabilitiesTranslation.create;
  try
    ParseTerminologyCapabilitiesTranslationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseTerminologyCapabilitiesTranslationProperties(jsn : TJsonObject; result : TFhirTerminologyCapabilitiesTranslation);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('needsMap') or jsn.has('_needsMap') then
        result.needsMapElement := parseBoolean(jsn.node['needsMap'], jsn.vObj['_needsMap']);{q}
end;

procedure TFHIRJsonComposer.ComposeTerminologyCapabilitiesTranslation(json : TJSONWriter; name : string; elem : TFhirTerminologyCapabilitiesTranslation; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeBooleanValue(json, 'needsMap', elem.needsMapElement, false);
  ComposeBooleanProps(json, 'needsMap', elem.needsMapElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseTerminologyCapabilitiesClosure(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTerminologyCapabilitiesClosure(jsn)); {2}
end;

function TFHIRJsonParser.ParseTerminologyCapabilitiesClosure(jsn : TJsonObject) : TFhirTerminologyCapabilitiesClosure;
begin
  result := TFhirTerminologyCapabilitiesClosure.create;
  try
    ParseTerminologyCapabilitiesClosureProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseTerminologyCapabilitiesClosureProperties(jsn : TJsonObject; result : TFhirTerminologyCapabilitiesClosure);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('translation') or jsn.has('_translation') then
        result.translationElement := parseBoolean(jsn.node['translation'], jsn.vObj['_translation']);{q}
end;

procedure TFHIRJsonComposer.ComposeTerminologyCapabilitiesClosure(json : TJSONWriter; name : string; elem : TFhirTerminologyCapabilitiesClosure; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'translation', elem.translationElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'translation', elem.translationElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseTerminologyCapabilities(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTerminologyCapabilities(jsn)); {2}
end;

function TFHIRJsonParser.ParseTerminologyCapabilities(jsn : TJsonObject) : TFhirTerminologyCapabilities;
begin
  result := TFhirTerminologyCapabilities.create;
  try
    ParseTerminologyCapabilitiesProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseTerminologyCapabilitiesProperties(jsn : TJsonObject; result : TFhirTerminologyCapabilities);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := parseUri(jsn.node['url'], jsn.vObj['_url']);{q}
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := parseString(jsn.node['version'], jsn.vObj['_version']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('title') or jsn.has('_title') then
        result.titleElement := parseString(jsn.node['title'], jsn.vObj['_title']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    if jsn.has('experimental') or jsn.has('_experimental') then
        result.experimentalElement := parseBoolean(jsn.node['experimental'], jsn.vObj['_experimental']);{q}
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := parseDateTime(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('publisher') or jsn.has('_publisher') then
        result.publisherElement := parseString(jsn.node['publisher'], jsn.vObj['_publisher']);{q}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseContactDetail);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseMarkdown(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('useContext') then
      iterateArray(jsn.vArr['useContext'], result.useContextList, parseUsageContext);
    if jsn.has('jurisdiction') then
      iterateArray(jsn.vArr['jurisdiction'], result.jurisdictionList, parseCodeableConcept);
    if jsn.has('purpose') or jsn.has('_purpose') then
        result.purposeElement := parseMarkdown(jsn.node['purpose'], jsn.vObj['_purpose']);{q}
    if jsn.has('copyright') or jsn.has('_copyright') then
        result.copyrightElement := parseMarkdown(jsn.node['copyright'], jsn.vObj['_copyright']);{q}
    if jsn.has('kind') or jsn.has('_kind')  then
      result.kindElement := parseEnum(jsn.path+'/kind', jsn.node['kind'], jsn.vObj['_kind'], CODES_TFhirCapabilityStatementKindEnum, SYSTEMS_TFhirCapabilityStatementKindEnum);
    if jsn.has('software') then
        result.software := ParseTerminologyCapabilitiesSoftware(jsn.vObj['software']);{q3}
    if jsn.has('implementation') then
        result.implementation_ := ParseTerminologyCapabilitiesImplementation(jsn.vObj['implementation']);{q3}
    if jsn.has('lockedDate') or jsn.has('_lockedDate') then
        result.lockedDateElement := parseBoolean(jsn.node['lockedDate'], jsn.vObj['_lockedDate']);{q}
    if jsn.has('codeSystem') then
      iterateArray(jsn.vArr['codeSystem'], result.codeSystemList, parseTerminologyCapabilitiesCodeSystem);
    if jsn.has('expansion') then
        result.expansion := ParseTerminologyCapabilitiesExpansion(jsn.vObj['expansion']);{q3}
    if jsn.has('codeSearch') or jsn.has('_codeSearch')  then
      result.codeSearchElement := parseEnum(jsn.path+'/codeSearch', jsn.node['codeSearch'], jsn.vObj['_codeSearch'], CODES_TFhirCodeSearchSupportEnum, SYSTEMS_TFhirCodeSearchSupportEnum);
    if jsn.has('validateCode') then
        result.validateCode := ParseTerminologyCapabilitiesValidateCode(jsn.vObj['validateCode']);{q3}
    if jsn.has('translation') then
        result.translation := ParseTerminologyCapabilitiesTranslation(jsn.vObj['translation']);{q3}
    if jsn.has('closure') then
        result.closure := ParseTerminologyCapabilitiesClosure(jsn.vObj['closure']);{q3}
end;

procedure TFHIRJsonComposer.ComposeTerminologyCapabilities(json : TJSONWriter; name : string; elem : TFhirTerminologyCapabilities; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUriValue(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUriProps(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeStringValue(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeStringProps(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeStringValue(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeStringProps(json, 'title', elem.titleElement, false);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBooleanValue(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBooleanProps(json, 'experimental', elem.experimentalElement, false);
  ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringValue(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringProps(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') and (elem.contactList.Count > 0) then
  begin
    json.valueArray('contact');
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(json, '', elem.contactList[i]); {z - ContactDetail}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdownValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdownProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') and (elem.useContextList.Count > 0) then
  begin
    json.valueArray('useContext');
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(json, '', elem.useContextList[i]); {z - UsageContext}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') and (elem.jurisdictionList.Count > 0) then
  begin
    json.valueArray('jurisdiction');
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.jurisdictionList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdownValue(json, 'purpose', elem.purposeElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdownProps(json, 'purpose', elem.purposeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('copyright') then
    ComposeMarkdownValue(json, 'copyright', elem.copyrightElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('copyright') then
    ComposeMarkdownProps(json, 'copyright', elem.copyrightElement, false);
  ComposeEnumValue(json, 'kind', elem.KindElement, CODES_TFhirCapabilityStatementKindEnum, false);
  ComposeEnumProps(json, 'kind', elem.KindElement, CODES_TFhirCapabilityStatementKindEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('software') then
    ComposeTerminologyCapabilitiesSoftware(json, 'software', elem.software); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('implementation_') then
    ComposeTerminologyCapabilitiesImplementation(json, 'implementation', elem.implementation_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('lockedDate') then
    ComposeBooleanValue(json, 'lockedDate', elem.lockedDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('lockedDate') then
    ComposeBooleanProps(json, 'lockedDate', elem.lockedDateElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('codeSystem') and (elem.codeSystemList.Count > 0) then
  begin
    json.valueArray('codeSystem');
    for i := 0 to elem.codeSystemList.Count - 1 do
      ComposeTerminologyCapabilitiesCodeSystem(json, '', elem.codeSystemList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('expansion') then
    ComposeTerminologyCapabilitiesExpansion(json, 'expansion', elem.expansion); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('codeSearch') then
    ComposeEnumValue(json, 'codeSearch', elem.CodeSearchElement, CODES_TFhirCodeSearchSupportEnum, false);
  if (SummaryOption in [soFull, soData]) and doCompose('codeSearch') then
    ComposeEnumProps(json, 'codeSearch', elem.CodeSearchElement, CODES_TFhirCodeSearchSupportEnum, false);
  if (SummaryOption in [soFull, soData]) and doCompose('validateCode') then
    ComposeTerminologyCapabilitiesValidateCode(json, 'validateCode', elem.validateCode); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('translation') then
    ComposeTerminologyCapabilitiesTranslation(json, 'translation', elem.translation); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('closure') then
    ComposeTerminologyCapabilitiesClosure(json, 'closure', elem.closure); {a}
end;

{$ENDIF FHIR_TERMINOLOGYCAPABILITIES}
{$IFDEF FHIR_TESTREPORT}
procedure TFHIRJsonParser.ParseTestReportParticipant(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTestReportParticipant(jsn)); {2}
end;

function TFHIRJsonParser.ParseTestReportParticipant(jsn : TJsonObject) : TFhirTestReportParticipant;
begin
  result := TFhirTestReportParticipant.create;
  try
    ParseTestReportParticipantProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseTestReportParticipantProperties(jsn : TJsonObject; result : TFhirTestReportParticipant);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn.node['type'], jsn.vObj['_type'], CODES_TFhirReportParticipantTypeEnum, SYSTEMS_TFhirReportParticipantTypeEnum);
    if jsn.has('uri') or jsn.has('_uri') then
        result.uriElement := parseUri(jsn.node['uri'], jsn.vObj['_uri']);{q}
    if jsn.has('display') or jsn.has('_display') then
        result.displayElement := parseString(jsn.node['display'], jsn.vObj['_display']);{q}
end;

procedure TFHIRJsonComposer.ComposeTestReportParticipant(json : TJSONWriter; name : string; elem : TFhirTestReportParticipant; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirReportParticipantTypeEnum, false);
  ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirReportParticipantTypeEnum, false);
  ComposeUriValue(json, 'uri', elem.uriElement, false);
  ComposeUriProps(json, 'uri', elem.uriElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'display', elem.displayElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'display', elem.displayElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseTestReportSetup(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTestReportSetup(jsn)); {2}
end;

function TFHIRJsonParser.ParseTestReportSetup(jsn : TJsonObject) : TFhirTestReportSetup;
begin
  result := TFhirTestReportSetup.create;
  try
    ParseTestReportSetupProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseTestReportSetupProperties(jsn : TJsonObject; result : TFhirTestReportSetup);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('action') then
      iterateArray(jsn.vArr['action'], result.actionList, parseTestReportSetupAction);
end;

procedure TFHIRJsonComposer.ComposeTestReportSetup(json : TJSONWriter; name : string; elem : TFhirTestReportSetup; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (elem.actionList.Count > 0) then
  begin
    json.valueArray('action');
    for i := 0 to elem.actionList.Count - 1 do
      ComposeTestReportSetupAction(json, '', elem.actionList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseTestReportSetupAction(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTestReportSetupAction(jsn)); {2}
end;

function TFHIRJsonParser.ParseTestReportSetupAction(jsn : TJsonObject) : TFhirTestReportSetupAction;
begin
  result := TFhirTestReportSetupAction.create;
  try
    ParseTestReportSetupActionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseTestReportSetupActionProperties(jsn : TJsonObject; result : TFhirTestReportSetupAction);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('operation') then
        result.operation := ParseTestReportSetupActionOperation(jsn.vObj['operation']);{q3}
    if jsn.has('assert') then
        result.assert := ParseTestReportSetupActionAssert(jsn.vObj['assert']);{q3}
end;

procedure TFHIRJsonComposer.ComposeTestReportSetupAction(json : TJSONWriter; name : string; elem : TFhirTestReportSetupAction; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeTestReportSetupActionOperation(json, 'operation', elem.operation); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeTestReportSetupActionAssert(json, 'assert', elem.assert); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseTestReportSetupActionOperation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTestReportSetupActionOperation(jsn)); {2}
end;

function TFHIRJsonParser.ParseTestReportSetupActionOperation(jsn : TJsonObject) : TFhirTestReportSetupActionOperation;
begin
  result := TFhirTestReportSetupActionOperation.create;
  try
    ParseTestReportSetupActionOperationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseTestReportSetupActionOperationProperties(jsn : TJsonObject; result : TFhirTestReportSetupActionOperation);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('result') or jsn.has('_result')  then
      result.resultElement := parseEnum(jsn.path+'/result', jsn.node['result'], jsn.vObj['_result'], CODES_TFhirReportActionResultCodesEnum, SYSTEMS_TFhirReportActionResultCodesEnum);
    if jsn.has('message') or jsn.has('_message') then
        result.messageElement := parseMarkdown(jsn.node['message'], jsn.vObj['_message']);{q}
    if jsn.has('detail') or jsn.has('_detail') then
        result.detailElement := parseUri(jsn.node['detail'], jsn.vObj['_detail']);{q}
end;

procedure TFHIRJsonComposer.ComposeTestReportSetupActionOperation(json : TJSONWriter; name : string; elem : TFhirTestReportSetupActionOperation; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'result', elem.ResultElement, CODES_TFhirReportActionResultCodesEnum, false);
  ComposeEnumProps(json, 'result', elem.ResultElement, CODES_TFhirReportActionResultCodesEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdownValue(json, 'message', elem.messageElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdownProps(json, 'message', elem.messageElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeUriValue(json, 'detail', elem.detailElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeUriProps(json, 'detail', elem.detailElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseTestReportSetupActionAssert(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTestReportSetupActionAssert(jsn)); {2}
end;

function TFHIRJsonParser.ParseTestReportSetupActionAssert(jsn : TJsonObject) : TFhirTestReportSetupActionAssert;
begin
  result := TFhirTestReportSetupActionAssert.create;
  try
    ParseTestReportSetupActionAssertProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseTestReportSetupActionAssertProperties(jsn : TJsonObject; result : TFhirTestReportSetupActionAssert);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('result') or jsn.has('_result')  then
      result.resultElement := parseEnum(jsn.path+'/result', jsn.node['result'], jsn.vObj['_result'], CODES_TFhirReportActionResultCodesEnum, SYSTEMS_TFhirReportActionResultCodesEnum);
    if jsn.has('message') or jsn.has('_message') then
        result.messageElement := parseMarkdown(jsn.node['message'], jsn.vObj['_message']);{q}
    if jsn.has('detail') or jsn.has('_detail') then
        result.detailElement := parseString(jsn.node['detail'], jsn.vObj['_detail']);{q}
end;

procedure TFHIRJsonComposer.ComposeTestReportSetupActionAssert(json : TJSONWriter; name : string; elem : TFhirTestReportSetupActionAssert; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'result', elem.ResultElement, CODES_TFhirReportActionResultCodesEnum, false);
  ComposeEnumProps(json, 'result', elem.ResultElement, CODES_TFhirReportActionResultCodesEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdownValue(json, 'message', elem.messageElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeMarkdownProps(json, 'message', elem.messageElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'detail', elem.detailElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'detail', elem.detailElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseTestReportTest(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTestReportTest(jsn)); {2}
end;

function TFHIRJsonParser.ParseTestReportTest(jsn : TJsonObject) : TFhirTestReportTest;
begin
  result := TFhirTestReportTest.create;
  try
    ParseTestReportTestProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseTestReportTestProperties(jsn : TJsonObject; result : TFhirTestReportTest);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('action') then
      iterateArray(jsn.vArr['action'], result.actionList, parseTestReportTestAction);
end;

procedure TFHIRJsonComposer.ComposeTestReportTest(json : TJSONWriter; name : string; elem : TFhirTestReportTest; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (elem.actionList.Count > 0) then
  begin
    json.valueArray('action');
    for i := 0 to elem.actionList.Count - 1 do
      ComposeTestReportTestAction(json, '', elem.actionList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseTestReportTestAction(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTestReportTestAction(jsn)); {2}
end;

function TFHIRJsonParser.ParseTestReportTestAction(jsn : TJsonObject) : TFhirTestReportTestAction;
begin
  result := TFhirTestReportTestAction.create;
  try
    ParseTestReportTestActionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseTestReportTestActionProperties(jsn : TJsonObject; result : TFhirTestReportTestAction);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('operation') then
        result.operation := ParseTestReportSetupActionOperation(jsn.vObj['operation']);{q3}
    if jsn.has('assert') then
        result.assert := ParseTestReportSetupActionAssert(jsn.vObj['assert']);{q3}
end;

procedure TFHIRJsonComposer.ComposeTestReportTestAction(json : TJSONWriter; name : string; elem : TFhirTestReportTestAction; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeTestReportSetupActionOperation(json, 'operation', elem.operation); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeTestReportSetupActionAssert(json, 'assert', elem.assert); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseTestReportTeardown(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTestReportTeardown(jsn)); {2}
end;

function TFHIRJsonParser.ParseTestReportTeardown(jsn : TJsonObject) : TFhirTestReportTeardown;
begin
  result := TFhirTestReportTeardown.create;
  try
    ParseTestReportTeardownProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseTestReportTeardownProperties(jsn : TJsonObject; result : TFhirTestReportTeardown);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('action') then
      iterateArray(jsn.vArr['action'], result.actionList, parseTestReportTeardownAction);
end;

procedure TFHIRJsonComposer.ComposeTestReportTeardown(json : TJSONWriter; name : string; elem : TFhirTestReportTeardown; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (elem.actionList.Count > 0) then
  begin
    json.valueArray('action');
    for i := 0 to elem.actionList.Count - 1 do
      ComposeTestReportTeardownAction(json, '', elem.actionList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseTestReportTeardownAction(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTestReportTeardownAction(jsn)); {2}
end;

function TFHIRJsonParser.ParseTestReportTeardownAction(jsn : TJsonObject) : TFhirTestReportTeardownAction;
begin
  result := TFhirTestReportTeardownAction.create;
  try
    ParseTestReportTeardownActionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseTestReportTeardownActionProperties(jsn : TJsonObject; result : TFhirTestReportTeardownAction);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('operation') then
        result.operation := ParseTestReportSetupActionOperation(jsn.vObj['operation']);{q3}
end;

procedure TFHIRJsonComposer.ComposeTestReportTeardownAction(json : TJSONWriter; name : string; elem : TFhirTestReportTeardownAction; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeTestReportSetupActionOperation(json, 'operation', elem.operation); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseTestReport(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTestReport(jsn)); {2}
end;

function TFHIRJsonParser.ParseTestReport(jsn : TJsonObject) : TFhirTestReport;
begin
  result := TFhirTestReport.create;
  try
    ParseTestReportProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseTestReportProperties(jsn : TJsonObject; result : TFhirTestReport);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q3}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirReportStatusCodesEnum, SYSTEMS_TFhirReportStatusCodesEnum);
    if jsn.has('testScript') then
        result.testScript := ParseReference{TFhirTestScript}(jsn.vObj['testScript']);{q3}
    if jsn.has('result') or jsn.has('_result')  then
      result.resultElement := parseEnum(jsn.path+'/result', jsn.node['result'], jsn.vObj['_result'], CODES_TFhirReportResultCodesEnum, SYSTEMS_TFhirReportResultCodesEnum);
    if jsn.has('score') or jsn.has('_score') then
        result.scoreElement := parseDecimal(jsn.node['score'], jsn.vObj['_score']);{q}
    if jsn.has('tester') or jsn.has('_tester') then
        result.testerElement := parseString(jsn.node['tester'], jsn.vObj['_tester']);{q}
    if jsn.has('issued') or jsn.has('_issued') then
        result.issuedElement := parseDateTime(jsn.node['issued'], jsn.vObj['_issued']);{q}
    if jsn.has('participant') then
      iterateArray(jsn.vArr['participant'], result.participantList, parseTestReportParticipant);
    if jsn.has('setup') then
        result.setup := ParseTestReportSetup(jsn.vObj['setup']);{q3}
    if jsn.has('test') then
      iterateArray(jsn.vArr['test'], result.testList, parseTestReportTest);
    if jsn.has('teardown') then
        result.teardown := ParseTestReportTeardown(jsn.vObj['teardown']);{q3}
end;

procedure TFHIRJsonComposer.ComposeTestReport(json : TJSONWriter; name : string; elem : TFhirTestReport; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirReportStatusCodesEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirReportStatusCodesEnum, false);
  ComposeReference{TFhirTestScript}(json, 'testScript', elem.testScript); {a}
  ComposeEnumValue(json, 'result', elem.ResultElement, CODES_TFhirReportResultCodesEnum, false);
  ComposeEnumProps(json, 'result', elem.ResultElement, CODES_TFhirReportResultCodesEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('score') then
    ComposeDecimalValue(json, 'score', elem.scoreElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('score') then
    ComposeDecimalProps(json, 'score', elem.scoreElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('tester') then
    ComposeStringValue(json, 'tester', elem.testerElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('tester') then
    ComposeStringProps(json, 'tester', elem.testerElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('issued') then
    ComposeDateTimeValue(json, 'issued', elem.issuedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('issued') then
    ComposeDateTimeProps(json, 'issued', elem.issuedElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('participant') and (elem.participantList.Count > 0) then
  begin
    json.valueArray('participant');
    for i := 0 to elem.participantList.Count - 1 do
      ComposeTestReportParticipant(json, '', elem.participantList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('setup') then
    ComposeTestReportSetup(json, 'setup', elem.setup); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('test') and (elem.testList.Count > 0) then
  begin
    json.valueArray('test');
    for i := 0 to elem.testList.Count - 1 do
      ComposeTestReportTest(json, '', elem.testList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('teardown') then
    ComposeTestReportTeardown(json, 'teardown', elem.teardown); {a}
end;

{$ENDIF FHIR_TESTREPORT}
{$IFDEF FHIR_TESTSCRIPT}
procedure TFHIRJsonParser.ParseTestScriptOrigin(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTestScriptOrigin(jsn)); {2}
end;

function TFHIRJsonParser.ParseTestScriptOrigin(jsn : TJsonObject) : TFhirTestScriptOrigin;
begin
  result := TFhirTestScriptOrigin.create;
  try
    ParseTestScriptOriginProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseTestScriptOriginProperties(jsn : TJsonObject; result : TFhirTestScriptOrigin);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('index') or jsn.has('_index') then
        result.indexElement := parseInteger(jsn.node['index'], jsn.vObj['_index']);{q}
    if jsn.has('profile') then
        result.profile := ParseCoding(jsn.vObj['profile']);{q3}
end;

procedure TFHIRJsonComposer.ComposeTestScriptOrigin(json : TJSONWriter; name : string; elem : TFhirTestScriptOrigin; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeIntegerValue(json, 'index', elem.indexElement, false);
  ComposeIntegerProps(json, 'index', elem.indexElement, false);
  ComposeCoding(json, 'profile', elem.profile); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseTestScriptDestination(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTestScriptDestination(jsn)); {2}
end;

function TFHIRJsonParser.ParseTestScriptDestination(jsn : TJsonObject) : TFhirTestScriptDestination;
begin
  result := TFhirTestScriptDestination.create;
  try
    ParseTestScriptDestinationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseTestScriptDestinationProperties(jsn : TJsonObject; result : TFhirTestScriptDestination);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('index') or jsn.has('_index') then
        result.indexElement := parseInteger(jsn.node['index'], jsn.vObj['_index']);{q}
    if jsn.has('profile') then
        result.profile := ParseCoding(jsn.vObj['profile']);{q3}
end;

procedure TFHIRJsonComposer.ComposeTestScriptDestination(json : TJSONWriter; name : string; elem : TFhirTestScriptDestination; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeIntegerValue(json, 'index', elem.indexElement, false);
  ComposeIntegerProps(json, 'index', elem.indexElement, false);
  ComposeCoding(json, 'profile', elem.profile); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseTestScriptMetadata(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTestScriptMetadata(jsn)); {2}
end;

function TFHIRJsonParser.ParseTestScriptMetadata(jsn : TJsonObject) : TFhirTestScriptMetadata;
begin
  result := TFhirTestScriptMetadata.create;
  try
    ParseTestScriptMetadataProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseTestScriptMetadataProperties(jsn : TJsonObject; result : TFhirTestScriptMetadata);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('link') then
      iterateArray(jsn.vArr['link'], result.link_List, parseTestScriptMetadataLink);
    if jsn.has('capability') then
      iterateArray(jsn.vArr['capability'], result.capabilityList, parseTestScriptMetadataCapability);
end;

procedure TFHIRJsonComposer.ComposeTestScriptMetadata(json : TJSONWriter; name : string; elem : TFhirTestScriptMetadata; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and (elem.link_List.Count > 0) then
  begin
    json.valueArray('link');
    for i := 0 to elem.link_List.Count - 1 do
      ComposeTestScriptMetadataLink(json, '', elem.link_List[i]); {z - }
    json.FinishArray;
  end;
  if (elem.capabilityList.Count > 0) then
  begin
    json.valueArray('capability');
    for i := 0 to elem.capabilityList.Count - 1 do
      ComposeTestScriptMetadataCapability(json, '', elem.capabilityList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseTestScriptMetadataLink(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTestScriptMetadataLink(jsn)); {2}
end;

function TFHIRJsonParser.ParseTestScriptMetadataLink(jsn : TJsonObject) : TFhirTestScriptMetadataLink;
begin
  result := TFhirTestScriptMetadataLink.create;
  try
    ParseTestScriptMetadataLinkProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseTestScriptMetadataLinkProperties(jsn : TJsonObject; result : TFhirTestScriptMetadataLink);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := parseUri(jsn.node['url'], jsn.vObj['_url']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseString(jsn.node['description'], jsn.vObj['_description']);{q}
end;

procedure TFHIRJsonComposer.ComposeTestScriptMetadataLink(json : TJSONWriter; name : string; elem : TFhirTestScriptMetadataLink; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeUriValue(json, 'url', elem.urlElement, false);
  ComposeUriProps(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseTestScriptMetadataCapability(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTestScriptMetadataCapability(jsn)); {2}
end;

function TFHIRJsonParser.ParseTestScriptMetadataCapability(jsn : TJsonObject) : TFhirTestScriptMetadataCapability;
begin
  result := TFhirTestScriptMetadataCapability.create;
  try
    ParseTestScriptMetadataCapabilityProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseTestScriptMetadataCapabilityProperties(jsn : TJsonObject; result : TFhirTestScriptMetadataCapability);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('required') or jsn.has('_required') then
        result.requiredElement := parseBoolean(jsn.node['required'], jsn.vObj['_required']);{q}
    if jsn.has('validated') or jsn.has('_validated') then
        result.validatedElement := parseBoolean(jsn.node['validated'], jsn.vObj['_validated']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseString(jsn.node['description'], jsn.vObj['_description']);{q}
      if jsn.has('origin') or jsn.has('_origin') then
      iteratePrimitiveArray(jsn.vArr['origin'], jsn.vArr['_origin'], result.originList, parseInteger);
    if jsn.has('destination') or jsn.has('_destination') then
        result.destinationElement := parseInteger(jsn.node['destination'], jsn.vObj['_destination']);{q}
      if jsn.has('link') or jsn.has('_link') then
      iteratePrimitiveArray(jsn.vArr['link'], jsn.vArr['_link'], result.link_List, parseUri);
    if jsn.has('capabilities') or jsn.has('_capabilities') then
        result.capabilitiesElement := parseCanonical(jsn.node['capabilities'], jsn.vObj['_capabilities']);{q}
end;

procedure TFHIRJsonComposer.ComposeTestScriptMetadataCapability(json : TJSONWriter; name : string; elem : TFhirTestScriptMetadataCapability; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeBooleanValue(json, 'required', elem.requiredElement, false);
  ComposeBooleanProps(json, 'required', elem.requiredElement, false);
  ComposeBooleanValue(json, 'validated', elem.validatedElement, false);
  ComposeBooleanProps(json, 'validated', elem.validatedElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.originList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.originList.Count - 1 do
    begin
      ext := ext or ((elem.originList[i].id <> '') or (elem.originList[i].hasExtensionList) {no-comments or (elem.originList[i].hasComments)});
      val := val or (elem.originList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('origin');
      for i := 0 to elem.originList.Count - 1 do
        ComposeIntegerValue(json, '',elem.originList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_origin');
      for i := 0 to elem.originList.Count - 1 do
        ComposeIntegerProps(json, '',elem.originList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeIntegerValue(json, 'destination', elem.destinationElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIntegerProps(json, 'destination', elem.destinationElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.link_List.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.link_List.Count - 1 do
    begin
      ext := ext or ((elem.link_List[i].id <> '') or (elem.link_List[i].hasExtensionList) {no-comments or (elem.link_List[i].hasComments)});
      val := val or (elem.link_List[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('link');
      for i := 0 to elem.link_List.Count - 1 do
        ComposeUriValue(json, '',elem.link_List[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_link');
      for i := 0 to elem.link_List.Count - 1 do
        ComposeUriProps(json, '',elem.link_List[i], true);
      json.FinishArray;
    end;
  end;
  ComposeCanonicalValue(json, 'capabilities', elem.capabilitiesElement, false);
  ComposeCanonicalProps(json, 'capabilities', elem.capabilitiesElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseTestScriptFixture(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTestScriptFixture(jsn)); {2}
end;

function TFHIRJsonParser.ParseTestScriptFixture(jsn : TJsonObject) : TFhirTestScriptFixture;
begin
  result := TFhirTestScriptFixture.create;
  try
    ParseTestScriptFixtureProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseTestScriptFixtureProperties(jsn : TJsonObject; result : TFhirTestScriptFixture);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('autocreate') or jsn.has('_autocreate') then
        result.autocreateElement := parseBoolean(jsn.node['autocreate'], jsn.vObj['_autocreate']);{q}
    if jsn.has('autodelete') or jsn.has('_autodelete') then
        result.autodeleteElement := parseBoolean(jsn.node['autodelete'], jsn.vObj['_autodelete']);{q}
    if jsn.has('resource') then
        result.resource := ParseReference{TFhirReference}(jsn.vObj['resource']);{q3}
end;

procedure TFHIRJsonComposer.ComposeTestScriptFixture(json : TJSONWriter; name : string; elem : TFhirTestScriptFixture; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeBooleanValue(json, 'autocreate', elem.autocreateElement, false);
  ComposeBooleanProps(json, 'autocreate', elem.autocreateElement, false);
  ComposeBooleanValue(json, 'autodelete', elem.autodeleteElement, false);
  ComposeBooleanProps(json, 'autodelete', elem.autodeleteElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirReference}(json, 'resource', elem.resource); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseTestScriptVariable(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTestScriptVariable(jsn)); {2}
end;

function TFHIRJsonParser.ParseTestScriptVariable(jsn : TJsonObject) : TFhirTestScriptVariable;
begin
  result := TFhirTestScriptVariable.create;
  try
    ParseTestScriptVariableProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseTestScriptVariableProperties(jsn : TJsonObject; result : TFhirTestScriptVariable);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('defaultValue') or jsn.has('_defaultValue') then
        result.defaultValueElement := parseString(jsn.node['defaultValue'], jsn.vObj['_defaultValue']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('expression') or jsn.has('_expression') then
        result.expressionElement := parseString(jsn.node['expression'], jsn.vObj['_expression']);{q}
    if jsn.has('headerField') or jsn.has('_headerField') then
        result.headerFieldElement := parseString(jsn.node['headerField'], jsn.vObj['_headerField']);{q}
    if jsn.has('hint') or jsn.has('_hint') then
        result.hintElement := parseString(jsn.node['hint'], jsn.vObj['_hint']);{q}
    if jsn.has('path') or jsn.has('_path') then
        result.pathElement := parseString(jsn.node['path'], jsn.vObj['_path']);{q}
    if jsn.has('sourceId') or jsn.has('_sourceId') then
        result.sourceIdElement := parseId(jsn.node['sourceId'], jsn.vObj['_sourceId']);{q}
end;

procedure TFHIRJsonComposer.ComposeTestScriptVariable(json : TJSONWriter; name : string; elem : TFhirTestScriptVariable; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'name', elem.nameElement, false);
  ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'defaultValue', elem.defaultValueElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'defaultValue', elem.defaultValueElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'expression', elem.expressionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'expression', elem.expressionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'headerField', elem.headerFieldElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'headerField', elem.headerFieldElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'hint', elem.hintElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'hint', elem.hintElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'path', elem.pathElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'path', elem.pathElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdValue(json, 'sourceId', elem.sourceIdElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdProps(json, 'sourceId', elem.sourceIdElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseTestScriptSetup(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTestScriptSetup(jsn)); {2}
end;

function TFHIRJsonParser.ParseTestScriptSetup(jsn : TJsonObject) : TFhirTestScriptSetup;
begin
  result := TFhirTestScriptSetup.create;
  try
    ParseTestScriptSetupProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseTestScriptSetupProperties(jsn : TJsonObject; result : TFhirTestScriptSetup);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('action') then
      iterateArray(jsn.vArr['action'], result.actionList, parseTestScriptSetupAction);
end;

procedure TFHIRJsonComposer.ComposeTestScriptSetup(json : TJSONWriter; name : string; elem : TFhirTestScriptSetup; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (elem.actionList.Count > 0) then
  begin
    json.valueArray('action');
    for i := 0 to elem.actionList.Count - 1 do
      ComposeTestScriptSetupAction(json, '', elem.actionList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseTestScriptSetupAction(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTestScriptSetupAction(jsn)); {2}
end;

function TFHIRJsonParser.ParseTestScriptSetupAction(jsn : TJsonObject) : TFhirTestScriptSetupAction;
begin
  result := TFhirTestScriptSetupAction.create;
  try
    ParseTestScriptSetupActionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseTestScriptSetupActionProperties(jsn : TJsonObject; result : TFhirTestScriptSetupAction);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('operation') then
        result.operation := ParseTestScriptSetupActionOperation(jsn.vObj['operation']);{q3}
    if jsn.has('assert') then
        result.assert := ParseTestScriptSetupActionAssert(jsn.vObj['assert']);{q3}
end;

procedure TFHIRJsonComposer.ComposeTestScriptSetupAction(json : TJSONWriter; name : string; elem : TFhirTestScriptSetupAction; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptSetupActionOperation(json, 'operation', elem.operation); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptSetupActionAssert(json, 'assert', elem.assert); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseTestScriptSetupActionOperation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTestScriptSetupActionOperation(jsn)); {2}
end;

function TFHIRJsonParser.ParseTestScriptSetupActionOperation(jsn : TJsonObject) : TFhirTestScriptSetupActionOperation;
begin
  result := TFhirTestScriptSetupActionOperation.create;
  try
    ParseTestScriptSetupActionOperationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseTestScriptSetupActionOperationProperties(jsn : TJsonObject; result : TFhirTestScriptSetupActionOperation);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCoding(jsn.vObj['type']);{q3}
    if jsn.has('resource') or jsn.has('_resource') then
        result.resourceElement := parseCode(jsn.node['resource'], jsn.vObj['_resource']);{q}
    if jsn.has('label') or jsn.has('_label') then
        result.label_Element := parseString(jsn.node['label'], jsn.vObj['_label']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('accept') or jsn.has('_accept') then
        result.acceptElement := parseCode(jsn.node['accept'], jsn.vObj['_accept']);{q}
    if jsn.has('contentType') or jsn.has('_contentType') then
        result.contentTypeElement := parseCode(jsn.node['contentType'], jsn.vObj['_contentType']);{q}
    if jsn.has('destination') or jsn.has('_destination') then
        result.destinationElement := parseInteger(jsn.node['destination'], jsn.vObj['_destination']);{q}
    if jsn.has('encodeRequestUrl') or jsn.has('_encodeRequestUrl') then
        result.encodeRequestUrlElement := parseBoolean(jsn.node['encodeRequestUrl'], jsn.vObj['_encodeRequestUrl']);{q}
    if jsn.has('method') or jsn.has('_method')  then
      result.methodElement := parseEnum(jsn.path+'/method', jsn.node['method'], jsn.vObj['_method'], CODES_TFhirHttpOperationsEnum, SYSTEMS_TFhirHttpOperationsEnum);
    if jsn.has('origin') or jsn.has('_origin') then
        result.originElement := parseInteger(jsn.node['origin'], jsn.vObj['_origin']);{q}
    if jsn.has('params') or jsn.has('_params') then
        result.paramsElement := parseString(jsn.node['params'], jsn.vObj['_params']);{q}
    if jsn.has('requestHeader') then
      iterateArray(jsn.vArr['requestHeader'], result.requestHeaderList, parseTestScriptSetupActionOperationRequestHeader);
    if jsn.has('requestId') or jsn.has('_requestId') then
        result.requestIdElement := parseId(jsn.node['requestId'], jsn.vObj['_requestId']);{q}
    if jsn.has('responseId') or jsn.has('_responseId') then
        result.responseIdElement := parseId(jsn.node['responseId'], jsn.vObj['_responseId']);{q}
    if jsn.has('sourceId') or jsn.has('_sourceId') then
        result.sourceIdElement := parseId(jsn.node['sourceId'], jsn.vObj['_sourceId']);{q}
    if jsn.has('targetId') or jsn.has('_targetId') then
        result.targetIdElement := parseId(jsn.node['targetId'], jsn.vObj['_targetId']);{q}
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := parseString(jsn.node['url'], jsn.vObj['_url']);{q}
end;

procedure TFHIRJsonComposer.ComposeTestScriptSetupActionOperation(json : TJSONWriter; name : string; elem : TFhirTestScriptSetupActionOperation; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeValue(json, 'resource', elem.resourceElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeProps(json, 'resource', elem.resourceElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'label', elem.label_Element, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'label', elem.label_Element, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeValue(json, 'accept', elem.acceptElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeProps(json, 'accept', elem.acceptElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeValue(json, 'contentType', elem.contentTypeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeProps(json, 'contentType', elem.contentTypeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIntegerValue(json, 'destination', elem.destinationElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIntegerProps(json, 'destination', elem.destinationElement, false);
  ComposeBooleanValue(json, 'encodeRequestUrl', elem.encodeRequestUrlElement, false);
  ComposeBooleanProps(json, 'encodeRequestUrl', elem.encodeRequestUrlElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumValue(json, 'method', elem.MethodElement, CODES_TFhirHttpOperationsEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumProps(json, 'method', elem.MethodElement, CODES_TFhirHttpOperationsEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIntegerValue(json, 'origin', elem.originElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIntegerProps(json, 'origin', elem.originElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'params', elem.paramsElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'params', elem.paramsElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.requestHeaderList.Count > 0) then
  begin
    json.valueArray('requestHeader');
    for i := 0 to elem.requestHeaderList.Count - 1 do
      ComposeTestScriptSetupActionOperationRequestHeader(json, '', elem.requestHeaderList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeIdValue(json, 'requestId', elem.requestIdElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdProps(json, 'requestId', elem.requestIdElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdValue(json, 'responseId', elem.responseIdElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdProps(json, 'responseId', elem.responseIdElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdValue(json, 'sourceId', elem.sourceIdElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdProps(json, 'sourceId', elem.sourceIdElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdValue(json, 'targetId', elem.targetIdElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdProps(json, 'targetId', elem.targetIdElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'url', elem.urlElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseTestScriptSetupActionOperationRequestHeader(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTestScriptSetupActionOperationRequestHeader(jsn)); {2}
end;

function TFHIRJsonParser.ParseTestScriptSetupActionOperationRequestHeader(jsn : TJsonObject) : TFhirTestScriptSetupActionOperationRequestHeader;
begin
  result := TFhirTestScriptSetupActionOperationRequestHeader.create;
  try
    ParseTestScriptSetupActionOperationRequestHeaderProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseTestScriptSetupActionOperationRequestHeaderProperties(jsn : TJsonObject; result : TFhirTestScriptSetupActionOperationRequestHeader);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('field') or jsn.has('_field') then
        result.fieldElement := parseString(jsn.node['field'], jsn.vObj['_field']);{q}
    if jsn.has('value') or jsn.has('_value') then
        result.valueElement := parseString(jsn.node['value'], jsn.vObj['_value']);{q}
end;

procedure TFHIRJsonComposer.ComposeTestScriptSetupActionOperationRequestHeader(json : TJSONWriter; name : string; elem : TFhirTestScriptSetupActionOperationRequestHeader; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'field', elem.fieldElement, false);
  ComposeStringProps(json, 'field', elem.fieldElement, false);
  ComposeStringValue(json, 'value', elem.valueElement, false);
  ComposeStringProps(json, 'value', elem.valueElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseTestScriptSetupActionAssert(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTestScriptSetupActionAssert(jsn)); {2}
end;

function TFHIRJsonParser.ParseTestScriptSetupActionAssert(jsn : TJsonObject) : TFhirTestScriptSetupActionAssert;
begin
  result := TFhirTestScriptSetupActionAssert.create;
  try
    ParseTestScriptSetupActionAssertProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseTestScriptSetupActionAssertProperties(jsn : TJsonObject; result : TFhirTestScriptSetupActionAssert);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('label') or jsn.has('_label') then
        result.label_Element := parseString(jsn.node['label'], jsn.vObj['_label']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('direction') or jsn.has('_direction')  then
      result.directionElement := parseEnum(jsn.path+'/direction', jsn.node['direction'], jsn.vObj['_direction'], CODES_TFhirAssertDirectionCodesEnum, SYSTEMS_TFhirAssertDirectionCodesEnum);
    if jsn.has('compareToSourceId') or jsn.has('_compareToSourceId') then
        result.compareToSourceIdElement := parseString(jsn.node['compareToSourceId'], jsn.vObj['_compareToSourceId']);{q}
    if jsn.has('compareToSourceExpression') or jsn.has('_compareToSourceExpression') then
        result.compareToSourceExpressionElement := parseString(jsn.node['compareToSourceExpression'], jsn.vObj['_compareToSourceExpression']);{q}
    if jsn.has('compareToSourcePath') or jsn.has('_compareToSourcePath') then
        result.compareToSourcePathElement := parseString(jsn.node['compareToSourcePath'], jsn.vObj['_compareToSourcePath']);{q}
    if jsn.has('contentType') or jsn.has('_contentType') then
        result.contentTypeElement := parseCode(jsn.node['contentType'], jsn.vObj['_contentType']);{q}
    if jsn.has('expression') or jsn.has('_expression') then
        result.expressionElement := parseString(jsn.node['expression'], jsn.vObj['_expression']);{q}
    if jsn.has('headerField') or jsn.has('_headerField') then
        result.headerFieldElement := parseString(jsn.node['headerField'], jsn.vObj['_headerField']);{q}
    if jsn.has('minimumId') or jsn.has('_minimumId') then
        result.minimumIdElement := parseString(jsn.node['minimumId'], jsn.vObj['_minimumId']);{q}
    if jsn.has('navigationLinks') or jsn.has('_navigationLinks') then
        result.navigationLinksElement := parseBoolean(jsn.node['navigationLinks'], jsn.vObj['_navigationLinks']);{q}
    if jsn.has('operator') or jsn.has('_operator')  then
      result.operatorElement := parseEnum(jsn.path+'/operator', jsn.node['operator'], jsn.vObj['_operator'], CODES_TFhirAssertOperatorCodesEnum, SYSTEMS_TFhirAssertOperatorCodesEnum);
    if jsn.has('path') or jsn.has('_path') then
        result.pathElement := parseString(jsn.node['path'], jsn.vObj['_path']);{q}
    if jsn.has('requestMethod') or jsn.has('_requestMethod')  then
      result.requestMethodElement := parseEnum(jsn.path+'/requestMethod', jsn.node['requestMethod'], jsn.vObj['_requestMethod'], CODES_TFhirHttpOperationsEnum, SYSTEMS_TFhirHttpOperationsEnum);
    if jsn.has('requestURL') or jsn.has('_requestURL') then
        result.requestURLElement := parseString(jsn.node['requestURL'], jsn.vObj['_requestURL']);{q}
    if jsn.has('resource') or jsn.has('_resource') then
        result.resourceElement := parseCode(jsn.node['resource'], jsn.vObj['_resource']);{q}
    if jsn.has('response') or jsn.has('_response')  then
      result.responseElement := parseEnum(jsn.path+'/response', jsn.node['response'], jsn.vObj['_response'], CODES_TFhirAssertResponseCodeTypesEnum, SYSTEMS_TFhirAssertResponseCodeTypesEnum);
    if jsn.has('responseCode') or jsn.has('_responseCode') then
        result.responseCodeElement := parseString(jsn.node['responseCode'], jsn.vObj['_responseCode']);{q}
    if jsn.has('sourceId') or jsn.has('_sourceId') then
        result.sourceIdElement := parseId(jsn.node['sourceId'], jsn.vObj['_sourceId']);{q}
    if jsn.has('validateProfileId') or jsn.has('_validateProfileId') then
        result.validateProfileIdElement := parseId(jsn.node['validateProfileId'], jsn.vObj['_validateProfileId']);{q}
    if jsn.has('value') or jsn.has('_value') then
        result.valueElement := parseString(jsn.node['value'], jsn.vObj['_value']);{q}
    if jsn.has('warningOnly') or jsn.has('_warningOnly') then
        result.warningOnlyElement := parseBoolean(jsn.node['warningOnly'], jsn.vObj['_warningOnly']);{q}
end;

procedure TFHIRJsonComposer.ComposeTestScriptSetupActionAssert(json : TJSONWriter; name : string; elem : TFhirTestScriptSetupActionAssert; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'label', elem.label_Element, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'label', elem.label_Element, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumValue(json, 'direction', elem.DirectionElement, CODES_TFhirAssertDirectionCodesEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumProps(json, 'direction', elem.DirectionElement, CODES_TFhirAssertDirectionCodesEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'compareToSourceId', elem.compareToSourceIdElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'compareToSourceId', elem.compareToSourceIdElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'compareToSourceExpression', elem.compareToSourceExpressionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'compareToSourceExpression', elem.compareToSourceExpressionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'compareToSourcePath', elem.compareToSourcePathElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'compareToSourcePath', elem.compareToSourcePathElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeValue(json, 'contentType', elem.contentTypeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeProps(json, 'contentType', elem.contentTypeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'expression', elem.expressionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'expression', elem.expressionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'headerField', elem.headerFieldElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'headerField', elem.headerFieldElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'minimumId', elem.minimumIdElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'minimumId', elem.minimumIdElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'navigationLinks', elem.navigationLinksElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'navigationLinks', elem.navigationLinksElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumValue(json, 'operator', elem.OperatorElement, CODES_TFhirAssertOperatorCodesEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumProps(json, 'operator', elem.OperatorElement, CODES_TFhirAssertOperatorCodesEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'path', elem.pathElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'path', elem.pathElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumValue(json, 'requestMethod', elem.RequestMethodElement, CODES_TFhirHttpOperationsEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumProps(json, 'requestMethod', elem.RequestMethodElement, CODES_TFhirHttpOperationsEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'requestURL', elem.requestURLElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'requestURL', elem.requestURLElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeValue(json, 'resource', elem.resourceElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeProps(json, 'resource', elem.resourceElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumValue(json, 'response', elem.ResponseElement, CODES_TFhirAssertResponseCodeTypesEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumProps(json, 'response', elem.ResponseElement, CODES_TFhirAssertResponseCodeTypesEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'responseCode', elem.responseCodeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'responseCode', elem.responseCodeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdValue(json, 'sourceId', elem.sourceIdElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdProps(json, 'sourceId', elem.sourceIdElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdValue(json, 'validateProfileId', elem.validateProfileIdElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdProps(json, 'validateProfileId', elem.validateProfileIdElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'value', elem.valueElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'value', elem.valueElement, false);
  ComposeBooleanValue(json, 'warningOnly', elem.warningOnlyElement, false);
  ComposeBooleanProps(json, 'warningOnly', elem.warningOnlyElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseTestScriptTest(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTestScriptTest(jsn)); {2}
end;

function TFHIRJsonParser.ParseTestScriptTest(jsn : TJsonObject) : TFhirTestScriptTest;
begin
  result := TFhirTestScriptTest.create;
  try
    ParseTestScriptTestProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseTestScriptTestProperties(jsn : TJsonObject; result : TFhirTestScriptTest);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('action') then
      iterateArray(jsn.vArr['action'], result.actionList, parseTestScriptTestAction);
end;

procedure TFHIRJsonComposer.ComposeTestScriptTest(json : TJSONWriter; name : string; elem : TFhirTestScriptTest; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (elem.actionList.Count > 0) then
  begin
    json.valueArray('action');
    for i := 0 to elem.actionList.Count - 1 do
      ComposeTestScriptTestAction(json, '', elem.actionList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseTestScriptTestAction(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTestScriptTestAction(jsn)); {2}
end;

function TFHIRJsonParser.ParseTestScriptTestAction(jsn : TJsonObject) : TFhirTestScriptTestAction;
begin
  result := TFhirTestScriptTestAction.create;
  try
    ParseTestScriptTestActionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseTestScriptTestActionProperties(jsn : TJsonObject; result : TFhirTestScriptTestAction);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('operation') then
        result.operation := ParseTestScriptSetupActionOperation(jsn.vObj['operation']);{q3}
    if jsn.has('assert') then
        result.assert := ParseTestScriptSetupActionAssert(jsn.vObj['assert']);{q3}
end;

procedure TFHIRJsonComposer.ComposeTestScriptTestAction(json : TJSONWriter; name : string; elem : TFhirTestScriptTestAction; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptSetupActionOperation(json, 'operation', elem.operation); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptSetupActionAssert(json, 'assert', elem.assert); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseTestScriptTeardown(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTestScriptTeardown(jsn)); {2}
end;

function TFHIRJsonParser.ParseTestScriptTeardown(jsn : TJsonObject) : TFhirTestScriptTeardown;
begin
  result := TFhirTestScriptTeardown.create;
  try
    ParseTestScriptTeardownProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseTestScriptTeardownProperties(jsn : TJsonObject; result : TFhirTestScriptTeardown);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('action') then
      iterateArray(jsn.vArr['action'], result.actionList, parseTestScriptTeardownAction);
end;

procedure TFHIRJsonComposer.ComposeTestScriptTeardown(json : TJSONWriter; name : string; elem : TFhirTestScriptTeardown; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (elem.actionList.Count > 0) then
  begin
    json.valueArray('action');
    for i := 0 to elem.actionList.Count - 1 do
      ComposeTestScriptTeardownAction(json, '', elem.actionList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseTestScriptTeardownAction(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTestScriptTeardownAction(jsn)); {2}
end;

function TFHIRJsonParser.ParseTestScriptTeardownAction(jsn : TJsonObject) : TFhirTestScriptTeardownAction;
begin
  result := TFhirTestScriptTeardownAction.create;
  try
    ParseTestScriptTeardownActionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseTestScriptTeardownActionProperties(jsn : TJsonObject; result : TFhirTestScriptTeardownAction);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('operation') then
        result.operation := ParseTestScriptSetupActionOperation(jsn.vObj['operation']);{q3}
end;

procedure TFHIRJsonComposer.ComposeTestScriptTeardownAction(json : TJSONWriter; name : string; elem : TFhirTestScriptTeardownAction; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeTestScriptSetupActionOperation(json, 'operation', elem.operation); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseTestScript(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTestScript(jsn)); {2}
end;

function TFHIRJsonParser.ParseTestScript(jsn : TJsonObject) : TFhirTestScript;
begin
  result := TFhirTestScript.create;
  try
    ParseTestScriptProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseTestScriptProperties(jsn : TJsonObject; result : TFhirTestScript);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := parseUri(jsn.node['url'], jsn.vObj['_url']);{q}
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q3}
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := parseString(jsn.node['version'], jsn.vObj['_version']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('title') or jsn.has('_title') then
        result.titleElement := parseString(jsn.node['title'], jsn.vObj['_title']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    if jsn.has('experimental') or jsn.has('_experimental') then
        result.experimentalElement := parseBoolean(jsn.node['experimental'], jsn.vObj['_experimental']);{q}
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := parseDateTime(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('publisher') or jsn.has('_publisher') then
        result.publisherElement := parseString(jsn.node['publisher'], jsn.vObj['_publisher']);{q}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseContactDetail);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseMarkdown(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('useContext') then
      iterateArray(jsn.vArr['useContext'], result.useContextList, parseUsageContext);
    if jsn.has('jurisdiction') then
      iterateArray(jsn.vArr['jurisdiction'], result.jurisdictionList, parseCodeableConcept);
    if jsn.has('purpose') or jsn.has('_purpose') then
        result.purposeElement := parseMarkdown(jsn.node['purpose'], jsn.vObj['_purpose']);{q}
    if jsn.has('copyright') or jsn.has('_copyright') then
        result.copyrightElement := parseMarkdown(jsn.node['copyright'], jsn.vObj['_copyright']);{q}
    if jsn.has('origin') then
      iterateArray(jsn.vArr['origin'], result.originList, parseTestScriptOrigin);
    if jsn.has('destination') then
      iterateArray(jsn.vArr['destination'], result.destinationList, parseTestScriptDestination);
    if jsn.has('metadata') then
        result.metadata := ParseTestScriptMetadata(jsn.vObj['metadata']);{q3}
    if jsn.has('fixture') then
      iterateArray(jsn.vArr['fixture'], result.fixtureList, parseTestScriptFixture);
    if jsn.has('profile') then
      iterateArray(jsn.vArr['profile'], result.profileList, parseReference{TFhirReference});
    if jsn.has('variable') then
      iterateArray(jsn.vArr['variable'], result.variableList, parseTestScriptVariable);
    if jsn.has('setup') then
        result.setup := ParseTestScriptSetup(jsn.vObj['setup']);{q3}
    if jsn.has('test') then
      iterateArray(jsn.vArr['test'], result.testList, parseTestScriptTest);
    if jsn.has('teardown') then
        result.teardown := ParseTestScriptTeardown(jsn.vObj['teardown']);{q3}
end;

procedure TFHIRJsonComposer.ComposeTestScript(json : TJSONWriter; name : string; elem : TFhirTestScript; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  ComposeUriValue(json, 'url', elem.urlElement, false);
  ComposeUriProps(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeStringValue(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeStringProps(json, 'version', elem.versionElement, false);
  ComposeStringValue(json, 'name', elem.nameElement, false);
  ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeStringValue(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeStringProps(json, 'title', elem.titleElement, false);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBooleanValue(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBooleanProps(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringValue(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringProps(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') and (elem.contactList.Count > 0) then
  begin
    json.valueArray('contact');
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(json, '', elem.contactList[i]); {z - ContactDetail}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdownValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdownProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') and (elem.useContextList.Count > 0) then
  begin
    json.valueArray('useContext');
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(json, '', elem.useContextList[i]); {z - UsageContext}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') and (elem.jurisdictionList.Count > 0) then
  begin
    json.valueArray('jurisdiction');
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.jurisdictionList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdownValue(json, 'purpose', elem.purposeElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdownProps(json, 'purpose', elem.purposeElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdownValue(json, 'copyright', elem.copyrightElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdownProps(json, 'copyright', elem.copyrightElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('origin') and (elem.originList.Count > 0) then
  begin
    json.valueArray('origin');
    for i := 0 to elem.originList.Count - 1 do
      ComposeTestScriptOrigin(json, '', elem.originList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('destination') and (elem.destinationList.Count > 0) then
  begin
    json.valueArray('destination');
    for i := 0 to elem.destinationList.Count - 1 do
      ComposeTestScriptDestination(json, '', elem.destinationList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('metadata') then
    ComposeTestScriptMetadata(json, 'metadata', elem.metadata); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('fixture') and (elem.fixtureList.Count > 0) then
  begin
    json.valueArray('fixture');
    for i := 0 to elem.fixtureList.Count - 1 do
      ComposeTestScriptFixture(json, '', elem.fixtureList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('profile') and (elem.profileList.Count > 0) then
  begin
    json.valueArray('profile');
    for i := 0 to elem.profileList.Count - 1 do
      ComposeReference{TFhirReference}(json, '', elem.profileList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('variable') and (elem.variableList.Count > 0) then
  begin
    json.valueArray('variable');
    for i := 0 to elem.variableList.Count - 1 do
      ComposeTestScriptVariable(json, '', elem.variableList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('setup') then
    ComposeTestScriptSetup(json, 'setup', elem.setup); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('test') and (elem.testList.Count > 0) then
  begin
    json.valueArray('test');
    for i := 0 to elem.testList.Count - 1 do
      ComposeTestScriptTest(json, '', elem.testList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('teardown') then
    ComposeTestScriptTeardown(json, 'teardown', elem.teardown); {a}
end;

{$ENDIF FHIR_TESTSCRIPT}
{$IFDEF FHIR_VALUESET}
procedure TFHIRJsonParser.ParseValueSetCompose(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseValueSetCompose(jsn)); {2}
end;

function TFHIRJsonParser.ParseValueSetCompose(jsn : TJsonObject) : TFhirValueSetCompose;
begin
  result := TFhirValueSetCompose.create;
  try
    ParseValueSetComposeProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseValueSetComposeProperties(jsn : TJsonObject; result : TFhirValueSetCompose);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('lockedDate') or jsn.has('_lockedDate') then
        result.lockedDateElement := parseDate(jsn.node['lockedDate'], jsn.vObj['_lockedDate']);{q}
    if jsn.has('inactive') or jsn.has('_inactive') then
        result.inactiveElement := parseBoolean(jsn.node['inactive'], jsn.vObj['_inactive']);{q}
    if jsn.has('include') then
      iterateArray(jsn.vArr['include'], result.includeList, parseValueSetComposeInclude);
    if jsn.has('exclude') then
      iterateArray(jsn.vArr['exclude'], result.excludeList, parseValueSetComposeInclude);
end;

procedure TFHIRJsonComposer.ComposeValueSetCompose(json : TJSONWriter; name : string; elem : TFhirValueSetCompose; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateValue(json, 'lockedDate', elem.lockedDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateProps(json, 'lockedDate', elem.lockedDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBooleanValue(json, 'inactive', elem.inactiveElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBooleanProps(json, 'inactive', elem.inactiveElement, false);
  if (elem.includeList.Count > 0) then
  begin
    json.valueArray('include');
    for i := 0 to elem.includeList.Count - 1 do
      ComposeValueSetComposeInclude(json, '', elem.includeList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.excludeList.Count > 0) then
  begin
    json.valueArray('exclude');
    for i := 0 to elem.excludeList.Count - 1 do
      ComposeValueSetComposeInclude(json, '', elem.excludeList[i]); {z - @ValueSet.compose.include}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseValueSetComposeInclude(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseValueSetComposeInclude(jsn)); {2}
end;

function TFHIRJsonParser.ParseValueSetComposeInclude(jsn : TJsonObject) : TFhirValueSetComposeInclude;
begin
  result := TFhirValueSetComposeInclude.create;
  try
    ParseValueSetComposeIncludeProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseValueSetComposeIncludeProperties(jsn : TJsonObject; result : TFhirValueSetComposeInclude);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('system') or jsn.has('_system') then
        result.systemElement := parseUri(jsn.node['system'], jsn.vObj['_system']);{q}
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := parseString(jsn.node['version'], jsn.vObj['_version']);{q}
    if jsn.has('concept') then
      iterateArray(jsn.vArr['concept'], result.conceptList, parseValueSetComposeIncludeConcept);
    if jsn.has('filter') then
      iterateArray(jsn.vArr['filter'], result.filterList, parseValueSetComposeIncludeFilter);
      if jsn.has('valueSet') or jsn.has('_valueSet') then
      iteratePrimitiveArray(jsn.vArr['valueSet'], jsn.vArr['_valueSet'], result.valueSetList, parseCanonical);
end;

procedure TFHIRJsonComposer.ComposeValueSetComposeInclude(json : TJSONWriter; name : string; elem : TFhirValueSetComposeInclude; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUriValue(json, 'system', elem.systemElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUriProps(json, 'system', elem.systemElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.conceptList.Count > 0) then
  begin
    json.valueArray('concept');
    for i := 0 to elem.conceptList.Count - 1 do
      ComposeValueSetComposeIncludeConcept(json, '', elem.conceptList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.filterList.Count > 0) then
  begin
    json.valueArray('filter');
    for i := 0 to elem.filterList.Count - 1 do
      ComposeValueSetComposeIncludeFilter(json, '', elem.filterList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.valueSetList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.valueSetList.Count - 1 do
    begin
      ext := ext or ((elem.valueSetList[i].id <> '') or (elem.valueSetList[i].hasExtensionList) {no-comments or (elem.valueSetList[i].hasComments)});
      val := val or (elem.valueSetList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('valueSet');
      for i := 0 to elem.valueSetList.Count - 1 do
        ComposeCanonicalValue(json, '',elem.valueSetList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_valueSet');
      for i := 0 to elem.valueSetList.Count - 1 do
        ComposeCanonicalProps(json, '',elem.valueSetList[i], true);
      json.FinishArray;
    end;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseValueSetComposeIncludeConcept(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseValueSetComposeIncludeConcept(jsn)); {2}
end;

function TFHIRJsonParser.ParseValueSetComposeIncludeConcept(jsn : TJsonObject) : TFhirValueSetComposeIncludeConcept;
begin
  result := TFhirValueSetComposeIncludeConcept.create;
  try
    ParseValueSetComposeIncludeConceptProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseValueSetComposeIncludeConceptProperties(jsn : TJsonObject; result : TFhirValueSetComposeIncludeConcept);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') or jsn.has('_code') then
        result.codeElement := parseCode(jsn.node['code'], jsn.vObj['_code']);{q}
    if jsn.has('display') or jsn.has('_display') then
        result.displayElement := parseString(jsn.node['display'], jsn.vObj['_display']);{q}
    if jsn.has('designation') then
      iterateArray(jsn.vArr['designation'], result.designationList, parseValueSetComposeIncludeConceptDesignation);
end;

procedure TFHIRJsonComposer.ComposeValueSetComposeIncludeConcept(json : TJSONWriter; name : string; elem : TFhirValueSetComposeIncludeConcept; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeValue(json, 'code', elem.codeElement, false);
  ComposeCodeProps(json, 'code', elem.codeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'display', elem.displayElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'display', elem.displayElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.designationList.Count > 0) then
  begin
    json.valueArray('designation');
    for i := 0 to elem.designationList.Count - 1 do
      ComposeValueSetComposeIncludeConceptDesignation(json, '', elem.designationList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseValueSetComposeIncludeConceptDesignation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseValueSetComposeIncludeConceptDesignation(jsn)); {2}
end;

function TFHIRJsonParser.ParseValueSetComposeIncludeConceptDesignation(jsn : TJsonObject) : TFhirValueSetComposeIncludeConceptDesignation;
begin
  result := TFhirValueSetComposeIncludeConceptDesignation.create;
  try
    ParseValueSetComposeIncludeConceptDesignationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseValueSetComposeIncludeConceptDesignationProperties(jsn : TJsonObject; result : TFhirValueSetComposeIncludeConceptDesignation);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('language') or jsn.has('_language') then
        result.languageElement := parseCode(jsn.node['language'], jsn.vObj['_language']);{q}
    if jsn.has('use') then
        result.use := ParseCoding(jsn.vObj['use']);{q3}
    if jsn.has('value') or jsn.has('_value') then
        result.valueElement := parseString(jsn.node['value'], jsn.vObj['_value']);{q}
end;

procedure TFHIRJsonComposer.ComposeValueSetComposeIncludeConceptDesignation(json : TJSONWriter; name : string; elem : TFhirValueSetComposeIncludeConceptDesignation; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeValue(json, 'language', elem.languageElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeProps(json, 'language', elem.languageElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(json, 'use', elem.use); {a}
  ComposeStringValue(json, 'value', elem.valueElement, false);
  ComposeStringProps(json, 'value', elem.valueElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseValueSetComposeIncludeFilter(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseValueSetComposeIncludeFilter(jsn)); {2}
end;

function TFHIRJsonParser.ParseValueSetComposeIncludeFilter(jsn : TJsonObject) : TFhirValueSetComposeIncludeFilter;
begin
  result := TFhirValueSetComposeIncludeFilter.create;
  try
    ParseValueSetComposeIncludeFilterProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseValueSetComposeIncludeFilterProperties(jsn : TJsonObject; result : TFhirValueSetComposeIncludeFilter);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('property') or jsn.has('_property') then
        result.property_Element := parseCode(jsn.node['property'], jsn.vObj['_property']);{q}
    if jsn.has('op') or jsn.has('_op')  then
      result.opElement := parseEnum(jsn.path+'/op', jsn.node['op'], jsn.vObj['_op'], CODES_TFhirFilterOperatorEnum, SYSTEMS_TFhirFilterOperatorEnum);
    if jsn.has('value') or jsn.has('_value') then
        result.valueElement := parseString(jsn.node['value'], jsn.vObj['_value']);{q}
end;

procedure TFHIRJsonComposer.ComposeValueSetComposeIncludeFilter(json : TJSONWriter; name : string; elem : TFhirValueSetComposeIncludeFilter; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeValue(json, 'property', elem.property_Element, false);
  ComposeCodeProps(json, 'property', elem.property_Element, false);
  ComposeEnumValue(json, 'op', elem.OpElement, CODES_TFhirFilterOperatorEnum, false);
  ComposeEnumProps(json, 'op', elem.OpElement, CODES_TFhirFilterOperatorEnum, false);
  ComposeStringValue(json, 'value', elem.valueElement, false);
  ComposeStringProps(json, 'value', elem.valueElement, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseValueSetExpansion(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseValueSetExpansion(jsn)); {2}
end;

function TFHIRJsonParser.ParseValueSetExpansion(jsn : TJsonObject) : TFhirValueSetExpansion;
begin
  result := TFhirValueSetExpansion.create;
  try
    ParseValueSetExpansionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseValueSetExpansionProperties(jsn : TJsonObject; result : TFhirValueSetExpansion);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identifier') or jsn.has('_identifier') then
        result.identifierElement := parseUri(jsn.node['identifier'], jsn.vObj['_identifier']);{q}
    if jsn.has('timestamp') or jsn.has('_timestamp') then
        result.timestampElement := parseDateTime(jsn.node['timestamp'], jsn.vObj['_timestamp']);{q}
    if jsn.has('total') or jsn.has('_total') then
        result.totalElement := parseInteger(jsn.node['total'], jsn.vObj['_total']);{q}
    if jsn.has('offset') or jsn.has('_offset') then
        result.offsetElement := parseInteger(jsn.node['offset'], jsn.vObj['_offset']);{q}
    if jsn.has('parameter') then
      iterateArray(jsn.vArr['parameter'], result.parameterList, parseValueSetExpansionParameter);
    if jsn.has('contains') then
      iterateArray(jsn.vArr['contains'], result.containsList, parseValueSetExpansionContains);
end;

procedure TFHIRJsonComposer.ComposeValueSetExpansion(json : TJSONWriter; name : string; elem : TFhirValueSetExpansion; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeUriValue(json, 'identifier', elem.identifierElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeUriProps(json, 'identifier', elem.identifierElement, false);
  ComposeDateTimeValue(json, 'timestamp', elem.timestampElement, false);
  ComposeDateTimeProps(json, 'timestamp', elem.timestampElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIntegerValue(json, 'total', elem.totalElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIntegerProps(json, 'total', elem.totalElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIntegerValue(json, 'offset', elem.offsetElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIntegerProps(json, 'offset', elem.offsetElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.parameterList.Count > 0) then
  begin
    json.valueArray('parameter');
    for i := 0 to elem.parameterList.Count - 1 do
      ComposeValueSetExpansionParameter(json, '', elem.parameterList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.containsList.Count > 0) then
  begin
    json.valueArray('contains');
    for i := 0 to elem.containsList.Count - 1 do
      ComposeValueSetExpansionContains(json, '', elem.containsList[i]); {z - }
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseValueSetExpansionParameter(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseValueSetExpansionParameter(jsn)); {2}
end;

function TFHIRJsonParser.ParseValueSetExpansionParameter(jsn : TJsonObject) : TFhirValueSetExpansionParameter;
begin
  result := TFhirValueSetExpansionParameter.create;
  try
    ParseValueSetExpansionParameterProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseValueSetExpansionParameterProperties(jsn : TJsonObject; result : TFhirValueSetExpansionParameter);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('valueCode') or jsn.has('_valueCode') then
      result.value := parseCode(jsn.node['valueCode'], jsn.vObj['_valueCode']);
    if jsn.has('valueString') or jsn.has('_valueString') then
      result.value := parseString(jsn.node['valueString'], jsn.vObj['_valueString']);
    if jsn.has('valueBoolean') or jsn.has('_valueBoolean') then
      result.value := parseBoolean(jsn.node['valueBoolean'], jsn.vObj['_valueBoolean']);
    if jsn.has('valueInteger') or jsn.has('_valueInteger') then
      result.value := parseInteger(jsn.node['valueInteger'], jsn.vObj['_valueInteger']);
    if jsn.has('valueDecimal') or jsn.has('_valueDecimal') then
      result.value := parseDecimal(jsn.node['valueDecimal'], jsn.vObj['_valueDecimal']);
    if jsn.has('valueUri') or jsn.has('_valueUri') then
      result.value := parseUri(jsn.node['valueUri'], jsn.vObj['_valueUri']);
    if jsn.has('valueDateTime') or jsn.has('_valueDateTime') then
      result.value := parseDateTime(jsn.node['valueDateTime'], jsn.vObj['_valueDateTime']);
end;

procedure TFHIRJsonComposer.ComposeValueSetExpansionParameter(json : TJSONWriter; name : string; elem : TFhirValueSetExpansionParameter; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'name', elem.nameElement, false);
  ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.value is TFhirCode) then 
  begin
    ComposeCodeValue(json, 'valueCode', TFhirCode(elem.value), false);
    ComposeCodeProps(json, 'valueCode', TFhirCode(elem.value), false);
  end
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirString) then 
  begin
    ComposeStringValue(json, 'valueString', TFhirString(elem.value), false);
    ComposeStringProps(json, 'valueString', TFhirString(elem.value), false);
  end
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'valueBoolean', TFhirBoolean(elem.value), false);
    ComposeBooleanProps(json, 'valueBoolean', TFhirBoolean(elem.value), false);
  end
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirInteger) then 
  begin
    ComposeIntegerValue(json, 'valueInteger', TFhirInteger(elem.value), false);
    ComposeIntegerProps(json, 'valueInteger', TFhirInteger(elem.value), false);
  end
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirDecimal) then 
  begin
    ComposeDecimalValue(json, 'valueDecimal', TFhirDecimal(elem.value), false);
    ComposeDecimalProps(json, 'valueDecimal', TFhirDecimal(elem.value), false);
  end
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirUri) then 
  begin
    ComposeUriValue(json, 'valueUri', TFhirUri(elem.value), false);
    ComposeUriProps(json, 'valueUri', TFhirUri(elem.value), false);
  end
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'valueDateTime', TFhirDateTime(elem.value), false);
    ComposeDateTimeProps(json, 'valueDateTime', TFhirDateTime(elem.value), false);
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseValueSetExpansionContains(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseValueSetExpansionContains(jsn)); {2}
end;

function TFHIRJsonParser.ParseValueSetExpansionContains(jsn : TJsonObject) : TFhirValueSetExpansionContains;
begin
  result := TFhirValueSetExpansionContains.create;
  try
    ParseValueSetExpansionContainsProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseValueSetExpansionContainsProperties(jsn : TJsonObject; result : TFhirValueSetExpansionContains);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('system') or jsn.has('_system') then
        result.systemElement := parseUri(jsn.node['system'], jsn.vObj['_system']);{q}
    if jsn.has('abstract') or jsn.has('_abstract') then
        result.abstractElement := parseBoolean(jsn.node['abstract'], jsn.vObj['_abstract']);{q}
    if jsn.has('inactive') or jsn.has('_inactive') then
        result.inactiveElement := parseBoolean(jsn.node['inactive'], jsn.vObj['_inactive']);{q}
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := parseString(jsn.node['version'], jsn.vObj['_version']);{q}
    if jsn.has('code') or jsn.has('_code') then
        result.codeElement := parseCode(jsn.node['code'], jsn.vObj['_code']);{q}
    if jsn.has('display') or jsn.has('_display') then
        result.displayElement := parseString(jsn.node['display'], jsn.vObj['_display']);{q}
    if jsn.has('designation') then
      iterateArray(jsn.vArr['designation'], result.designationList, parseValueSetComposeIncludeConceptDesignation);
    if jsn.has('contains') then
      iterateArray(jsn.vArr['contains'], result.containsList, parseValueSetExpansionContains);
end;

procedure TFHIRJsonComposer.ComposeValueSetExpansionContains(json : TJSONWriter; name : string; elem : TFhirValueSetExpansionContains; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeUriValue(json, 'system', elem.systemElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeUriProps(json, 'system', elem.systemElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'abstract', elem.abstractElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'abstract', elem.abstractElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'inactive', elem.inactiveElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'inactive', elem.inactiveElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeValue(json, 'code', elem.codeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeProps(json, 'code', elem.codeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'display', elem.displayElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'display', elem.displayElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.designationList.Count > 0) then
  begin
    json.valueArray('designation');
    for i := 0 to elem.designationList.Count - 1 do
      ComposeValueSetComposeIncludeConceptDesignation(json, '', elem.designationList[i]); {z - @ValueSet.compose.include.concept.designation}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.containsList.Count > 0) then
  begin
    json.valueArray('contains');
    for i := 0 to elem.containsList.Count - 1 do
      ComposeValueSetExpansionContains(json, '', elem.containsList[i]); {z - @ValueSet.expansion.contains}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseValueSet(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseValueSet(jsn)); {2}
end;

function TFHIRJsonParser.ParseValueSet(jsn : TJsonObject) : TFhirValueSet;
begin
  result := TFhirValueSet.create;
  try
    ParseValueSetProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseValueSetProperties(jsn : TJsonObject; result : TFhirValueSet);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := parseUri(jsn.node['url'], jsn.vObj['_url']);{q}
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := parseString(jsn.node['version'], jsn.vObj['_version']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := parseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('title') or jsn.has('_title') then
        result.titleElement := parseString(jsn.node['title'], jsn.vObj['_title']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirPublicationStatusEnum, SYSTEMS_TFhirPublicationStatusEnum);
    if jsn.has('experimental') or jsn.has('_experimental') then
        result.experimentalElement := parseBoolean(jsn.node['experimental'], jsn.vObj['_experimental']);{q}
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := parseDateTime(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('publisher') or jsn.has('_publisher') then
        result.publisherElement := parseString(jsn.node['publisher'], jsn.vObj['_publisher']);{q}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseContactDetail);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := parseMarkdown(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('useContext') then
      iterateArray(jsn.vArr['useContext'], result.useContextList, parseUsageContext);
    if jsn.has('jurisdiction') then
      iterateArray(jsn.vArr['jurisdiction'], result.jurisdictionList, parseCodeableConcept);
    if jsn.has('immutable') or jsn.has('_immutable') then
        result.immutableElement := parseBoolean(jsn.node['immutable'], jsn.vObj['_immutable']);{q}
    if jsn.has('purpose') or jsn.has('_purpose') then
        result.purposeElement := parseMarkdown(jsn.node['purpose'], jsn.vObj['_purpose']);{q}
    if jsn.has('copyright') or jsn.has('_copyright') then
        result.copyrightElement := parseMarkdown(jsn.node['copyright'], jsn.vObj['_copyright']);{q}
    if jsn.has('compose') then
        result.compose := ParseValueSetCompose(jsn.vObj['compose']);{q3}
    if jsn.has('expansion') then
        result.expansion := ParseValueSetExpansion(jsn.vObj['expansion']);{q3}
end;

procedure TFHIRJsonComposer.ComposeValueSet(json : TJSONWriter; name : string; elem : TFhirValueSet; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUriValue(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUriProps(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeStringValue(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeStringProps(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeStringValue(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeStringProps(json, 'title', elem.titleElement, false);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirPublicationStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBooleanValue(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBooleanProps(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringValue(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringProps(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') and (elem.contactList.Count > 0) then
  begin
    json.valueArray('contact');
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactDetail(json, '', elem.contactList[i]); {z - ContactDetail}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdownValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeMarkdownProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') and (elem.useContextList.Count > 0) then
  begin
    json.valueArray('useContext');
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeUsageContext(json, '', elem.useContextList[i]); {z - UsageContext}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('jurisdiction') and (elem.jurisdictionList.Count > 0) then
  begin
    json.valueArray('jurisdiction');
    for i := 0 to elem.jurisdictionList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.jurisdictionList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('immutable') then
    ComposeBooleanValue(json, 'immutable', elem.immutableElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('immutable') then
    ComposeBooleanProps(json, 'immutable', elem.immutableElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdownValue(json, 'purpose', elem.purposeElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('purpose') then
    ComposeMarkdownProps(json, 'purpose', elem.purposeElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdownValue(json, 'copyright', elem.copyrightElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeMarkdownProps(json, 'copyright', elem.copyrightElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('compose') then
    ComposeValueSetCompose(json, 'compose', elem.compose); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('expansion') then
    ComposeValueSetExpansion(json, 'expansion', elem.expansion); {a}
end;

{$ENDIF FHIR_VALUESET}
{$IFDEF FHIR_VERIFICATIONRESULT}
procedure TFHIRJsonParser.ParseVerificationResultPrimarySource(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseVerificationResultPrimarySource(jsn)); {2}
end;

function TFHIRJsonParser.ParseVerificationResultPrimarySource(jsn : TJsonObject) : TFhirVerificationResultPrimarySource;
begin
  result := TFhirVerificationResultPrimarySource.create;
  try
    ParseVerificationResultPrimarySourceProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseVerificationResultPrimarySourceProperties(jsn : TJsonObject; result : TFhirVerificationResultPrimarySource);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('who') then
        result.who := ParseReference{TFhirOrganization}(jsn.vObj['who']);{q3}
    if jsn.has('type') then
      iterateArray(jsn.vArr['type'], result.type_List, parseCodeableConcept);
    if jsn.has('communicationMethod') then
      iterateArray(jsn.vArr['communicationMethod'], result.communicationMethodList, parseCodeableConcept);
    if jsn.has('validationStatus') then
        result.validationStatus := ParseCodeableConcept(jsn.vObj['validationStatus']);{q3}
    if jsn.has('validationDate') or jsn.has('_validationDate') then
        result.validationDateElement := parseDateTime(jsn.node['validationDate'], jsn.vObj['_validationDate']);{q}
    if jsn.has('canPushUpdates') then
        result.canPushUpdates := ParseCodeableConcept(jsn.vObj['canPushUpdates']);{q3}
    if jsn.has('pushTypeAvailable') then
      iterateArray(jsn.vArr['pushTypeAvailable'], result.pushTypeAvailableList, parseCodeableConcept);
end;

procedure TFHIRJsonComposer.ComposeVerificationResultPrimarySource(json : TJSONWriter; name : string; elem : TFhirVerificationResultPrimarySource; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(json, 'who', elem.who); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.type_List.Count > 0) then
  begin
    json.valueArray('type');
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(json, '', elem.type_List[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.communicationMethodList.Count > 0) then
  begin
    json.valueArray('communicationMethod');
    for i := 0 to elem.communicationMethodList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.communicationMethodList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'validationStatus', elem.validationStatus); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTimeValue(json, 'validationDate', elem.validationDateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTimeProps(json, 'validationDate', elem.validationDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'canPushUpdates', elem.canPushUpdates); {a}
  if (SummaryOption in [soFull, soData]) and (elem.pushTypeAvailableList.Count > 0) then
  begin
    json.valueArray('pushTypeAvailable');
    for i := 0 to elem.pushTypeAvailableList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.pushTypeAvailableList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseVerificationResultAttestation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseVerificationResultAttestation(jsn)); {2}
end;

function TFHIRJsonParser.ParseVerificationResultAttestation(jsn : TJsonObject) : TFhirVerificationResultAttestation;
begin
  result := TFhirVerificationResultAttestation.create;
  try
    ParseVerificationResultAttestationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseVerificationResultAttestationProperties(jsn : TJsonObject; result : TFhirVerificationResultAttestation);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('who') then
        result.who := ParseReference{TFhirPractitioner}(jsn.vObj['who']);{q3}
    if jsn.has('onBehalfOf') then
        result.onBehalfOf := ParseReference{TFhirOrganization}(jsn.vObj['onBehalfOf']);{q3}
    if jsn.has('communicationMethod') then
        result.communicationMethod := ParseCodeableConcept(jsn.vObj['communicationMethod']);{q3}
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := parseDate(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('sourceIdentityCertificate') or jsn.has('_sourceIdentityCertificate') then
        result.sourceIdentityCertificateElement := parseString(jsn.node['sourceIdentityCertificate'], jsn.vObj['_sourceIdentityCertificate']);{q}
    if jsn.has('proxyIdentityCertificate') or jsn.has('_proxyIdentityCertificate') then
        result.proxyIdentityCertificateElement := parseString(jsn.node['proxyIdentityCertificate'], jsn.vObj['_proxyIdentityCertificate']);{q}
    if jsn.has('proxySignature') then
        result.proxySignature := ParseSignature(jsn.vObj['proxySignature']);{q3}
    if jsn.has('sourceSignature') then
        result.sourceSignature := ParseSignature(jsn.vObj['sourceSignature']);{q3}
end;

procedure TFHIRJsonComposer.ComposeVerificationResultAttestation(json : TJSONWriter; name : string; elem : TFhirVerificationResultAttestation; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(json, 'who', elem.who); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(json, 'onBehalfOf', elem.onBehalfOf); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'communicationMethod', elem.communicationMethod); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'sourceIdentityCertificate', elem.sourceIdentityCertificateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'sourceIdentityCertificate', elem.sourceIdentityCertificateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'proxyIdentityCertificate', elem.proxyIdentityCertificateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'proxyIdentityCertificate', elem.proxyIdentityCertificateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeSignature(json, 'proxySignature', elem.proxySignature); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeSignature(json, 'sourceSignature', elem.sourceSignature); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseVerificationResultValidator(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseVerificationResultValidator(jsn)); {2}
end;

function TFHIRJsonParser.ParseVerificationResultValidator(jsn : TJsonObject) : TFhirVerificationResultValidator;
begin
  result := TFhirVerificationResultValidator.create;
  try
    ParseVerificationResultValidatorProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseVerificationResultValidatorProperties(jsn : TJsonObject; result : TFhirVerificationResultValidator);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('organization') then
        result.organization := ParseReference{TFhirOrganization}(jsn.vObj['organization']);{q3}
    if jsn.has('identityCertificate') or jsn.has('_identityCertificate') then
        result.identityCertificateElement := parseString(jsn.node['identityCertificate'], jsn.vObj['_identityCertificate']);{q}
    if jsn.has('attestationSignature') then
        result.attestationSignature := ParseSignature(jsn.vObj['attestationSignature']);{q3}
end;

procedure TFHIRJsonComposer.ComposeVerificationResultValidator(json : TJSONWriter; name : string; elem : TFhirVerificationResultValidator; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeReference{TFhirOrganization}(json, 'organization', elem.organization); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'identityCertificate', elem.identityCertificateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'identityCertificate', elem.identityCertificateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeSignature(json, 'attestationSignature', elem.attestationSignature); {a}
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseVerificationResult(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseVerificationResult(jsn)); {2}
end;

function TFHIRJsonParser.ParseVerificationResult(jsn : TJsonObject) : TFhirVerificationResult;
begin
  result := TFhirVerificationResult.create;
  try
    ParseVerificationResultProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseVerificationResultProperties(jsn : TJsonObject; result : TFhirVerificationResult);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('target') then
      iterateArray(jsn.vArr['target'], result.targetList, parseReference{TFhirReference});
      if jsn.has('targetLocation') or jsn.has('_targetLocation') then
      iteratePrimitiveArray(jsn.vArr['targetLocation'], jsn.vArr['_targetLocation'], result.targetLocationList, parseString);
    if jsn.has('need') then
        result.need := ParseCodeableConcept(jsn.vObj['need']);{q3}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirVerificationresultStatusEnum, SYSTEMS_TFhirVerificationresultStatusEnum);
    if jsn.has('statusDate') or jsn.has('_statusDate') then
        result.statusDateElement := parseDateTime(jsn.node['statusDate'], jsn.vObj['_statusDate']);{q}
    if jsn.has('validationType') then
        result.validationType := ParseCodeableConcept(jsn.vObj['validationType']);{q3}
    if jsn.has('validationProcess') then
      iterateArray(jsn.vArr['validationProcess'], result.validationProcessList, parseCodeableConcept);
    if jsn.has('frequency') then
        result.frequency := ParseTiming(jsn.vObj['frequency']);{q3}
    if jsn.has('lastPerformed') or jsn.has('_lastPerformed') then
        result.lastPerformedElement := parseDateTime(jsn.node['lastPerformed'], jsn.vObj['_lastPerformed']);{q}
    if jsn.has('nextScheduled') or jsn.has('_nextScheduled') then
        result.nextScheduledElement := parseDate(jsn.node['nextScheduled'], jsn.vObj['_nextScheduled']);{q}
    if jsn.has('failureAction') then
        result.failureAction := ParseCodeableConcept(jsn.vObj['failureAction']);{q3}
    if jsn.has('primarySource') then
      iterateArray(jsn.vArr['primarySource'], result.primarySourceList, parseVerificationResultPrimarySource);
    if jsn.has('attestation') then
        result.attestation := ParseVerificationResultAttestation(jsn.vObj['attestation']);{q3}
    if jsn.has('validator') then
      iterateArray(jsn.vArr['validator'], result.validatorList, parseVerificationResultValidator);
end;

procedure TFHIRJsonComposer.ComposeVerificationResult(json : TJSONWriter; name : string; elem : TFhirVerificationResult; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('target') and (elem.targetList.Count > 0) then
  begin
    json.valueArray('target');
    for i := 0 to elem.targetList.Count - 1 do
      ComposeReference{TFhirReference}(json, '', elem.targetList[i]); {z - Reference(Any)}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('targetLocation') and (elem.targetLocationList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.targetLocationList.Count - 1 do
    begin
      ext := ext or ((elem.targetLocationList[i].id <> '') or (elem.targetLocationList[i].hasExtensionList) {no-comments or (elem.targetLocationList[i].hasComments)});
      val := val or (elem.targetLocationList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      json.valueArray('targetLocation');
      for i := 0 to elem.targetLocationList.Count - 1 do
        ComposeStringValue(json, '',elem.targetLocationList[i], true);
      json.FinishArray;
    end;
    if ext then
    begin
      json.valueArray('_targetLocation');
      for i := 0 to elem.targetLocationList.Count - 1 do
        ComposeStringProps(json, '',elem.targetLocationList[i], true);
      json.FinishArray;
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('need') then
    ComposeCodeableConcept(json, 'need', elem.need); {a}
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirVerificationresultStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirVerificationresultStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('statusDate') then
    ComposeDateTimeValue(json, 'statusDate', elem.statusDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('statusDate') then
    ComposeDateTimeProps(json, 'statusDate', elem.statusDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('validationType') then
    ComposeCodeableConcept(json, 'validationType', elem.validationType); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('validationProcess') and (elem.validationProcessList.Count > 0) then
  begin
    json.valueArray('validationProcess');
    for i := 0 to elem.validationProcessList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.validationProcessList[i]); {z - CodeableConcept}
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('frequency') then
    ComposeTiming(json, 'frequency', elem.frequency); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('lastPerformed') then
    ComposeDateTimeValue(json, 'lastPerformed', elem.lastPerformedElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('lastPerformed') then
    ComposeDateTimeProps(json, 'lastPerformed', elem.lastPerformedElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('nextScheduled') then
    ComposeDateValue(json, 'nextScheduled', elem.nextScheduledElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('nextScheduled') then
    ComposeDateProps(json, 'nextScheduled', elem.nextScheduledElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('failureAction') then
    ComposeCodeableConcept(json, 'failureAction', elem.failureAction); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('primarySource') and (elem.primarySourceList.Count > 0) then
  begin
    json.valueArray('primarySource');
    for i := 0 to elem.primarySourceList.Count - 1 do
      ComposeVerificationResultPrimarySource(json, '', elem.primarySourceList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('attestation') then
    ComposeVerificationResultAttestation(json, 'attestation', elem.attestation); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('validator') and (elem.validatorList.Count > 0) then
  begin
    json.valueArray('validator');
    for i := 0 to elem.validatorList.Count - 1 do
      ComposeVerificationResultValidator(json, '', elem.validatorList[i]); {z - }
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_VERIFICATIONRESULT}
{$IFDEF FHIR_VISIONPRESCRIPTION}
procedure TFHIRJsonParser.ParseVisionPrescriptionLensSpecification(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseVisionPrescriptionLensSpecification(jsn)); {2}
end;

function TFHIRJsonParser.ParseVisionPrescriptionLensSpecification(jsn : TJsonObject) : TFhirVisionPrescriptionLensSpecification;
begin
  result := TFhirVisionPrescriptionLensSpecification.create;
  try
    ParseVisionPrescriptionLensSpecificationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseVisionPrescriptionLensSpecificationProperties(jsn : TJsonObject; result : TFhirVisionPrescriptionLensSpecification);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('product') then
        result.product := ParseCodeableConcept(jsn.vObj['product']);{q3}
    if jsn.has('eye') or jsn.has('_eye')  then
      result.eyeElement := parseEnum(jsn.path+'/eye', jsn.node['eye'], jsn.vObj['_eye'], CODES_TFhirVisionEyeCodesEnum, SYSTEMS_TFhirVisionEyeCodesEnum);
    if jsn.has('sphere') or jsn.has('_sphere') then
        result.sphereElement := parseDecimal(jsn.node['sphere'], jsn.vObj['_sphere']);{q}
    if jsn.has('cylinder') or jsn.has('_cylinder') then
        result.cylinderElement := parseDecimal(jsn.node['cylinder'], jsn.vObj['_cylinder']);{q}
    if jsn.has('axis') or jsn.has('_axis') then
        result.axisElement := parseInteger(jsn.node['axis'], jsn.vObj['_axis']);{q}
    if jsn.has('prism') then
      iterateArray(jsn.vArr['prism'], result.prismList, parseVisionPrescriptionLensSpecificationPrism);
    if jsn.has('add') or jsn.has('_add') then
        result.addElement := parseDecimal(jsn.node['add'], jsn.vObj['_add']);{q}
    if jsn.has('power') or jsn.has('_power') then
        result.powerElement := parseDecimal(jsn.node['power'], jsn.vObj['_power']);{q}
    if jsn.has('backCurve') or jsn.has('_backCurve') then
        result.backCurveElement := parseDecimal(jsn.node['backCurve'], jsn.vObj['_backCurve']);{q}
    if jsn.has('diameter') or jsn.has('_diameter') then
        result.diameterElement := parseDecimal(jsn.node['diameter'], jsn.vObj['_diameter']);{q}
    if jsn.has('duration') then
        result.duration := ParseQuantity(jsn.vObj['duration']);{q3}
    if jsn.has('color') or jsn.has('_color') then
        result.colorElement := parseString(jsn.node['color'], jsn.vObj['_color']);{q}
    if jsn.has('brand') or jsn.has('_brand') then
        result.brandElement := parseString(jsn.node['brand'], jsn.vObj['_brand']);{q}
    if jsn.has('note') then
      iterateArray(jsn.vArr['note'], result.noteList, parseAnnotation);
end;

procedure TFHIRJsonComposer.ComposeVisionPrescriptionLensSpecification(json : TJSONWriter; name : string; elem : TFhirVisionPrescriptionLensSpecification; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
    ComposeCodeableConcept(json, 'product', elem.product); {a}
  ComposeEnumValue(json, 'eye', elem.EyeElement, CODES_TFhirVisionEyeCodesEnum, false);
  ComposeEnumProps(json, 'eye', elem.EyeElement, CODES_TFhirVisionEyeCodesEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalValue(json, 'sphere', elem.sphereElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalProps(json, 'sphere', elem.sphereElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalValue(json, 'cylinder', elem.cylinderElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalProps(json, 'cylinder', elem.cylinderElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIntegerValue(json, 'axis', elem.axisElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIntegerProps(json, 'axis', elem.axisElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.prismList.Count > 0) then
  begin
    json.valueArray('prism');
    for i := 0 to elem.prismList.Count - 1 do
      ComposeVisionPrescriptionLensSpecificationPrism(json, '', elem.prismList[i]); {z - }
    json.FinishArray;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalValue(json, 'add', elem.addElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalProps(json, 'add', elem.addElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalValue(json, 'power', elem.powerElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalProps(json, 'power', elem.powerElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalValue(json, 'backCurve', elem.backCurveElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalProps(json, 'backCurve', elem.backCurveElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalValue(json, 'diameter', elem.diameterElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalProps(json, 'diameter', elem.diameterElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'duration', elem.duration); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'color', elem.colorElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'color', elem.colorElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'brand', elem.brandElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'brand', elem.brandElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.noteList.Count > 0) then
  begin
    json.valueArray('note');
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(json, '', elem.noteList[i]); {z - Annotation}
    json.FinishArray;
  end;
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseVisionPrescriptionLensSpecificationPrism(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseVisionPrescriptionLensSpecificationPrism(jsn)); {2}
end;

function TFHIRJsonParser.ParseVisionPrescriptionLensSpecificationPrism(jsn : TJsonObject) : TFhirVisionPrescriptionLensSpecificationPrism;
begin
  result := TFhirVisionPrescriptionLensSpecificationPrism.create;
  try
    ParseVisionPrescriptionLensSpecificationPrismProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseVisionPrescriptionLensSpecificationPrismProperties(jsn : TJsonObject; result : TFhirVisionPrescriptionLensSpecificationPrism);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('amount') or jsn.has('_amount') then
        result.amountElement := parseDecimal(jsn.node['amount'], jsn.vObj['_amount']);{q}
    if jsn.has('base') or jsn.has('_base')  then
      result.baseElement := parseEnum(jsn.path+'/base', jsn.node['base'], jsn.vObj['_base'], CODES_TFhirVisionBaseCodesEnum, SYSTEMS_TFhirVisionBaseCodesEnum);
end;

procedure TFHIRJsonComposer.ComposeVisionPrescriptionLensSpecificationPrism(json : TJSONWriter; name : string; elem : TFhirVisionPrescriptionLensSpecificationPrism; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  if not noObj then json.valueObject(name);
  ComposeBackboneElementProperties(json, elem);
  ComposeDecimalValue(json, 'amount', elem.amountElement, false);
  ComposeDecimalProps(json, 'amount', elem.amountElement, false);
  ComposeEnumValue(json, 'base', elem.BaseElement, CODES_TFhirVisionBaseCodesEnum, false);
  ComposeEnumProps(json, 'base', elem.BaseElement, CODES_TFhirVisionBaseCodesEnum, false);
  if not noObj then json.finishObject;
end;

procedure TFHIRJsonParser.ParseVisionPrescription(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseVisionPrescription(jsn)); {2}
end;

function TFHIRJsonParser.ParseVisionPrescription(jsn : TJsonObject) : TFhirVisionPrescription;
begin
  result := TFhirVisionPrescription.create;
  try
    ParseVisionPrescriptionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseVisionPrescriptionProperties(jsn : TJsonObject; result : TFhirVisionPrescription);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirFmStatusEnum, SYSTEMS_TFhirFmStatusEnum);
    if jsn.has('created') or jsn.has('_created') then
        result.createdElement := parseDateTime(jsn.node['created'], jsn.vObj['_created']);{q}
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q3}
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q3}
    if jsn.has('dateWritten') or jsn.has('_dateWritten') then
        result.dateWrittenElement := parseDateTime(jsn.node['dateWritten'], jsn.vObj['_dateWritten']);{q}
    if jsn.has('prescriber') then
        result.prescriber := ParseReference{TFhirPractitioner}(jsn.vObj['prescriber']);{q3}
    if jsn.has('lensSpecification') then
      iterateArray(jsn.vArr['lensSpecification'], result.lensSpecificationList, parseVisionPrescriptionLensSpecification);
end;

procedure TFHIRJsonComposer.ComposeVisionPrescription(json : TJSONWriter; name : string; elem : TFhirVisionPrescription; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    json.valueArray('identifier');
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    json.FinishArray;
  end;
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirFmStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirFmStatusEnum, false);
  ComposeDateTimeValue(json, 'created', elem.createdElement, false);
  ComposeDateTimeProps(json, 'created', elem.createdElement, false);
    ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
    ComposeDateTimeValue(json, 'dateWritten', elem.dateWrittenElement, false);
    ComposeDateTimeProps(json, 'dateWritten', elem.dateWrittenElement, false);
    ComposeReference{TFhirPractitioner}(json, 'prescriber', elem.prescriber); {a}
  if (elem.lensSpecificationList.Count > 0) then
  begin
    json.valueArray('lensSpecification');
    for i := 0 to elem.lensSpecificationList.Count - 1 do
      ComposeVisionPrescriptionLensSpecification(json, '', elem.lensSpecificationList[i]); {z - }
    json.FinishArray;
  end;
end;

{$ENDIF FHIR_VISIONPRESCRIPTION}
function TFHIRJsonParser.ParseResource(jsn : TJsonObject) : TFhirResource;
var
  s : String;
begin
  s := jsn['resourceType'];
 {$IFDEF FHIR_PARAMETERS}
  if s = 'Parameters' Then
    result := ParseParameters(jsn)
{$ENDIF FHIR_PARAMETERS}
{$IFDEF FHIR_ACCOUNT}
  {$IFDEF FHIR_ACCOUNT}
   else if s = 'Account' Then
    result := ParseAccount(jsn) 
  {$ENDIF}
{$ENDIF FHIR_ACCOUNT}
{$IFDEF FHIR_ACTIVITYDEFINITION}
  {$IFDEF FHIR_ACTIVITYDEFINITION}
   else if s = 'ActivityDefinition' Then
    result := ParseActivityDefinition(jsn) 
  {$ENDIF}
{$ENDIF FHIR_ACTIVITYDEFINITION}
{$IFDEF FHIR_ADVERSEEVENT}
  {$IFDEF FHIR_ADVERSEEVENT}
   else if s = 'AdverseEvent' Then
    result := ParseAdverseEvent(jsn) 
  {$ENDIF}
{$ENDIF FHIR_ADVERSEEVENT}
{$IFDEF FHIR_ALLERGYINTOLERANCE}
  {$IFDEF FHIR_ALLERGYINTOLERANCE}
   else if s = 'AllergyIntolerance' Then
    result := ParseAllergyIntolerance(jsn) 
  {$ENDIF}
{$ENDIF FHIR_ALLERGYINTOLERANCE}
{$IFDEF FHIR_APPOINTMENT}
  {$IFDEF FHIR_APPOINTMENT}
   else if s = 'Appointment' Then
    result := ParseAppointment(jsn) 
  {$ENDIF}
{$ENDIF FHIR_APPOINTMENT}
{$IFDEF FHIR_APPOINTMENTRESPONSE}
  {$IFDEF FHIR_APPOINTMENTRESPONSE}
   else if s = 'AppointmentResponse' Then
    result := ParseAppointmentResponse(jsn) 
  {$ENDIF}
{$ENDIF FHIR_APPOINTMENTRESPONSE}
{$IFDEF FHIR_AUDITEVENT}
  {$IFDEF FHIR_AUDITEVENT}
   else if s = 'AuditEvent' Then
    result := ParseAuditEvent(jsn) 
  {$ENDIF}
{$ENDIF FHIR_AUDITEVENT}
{$IFDEF FHIR_BASIC}
  {$IFDEF FHIR_BASIC}
   else if s = 'Basic' Then
    result := ParseBasic(jsn) 
  {$ENDIF}
{$ENDIF FHIR_BASIC}
{$IFDEF FHIR_BINARY}
  {$IFDEF FHIR_BINARY}
   else if s = 'Binary' Then
    result := ParseBinary(jsn) 
  {$ENDIF}
{$ENDIF FHIR_BINARY}
{$IFDEF FHIR_BIOLOGICALLYDERIVEDPRODUCT}
  {$IFDEF FHIR_BIOLOGICALLYDERIVEDPRODUCT}
   else if s = 'BiologicallyDerivedProduct' Then
    result := ParseBiologicallyDerivedProduct(jsn) 
  {$ENDIF}
{$ENDIF FHIR_BIOLOGICALLYDERIVEDPRODUCT}
{$IFDEF FHIR_BODYSTRUCTURE}
  {$IFDEF FHIR_BODYSTRUCTURE}
   else if s = 'BodyStructure' Then
    result := ParseBodyStructure(jsn) 
  {$ENDIF}
{$ENDIF FHIR_BODYSTRUCTURE}
{$IFDEF FHIR_BUNDLE}
  {$IFDEF FHIR_BUNDLE}
   else if s = 'Bundle' Then
    result := ParseBundle(jsn) 
  {$ENDIF}
{$ENDIF FHIR_BUNDLE}
{$IFDEF FHIR_CAPABILITYSTATEMENT}
  {$IFDEF FHIR_CAPABILITYSTATEMENT}
   else if s = 'CapabilityStatement' Then
    result := ParseCapabilityStatement(jsn) 
  {$ENDIF}
{$ENDIF FHIR_CAPABILITYSTATEMENT}
{$IFDEF FHIR_CAREPLAN}
  {$IFDEF FHIR_CAREPLAN}
   else if s = 'CarePlan' Then
    result := ParseCarePlan(jsn) 
  {$ENDIF}
{$ENDIF FHIR_CAREPLAN}
{$IFDEF FHIR_CARETEAM}
  {$IFDEF FHIR_CARETEAM}
   else if s = 'CareTeam' Then
    result := ParseCareTeam(jsn) 
  {$ENDIF}
{$ENDIF FHIR_CARETEAM}
{$IFDEF FHIR_CATALOGENTRY}
  {$IFDEF FHIR_CATALOGENTRY}
   else if s = 'CatalogEntry' Then
    result := ParseCatalogEntry(jsn) 
  {$ENDIF}
{$ENDIF FHIR_CATALOGENTRY}
{$IFDEF FHIR_CHARGEITEM}
  {$IFDEF FHIR_CHARGEITEM}
   else if s = 'ChargeItem' Then
    result := ParseChargeItem(jsn) 
  {$ENDIF}
{$ENDIF FHIR_CHARGEITEM}
{$IFDEF FHIR_CHARGEITEMDEFINITION}
  {$IFDEF FHIR_CHARGEITEMDEFINITION}
   else if s = 'ChargeItemDefinition' Then
    result := ParseChargeItemDefinition(jsn) 
  {$ENDIF}
{$ENDIF FHIR_CHARGEITEMDEFINITION}
{$IFDEF FHIR_CLAIM}
  {$IFDEF FHIR_CLAIM}
   else if s = 'Claim' Then
    result := ParseClaim(jsn) 
  {$ENDIF}
{$ENDIF FHIR_CLAIM}
{$IFDEF FHIR_CLAIMRESPONSE}
  {$IFDEF FHIR_CLAIMRESPONSE}
   else if s = 'ClaimResponse' Then
    result := ParseClaimResponse(jsn) 
  {$ENDIF}
{$ENDIF FHIR_CLAIMRESPONSE}
{$IFDEF FHIR_CLINICALIMPRESSION}
  {$IFDEF FHIR_CLINICALIMPRESSION}
   else if s = 'ClinicalImpression' Then
    result := ParseClinicalImpression(jsn) 
  {$ENDIF}
{$ENDIF FHIR_CLINICALIMPRESSION}
{$IFDEF FHIR_CODESYSTEM}
  {$IFDEF FHIR_CODESYSTEM}
   else if s = 'CodeSystem' Then
    result := ParseCodeSystem(jsn) 
  {$ENDIF}
{$ENDIF FHIR_CODESYSTEM}
{$IFDEF FHIR_COMMUNICATION}
  {$IFDEF FHIR_COMMUNICATION}
   else if s = 'Communication' Then
    result := ParseCommunication(jsn) 
  {$ENDIF}
{$ENDIF FHIR_COMMUNICATION}
{$IFDEF FHIR_COMMUNICATIONREQUEST}
  {$IFDEF FHIR_COMMUNICATIONREQUEST}
   else if s = 'CommunicationRequest' Then
    result := ParseCommunicationRequest(jsn) 
  {$ENDIF}
{$ENDIF FHIR_COMMUNICATIONREQUEST}
{$IFDEF FHIR_COMPARTMENTDEFINITION}
  {$IFDEF FHIR_COMPARTMENTDEFINITION}
   else if s = 'CompartmentDefinition' Then
    result := ParseCompartmentDefinition(jsn) 
  {$ENDIF}
{$ENDIF FHIR_COMPARTMENTDEFINITION}
{$IFDEF FHIR_COMPOSITION}
  {$IFDEF FHIR_COMPOSITION}
   else if s = 'Composition' Then
    result := ParseComposition(jsn) 
  {$ENDIF}
{$ENDIF FHIR_COMPOSITION}
{$IFDEF FHIR_CONCEPTMAP}
  {$IFDEF FHIR_CONCEPTMAP}
   else if s = 'ConceptMap' Then
    result := ParseConceptMap(jsn) 
  {$ENDIF}
{$ENDIF FHIR_CONCEPTMAP}
{$IFDEF FHIR_CONDITION}
  {$IFDEF FHIR_CONDITION}
   else if s = 'Condition' Then
    result := ParseCondition(jsn) 
  {$ENDIF}
{$ENDIF FHIR_CONDITION}
{$IFDEF FHIR_CONSENT}
  {$IFDEF FHIR_CONSENT}
   else if s = 'Consent' Then
    result := ParseConsent(jsn) 
  {$ENDIF}
{$ENDIF FHIR_CONSENT}
{$IFDEF FHIR_CONTRACT}
  {$IFDEF FHIR_CONTRACT}
   else if s = 'Contract' Then
    result := ParseContract(jsn) 
  {$ENDIF}
{$ENDIF FHIR_CONTRACT}
{$IFDEF FHIR_COVERAGE}
  {$IFDEF FHIR_COVERAGE}
   else if s = 'Coverage' Then
    result := ParseCoverage(jsn) 
  {$ENDIF}
{$ENDIF FHIR_COVERAGE}
{$IFDEF FHIR_COVERAGEELIGIBILITYREQUEST}
  {$IFDEF FHIR_COVERAGEELIGIBILITYREQUEST}
   else if s = 'CoverageEligibilityRequest' Then
    result := ParseCoverageEligibilityRequest(jsn) 
  {$ENDIF}
{$ENDIF FHIR_COVERAGEELIGIBILITYREQUEST}
{$IFDEF FHIR_COVERAGEELIGIBILITYRESPONSE}
  {$IFDEF FHIR_COVERAGEELIGIBILITYRESPONSE}
   else if s = 'CoverageEligibilityResponse' Then
    result := ParseCoverageEligibilityResponse(jsn) 
  {$ENDIF}
{$ENDIF FHIR_COVERAGEELIGIBILITYRESPONSE}
{$IFDEF FHIR_DETECTEDISSUE}
  {$IFDEF FHIR_DETECTEDISSUE}
   else if s = 'DetectedIssue' Then
    result := ParseDetectedIssue(jsn) 
  {$ENDIF}
{$ENDIF FHIR_DETECTEDISSUE}
{$IFDEF FHIR_DEVICE}
  {$IFDEF FHIR_DEVICE}
   else if s = 'Device' Then
    result := ParseDevice(jsn) 
  {$ENDIF}
{$ENDIF FHIR_DEVICE}
{$IFDEF FHIR_DEVICEDEFINITION}
  {$IFDEF FHIR_DEVICEDEFINITION}
   else if s = 'DeviceDefinition' Then
    result := ParseDeviceDefinition(jsn) 
  {$ENDIF}
{$ENDIF FHIR_DEVICEDEFINITION}
{$IFDEF FHIR_DEVICEMETRIC}
  {$IFDEF FHIR_DEVICEMETRIC}
   else if s = 'DeviceMetric' Then
    result := ParseDeviceMetric(jsn) 
  {$ENDIF}
{$ENDIF FHIR_DEVICEMETRIC}
{$IFDEF FHIR_DEVICEREQUEST}
  {$IFDEF FHIR_DEVICEREQUEST}
   else if s = 'DeviceRequest' Then
    result := ParseDeviceRequest(jsn) 
  {$ENDIF}
{$ENDIF FHIR_DEVICEREQUEST}
{$IFDEF FHIR_DEVICEUSESTATEMENT}
  {$IFDEF FHIR_DEVICEUSESTATEMENT}
   else if s = 'DeviceUseStatement' Then
    result := ParseDeviceUseStatement(jsn) 
  {$ENDIF}
{$ENDIF FHIR_DEVICEUSESTATEMENT}
{$IFDEF FHIR_DIAGNOSTICREPORT}
  {$IFDEF FHIR_DIAGNOSTICREPORT}
   else if s = 'DiagnosticReport' Then
    result := ParseDiagnosticReport(jsn) 
  {$ENDIF}
{$ENDIF FHIR_DIAGNOSTICREPORT}
{$IFDEF FHIR_DOCUMENTMANIFEST}
  {$IFDEF FHIR_DOCUMENTMANIFEST}
   else if s = 'DocumentManifest' Then
    result := ParseDocumentManifest(jsn) 
  {$ENDIF}
{$ENDIF FHIR_DOCUMENTMANIFEST}
{$IFDEF FHIR_DOCUMENTREFERENCE}
  {$IFDEF FHIR_DOCUMENTREFERENCE}
   else if s = 'DocumentReference' Then
    result := ParseDocumentReference(jsn) 
  {$ENDIF}
{$ENDIF FHIR_DOCUMENTREFERENCE}
{$IFDEF FHIR_EFFECTEVIDENCESYNTHESIS}
  {$IFDEF FHIR_EFFECTEVIDENCESYNTHESIS}
   else if s = 'EffectEvidenceSynthesis' Then
    result := ParseEffectEvidenceSynthesis(jsn) 
  {$ENDIF}
{$ENDIF FHIR_EFFECTEVIDENCESYNTHESIS}
{$IFDEF FHIR_ENCOUNTER}
  {$IFDEF FHIR_ENCOUNTER}
   else if s = 'Encounter' Then
    result := ParseEncounter(jsn) 
  {$ENDIF}
{$ENDIF FHIR_ENCOUNTER}
{$IFDEF FHIR_ENDPOINT}
  {$IFDEF FHIR_ENDPOINT}
   else if s = 'Endpoint' Then
    result := ParseEndpoint(jsn) 
  {$ENDIF}
{$ENDIF FHIR_ENDPOINT}
{$IFDEF FHIR_ENROLLMENTREQUEST}
  {$IFDEF FHIR_ENROLLMENTREQUEST}
   else if s = 'EnrollmentRequest' Then
    result := ParseEnrollmentRequest(jsn) 
  {$ENDIF}
{$ENDIF FHIR_ENROLLMENTREQUEST}
{$IFDEF FHIR_ENROLLMENTRESPONSE}
  {$IFDEF FHIR_ENROLLMENTRESPONSE}
   else if s = 'EnrollmentResponse' Then
    result := ParseEnrollmentResponse(jsn) 
  {$ENDIF}
{$ENDIF FHIR_ENROLLMENTRESPONSE}
{$IFDEF FHIR_EPISODEOFCARE}
  {$IFDEF FHIR_EPISODEOFCARE}
   else if s = 'EpisodeOfCare' Then
    result := ParseEpisodeOfCare(jsn) 
  {$ENDIF}
{$ENDIF FHIR_EPISODEOFCARE}
{$IFDEF FHIR_EVENTDEFINITION}
  {$IFDEF FHIR_EVENTDEFINITION}
   else if s = 'EventDefinition' Then
    result := ParseEventDefinition(jsn) 
  {$ENDIF}
{$ENDIF FHIR_EVENTDEFINITION}
{$IFDEF FHIR_EVIDENCE}
  {$IFDEF FHIR_EVIDENCE}
   else if s = 'Evidence' Then
    result := ParseEvidence(jsn) 
  {$ENDIF}
{$ENDIF FHIR_EVIDENCE}
{$IFDEF FHIR_EVIDENCEVARIABLE}
  {$IFDEF FHIR_EVIDENCEVARIABLE}
   else if s = 'EvidenceVariable' Then
    result := ParseEvidenceVariable(jsn) 
  {$ENDIF}
{$ENDIF FHIR_EVIDENCEVARIABLE}
{$IFDEF FHIR_EXAMPLESCENARIO}
  {$IFDEF FHIR_EXAMPLESCENARIO}
   else if s = 'ExampleScenario' Then
    result := ParseExampleScenario(jsn) 
  {$ENDIF}
{$ENDIF FHIR_EXAMPLESCENARIO}
{$IFDEF FHIR_EXPLANATIONOFBENEFIT}
  {$IFDEF FHIR_EXPLANATIONOFBENEFIT}
   else if s = 'ExplanationOfBenefit' Then
    result := ParseExplanationOfBenefit(jsn) 
  {$ENDIF}
{$ENDIF FHIR_EXPLANATIONOFBENEFIT}
{$IFDEF FHIR_FAMILYMEMBERHISTORY}
  {$IFDEF FHIR_FAMILYMEMBERHISTORY}
   else if s = 'FamilyMemberHistory' Then
    result := ParseFamilyMemberHistory(jsn) 
  {$ENDIF}
{$ENDIF FHIR_FAMILYMEMBERHISTORY}
{$IFDEF FHIR_FLAG}
  {$IFDEF FHIR_FLAG}
   else if s = 'Flag' Then
    result := ParseFlag(jsn) 
  {$ENDIF}
{$ENDIF FHIR_FLAG}
{$IFDEF FHIR_GOAL}
  {$IFDEF FHIR_GOAL}
   else if s = 'Goal' Then
    result := ParseGoal(jsn) 
  {$ENDIF}
{$ENDIF FHIR_GOAL}
{$IFDEF FHIR_GRAPHDEFINITION}
  {$IFDEF FHIR_GRAPHDEFINITION}
   else if s = 'GraphDefinition' Then
    result := ParseGraphDefinition(jsn) 
  {$ENDIF}
{$ENDIF FHIR_GRAPHDEFINITION}
{$IFDEF FHIR_GROUP}
  {$IFDEF FHIR_GROUP}
   else if s = 'Group' Then
    result := ParseGroup(jsn) 
  {$ENDIF}
{$ENDIF FHIR_GROUP}
{$IFDEF FHIR_GUIDANCERESPONSE}
  {$IFDEF FHIR_GUIDANCERESPONSE}
   else if s = 'GuidanceResponse' Then
    result := ParseGuidanceResponse(jsn) 
  {$ENDIF}
{$ENDIF FHIR_GUIDANCERESPONSE}
{$IFDEF FHIR_HEALTHCARESERVICE}
  {$IFDEF FHIR_HEALTHCARESERVICE}
   else if s = 'HealthcareService' Then
    result := ParseHealthcareService(jsn) 
  {$ENDIF}
{$ENDIF FHIR_HEALTHCARESERVICE}
{$IFDEF FHIR_IMAGINGSTUDY}
  {$IFDEF FHIR_IMAGINGSTUDY}
   else if s = 'ImagingStudy' Then
    result := ParseImagingStudy(jsn) 
  {$ENDIF}
{$ENDIF FHIR_IMAGINGSTUDY}
{$IFDEF FHIR_IMMUNIZATION}
  {$IFDEF FHIR_IMMUNIZATION}
   else if s = 'Immunization' Then
    result := ParseImmunization(jsn) 
  {$ENDIF}
{$ENDIF FHIR_IMMUNIZATION}
{$IFDEF FHIR_IMMUNIZATIONEVALUATION}
  {$IFDEF FHIR_IMMUNIZATIONEVALUATION}
   else if s = 'ImmunizationEvaluation' Then
    result := ParseImmunizationEvaluation(jsn) 
  {$ENDIF}
{$ENDIF FHIR_IMMUNIZATIONEVALUATION}
{$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
  {$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
   else if s = 'ImmunizationRecommendation' Then
    result := ParseImmunizationRecommendation(jsn) 
  {$ENDIF}
{$ENDIF FHIR_IMMUNIZATIONRECOMMENDATION}
{$IFDEF FHIR_IMPLEMENTATIONGUIDE}
  {$IFDEF FHIR_IMPLEMENTATIONGUIDE}
   else if s = 'ImplementationGuide' Then
    result := ParseImplementationGuide(jsn) 
  {$ENDIF}
{$ENDIF FHIR_IMPLEMENTATIONGUIDE}
{$IFDEF FHIR_INSURANCEPLAN}
  {$IFDEF FHIR_INSURANCEPLAN}
   else if s = 'InsurancePlan' Then
    result := ParseInsurancePlan(jsn) 
  {$ENDIF}
{$ENDIF FHIR_INSURANCEPLAN}
{$IFDEF FHIR_INVOICE}
  {$IFDEF FHIR_INVOICE}
   else if s = 'Invoice' Then
    result := ParseInvoice(jsn) 
  {$ENDIF}
{$ENDIF FHIR_INVOICE}
{$IFDEF FHIR_LIBRARY}
  {$IFDEF FHIR_LIBRARY}
   else if s = 'Library' Then
    result := ParseLibrary(jsn) 
  {$ENDIF}
{$ENDIF FHIR_LIBRARY}
{$IFDEF FHIR_LINKAGE}
  {$IFDEF FHIR_LINKAGE}
   else if s = 'Linkage' Then
    result := ParseLinkage(jsn) 
  {$ENDIF}
{$ENDIF FHIR_LINKAGE}
{$IFDEF FHIR_LIST}
  {$IFDEF FHIR_LIST}
   else if s = 'List' Then
    result := ParseList(jsn) 
  {$ENDIF}
{$ENDIF FHIR_LIST}
{$IFDEF FHIR_LOCATION}
  {$IFDEF FHIR_LOCATION}
   else if s = 'Location' Then
    result := ParseLocation(jsn) 
  {$ENDIF}
{$ENDIF FHIR_LOCATION}
{$IFDEF FHIR_MEASURE}
  {$IFDEF FHIR_MEASURE}
   else if s = 'Measure' Then
    result := ParseMeasure(jsn) 
  {$ENDIF}
{$ENDIF FHIR_MEASURE}
{$IFDEF FHIR_MEASUREREPORT}
  {$IFDEF FHIR_MEASUREREPORT}
   else if s = 'MeasureReport' Then
    result := ParseMeasureReport(jsn) 
  {$ENDIF}
{$ENDIF FHIR_MEASUREREPORT}
{$IFDEF FHIR_MEDIA}
  {$IFDEF FHIR_MEDIA}
   else if s = 'Media' Then
    result := ParseMedia(jsn) 
  {$ENDIF}
{$ENDIF FHIR_MEDIA}
{$IFDEF FHIR_MEDICATION}
  {$IFDEF FHIR_MEDICATION}
   else if s = 'Medication' Then
    result := ParseMedication(jsn) 
  {$ENDIF}
{$ENDIF FHIR_MEDICATION}
{$IFDEF FHIR_MEDICATIONADMINISTRATION}
  {$IFDEF FHIR_MEDICATIONADMINISTRATION}
   else if s = 'MedicationAdministration' Then
    result := ParseMedicationAdministration(jsn) 
  {$ENDIF}
{$ENDIF FHIR_MEDICATIONADMINISTRATION}
{$IFDEF FHIR_MEDICATIONDISPENSE}
  {$IFDEF FHIR_MEDICATIONDISPENSE}
   else if s = 'MedicationDispense' Then
    result := ParseMedicationDispense(jsn) 
  {$ENDIF}
{$ENDIF FHIR_MEDICATIONDISPENSE}
{$IFDEF FHIR_MEDICATIONKNOWLEDGE}
  {$IFDEF FHIR_MEDICATIONKNOWLEDGE}
   else if s = 'MedicationKnowledge' Then
    result := ParseMedicationKnowledge(jsn) 
  {$ENDIF}
{$ENDIF FHIR_MEDICATIONKNOWLEDGE}
{$IFDEF FHIR_MEDICATIONREQUEST}
  {$IFDEF FHIR_MEDICATIONREQUEST}
   else if s = 'MedicationRequest' Then
    result := ParseMedicationRequest(jsn) 
  {$ENDIF}
{$ENDIF FHIR_MEDICATIONREQUEST}
{$IFDEF FHIR_MEDICATIONSTATEMENT}
  {$IFDEF FHIR_MEDICATIONSTATEMENT}
   else if s = 'MedicationStatement' Then
    result := ParseMedicationStatement(jsn) 
  {$ENDIF}
{$ENDIF FHIR_MEDICATIONSTATEMENT}
{$IFDEF FHIR_MEDICINALPRODUCT}
  {$IFDEF FHIR_MEDICINALPRODUCT}
   else if s = 'MedicinalProduct' Then
    result := ParseMedicinalProduct(jsn) 
  {$ENDIF}
{$ENDIF FHIR_MEDICINALPRODUCT}
{$IFDEF FHIR_MEDICINALPRODUCTAUTHORIZATION}
  {$IFDEF FHIR_MEDICINALPRODUCTAUTHORIZATION}
   else if s = 'MedicinalProductAuthorization' Then
    result := ParseMedicinalProductAuthorization(jsn) 
  {$ENDIF}
{$ENDIF FHIR_MEDICINALPRODUCTAUTHORIZATION}
{$IFDEF FHIR_MEDICINALPRODUCTCONTRAINDICATION}
  {$IFDEF FHIR_MEDICINALPRODUCTCONTRAINDICATION}
   else if s = 'MedicinalProductContraindication' Then
    result := ParseMedicinalProductContraindication(jsn) 
  {$ENDIF}
{$ENDIF FHIR_MEDICINALPRODUCTCONTRAINDICATION}
{$IFDEF FHIR_MEDICINALPRODUCTINDICATION}
  {$IFDEF FHIR_MEDICINALPRODUCTINDICATION}
   else if s = 'MedicinalProductIndication' Then
    result := ParseMedicinalProductIndication(jsn) 
  {$ENDIF}
{$ENDIF FHIR_MEDICINALPRODUCTINDICATION}
{$IFDEF FHIR_MEDICINALPRODUCTINGREDIENT}
  {$IFDEF FHIR_MEDICINALPRODUCTINGREDIENT}
   else if s = 'MedicinalProductIngredient' Then
    result := ParseMedicinalProductIngredient(jsn) 
  {$ENDIF}
{$ENDIF FHIR_MEDICINALPRODUCTINGREDIENT}
{$IFDEF FHIR_MEDICINALPRODUCTINTERACTION}
  {$IFDEF FHIR_MEDICINALPRODUCTINTERACTION}
   else if s = 'MedicinalProductInteraction' Then
    result := ParseMedicinalProductInteraction(jsn) 
  {$ENDIF}
{$ENDIF FHIR_MEDICINALPRODUCTINTERACTION}
{$IFDEF FHIR_MEDICINALPRODUCTMANUFACTURED}
  {$IFDEF FHIR_MEDICINALPRODUCTMANUFACTURED}
   else if s = 'MedicinalProductManufactured' Then
    result := ParseMedicinalProductManufactured(jsn) 
  {$ENDIF}
{$ENDIF FHIR_MEDICINALPRODUCTMANUFACTURED}
{$IFDEF FHIR_MEDICINALPRODUCTPACKAGED}
  {$IFDEF FHIR_MEDICINALPRODUCTPACKAGED}
   else if s = 'MedicinalProductPackaged' Then
    result := ParseMedicinalProductPackaged(jsn) 
  {$ENDIF}
{$ENDIF FHIR_MEDICINALPRODUCTPACKAGED}
{$IFDEF FHIR_MEDICINALPRODUCTPHARMACEUTICAL}
  {$IFDEF FHIR_MEDICINALPRODUCTPHARMACEUTICAL}
   else if s = 'MedicinalProductPharmaceutical' Then
    result := ParseMedicinalProductPharmaceutical(jsn) 
  {$ENDIF}
{$ENDIF FHIR_MEDICINALPRODUCTPHARMACEUTICAL}
{$IFDEF FHIR_MEDICINALPRODUCTUNDESIRABLEEFFECT}
  {$IFDEF FHIR_MEDICINALPRODUCTUNDESIRABLEEFFECT}
   else if s = 'MedicinalProductUndesirableEffect' Then
    result := ParseMedicinalProductUndesirableEffect(jsn) 
  {$ENDIF}
{$ENDIF FHIR_MEDICINALPRODUCTUNDESIRABLEEFFECT}
{$IFDEF FHIR_MESSAGEDEFINITION}
  {$IFDEF FHIR_MESSAGEDEFINITION}
   else if s = 'MessageDefinition' Then
    result := ParseMessageDefinition(jsn) 
  {$ENDIF}
{$ENDIF FHIR_MESSAGEDEFINITION}
{$IFDEF FHIR_MESSAGEHEADER}
  {$IFDEF FHIR_MESSAGEHEADER}
   else if s = 'MessageHeader' Then
    result := ParseMessageHeader(jsn) 
  {$ENDIF}
{$ENDIF FHIR_MESSAGEHEADER}
{$IFDEF FHIR_MOLECULARSEQUENCE}
  {$IFDEF FHIR_MOLECULARSEQUENCE}
   else if s = 'MolecularSequence' Then
    result := ParseMolecularSequence(jsn) 
  {$ENDIF}
{$ENDIF FHIR_MOLECULARSEQUENCE}
{$IFDEF FHIR_NAMINGSYSTEM}
  {$IFDEF FHIR_NAMINGSYSTEM}
   else if s = 'NamingSystem' Then
    result := ParseNamingSystem(jsn) 
  {$ENDIF}
{$ENDIF FHIR_NAMINGSYSTEM}
{$IFDEF FHIR_NUTRITIONORDER}
  {$IFDEF FHIR_NUTRITIONORDER}
   else if s = 'NutritionOrder' Then
    result := ParseNutritionOrder(jsn) 
  {$ENDIF}
{$ENDIF FHIR_NUTRITIONORDER}
{$IFDEF FHIR_OBSERVATION}
  {$IFDEF FHIR_OBSERVATION}
   else if s = 'Observation' Then
    result := ParseObservation(jsn) 
  {$ENDIF}
{$ENDIF FHIR_OBSERVATION}
{$IFDEF FHIR_OBSERVATIONDEFINITION}
  {$IFDEF FHIR_OBSERVATIONDEFINITION}
   else if s = 'ObservationDefinition' Then
    result := ParseObservationDefinition(jsn) 
  {$ENDIF}
{$ENDIF FHIR_OBSERVATIONDEFINITION}
{$IFDEF FHIR_OPERATIONDEFINITION}
  {$IFDEF FHIR_OPERATIONDEFINITION}
   else if s = 'OperationDefinition' Then
    result := ParseOperationDefinition(jsn) 
  {$ENDIF}
{$ENDIF FHIR_OPERATIONDEFINITION}
{$IFDEF FHIR_OPERATIONOUTCOME}
  {$IFDEF FHIR_OPERATIONOUTCOME}
   else if s = 'OperationOutcome' Then
    result := ParseOperationOutcome(jsn) 
  {$ENDIF}
{$ENDIF FHIR_OPERATIONOUTCOME}
{$IFDEF FHIR_ORGANIZATION}
  {$IFDEF FHIR_ORGANIZATION}
   else if s = 'Organization' Then
    result := ParseOrganization(jsn) 
  {$ENDIF}
{$ENDIF FHIR_ORGANIZATION}
{$IFDEF FHIR_ORGANIZATIONAFFILIATION}
  {$IFDEF FHIR_ORGANIZATIONAFFILIATION}
   else if s = 'OrganizationAffiliation' Then
    result := ParseOrganizationAffiliation(jsn) 
  {$ENDIF}
{$ENDIF FHIR_ORGANIZATIONAFFILIATION}
{$IFDEF FHIR_PATIENT}
  {$IFDEF FHIR_PATIENT}
   else if s = 'Patient' Then
    result := ParsePatient(jsn) 
  {$ENDIF}
{$ENDIF FHIR_PATIENT}
{$IFDEF FHIR_PAYMENTNOTICE}
  {$IFDEF FHIR_PAYMENTNOTICE}
   else if s = 'PaymentNotice' Then
    result := ParsePaymentNotice(jsn) 
  {$ENDIF}
{$ENDIF FHIR_PAYMENTNOTICE}
{$IFDEF FHIR_PAYMENTRECONCILIATION}
  {$IFDEF FHIR_PAYMENTRECONCILIATION}
   else if s = 'PaymentReconciliation' Then
    result := ParsePaymentReconciliation(jsn) 
  {$ENDIF}
{$ENDIF FHIR_PAYMENTRECONCILIATION}
{$IFDEF FHIR_PERSON}
  {$IFDEF FHIR_PERSON}
   else if s = 'Person' Then
    result := ParsePerson(jsn) 
  {$ENDIF}
{$ENDIF FHIR_PERSON}
{$IFDEF FHIR_PLANDEFINITION}
  {$IFDEF FHIR_PLANDEFINITION}
   else if s = 'PlanDefinition' Then
    result := ParsePlanDefinition(jsn) 
  {$ENDIF}
{$ENDIF FHIR_PLANDEFINITION}
{$IFDEF FHIR_PRACTITIONER}
  {$IFDEF FHIR_PRACTITIONER}
   else if s = 'Practitioner' Then
    result := ParsePractitioner(jsn) 
  {$ENDIF}
{$ENDIF FHIR_PRACTITIONER}
{$IFDEF FHIR_PRACTITIONERROLE}
  {$IFDEF FHIR_PRACTITIONERROLE}
   else if s = 'PractitionerRole' Then
    result := ParsePractitionerRole(jsn) 
  {$ENDIF}
{$ENDIF FHIR_PRACTITIONERROLE}
{$IFDEF FHIR_PROCEDURE}
  {$IFDEF FHIR_PROCEDURE}
   else if s = 'Procedure' Then
    result := ParseProcedure(jsn) 
  {$ENDIF}
{$ENDIF FHIR_PROCEDURE}
{$IFDEF FHIR_PROVENANCE}
  {$IFDEF FHIR_PROVENANCE}
   else if s = 'Provenance' Then
    result := ParseProvenance(jsn) 
  {$ENDIF}
{$ENDIF FHIR_PROVENANCE}
{$IFDEF FHIR_QUESTIONNAIRE}
  {$IFDEF FHIR_QUESTIONNAIRE}
   else if s = 'Questionnaire' Then
    result := ParseQuestionnaire(jsn) 
  {$ENDIF}
{$ENDIF FHIR_QUESTIONNAIRE}
{$IFDEF FHIR_QUESTIONNAIRERESPONSE}
  {$IFDEF FHIR_QUESTIONNAIRERESPONSE}
   else if s = 'QuestionnaireResponse' Then
    result := ParseQuestionnaireResponse(jsn) 
  {$ENDIF}
{$ENDIF FHIR_QUESTIONNAIRERESPONSE}
{$IFDEF FHIR_RELATEDPERSON}
  {$IFDEF FHIR_RELATEDPERSON}
   else if s = 'RelatedPerson' Then
    result := ParseRelatedPerson(jsn) 
  {$ENDIF}
{$ENDIF FHIR_RELATEDPERSON}
{$IFDEF FHIR_REQUESTGROUP}
  {$IFDEF FHIR_REQUESTGROUP}
   else if s = 'RequestGroup' Then
    result := ParseRequestGroup(jsn) 
  {$ENDIF}
{$ENDIF FHIR_REQUESTGROUP}
{$IFDEF FHIR_RESEARCHDEFINITION}
  {$IFDEF FHIR_RESEARCHDEFINITION}
   else if s = 'ResearchDefinition' Then
    result := ParseResearchDefinition(jsn) 
  {$ENDIF}
{$ENDIF FHIR_RESEARCHDEFINITION}
{$IFDEF FHIR_RESEARCHELEMENTDEFINITION}
  {$IFDEF FHIR_RESEARCHELEMENTDEFINITION}
   else if s = 'ResearchElementDefinition' Then
    result := ParseResearchElementDefinition(jsn) 
  {$ENDIF}
{$ENDIF FHIR_RESEARCHELEMENTDEFINITION}
{$IFDEF FHIR_RESEARCHSTUDY}
  {$IFDEF FHIR_RESEARCHSTUDY}
   else if s = 'ResearchStudy' Then
    result := ParseResearchStudy(jsn) 
  {$ENDIF}
{$ENDIF FHIR_RESEARCHSTUDY}
{$IFDEF FHIR_RESEARCHSUBJECT}
  {$IFDEF FHIR_RESEARCHSUBJECT}
   else if s = 'ResearchSubject' Then
    result := ParseResearchSubject(jsn) 
  {$ENDIF}
{$ENDIF FHIR_RESEARCHSUBJECT}
{$IFDEF FHIR_RISKASSESSMENT}
  {$IFDEF FHIR_RISKASSESSMENT}
   else if s = 'RiskAssessment' Then
    result := ParseRiskAssessment(jsn) 
  {$ENDIF}
{$ENDIF FHIR_RISKASSESSMENT}
{$IFDEF FHIR_RISKEVIDENCESYNTHESIS}
  {$IFDEF FHIR_RISKEVIDENCESYNTHESIS}
   else if s = 'RiskEvidenceSynthesis' Then
    result := ParseRiskEvidenceSynthesis(jsn) 
  {$ENDIF}
{$ENDIF FHIR_RISKEVIDENCESYNTHESIS}
{$IFDEF FHIR_SCHEDULE}
  {$IFDEF FHIR_SCHEDULE}
   else if s = 'Schedule' Then
    result := ParseSchedule(jsn) 
  {$ENDIF}
{$ENDIF FHIR_SCHEDULE}
{$IFDEF FHIR_SEARCHPARAMETER}
  {$IFDEF FHIR_SEARCHPARAMETER}
   else if s = 'SearchParameter' Then
    result := ParseSearchParameter(jsn) 
  {$ENDIF}
{$ENDIF FHIR_SEARCHPARAMETER}
{$IFDEF FHIR_SERVICEREQUEST}
  {$IFDEF FHIR_SERVICEREQUEST}
   else if s = 'ServiceRequest' Then
    result := ParseServiceRequest(jsn) 
  {$ENDIF}
{$ENDIF FHIR_SERVICEREQUEST}
{$IFDEF FHIR_SLOT}
  {$IFDEF FHIR_SLOT}
   else if s = 'Slot' Then
    result := ParseSlot(jsn) 
  {$ENDIF}
{$ENDIF FHIR_SLOT}
{$IFDEF FHIR_SPECIMEN}
  {$IFDEF FHIR_SPECIMEN}
   else if s = 'Specimen' Then
    result := ParseSpecimen(jsn) 
  {$ENDIF}
{$ENDIF FHIR_SPECIMEN}
{$IFDEF FHIR_SPECIMENDEFINITION}
  {$IFDEF FHIR_SPECIMENDEFINITION}
   else if s = 'SpecimenDefinition' Then
    result := ParseSpecimenDefinition(jsn) 
  {$ENDIF}
{$ENDIF FHIR_SPECIMENDEFINITION}
{$IFDEF FHIR_STRUCTUREDEFINITION}
  {$IFDEF FHIR_STRUCTUREDEFINITION}
   else if s = 'StructureDefinition' Then
    result := ParseStructureDefinition(jsn) 
  {$ENDIF}
{$ENDIF FHIR_STRUCTUREDEFINITION}
{$IFDEF FHIR_STRUCTUREMAP}
  {$IFDEF FHIR_STRUCTUREMAP}
   else if s = 'StructureMap' Then
    result := ParseStructureMap(jsn) 
  {$ENDIF}
{$ENDIF FHIR_STRUCTUREMAP}
{$IFDEF FHIR_SUBSCRIPTION}
  {$IFDEF FHIR_SUBSCRIPTION}
   else if s = 'Subscription' Then
    result := ParseSubscription(jsn) 
  {$ENDIF}
{$ENDIF FHIR_SUBSCRIPTION}
{$IFDEF FHIR_SUBSTANCE}
  {$IFDEF FHIR_SUBSTANCE}
   else if s = 'Substance' Then
    result := ParseSubstance(jsn) 
  {$ENDIF}
{$ENDIF FHIR_SUBSTANCE}
{$IFDEF FHIR_SUBSTANCENUCLEICACID}
  {$IFDEF FHIR_SUBSTANCENUCLEICACID}
   else if s = 'SubstanceNucleicAcid' Then
    result := ParseSubstanceNucleicAcid(jsn) 
  {$ENDIF}
{$ENDIF FHIR_SUBSTANCENUCLEICACID}
{$IFDEF FHIR_SUBSTANCEPOLYMER}
  {$IFDEF FHIR_SUBSTANCEPOLYMER}
   else if s = 'SubstancePolymer' Then
    result := ParseSubstancePolymer(jsn) 
  {$ENDIF}
{$ENDIF FHIR_SUBSTANCEPOLYMER}
{$IFDEF FHIR_SUBSTANCEPROTEIN}
  {$IFDEF FHIR_SUBSTANCEPROTEIN}
   else if s = 'SubstanceProtein' Then
    result := ParseSubstanceProtein(jsn) 
  {$ENDIF}
{$ENDIF FHIR_SUBSTANCEPROTEIN}
{$IFDEF FHIR_SUBSTANCEREFERENCEINFORMATION}
  {$IFDEF FHIR_SUBSTANCEREFERENCEINFORMATION}
   else if s = 'SubstanceReferenceInformation' Then
    result := ParseSubstanceReferenceInformation(jsn) 
  {$ENDIF}
{$ENDIF FHIR_SUBSTANCEREFERENCEINFORMATION}
{$IFDEF FHIR_SUBSTANCESOURCEMATERIAL}
  {$IFDEF FHIR_SUBSTANCESOURCEMATERIAL}
   else if s = 'SubstanceSourceMaterial' Then
    result := ParseSubstanceSourceMaterial(jsn) 
  {$ENDIF}
{$ENDIF FHIR_SUBSTANCESOURCEMATERIAL}
{$IFDEF FHIR_SUBSTANCESPECIFICATION}
  {$IFDEF FHIR_SUBSTANCESPECIFICATION}
   else if s = 'SubstanceSpecification' Then
    result := ParseSubstanceSpecification(jsn) 
  {$ENDIF}
{$ENDIF FHIR_SUBSTANCESPECIFICATION}
{$IFDEF FHIR_SUPPLYDELIVERY}
  {$IFDEF FHIR_SUPPLYDELIVERY}
   else if s = 'SupplyDelivery' Then
    result := ParseSupplyDelivery(jsn) 
  {$ENDIF}
{$ENDIF FHIR_SUPPLYDELIVERY}
{$IFDEF FHIR_SUPPLYREQUEST}
  {$IFDEF FHIR_SUPPLYREQUEST}
   else if s = 'SupplyRequest' Then
    result := ParseSupplyRequest(jsn) 
  {$ENDIF}
{$ENDIF FHIR_SUPPLYREQUEST}
{$IFDEF FHIR_TASK}
  {$IFDEF FHIR_TASK}
   else if s = 'Task' Then
    result := ParseTask(jsn) 
  {$ENDIF}
{$ENDIF FHIR_TASK}
{$IFDEF FHIR_TERMINOLOGYCAPABILITIES}
  {$IFDEF FHIR_TERMINOLOGYCAPABILITIES}
   else if s = 'TerminologyCapabilities' Then
    result := ParseTerminologyCapabilities(jsn) 
  {$ENDIF}
{$ENDIF FHIR_TERMINOLOGYCAPABILITIES}
{$IFDEF FHIR_TESTREPORT}
  {$IFDEF FHIR_TESTREPORT}
   else if s = 'TestReport' Then
    result := ParseTestReport(jsn) 
  {$ENDIF}
{$ENDIF FHIR_TESTREPORT}
{$IFDEF FHIR_TESTSCRIPT}
  {$IFDEF FHIR_TESTSCRIPT}
   else if s = 'TestScript' Then
    result := ParseTestScript(jsn) 
  {$ENDIF}
{$ENDIF FHIR_TESTSCRIPT}
{$IFDEF FHIR_VALUESET}
  {$IFDEF FHIR_VALUESET}
   else if s = 'ValueSet' Then
    result := ParseValueSet(jsn) 
  {$ENDIF}
{$ENDIF FHIR_VALUESET}
{$IFDEF FHIR_VERIFICATIONRESULT}
  {$IFDEF FHIR_VERIFICATIONRESULT}
   else if s = 'VerificationResult' Then
    result := ParseVerificationResult(jsn) 
  {$ENDIF}
{$ENDIF FHIR_VERIFICATIONRESULT}
{$IFDEF FHIR_VISIONPRESCRIPTION}
  {$IFDEF FHIR_VISIONPRESCRIPTION}
   else if s = 'VisionPrescription' Then
    result := ParseVisionPrescription(jsn) 
  {$ENDIF}
{$ENDIF FHIR_VISIONPRESCRIPTION}
  else
    raise EJsonException.create('error: the element '+s+' is not a valid resource name');
end;

function TFHIRJsonParser.ParseFragment(jsn : TJsonObject; type_ : String) : TFHIRObject;
begin
   if (type_ = 'TFhirElement') then
    result := parseElement(jsn)
  else if (type_ = 'TFhirBackboneElement') then
    result := parseBackboneElement(jsn)
  else if (type_ = 'TFhirBackboneType') then
    result := parseBackboneType(jsn)
{$IFDEF FHIR_PARAMETERS}
  else if (type_ = 'TFhirParameters') then
    result := parseParameters(jsn)
{$ENDIF FHIR_PARAMETERS}
  else if (type_ = 'TFhirExtension') then
    result := parseExtension(jsn)
  else if (type_ = 'TFhirNarrative') then
    result := parseNarrative(jsn)
  else if (type_ = 'TFhirContributor') then
    result := parseContributor(jsn)
  else if (type_ = 'TFhirAttachment') then
    result := parseAttachment(jsn)
  else if (type_ = 'TFhirDataRequirement') then
    result := parseDataRequirement(jsn)
  else if (type_ = 'TFhirDosage') then
    result := parseDosage(jsn)
  else if (type_ = 'TFhirMoney') then
    result := parseMoney(jsn)
  else if (type_ = 'TFhirMarketingStatus') then
    result := parseMarketingStatus(jsn)
  else if (type_ = 'TFhirIdentifier') then
    result := parseIdentifier(jsn)
  else if (type_ = 'TFhirSubstanceAmount') then
    result := parseSubstanceAmount(jsn)
  else if (type_ = 'TFhirCoding') then
    result := parseCoding(jsn)
  else if (type_ = 'TFhirSampledData') then
    result := parseSampledData(jsn)
  else if (type_ = 'TFhirPopulation') then
    result := parsePopulation(jsn)
  else if (type_ = 'TFhirRatio') then
    result := parseRatio(jsn)
  else if (type_ = 'TFhirReference') then
    result := parseReference(jsn)
  else if (type_ = 'TFhirTriggerDefinition') then
    result := parseTriggerDefinition(jsn)
  else if (type_ = 'TFhirPeriod') then
    result := parsePeriod(jsn)
  else if (type_ = 'TFhirQuantity') then
    result := parseQuantity(jsn)
  else if (type_ = 'TFhirRange') then
    result := parseRange(jsn)
  else if (type_ = 'TFhirRelatedArtifact') then
    result := parseRelatedArtifact(jsn)
  else if (type_ = 'TFhirAnnotation') then
    result := parseAnnotation(jsn)
  else if (type_ = 'TFhirProductShelfLife') then
    result := parseProductShelfLife(jsn)
  else if (type_ = 'TFhirContactDetail') then
    result := parseContactDetail(jsn)
  else if (type_ = 'TFhirExpression') then
    result := parseExpression(jsn)
  else if (type_ = 'TFhirUsageContext') then
    result := parseUsageContext(jsn)
  else if (type_ = 'TFhirSignature') then
    result := parseSignature(jsn)
  else if (type_ = 'TFhirProdCharacteristic') then
    result := parseProdCharacteristic(jsn)
  else if (type_ = 'TFhirCodeableConcept') then
    result := parseCodeableConcept(jsn)
  else if (type_ = 'TFhirParameterDefinition') then
    result := parseParameterDefinition(jsn)
  else if (type_ = 'TFhirContactPoint') then
    result := parseContactPoint(jsn)
  else if (type_ = 'TFhirHumanName') then
    result := parseHumanName(jsn)
  else if (type_ = 'TFhirMeta') then
    result := parseMeta(jsn)
  else if (type_ = 'TFhirAddress') then
    result := parseAddress(jsn)
  else if (type_ = 'TFhirElementDefinition') then
    result := parseElementDefinition(jsn)
  else if (type_ = 'TFhirTiming') then
    result := parseTiming(jsn)
  else if (type_ = 'TFhirCount') then
    result := parseCount(jsn)
  else if (type_ = 'TFhirAge') then
    result := parseAge(jsn)
  else if (type_ = 'TFhirDistance') then
    result := parseDistance(jsn)
  else if (type_ = 'TFhirDuration') then
    result := parseDuration(jsn)
{$IFDEF FHIR_ACCOUNT}
  else if (type_ = 'TFhirAccount') then
    result := parseAccount(jsn)
{$ENDIF FHIR_ACCOUNT}
{$IFDEF FHIR_ACTIVITYDEFINITION}
  else if (type_ = 'TFhirActivityDefinition') then
    result := parseActivityDefinition(jsn)
{$ENDIF FHIR_ACTIVITYDEFINITION}
{$IFDEF FHIR_ADVERSEEVENT}
  else if (type_ = 'TFhirAdverseEvent') then
    result := parseAdverseEvent(jsn)
{$ENDIF FHIR_ADVERSEEVENT}
{$IFDEF FHIR_ALLERGYINTOLERANCE}
  else if (type_ = 'TFhirAllergyIntolerance') then
    result := parseAllergyIntolerance(jsn)
{$ENDIF FHIR_ALLERGYINTOLERANCE}
{$IFDEF FHIR_APPOINTMENT}
  else if (type_ = 'TFhirAppointment') then
    result := parseAppointment(jsn)
{$ENDIF FHIR_APPOINTMENT}
{$IFDEF FHIR_APPOINTMENTRESPONSE}
  else if (type_ = 'TFhirAppointmentResponse') then
    result := parseAppointmentResponse(jsn)
{$ENDIF FHIR_APPOINTMENTRESPONSE}
{$IFDEF FHIR_AUDITEVENT}
  else if (type_ = 'TFhirAuditEvent') then
    result := parseAuditEvent(jsn)
{$ENDIF FHIR_AUDITEVENT}
{$IFDEF FHIR_BASIC}
  else if (type_ = 'TFhirBasic') then
    result := parseBasic(jsn)
{$ENDIF FHIR_BASIC}
{$IFDEF FHIR_BINARY}
  else if (type_ = 'TFhirBinary') then
    result := parseBinary(jsn)
{$ENDIF FHIR_BINARY}
{$IFDEF FHIR_BIOLOGICALLYDERIVEDPRODUCT}
  else if (type_ = 'TFhirBiologicallyDerivedProduct') then
    result := parseBiologicallyDerivedProduct(jsn)
{$ENDIF FHIR_BIOLOGICALLYDERIVEDPRODUCT}
{$IFDEF FHIR_BODYSTRUCTURE}
  else if (type_ = 'TFhirBodyStructure') then
    result := parseBodyStructure(jsn)
{$ENDIF FHIR_BODYSTRUCTURE}
{$IFDEF FHIR_BUNDLE}
  else if (type_ = 'TFhirBundle') then
    result := parseBundle(jsn)
{$ENDIF FHIR_BUNDLE}
{$IFDEF FHIR_CAPABILITYSTATEMENT}
  else if (type_ = 'TFhirCapabilityStatement') then
    result := parseCapabilityStatement(jsn)
{$ENDIF FHIR_CAPABILITYSTATEMENT}
{$IFDEF FHIR_CAREPLAN}
  else if (type_ = 'TFhirCarePlan') then
    result := parseCarePlan(jsn)
{$ENDIF FHIR_CAREPLAN}
{$IFDEF FHIR_CARETEAM}
  else if (type_ = 'TFhirCareTeam') then
    result := parseCareTeam(jsn)
{$ENDIF FHIR_CARETEAM}
{$IFDEF FHIR_CATALOGENTRY}
  else if (type_ = 'TFhirCatalogEntry') then
    result := parseCatalogEntry(jsn)
{$ENDIF FHIR_CATALOGENTRY}
{$IFDEF FHIR_CHARGEITEM}
  else if (type_ = 'TFhirChargeItem') then
    result := parseChargeItem(jsn)
{$ENDIF FHIR_CHARGEITEM}
{$IFDEF FHIR_CHARGEITEMDEFINITION}
  else if (type_ = 'TFhirChargeItemDefinition') then
    result := parseChargeItemDefinition(jsn)
{$ENDIF FHIR_CHARGEITEMDEFINITION}
{$IFDEF FHIR_CLAIM}
  else if (type_ = 'TFhirClaim') then
    result := parseClaim(jsn)
{$ENDIF FHIR_CLAIM}
{$IFDEF FHIR_CLAIMRESPONSE}
  else if (type_ = 'TFhirClaimResponse') then
    result := parseClaimResponse(jsn)
{$ENDIF FHIR_CLAIMRESPONSE}
{$IFDEF FHIR_CLINICALIMPRESSION}
  else if (type_ = 'TFhirClinicalImpression') then
    result := parseClinicalImpression(jsn)
{$ENDIF FHIR_CLINICALIMPRESSION}
{$IFDEF FHIR_CODESYSTEM}
  else if (type_ = 'TFhirCodeSystem') then
    result := parseCodeSystem(jsn)
{$ENDIF FHIR_CODESYSTEM}
{$IFDEF FHIR_COMMUNICATION}
  else if (type_ = 'TFhirCommunication') then
    result := parseCommunication(jsn)
{$ENDIF FHIR_COMMUNICATION}
{$IFDEF FHIR_COMMUNICATIONREQUEST}
  else if (type_ = 'TFhirCommunicationRequest') then
    result := parseCommunicationRequest(jsn)
{$ENDIF FHIR_COMMUNICATIONREQUEST}
{$IFDEF FHIR_COMPARTMENTDEFINITION}
  else if (type_ = 'TFhirCompartmentDefinition') then
    result := parseCompartmentDefinition(jsn)
{$ENDIF FHIR_COMPARTMENTDEFINITION}
{$IFDEF FHIR_COMPOSITION}
  else if (type_ = 'TFhirComposition') then
    result := parseComposition(jsn)
{$ENDIF FHIR_COMPOSITION}
{$IFDEF FHIR_CONCEPTMAP}
  else if (type_ = 'TFhirConceptMap') then
    result := parseConceptMap(jsn)
{$ENDIF FHIR_CONCEPTMAP}
{$IFDEF FHIR_CONDITION}
  else if (type_ = 'TFhirCondition') then
    result := parseCondition(jsn)
{$ENDIF FHIR_CONDITION}
{$IFDEF FHIR_CONSENT}
  else if (type_ = 'TFhirConsent') then
    result := parseConsent(jsn)
{$ENDIF FHIR_CONSENT}
{$IFDEF FHIR_CONTRACT}
  else if (type_ = 'TFhirContract') then
    result := parseContract(jsn)
{$ENDIF FHIR_CONTRACT}
{$IFDEF FHIR_COVERAGE}
  else if (type_ = 'TFhirCoverage') then
    result := parseCoverage(jsn)
{$ENDIF FHIR_COVERAGE}
{$IFDEF FHIR_COVERAGEELIGIBILITYREQUEST}
  else if (type_ = 'TFhirCoverageEligibilityRequest') then
    result := parseCoverageEligibilityRequest(jsn)
{$ENDIF FHIR_COVERAGEELIGIBILITYREQUEST}
{$IFDEF FHIR_COVERAGEELIGIBILITYRESPONSE}
  else if (type_ = 'TFhirCoverageEligibilityResponse') then
    result := parseCoverageEligibilityResponse(jsn)
{$ENDIF FHIR_COVERAGEELIGIBILITYRESPONSE}
{$IFDEF FHIR_DETECTEDISSUE}
  else if (type_ = 'TFhirDetectedIssue') then
    result := parseDetectedIssue(jsn)
{$ENDIF FHIR_DETECTEDISSUE}
{$IFDEF FHIR_DEVICE}
  else if (type_ = 'TFhirDevice') then
    result := parseDevice(jsn)
{$ENDIF FHIR_DEVICE}
{$IFDEF FHIR_DEVICEDEFINITION}
  else if (type_ = 'TFhirDeviceDefinition') then
    result := parseDeviceDefinition(jsn)
{$ENDIF FHIR_DEVICEDEFINITION}
{$IFDEF FHIR_DEVICEMETRIC}
  else if (type_ = 'TFhirDeviceMetric') then
    result := parseDeviceMetric(jsn)
{$ENDIF FHIR_DEVICEMETRIC}
{$IFDEF FHIR_DEVICEREQUEST}
  else if (type_ = 'TFhirDeviceRequest') then
    result := parseDeviceRequest(jsn)
{$ENDIF FHIR_DEVICEREQUEST}
{$IFDEF FHIR_DEVICEUSESTATEMENT}
  else if (type_ = 'TFhirDeviceUseStatement') then
    result := parseDeviceUseStatement(jsn)
{$ENDIF FHIR_DEVICEUSESTATEMENT}
{$IFDEF FHIR_DIAGNOSTICREPORT}
  else if (type_ = 'TFhirDiagnosticReport') then
    result := parseDiagnosticReport(jsn)
{$ENDIF FHIR_DIAGNOSTICREPORT}
{$IFDEF FHIR_DOCUMENTMANIFEST}
  else if (type_ = 'TFhirDocumentManifest') then
    result := parseDocumentManifest(jsn)
{$ENDIF FHIR_DOCUMENTMANIFEST}
{$IFDEF FHIR_DOCUMENTREFERENCE}
  else if (type_ = 'TFhirDocumentReference') then
    result := parseDocumentReference(jsn)
{$ENDIF FHIR_DOCUMENTREFERENCE}
{$IFDEF FHIR_EFFECTEVIDENCESYNTHESIS}
  else if (type_ = 'TFhirEffectEvidenceSynthesis') then
    result := parseEffectEvidenceSynthesis(jsn)
{$ENDIF FHIR_EFFECTEVIDENCESYNTHESIS}
{$IFDEF FHIR_ENCOUNTER}
  else if (type_ = 'TFhirEncounter') then
    result := parseEncounter(jsn)
{$ENDIF FHIR_ENCOUNTER}
{$IFDEF FHIR_ENDPOINT}
  else if (type_ = 'TFhirEndpoint') then
    result := parseEndpoint(jsn)
{$ENDIF FHIR_ENDPOINT}
{$IFDEF FHIR_ENROLLMENTREQUEST}
  else if (type_ = 'TFhirEnrollmentRequest') then
    result := parseEnrollmentRequest(jsn)
{$ENDIF FHIR_ENROLLMENTREQUEST}
{$IFDEF FHIR_ENROLLMENTRESPONSE}
  else if (type_ = 'TFhirEnrollmentResponse') then
    result := parseEnrollmentResponse(jsn)
{$ENDIF FHIR_ENROLLMENTRESPONSE}
{$IFDEF FHIR_EPISODEOFCARE}
  else if (type_ = 'TFhirEpisodeOfCare') then
    result := parseEpisodeOfCare(jsn)
{$ENDIF FHIR_EPISODEOFCARE}
{$IFDEF FHIR_EVENTDEFINITION}
  else if (type_ = 'TFhirEventDefinition') then
    result := parseEventDefinition(jsn)
{$ENDIF FHIR_EVENTDEFINITION}
{$IFDEF FHIR_EVIDENCE}
  else if (type_ = 'TFhirEvidence') then
    result := parseEvidence(jsn)
{$ENDIF FHIR_EVIDENCE}
{$IFDEF FHIR_EVIDENCEVARIABLE}
  else if (type_ = 'TFhirEvidenceVariable') then
    result := parseEvidenceVariable(jsn)
{$ENDIF FHIR_EVIDENCEVARIABLE}
{$IFDEF FHIR_EXAMPLESCENARIO}
  else if (type_ = 'TFhirExampleScenario') then
    result := parseExampleScenario(jsn)
{$ENDIF FHIR_EXAMPLESCENARIO}
{$IFDEF FHIR_EXPLANATIONOFBENEFIT}
  else if (type_ = 'TFhirExplanationOfBenefit') then
    result := parseExplanationOfBenefit(jsn)
{$ENDIF FHIR_EXPLANATIONOFBENEFIT}
{$IFDEF FHIR_FAMILYMEMBERHISTORY}
  else if (type_ = 'TFhirFamilyMemberHistory') then
    result := parseFamilyMemberHistory(jsn)
{$ENDIF FHIR_FAMILYMEMBERHISTORY}
{$IFDEF FHIR_FLAG}
  else if (type_ = 'TFhirFlag') then
    result := parseFlag(jsn)
{$ENDIF FHIR_FLAG}
{$IFDEF FHIR_GOAL}
  else if (type_ = 'TFhirGoal') then
    result := parseGoal(jsn)
{$ENDIF FHIR_GOAL}
{$IFDEF FHIR_GRAPHDEFINITION}
  else if (type_ = 'TFhirGraphDefinition') then
    result := parseGraphDefinition(jsn)
{$ENDIF FHIR_GRAPHDEFINITION}
{$IFDEF FHIR_GROUP}
  else if (type_ = 'TFhirGroup') then
    result := parseGroup(jsn)
{$ENDIF FHIR_GROUP}
{$IFDEF FHIR_GUIDANCERESPONSE}
  else if (type_ = 'TFhirGuidanceResponse') then
    result := parseGuidanceResponse(jsn)
{$ENDIF FHIR_GUIDANCERESPONSE}
{$IFDEF FHIR_HEALTHCARESERVICE}
  else if (type_ = 'TFhirHealthcareService') then
    result := parseHealthcareService(jsn)
{$ENDIF FHIR_HEALTHCARESERVICE}
{$IFDEF FHIR_IMAGINGSTUDY}
  else if (type_ = 'TFhirImagingStudy') then
    result := parseImagingStudy(jsn)
{$ENDIF FHIR_IMAGINGSTUDY}
{$IFDEF FHIR_IMMUNIZATION}
  else if (type_ = 'TFhirImmunization') then
    result := parseImmunization(jsn)
{$ENDIF FHIR_IMMUNIZATION}
{$IFDEF FHIR_IMMUNIZATIONEVALUATION}
  else if (type_ = 'TFhirImmunizationEvaluation') then
    result := parseImmunizationEvaluation(jsn)
{$ENDIF FHIR_IMMUNIZATIONEVALUATION}
{$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
  else if (type_ = 'TFhirImmunizationRecommendation') then
    result := parseImmunizationRecommendation(jsn)
{$ENDIF FHIR_IMMUNIZATIONRECOMMENDATION}
{$IFDEF FHIR_IMPLEMENTATIONGUIDE}
  else if (type_ = 'TFhirImplementationGuide') then
    result := parseImplementationGuide(jsn)
{$ENDIF FHIR_IMPLEMENTATIONGUIDE}
{$IFDEF FHIR_INSURANCEPLAN}
  else if (type_ = 'TFhirInsurancePlan') then
    result := parseInsurancePlan(jsn)
{$ENDIF FHIR_INSURANCEPLAN}
{$IFDEF FHIR_INVOICE}
  else if (type_ = 'TFhirInvoice') then
    result := parseInvoice(jsn)
{$ENDIF FHIR_INVOICE}
{$IFDEF FHIR_LIBRARY}
  else if (type_ = 'TFhirLibrary') then
    result := parseLibrary(jsn)
{$ENDIF FHIR_LIBRARY}
{$IFDEF FHIR_LINKAGE}
  else if (type_ = 'TFhirLinkage') then
    result := parseLinkage(jsn)
{$ENDIF FHIR_LINKAGE}
{$IFDEF FHIR_LIST}
  else if (type_ = 'TFhirList') then
    result := parseList(jsn)
{$ENDIF FHIR_LIST}
{$IFDEF FHIR_LOCATION}
  else if (type_ = 'TFhirLocation') then
    result := parseLocation(jsn)
{$ENDIF FHIR_LOCATION}
{$IFDEF FHIR_MEASURE}
  else if (type_ = 'TFhirMeasure') then
    result := parseMeasure(jsn)
{$ENDIF FHIR_MEASURE}
{$IFDEF FHIR_MEASUREREPORT}
  else if (type_ = 'TFhirMeasureReport') then
    result := parseMeasureReport(jsn)
{$ENDIF FHIR_MEASUREREPORT}
{$IFDEF FHIR_MEDIA}
  else if (type_ = 'TFhirMedia') then
    result := parseMedia(jsn)
{$ENDIF FHIR_MEDIA}
{$IFDEF FHIR_MEDICATION}
  else if (type_ = 'TFhirMedication') then
    result := parseMedication(jsn)
{$ENDIF FHIR_MEDICATION}
{$IFDEF FHIR_MEDICATIONADMINISTRATION}
  else if (type_ = 'TFhirMedicationAdministration') then
    result := parseMedicationAdministration(jsn)
{$ENDIF FHIR_MEDICATIONADMINISTRATION}
{$IFDEF FHIR_MEDICATIONDISPENSE}
  else if (type_ = 'TFhirMedicationDispense') then
    result := parseMedicationDispense(jsn)
{$ENDIF FHIR_MEDICATIONDISPENSE}
{$IFDEF FHIR_MEDICATIONKNOWLEDGE}
  else if (type_ = 'TFhirMedicationKnowledge') then
    result := parseMedicationKnowledge(jsn)
{$ENDIF FHIR_MEDICATIONKNOWLEDGE}
{$IFDEF FHIR_MEDICATIONREQUEST}
  else if (type_ = 'TFhirMedicationRequest') then
    result := parseMedicationRequest(jsn)
{$ENDIF FHIR_MEDICATIONREQUEST}
{$IFDEF FHIR_MEDICATIONSTATEMENT}
  else if (type_ = 'TFhirMedicationStatement') then
    result := parseMedicationStatement(jsn)
{$ENDIF FHIR_MEDICATIONSTATEMENT}
{$IFDEF FHIR_MEDICINALPRODUCT}
  else if (type_ = 'TFhirMedicinalProduct') then
    result := parseMedicinalProduct(jsn)
{$ENDIF FHIR_MEDICINALPRODUCT}
{$IFDEF FHIR_MEDICINALPRODUCTAUTHORIZATION}
  else if (type_ = 'TFhirMedicinalProductAuthorization') then
    result := parseMedicinalProductAuthorization(jsn)
{$ENDIF FHIR_MEDICINALPRODUCTAUTHORIZATION}
{$IFDEF FHIR_MEDICINALPRODUCTCONTRAINDICATION}
  else if (type_ = 'TFhirMedicinalProductContraindication') then
    result := parseMedicinalProductContraindication(jsn)
{$ENDIF FHIR_MEDICINALPRODUCTCONTRAINDICATION}
{$IFDEF FHIR_MEDICINALPRODUCTINDICATION}
  else if (type_ = 'TFhirMedicinalProductIndication') then
    result := parseMedicinalProductIndication(jsn)
{$ENDIF FHIR_MEDICINALPRODUCTINDICATION}
{$IFDEF FHIR_MEDICINALPRODUCTINGREDIENT}
  else if (type_ = 'TFhirMedicinalProductIngredient') then
    result := parseMedicinalProductIngredient(jsn)
{$ENDIF FHIR_MEDICINALPRODUCTINGREDIENT}
{$IFDEF FHIR_MEDICINALPRODUCTINTERACTION}
  else if (type_ = 'TFhirMedicinalProductInteraction') then
    result := parseMedicinalProductInteraction(jsn)
{$ENDIF FHIR_MEDICINALPRODUCTINTERACTION}
{$IFDEF FHIR_MEDICINALPRODUCTMANUFACTURED}
  else if (type_ = 'TFhirMedicinalProductManufactured') then
    result := parseMedicinalProductManufactured(jsn)
{$ENDIF FHIR_MEDICINALPRODUCTMANUFACTURED}
{$IFDEF FHIR_MEDICINALPRODUCTPACKAGED}
  else if (type_ = 'TFhirMedicinalProductPackaged') then
    result := parseMedicinalProductPackaged(jsn)
{$ENDIF FHIR_MEDICINALPRODUCTPACKAGED}
{$IFDEF FHIR_MEDICINALPRODUCTPHARMACEUTICAL}
  else if (type_ = 'TFhirMedicinalProductPharmaceutical') then
    result := parseMedicinalProductPharmaceutical(jsn)
{$ENDIF FHIR_MEDICINALPRODUCTPHARMACEUTICAL}
{$IFDEF FHIR_MEDICINALPRODUCTUNDESIRABLEEFFECT}
  else if (type_ = 'TFhirMedicinalProductUndesirableEffect') then
    result := parseMedicinalProductUndesirableEffect(jsn)
{$ENDIF FHIR_MEDICINALPRODUCTUNDESIRABLEEFFECT}
{$IFDEF FHIR_MESSAGEDEFINITION}
  else if (type_ = 'TFhirMessageDefinition') then
    result := parseMessageDefinition(jsn)
{$ENDIF FHIR_MESSAGEDEFINITION}
{$IFDEF FHIR_MESSAGEHEADER}
  else if (type_ = 'TFhirMessageHeader') then
    result := parseMessageHeader(jsn)
{$ENDIF FHIR_MESSAGEHEADER}
{$IFDEF FHIR_MOLECULARSEQUENCE}
  else if (type_ = 'TFhirMolecularSequence') then
    result := parseMolecularSequence(jsn)
{$ENDIF FHIR_MOLECULARSEQUENCE}
{$IFDEF FHIR_NAMINGSYSTEM}
  else if (type_ = 'TFhirNamingSystem') then
    result := parseNamingSystem(jsn)
{$ENDIF FHIR_NAMINGSYSTEM}
{$IFDEF FHIR_NUTRITIONORDER}
  else if (type_ = 'TFhirNutritionOrder') then
    result := parseNutritionOrder(jsn)
{$ENDIF FHIR_NUTRITIONORDER}
{$IFDEF FHIR_OBSERVATION}
  else if (type_ = 'TFhirObservation') then
    result := parseObservation(jsn)
{$ENDIF FHIR_OBSERVATION}
{$IFDEF FHIR_OBSERVATIONDEFINITION}
  else if (type_ = 'TFhirObservationDefinition') then
    result := parseObservationDefinition(jsn)
{$ENDIF FHIR_OBSERVATIONDEFINITION}
{$IFDEF FHIR_OPERATIONDEFINITION}
  else if (type_ = 'TFhirOperationDefinition') then
    result := parseOperationDefinition(jsn)
{$ENDIF FHIR_OPERATIONDEFINITION}
{$IFDEF FHIR_OPERATIONOUTCOME}
  else if (type_ = 'TFhirOperationOutcome') then
    result := parseOperationOutcome(jsn)
{$ENDIF FHIR_OPERATIONOUTCOME}
{$IFDEF FHIR_ORGANIZATION}
  else if (type_ = 'TFhirOrganization') then
    result := parseOrganization(jsn)
{$ENDIF FHIR_ORGANIZATION}
{$IFDEF FHIR_ORGANIZATIONAFFILIATION}
  else if (type_ = 'TFhirOrganizationAffiliation') then
    result := parseOrganizationAffiliation(jsn)
{$ENDIF FHIR_ORGANIZATIONAFFILIATION}
{$IFDEF FHIR_PATIENT}
  else if (type_ = 'TFhirPatient') then
    result := parsePatient(jsn)
{$ENDIF FHIR_PATIENT}
{$IFDEF FHIR_PAYMENTNOTICE}
  else if (type_ = 'TFhirPaymentNotice') then
    result := parsePaymentNotice(jsn)
{$ENDIF FHIR_PAYMENTNOTICE}
{$IFDEF FHIR_PAYMENTRECONCILIATION}
  else if (type_ = 'TFhirPaymentReconciliation') then
    result := parsePaymentReconciliation(jsn)
{$ENDIF FHIR_PAYMENTRECONCILIATION}
{$IFDEF FHIR_PERSON}
  else if (type_ = 'TFhirPerson') then
    result := parsePerson(jsn)
{$ENDIF FHIR_PERSON}
{$IFDEF FHIR_PLANDEFINITION}
  else if (type_ = 'TFhirPlanDefinition') then
    result := parsePlanDefinition(jsn)
{$ENDIF FHIR_PLANDEFINITION}
{$IFDEF FHIR_PRACTITIONER}
  else if (type_ = 'TFhirPractitioner') then
    result := parsePractitioner(jsn)
{$ENDIF FHIR_PRACTITIONER}
{$IFDEF FHIR_PRACTITIONERROLE}
  else if (type_ = 'TFhirPractitionerRole') then
    result := parsePractitionerRole(jsn)
{$ENDIF FHIR_PRACTITIONERROLE}
{$IFDEF FHIR_PROCEDURE}
  else if (type_ = 'TFhirProcedure') then
    result := parseProcedure(jsn)
{$ENDIF FHIR_PROCEDURE}
{$IFDEF FHIR_PROVENANCE}
  else if (type_ = 'TFhirProvenance') then
    result := parseProvenance(jsn)
{$ENDIF FHIR_PROVENANCE}
{$IFDEF FHIR_QUESTIONNAIRE}
  else if (type_ = 'TFhirQuestionnaire') then
    result := parseQuestionnaire(jsn)
{$ENDIF FHIR_QUESTIONNAIRE}
{$IFDEF FHIR_QUESTIONNAIRERESPONSE}
  else if (type_ = 'TFhirQuestionnaireResponse') then
    result := parseQuestionnaireResponse(jsn)
{$ENDIF FHIR_QUESTIONNAIRERESPONSE}
{$IFDEF FHIR_RELATEDPERSON}
  else if (type_ = 'TFhirRelatedPerson') then
    result := parseRelatedPerson(jsn)
{$ENDIF FHIR_RELATEDPERSON}
{$IFDEF FHIR_REQUESTGROUP}
  else if (type_ = 'TFhirRequestGroup') then
    result := parseRequestGroup(jsn)
{$ENDIF FHIR_REQUESTGROUP}
{$IFDEF FHIR_RESEARCHDEFINITION}
  else if (type_ = 'TFhirResearchDefinition') then
    result := parseResearchDefinition(jsn)
{$ENDIF FHIR_RESEARCHDEFINITION}
{$IFDEF FHIR_RESEARCHELEMENTDEFINITION}
  else if (type_ = 'TFhirResearchElementDefinition') then
    result := parseResearchElementDefinition(jsn)
{$ENDIF FHIR_RESEARCHELEMENTDEFINITION}
{$IFDEF FHIR_RESEARCHSTUDY}
  else if (type_ = 'TFhirResearchStudy') then
    result := parseResearchStudy(jsn)
{$ENDIF FHIR_RESEARCHSTUDY}
{$IFDEF FHIR_RESEARCHSUBJECT}
  else if (type_ = 'TFhirResearchSubject') then
    result := parseResearchSubject(jsn)
{$ENDIF FHIR_RESEARCHSUBJECT}
{$IFDEF FHIR_RISKASSESSMENT}
  else if (type_ = 'TFhirRiskAssessment') then
    result := parseRiskAssessment(jsn)
{$ENDIF FHIR_RISKASSESSMENT}
{$IFDEF FHIR_RISKEVIDENCESYNTHESIS}
  else if (type_ = 'TFhirRiskEvidenceSynthesis') then
    result := parseRiskEvidenceSynthesis(jsn)
{$ENDIF FHIR_RISKEVIDENCESYNTHESIS}
{$IFDEF FHIR_SCHEDULE}
  else if (type_ = 'TFhirSchedule') then
    result := parseSchedule(jsn)
{$ENDIF FHIR_SCHEDULE}
{$IFDEF FHIR_SEARCHPARAMETER}
  else if (type_ = 'TFhirSearchParameter') then
    result := parseSearchParameter(jsn)
{$ENDIF FHIR_SEARCHPARAMETER}
{$IFDEF FHIR_SERVICEREQUEST}
  else if (type_ = 'TFhirServiceRequest') then
    result := parseServiceRequest(jsn)
{$ENDIF FHIR_SERVICEREQUEST}
{$IFDEF FHIR_SLOT}
  else if (type_ = 'TFhirSlot') then
    result := parseSlot(jsn)
{$ENDIF FHIR_SLOT}
{$IFDEF FHIR_SPECIMEN}
  else if (type_ = 'TFhirSpecimen') then
    result := parseSpecimen(jsn)
{$ENDIF FHIR_SPECIMEN}
{$IFDEF FHIR_SPECIMENDEFINITION}
  else if (type_ = 'TFhirSpecimenDefinition') then
    result := parseSpecimenDefinition(jsn)
{$ENDIF FHIR_SPECIMENDEFINITION}
{$IFDEF FHIR_STRUCTUREDEFINITION}
  else if (type_ = 'TFhirStructureDefinition') then
    result := parseStructureDefinition(jsn)
{$ENDIF FHIR_STRUCTUREDEFINITION}
{$IFDEF FHIR_STRUCTUREMAP}
  else if (type_ = 'TFhirStructureMap') then
    result := parseStructureMap(jsn)
{$ENDIF FHIR_STRUCTUREMAP}
{$IFDEF FHIR_SUBSCRIPTION}
  else if (type_ = 'TFhirSubscription') then
    result := parseSubscription(jsn)
{$ENDIF FHIR_SUBSCRIPTION}
{$IFDEF FHIR_SUBSTANCE}
  else if (type_ = 'TFhirSubstance') then
    result := parseSubstance(jsn)
{$ENDIF FHIR_SUBSTANCE}
{$IFDEF FHIR_SUBSTANCENUCLEICACID}
  else if (type_ = 'TFhirSubstanceNucleicAcid') then
    result := parseSubstanceNucleicAcid(jsn)
{$ENDIF FHIR_SUBSTANCENUCLEICACID}
{$IFDEF FHIR_SUBSTANCEPOLYMER}
  else if (type_ = 'TFhirSubstancePolymer') then
    result := parseSubstancePolymer(jsn)
{$ENDIF FHIR_SUBSTANCEPOLYMER}
{$IFDEF FHIR_SUBSTANCEPROTEIN}
  else if (type_ = 'TFhirSubstanceProtein') then
    result := parseSubstanceProtein(jsn)
{$ENDIF FHIR_SUBSTANCEPROTEIN}
{$IFDEF FHIR_SUBSTANCEREFERENCEINFORMATION}
  else if (type_ = 'TFhirSubstanceReferenceInformation') then
    result := parseSubstanceReferenceInformation(jsn)
{$ENDIF FHIR_SUBSTANCEREFERENCEINFORMATION}
{$IFDEF FHIR_SUBSTANCESOURCEMATERIAL}
  else if (type_ = 'TFhirSubstanceSourceMaterial') then
    result := parseSubstanceSourceMaterial(jsn)
{$ENDIF FHIR_SUBSTANCESOURCEMATERIAL}
{$IFDEF FHIR_SUBSTANCESPECIFICATION}
  else if (type_ = 'TFhirSubstanceSpecification') then
    result := parseSubstanceSpecification(jsn)
{$ENDIF FHIR_SUBSTANCESPECIFICATION}
{$IFDEF FHIR_SUPPLYDELIVERY}
  else if (type_ = 'TFhirSupplyDelivery') then
    result := parseSupplyDelivery(jsn)
{$ENDIF FHIR_SUPPLYDELIVERY}
{$IFDEF FHIR_SUPPLYREQUEST}
  else if (type_ = 'TFhirSupplyRequest') then
    result := parseSupplyRequest(jsn)
{$ENDIF FHIR_SUPPLYREQUEST}
{$IFDEF FHIR_TASK}
  else if (type_ = 'TFhirTask') then
    result := parseTask(jsn)
{$ENDIF FHIR_TASK}
{$IFDEF FHIR_TERMINOLOGYCAPABILITIES}
  else if (type_ = 'TFhirTerminologyCapabilities') then
    result := parseTerminologyCapabilities(jsn)
{$ENDIF FHIR_TERMINOLOGYCAPABILITIES}
{$IFDEF FHIR_TESTREPORT}
  else if (type_ = 'TFhirTestReport') then
    result := parseTestReport(jsn)
{$ENDIF FHIR_TESTREPORT}
{$IFDEF FHIR_TESTSCRIPT}
  else if (type_ = 'TFhirTestScript') then
    result := parseTestScript(jsn)
{$ENDIF FHIR_TESTSCRIPT}
{$IFDEF FHIR_VALUESET}
  else if (type_ = 'TFhirValueSet') then
    result := parseValueSet(jsn)
{$ENDIF FHIR_VALUESET}
{$IFDEF FHIR_VERIFICATIONRESULT}
  else if (type_ = 'TFhirVerificationResult') then
    result := parseVerificationResult(jsn)
{$ENDIF FHIR_VERIFICATIONRESULT}
{$IFDEF FHIR_VISIONPRESCRIPTION}
  else if (type_ = 'TFhirVisionPrescription') then
    result := parseVisionPrescription(jsn)
{$ENDIF FHIR_VISIONPRESCRIPTION}
  else
    raise EJsonException.create('error: the element '+type_+' is not a valid fragment name');
end;

function TFHIRJsonParser.ParseDataType(jsn : TJsonObject; name : String; type_ : TFHIRTypeClass) : TFHIRType;
begin
   if (type_ = TFhirExtension) then
    result := parseExtension(jsn)
  else if (type_ = TFhirNarrative) then
    result := parseNarrative(jsn)
  else if (type_ = TFhirContributor) then
    result := parseContributor(jsn)
  else if (type_ = TFhirAttachment) then
    result := parseAttachment(jsn)
  else if (type_ = TFhirDataRequirement) then
    result := parseDataRequirement(jsn)
  else if (type_ = TFhirDosage) then
    result := parseDosage(jsn)
  else if (type_ = TFhirMoney) then
    result := parseMoney(jsn)
  else if (type_ = TFhirMarketingStatus) then
    result := parseMarketingStatus(jsn)
  else if (type_ = TFhirIdentifier) then
    result := parseIdentifier(jsn)
  else if (type_ = TFhirSubstanceAmount) then
    result := parseSubstanceAmount(jsn)
  else if (type_ = TFhirCoding) then
    result := parseCoding(jsn)
  else if (type_ = TFhirSampledData) then
    result := parseSampledData(jsn)
  else if (type_ = TFhirPopulation) then
    result := parsePopulation(jsn)
  else if (type_ = TFhirRatio) then
    result := parseRatio(jsn)
  else if (type_ = TFhirReference) then
    result := parseReference(jsn)
  else if (type_ = TFhirTriggerDefinition) then
    result := parseTriggerDefinition(jsn)
  else if (type_ = TFhirPeriod) then
    result := parsePeriod(jsn)
  else if (type_ = TFhirQuantity) then
    result := parseQuantity(jsn)
  else if (type_ = TFhirRange) then
    result := parseRange(jsn)
  else if (type_ = TFhirRelatedArtifact) then
    result := parseRelatedArtifact(jsn)
  else if (type_ = TFhirAnnotation) then
    result := parseAnnotation(jsn)
  else if (type_ = TFhirProductShelfLife) then
    result := parseProductShelfLife(jsn)
  else if (type_ = TFhirContactDetail) then
    result := parseContactDetail(jsn)
  else if (type_ = TFhirExpression) then
    result := parseExpression(jsn)
  else if (type_ = TFhirUsageContext) then
    result := parseUsageContext(jsn)
  else if (type_ = TFhirSignature) then
    result := parseSignature(jsn)
  else if (type_ = TFhirProdCharacteristic) then
    result := parseProdCharacteristic(jsn)
  else if (type_ = TFhirCodeableConcept) then
    result := parseCodeableConcept(jsn)
  else if (type_ = TFhirParameterDefinition) then
    result := parseParameterDefinition(jsn)
  else if (type_ = TFhirContactPoint) then
    result := parseContactPoint(jsn)
  else if (type_ = TFhirHumanName) then
    result := parseHumanName(jsn)
  else if (type_ = TFhirMeta) then
    result := parseMeta(jsn)
  else if (type_ = TFhirAddress) then
    result := parseAddress(jsn)
  else if (type_ = TFhirElementDefinition) then
    result := parseElementDefinition(jsn)
  else if (type_ = TFhirTiming) then
    result := parseTiming(jsn)
  else if (type_ = TFhirCount) then
    result := parseCount(jsn)
  else if (type_ = TFhirAge) then
    result := parseAge(jsn)
  else if (type_ = TFhirDistance) then
    result := parseDistance(jsn)
  else if (type_ = TFhirDuration) then
    result := parseDuration(jsn)
  else
    raise EJsonException.create('Unknown Type');
end;

procedure TFHIRJsonComposer.ComposeBase(json: TJSONWriter; name: String; base: TFHIRObject);
begin
   if (base is TFhirDate) then
    composeDateValue(json, name, TFhirDate(base), false)
  else if (base is TFhirDateTime) then
    composeDateTimeValue(json, name, TFhirDateTime(base), false)
  else if (base is TFhirString) then
    composeStringValue(json, name, TFhirString(base), false)
  else if (base is TFhirInteger) then
    composeIntegerValue(json, name, TFhirInteger(base), false)
  else if (base is TFhirUri) then
    composeUriValue(json, name, TFhirUri(base), false)
  else if (base is TFhirInstant) then
    composeInstantValue(json, name, TFhirInstant(base), false)
  else if (base is TFhirXhtml) then
    composeXhtmlValue(json, name, TFhirXhtml(base), false)
  else if (base is TFhirBoolean) then
    composeBooleanValue(json, name, TFhirBoolean(base), false)
  else if (base is TFhirBase64Binary) then
    composeBase64BinaryValue(json, name, TFhirBase64Binary(base), false)
  else if (base is TFhirTime) then
    composeTimeValue(json, name, TFhirTime(base), false)
  else if (base is TFhirDecimal) then
    composeDecimalValue(json, name, TFhirDecimal(base), false)
  else if (base is TFhirCode) then
    composeCodeValue(json, name, TFhirCode(base), false)
  else if (base is TFhirCanonical) then
    composeCanonicalValue(json, name, TFhirCanonical(base), false)
  else if (base is TFhirOid) then
    composeOidValue(json, name, TFhirOid(base), false)
  else if (base is TFhirUuid) then
    composeUuidValue(json, name, TFhirUuid(base), false)
  else if (base is TFhirUrl) then
    composeUrlValue(json, name, TFhirUrl(base), false)
  else if (base is TFhirMarkdown) then
    composeMarkdownValue(json, name, TFhirMarkdown(base), false)
  else if (base is TFhirUnsignedInt) then
    composeUnsignedIntValue(json, name, TFhirUnsignedInt(base), false)
  else if (base is TFhirId) then
    composeIdValue(json, name, TFhirId(base), false)
  else if (base is TFhirPositiveInt) then
    composePositiveIntValue(json, name, TFhirPositiveInt(base), false)
{$IFDEF FHIR_PARAMETERS}
  else if (base is TFhirParametersParameter) then
    composeParametersParameter(json, name, TFhirParametersParameter(base), false)
  else if (base is TFhirParameters) then
    composeParameters(json, name, TFhirParameters(base), false)
{$ENDIF FHIR_PARAMETERS}
  else if (base is TFhirExtension) then
    composeExtension(json, name, TFhirExtension(base), false)
  else if (base is TFhirNarrative) then
    composeNarrative(json, name, TFhirNarrative(base), false)
  else if (base is TFhirContributor) then
    composeContributor(json, name, TFhirContributor(base), false)
  else if (base is TFhirAttachment) then
    composeAttachment(json, name, TFhirAttachment(base), false)
  else if (base is TFhirDataRequirementCodeFilter) then
    composeDataRequirementCodeFilter(json, name, TFhirDataRequirementCodeFilter(base), false)
  else if (base is TFhirDataRequirementDateFilter) then
    composeDataRequirementDateFilter(json, name, TFhirDataRequirementDateFilter(base), false)
  else if (base is TFhirDataRequirementSort) then
    composeDataRequirementSort(json, name, TFhirDataRequirementSort(base), false)
  else if (base is TFhirDataRequirement) then
    composeDataRequirement(json, name, TFhirDataRequirement(base), false)
  else if (base is TFhirDosageDoseAndRate) then
    composeDosageDoseAndRate(json, name, TFhirDosageDoseAndRate(base), false)
  else if (base is TFhirDosage) then
    composeDosage(json, name, TFhirDosage(base), false)
  else if (base is TFhirMoney) then
    composeMoney(json, name, TFhirMoney(base), false)
  else if (base is TFhirMarketingStatus) then
    composeMarketingStatus(json, name, TFhirMarketingStatus(base), false)
  else if (base is TFhirIdentifier) then
    composeIdentifier(json, name, TFhirIdentifier(base), false)
  else if (base is TFhirSubstanceAmountReferenceRange) then
    composeSubstanceAmountReferenceRange(json, name, TFhirSubstanceAmountReferenceRange(base), false)
  else if (base is TFhirSubstanceAmount) then
    composeSubstanceAmount(json, name, TFhirSubstanceAmount(base), false)
  else if (base is TFhirCoding) then
    composeCoding(json, name, TFhirCoding(base), false)
  else if (base is TFhirSampledData) then
    composeSampledData(json, name, TFhirSampledData(base), false)
  else if (base is TFhirPopulation) then
    composePopulation(json, name, TFhirPopulation(base), false)
  else if (base is TFhirRatio) then
    composeRatio(json, name, TFhirRatio(base), false)
  else if (base is TFhirReference) then
    composeReference(json, name, TFhirReference(base), false)
  else if (base is TFhirTriggerDefinition) then
    composeTriggerDefinition(json, name, TFhirTriggerDefinition(base), false)
  else if (base is TFhirPeriod) then
    composePeriod(json, name, TFhirPeriod(base), false)
  else if (base is TFhirQuantity) then
    composeQuantity(json, name, TFhirQuantity(base), false)
  else if (base is TFhirRange) then
    composeRange(json, name, TFhirRange(base), false)
  else if (base is TFhirRelatedArtifact) then
    composeRelatedArtifact(json, name, TFhirRelatedArtifact(base), false)
  else if (base is TFhirAnnotation) then
    composeAnnotation(json, name, TFhirAnnotation(base), false)
  else if (base is TFhirProductShelfLife) then
    composeProductShelfLife(json, name, TFhirProductShelfLife(base), false)
  else if (base is TFhirContactDetail) then
    composeContactDetail(json, name, TFhirContactDetail(base), false)
  else if (base is TFhirExpression) then
    composeExpression(json, name, TFhirExpression(base), false)
  else if (base is TFhirUsageContext) then
    composeUsageContext(json, name, TFhirUsageContext(base), false)
  else if (base is TFhirSignature) then
    composeSignature(json, name, TFhirSignature(base), false)
  else if (base is TFhirProdCharacteristic) then
    composeProdCharacteristic(json, name, TFhirProdCharacteristic(base), false)
  else if (base is TFhirCodeableConcept) then
    composeCodeableConcept(json, name, TFhirCodeableConcept(base), false)
  else if (base is TFhirParameterDefinition) then
    composeParameterDefinition(json, name, TFhirParameterDefinition(base), false)
  else if (base is TFhirContactPoint) then
    composeContactPoint(json, name, TFhirContactPoint(base), false)
  else if (base is TFhirHumanName) then
    composeHumanName(json, name, TFhirHumanName(base), false)
  else if (base is TFhirMeta) then
    composeMeta(json, name, TFhirMeta(base), false)
  else if (base is TFhirAddress) then
    composeAddress(json, name, TFhirAddress(base), false)
  else if (base is TFhirElementDefinitionSlicing) then
    composeElementDefinitionSlicing(json, name, TFhirElementDefinitionSlicing(base), false)
  else if (base is TFhirElementDefinitionSlicingDiscriminator) then
    composeElementDefinitionSlicingDiscriminator(json, name, TFhirElementDefinitionSlicingDiscriminator(base), false)
  else if (base is TFhirElementDefinitionBase) then
    composeElementDefinitionBase(json, name, TFhirElementDefinitionBase(base), false)
  else if (base is TFhirElementDefinitionType) then
    composeElementDefinitionType(json, name, TFhirElementDefinitionType(base), false)
  else if (base is TFhirElementDefinitionExample) then
    composeElementDefinitionExample(json, name, TFhirElementDefinitionExample(base), false)
  else if (base is TFhirElementDefinitionConstraint) then
    composeElementDefinitionConstraint(json, name, TFhirElementDefinitionConstraint(base), false)
  else if (base is TFhirElementDefinitionBinding) then
    composeElementDefinitionBinding(json, name, TFhirElementDefinitionBinding(base), false)
  else if (base is TFhirElementDefinitionMapping) then
    composeElementDefinitionMapping(json, name, TFhirElementDefinitionMapping(base), false)
  else if (base is TFhirElementDefinition) then
    composeElementDefinition(json, name, TFhirElementDefinition(base), false)
  else if (base is TFhirTimingRepeat) then
    composeTimingRepeat(json, name, TFhirTimingRepeat(base), false)
  else if (base is TFhirTiming) then
    composeTiming(json, name, TFhirTiming(base), false)
  else if (base is TFhirCount) then
    composeCount(json, name, TFhirCount(base), false)
  else if (base is TFhirAge) then
    composeAge(json, name, TFhirAge(base), false)
  else if (base is TFhirDistance) then
    composeDistance(json, name, TFhirDistance(base), false)
  else if (base is TFhirDuration) then
    composeDuration(json, name, TFhirDuration(base), false)
{$IFDEF FHIR_ACCOUNT}
  else if (base is TFhirAccountCoverage) then
    composeAccountCoverage(json, name, TFhirAccountCoverage(base), false)
  else if (base is TFhirAccountGuarantor) then
    composeAccountGuarantor(json, name, TFhirAccountGuarantor(base), false)
  else if (base is TFhirAccount) then
    composeAccount(json, name, TFhirAccount(base), false)
{$ENDIF FHIR_ACCOUNT}
{$IFDEF FHIR_ACTIVITYDEFINITION}
  else if (base is TFhirActivityDefinitionParticipant) then
    composeActivityDefinitionParticipant(json, name, TFhirActivityDefinitionParticipant(base), false)
  else if (base is TFhirActivityDefinitionDynamicValue) then
    composeActivityDefinitionDynamicValue(json, name, TFhirActivityDefinitionDynamicValue(base), false)
  else if (base is TFhirActivityDefinition) then
    composeActivityDefinition(json, name, TFhirActivityDefinition(base), false)
{$ENDIF FHIR_ACTIVITYDEFINITION}
{$IFDEF FHIR_ADVERSEEVENT}
  else if (base is TFhirAdverseEventSuspectEntity) then
    composeAdverseEventSuspectEntity(json, name, TFhirAdverseEventSuspectEntity(base), false)
  else if (base is TFhirAdverseEventSuspectEntityCausality) then
    composeAdverseEventSuspectEntityCausality(json, name, TFhirAdverseEventSuspectEntityCausality(base), false)
  else if (base is TFhirAdverseEvent) then
    composeAdverseEvent(json, name, TFhirAdverseEvent(base), false)
{$ENDIF FHIR_ADVERSEEVENT}
{$IFDEF FHIR_ALLERGYINTOLERANCE}
  else if (base is TFhirAllergyIntoleranceReaction) then
    composeAllergyIntoleranceReaction(json, name, TFhirAllergyIntoleranceReaction(base), false)
  else if (base is TFhirAllergyIntolerance) then
    composeAllergyIntolerance(json, name, TFhirAllergyIntolerance(base), false)
{$ENDIF FHIR_ALLERGYINTOLERANCE}
{$IFDEF FHIR_APPOINTMENT}
  else if (base is TFhirAppointmentParticipant) then
    composeAppointmentParticipant(json, name, TFhirAppointmentParticipant(base), false)
  else if (base is TFhirAppointment) then
    composeAppointment(json, name, TFhirAppointment(base), false)
{$ENDIF FHIR_APPOINTMENT}
{$IFDEF FHIR_APPOINTMENTRESPONSE}
  else if (base is TFhirAppointmentResponse) then
    composeAppointmentResponse(json, name, TFhirAppointmentResponse(base), false)
{$ENDIF FHIR_APPOINTMENTRESPONSE}
{$IFDEF FHIR_AUDITEVENT}
  else if (base is TFhirAuditEventAgent) then
    composeAuditEventAgent(json, name, TFhirAuditEventAgent(base), false)
  else if (base is TFhirAuditEventAgentNetwork) then
    composeAuditEventAgentNetwork(json, name, TFhirAuditEventAgentNetwork(base), false)
  else if (base is TFhirAuditEventSource) then
    composeAuditEventSource(json, name, TFhirAuditEventSource(base), false)
  else if (base is TFhirAuditEventEntity) then
    composeAuditEventEntity(json, name, TFhirAuditEventEntity(base), false)
  else if (base is TFhirAuditEventEntityDetail) then
    composeAuditEventEntityDetail(json, name, TFhirAuditEventEntityDetail(base), false)
  else if (base is TFhirAuditEvent) then
    composeAuditEvent(json, name, TFhirAuditEvent(base), false)
{$ENDIF FHIR_AUDITEVENT}
{$IFDEF FHIR_BASIC}
  else if (base is TFhirBasic) then
    composeBasic(json, name, TFhirBasic(base), false)
{$ENDIF FHIR_BASIC}
{$IFDEF FHIR_BINARY}
  else if (base is TFhirBinary) then
    composeBinary(json, name, TFhirBinary(base), false)
{$ENDIF FHIR_BINARY}
{$IFDEF FHIR_BIOLOGICALLYDERIVEDPRODUCT}
  else if (base is TFhirBiologicallyDerivedProductCollection) then
    composeBiologicallyDerivedProductCollection(json, name, TFhirBiologicallyDerivedProductCollection(base), false)
  else if (base is TFhirBiologicallyDerivedProductProcessing) then
    composeBiologicallyDerivedProductProcessing(json, name, TFhirBiologicallyDerivedProductProcessing(base), false)
  else if (base is TFhirBiologicallyDerivedProductManipulation) then
    composeBiologicallyDerivedProductManipulation(json, name, TFhirBiologicallyDerivedProductManipulation(base), false)
  else if (base is TFhirBiologicallyDerivedProductStorage) then
    composeBiologicallyDerivedProductStorage(json, name, TFhirBiologicallyDerivedProductStorage(base), false)
  else if (base is TFhirBiologicallyDerivedProduct) then
    composeBiologicallyDerivedProduct(json, name, TFhirBiologicallyDerivedProduct(base), false)
{$ENDIF FHIR_BIOLOGICALLYDERIVEDPRODUCT}
{$IFDEF FHIR_BODYSTRUCTURE}
  else if (base is TFhirBodyStructure) then
    composeBodyStructure(json, name, TFhirBodyStructure(base), false)
{$ENDIF FHIR_BODYSTRUCTURE}
{$IFDEF FHIR_BUNDLE}
  else if (base is TFhirBundleLink) then
    composeBundleLink(json, name, TFhirBundleLink(base), false)
  else if (base is TFhirBundleEntry) then
    composeBundleEntry(json, name, TFhirBundleEntry(base), false)
  else if (base is TFhirBundleEntrySearch) then
    composeBundleEntrySearch(json, name, TFhirBundleEntrySearch(base), false)
  else if (base is TFhirBundleEntryRequest) then
    composeBundleEntryRequest(json, name, TFhirBundleEntryRequest(base), false)
  else if (base is TFhirBundleEntryResponse) then
    composeBundleEntryResponse(json, name, TFhirBundleEntryResponse(base), false)
  else if (base is TFhirBundle) then
    composeBundle(json, name, TFhirBundle(base), false)
{$ENDIF FHIR_BUNDLE}
{$IFDEF FHIR_CAPABILITYSTATEMENT}
  else if (base is TFhirCapabilityStatementSoftware) then
    composeCapabilityStatementSoftware(json, name, TFhirCapabilityStatementSoftware(base), false)
  else if (base is TFhirCapabilityStatementImplementation) then
    composeCapabilityStatementImplementation(json, name, TFhirCapabilityStatementImplementation(base), false)
  else if (base is TFhirCapabilityStatementRest) then
    composeCapabilityStatementRest(json, name, TFhirCapabilityStatementRest(base), false)
  else if (base is TFhirCapabilityStatementRestSecurity) then
    composeCapabilityStatementRestSecurity(json, name, TFhirCapabilityStatementRestSecurity(base), false)
  else if (base is TFhirCapabilityStatementRestResource) then
    composeCapabilityStatementRestResource(json, name, TFhirCapabilityStatementRestResource(base), false)
  else if (base is TFhirCapabilityStatementRestResourceInteraction) then
    composeCapabilityStatementRestResourceInteraction(json, name, TFhirCapabilityStatementRestResourceInteraction(base), false)
  else if (base is TFhirCapabilityStatementRestResourceSearchParam) then
    composeCapabilityStatementRestResourceSearchParam(json, name, TFhirCapabilityStatementRestResourceSearchParam(base), false)
  else if (base is TFhirCapabilityStatementRestResourceOperation) then
    composeCapabilityStatementRestResourceOperation(json, name, TFhirCapabilityStatementRestResourceOperation(base), false)
  else if (base is TFhirCapabilityStatementRestInteraction) then
    composeCapabilityStatementRestInteraction(json, name, TFhirCapabilityStatementRestInteraction(base), false)
  else if (base is TFhirCapabilityStatementMessaging) then
    composeCapabilityStatementMessaging(json, name, TFhirCapabilityStatementMessaging(base), false)
  else if (base is TFhirCapabilityStatementMessagingEndpoint) then
    composeCapabilityStatementMessagingEndpoint(json, name, TFhirCapabilityStatementMessagingEndpoint(base), false)
  else if (base is TFhirCapabilityStatementMessagingSupportedMessage) then
    composeCapabilityStatementMessagingSupportedMessage(json, name, TFhirCapabilityStatementMessagingSupportedMessage(base), false)
  else if (base is TFhirCapabilityStatementDocument) then
    composeCapabilityStatementDocument(json, name, TFhirCapabilityStatementDocument(base), false)
  else if (base is TFhirCapabilityStatement) then
    composeCapabilityStatement(json, name, TFhirCapabilityStatement(base), false)
{$ENDIF FHIR_CAPABILITYSTATEMENT}
{$IFDEF FHIR_CAREPLAN}
  else if (base is TFhirCarePlanActivity) then
    composeCarePlanActivity(json, name, TFhirCarePlanActivity(base), false)
  else if (base is TFhirCarePlanActivityDetail) then
    composeCarePlanActivityDetail(json, name, TFhirCarePlanActivityDetail(base), false)
  else if (base is TFhirCarePlan) then
    composeCarePlan(json, name, TFhirCarePlan(base), false)
{$ENDIF FHIR_CAREPLAN}
{$IFDEF FHIR_CARETEAM}
  else if (base is TFhirCareTeamParticipant) then
    composeCareTeamParticipant(json, name, TFhirCareTeamParticipant(base), false)
  else if (base is TFhirCareTeam) then
    composeCareTeam(json, name, TFhirCareTeam(base), false)
{$ENDIF FHIR_CARETEAM}
{$IFDEF FHIR_CATALOGENTRY}
  else if (base is TFhirCatalogEntryRelatedEntry) then
    composeCatalogEntryRelatedEntry(json, name, TFhirCatalogEntryRelatedEntry(base), false)
  else if (base is TFhirCatalogEntry) then
    composeCatalogEntry(json, name, TFhirCatalogEntry(base), false)
{$ENDIF FHIR_CATALOGENTRY}
{$IFDEF FHIR_CHARGEITEM}
  else if (base is TFhirChargeItemPerformer) then
    composeChargeItemPerformer(json, name, TFhirChargeItemPerformer(base), false)
  else if (base is TFhirChargeItem) then
    composeChargeItem(json, name, TFhirChargeItem(base), false)
{$ENDIF FHIR_CHARGEITEM}
{$IFDEF FHIR_CHARGEITEMDEFINITION}
  else if (base is TFhirChargeItemDefinitionApplicability) then
    composeChargeItemDefinitionApplicability(json, name, TFhirChargeItemDefinitionApplicability(base), false)
  else if (base is TFhirChargeItemDefinitionPropertyGroup) then
    composeChargeItemDefinitionPropertyGroup(json, name, TFhirChargeItemDefinitionPropertyGroup(base), false)
  else if (base is TFhirChargeItemDefinitionPropertyGroupPriceComponent) then
    composeChargeItemDefinitionPropertyGroupPriceComponent(json, name, TFhirChargeItemDefinitionPropertyGroupPriceComponent(base), false)
  else if (base is TFhirChargeItemDefinition) then
    composeChargeItemDefinition(json, name, TFhirChargeItemDefinition(base), false)
{$ENDIF FHIR_CHARGEITEMDEFINITION}
{$IFDEF FHIR_CLAIM}
  else if (base is TFhirClaimRelated) then
    composeClaimRelated(json, name, TFhirClaimRelated(base), false)
  else if (base is TFhirClaimPayee) then
    composeClaimPayee(json, name, TFhirClaimPayee(base), false)
  else if (base is TFhirClaimCareTeam) then
    composeClaimCareTeam(json, name, TFhirClaimCareTeam(base), false)
  else if (base is TFhirClaimSupportingInfo) then
    composeClaimSupportingInfo(json, name, TFhirClaimSupportingInfo(base), false)
  else if (base is TFhirClaimDiagnosis) then
    composeClaimDiagnosis(json, name, TFhirClaimDiagnosis(base), false)
  else if (base is TFhirClaimProcedure) then
    composeClaimProcedure(json, name, TFhirClaimProcedure(base), false)
  else if (base is TFhirClaimInsurance) then
    composeClaimInsurance(json, name, TFhirClaimInsurance(base), false)
  else if (base is TFhirClaimAccident) then
    composeClaimAccident(json, name, TFhirClaimAccident(base), false)
  else if (base is TFhirClaimItem) then
    composeClaimItem(json, name, TFhirClaimItem(base), false)
  else if (base is TFhirClaimItemDetail) then
    composeClaimItemDetail(json, name, TFhirClaimItemDetail(base), false)
  else if (base is TFhirClaimItemDetailSubDetail) then
    composeClaimItemDetailSubDetail(json, name, TFhirClaimItemDetailSubDetail(base), false)
  else if (base is TFhirClaim) then
    composeClaim(json, name, TFhirClaim(base), false)
{$ENDIF FHIR_CLAIM}
{$IFDEF FHIR_CLAIMRESPONSE}
  else if (base is TFhirClaimResponseItem) then
    composeClaimResponseItem(json, name, TFhirClaimResponseItem(base), false)
  else if (base is TFhirClaimResponseItemAdjudication) then
    composeClaimResponseItemAdjudication(json, name, TFhirClaimResponseItemAdjudication(base), false)
  else if (base is TFhirClaimResponseItemDetail) then
    composeClaimResponseItemDetail(json, name, TFhirClaimResponseItemDetail(base), false)
  else if (base is TFhirClaimResponseItemDetailSubDetail) then
    composeClaimResponseItemDetailSubDetail(json, name, TFhirClaimResponseItemDetailSubDetail(base), false)
  else if (base is TFhirClaimResponseAddItem) then
    composeClaimResponseAddItem(json, name, TFhirClaimResponseAddItem(base), false)
  else if (base is TFhirClaimResponseAddItemDetail) then
    composeClaimResponseAddItemDetail(json, name, TFhirClaimResponseAddItemDetail(base), false)
  else if (base is TFhirClaimResponseAddItemDetailSubDetail) then
    composeClaimResponseAddItemDetailSubDetail(json, name, TFhirClaimResponseAddItemDetailSubDetail(base), false)
  else if (base is TFhirClaimResponseTotal) then
    composeClaimResponseTotal(json, name, TFhirClaimResponseTotal(base), false)
  else if (base is TFhirClaimResponsePayment) then
    composeClaimResponsePayment(json, name, TFhirClaimResponsePayment(base), false)
  else if (base is TFhirClaimResponseProcessNote) then
    composeClaimResponseProcessNote(json, name, TFhirClaimResponseProcessNote(base), false)
  else if (base is TFhirClaimResponseInsurance) then
    composeClaimResponseInsurance(json, name, TFhirClaimResponseInsurance(base), false)
  else if (base is TFhirClaimResponseError) then
    composeClaimResponseError(json, name, TFhirClaimResponseError(base), false)
  else if (base is TFhirClaimResponse) then
    composeClaimResponse(json, name, TFhirClaimResponse(base), false)
{$ENDIF FHIR_CLAIMRESPONSE}
{$IFDEF FHIR_CLINICALIMPRESSION}
  else if (base is TFhirClinicalImpressionInvestigation) then
    composeClinicalImpressionInvestigation(json, name, TFhirClinicalImpressionInvestigation(base), false)
  else if (base is TFhirClinicalImpressionFinding) then
    composeClinicalImpressionFinding(json, name, TFhirClinicalImpressionFinding(base), false)
  else if (base is TFhirClinicalImpression) then
    composeClinicalImpression(json, name, TFhirClinicalImpression(base), false)
{$ENDIF FHIR_CLINICALIMPRESSION}
{$IFDEF FHIR_CODESYSTEM}
  else if (base is TFhirCodeSystemFilter) then
    composeCodeSystemFilter(json, name, TFhirCodeSystemFilter(base), false)
  else if (base is TFhirCodeSystemProperty) then
    composeCodeSystemProperty(json, name, TFhirCodeSystemProperty(base), false)
  else if (base is TFhirCodeSystemConcept) then
    composeCodeSystemConcept(json, name, TFhirCodeSystemConcept(base), false)
  else if (base is TFhirCodeSystemConceptDesignation) then
    composeCodeSystemConceptDesignation(json, name, TFhirCodeSystemConceptDesignation(base), false)
  else if (base is TFhirCodeSystemConceptProperty) then
    composeCodeSystemConceptProperty(json, name, TFhirCodeSystemConceptProperty(base), false)
  else if (base is TFhirCodeSystem) then
    composeCodeSystem(json, name, TFhirCodeSystem(base), false)
{$ENDIF FHIR_CODESYSTEM}
{$IFDEF FHIR_COMMUNICATION}
  else if (base is TFhirCommunicationPayload) then
    composeCommunicationPayload(json, name, TFhirCommunicationPayload(base), false)
  else if (base is TFhirCommunication) then
    composeCommunication(json, name, TFhirCommunication(base), false)
{$ENDIF FHIR_COMMUNICATION}
{$IFDEF FHIR_COMMUNICATIONREQUEST}
  else if (base is TFhirCommunicationRequestPayload) then
    composeCommunicationRequestPayload(json, name, TFhirCommunicationRequestPayload(base), false)
  else if (base is TFhirCommunicationRequest) then
    composeCommunicationRequest(json, name, TFhirCommunicationRequest(base), false)
{$ENDIF FHIR_COMMUNICATIONREQUEST}
{$IFDEF FHIR_COMPARTMENTDEFINITION}
  else if (base is TFhirCompartmentDefinitionResource) then
    composeCompartmentDefinitionResource(json, name, TFhirCompartmentDefinitionResource(base), false)
  else if (base is TFhirCompartmentDefinition) then
    composeCompartmentDefinition(json, name, TFhirCompartmentDefinition(base), false)
{$ENDIF FHIR_COMPARTMENTDEFINITION}
{$IFDEF FHIR_COMPOSITION}
  else if (base is TFhirCompositionAttester) then
    composeCompositionAttester(json, name, TFhirCompositionAttester(base), false)
  else if (base is TFhirCompositionRelatesTo) then
    composeCompositionRelatesTo(json, name, TFhirCompositionRelatesTo(base), false)
  else if (base is TFhirCompositionEvent) then
    composeCompositionEvent(json, name, TFhirCompositionEvent(base), false)
  else if (base is TFhirCompositionSection) then
    composeCompositionSection(json, name, TFhirCompositionSection(base), false)
  else if (base is TFhirComposition) then
    composeComposition(json, name, TFhirComposition(base), false)
{$ENDIF FHIR_COMPOSITION}
{$IFDEF FHIR_CONCEPTMAP}
  else if (base is TFhirConceptMapGroup) then
    composeConceptMapGroup(json, name, TFhirConceptMapGroup(base), false)
  else if (base is TFhirConceptMapGroupElement) then
    composeConceptMapGroupElement(json, name, TFhirConceptMapGroupElement(base), false)
  else if (base is TFhirConceptMapGroupElementTarget) then
    composeConceptMapGroupElementTarget(json, name, TFhirConceptMapGroupElementTarget(base), false)
  else if (base is TFhirConceptMapGroupElementTargetDependsOn) then
    composeConceptMapGroupElementTargetDependsOn(json, name, TFhirConceptMapGroupElementTargetDependsOn(base), false)
  else if (base is TFhirConceptMapGroupUnmapped) then
    composeConceptMapGroupUnmapped(json, name, TFhirConceptMapGroupUnmapped(base), false)
  else if (base is TFhirConceptMap) then
    composeConceptMap(json, name, TFhirConceptMap(base), false)
{$ENDIF FHIR_CONCEPTMAP}
{$IFDEF FHIR_CONDITION}
  else if (base is TFhirConditionStage) then
    composeConditionStage(json, name, TFhirConditionStage(base), false)
  else if (base is TFhirConditionEvidence) then
    composeConditionEvidence(json, name, TFhirConditionEvidence(base), false)
  else if (base is TFhirCondition) then
    composeCondition(json, name, TFhirCondition(base), false)
{$ENDIF FHIR_CONDITION}
{$IFDEF FHIR_CONSENT}
  else if (base is TFhirConsentPolicy) then
    composeConsentPolicy(json, name, TFhirConsentPolicy(base), false)
  else if (base is TFhirConsentVerification) then
    composeConsentVerification(json, name, TFhirConsentVerification(base), false)
  else if (base is TFhirConsentProvision) then
    composeConsentProvision(json, name, TFhirConsentProvision(base), false)
  else if (base is TFhirConsentProvisionActor) then
    composeConsentProvisionActor(json, name, TFhirConsentProvisionActor(base), false)
  else if (base is TFhirConsentProvisionData) then
    composeConsentProvisionData(json, name, TFhirConsentProvisionData(base), false)
  else if (base is TFhirConsent) then
    composeConsent(json, name, TFhirConsent(base), false)
{$ENDIF FHIR_CONSENT}
{$IFDEF FHIR_CONTRACT}
  else if (base is TFhirContractContentDefinition) then
    composeContractContentDefinition(json, name, TFhirContractContentDefinition(base), false)
  else if (base is TFhirContractTerm) then
    composeContractTerm(json, name, TFhirContractTerm(base), false)
  else if (base is TFhirContractTermSecurityLabel) then
    composeContractTermSecurityLabel(json, name, TFhirContractTermSecurityLabel(base), false)
  else if (base is TFhirContractTermOffer) then
    composeContractTermOffer(json, name, TFhirContractTermOffer(base), false)
  else if (base is TFhirContractTermOfferParty) then
    composeContractTermOfferParty(json, name, TFhirContractTermOfferParty(base), false)
  else if (base is TFhirContractTermOfferAnswer) then
    composeContractTermOfferAnswer(json, name, TFhirContractTermOfferAnswer(base), false)
  else if (base is TFhirContractTermAsset) then
    composeContractTermAsset(json, name, TFhirContractTermAsset(base), false)
  else if (base is TFhirContractTermAssetContext) then
    composeContractTermAssetContext(json, name, TFhirContractTermAssetContext(base), false)
  else if (base is TFhirContractTermAssetValuedItem) then
    composeContractTermAssetValuedItem(json, name, TFhirContractTermAssetValuedItem(base), false)
  else if (base is TFhirContractTermAction) then
    composeContractTermAction(json, name, TFhirContractTermAction(base), false)
  else if (base is TFhirContractTermActionSubject) then
    composeContractTermActionSubject(json, name, TFhirContractTermActionSubject(base), false)
  else if (base is TFhirContractSigner) then
    composeContractSigner(json, name, TFhirContractSigner(base), false)
  else if (base is TFhirContractFriendly) then
    composeContractFriendly(json, name, TFhirContractFriendly(base), false)
  else if (base is TFhirContractLegal) then
    composeContractLegal(json, name, TFhirContractLegal(base), false)
  else if (base is TFhirContractRule) then
    composeContractRule(json, name, TFhirContractRule(base), false)
  else if (base is TFhirContract) then
    composeContract(json, name, TFhirContract(base), false)
{$ENDIF FHIR_CONTRACT}
{$IFDEF FHIR_COVERAGE}
  else if (base is TFhirCoverageClass) then
    composeCoverageClass(json, name, TFhirCoverageClass(base), false)
  else if (base is TFhirCoverageCostToBeneficiary) then
    composeCoverageCostToBeneficiary(json, name, TFhirCoverageCostToBeneficiary(base), false)
  else if (base is TFhirCoverageCostToBeneficiaryException) then
    composeCoverageCostToBeneficiaryException(json, name, TFhirCoverageCostToBeneficiaryException(base), false)
  else if (base is TFhirCoverage) then
    composeCoverage(json, name, TFhirCoverage(base), false)
{$ENDIF FHIR_COVERAGE}
{$IFDEF FHIR_COVERAGEELIGIBILITYREQUEST}
  else if (base is TFhirCoverageEligibilityRequestSupportingInfo) then
    composeCoverageEligibilityRequestSupportingInfo(json, name, TFhirCoverageEligibilityRequestSupportingInfo(base), false)
  else if (base is TFhirCoverageEligibilityRequestInsurance) then
    composeCoverageEligibilityRequestInsurance(json, name, TFhirCoverageEligibilityRequestInsurance(base), false)
  else if (base is TFhirCoverageEligibilityRequestItem) then
    composeCoverageEligibilityRequestItem(json, name, TFhirCoverageEligibilityRequestItem(base), false)
  else if (base is TFhirCoverageEligibilityRequestItemDiagnosis) then
    composeCoverageEligibilityRequestItemDiagnosis(json, name, TFhirCoverageEligibilityRequestItemDiagnosis(base), false)
  else if (base is TFhirCoverageEligibilityRequest) then
    composeCoverageEligibilityRequest(json, name, TFhirCoverageEligibilityRequest(base), false)
{$ENDIF FHIR_COVERAGEELIGIBILITYREQUEST}
{$IFDEF FHIR_COVERAGEELIGIBILITYRESPONSE}
  else if (base is TFhirCoverageEligibilityResponseInsurance) then
    composeCoverageEligibilityResponseInsurance(json, name, TFhirCoverageEligibilityResponseInsurance(base), false)
  else if (base is TFhirCoverageEligibilityResponseInsuranceItem) then
    composeCoverageEligibilityResponseInsuranceItem(json, name, TFhirCoverageEligibilityResponseInsuranceItem(base), false)
  else if (base is TFhirCoverageEligibilityResponseInsuranceItemBenefit) then
    composeCoverageEligibilityResponseInsuranceItemBenefit(json, name, TFhirCoverageEligibilityResponseInsuranceItemBenefit(base), false)
  else if (base is TFhirCoverageEligibilityResponseError) then
    composeCoverageEligibilityResponseError(json, name, TFhirCoverageEligibilityResponseError(base), false)
  else if (base is TFhirCoverageEligibilityResponse) then
    composeCoverageEligibilityResponse(json, name, TFhirCoverageEligibilityResponse(base), false)
{$ENDIF FHIR_COVERAGEELIGIBILITYRESPONSE}
{$IFDEF FHIR_DETECTEDISSUE}
  else if (base is TFhirDetectedIssueEvidence) then
    composeDetectedIssueEvidence(json, name, TFhirDetectedIssueEvidence(base), false)
  else if (base is TFhirDetectedIssueMitigation) then
    composeDetectedIssueMitigation(json, name, TFhirDetectedIssueMitigation(base), false)
  else if (base is TFhirDetectedIssue) then
    composeDetectedIssue(json, name, TFhirDetectedIssue(base), false)
{$ENDIF FHIR_DETECTEDISSUE}
{$IFDEF FHIR_DEVICE}
  else if (base is TFhirDeviceUdiCarrier) then
    composeDeviceUdiCarrier(json, name, TFhirDeviceUdiCarrier(base), false)
  else if (base is TFhirDeviceDeviceName) then
    composeDeviceDeviceName(json, name, TFhirDeviceDeviceName(base), false)
  else if (base is TFhirDeviceSpecialization) then
    composeDeviceSpecialization(json, name, TFhirDeviceSpecialization(base), false)
  else if (base is TFhirDeviceVersion) then
    composeDeviceVersion(json, name, TFhirDeviceVersion(base), false)
  else if (base is TFhirDeviceProperty) then
    composeDeviceProperty(json, name, TFhirDeviceProperty(base), false)
  else if (base is TFhirDevice) then
    composeDevice(json, name, TFhirDevice(base), false)
{$ENDIF FHIR_DEVICE}
{$IFDEF FHIR_DEVICEDEFINITION}
  else if (base is TFhirDeviceDefinitionUdiDeviceIdentifier) then
    composeDeviceDefinitionUdiDeviceIdentifier(json, name, TFhirDeviceDefinitionUdiDeviceIdentifier(base), false)
  else if (base is TFhirDeviceDefinitionDeviceName) then
    composeDeviceDefinitionDeviceName(json, name, TFhirDeviceDefinitionDeviceName(base), false)
  else if (base is TFhirDeviceDefinitionSpecialization) then
    composeDeviceDefinitionSpecialization(json, name, TFhirDeviceDefinitionSpecialization(base), false)
  else if (base is TFhirDeviceDefinitionCapability) then
    composeDeviceDefinitionCapability(json, name, TFhirDeviceDefinitionCapability(base), false)
  else if (base is TFhirDeviceDefinitionProperty) then
    composeDeviceDefinitionProperty(json, name, TFhirDeviceDefinitionProperty(base), false)
  else if (base is TFhirDeviceDefinitionMaterial) then
    composeDeviceDefinitionMaterial(json, name, TFhirDeviceDefinitionMaterial(base), false)
  else if (base is TFhirDeviceDefinition) then
    composeDeviceDefinition(json, name, TFhirDeviceDefinition(base), false)
{$ENDIF FHIR_DEVICEDEFINITION}
{$IFDEF FHIR_DEVICEMETRIC}
  else if (base is TFhirDeviceMetricCalibration) then
    composeDeviceMetricCalibration(json, name, TFhirDeviceMetricCalibration(base), false)
  else if (base is TFhirDeviceMetric) then
    composeDeviceMetric(json, name, TFhirDeviceMetric(base), false)
{$ENDIF FHIR_DEVICEMETRIC}
{$IFDEF FHIR_DEVICEREQUEST}
  else if (base is TFhirDeviceRequestParameter) then
    composeDeviceRequestParameter(json, name, TFhirDeviceRequestParameter(base), false)
  else if (base is TFhirDeviceRequest) then
    composeDeviceRequest(json, name, TFhirDeviceRequest(base), false)
{$ENDIF FHIR_DEVICEREQUEST}
{$IFDEF FHIR_DEVICEUSESTATEMENT}
  else if (base is TFhirDeviceUseStatement) then
    composeDeviceUseStatement(json, name, TFhirDeviceUseStatement(base), false)
{$ENDIF FHIR_DEVICEUSESTATEMENT}
{$IFDEF FHIR_DIAGNOSTICREPORT}
  else if (base is TFhirDiagnosticReportMedia) then
    composeDiagnosticReportMedia(json, name, TFhirDiagnosticReportMedia(base), false)
  else if (base is TFhirDiagnosticReport) then
    composeDiagnosticReport(json, name, TFhirDiagnosticReport(base), false)
{$ENDIF FHIR_DIAGNOSTICREPORT}
{$IFDEF FHIR_DOCUMENTMANIFEST}
  else if (base is TFhirDocumentManifestRelated) then
    composeDocumentManifestRelated(json, name, TFhirDocumentManifestRelated(base), false)
  else if (base is TFhirDocumentManifest) then
    composeDocumentManifest(json, name, TFhirDocumentManifest(base), false)
{$ENDIF FHIR_DOCUMENTMANIFEST}
{$IFDEF FHIR_DOCUMENTREFERENCE}
  else if (base is TFhirDocumentReferenceRelatesTo) then
    composeDocumentReferenceRelatesTo(json, name, TFhirDocumentReferenceRelatesTo(base), false)
  else if (base is TFhirDocumentReferenceContent) then
    composeDocumentReferenceContent(json, name, TFhirDocumentReferenceContent(base), false)
  else if (base is TFhirDocumentReferenceContext) then
    composeDocumentReferenceContext(json, name, TFhirDocumentReferenceContext(base), false)
  else if (base is TFhirDocumentReference) then
    composeDocumentReference(json, name, TFhirDocumentReference(base), false)
{$ENDIF FHIR_DOCUMENTREFERENCE}
{$IFDEF FHIR_EFFECTEVIDENCESYNTHESIS}
  else if (base is TFhirEffectEvidenceSynthesisSampleSize) then
    composeEffectEvidenceSynthesisSampleSize(json, name, TFhirEffectEvidenceSynthesisSampleSize(base), false)
  else if (base is TFhirEffectEvidenceSynthesisResultsByExposure) then
    composeEffectEvidenceSynthesisResultsByExposure(json, name, TFhirEffectEvidenceSynthesisResultsByExposure(base), false)
  else if (base is TFhirEffectEvidenceSynthesisEffectEstimate) then
    composeEffectEvidenceSynthesisEffectEstimate(json, name, TFhirEffectEvidenceSynthesisEffectEstimate(base), false)
  else if (base is TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate) then
    composeEffectEvidenceSynthesisEffectEstimatePrecisionEstimate(json, name, TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate(base), false)
  else if (base is TFhirEffectEvidenceSynthesisCertainty) then
    composeEffectEvidenceSynthesisCertainty(json, name, TFhirEffectEvidenceSynthesisCertainty(base), false)
  else if (base is TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent) then
    composeEffectEvidenceSynthesisCertaintyCertaintySubcomponent(json, name, TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent(base), false)
  else if (base is TFhirEffectEvidenceSynthesis) then
    composeEffectEvidenceSynthesis(json, name, TFhirEffectEvidenceSynthesis(base), false)
{$ENDIF FHIR_EFFECTEVIDENCESYNTHESIS}
{$IFDEF FHIR_ENCOUNTER}
  else if (base is TFhirEncounterStatusHistory) then
    composeEncounterStatusHistory(json, name, TFhirEncounterStatusHistory(base), false)
  else if (base is TFhirEncounterClassHistory) then
    composeEncounterClassHistory(json, name, TFhirEncounterClassHistory(base), false)
  else if (base is TFhirEncounterParticipant) then
    composeEncounterParticipant(json, name, TFhirEncounterParticipant(base), false)
  else if (base is TFhirEncounterDiagnosis) then
    composeEncounterDiagnosis(json, name, TFhirEncounterDiagnosis(base), false)
  else if (base is TFhirEncounterHospitalization) then
    composeEncounterHospitalization(json, name, TFhirEncounterHospitalization(base), false)
  else if (base is TFhirEncounterLocation) then
    composeEncounterLocation(json, name, TFhirEncounterLocation(base), false)
  else if (base is TFhirEncounter) then
    composeEncounter(json, name, TFhirEncounter(base), false)
{$ENDIF FHIR_ENCOUNTER}
{$IFDEF FHIR_ENDPOINT}
  else if (base is TFhirEndpoint) then
    composeEndpoint(json, name, TFhirEndpoint(base), false)
{$ENDIF FHIR_ENDPOINT}
{$IFDEF FHIR_ENROLLMENTREQUEST}
  else if (base is TFhirEnrollmentRequest) then
    composeEnrollmentRequest(json, name, TFhirEnrollmentRequest(base), false)
{$ENDIF FHIR_ENROLLMENTREQUEST}
{$IFDEF FHIR_ENROLLMENTRESPONSE}
  else if (base is TFhirEnrollmentResponse) then
    composeEnrollmentResponse(json, name, TFhirEnrollmentResponse(base), false)
{$ENDIF FHIR_ENROLLMENTRESPONSE}
{$IFDEF FHIR_EPISODEOFCARE}
  else if (base is TFhirEpisodeOfCareStatusHistory) then
    composeEpisodeOfCareStatusHistory(json, name, TFhirEpisodeOfCareStatusHistory(base), false)
  else if (base is TFhirEpisodeOfCareDiagnosis) then
    composeEpisodeOfCareDiagnosis(json, name, TFhirEpisodeOfCareDiagnosis(base), false)
  else if (base is TFhirEpisodeOfCare) then
    composeEpisodeOfCare(json, name, TFhirEpisodeOfCare(base), false)
{$ENDIF FHIR_EPISODEOFCARE}
{$IFDEF FHIR_EVENTDEFINITION}
  else if (base is TFhirEventDefinition) then
    composeEventDefinition(json, name, TFhirEventDefinition(base), false)
{$ENDIF FHIR_EVENTDEFINITION}
{$IFDEF FHIR_EVIDENCE}
  else if (base is TFhirEvidence) then
    composeEvidence(json, name, TFhirEvidence(base), false)
{$ENDIF FHIR_EVIDENCE}
{$IFDEF FHIR_EVIDENCEVARIABLE}
  else if (base is TFhirEvidenceVariableCharacteristic) then
    composeEvidenceVariableCharacteristic(json, name, TFhirEvidenceVariableCharacteristic(base), false)
  else if (base is TFhirEvidenceVariable) then
    composeEvidenceVariable(json, name, TFhirEvidenceVariable(base), false)
{$ENDIF FHIR_EVIDENCEVARIABLE}
{$IFDEF FHIR_EXAMPLESCENARIO}
  else if (base is TFhirExampleScenarioActor) then
    composeExampleScenarioActor(json, name, TFhirExampleScenarioActor(base), false)
  else if (base is TFhirExampleScenarioInstance) then
    composeExampleScenarioInstance(json, name, TFhirExampleScenarioInstance(base), false)
  else if (base is TFhirExampleScenarioInstanceVersion) then
    composeExampleScenarioInstanceVersion(json, name, TFhirExampleScenarioInstanceVersion(base), false)
  else if (base is TFhirExampleScenarioInstanceContainedInstance) then
    composeExampleScenarioInstanceContainedInstance(json, name, TFhirExampleScenarioInstanceContainedInstance(base), false)
  else if (base is TFhirExampleScenarioProcess) then
    composeExampleScenarioProcess(json, name, TFhirExampleScenarioProcess(base), false)
  else if (base is TFhirExampleScenarioProcessStep) then
    composeExampleScenarioProcessStep(json, name, TFhirExampleScenarioProcessStep(base), false)
  else if (base is TFhirExampleScenarioProcessStepOperation) then
    composeExampleScenarioProcessStepOperation(json, name, TFhirExampleScenarioProcessStepOperation(base), false)
  else if (base is TFhirExampleScenarioProcessStepAlternative) then
    composeExampleScenarioProcessStepAlternative(json, name, TFhirExampleScenarioProcessStepAlternative(base), false)
  else if (base is TFhirExampleScenario) then
    composeExampleScenario(json, name, TFhirExampleScenario(base), false)
{$ENDIF FHIR_EXAMPLESCENARIO}
{$IFDEF FHIR_EXPLANATIONOFBENEFIT}
  else if (base is TFhirExplanationOfBenefitRelated) then
    composeExplanationOfBenefitRelated(json, name, TFhirExplanationOfBenefitRelated(base), false)
  else if (base is TFhirExplanationOfBenefitPayee) then
    composeExplanationOfBenefitPayee(json, name, TFhirExplanationOfBenefitPayee(base), false)
  else if (base is TFhirExplanationOfBenefitCareTeam) then
    composeExplanationOfBenefitCareTeam(json, name, TFhirExplanationOfBenefitCareTeam(base), false)
  else if (base is TFhirExplanationOfBenefitSupportingInfo) then
    composeExplanationOfBenefitSupportingInfo(json, name, TFhirExplanationOfBenefitSupportingInfo(base), false)
  else if (base is TFhirExplanationOfBenefitDiagnosis) then
    composeExplanationOfBenefitDiagnosis(json, name, TFhirExplanationOfBenefitDiagnosis(base), false)
  else if (base is TFhirExplanationOfBenefitProcedure) then
    composeExplanationOfBenefitProcedure(json, name, TFhirExplanationOfBenefitProcedure(base), false)
  else if (base is TFhirExplanationOfBenefitInsurance) then
    composeExplanationOfBenefitInsurance(json, name, TFhirExplanationOfBenefitInsurance(base), false)
  else if (base is TFhirExplanationOfBenefitAccident) then
    composeExplanationOfBenefitAccident(json, name, TFhirExplanationOfBenefitAccident(base), false)
  else if (base is TFhirExplanationOfBenefitItem) then
    composeExplanationOfBenefitItem(json, name, TFhirExplanationOfBenefitItem(base), false)
  else if (base is TFhirExplanationOfBenefitItemAdjudication) then
    composeExplanationOfBenefitItemAdjudication(json, name, TFhirExplanationOfBenefitItemAdjudication(base), false)
  else if (base is TFhirExplanationOfBenefitItemDetail) then
    composeExplanationOfBenefitItemDetail(json, name, TFhirExplanationOfBenefitItemDetail(base), false)
  else if (base is TFhirExplanationOfBenefitItemDetailSubDetail) then
    composeExplanationOfBenefitItemDetailSubDetail(json, name, TFhirExplanationOfBenefitItemDetailSubDetail(base), false)
  else if (base is TFhirExplanationOfBenefitAddItem) then
    composeExplanationOfBenefitAddItem(json, name, TFhirExplanationOfBenefitAddItem(base), false)
  else if (base is TFhirExplanationOfBenefitAddItemDetail) then
    composeExplanationOfBenefitAddItemDetail(json, name, TFhirExplanationOfBenefitAddItemDetail(base), false)
  else if (base is TFhirExplanationOfBenefitAddItemDetailSubDetail) then
    composeExplanationOfBenefitAddItemDetailSubDetail(json, name, TFhirExplanationOfBenefitAddItemDetailSubDetail(base), false)
  else if (base is TFhirExplanationOfBenefitTotal) then
    composeExplanationOfBenefitTotal(json, name, TFhirExplanationOfBenefitTotal(base), false)
  else if (base is TFhirExplanationOfBenefitPayment) then
    composeExplanationOfBenefitPayment(json, name, TFhirExplanationOfBenefitPayment(base), false)
  else if (base is TFhirExplanationOfBenefitProcessNote) then
    composeExplanationOfBenefitProcessNote(json, name, TFhirExplanationOfBenefitProcessNote(base), false)
  else if (base is TFhirExplanationOfBenefitBenefitBalance) then
    composeExplanationOfBenefitBenefitBalance(json, name, TFhirExplanationOfBenefitBenefitBalance(base), false)
  else if (base is TFhirExplanationOfBenefitBenefitBalanceFinancial) then
    composeExplanationOfBenefitBenefitBalanceFinancial(json, name, TFhirExplanationOfBenefitBenefitBalanceFinancial(base), false)
  else if (base is TFhirExplanationOfBenefit) then
    composeExplanationOfBenefit(json, name, TFhirExplanationOfBenefit(base), false)
{$ENDIF FHIR_EXPLANATIONOFBENEFIT}
{$IFDEF FHIR_FAMILYMEMBERHISTORY}
  else if (base is TFhirFamilyMemberHistoryCondition) then
    composeFamilyMemberHistoryCondition(json, name, TFhirFamilyMemberHistoryCondition(base), false)
  else if (base is TFhirFamilyMemberHistory) then
    composeFamilyMemberHistory(json, name, TFhirFamilyMemberHistory(base), false)
{$ENDIF FHIR_FAMILYMEMBERHISTORY}
{$IFDEF FHIR_FLAG}
  else if (base is TFhirFlag) then
    composeFlag(json, name, TFhirFlag(base), false)
{$ENDIF FHIR_FLAG}
{$IFDEF FHIR_GOAL}
  else if (base is TFhirGoalTarget) then
    composeGoalTarget(json, name, TFhirGoalTarget(base), false)
  else if (base is TFhirGoal) then
    composeGoal(json, name, TFhirGoal(base), false)
{$ENDIF FHIR_GOAL}
{$IFDEF FHIR_GRAPHDEFINITION}
  else if (base is TFhirGraphDefinitionLink) then
    composeGraphDefinitionLink(json, name, TFhirGraphDefinitionLink(base), false)
  else if (base is TFhirGraphDefinitionLinkTarget) then
    composeGraphDefinitionLinkTarget(json, name, TFhirGraphDefinitionLinkTarget(base), false)
  else if (base is TFhirGraphDefinitionLinkTargetCompartment) then
    composeGraphDefinitionLinkTargetCompartment(json, name, TFhirGraphDefinitionLinkTargetCompartment(base), false)
  else if (base is TFhirGraphDefinition) then
    composeGraphDefinition(json, name, TFhirGraphDefinition(base), false)
{$ENDIF FHIR_GRAPHDEFINITION}
{$IFDEF FHIR_GROUP}
  else if (base is TFhirGroupCharacteristic) then
    composeGroupCharacteristic(json, name, TFhirGroupCharacteristic(base), false)
  else if (base is TFhirGroupMember) then
    composeGroupMember(json, name, TFhirGroupMember(base), false)
  else if (base is TFhirGroup) then
    composeGroup(json, name, TFhirGroup(base), false)
{$ENDIF FHIR_GROUP}
{$IFDEF FHIR_GUIDANCERESPONSE}
  else if (base is TFhirGuidanceResponse) then
    composeGuidanceResponse(json, name, TFhirGuidanceResponse(base), false)
{$ENDIF FHIR_GUIDANCERESPONSE}
{$IFDEF FHIR_HEALTHCARESERVICE}
  else if (base is TFhirHealthcareServiceEligibility) then
    composeHealthcareServiceEligibility(json, name, TFhirHealthcareServiceEligibility(base), false)
  else if (base is TFhirHealthcareServiceAvailableTime) then
    composeHealthcareServiceAvailableTime(json, name, TFhirHealthcareServiceAvailableTime(base), false)
  else if (base is TFhirHealthcareServiceNotAvailable) then
    composeHealthcareServiceNotAvailable(json, name, TFhirHealthcareServiceNotAvailable(base), false)
  else if (base is TFhirHealthcareService) then
    composeHealthcareService(json, name, TFhirHealthcareService(base), false)
{$ENDIF FHIR_HEALTHCARESERVICE}
{$IFDEF FHIR_IMAGINGSTUDY}
  else if (base is TFhirImagingStudySeries) then
    composeImagingStudySeries(json, name, TFhirImagingStudySeries(base), false)
  else if (base is TFhirImagingStudySeriesPerformer) then
    composeImagingStudySeriesPerformer(json, name, TFhirImagingStudySeriesPerformer(base), false)
  else if (base is TFhirImagingStudySeriesInstance) then
    composeImagingStudySeriesInstance(json, name, TFhirImagingStudySeriesInstance(base), false)
  else if (base is TFhirImagingStudy) then
    composeImagingStudy(json, name, TFhirImagingStudy(base), false)
{$ENDIF FHIR_IMAGINGSTUDY}
{$IFDEF FHIR_IMMUNIZATION}
  else if (base is TFhirImmunizationPerformer) then
    composeImmunizationPerformer(json, name, TFhirImmunizationPerformer(base), false)
  else if (base is TFhirImmunizationEducation) then
    composeImmunizationEducation(json, name, TFhirImmunizationEducation(base), false)
  else if (base is TFhirImmunizationReaction) then
    composeImmunizationReaction(json, name, TFhirImmunizationReaction(base), false)
  else if (base is TFhirImmunizationProtocolApplied) then
    composeImmunizationProtocolApplied(json, name, TFhirImmunizationProtocolApplied(base), false)
  else if (base is TFhirImmunization) then
    composeImmunization(json, name, TFhirImmunization(base), false)
{$ENDIF FHIR_IMMUNIZATION}
{$IFDEF FHIR_IMMUNIZATIONEVALUATION}
  else if (base is TFhirImmunizationEvaluation) then
    composeImmunizationEvaluation(json, name, TFhirImmunizationEvaluation(base), false)
{$ENDIF FHIR_IMMUNIZATIONEVALUATION}
{$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
  else if (base is TFhirImmunizationRecommendationRecommendation) then
    composeImmunizationRecommendationRecommendation(json, name, TFhirImmunizationRecommendationRecommendation(base), false)
  else if (base is TFhirImmunizationRecommendationRecommendationDateCriterion) then
    composeImmunizationRecommendationRecommendationDateCriterion(json, name, TFhirImmunizationRecommendationRecommendationDateCriterion(base), false)
  else if (base is TFhirImmunizationRecommendation) then
    composeImmunizationRecommendation(json, name, TFhirImmunizationRecommendation(base), false)
{$ENDIF FHIR_IMMUNIZATIONRECOMMENDATION}
{$IFDEF FHIR_IMPLEMENTATIONGUIDE}
  else if (base is TFhirImplementationGuideDependsOn) then
    composeImplementationGuideDependsOn(json, name, TFhirImplementationGuideDependsOn(base), false)
  else if (base is TFhirImplementationGuideGlobal) then
    composeImplementationGuideGlobal(json, name, TFhirImplementationGuideGlobal(base), false)
  else if (base is TFhirImplementationGuideDefinition) then
    composeImplementationGuideDefinition(json, name, TFhirImplementationGuideDefinition(base), false)
  else if (base is TFhirImplementationGuideDefinitionGrouping) then
    composeImplementationGuideDefinitionGrouping(json, name, TFhirImplementationGuideDefinitionGrouping(base), false)
  else if (base is TFhirImplementationGuideDefinitionResource) then
    composeImplementationGuideDefinitionResource(json, name, TFhirImplementationGuideDefinitionResource(base), false)
  else if (base is TFhirImplementationGuideDefinitionPage) then
    composeImplementationGuideDefinitionPage(json, name, TFhirImplementationGuideDefinitionPage(base), false)
  else if (base is TFhirImplementationGuideDefinitionParameter) then
    composeImplementationGuideDefinitionParameter(json, name, TFhirImplementationGuideDefinitionParameter(base), false)
  else if (base is TFhirImplementationGuideDefinitionTemplate) then
    composeImplementationGuideDefinitionTemplate(json, name, TFhirImplementationGuideDefinitionTemplate(base), false)
  else if (base is TFhirImplementationGuideManifest) then
    composeImplementationGuideManifest(json, name, TFhirImplementationGuideManifest(base), false)
  else if (base is TFhirImplementationGuideManifestResource) then
    composeImplementationGuideManifestResource(json, name, TFhirImplementationGuideManifestResource(base), false)
  else if (base is TFhirImplementationGuideManifestPage) then
    composeImplementationGuideManifestPage(json, name, TFhirImplementationGuideManifestPage(base), false)
  else if (base is TFhirImplementationGuide) then
    composeImplementationGuide(json, name, TFhirImplementationGuide(base), false)
{$ENDIF FHIR_IMPLEMENTATIONGUIDE}
{$IFDEF FHIR_INSURANCEPLAN}
  else if (base is TFhirInsurancePlanContact) then
    composeInsurancePlanContact(json, name, TFhirInsurancePlanContact(base), false)
  else if (base is TFhirInsurancePlanCoverage) then
    composeInsurancePlanCoverage(json, name, TFhirInsurancePlanCoverage(base), false)
  else if (base is TFhirInsurancePlanCoverageBenefit) then
    composeInsurancePlanCoverageBenefit(json, name, TFhirInsurancePlanCoverageBenefit(base), false)
  else if (base is TFhirInsurancePlanCoverageBenefitLimit) then
    composeInsurancePlanCoverageBenefitLimit(json, name, TFhirInsurancePlanCoverageBenefitLimit(base), false)
  else if (base is TFhirInsurancePlanPlan) then
    composeInsurancePlanPlan(json, name, TFhirInsurancePlanPlan(base), false)
  else if (base is TFhirInsurancePlanPlanGeneralCost) then
    composeInsurancePlanPlanGeneralCost(json, name, TFhirInsurancePlanPlanGeneralCost(base), false)
  else if (base is TFhirInsurancePlanPlanSpecificCost) then
    composeInsurancePlanPlanSpecificCost(json, name, TFhirInsurancePlanPlanSpecificCost(base), false)
  else if (base is TFhirInsurancePlanPlanSpecificCostBenefit) then
    composeInsurancePlanPlanSpecificCostBenefit(json, name, TFhirInsurancePlanPlanSpecificCostBenefit(base), false)
  else if (base is TFhirInsurancePlanPlanSpecificCostBenefitCost) then
    composeInsurancePlanPlanSpecificCostBenefitCost(json, name, TFhirInsurancePlanPlanSpecificCostBenefitCost(base), false)
  else if (base is TFhirInsurancePlan) then
    composeInsurancePlan(json, name, TFhirInsurancePlan(base), false)
{$ENDIF FHIR_INSURANCEPLAN}
{$IFDEF FHIR_INVOICE}
  else if (base is TFhirInvoiceParticipant) then
    composeInvoiceParticipant(json, name, TFhirInvoiceParticipant(base), false)
  else if (base is TFhirInvoiceLineItem) then
    composeInvoiceLineItem(json, name, TFhirInvoiceLineItem(base), false)
  else if (base is TFhirInvoiceLineItemPriceComponent) then
    composeInvoiceLineItemPriceComponent(json, name, TFhirInvoiceLineItemPriceComponent(base), false)
  else if (base is TFhirInvoice) then
    composeInvoice(json, name, TFhirInvoice(base), false)
{$ENDIF FHIR_INVOICE}
{$IFDEF FHIR_LIBRARY}
  else if (base is TFhirLibrary) then
    composeLibrary(json, name, TFhirLibrary(base), false)
{$ENDIF FHIR_LIBRARY}
{$IFDEF FHIR_LINKAGE}
  else if (base is TFhirLinkageItem) then
    composeLinkageItem(json, name, TFhirLinkageItem(base), false)
  else if (base is TFhirLinkage) then
    composeLinkage(json, name, TFhirLinkage(base), false)
{$ENDIF FHIR_LINKAGE}
{$IFDEF FHIR_LIST}
  else if (base is TFhirListEntry) then
    composeListEntry(json, name, TFhirListEntry(base), false)
  else if (base is TFhirList) then
    composeList(json, name, TFhirList(base), false)
{$ENDIF FHIR_LIST}
{$IFDEF FHIR_LOCATION}
  else if (base is TFhirLocationPosition) then
    composeLocationPosition(json, name, TFhirLocationPosition(base), false)
  else if (base is TFhirLocationHoursOfOperation) then
    composeLocationHoursOfOperation(json, name, TFhirLocationHoursOfOperation(base), false)
  else if (base is TFhirLocation) then
    composeLocation(json, name, TFhirLocation(base), false)
{$ENDIF FHIR_LOCATION}
{$IFDEF FHIR_MEASURE}
  else if (base is TFhirMeasureGroup) then
    composeMeasureGroup(json, name, TFhirMeasureGroup(base), false)
  else if (base is TFhirMeasureGroupPopulation) then
    composeMeasureGroupPopulation(json, name, TFhirMeasureGroupPopulation(base), false)
  else if (base is TFhirMeasureGroupStratifier) then
    composeMeasureGroupStratifier(json, name, TFhirMeasureGroupStratifier(base), false)
  else if (base is TFhirMeasureGroupStratifierComponent) then
    composeMeasureGroupStratifierComponent(json, name, TFhirMeasureGroupStratifierComponent(base), false)
  else if (base is TFhirMeasureSupplementalData) then
    composeMeasureSupplementalData(json, name, TFhirMeasureSupplementalData(base), false)
  else if (base is TFhirMeasure) then
    composeMeasure(json, name, TFhirMeasure(base), false)
{$ENDIF FHIR_MEASURE}
{$IFDEF FHIR_MEASUREREPORT}
  else if (base is TFhirMeasureReportGroup) then
    composeMeasureReportGroup(json, name, TFhirMeasureReportGroup(base), false)
  else if (base is TFhirMeasureReportGroupPopulation) then
    composeMeasureReportGroupPopulation(json, name, TFhirMeasureReportGroupPopulation(base), false)
  else if (base is TFhirMeasureReportGroupStratifier) then
    composeMeasureReportGroupStratifier(json, name, TFhirMeasureReportGroupStratifier(base), false)
  else if (base is TFhirMeasureReportGroupStratifierStratum) then
    composeMeasureReportGroupStratifierStratum(json, name, TFhirMeasureReportGroupStratifierStratum(base), false)
  else if (base is TFhirMeasureReportGroupStratifierStratumComponent) then
    composeMeasureReportGroupStratifierStratumComponent(json, name, TFhirMeasureReportGroupStratifierStratumComponent(base), false)
  else if (base is TFhirMeasureReportGroupStratifierStratumPopulation) then
    composeMeasureReportGroupStratifierStratumPopulation(json, name, TFhirMeasureReportGroupStratifierStratumPopulation(base), false)
  else if (base is TFhirMeasureReport) then
    composeMeasureReport(json, name, TFhirMeasureReport(base), false)
{$ENDIF FHIR_MEASUREREPORT}
{$IFDEF FHIR_MEDIA}
  else if (base is TFhirMedia) then
    composeMedia(json, name, TFhirMedia(base), false)
{$ENDIF FHIR_MEDIA}
{$IFDEF FHIR_MEDICATION}
  else if (base is TFhirMedicationIngredient) then
    composeMedicationIngredient(json, name, TFhirMedicationIngredient(base), false)
  else if (base is TFhirMedicationBatch) then
    composeMedicationBatch(json, name, TFhirMedicationBatch(base), false)
  else if (base is TFhirMedication) then
    composeMedication(json, name, TFhirMedication(base), false)
{$ENDIF FHIR_MEDICATION}
{$IFDEF FHIR_MEDICATIONADMINISTRATION}
  else if (base is TFhirMedicationAdministrationPerformer) then
    composeMedicationAdministrationPerformer(json, name, TFhirMedicationAdministrationPerformer(base), false)
  else if (base is TFhirMedicationAdministrationDosage) then
    composeMedicationAdministrationDosage(json, name, TFhirMedicationAdministrationDosage(base), false)
  else if (base is TFhirMedicationAdministration) then
    composeMedicationAdministration(json, name, TFhirMedicationAdministration(base), false)
{$ENDIF FHIR_MEDICATIONADMINISTRATION}
{$IFDEF FHIR_MEDICATIONDISPENSE}
  else if (base is TFhirMedicationDispensePerformer) then
    composeMedicationDispensePerformer(json, name, TFhirMedicationDispensePerformer(base), false)
  else if (base is TFhirMedicationDispenseSubstitution) then
    composeMedicationDispenseSubstitution(json, name, TFhirMedicationDispenseSubstitution(base), false)
  else if (base is TFhirMedicationDispense) then
    composeMedicationDispense(json, name, TFhirMedicationDispense(base), false)
{$ENDIF FHIR_MEDICATIONDISPENSE}
{$IFDEF FHIR_MEDICATIONKNOWLEDGE}
  else if (base is TFhirMedicationKnowledgeRelatedMedicationKnowledge) then
    composeMedicationKnowledgeRelatedMedicationKnowledge(json, name, TFhirMedicationKnowledgeRelatedMedicationKnowledge(base), false)
  else if (base is TFhirMedicationKnowledgeMonograph) then
    composeMedicationKnowledgeMonograph(json, name, TFhirMedicationKnowledgeMonograph(base), false)
  else if (base is TFhirMedicationKnowledgeIngredient) then
    composeMedicationKnowledgeIngredient(json, name, TFhirMedicationKnowledgeIngredient(base), false)
  else if (base is TFhirMedicationKnowledgeCost) then
    composeMedicationKnowledgeCost(json, name, TFhirMedicationKnowledgeCost(base), false)
  else if (base is TFhirMedicationKnowledgeMonitoringProgram) then
    composeMedicationKnowledgeMonitoringProgram(json, name, TFhirMedicationKnowledgeMonitoringProgram(base), false)
  else if (base is TFhirMedicationKnowledgeAdministrationGuidelines) then
    composeMedicationKnowledgeAdministrationGuidelines(json, name, TFhirMedicationKnowledgeAdministrationGuidelines(base), false)
  else if (base is TFhirMedicationKnowledgeAdministrationGuidelinesDosage) then
    composeMedicationKnowledgeAdministrationGuidelinesDosage(json, name, TFhirMedicationKnowledgeAdministrationGuidelinesDosage(base), false)
  else if (base is TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics) then
    composeMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics(json, name, TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics(base), false)
  else if (base is TFhirMedicationKnowledgeMedicineClassification) then
    composeMedicationKnowledgeMedicineClassification(json, name, TFhirMedicationKnowledgeMedicineClassification(base), false)
  else if (base is TFhirMedicationKnowledgePackaging) then
    composeMedicationKnowledgePackaging(json, name, TFhirMedicationKnowledgePackaging(base), false)
  else if (base is TFhirMedicationKnowledgeDrugCharacteristic) then
    composeMedicationKnowledgeDrugCharacteristic(json, name, TFhirMedicationKnowledgeDrugCharacteristic(base), false)
  else if (base is TFhirMedicationKnowledgeRegulatory) then
    composeMedicationKnowledgeRegulatory(json, name, TFhirMedicationKnowledgeRegulatory(base), false)
  else if (base is TFhirMedicationKnowledgeRegulatorySubstitution) then
    composeMedicationKnowledgeRegulatorySubstitution(json, name, TFhirMedicationKnowledgeRegulatorySubstitution(base), false)
  else if (base is TFhirMedicationKnowledgeRegulatorySchedule) then
    composeMedicationKnowledgeRegulatorySchedule(json, name, TFhirMedicationKnowledgeRegulatorySchedule(base), false)
  else if (base is TFhirMedicationKnowledgeRegulatoryMaxDispense) then
    composeMedicationKnowledgeRegulatoryMaxDispense(json, name, TFhirMedicationKnowledgeRegulatoryMaxDispense(base), false)
  else if (base is TFhirMedicationKnowledgeKinetics) then
    composeMedicationKnowledgeKinetics(json, name, TFhirMedicationKnowledgeKinetics(base), false)
  else if (base is TFhirMedicationKnowledge) then
    composeMedicationKnowledge(json, name, TFhirMedicationKnowledge(base), false)
{$ENDIF FHIR_MEDICATIONKNOWLEDGE}
{$IFDEF FHIR_MEDICATIONREQUEST}
  else if (base is TFhirMedicationRequestDispenseRequest) then
    composeMedicationRequestDispenseRequest(json, name, TFhirMedicationRequestDispenseRequest(base), false)
  else if (base is TFhirMedicationRequestDispenseRequestInitialFill) then
    composeMedicationRequestDispenseRequestInitialFill(json, name, TFhirMedicationRequestDispenseRequestInitialFill(base), false)
  else if (base is TFhirMedicationRequestSubstitution) then
    composeMedicationRequestSubstitution(json, name, TFhirMedicationRequestSubstitution(base), false)
  else if (base is TFhirMedicationRequest) then
    composeMedicationRequest(json, name, TFhirMedicationRequest(base), false)
{$ENDIF FHIR_MEDICATIONREQUEST}
{$IFDEF FHIR_MEDICATIONSTATEMENT}
  else if (base is TFhirMedicationStatement) then
    composeMedicationStatement(json, name, TFhirMedicationStatement(base), false)
{$ENDIF FHIR_MEDICATIONSTATEMENT}
{$IFDEF FHIR_MEDICINALPRODUCT}
  else if (base is TFhirMedicinalProductName) then
    composeMedicinalProductName(json, name, TFhirMedicinalProductName(base), false)
  else if (base is TFhirMedicinalProductNameNamePart) then
    composeMedicinalProductNameNamePart(json, name, TFhirMedicinalProductNameNamePart(base), false)
  else if (base is TFhirMedicinalProductNameCountryLanguage) then
    composeMedicinalProductNameCountryLanguage(json, name, TFhirMedicinalProductNameCountryLanguage(base), false)
  else if (base is TFhirMedicinalProductManufacturingBusinessOperation) then
    composeMedicinalProductManufacturingBusinessOperation(json, name, TFhirMedicinalProductManufacturingBusinessOperation(base), false)
  else if (base is TFhirMedicinalProductSpecialDesignation) then
    composeMedicinalProductSpecialDesignation(json, name, TFhirMedicinalProductSpecialDesignation(base), false)
  else if (base is TFhirMedicinalProduct) then
    composeMedicinalProduct(json, name, TFhirMedicinalProduct(base), false)
{$ENDIF FHIR_MEDICINALPRODUCT}
{$IFDEF FHIR_MEDICINALPRODUCTAUTHORIZATION}
  else if (base is TFhirMedicinalProductAuthorizationJurisdictionalAuthorization) then
    composeMedicinalProductAuthorizationJurisdictionalAuthorization(json, name, TFhirMedicinalProductAuthorizationJurisdictionalAuthorization(base), false)
  else if (base is TFhirMedicinalProductAuthorizationProcedure) then
    composeMedicinalProductAuthorizationProcedure(json, name, TFhirMedicinalProductAuthorizationProcedure(base), false)
  else if (base is TFhirMedicinalProductAuthorization) then
    composeMedicinalProductAuthorization(json, name, TFhirMedicinalProductAuthorization(base), false)
{$ENDIF FHIR_MEDICINALPRODUCTAUTHORIZATION}
{$IFDEF FHIR_MEDICINALPRODUCTCONTRAINDICATION}
  else if (base is TFhirMedicinalProductContraindicationOtherTherapy) then
    composeMedicinalProductContraindicationOtherTherapy(json, name, TFhirMedicinalProductContraindicationOtherTherapy(base), false)
  else if (base is TFhirMedicinalProductContraindication) then
    composeMedicinalProductContraindication(json, name, TFhirMedicinalProductContraindication(base), false)
{$ENDIF FHIR_MEDICINALPRODUCTCONTRAINDICATION}
{$IFDEF FHIR_MEDICINALPRODUCTINDICATION}
  else if (base is TFhirMedicinalProductIndicationOtherTherapy) then
    composeMedicinalProductIndicationOtherTherapy(json, name, TFhirMedicinalProductIndicationOtherTherapy(base), false)
  else if (base is TFhirMedicinalProductIndication) then
    composeMedicinalProductIndication(json, name, TFhirMedicinalProductIndication(base), false)
{$ENDIF FHIR_MEDICINALPRODUCTINDICATION}
{$IFDEF FHIR_MEDICINALPRODUCTINGREDIENT}
  else if (base is TFhirMedicinalProductIngredientSpecifiedSubstance) then
    composeMedicinalProductIngredientSpecifiedSubstance(json, name, TFhirMedicinalProductIngredientSpecifiedSubstance(base), false)
  else if (base is TFhirMedicinalProductIngredientSpecifiedSubstanceStrength) then
    composeMedicinalProductIngredientSpecifiedSubstanceStrength(json, name, TFhirMedicinalProductIngredientSpecifiedSubstanceStrength(base), false)
  else if (base is TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength) then
    composeMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength(json, name, TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength(base), false)
  else if (base is TFhirMedicinalProductIngredientSubstance) then
    composeMedicinalProductIngredientSubstance(json, name, TFhirMedicinalProductIngredientSubstance(base), false)
  else if (base is TFhirMedicinalProductIngredient) then
    composeMedicinalProductIngredient(json, name, TFhirMedicinalProductIngredient(base), false)
{$ENDIF FHIR_MEDICINALPRODUCTINGREDIENT}
{$IFDEF FHIR_MEDICINALPRODUCTINTERACTION}
  else if (base is TFhirMedicinalProductInteractionInteractant) then
    composeMedicinalProductInteractionInteractant(json, name, TFhirMedicinalProductInteractionInteractant(base), false)
  else if (base is TFhirMedicinalProductInteraction) then
    composeMedicinalProductInteraction(json, name, TFhirMedicinalProductInteraction(base), false)
{$ENDIF FHIR_MEDICINALPRODUCTINTERACTION}
{$IFDEF FHIR_MEDICINALPRODUCTMANUFACTURED}
  else if (base is TFhirMedicinalProductManufactured) then
    composeMedicinalProductManufactured(json, name, TFhirMedicinalProductManufactured(base), false)
{$ENDIF FHIR_MEDICINALPRODUCTMANUFACTURED}
{$IFDEF FHIR_MEDICINALPRODUCTPACKAGED}
  else if (base is TFhirMedicinalProductPackagedBatchIdentifier) then
    composeMedicinalProductPackagedBatchIdentifier(json, name, TFhirMedicinalProductPackagedBatchIdentifier(base), false)
  else if (base is TFhirMedicinalProductPackagedPackageItem) then
    composeMedicinalProductPackagedPackageItem(json, name, TFhirMedicinalProductPackagedPackageItem(base), false)
  else if (base is TFhirMedicinalProductPackaged) then
    composeMedicinalProductPackaged(json, name, TFhirMedicinalProductPackaged(base), false)
{$ENDIF FHIR_MEDICINALPRODUCTPACKAGED}
{$IFDEF FHIR_MEDICINALPRODUCTPHARMACEUTICAL}
  else if (base is TFhirMedicinalProductPharmaceuticalCharacteristics) then
    composeMedicinalProductPharmaceuticalCharacteristics(json, name, TFhirMedicinalProductPharmaceuticalCharacteristics(base), false)
  else if (base is TFhirMedicinalProductPharmaceuticalRouteOfAdministration) then
    composeMedicinalProductPharmaceuticalRouteOfAdministration(json, name, TFhirMedicinalProductPharmaceuticalRouteOfAdministration(base), false)
  else if (base is TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies) then
    composeMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies(json, name, TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies(base), false)
  else if (base is TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod) then
    composeMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod(json, name, TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod(base), false)
  else if (base is TFhirMedicinalProductPharmaceutical) then
    composeMedicinalProductPharmaceutical(json, name, TFhirMedicinalProductPharmaceutical(base), false)
{$ENDIF FHIR_MEDICINALPRODUCTPHARMACEUTICAL}
{$IFDEF FHIR_MEDICINALPRODUCTUNDESIRABLEEFFECT}
  else if (base is TFhirMedicinalProductUndesirableEffect) then
    composeMedicinalProductUndesirableEffect(json, name, TFhirMedicinalProductUndesirableEffect(base), false)
{$ENDIF FHIR_MEDICINALPRODUCTUNDESIRABLEEFFECT}
{$IFDEF FHIR_MESSAGEDEFINITION}
  else if (base is TFhirMessageDefinitionFocus) then
    composeMessageDefinitionFocus(json, name, TFhirMessageDefinitionFocus(base), false)
  else if (base is TFhirMessageDefinitionAllowedResponse) then
    composeMessageDefinitionAllowedResponse(json, name, TFhirMessageDefinitionAllowedResponse(base), false)
  else if (base is TFhirMessageDefinition) then
    composeMessageDefinition(json, name, TFhirMessageDefinition(base), false)
{$ENDIF FHIR_MESSAGEDEFINITION}
{$IFDEF FHIR_MESSAGEHEADER}
  else if (base is TFhirMessageHeaderDestination) then
    composeMessageHeaderDestination(json, name, TFhirMessageHeaderDestination(base), false)
  else if (base is TFhirMessageHeaderSource) then
    composeMessageHeaderSource(json, name, TFhirMessageHeaderSource(base), false)
  else if (base is TFhirMessageHeaderResponse) then
    composeMessageHeaderResponse(json, name, TFhirMessageHeaderResponse(base), false)
  else if (base is TFhirMessageHeader) then
    composeMessageHeader(json, name, TFhirMessageHeader(base), false)
{$ENDIF FHIR_MESSAGEHEADER}
{$IFDEF FHIR_MOLECULARSEQUENCE}
  else if (base is TFhirMolecularSequenceReferenceSeq) then
    composeMolecularSequenceReferenceSeq(json, name, TFhirMolecularSequenceReferenceSeq(base), false)
  else if (base is TFhirMolecularSequenceVariant) then
    composeMolecularSequenceVariant(json, name, TFhirMolecularSequenceVariant(base), false)
  else if (base is TFhirMolecularSequenceQuality) then
    composeMolecularSequenceQuality(json, name, TFhirMolecularSequenceQuality(base), false)
  else if (base is TFhirMolecularSequenceQualityRoc) then
    composeMolecularSequenceQualityRoc(json, name, TFhirMolecularSequenceQualityRoc(base), false)
  else if (base is TFhirMolecularSequenceRepository) then
    composeMolecularSequenceRepository(json, name, TFhirMolecularSequenceRepository(base), false)
  else if (base is TFhirMolecularSequenceStructureVariant) then
    composeMolecularSequenceStructureVariant(json, name, TFhirMolecularSequenceStructureVariant(base), false)
  else if (base is TFhirMolecularSequenceStructureVariantOuter) then
    composeMolecularSequenceStructureVariantOuter(json, name, TFhirMolecularSequenceStructureVariantOuter(base), false)
  else if (base is TFhirMolecularSequenceStructureVariantInner) then
    composeMolecularSequenceStructureVariantInner(json, name, TFhirMolecularSequenceStructureVariantInner(base), false)
  else if (base is TFhirMolecularSequence) then
    composeMolecularSequence(json, name, TFhirMolecularSequence(base), false)
{$ENDIF FHIR_MOLECULARSEQUENCE}
{$IFDEF FHIR_NAMINGSYSTEM}
  else if (base is TFhirNamingSystemUniqueId) then
    composeNamingSystemUniqueId(json, name, TFhirNamingSystemUniqueId(base), false)
  else if (base is TFhirNamingSystem) then
    composeNamingSystem(json, name, TFhirNamingSystem(base), false)
{$ENDIF FHIR_NAMINGSYSTEM}
{$IFDEF FHIR_NUTRITIONORDER}
  else if (base is TFhirNutritionOrderOralDiet) then
    composeNutritionOrderOralDiet(json, name, TFhirNutritionOrderOralDiet(base), false)
  else if (base is TFhirNutritionOrderOralDietNutrient) then
    composeNutritionOrderOralDietNutrient(json, name, TFhirNutritionOrderOralDietNutrient(base), false)
  else if (base is TFhirNutritionOrderOralDietTexture) then
    composeNutritionOrderOralDietTexture(json, name, TFhirNutritionOrderOralDietTexture(base), false)
  else if (base is TFhirNutritionOrderSupplement) then
    composeNutritionOrderSupplement(json, name, TFhirNutritionOrderSupplement(base), false)
  else if (base is TFhirNutritionOrderEnteralFormula) then
    composeNutritionOrderEnteralFormula(json, name, TFhirNutritionOrderEnteralFormula(base), false)
  else if (base is TFhirNutritionOrderEnteralFormulaAdministration) then
    composeNutritionOrderEnteralFormulaAdministration(json, name, TFhirNutritionOrderEnteralFormulaAdministration(base), false)
  else if (base is TFhirNutritionOrder) then
    composeNutritionOrder(json, name, TFhirNutritionOrder(base), false)
{$ENDIF FHIR_NUTRITIONORDER}
{$IFDEF FHIR_OBSERVATION}
  else if (base is TFhirObservationReferenceRange) then
    composeObservationReferenceRange(json, name, TFhirObservationReferenceRange(base), false)
  else if (base is TFhirObservationComponent) then
    composeObservationComponent(json, name, TFhirObservationComponent(base), false)
  else if (base is TFhirObservation) then
    composeObservation(json, name, TFhirObservation(base), false)
{$ENDIF FHIR_OBSERVATION}
{$IFDEF FHIR_OBSERVATIONDEFINITION}
  else if (base is TFhirObservationDefinitionQuantitativeDetails) then
    composeObservationDefinitionQuantitativeDetails(json, name, TFhirObservationDefinitionQuantitativeDetails(base), false)
  else if (base is TFhirObservationDefinitionQualifiedInterval) then
    composeObservationDefinitionQualifiedInterval(json, name, TFhirObservationDefinitionQualifiedInterval(base), false)
  else if (base is TFhirObservationDefinition) then
    composeObservationDefinition(json, name, TFhirObservationDefinition(base), false)
{$ENDIF FHIR_OBSERVATIONDEFINITION}
{$IFDEF FHIR_OPERATIONDEFINITION}
  else if (base is TFhirOperationDefinitionParameter) then
    composeOperationDefinitionParameter(json, name, TFhirOperationDefinitionParameter(base), false)
  else if (base is TFhirOperationDefinitionParameterBinding) then
    composeOperationDefinitionParameterBinding(json, name, TFhirOperationDefinitionParameterBinding(base), false)
  else if (base is TFhirOperationDefinitionParameterReferencedFrom) then
    composeOperationDefinitionParameterReferencedFrom(json, name, TFhirOperationDefinitionParameterReferencedFrom(base), false)
  else if (base is TFhirOperationDefinitionOverload) then
    composeOperationDefinitionOverload(json, name, TFhirOperationDefinitionOverload(base), false)
  else if (base is TFhirOperationDefinition) then
    composeOperationDefinition(json, name, TFhirOperationDefinition(base), false)
{$ENDIF FHIR_OPERATIONDEFINITION}
{$IFDEF FHIR_OPERATIONOUTCOME}
  else if (base is TFhirOperationOutcomeIssue) then
    composeOperationOutcomeIssue(json, name, TFhirOperationOutcomeIssue(base), false)
  else if (base is TFhirOperationOutcome) then
    composeOperationOutcome(json, name, TFhirOperationOutcome(base), false)
{$ENDIF FHIR_OPERATIONOUTCOME}
{$IFDEF FHIR_ORGANIZATION}
  else if (base is TFhirOrganizationContact) then
    composeOrganizationContact(json, name, TFhirOrganizationContact(base), false)
  else if (base is TFhirOrganization) then
    composeOrganization(json, name, TFhirOrganization(base), false)
{$ENDIF FHIR_ORGANIZATION}
{$IFDEF FHIR_ORGANIZATIONAFFILIATION}
  else if (base is TFhirOrganizationAffiliation) then
    composeOrganizationAffiliation(json, name, TFhirOrganizationAffiliation(base), false)
{$ENDIF FHIR_ORGANIZATIONAFFILIATION}
{$IFDEF FHIR_PATIENT}
  else if (base is TFhirPatientContact) then
    composePatientContact(json, name, TFhirPatientContact(base), false)
  else if (base is TFhirPatientCommunication) then
    composePatientCommunication(json, name, TFhirPatientCommunication(base), false)
  else if (base is TFhirPatientLink) then
    composePatientLink(json, name, TFhirPatientLink(base), false)
  else if (base is TFhirPatient) then
    composePatient(json, name, TFhirPatient(base), false)
{$ENDIF FHIR_PATIENT}
{$IFDEF FHIR_PAYMENTNOTICE}
  else if (base is TFhirPaymentNotice) then
    composePaymentNotice(json, name, TFhirPaymentNotice(base), false)
{$ENDIF FHIR_PAYMENTNOTICE}
{$IFDEF FHIR_PAYMENTRECONCILIATION}
  else if (base is TFhirPaymentReconciliationDetail) then
    composePaymentReconciliationDetail(json, name, TFhirPaymentReconciliationDetail(base), false)
  else if (base is TFhirPaymentReconciliationProcessNote) then
    composePaymentReconciliationProcessNote(json, name, TFhirPaymentReconciliationProcessNote(base), false)
  else if (base is TFhirPaymentReconciliation) then
    composePaymentReconciliation(json, name, TFhirPaymentReconciliation(base), false)
{$ENDIF FHIR_PAYMENTRECONCILIATION}
{$IFDEF FHIR_PERSON}
  else if (base is TFhirPersonLink) then
    composePersonLink(json, name, TFhirPersonLink(base), false)
  else if (base is TFhirPerson) then
    composePerson(json, name, TFhirPerson(base), false)
{$ENDIF FHIR_PERSON}
{$IFDEF FHIR_PLANDEFINITION}
  else if (base is TFhirPlanDefinitionGoal) then
    composePlanDefinitionGoal(json, name, TFhirPlanDefinitionGoal(base), false)
  else if (base is TFhirPlanDefinitionGoalTarget) then
    composePlanDefinitionGoalTarget(json, name, TFhirPlanDefinitionGoalTarget(base), false)
  else if (base is TFhirPlanDefinitionAction) then
    composePlanDefinitionAction(json, name, TFhirPlanDefinitionAction(base), false)
  else if (base is TFhirPlanDefinitionActionCondition) then
    composePlanDefinitionActionCondition(json, name, TFhirPlanDefinitionActionCondition(base), false)
  else if (base is TFhirPlanDefinitionActionRelatedAction) then
    composePlanDefinitionActionRelatedAction(json, name, TFhirPlanDefinitionActionRelatedAction(base), false)
  else if (base is TFhirPlanDefinitionActionParticipant) then
    composePlanDefinitionActionParticipant(json, name, TFhirPlanDefinitionActionParticipant(base), false)
  else if (base is TFhirPlanDefinitionActionDynamicValue) then
    composePlanDefinitionActionDynamicValue(json, name, TFhirPlanDefinitionActionDynamicValue(base), false)
  else if (base is TFhirPlanDefinition) then
    composePlanDefinition(json, name, TFhirPlanDefinition(base), false)
{$ENDIF FHIR_PLANDEFINITION}
{$IFDEF FHIR_PRACTITIONER}
  else if (base is TFhirPractitionerQualification) then
    composePractitionerQualification(json, name, TFhirPractitionerQualification(base), false)
  else if (base is TFhirPractitioner) then
    composePractitioner(json, name, TFhirPractitioner(base), false)
{$ENDIF FHIR_PRACTITIONER}
{$IFDEF FHIR_PRACTITIONERROLE}
  else if (base is TFhirPractitionerRoleAvailableTime) then
    composePractitionerRoleAvailableTime(json, name, TFhirPractitionerRoleAvailableTime(base), false)
  else if (base is TFhirPractitionerRoleNotAvailable) then
    composePractitionerRoleNotAvailable(json, name, TFhirPractitionerRoleNotAvailable(base), false)
  else if (base is TFhirPractitionerRole) then
    composePractitionerRole(json, name, TFhirPractitionerRole(base), false)
{$ENDIF FHIR_PRACTITIONERROLE}
{$IFDEF FHIR_PROCEDURE}
  else if (base is TFhirProcedurePerformer) then
    composeProcedurePerformer(json, name, TFhirProcedurePerformer(base), false)
  else if (base is TFhirProcedureFocalDevice) then
    composeProcedureFocalDevice(json, name, TFhirProcedureFocalDevice(base), false)
  else if (base is TFhirProcedure) then
    composeProcedure(json, name, TFhirProcedure(base), false)
{$ENDIF FHIR_PROCEDURE}
{$IFDEF FHIR_PROVENANCE}
  else if (base is TFhirProvenanceAgent) then
    composeProvenanceAgent(json, name, TFhirProvenanceAgent(base), false)
  else if (base is TFhirProvenanceEntity) then
    composeProvenanceEntity(json, name, TFhirProvenanceEntity(base), false)
  else if (base is TFhirProvenance) then
    composeProvenance(json, name, TFhirProvenance(base), false)
{$ENDIF FHIR_PROVENANCE}
{$IFDEF FHIR_QUESTIONNAIRE}
  else if (base is TFhirQuestionnaireItem) then
    composeQuestionnaireItem(json, name, TFhirQuestionnaireItem(base), false)
  else if (base is TFhirQuestionnaireItemEnableWhen) then
    composeQuestionnaireItemEnableWhen(json, name, TFhirQuestionnaireItemEnableWhen(base), false)
  else if (base is TFhirQuestionnaireItemAnswerOption) then
    composeQuestionnaireItemAnswerOption(json, name, TFhirQuestionnaireItemAnswerOption(base), false)
  else if (base is TFhirQuestionnaireItemInitial) then
    composeQuestionnaireItemInitial(json, name, TFhirQuestionnaireItemInitial(base), false)
  else if (base is TFhirQuestionnaire) then
    composeQuestionnaire(json, name, TFhirQuestionnaire(base), false)
{$ENDIF FHIR_QUESTIONNAIRE}
{$IFDEF FHIR_QUESTIONNAIRERESPONSE}
  else if (base is TFhirQuestionnaireResponseItem) then
    composeQuestionnaireResponseItem(json, name, TFhirQuestionnaireResponseItem(base), false)
  else if (base is TFhirQuestionnaireResponseItemAnswer) then
    composeQuestionnaireResponseItemAnswer(json, name, TFhirQuestionnaireResponseItemAnswer(base), false)
  else if (base is TFhirQuestionnaireResponse) then
    composeQuestionnaireResponse(json, name, TFhirQuestionnaireResponse(base), false)
{$ENDIF FHIR_QUESTIONNAIRERESPONSE}
{$IFDEF FHIR_RELATEDPERSON}
  else if (base is TFhirRelatedPersonCommunication) then
    composeRelatedPersonCommunication(json, name, TFhirRelatedPersonCommunication(base), false)
  else if (base is TFhirRelatedPerson) then
    composeRelatedPerson(json, name, TFhirRelatedPerson(base), false)
{$ENDIF FHIR_RELATEDPERSON}
{$IFDEF FHIR_REQUESTGROUP}
  else if (base is TFhirRequestGroupAction) then
    composeRequestGroupAction(json, name, TFhirRequestGroupAction(base), false)
  else if (base is TFhirRequestGroupActionCondition) then
    composeRequestGroupActionCondition(json, name, TFhirRequestGroupActionCondition(base), false)
  else if (base is TFhirRequestGroupActionRelatedAction) then
    composeRequestGroupActionRelatedAction(json, name, TFhirRequestGroupActionRelatedAction(base), false)
  else if (base is TFhirRequestGroup) then
    composeRequestGroup(json, name, TFhirRequestGroup(base), false)
{$ENDIF FHIR_REQUESTGROUP}
{$IFDEF FHIR_RESEARCHDEFINITION}
  else if (base is TFhirResearchDefinition) then
    composeResearchDefinition(json, name, TFhirResearchDefinition(base), false)
{$ENDIF FHIR_RESEARCHDEFINITION}
{$IFDEF FHIR_RESEARCHELEMENTDEFINITION}
  else if (base is TFhirResearchElementDefinitionCharacteristic) then
    composeResearchElementDefinitionCharacteristic(json, name, TFhirResearchElementDefinitionCharacteristic(base), false)
  else if (base is TFhirResearchElementDefinition) then
    composeResearchElementDefinition(json, name, TFhirResearchElementDefinition(base), false)
{$ENDIF FHIR_RESEARCHELEMENTDEFINITION}
{$IFDEF FHIR_RESEARCHSTUDY}
  else if (base is TFhirResearchStudyArm) then
    composeResearchStudyArm(json, name, TFhirResearchStudyArm(base), false)
  else if (base is TFhirResearchStudyObjective) then
    composeResearchStudyObjective(json, name, TFhirResearchStudyObjective(base), false)
  else if (base is TFhirResearchStudy) then
    composeResearchStudy(json, name, TFhirResearchStudy(base), false)
{$ENDIF FHIR_RESEARCHSTUDY}
{$IFDEF FHIR_RESEARCHSUBJECT}
  else if (base is TFhirResearchSubject) then
    composeResearchSubject(json, name, TFhirResearchSubject(base), false)
{$ENDIF FHIR_RESEARCHSUBJECT}
{$IFDEF FHIR_RISKASSESSMENT}
  else if (base is TFhirRiskAssessmentPrediction) then
    composeRiskAssessmentPrediction(json, name, TFhirRiskAssessmentPrediction(base), false)
  else if (base is TFhirRiskAssessment) then
    composeRiskAssessment(json, name, TFhirRiskAssessment(base), false)
{$ENDIF FHIR_RISKASSESSMENT}
{$IFDEF FHIR_RISKEVIDENCESYNTHESIS}
  else if (base is TFhirRiskEvidenceSynthesisSampleSize) then
    composeRiskEvidenceSynthesisSampleSize(json, name, TFhirRiskEvidenceSynthesisSampleSize(base), false)
  else if (base is TFhirRiskEvidenceSynthesisRiskEstimate) then
    composeRiskEvidenceSynthesisRiskEstimate(json, name, TFhirRiskEvidenceSynthesisRiskEstimate(base), false)
  else if (base is TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate) then
    composeRiskEvidenceSynthesisRiskEstimatePrecisionEstimate(json, name, TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate(base), false)
  else if (base is TFhirRiskEvidenceSynthesisCertainty) then
    composeRiskEvidenceSynthesisCertainty(json, name, TFhirRiskEvidenceSynthesisCertainty(base), false)
  else if (base is TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent) then
    composeRiskEvidenceSynthesisCertaintyCertaintySubcomponent(json, name, TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent(base), false)
  else if (base is TFhirRiskEvidenceSynthesis) then
    composeRiskEvidenceSynthesis(json, name, TFhirRiskEvidenceSynthesis(base), false)
{$ENDIF FHIR_RISKEVIDENCESYNTHESIS}
{$IFDEF FHIR_SCHEDULE}
  else if (base is TFhirSchedule) then
    composeSchedule(json, name, TFhirSchedule(base), false)
{$ENDIF FHIR_SCHEDULE}
{$IFDEF FHIR_SEARCHPARAMETER}
  else if (base is TFhirSearchParameterComponent) then
    composeSearchParameterComponent(json, name, TFhirSearchParameterComponent(base), false)
  else if (base is TFhirSearchParameter) then
    composeSearchParameter(json, name, TFhirSearchParameter(base), false)
{$ENDIF FHIR_SEARCHPARAMETER}
{$IFDEF FHIR_SERVICEREQUEST}
  else if (base is TFhirServiceRequest) then
    composeServiceRequest(json, name, TFhirServiceRequest(base), false)
{$ENDIF FHIR_SERVICEREQUEST}
{$IFDEF FHIR_SLOT}
  else if (base is TFhirSlot) then
    composeSlot(json, name, TFhirSlot(base), false)
{$ENDIF FHIR_SLOT}
{$IFDEF FHIR_SPECIMEN}
  else if (base is TFhirSpecimenCollection) then
    composeSpecimenCollection(json, name, TFhirSpecimenCollection(base), false)
  else if (base is TFhirSpecimenProcessing) then
    composeSpecimenProcessing(json, name, TFhirSpecimenProcessing(base), false)
  else if (base is TFhirSpecimenContainer) then
    composeSpecimenContainer(json, name, TFhirSpecimenContainer(base), false)
  else if (base is TFhirSpecimen) then
    composeSpecimen(json, name, TFhirSpecimen(base), false)
{$ENDIF FHIR_SPECIMEN}
{$IFDEF FHIR_SPECIMENDEFINITION}
  else if (base is TFhirSpecimenDefinitionTypeTested) then
    composeSpecimenDefinitionTypeTested(json, name, TFhirSpecimenDefinitionTypeTested(base), false)
  else if (base is TFhirSpecimenDefinitionTypeTestedContainer) then
    composeSpecimenDefinitionTypeTestedContainer(json, name, TFhirSpecimenDefinitionTypeTestedContainer(base), false)
  else if (base is TFhirSpecimenDefinitionTypeTestedContainerAdditive) then
    composeSpecimenDefinitionTypeTestedContainerAdditive(json, name, TFhirSpecimenDefinitionTypeTestedContainerAdditive(base), false)
  else if (base is TFhirSpecimenDefinitionTypeTestedHandling) then
    composeSpecimenDefinitionTypeTestedHandling(json, name, TFhirSpecimenDefinitionTypeTestedHandling(base), false)
  else if (base is TFhirSpecimenDefinition) then
    composeSpecimenDefinition(json, name, TFhirSpecimenDefinition(base), false)
{$ENDIF FHIR_SPECIMENDEFINITION}
{$IFDEF FHIR_STRUCTUREDEFINITION}
  else if (base is TFhirStructureDefinitionMapping) then
    composeStructureDefinitionMapping(json, name, TFhirStructureDefinitionMapping(base), false)
  else if (base is TFhirStructureDefinitionContext) then
    composeStructureDefinitionContext(json, name, TFhirStructureDefinitionContext(base), false)
  else if (base is TFhirStructureDefinitionSnapshot) then
    composeStructureDefinitionSnapshot(json, name, TFhirStructureDefinitionSnapshot(base), false)
  else if (base is TFhirStructureDefinitionDifferential) then
    composeStructureDefinitionDifferential(json, name, TFhirStructureDefinitionDifferential(base), false)
  else if (base is TFhirStructureDefinition) then
    composeStructureDefinition(json, name, TFhirStructureDefinition(base), false)
{$ENDIF FHIR_STRUCTUREDEFINITION}
{$IFDEF FHIR_STRUCTUREMAP}
  else if (base is TFhirStructureMapStructure) then
    composeStructureMapStructure(json, name, TFhirStructureMapStructure(base), false)
  else if (base is TFhirStructureMapGroup) then
    composeStructureMapGroup(json, name, TFhirStructureMapGroup(base), false)
  else if (base is TFhirStructureMapGroupInput) then
    composeStructureMapGroupInput(json, name, TFhirStructureMapGroupInput(base), false)
  else if (base is TFhirStructureMapGroupRule) then
    composeStructureMapGroupRule(json, name, TFhirStructureMapGroupRule(base), false)
  else if (base is TFhirStructureMapGroupRuleSource) then
    composeStructureMapGroupRuleSource(json, name, TFhirStructureMapGroupRuleSource(base), false)
  else if (base is TFhirStructureMapGroupRuleTarget) then
    composeStructureMapGroupRuleTarget(json, name, TFhirStructureMapGroupRuleTarget(base), false)
  else if (base is TFhirStructureMapGroupRuleTargetParameter) then
    composeStructureMapGroupRuleTargetParameter(json, name, TFhirStructureMapGroupRuleTargetParameter(base), false)
  else if (base is TFhirStructureMapGroupRuleDependent) then
    composeStructureMapGroupRuleDependent(json, name, TFhirStructureMapGroupRuleDependent(base), false)
  else if (base is TFhirStructureMap) then
    composeStructureMap(json, name, TFhirStructureMap(base), false)
{$ENDIF FHIR_STRUCTUREMAP}
{$IFDEF FHIR_SUBSCRIPTION}
  else if (base is TFhirSubscriptionChannel) then
    composeSubscriptionChannel(json, name, TFhirSubscriptionChannel(base), false)
  else if (base is TFhirSubscription) then
    composeSubscription(json, name, TFhirSubscription(base), false)
{$ENDIF FHIR_SUBSCRIPTION}
{$IFDEF FHIR_SUBSTANCE}
  else if (base is TFhirSubstanceInstance) then
    composeSubstanceInstance(json, name, TFhirSubstanceInstance(base), false)
  else if (base is TFhirSubstanceIngredient) then
    composeSubstanceIngredient(json, name, TFhirSubstanceIngredient(base), false)
  else if (base is TFhirSubstance) then
    composeSubstance(json, name, TFhirSubstance(base), false)
{$ENDIF FHIR_SUBSTANCE}
{$IFDEF FHIR_SUBSTANCENUCLEICACID}
  else if (base is TFhirSubstanceNucleicAcidSubunit) then
    composeSubstanceNucleicAcidSubunit(json, name, TFhirSubstanceNucleicAcidSubunit(base), false)
  else if (base is TFhirSubstanceNucleicAcidSubunitLinkage) then
    composeSubstanceNucleicAcidSubunitLinkage(json, name, TFhirSubstanceNucleicAcidSubunitLinkage(base), false)
  else if (base is TFhirSubstanceNucleicAcidSubunitSugar) then
    composeSubstanceNucleicAcidSubunitSugar(json, name, TFhirSubstanceNucleicAcidSubunitSugar(base), false)
  else if (base is TFhirSubstanceNucleicAcid) then
    composeSubstanceNucleicAcid(json, name, TFhirSubstanceNucleicAcid(base), false)
{$ENDIF FHIR_SUBSTANCENUCLEICACID}
{$IFDEF FHIR_SUBSTANCEPOLYMER}
  else if (base is TFhirSubstancePolymerMonomerSet) then
    composeSubstancePolymerMonomerSet(json, name, TFhirSubstancePolymerMonomerSet(base), false)
  else if (base is TFhirSubstancePolymerMonomerSetStartingMaterial) then
    composeSubstancePolymerMonomerSetStartingMaterial(json, name, TFhirSubstancePolymerMonomerSetStartingMaterial(base), false)
  else if (base is TFhirSubstancePolymerRepeat) then
    composeSubstancePolymerRepeat(json, name, TFhirSubstancePolymerRepeat(base), false)
  else if (base is TFhirSubstancePolymerRepeatRepeatUnit) then
    composeSubstancePolymerRepeatRepeatUnit(json, name, TFhirSubstancePolymerRepeatRepeatUnit(base), false)
  else if (base is TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation) then
    composeSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation(json, name, TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation(base), false)
  else if (base is TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation) then
    composeSubstancePolymerRepeatRepeatUnitStructuralRepresentation(json, name, TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation(base), false)
  else if (base is TFhirSubstancePolymer) then
    composeSubstancePolymer(json, name, TFhirSubstancePolymer(base), false)
{$ENDIF FHIR_SUBSTANCEPOLYMER}
{$IFDEF FHIR_SUBSTANCEPROTEIN}
  else if (base is TFhirSubstanceProteinSubunit) then
    composeSubstanceProteinSubunit(json, name, TFhirSubstanceProteinSubunit(base), false)
  else if (base is TFhirSubstanceProtein) then
    composeSubstanceProtein(json, name, TFhirSubstanceProtein(base), false)
{$ENDIF FHIR_SUBSTANCEPROTEIN}
{$IFDEF FHIR_SUBSTANCEREFERENCEINFORMATION}
  else if (base is TFhirSubstanceReferenceInformationGene) then
    composeSubstanceReferenceInformationGene(json, name, TFhirSubstanceReferenceInformationGene(base), false)
  else if (base is TFhirSubstanceReferenceInformationGeneElement) then
    composeSubstanceReferenceInformationGeneElement(json, name, TFhirSubstanceReferenceInformationGeneElement(base), false)
  else if (base is TFhirSubstanceReferenceInformationClassification) then
    composeSubstanceReferenceInformationClassification(json, name, TFhirSubstanceReferenceInformationClassification(base), false)
  else if (base is TFhirSubstanceReferenceInformationTarget) then
    composeSubstanceReferenceInformationTarget(json, name, TFhirSubstanceReferenceInformationTarget(base), false)
  else if (base is TFhirSubstanceReferenceInformation) then
    composeSubstanceReferenceInformation(json, name, TFhirSubstanceReferenceInformation(base), false)
{$ENDIF FHIR_SUBSTANCEREFERENCEINFORMATION}
{$IFDEF FHIR_SUBSTANCESOURCEMATERIAL}
  else if (base is TFhirSubstanceSourceMaterialFractionDescription) then
    composeSubstanceSourceMaterialFractionDescription(json, name, TFhirSubstanceSourceMaterialFractionDescription(base), false)
  else if (base is TFhirSubstanceSourceMaterialOrganism) then
    composeSubstanceSourceMaterialOrganism(json, name, TFhirSubstanceSourceMaterialOrganism(base), false)
  else if (base is TFhirSubstanceSourceMaterialOrganismAuthor) then
    composeSubstanceSourceMaterialOrganismAuthor(json, name, TFhirSubstanceSourceMaterialOrganismAuthor(base), false)
  else if (base is TFhirSubstanceSourceMaterialOrganismHybrid) then
    composeSubstanceSourceMaterialOrganismHybrid(json, name, TFhirSubstanceSourceMaterialOrganismHybrid(base), false)
  else if (base is TFhirSubstanceSourceMaterialOrganismOrganismGeneral) then
    composeSubstanceSourceMaterialOrganismOrganismGeneral(json, name, TFhirSubstanceSourceMaterialOrganismOrganismGeneral(base), false)
  else if (base is TFhirSubstanceSourceMaterialPartDescription) then
    composeSubstanceSourceMaterialPartDescription(json, name, TFhirSubstanceSourceMaterialPartDescription(base), false)
  else if (base is TFhirSubstanceSourceMaterial) then
    composeSubstanceSourceMaterial(json, name, TFhirSubstanceSourceMaterial(base), false)
{$ENDIF FHIR_SUBSTANCESOURCEMATERIAL}
{$IFDEF FHIR_SUBSTANCESPECIFICATION}
  else if (base is TFhirSubstanceSpecificationMoiety) then
    composeSubstanceSpecificationMoiety(json, name, TFhirSubstanceSpecificationMoiety(base), false)
  else if (base is TFhirSubstanceSpecificationProperty) then
    composeSubstanceSpecificationProperty(json, name, TFhirSubstanceSpecificationProperty(base), false)
  else if (base is TFhirSubstanceSpecificationStructure) then
    composeSubstanceSpecificationStructure(json, name, TFhirSubstanceSpecificationStructure(base), false)
  else if (base is TFhirSubstanceSpecificationStructureIsotope) then
    composeSubstanceSpecificationStructureIsotope(json, name, TFhirSubstanceSpecificationStructureIsotope(base), false)
  else if (base is TFhirSubstanceSpecificationStructureIsotopeMolecularWeight) then
    composeSubstanceSpecificationStructureIsotopeMolecularWeight(json, name, TFhirSubstanceSpecificationStructureIsotopeMolecularWeight(base), false)
  else if (base is TFhirSubstanceSpecificationStructureRepresentation) then
    composeSubstanceSpecificationStructureRepresentation(json, name, TFhirSubstanceSpecificationStructureRepresentation(base), false)
  else if (base is TFhirSubstanceSpecificationCode) then
    composeSubstanceSpecificationCode(json, name, TFhirSubstanceSpecificationCode(base), false)
  else if (base is TFhirSubstanceSpecificationName) then
    composeSubstanceSpecificationName(json, name, TFhirSubstanceSpecificationName(base), false)
  else if (base is TFhirSubstanceSpecificationNameOfficial) then
    composeSubstanceSpecificationNameOfficial(json, name, TFhirSubstanceSpecificationNameOfficial(base), false)
  else if (base is TFhirSubstanceSpecificationRelationship) then
    composeSubstanceSpecificationRelationship(json, name, TFhirSubstanceSpecificationRelationship(base), false)
  else if (base is TFhirSubstanceSpecification) then
    composeSubstanceSpecification(json, name, TFhirSubstanceSpecification(base), false)
{$ENDIF FHIR_SUBSTANCESPECIFICATION}
{$IFDEF FHIR_SUPPLYDELIVERY}
  else if (base is TFhirSupplyDeliverySuppliedItem) then
    composeSupplyDeliverySuppliedItem(json, name, TFhirSupplyDeliverySuppliedItem(base), false)
  else if (base is TFhirSupplyDelivery) then
    composeSupplyDelivery(json, name, TFhirSupplyDelivery(base), false)
{$ENDIF FHIR_SUPPLYDELIVERY}
{$IFDEF FHIR_SUPPLYREQUEST}
  else if (base is TFhirSupplyRequestParameter) then
    composeSupplyRequestParameter(json, name, TFhirSupplyRequestParameter(base), false)
  else if (base is TFhirSupplyRequest) then
    composeSupplyRequest(json, name, TFhirSupplyRequest(base), false)
{$ENDIF FHIR_SUPPLYREQUEST}
{$IFDEF FHIR_TASK}
  else if (base is TFhirTaskRestriction) then
    composeTaskRestriction(json, name, TFhirTaskRestriction(base), false)
  else if (base is TFhirTaskInput) then
    composeTaskInput(json, name, TFhirTaskInput(base), false)
  else if (base is TFhirTaskOutput) then
    composeTaskOutput(json, name, TFhirTaskOutput(base), false)
  else if (base is TFhirTask) then
    composeTask(json, name, TFhirTask(base), false)
{$ENDIF FHIR_TASK}
{$IFDEF FHIR_TERMINOLOGYCAPABILITIES}
  else if (base is TFhirTerminologyCapabilitiesSoftware) then
    composeTerminologyCapabilitiesSoftware(json, name, TFhirTerminologyCapabilitiesSoftware(base), false)
  else if (base is TFhirTerminologyCapabilitiesImplementation) then
    composeTerminologyCapabilitiesImplementation(json, name, TFhirTerminologyCapabilitiesImplementation(base), false)
  else if (base is TFhirTerminologyCapabilitiesCodeSystem) then
    composeTerminologyCapabilitiesCodeSystem(json, name, TFhirTerminologyCapabilitiesCodeSystem(base), false)
  else if (base is TFhirTerminologyCapabilitiesCodeSystemVersion) then
    composeTerminologyCapabilitiesCodeSystemVersion(json, name, TFhirTerminologyCapabilitiesCodeSystemVersion(base), false)
  else if (base is TFhirTerminologyCapabilitiesCodeSystemVersionFilter) then
    composeTerminologyCapabilitiesCodeSystemVersionFilter(json, name, TFhirTerminologyCapabilitiesCodeSystemVersionFilter(base), false)
  else if (base is TFhirTerminologyCapabilitiesExpansion) then
    composeTerminologyCapabilitiesExpansion(json, name, TFhirTerminologyCapabilitiesExpansion(base), false)
  else if (base is TFhirTerminologyCapabilitiesExpansionParameter) then
    composeTerminologyCapabilitiesExpansionParameter(json, name, TFhirTerminologyCapabilitiesExpansionParameter(base), false)
  else if (base is TFhirTerminologyCapabilitiesValidateCode) then
    composeTerminologyCapabilitiesValidateCode(json, name, TFhirTerminologyCapabilitiesValidateCode(base), false)
  else if (base is TFhirTerminologyCapabilitiesTranslation) then
    composeTerminologyCapabilitiesTranslation(json, name, TFhirTerminologyCapabilitiesTranslation(base), false)
  else if (base is TFhirTerminologyCapabilitiesClosure) then
    composeTerminologyCapabilitiesClosure(json, name, TFhirTerminologyCapabilitiesClosure(base), false)
  else if (base is TFhirTerminologyCapabilities) then
    composeTerminologyCapabilities(json, name, TFhirTerminologyCapabilities(base), false)
{$ENDIF FHIR_TERMINOLOGYCAPABILITIES}
{$IFDEF FHIR_TESTREPORT}
  else if (base is TFhirTestReportParticipant) then
    composeTestReportParticipant(json, name, TFhirTestReportParticipant(base), false)
  else if (base is TFhirTestReportSetup) then
    composeTestReportSetup(json, name, TFhirTestReportSetup(base), false)
  else if (base is TFhirTestReportSetupAction) then
    composeTestReportSetupAction(json, name, TFhirTestReportSetupAction(base), false)
  else if (base is TFhirTestReportSetupActionOperation) then
    composeTestReportSetupActionOperation(json, name, TFhirTestReportSetupActionOperation(base), false)
  else if (base is TFhirTestReportSetupActionAssert) then
    composeTestReportSetupActionAssert(json, name, TFhirTestReportSetupActionAssert(base), false)
  else if (base is TFhirTestReportTest) then
    composeTestReportTest(json, name, TFhirTestReportTest(base), false)
  else if (base is TFhirTestReportTestAction) then
    composeTestReportTestAction(json, name, TFhirTestReportTestAction(base), false)
  else if (base is TFhirTestReportTeardown) then
    composeTestReportTeardown(json, name, TFhirTestReportTeardown(base), false)
  else if (base is TFhirTestReportTeardownAction) then
    composeTestReportTeardownAction(json, name, TFhirTestReportTeardownAction(base), false)
  else if (base is TFhirTestReport) then
    composeTestReport(json, name, TFhirTestReport(base), false)
{$ENDIF FHIR_TESTREPORT}
{$IFDEF FHIR_TESTSCRIPT}
  else if (base is TFhirTestScriptOrigin) then
    composeTestScriptOrigin(json, name, TFhirTestScriptOrigin(base), false)
  else if (base is TFhirTestScriptDestination) then
    composeTestScriptDestination(json, name, TFhirTestScriptDestination(base), false)
  else if (base is TFhirTestScriptMetadata) then
    composeTestScriptMetadata(json, name, TFhirTestScriptMetadata(base), false)
  else if (base is TFhirTestScriptMetadataLink) then
    composeTestScriptMetadataLink(json, name, TFhirTestScriptMetadataLink(base), false)
  else if (base is TFhirTestScriptMetadataCapability) then
    composeTestScriptMetadataCapability(json, name, TFhirTestScriptMetadataCapability(base), false)
  else if (base is TFhirTestScriptFixture) then
    composeTestScriptFixture(json, name, TFhirTestScriptFixture(base), false)
  else if (base is TFhirTestScriptVariable) then
    composeTestScriptVariable(json, name, TFhirTestScriptVariable(base), false)
  else if (base is TFhirTestScriptSetup) then
    composeTestScriptSetup(json, name, TFhirTestScriptSetup(base), false)
  else if (base is TFhirTestScriptSetupAction) then
    composeTestScriptSetupAction(json, name, TFhirTestScriptSetupAction(base), false)
  else if (base is TFhirTestScriptSetupActionOperation) then
    composeTestScriptSetupActionOperation(json, name, TFhirTestScriptSetupActionOperation(base), false)
  else if (base is TFhirTestScriptSetupActionOperationRequestHeader) then
    composeTestScriptSetupActionOperationRequestHeader(json, name, TFhirTestScriptSetupActionOperationRequestHeader(base), false)
  else if (base is TFhirTestScriptSetupActionAssert) then
    composeTestScriptSetupActionAssert(json, name, TFhirTestScriptSetupActionAssert(base), false)
  else if (base is TFhirTestScriptTest) then
    composeTestScriptTest(json, name, TFhirTestScriptTest(base), false)
  else if (base is TFhirTestScriptTestAction) then
    composeTestScriptTestAction(json, name, TFhirTestScriptTestAction(base), false)
  else if (base is TFhirTestScriptTeardown) then
    composeTestScriptTeardown(json, name, TFhirTestScriptTeardown(base), false)
  else if (base is TFhirTestScriptTeardownAction) then
    composeTestScriptTeardownAction(json, name, TFhirTestScriptTeardownAction(base), false)
  else if (base is TFhirTestScript) then
    composeTestScript(json, name, TFhirTestScript(base), false)
{$ENDIF FHIR_TESTSCRIPT}
{$IFDEF FHIR_VALUESET}
  else if (base is TFhirValueSetCompose) then
    composeValueSetCompose(json, name, TFhirValueSetCompose(base), false)
  else if (base is TFhirValueSetComposeInclude) then
    composeValueSetComposeInclude(json, name, TFhirValueSetComposeInclude(base), false)
  else if (base is TFhirValueSetComposeIncludeConcept) then
    composeValueSetComposeIncludeConcept(json, name, TFhirValueSetComposeIncludeConcept(base), false)
  else if (base is TFhirValueSetComposeIncludeConceptDesignation) then
    composeValueSetComposeIncludeConceptDesignation(json, name, TFhirValueSetComposeIncludeConceptDesignation(base), false)
  else if (base is TFhirValueSetComposeIncludeFilter) then
    composeValueSetComposeIncludeFilter(json, name, TFhirValueSetComposeIncludeFilter(base), false)
  else if (base is TFhirValueSetExpansion) then
    composeValueSetExpansion(json, name, TFhirValueSetExpansion(base), false)
  else if (base is TFhirValueSetExpansionParameter) then
    composeValueSetExpansionParameter(json, name, TFhirValueSetExpansionParameter(base), false)
  else if (base is TFhirValueSetExpansionContains) then
    composeValueSetExpansionContains(json, name, TFhirValueSetExpansionContains(base), false)
  else if (base is TFhirValueSet) then
    composeValueSet(json, name, TFhirValueSet(base), false)
{$ENDIF FHIR_VALUESET}
{$IFDEF FHIR_VERIFICATIONRESULT}
  else if (base is TFhirVerificationResultPrimarySource) then
    composeVerificationResultPrimarySource(json, name, TFhirVerificationResultPrimarySource(base), false)
  else if (base is TFhirVerificationResultAttestation) then
    composeVerificationResultAttestation(json, name, TFhirVerificationResultAttestation(base), false)
  else if (base is TFhirVerificationResultValidator) then
    composeVerificationResultValidator(json, name, TFhirVerificationResultValidator(base), false)
  else if (base is TFhirVerificationResult) then
    composeVerificationResult(json, name, TFhirVerificationResult(base), false)
{$ENDIF FHIR_VERIFICATIONRESULT}
{$IFDEF FHIR_VISIONPRESCRIPTION}
  else if (base is TFhirVisionPrescriptionLensSpecification) then
    composeVisionPrescriptionLensSpecification(json, name, TFhirVisionPrescriptionLensSpecification(base), false)
  else if (base is TFhirVisionPrescriptionLensSpecificationPrism) then
    composeVisionPrescriptionLensSpecificationPrism(json, name, TFhirVisionPrescriptionLensSpecificationPrism(base), false)
  else if (base is TFhirVisionPrescription) then
    composeVisionPrescription(json, name, TFhirVisionPrescription(base), false)
{$ENDIF FHIR_VISIONPRESCRIPTION}
  else
    inherited ComposeBase(json, name, base);
end;

procedure TFHIRJsonComposer.ComposeResource(json : TJSONWriter; resource: TFhirResource);
begin
  if (resource = nil) Then
    Raise EJsonException.Create('error - resource is nil');
  json.value('resourceType', CODES_TFhirResourceType[resource.ResourceType]);
  Case resource.ResourceType of
{$IFDEF FHIR_PARAMETERS}
    frtParameters: ComposeParameters(json, 'Parameters', TFhirParameters(resource));
{$ENDIF FHIR_PARAMETERS}
{$IFDEF FHIR_ACCOUNT}
  {$IFDEF FHIR_ACCOUNT}
     frtAccount: ComposeAccount(json, 'Account', TFhirAccount(resource));
   {$ENDIF}
{$ENDIF FHIR_ACCOUNT}
{$IFDEF FHIR_ACTIVITYDEFINITION}
  {$IFDEF FHIR_ACTIVITYDEFINITION}
     frtActivityDefinition: ComposeActivityDefinition(json, 'ActivityDefinition', TFhirActivityDefinition(resource));
   {$ENDIF}
{$ENDIF FHIR_ACTIVITYDEFINITION}
{$IFDEF FHIR_ADVERSEEVENT}
  {$IFDEF FHIR_ADVERSEEVENT}
     frtAdverseEvent: ComposeAdverseEvent(json, 'AdverseEvent', TFhirAdverseEvent(resource));
   {$ENDIF}
{$ENDIF FHIR_ADVERSEEVENT}
{$IFDEF FHIR_ALLERGYINTOLERANCE}
  {$IFDEF FHIR_ALLERGYINTOLERANCE}
     frtAllergyIntolerance: ComposeAllergyIntolerance(json, 'AllergyIntolerance', TFhirAllergyIntolerance(resource));
   {$ENDIF}
{$ENDIF FHIR_ALLERGYINTOLERANCE}
{$IFDEF FHIR_APPOINTMENT}
  {$IFDEF FHIR_APPOINTMENT}
     frtAppointment: ComposeAppointment(json, 'Appointment', TFhirAppointment(resource));
   {$ENDIF}
{$ENDIF FHIR_APPOINTMENT}
{$IFDEF FHIR_APPOINTMENTRESPONSE}
  {$IFDEF FHIR_APPOINTMENTRESPONSE}
     frtAppointmentResponse: ComposeAppointmentResponse(json, 'AppointmentResponse', TFhirAppointmentResponse(resource));
   {$ENDIF}
{$ENDIF FHIR_APPOINTMENTRESPONSE}
{$IFDEF FHIR_AUDITEVENT}
  {$IFDEF FHIR_AUDITEVENT}
     frtAuditEvent: ComposeAuditEvent(json, 'AuditEvent', TFhirAuditEvent(resource));
   {$ENDIF}
{$ENDIF FHIR_AUDITEVENT}
{$IFDEF FHIR_BASIC}
  {$IFDEF FHIR_BASIC}
     frtBasic: ComposeBasic(json, 'Basic', TFhirBasic(resource));
   {$ENDIF}
{$ENDIF FHIR_BASIC}
{$IFDEF FHIR_BINARY}
  {$IFDEF FHIR_BINARY}
     frtBinary: ComposeBinary(json, 'Binary', TFhirBinary(resource));
   {$ENDIF}
{$ENDIF FHIR_BINARY}
{$IFDEF FHIR_BIOLOGICALLYDERIVEDPRODUCT}
  {$IFDEF FHIR_BIOLOGICALLYDERIVEDPRODUCT}
     frtBiologicallyDerivedProduct: ComposeBiologicallyDerivedProduct(json, 'BiologicallyDerivedProduct', TFhirBiologicallyDerivedProduct(resource));
   {$ENDIF}
{$ENDIF FHIR_BIOLOGICALLYDERIVEDPRODUCT}
{$IFDEF FHIR_BODYSTRUCTURE}
  {$IFDEF FHIR_BODYSTRUCTURE}
     frtBodyStructure: ComposeBodyStructure(json, 'BodyStructure', TFhirBodyStructure(resource));
   {$ENDIF}
{$ENDIF FHIR_BODYSTRUCTURE}
{$IFDEF FHIR_BUNDLE}
  {$IFDEF FHIR_BUNDLE}
     frtBundle: ComposeBundle(json, 'Bundle', TFhirBundle(resource));
   {$ENDIF}
{$ENDIF FHIR_BUNDLE}
{$IFDEF FHIR_CAPABILITYSTATEMENT}
  {$IFDEF FHIR_CAPABILITYSTATEMENT}
     frtCapabilityStatement: ComposeCapabilityStatement(json, 'CapabilityStatement', TFhirCapabilityStatement(resource));
   {$ENDIF}
{$ENDIF FHIR_CAPABILITYSTATEMENT}
{$IFDEF FHIR_CAREPLAN}
  {$IFDEF FHIR_CAREPLAN}
     frtCarePlan: ComposeCarePlan(json, 'CarePlan', TFhirCarePlan(resource));
   {$ENDIF}
{$ENDIF FHIR_CAREPLAN}
{$IFDEF FHIR_CARETEAM}
  {$IFDEF FHIR_CARETEAM}
     frtCareTeam: ComposeCareTeam(json, 'CareTeam', TFhirCareTeam(resource));
   {$ENDIF}
{$ENDIF FHIR_CARETEAM}
{$IFDEF FHIR_CATALOGENTRY}
  {$IFDEF FHIR_CATALOGENTRY}
     frtCatalogEntry: ComposeCatalogEntry(json, 'CatalogEntry', TFhirCatalogEntry(resource));
   {$ENDIF}
{$ENDIF FHIR_CATALOGENTRY}
{$IFDEF FHIR_CHARGEITEM}
  {$IFDEF FHIR_CHARGEITEM}
     frtChargeItem: ComposeChargeItem(json, 'ChargeItem', TFhirChargeItem(resource));
   {$ENDIF}
{$ENDIF FHIR_CHARGEITEM}
{$IFDEF FHIR_CHARGEITEMDEFINITION}
  {$IFDEF FHIR_CHARGEITEMDEFINITION}
     frtChargeItemDefinition: ComposeChargeItemDefinition(json, 'ChargeItemDefinition', TFhirChargeItemDefinition(resource));
   {$ENDIF}
{$ENDIF FHIR_CHARGEITEMDEFINITION}
{$IFDEF FHIR_CLAIM}
  {$IFDEF FHIR_CLAIM}
     frtClaim: ComposeClaim(json, 'Claim', TFhirClaim(resource));
   {$ENDIF}
{$ENDIF FHIR_CLAIM}
{$IFDEF FHIR_CLAIMRESPONSE}
  {$IFDEF FHIR_CLAIMRESPONSE}
     frtClaimResponse: ComposeClaimResponse(json, 'ClaimResponse', TFhirClaimResponse(resource));
   {$ENDIF}
{$ENDIF FHIR_CLAIMRESPONSE}
{$IFDEF FHIR_CLINICALIMPRESSION}
  {$IFDEF FHIR_CLINICALIMPRESSION}
     frtClinicalImpression: ComposeClinicalImpression(json, 'ClinicalImpression', TFhirClinicalImpression(resource));
   {$ENDIF}
{$ENDIF FHIR_CLINICALIMPRESSION}
{$IFDEF FHIR_CODESYSTEM}
  {$IFDEF FHIR_CODESYSTEM}
     frtCodeSystem: ComposeCodeSystem(json, 'CodeSystem', TFhirCodeSystem(resource));
   {$ENDIF}
{$ENDIF FHIR_CODESYSTEM}
{$IFDEF FHIR_COMMUNICATION}
  {$IFDEF FHIR_COMMUNICATION}
     frtCommunication: ComposeCommunication(json, 'Communication', TFhirCommunication(resource));
   {$ENDIF}
{$ENDIF FHIR_COMMUNICATION}
{$IFDEF FHIR_COMMUNICATIONREQUEST}
  {$IFDEF FHIR_COMMUNICATIONREQUEST}
     frtCommunicationRequest: ComposeCommunicationRequest(json, 'CommunicationRequest', TFhirCommunicationRequest(resource));
   {$ENDIF}
{$ENDIF FHIR_COMMUNICATIONREQUEST}
{$IFDEF FHIR_COMPARTMENTDEFINITION}
  {$IFDEF FHIR_COMPARTMENTDEFINITION}
     frtCompartmentDefinition: ComposeCompartmentDefinition(json, 'CompartmentDefinition', TFhirCompartmentDefinition(resource));
   {$ENDIF}
{$ENDIF FHIR_COMPARTMENTDEFINITION}
{$IFDEF FHIR_COMPOSITION}
  {$IFDEF FHIR_COMPOSITION}
     frtComposition: ComposeComposition(json, 'Composition', TFhirComposition(resource));
   {$ENDIF}
{$ENDIF FHIR_COMPOSITION}
{$IFDEF FHIR_CONCEPTMAP}
  {$IFDEF FHIR_CONCEPTMAP}
     frtConceptMap: ComposeConceptMap(json, 'ConceptMap', TFhirConceptMap(resource));
   {$ENDIF}
{$ENDIF FHIR_CONCEPTMAP}
{$IFDEF FHIR_CONDITION}
  {$IFDEF FHIR_CONDITION}
     frtCondition: ComposeCondition(json, 'Condition', TFhirCondition(resource));
   {$ENDIF}
{$ENDIF FHIR_CONDITION}
{$IFDEF FHIR_CONSENT}
  {$IFDEF FHIR_CONSENT}
     frtConsent: ComposeConsent(json, 'Consent', TFhirConsent(resource));
   {$ENDIF}
{$ENDIF FHIR_CONSENT}
{$IFDEF FHIR_CONTRACT}
  {$IFDEF FHIR_CONTRACT}
     frtContract: ComposeContract(json, 'Contract', TFhirContract(resource));
   {$ENDIF}
{$ENDIF FHIR_CONTRACT}
{$IFDEF FHIR_COVERAGE}
  {$IFDEF FHIR_COVERAGE}
     frtCoverage: ComposeCoverage(json, 'Coverage', TFhirCoverage(resource));
   {$ENDIF}
{$ENDIF FHIR_COVERAGE}
{$IFDEF FHIR_COVERAGEELIGIBILITYREQUEST}
  {$IFDEF FHIR_COVERAGEELIGIBILITYREQUEST}
     frtCoverageEligibilityRequest: ComposeCoverageEligibilityRequest(json, 'CoverageEligibilityRequest', TFhirCoverageEligibilityRequest(resource));
   {$ENDIF}
{$ENDIF FHIR_COVERAGEELIGIBILITYREQUEST}
{$IFDEF FHIR_COVERAGEELIGIBILITYRESPONSE}
  {$IFDEF FHIR_COVERAGEELIGIBILITYRESPONSE}
     frtCoverageEligibilityResponse: ComposeCoverageEligibilityResponse(json, 'CoverageEligibilityResponse', TFhirCoverageEligibilityResponse(resource));
   {$ENDIF}
{$ENDIF FHIR_COVERAGEELIGIBILITYRESPONSE}
{$IFDEF FHIR_DETECTEDISSUE}
  {$IFDEF FHIR_DETECTEDISSUE}
     frtDetectedIssue: ComposeDetectedIssue(json, 'DetectedIssue', TFhirDetectedIssue(resource));
   {$ENDIF}
{$ENDIF FHIR_DETECTEDISSUE}
{$IFDEF FHIR_DEVICE}
  {$IFDEF FHIR_DEVICE}
     frtDevice: ComposeDevice(json, 'Device', TFhirDevice(resource));
   {$ENDIF}
{$ENDIF FHIR_DEVICE}
{$IFDEF FHIR_DEVICEDEFINITION}
  {$IFDEF FHIR_DEVICEDEFINITION}
     frtDeviceDefinition: ComposeDeviceDefinition(json, 'DeviceDefinition', TFhirDeviceDefinition(resource));
   {$ENDIF}
{$ENDIF FHIR_DEVICEDEFINITION}
{$IFDEF FHIR_DEVICEMETRIC}
  {$IFDEF FHIR_DEVICEMETRIC}
     frtDeviceMetric: ComposeDeviceMetric(json, 'DeviceMetric', TFhirDeviceMetric(resource));
   {$ENDIF}
{$ENDIF FHIR_DEVICEMETRIC}
{$IFDEF FHIR_DEVICEREQUEST}
  {$IFDEF FHIR_DEVICEREQUEST}
     frtDeviceRequest: ComposeDeviceRequest(json, 'DeviceRequest', TFhirDeviceRequest(resource));
   {$ENDIF}
{$ENDIF FHIR_DEVICEREQUEST}
{$IFDEF FHIR_DEVICEUSESTATEMENT}
  {$IFDEF FHIR_DEVICEUSESTATEMENT}
     frtDeviceUseStatement: ComposeDeviceUseStatement(json, 'DeviceUseStatement', TFhirDeviceUseStatement(resource));
   {$ENDIF}
{$ENDIF FHIR_DEVICEUSESTATEMENT}
{$IFDEF FHIR_DIAGNOSTICREPORT}
  {$IFDEF FHIR_DIAGNOSTICREPORT}
     frtDiagnosticReport: ComposeDiagnosticReport(json, 'DiagnosticReport', TFhirDiagnosticReport(resource));
   {$ENDIF}
{$ENDIF FHIR_DIAGNOSTICREPORT}
{$IFDEF FHIR_DOCUMENTMANIFEST}
  {$IFDEF FHIR_DOCUMENTMANIFEST}
     frtDocumentManifest: ComposeDocumentManifest(json, 'DocumentManifest', TFhirDocumentManifest(resource));
   {$ENDIF}
{$ENDIF FHIR_DOCUMENTMANIFEST}
{$IFDEF FHIR_DOCUMENTREFERENCE}
  {$IFDEF FHIR_DOCUMENTREFERENCE}
     frtDocumentReference: ComposeDocumentReference(json, 'DocumentReference', TFhirDocumentReference(resource));
   {$ENDIF}
{$ENDIF FHIR_DOCUMENTREFERENCE}
{$IFDEF FHIR_EFFECTEVIDENCESYNTHESIS}
  {$IFDEF FHIR_EFFECTEVIDENCESYNTHESIS}
     frtEffectEvidenceSynthesis: ComposeEffectEvidenceSynthesis(json, 'EffectEvidenceSynthesis', TFhirEffectEvidenceSynthesis(resource));
   {$ENDIF}
{$ENDIF FHIR_EFFECTEVIDENCESYNTHESIS}
{$IFDEF FHIR_ENCOUNTER}
  {$IFDEF FHIR_ENCOUNTER}
     frtEncounter: ComposeEncounter(json, 'Encounter', TFhirEncounter(resource));
   {$ENDIF}
{$ENDIF FHIR_ENCOUNTER}
{$IFDEF FHIR_ENDPOINT}
  {$IFDEF FHIR_ENDPOINT}
     frtEndpoint: ComposeEndpoint(json, 'Endpoint', TFhirEndpoint(resource));
   {$ENDIF}
{$ENDIF FHIR_ENDPOINT}
{$IFDEF FHIR_ENROLLMENTREQUEST}
  {$IFDEF FHIR_ENROLLMENTREQUEST}
     frtEnrollmentRequest: ComposeEnrollmentRequest(json, 'EnrollmentRequest', TFhirEnrollmentRequest(resource));
   {$ENDIF}
{$ENDIF FHIR_ENROLLMENTREQUEST}
{$IFDEF FHIR_ENROLLMENTRESPONSE}
  {$IFDEF FHIR_ENROLLMENTRESPONSE}
     frtEnrollmentResponse: ComposeEnrollmentResponse(json, 'EnrollmentResponse', TFhirEnrollmentResponse(resource));
   {$ENDIF}
{$ENDIF FHIR_ENROLLMENTRESPONSE}
{$IFDEF FHIR_EPISODEOFCARE}
  {$IFDEF FHIR_EPISODEOFCARE}
     frtEpisodeOfCare: ComposeEpisodeOfCare(json, 'EpisodeOfCare', TFhirEpisodeOfCare(resource));
   {$ENDIF}
{$ENDIF FHIR_EPISODEOFCARE}
{$IFDEF FHIR_EVENTDEFINITION}
  {$IFDEF FHIR_EVENTDEFINITION}
     frtEventDefinition: ComposeEventDefinition(json, 'EventDefinition', TFhirEventDefinition(resource));
   {$ENDIF}
{$ENDIF FHIR_EVENTDEFINITION}
{$IFDEF FHIR_EVIDENCE}
  {$IFDEF FHIR_EVIDENCE}
     frtEvidence: ComposeEvidence(json, 'Evidence', TFhirEvidence(resource));
   {$ENDIF}
{$ENDIF FHIR_EVIDENCE}
{$IFDEF FHIR_EVIDENCEVARIABLE}
  {$IFDEF FHIR_EVIDENCEVARIABLE}
     frtEvidenceVariable: ComposeEvidenceVariable(json, 'EvidenceVariable', TFhirEvidenceVariable(resource));
   {$ENDIF}
{$ENDIF FHIR_EVIDENCEVARIABLE}
{$IFDEF FHIR_EXAMPLESCENARIO}
  {$IFDEF FHIR_EXAMPLESCENARIO}
     frtExampleScenario: ComposeExampleScenario(json, 'ExampleScenario', TFhirExampleScenario(resource));
   {$ENDIF}
{$ENDIF FHIR_EXAMPLESCENARIO}
{$IFDEF FHIR_EXPLANATIONOFBENEFIT}
  {$IFDEF FHIR_EXPLANATIONOFBENEFIT}
     frtExplanationOfBenefit: ComposeExplanationOfBenefit(json, 'ExplanationOfBenefit', TFhirExplanationOfBenefit(resource));
   {$ENDIF}
{$ENDIF FHIR_EXPLANATIONOFBENEFIT}
{$IFDEF FHIR_FAMILYMEMBERHISTORY}
  {$IFDEF FHIR_FAMILYMEMBERHISTORY}
     frtFamilyMemberHistory: ComposeFamilyMemberHistory(json, 'FamilyMemberHistory', TFhirFamilyMemberHistory(resource));
   {$ENDIF}
{$ENDIF FHIR_FAMILYMEMBERHISTORY}
{$IFDEF FHIR_FLAG}
  {$IFDEF FHIR_FLAG}
     frtFlag: ComposeFlag(json, 'Flag', TFhirFlag(resource));
   {$ENDIF}
{$ENDIF FHIR_FLAG}
{$IFDEF FHIR_GOAL}
  {$IFDEF FHIR_GOAL}
     frtGoal: ComposeGoal(json, 'Goal', TFhirGoal(resource));
   {$ENDIF}
{$ENDIF FHIR_GOAL}
{$IFDEF FHIR_GRAPHDEFINITION}
  {$IFDEF FHIR_GRAPHDEFINITION}
     frtGraphDefinition: ComposeGraphDefinition(json, 'GraphDefinition', TFhirGraphDefinition(resource));
   {$ENDIF}
{$ENDIF FHIR_GRAPHDEFINITION}
{$IFDEF FHIR_GROUP}
  {$IFDEF FHIR_GROUP}
     frtGroup: ComposeGroup(json, 'Group', TFhirGroup(resource));
   {$ENDIF}
{$ENDIF FHIR_GROUP}
{$IFDEF FHIR_GUIDANCERESPONSE}
  {$IFDEF FHIR_GUIDANCERESPONSE}
     frtGuidanceResponse: ComposeGuidanceResponse(json, 'GuidanceResponse', TFhirGuidanceResponse(resource));
   {$ENDIF}
{$ENDIF FHIR_GUIDANCERESPONSE}
{$IFDEF FHIR_HEALTHCARESERVICE}
  {$IFDEF FHIR_HEALTHCARESERVICE}
     frtHealthcareService: ComposeHealthcareService(json, 'HealthcareService', TFhirHealthcareService(resource));
   {$ENDIF}
{$ENDIF FHIR_HEALTHCARESERVICE}
{$IFDEF FHIR_IMAGINGSTUDY}
  {$IFDEF FHIR_IMAGINGSTUDY}
     frtImagingStudy: ComposeImagingStudy(json, 'ImagingStudy', TFhirImagingStudy(resource));
   {$ENDIF}
{$ENDIF FHIR_IMAGINGSTUDY}
{$IFDEF FHIR_IMMUNIZATION}
  {$IFDEF FHIR_IMMUNIZATION}
     frtImmunization: ComposeImmunization(json, 'Immunization', TFhirImmunization(resource));
   {$ENDIF}
{$ENDIF FHIR_IMMUNIZATION}
{$IFDEF FHIR_IMMUNIZATIONEVALUATION}
  {$IFDEF FHIR_IMMUNIZATIONEVALUATION}
     frtImmunizationEvaluation: ComposeImmunizationEvaluation(json, 'ImmunizationEvaluation', TFhirImmunizationEvaluation(resource));
   {$ENDIF}
{$ENDIF FHIR_IMMUNIZATIONEVALUATION}
{$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
  {$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
     frtImmunizationRecommendation: ComposeImmunizationRecommendation(json, 'ImmunizationRecommendation', TFhirImmunizationRecommendation(resource));
   {$ENDIF}
{$ENDIF FHIR_IMMUNIZATIONRECOMMENDATION}
{$IFDEF FHIR_IMPLEMENTATIONGUIDE}
  {$IFDEF FHIR_IMPLEMENTATIONGUIDE}
     frtImplementationGuide: ComposeImplementationGuide(json, 'ImplementationGuide', TFhirImplementationGuide(resource));
   {$ENDIF}
{$ENDIF FHIR_IMPLEMENTATIONGUIDE}
{$IFDEF FHIR_INSURANCEPLAN}
  {$IFDEF FHIR_INSURANCEPLAN}
     frtInsurancePlan: ComposeInsurancePlan(json, 'InsurancePlan', TFhirInsurancePlan(resource));
   {$ENDIF}
{$ENDIF FHIR_INSURANCEPLAN}
{$IFDEF FHIR_INVOICE}
  {$IFDEF FHIR_INVOICE}
     frtInvoice: ComposeInvoice(json, 'Invoice', TFhirInvoice(resource));
   {$ENDIF}
{$ENDIF FHIR_INVOICE}
{$IFDEF FHIR_LIBRARY}
  {$IFDEF FHIR_LIBRARY}
     frtLibrary: ComposeLibrary(json, 'Library', TFhirLibrary(resource));
   {$ENDIF}
{$ENDIF FHIR_LIBRARY}
{$IFDEF FHIR_LINKAGE}
  {$IFDEF FHIR_LINKAGE}
     frtLinkage: ComposeLinkage(json, 'Linkage', TFhirLinkage(resource));
   {$ENDIF}
{$ENDIF FHIR_LINKAGE}
{$IFDEF FHIR_LIST}
  {$IFDEF FHIR_LIST}
     frtList: ComposeList(json, 'List', TFhirList(resource));
   {$ENDIF}
{$ENDIF FHIR_LIST}
{$IFDEF FHIR_LOCATION}
  {$IFDEF FHIR_LOCATION}
     frtLocation: ComposeLocation(json, 'Location', TFhirLocation(resource));
   {$ENDIF}
{$ENDIF FHIR_LOCATION}
{$IFDEF FHIR_MEASURE}
  {$IFDEF FHIR_MEASURE}
     frtMeasure: ComposeMeasure(json, 'Measure', TFhirMeasure(resource));
   {$ENDIF}
{$ENDIF FHIR_MEASURE}
{$IFDEF FHIR_MEASUREREPORT}
  {$IFDEF FHIR_MEASUREREPORT}
     frtMeasureReport: ComposeMeasureReport(json, 'MeasureReport', TFhirMeasureReport(resource));
   {$ENDIF}
{$ENDIF FHIR_MEASUREREPORT}
{$IFDEF FHIR_MEDIA}
  {$IFDEF FHIR_MEDIA}
     frtMedia: ComposeMedia(json, 'Media', TFhirMedia(resource));
   {$ENDIF}
{$ENDIF FHIR_MEDIA}
{$IFDEF FHIR_MEDICATION}
  {$IFDEF FHIR_MEDICATION}
     frtMedication: ComposeMedication(json, 'Medication', TFhirMedication(resource));
   {$ENDIF}
{$ENDIF FHIR_MEDICATION}
{$IFDEF FHIR_MEDICATIONADMINISTRATION}
  {$IFDEF FHIR_MEDICATIONADMINISTRATION}
     frtMedicationAdministration: ComposeMedicationAdministration(json, 'MedicationAdministration', TFhirMedicationAdministration(resource));
   {$ENDIF}
{$ENDIF FHIR_MEDICATIONADMINISTRATION}
{$IFDEF FHIR_MEDICATIONDISPENSE}
  {$IFDEF FHIR_MEDICATIONDISPENSE}
     frtMedicationDispense: ComposeMedicationDispense(json, 'MedicationDispense', TFhirMedicationDispense(resource));
   {$ENDIF}
{$ENDIF FHIR_MEDICATIONDISPENSE}
{$IFDEF FHIR_MEDICATIONKNOWLEDGE}
  {$IFDEF FHIR_MEDICATIONKNOWLEDGE}
     frtMedicationKnowledge: ComposeMedicationKnowledge(json, 'MedicationKnowledge', TFhirMedicationKnowledge(resource));
   {$ENDIF}
{$ENDIF FHIR_MEDICATIONKNOWLEDGE}
{$IFDEF FHIR_MEDICATIONREQUEST}
  {$IFDEF FHIR_MEDICATIONREQUEST}
     frtMedicationRequest: ComposeMedicationRequest(json, 'MedicationRequest', TFhirMedicationRequest(resource));
   {$ENDIF}
{$ENDIF FHIR_MEDICATIONREQUEST}
{$IFDEF FHIR_MEDICATIONSTATEMENT}
  {$IFDEF FHIR_MEDICATIONSTATEMENT}
     frtMedicationStatement: ComposeMedicationStatement(json, 'MedicationStatement', TFhirMedicationStatement(resource));
   {$ENDIF}
{$ENDIF FHIR_MEDICATIONSTATEMENT}
{$IFDEF FHIR_MEDICINALPRODUCT}
  {$IFDEF FHIR_MEDICINALPRODUCT}
     frtMedicinalProduct: ComposeMedicinalProduct(json, 'MedicinalProduct', TFhirMedicinalProduct(resource));
   {$ENDIF}
{$ENDIF FHIR_MEDICINALPRODUCT}
{$IFDEF FHIR_MEDICINALPRODUCTAUTHORIZATION}
  {$IFDEF FHIR_MEDICINALPRODUCTAUTHORIZATION}
     frtMedicinalProductAuthorization: ComposeMedicinalProductAuthorization(json, 'MedicinalProductAuthorization', TFhirMedicinalProductAuthorization(resource));
   {$ENDIF}
{$ENDIF FHIR_MEDICINALPRODUCTAUTHORIZATION}
{$IFDEF FHIR_MEDICINALPRODUCTCONTRAINDICATION}
  {$IFDEF FHIR_MEDICINALPRODUCTCONTRAINDICATION}
     frtMedicinalProductContraindication: ComposeMedicinalProductContraindication(json, 'MedicinalProductContraindication', TFhirMedicinalProductContraindication(resource));
   {$ENDIF}
{$ENDIF FHIR_MEDICINALPRODUCTCONTRAINDICATION}
{$IFDEF FHIR_MEDICINALPRODUCTINDICATION}
  {$IFDEF FHIR_MEDICINALPRODUCTINDICATION}
     frtMedicinalProductIndication: ComposeMedicinalProductIndication(json, 'MedicinalProductIndication', TFhirMedicinalProductIndication(resource));
   {$ENDIF}
{$ENDIF FHIR_MEDICINALPRODUCTINDICATION}
{$IFDEF FHIR_MEDICINALPRODUCTINGREDIENT}
  {$IFDEF FHIR_MEDICINALPRODUCTINGREDIENT}
     frtMedicinalProductIngredient: ComposeMedicinalProductIngredient(json, 'MedicinalProductIngredient', TFhirMedicinalProductIngredient(resource));
   {$ENDIF}
{$ENDIF FHIR_MEDICINALPRODUCTINGREDIENT}
{$IFDEF FHIR_MEDICINALPRODUCTINTERACTION}
  {$IFDEF FHIR_MEDICINALPRODUCTINTERACTION}
     frtMedicinalProductInteraction: ComposeMedicinalProductInteraction(json, 'MedicinalProductInteraction', TFhirMedicinalProductInteraction(resource));
   {$ENDIF}
{$ENDIF FHIR_MEDICINALPRODUCTINTERACTION}
{$IFDEF FHIR_MEDICINALPRODUCTMANUFACTURED}
  {$IFDEF FHIR_MEDICINALPRODUCTMANUFACTURED}
     frtMedicinalProductManufactured: ComposeMedicinalProductManufactured(json, 'MedicinalProductManufactured', TFhirMedicinalProductManufactured(resource));
   {$ENDIF}
{$ENDIF FHIR_MEDICINALPRODUCTMANUFACTURED}
{$IFDEF FHIR_MEDICINALPRODUCTPACKAGED}
  {$IFDEF FHIR_MEDICINALPRODUCTPACKAGED}
     frtMedicinalProductPackaged: ComposeMedicinalProductPackaged(json, 'MedicinalProductPackaged', TFhirMedicinalProductPackaged(resource));
   {$ENDIF}
{$ENDIF FHIR_MEDICINALPRODUCTPACKAGED}
{$IFDEF FHIR_MEDICINALPRODUCTPHARMACEUTICAL}
  {$IFDEF FHIR_MEDICINALPRODUCTPHARMACEUTICAL}
     frtMedicinalProductPharmaceutical: ComposeMedicinalProductPharmaceutical(json, 'MedicinalProductPharmaceutical', TFhirMedicinalProductPharmaceutical(resource));
   {$ENDIF}
{$ENDIF FHIR_MEDICINALPRODUCTPHARMACEUTICAL}
{$IFDEF FHIR_MEDICINALPRODUCTUNDESIRABLEEFFECT}
  {$IFDEF FHIR_MEDICINALPRODUCTUNDESIRABLEEFFECT}
     frtMedicinalProductUndesirableEffect: ComposeMedicinalProductUndesirableEffect(json, 'MedicinalProductUndesirableEffect', TFhirMedicinalProductUndesirableEffect(resource));
   {$ENDIF}
{$ENDIF FHIR_MEDICINALPRODUCTUNDESIRABLEEFFECT}
{$IFDEF FHIR_MESSAGEDEFINITION}
  {$IFDEF FHIR_MESSAGEDEFINITION}
     frtMessageDefinition: ComposeMessageDefinition(json, 'MessageDefinition', TFhirMessageDefinition(resource));
   {$ENDIF}
{$ENDIF FHIR_MESSAGEDEFINITION}
{$IFDEF FHIR_MESSAGEHEADER}
  {$IFDEF FHIR_MESSAGEHEADER}
     frtMessageHeader: ComposeMessageHeader(json, 'MessageHeader', TFhirMessageHeader(resource));
   {$ENDIF}
{$ENDIF FHIR_MESSAGEHEADER}
{$IFDEF FHIR_MOLECULARSEQUENCE}
  {$IFDEF FHIR_MOLECULARSEQUENCE}
     frtMolecularSequence: ComposeMolecularSequence(json, 'MolecularSequence', TFhirMolecularSequence(resource));
   {$ENDIF}
{$ENDIF FHIR_MOLECULARSEQUENCE}
{$IFDEF FHIR_NAMINGSYSTEM}
  {$IFDEF FHIR_NAMINGSYSTEM}
     frtNamingSystem: ComposeNamingSystem(json, 'NamingSystem', TFhirNamingSystem(resource));
   {$ENDIF}
{$ENDIF FHIR_NAMINGSYSTEM}
{$IFDEF FHIR_NUTRITIONORDER}
  {$IFDEF FHIR_NUTRITIONORDER}
     frtNutritionOrder: ComposeNutritionOrder(json, 'NutritionOrder', TFhirNutritionOrder(resource));
   {$ENDIF}
{$ENDIF FHIR_NUTRITIONORDER}
{$IFDEF FHIR_OBSERVATION}
  {$IFDEF FHIR_OBSERVATION}
     frtObservation: ComposeObservation(json, 'Observation', TFhirObservation(resource));
   {$ENDIF}
{$ENDIF FHIR_OBSERVATION}
{$IFDEF FHIR_OBSERVATIONDEFINITION}
  {$IFDEF FHIR_OBSERVATIONDEFINITION}
     frtObservationDefinition: ComposeObservationDefinition(json, 'ObservationDefinition', TFhirObservationDefinition(resource));
   {$ENDIF}
{$ENDIF FHIR_OBSERVATIONDEFINITION}
{$IFDEF FHIR_OPERATIONDEFINITION}
  {$IFDEF FHIR_OPERATIONDEFINITION}
     frtOperationDefinition: ComposeOperationDefinition(json, 'OperationDefinition', TFhirOperationDefinition(resource));
   {$ENDIF}
{$ENDIF FHIR_OPERATIONDEFINITION}
{$IFDEF FHIR_OPERATIONOUTCOME}
  {$IFDEF FHIR_OPERATIONOUTCOME}
     frtOperationOutcome: ComposeOperationOutcome(json, 'OperationOutcome', TFhirOperationOutcome(resource));
   {$ENDIF}
{$ENDIF FHIR_OPERATIONOUTCOME}
{$IFDEF FHIR_ORGANIZATION}
  {$IFDEF FHIR_ORGANIZATION}
     frtOrganization: ComposeOrganization(json, 'Organization', TFhirOrganization(resource));
   {$ENDIF}
{$ENDIF FHIR_ORGANIZATION}
{$IFDEF FHIR_ORGANIZATIONAFFILIATION}
  {$IFDEF FHIR_ORGANIZATIONAFFILIATION}
     frtOrganizationAffiliation: ComposeOrganizationAffiliation(json, 'OrganizationAffiliation', TFhirOrganizationAffiliation(resource));
   {$ENDIF}
{$ENDIF FHIR_ORGANIZATIONAFFILIATION}
{$IFDEF FHIR_PATIENT}
  {$IFDEF FHIR_PATIENT}
     frtPatient: ComposePatient(json, 'Patient', TFhirPatient(resource));
   {$ENDIF}
{$ENDIF FHIR_PATIENT}
{$IFDEF FHIR_PAYMENTNOTICE}
  {$IFDEF FHIR_PAYMENTNOTICE}
     frtPaymentNotice: ComposePaymentNotice(json, 'PaymentNotice', TFhirPaymentNotice(resource));
   {$ENDIF}
{$ENDIF FHIR_PAYMENTNOTICE}
{$IFDEF FHIR_PAYMENTRECONCILIATION}
  {$IFDEF FHIR_PAYMENTRECONCILIATION}
     frtPaymentReconciliation: ComposePaymentReconciliation(json, 'PaymentReconciliation', TFhirPaymentReconciliation(resource));
   {$ENDIF}
{$ENDIF FHIR_PAYMENTRECONCILIATION}
{$IFDEF FHIR_PERSON}
  {$IFDEF FHIR_PERSON}
     frtPerson: ComposePerson(json, 'Person', TFhirPerson(resource));
   {$ENDIF}
{$ENDIF FHIR_PERSON}
{$IFDEF FHIR_PLANDEFINITION}
  {$IFDEF FHIR_PLANDEFINITION}
     frtPlanDefinition: ComposePlanDefinition(json, 'PlanDefinition', TFhirPlanDefinition(resource));
   {$ENDIF}
{$ENDIF FHIR_PLANDEFINITION}
{$IFDEF FHIR_PRACTITIONER}
  {$IFDEF FHIR_PRACTITIONER}
     frtPractitioner: ComposePractitioner(json, 'Practitioner', TFhirPractitioner(resource));
   {$ENDIF}
{$ENDIF FHIR_PRACTITIONER}
{$IFDEF FHIR_PRACTITIONERROLE}
  {$IFDEF FHIR_PRACTITIONERROLE}
     frtPractitionerRole: ComposePractitionerRole(json, 'PractitionerRole', TFhirPractitionerRole(resource));
   {$ENDIF}
{$ENDIF FHIR_PRACTITIONERROLE}
{$IFDEF FHIR_PROCEDURE}
  {$IFDEF FHIR_PROCEDURE}
     frtProcedure: ComposeProcedure(json, 'Procedure', TFhirProcedure(resource));
   {$ENDIF}
{$ENDIF FHIR_PROCEDURE}
{$IFDEF FHIR_PROVENANCE}
  {$IFDEF FHIR_PROVENANCE}
     frtProvenance: ComposeProvenance(json, 'Provenance', TFhirProvenance(resource));
   {$ENDIF}
{$ENDIF FHIR_PROVENANCE}
{$IFDEF FHIR_QUESTIONNAIRE}
  {$IFDEF FHIR_QUESTIONNAIRE}
     frtQuestionnaire: ComposeQuestionnaire(json, 'Questionnaire', TFhirQuestionnaire(resource));
   {$ENDIF}
{$ENDIF FHIR_QUESTIONNAIRE}
{$IFDEF FHIR_QUESTIONNAIRERESPONSE}
  {$IFDEF FHIR_QUESTIONNAIRERESPONSE}
     frtQuestionnaireResponse: ComposeQuestionnaireResponse(json, 'QuestionnaireResponse', TFhirQuestionnaireResponse(resource));
   {$ENDIF}
{$ENDIF FHIR_QUESTIONNAIRERESPONSE}
{$IFDEF FHIR_RELATEDPERSON}
  {$IFDEF FHIR_RELATEDPERSON}
     frtRelatedPerson: ComposeRelatedPerson(json, 'RelatedPerson', TFhirRelatedPerson(resource));
   {$ENDIF}
{$ENDIF FHIR_RELATEDPERSON}
{$IFDEF FHIR_REQUESTGROUP}
  {$IFDEF FHIR_REQUESTGROUP}
     frtRequestGroup: ComposeRequestGroup(json, 'RequestGroup', TFhirRequestGroup(resource));
   {$ENDIF}
{$ENDIF FHIR_REQUESTGROUP}
{$IFDEF FHIR_RESEARCHDEFINITION}
  {$IFDEF FHIR_RESEARCHDEFINITION}
     frtResearchDefinition: ComposeResearchDefinition(json, 'ResearchDefinition', TFhirResearchDefinition(resource));
   {$ENDIF}
{$ENDIF FHIR_RESEARCHDEFINITION}
{$IFDEF FHIR_RESEARCHELEMENTDEFINITION}
  {$IFDEF FHIR_RESEARCHELEMENTDEFINITION}
     frtResearchElementDefinition: ComposeResearchElementDefinition(json, 'ResearchElementDefinition', TFhirResearchElementDefinition(resource));
   {$ENDIF}
{$ENDIF FHIR_RESEARCHELEMENTDEFINITION}
{$IFDEF FHIR_RESEARCHSTUDY}
  {$IFDEF FHIR_RESEARCHSTUDY}
     frtResearchStudy: ComposeResearchStudy(json, 'ResearchStudy', TFhirResearchStudy(resource));
   {$ENDIF}
{$ENDIF FHIR_RESEARCHSTUDY}
{$IFDEF FHIR_RESEARCHSUBJECT}
  {$IFDEF FHIR_RESEARCHSUBJECT}
     frtResearchSubject: ComposeResearchSubject(json, 'ResearchSubject', TFhirResearchSubject(resource));
   {$ENDIF}
{$ENDIF FHIR_RESEARCHSUBJECT}
{$IFDEF FHIR_RISKASSESSMENT}
  {$IFDEF FHIR_RISKASSESSMENT}
     frtRiskAssessment: ComposeRiskAssessment(json, 'RiskAssessment', TFhirRiskAssessment(resource));
   {$ENDIF}
{$ENDIF FHIR_RISKASSESSMENT}
{$IFDEF FHIR_RISKEVIDENCESYNTHESIS}
  {$IFDEF FHIR_RISKEVIDENCESYNTHESIS}
     frtRiskEvidenceSynthesis: ComposeRiskEvidenceSynthesis(json, 'RiskEvidenceSynthesis', TFhirRiskEvidenceSynthesis(resource));
   {$ENDIF}
{$ENDIF FHIR_RISKEVIDENCESYNTHESIS}
{$IFDEF FHIR_SCHEDULE}
  {$IFDEF FHIR_SCHEDULE}
     frtSchedule: ComposeSchedule(json, 'Schedule', TFhirSchedule(resource));
   {$ENDIF}
{$ENDIF FHIR_SCHEDULE}
{$IFDEF FHIR_SEARCHPARAMETER}
  {$IFDEF FHIR_SEARCHPARAMETER}
     frtSearchParameter: ComposeSearchParameter(json, 'SearchParameter', TFhirSearchParameter(resource));
   {$ENDIF}
{$ENDIF FHIR_SEARCHPARAMETER}
{$IFDEF FHIR_SERVICEREQUEST}
  {$IFDEF FHIR_SERVICEREQUEST}
     frtServiceRequest: ComposeServiceRequest(json, 'ServiceRequest', TFhirServiceRequest(resource));
   {$ENDIF}
{$ENDIF FHIR_SERVICEREQUEST}
{$IFDEF FHIR_SLOT}
  {$IFDEF FHIR_SLOT}
     frtSlot: ComposeSlot(json, 'Slot', TFhirSlot(resource));
   {$ENDIF}
{$ENDIF FHIR_SLOT}
{$IFDEF FHIR_SPECIMEN}
  {$IFDEF FHIR_SPECIMEN}
     frtSpecimen: ComposeSpecimen(json, 'Specimen', TFhirSpecimen(resource));
   {$ENDIF}
{$ENDIF FHIR_SPECIMEN}
{$IFDEF FHIR_SPECIMENDEFINITION}
  {$IFDEF FHIR_SPECIMENDEFINITION}
     frtSpecimenDefinition: ComposeSpecimenDefinition(json, 'SpecimenDefinition', TFhirSpecimenDefinition(resource));
   {$ENDIF}
{$ENDIF FHIR_SPECIMENDEFINITION}
{$IFDEF FHIR_STRUCTUREDEFINITION}
  {$IFDEF FHIR_STRUCTUREDEFINITION}
     frtStructureDefinition: ComposeStructureDefinition(json, 'StructureDefinition', TFhirStructureDefinition(resource));
   {$ENDIF}
{$ENDIF FHIR_STRUCTUREDEFINITION}
{$IFDEF FHIR_STRUCTUREMAP}
  {$IFDEF FHIR_STRUCTUREMAP}
     frtStructureMap: ComposeStructureMap(json, 'StructureMap', TFhirStructureMap(resource));
   {$ENDIF}
{$ENDIF FHIR_STRUCTUREMAP}
{$IFDEF FHIR_SUBSCRIPTION}
  {$IFDEF FHIR_SUBSCRIPTION}
     frtSubscription: ComposeSubscription(json, 'Subscription', TFhirSubscription(resource));
   {$ENDIF}
{$ENDIF FHIR_SUBSCRIPTION}
{$IFDEF FHIR_SUBSTANCE}
  {$IFDEF FHIR_SUBSTANCE}
     frtSubstance: ComposeSubstance(json, 'Substance', TFhirSubstance(resource));
   {$ENDIF}
{$ENDIF FHIR_SUBSTANCE}
{$IFDEF FHIR_SUBSTANCENUCLEICACID}
  {$IFDEF FHIR_SUBSTANCENUCLEICACID}
     frtSubstanceNucleicAcid: ComposeSubstanceNucleicAcid(json, 'SubstanceNucleicAcid', TFhirSubstanceNucleicAcid(resource));
   {$ENDIF}
{$ENDIF FHIR_SUBSTANCENUCLEICACID}
{$IFDEF FHIR_SUBSTANCEPOLYMER}
  {$IFDEF FHIR_SUBSTANCEPOLYMER}
     frtSubstancePolymer: ComposeSubstancePolymer(json, 'SubstancePolymer', TFhirSubstancePolymer(resource));
   {$ENDIF}
{$ENDIF FHIR_SUBSTANCEPOLYMER}
{$IFDEF FHIR_SUBSTANCEPROTEIN}
  {$IFDEF FHIR_SUBSTANCEPROTEIN}
     frtSubstanceProtein: ComposeSubstanceProtein(json, 'SubstanceProtein', TFhirSubstanceProtein(resource));
   {$ENDIF}
{$ENDIF FHIR_SUBSTANCEPROTEIN}
{$IFDEF FHIR_SUBSTANCEREFERENCEINFORMATION}
  {$IFDEF FHIR_SUBSTANCEREFERENCEINFORMATION}
     frtSubstanceReferenceInformation: ComposeSubstanceReferenceInformation(json, 'SubstanceReferenceInformation', TFhirSubstanceReferenceInformation(resource));
   {$ENDIF}
{$ENDIF FHIR_SUBSTANCEREFERENCEINFORMATION}
{$IFDEF FHIR_SUBSTANCESOURCEMATERIAL}
  {$IFDEF FHIR_SUBSTANCESOURCEMATERIAL}
     frtSubstanceSourceMaterial: ComposeSubstanceSourceMaterial(json, 'SubstanceSourceMaterial', TFhirSubstanceSourceMaterial(resource));
   {$ENDIF}
{$ENDIF FHIR_SUBSTANCESOURCEMATERIAL}
{$IFDEF FHIR_SUBSTANCESPECIFICATION}
  {$IFDEF FHIR_SUBSTANCESPECIFICATION}
     frtSubstanceSpecification: ComposeSubstanceSpecification(json, 'SubstanceSpecification', TFhirSubstanceSpecification(resource));
   {$ENDIF}
{$ENDIF FHIR_SUBSTANCESPECIFICATION}
{$IFDEF FHIR_SUPPLYDELIVERY}
  {$IFDEF FHIR_SUPPLYDELIVERY}
     frtSupplyDelivery: ComposeSupplyDelivery(json, 'SupplyDelivery', TFhirSupplyDelivery(resource));
   {$ENDIF}
{$ENDIF FHIR_SUPPLYDELIVERY}
{$IFDEF FHIR_SUPPLYREQUEST}
  {$IFDEF FHIR_SUPPLYREQUEST}
     frtSupplyRequest: ComposeSupplyRequest(json, 'SupplyRequest', TFhirSupplyRequest(resource));
   {$ENDIF}
{$ENDIF FHIR_SUPPLYREQUEST}
{$IFDEF FHIR_TASK}
  {$IFDEF FHIR_TASK}
     frtTask: ComposeTask(json, 'Task', TFhirTask(resource));
   {$ENDIF}
{$ENDIF FHIR_TASK}
{$IFDEF FHIR_TERMINOLOGYCAPABILITIES}
  {$IFDEF FHIR_TERMINOLOGYCAPABILITIES}
     frtTerminologyCapabilities: ComposeTerminologyCapabilities(json, 'TerminologyCapabilities', TFhirTerminologyCapabilities(resource));
   {$ENDIF}
{$ENDIF FHIR_TERMINOLOGYCAPABILITIES}
{$IFDEF FHIR_TESTREPORT}
  {$IFDEF FHIR_TESTREPORT}
     frtTestReport: ComposeTestReport(json, 'TestReport', TFhirTestReport(resource));
   {$ENDIF}
{$ENDIF FHIR_TESTREPORT}
{$IFDEF FHIR_TESTSCRIPT}
  {$IFDEF FHIR_TESTSCRIPT}
     frtTestScript: ComposeTestScript(json, 'TestScript', TFhirTestScript(resource));
   {$ENDIF}
{$ENDIF FHIR_TESTSCRIPT}
{$IFDEF FHIR_VALUESET}
  {$IFDEF FHIR_VALUESET}
     frtValueSet: ComposeValueSet(json, 'ValueSet', TFhirValueSet(resource));
   {$ENDIF}
{$ENDIF FHIR_VALUESET}
{$IFDEF FHIR_VERIFICATIONRESULT}
  {$IFDEF FHIR_VERIFICATIONRESULT}
     frtVerificationResult: ComposeVerificationResult(json, 'VerificationResult', TFhirVerificationResult(resource));
   {$ENDIF}
{$ENDIF FHIR_VERIFICATIONRESULT}
{$IFDEF FHIR_VISIONPRESCRIPTION}
  {$IFDEF FHIR_VISIONPRESCRIPTION}
     frtVisionPrescription: ComposeVisionPrescription(json, 'VisionPrescription', TFhirVisionPrescription(resource));
   {$ENDIF}
{$ENDIF FHIR_VISIONPRESCRIPTION}
  else
    raise EJsonException.create('Internal error: the resource type '+CODES_TFhirResourceType[resource.ResourceType]+' is not a valid resource type');
  end;
end;


end.

