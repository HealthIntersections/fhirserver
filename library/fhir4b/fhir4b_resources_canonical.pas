unit fhir4b_resources_canonical;

{
  Copyright (c) 2011+, HL7 and Health Intersections Pty Ltd (http://www.healthintersections.com.au)
  All rights reserved.
  
  Redistribution and use in source and binary forms, with or without modification, 
  are permitted provided that the following conditions are met:
  
   * Redistributions of source code must retain the above copyright notice, this 
     list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above copyright notice, 
     this list of conditions and the following disclaimer in the documentation 
     and/or other materials provided with the distribution.
   * Neither the name of HL7 nor the names of its contributors may be used to 
     endorse or promote products derived from this software without specific 
     prior written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
  POSSIBILITY OF SUCH DAMAGE.
  
}

{$I fhir.inc}
{$I fhir4b.inc}

interface

// Generated on Mon, Dec 27, 2021 21:46+1100 for FHIR v4.3.0



uses
  SysUtils, Classes, 
  fsl_base, fsl_utilities, fsl_stream, 
  fhir_objects, fhir_utilities,  
  fhir4b_base, fhir4b_enums, fhir4b_types, fhir4b_resources_base;



type
{$IFDEF FHIR_CAPABILITYSTATEMENT}
  TFhirCapabilityStatementSoftware = class;
  TFhirCapabilityStatementSoftwareList = class;
  TFhirCapabilityStatementImplementation = class;
  TFhirCapabilityStatementImplementationList = class;
  TFhirCapabilityStatementRest = class;
  TFhirCapabilityStatementRestList = class;
  TFhirCapabilityStatementRestSecurity = class;
  TFhirCapabilityStatementRestSecurityList = class;
  TFhirCapabilityStatementRestResource = class;
  TFhirCapabilityStatementRestResourceList = class;
  TFhirCapabilityStatementRestResourceInteraction = class;
  TFhirCapabilityStatementRestResourceInteractionList = class;
  TFhirCapabilityStatementRestResourceSearchParam = class;
  TFhirCapabilityStatementRestResourceSearchParamList = class;
  TFhirCapabilityStatementRestResourceOperation = class;
  TFhirCapabilityStatementRestResourceOperationList = class;
  TFhirCapabilityStatementRestInteraction = class;
  TFhirCapabilityStatementRestInteractionList = class;
  TFhirCapabilityStatementMessaging = class;
  TFhirCapabilityStatementMessagingList = class;
  TFhirCapabilityStatementMessagingEndpoint = class;
  TFhirCapabilityStatementMessagingEndpointList = class;
  TFhirCapabilityStatementMessagingSupportedMessage = class;
  TFhirCapabilityStatementMessagingSupportedMessageList = class;
  TFhirCapabilityStatementDocument = class;
  TFhirCapabilityStatementDocumentList = class;
  TFhirCapabilityStatement = class;
  TFhirCapabilityStatementList = class;
{$ENDIF FHIR_CAPABILITYSTATEMENT}
{$IFDEF FHIR_CODESYSTEM}
  TFhirCodeSystemFilter = class;
  TFhirCodeSystemFilterList = class;
  TFhirCodeSystemProperty = class;
  TFhirCodeSystemPropertyList = class;
  TFhirCodeSystemConcept = class;
  TFhirCodeSystemConceptList = class;
  TFhirCodeSystemConceptDesignation = class;
  TFhirCodeSystemConceptDesignationList = class;
  TFhirCodeSystemConceptProperty = class;
  TFhirCodeSystemConceptPropertyList = class;
  TFhirCodeSystem = class;
  TFhirCodeSystemList = class;
{$ENDIF FHIR_CODESYSTEM}
{$IFDEF FHIR_COMPARTMENTDEFINITION}
  TFhirCompartmentDefinitionResource = class;
  TFhirCompartmentDefinitionResourceList = class;
  TFhirCompartmentDefinition = class;
  TFhirCompartmentDefinitionList = class;
{$ENDIF FHIR_COMPARTMENTDEFINITION}
{$IFDEF FHIR_CONCEPTMAP}
  TFhirConceptMapGroup = class;
  TFhirConceptMapGroupList = class;
  TFhirConceptMapGroupElement = class;
  TFhirConceptMapGroupElementList = class;
  TFhirConceptMapGroupElementTarget = class;
  TFhirConceptMapGroupElementTargetList = class;
  TFhirConceptMapGroupElementTargetDependsOn = class;
  TFhirConceptMapGroupElementTargetDependsOnList = class;
  TFhirConceptMapGroupUnmapped = class;
  TFhirConceptMapGroupUnmappedList = class;
  TFhirConceptMap = class;
  TFhirConceptMapList = class;
{$ENDIF FHIR_CONCEPTMAP}
{$IFDEF FHIR_EVENTDEFINITION}
  TFhirEventDefinition = class;
  TFhirEventDefinitionList = class;
{$ENDIF FHIR_EVENTDEFINITION}
{$IFDEF FHIR_EXAMPLESCENARIO}
  TFhirExampleScenarioActor = class;
  TFhirExampleScenarioActorList = class;
  TFhirExampleScenarioInstance = class;
  TFhirExampleScenarioInstanceList = class;
  TFhirExampleScenarioInstanceVersion = class;
  TFhirExampleScenarioInstanceVersionList = class;
  TFhirExampleScenarioInstanceContainedInstance = class;
  TFhirExampleScenarioInstanceContainedInstanceList = class;
  TFhirExampleScenarioProcess = class;
  TFhirExampleScenarioProcessList = class;
  TFhirExampleScenarioProcessStep = class;
  TFhirExampleScenarioProcessStepList = class;
  TFhirExampleScenarioProcessStepOperation = class;
  TFhirExampleScenarioProcessStepOperationList = class;
  TFhirExampleScenarioProcessStepAlternative = class;
  TFhirExampleScenarioProcessStepAlternativeList = class;
  TFhirExampleScenario = class;
  TFhirExampleScenarioList = class;
{$ENDIF FHIR_EXAMPLESCENARIO}
{$IFDEF FHIR_GRAPHDEFINITION}
  TFhirGraphDefinitionLink = class;
  TFhirGraphDefinitionLinkList = class;
  TFhirGraphDefinitionLinkTarget = class;
  TFhirGraphDefinitionLinkTargetList = class;
  TFhirGraphDefinitionLinkTargetCompartment = class;
  TFhirGraphDefinitionLinkTargetCompartmentList = class;
  TFhirGraphDefinition = class;
  TFhirGraphDefinitionList = class;
{$ENDIF FHIR_GRAPHDEFINITION}
{$IFDEF FHIR_IMPLEMENTATIONGUIDE}
  TFhirImplementationGuideDependsOn = class;
  TFhirImplementationGuideDependsOnList = class;
  TFhirImplementationGuideGlobal = class;
  TFhirImplementationGuideGlobalList = class;
  TFhirImplementationGuideDefinition = class;
  TFhirImplementationGuideDefinitionList = class;
  TFhirImplementationGuideDefinitionGrouping = class;
  TFhirImplementationGuideDefinitionGroupingList = class;
  TFhirImplementationGuideDefinitionResource = class;
  TFhirImplementationGuideDefinitionResourceList = class;
  TFhirImplementationGuideDefinitionPage = class;
  TFhirImplementationGuideDefinitionPageList = class;
  TFhirImplementationGuideDefinitionParameter = class;
  TFhirImplementationGuideDefinitionParameterList = class;
  TFhirImplementationGuideDefinitionTemplate = class;
  TFhirImplementationGuideDefinitionTemplateList = class;
  TFhirImplementationGuideManifest = class;
  TFhirImplementationGuideManifestList = class;
  TFhirImplementationGuideManifestResource = class;
  TFhirImplementationGuideManifestResourceList = class;
  TFhirImplementationGuideManifestPage = class;
  TFhirImplementationGuideManifestPageList = class;
  TFhirImplementationGuide = class;
  TFhirImplementationGuideList = class;
{$ENDIF FHIR_IMPLEMENTATIONGUIDE}
{$IFDEF FHIR_LIBRARY}
  TFhirLibrary = class;
  TFhirLibraryList = class;
{$ENDIF FHIR_LIBRARY}
{$IFDEF FHIR_MEASURE}
  TFhirMeasureGroup = class;
  TFhirMeasureGroupList = class;
  TFhirMeasureGroupPopulation = class;
  TFhirMeasureGroupPopulationList = class;
  TFhirMeasureGroupStratifier = class;
  TFhirMeasureGroupStratifierList = class;
  TFhirMeasureGroupStratifierComponent = class;
  TFhirMeasureGroupStratifierComponentList = class;
  TFhirMeasureSupplementalData = class;
  TFhirMeasureSupplementalDataList = class;
  TFhirMeasure = class;
  TFhirMeasureList = class;
{$ENDIF FHIR_MEASURE}
{$IFDEF FHIR_MESSAGEDEFINITION}
  TFhirMessageDefinitionFocus = class;
  TFhirMessageDefinitionFocusList = class;
  TFhirMessageDefinitionAllowedResponse = class;
  TFhirMessageDefinitionAllowedResponseList = class;
  TFhirMessageDefinition = class;
  TFhirMessageDefinitionList = class;
{$ENDIF FHIR_MESSAGEDEFINITION}
{$IFDEF FHIR_NAMINGSYSTEM}
  TFhirNamingSystemUniqueId = class;
  TFhirNamingSystemUniqueIdList = class;
  TFhirNamingSystem = class;
  TFhirNamingSystemList = class;
{$ENDIF FHIR_NAMINGSYSTEM}
{$IFDEF FHIR_OBSERVATIONDEFINITION}
  TFhirObservationDefinitionQuantitativeDetails = class;
  TFhirObservationDefinitionQuantitativeDetailsList = class;
  TFhirObservationDefinitionQualifiedInterval = class;
  TFhirObservationDefinitionQualifiedIntervalList = class;
  TFhirObservationDefinition = class;
  TFhirObservationDefinitionList = class;
{$ENDIF FHIR_OBSERVATIONDEFINITION}
{$IFDEF FHIR_OPERATIONDEFINITION}
  TFhirOperationDefinitionParameter = class;
  TFhirOperationDefinitionParameterList = class;
  TFhirOperationDefinitionParameterBinding = class;
  TFhirOperationDefinitionParameterBindingList = class;
  TFhirOperationDefinitionParameterReferencedFrom = class;
  TFhirOperationDefinitionParameterReferencedFromList = class;
  TFhirOperationDefinitionOverload = class;
  TFhirOperationDefinitionOverloadList = class;
  TFhirOperationDefinition = class;
  TFhirOperationDefinitionList = class;
{$ENDIF FHIR_OPERATIONDEFINITION}
{$IFDEF FHIR_QUESTIONNAIRE}
  TFhirQuestionnaireItem = class;
  TFhirQuestionnaireItemList = class;
  TFhirQuestionnaireItemEnableWhen = class;
  TFhirQuestionnaireItemEnableWhenList = class;
  TFhirQuestionnaireItemAnswerOption = class;
  TFhirQuestionnaireItemAnswerOptionList = class;
  TFhirQuestionnaireItemInitial = class;
  TFhirQuestionnaireItemInitialList = class;
  TFhirQuestionnaire = class;
  TFhirQuestionnaireList = class;
{$ENDIF FHIR_QUESTIONNAIRE}
{$IFDEF FHIR_SEARCHPARAMETER}
  TFhirSearchParameterComponent = class;
  TFhirSearchParameterComponentList = class;
  TFhirSearchParameter = class;
  TFhirSearchParameterList = class;
{$ENDIF FHIR_SEARCHPARAMETER}
{$IFDEF FHIR_SPECIMENDEFINITION}
  TFhirSpecimenDefinitionTypeTested = class;
  TFhirSpecimenDefinitionTypeTestedList = class;
  TFhirSpecimenDefinitionTypeTestedContainer = class;
  TFhirSpecimenDefinitionTypeTestedContainerList = class;
  TFhirSpecimenDefinitionTypeTestedContainerAdditive = class;
  TFhirSpecimenDefinitionTypeTestedContainerAdditiveList = class;
  TFhirSpecimenDefinitionTypeTestedHandling = class;
  TFhirSpecimenDefinitionTypeTestedHandlingList = class;
  TFhirSpecimenDefinition = class;
  TFhirSpecimenDefinitionList = class;
{$ENDIF FHIR_SPECIMENDEFINITION}
{$IFDEF FHIR_STRUCTUREDEFINITION}
  TFhirStructureDefinitionMapping = class;
  TFhirStructureDefinitionMappingList = class;
  TFhirStructureDefinitionContext = class;
  TFhirStructureDefinitionContextList = class;
  TFhirStructureDefinitionSnapshot = class;
  TFhirStructureDefinitionSnapshotList = class;
  TFhirStructureDefinitionDifferential = class;
  TFhirStructureDefinitionDifferentialList = class;
  TFhirStructureDefinition = class;
  TFhirStructureDefinitionList = class;
{$ENDIF FHIR_STRUCTUREDEFINITION}
{$IFDEF FHIR_STRUCTUREMAP}
  TFhirStructureMapStructure = class;
  TFhirStructureMapStructureList = class;
  TFhirStructureMapGroup = class;
  TFhirStructureMapGroupList = class;
  TFhirStructureMapGroupInput = class;
  TFhirStructureMapGroupInputList = class;
  TFhirStructureMapGroupRule = class;
  TFhirStructureMapGroupRuleList = class;
  TFhirStructureMapGroupRuleSource = class;
  TFhirStructureMapGroupRuleSourceList = class;
  TFhirStructureMapGroupRuleTarget = class;
  TFhirStructureMapGroupRuleTargetList = class;
  TFhirStructureMapGroupRuleTargetParameter = class;
  TFhirStructureMapGroupRuleTargetParameterList = class;
  TFhirStructureMapGroupRuleDependent = class;
  TFhirStructureMapGroupRuleDependentList = class;
  TFhirStructureMap = class;
  TFhirStructureMapList = class;
{$ENDIF FHIR_STRUCTUREMAP}
{$IFDEF FHIR_TERMINOLOGYCAPABILITIES}
  TFhirTerminologyCapabilitiesSoftware = class;
  TFhirTerminologyCapabilitiesSoftwareList = class;
  TFhirTerminologyCapabilitiesImplementation = class;
  TFhirTerminologyCapabilitiesImplementationList = class;
  TFhirTerminologyCapabilitiesCodeSystem = class;
  TFhirTerminologyCapabilitiesCodeSystemList = class;
  TFhirTerminologyCapabilitiesCodeSystemVersion = class;
  TFhirTerminologyCapabilitiesCodeSystemVersionList = class;
  TFhirTerminologyCapabilitiesCodeSystemVersionFilter = class;
  TFhirTerminologyCapabilitiesCodeSystemVersionFilterList = class;
  TFhirTerminologyCapabilitiesExpansion = class;
  TFhirTerminologyCapabilitiesExpansionList = class;
  TFhirTerminologyCapabilitiesExpansionParameter = class;
  TFhirTerminologyCapabilitiesExpansionParameterList = class;
  TFhirTerminologyCapabilitiesValidateCode = class;
  TFhirTerminologyCapabilitiesValidateCodeList = class;
  TFhirTerminologyCapabilitiesTranslation = class;
  TFhirTerminologyCapabilitiesTranslationList = class;
  TFhirTerminologyCapabilitiesClosure = class;
  TFhirTerminologyCapabilitiesClosureList = class;
  TFhirTerminologyCapabilities = class;
  TFhirTerminologyCapabilitiesList = class;
{$ENDIF FHIR_TERMINOLOGYCAPABILITIES}
{$IFDEF FHIR_TESTSCRIPT}
  TFhirTestScriptOrigin = class;
  TFhirTestScriptOriginList = class;
  TFhirTestScriptDestination = class;
  TFhirTestScriptDestinationList = class;
  TFhirTestScriptMetadata = class;
  TFhirTestScriptMetadataList = class;
  TFhirTestScriptMetadataLink = class;
  TFhirTestScriptMetadataLinkList = class;
  TFhirTestScriptMetadataCapability = class;
  TFhirTestScriptMetadataCapabilityList = class;
  TFhirTestScriptFixture = class;
  TFhirTestScriptFixtureList = class;
  TFhirTestScriptVariable = class;
  TFhirTestScriptVariableList = class;
  TFhirTestScriptSetup = class;
  TFhirTestScriptSetupList = class;
  TFhirTestScriptSetupAction = class;
  TFhirTestScriptSetupActionList = class;
  TFhirTestScriptSetupActionOperation = class;
  TFhirTestScriptSetupActionOperationList = class;
  TFhirTestScriptSetupActionOperationRequestHeader = class;
  TFhirTestScriptSetupActionOperationRequestHeaderList = class;
  TFhirTestScriptSetupActionAssert = class;
  TFhirTestScriptSetupActionAssertList = class;
  TFhirTestScriptTest = class;
  TFhirTestScriptTestList = class;
  TFhirTestScriptTestAction = class;
  TFhirTestScriptTestActionList = class;
  TFhirTestScriptTeardown = class;
  TFhirTestScriptTeardownList = class;
  TFhirTestScriptTeardownAction = class;
  TFhirTestScriptTeardownActionList = class;
  TFhirTestScript = class;
  TFhirTestScriptList = class;
{$ENDIF FHIR_TESTSCRIPT}
{$IFDEF FHIR_VALUESET}
  TFhirValueSetCompose = class;
  TFhirValueSetComposeList = class;
  TFhirValueSetComposeInclude = class;
  TFhirValueSetComposeIncludeList = class;
  TFhirValueSetComposeIncludeConcept = class;
  TFhirValueSetComposeIncludeConceptList = class;
  TFhirValueSetComposeIncludeConceptDesignation = class;
  TFhirValueSetComposeIncludeConceptDesignationList = class;
  TFhirValueSetComposeIncludeFilter = class;
  TFhirValueSetComposeIncludeFilterList = class;
  TFhirValueSetExpansion = class;
  TFhirValueSetExpansionList = class;
  TFhirValueSetExpansionParameter = class;
  TFhirValueSetExpansionParameterList = class;
  TFhirValueSetExpansionContains = class;
  TFhirValueSetExpansionContainsList = class;
  TFhirValueSet = class;
  TFhirValueSetList = class;
{$ENDIF FHIR_VALUESET}




{$IFDEF FHIR_CAPABILITYSTATEMENT}
  // Software that is covered by this capability statement.  It is used when the capability statement describes the capabilities of a particular software version, independent of an installation.
  TFhirCapabilityStatementSoftware = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FVersion : TFhirString;
    FReleaseDate : TFhirDateTime;
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetVersion(value : TFhirString);
    function GetVersionST : String;
    procedure SetVersionST(value : String);
    procedure SetReleaseDate(value : TFhirDateTime);
    function GetReleaseDateST : TFslDateTime;
    procedure SetReleaseDateST(value : TFslDateTime);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCapabilityStatementSoftware; overload;
    function Clone : TFhirCapabilityStatementSoftware; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Name the software is known by.
    property name : String read GetNameST write SetNameST;
    // Name the software is known by.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to The version identifier for the software covered by this statement.
    property version : String read GetVersionST write SetVersionST;
    // The version identifier for the software covered by this statement.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to Date this version of the software was released.
    property releaseDate : TFslDateTime read GetReleaseDateST write SetReleaseDateST;
    // Date this version of the software was released.
    property releaseDateElement : TFhirDateTime read FReleaseDate write SetReleaseDate;

  end;

  TFhirCapabilityStatementSoftwareListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCapabilityStatementSoftwareList;
    function GetCurrent : TFhirCapabilityStatementSoftware;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCapabilityStatementSoftwareList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCapabilityStatementSoftware read GetCurrent;
  end;

  TFhirCapabilityStatementSoftwareList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCapabilityStatementSoftware;
    procedure SetItemN(index : Integer; value : TFhirCapabilityStatementSoftware);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCapabilityStatementSoftwareList; overload;
    function Clone : TFhirCapabilityStatementSoftwareList; overload;
    function GetEnumerator : TFhirCapabilityStatementSoftwareListEnumerator;
    
    //  Add a FhirCapabilityStatementSoftware to the end of the list.
    function Append : TFhirCapabilityStatementSoftware;
    
    // Add an already existing FhirCapabilityStatementSoftware to the end of the list.
    function AddItem(value : TFhirCapabilityStatementSoftware) : TFhirCapabilityStatementSoftware; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCapabilityStatementSoftware) : Integer;
    
    // Insert FhirCapabilityStatementSoftware before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCapabilityStatementSoftware;
    
    // Insert an existing FhirCapabilityStatementSoftware before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCapabilityStatementSoftware);
    
    // Get the iIndexth FhirCapabilityStatementSoftware. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCapabilityStatementSoftware);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCapabilityStatementSoftware;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCapabilityStatementSoftwares[index : Integer] : TFhirCapabilityStatementSoftware read GetItemN write SetItemN; default;
  End;

  // Identifies a specific implementation instance that is described by the capability statement - i.e. a particular installation, rather than the capabilities of a software program.
  TFhirCapabilityStatementImplementation = class (TFhirBackboneElement)
  protected
    FDescription : TFhirString;
    FUrl : TFhirUrl;
    FCustodian : TFhirReference;
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetUrl(value : TFhirUrl);
    function GetUrlST : String;
    procedure SetUrlST(value : String);
    procedure SetCustodian(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCapabilityStatementImplementation; overload;
    function Clone : TFhirCapabilityStatementImplementation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Information about the specific installation that this capability statement relates to.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Information about the specific installation that this capability statement relates to.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to An absolute base URL for the implementation.  This forms the base for REST interfaces as well as the mailbox and document interfaces.
    property url : String read GetUrlST write SetUrlST;
    // An absolute base URL for the implementation.  This forms the base for REST interfaces as well as the mailbox and document interfaces.
    property urlElement : TFhirUrl read FUrl write SetUrl;

    // Typed access to The organization responsible for the management of the instance and oversight of the data on the server at the specified URL. (defined for API consistency)
    property custodian : TFhirReference read FCustodian write SetCustodian;
    // The organization responsible for the management of the instance and oversight of the data on the server at the specified URL.
    property custodianElement : TFhirReference read FCustodian write SetCustodian;

  end;

  TFhirCapabilityStatementImplementationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCapabilityStatementImplementationList;
    function GetCurrent : TFhirCapabilityStatementImplementation;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCapabilityStatementImplementationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCapabilityStatementImplementation read GetCurrent;
  end;

  TFhirCapabilityStatementImplementationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCapabilityStatementImplementation;
    procedure SetItemN(index : Integer; value : TFhirCapabilityStatementImplementation);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCapabilityStatementImplementationList; overload;
    function Clone : TFhirCapabilityStatementImplementationList; overload;
    function GetEnumerator : TFhirCapabilityStatementImplementationListEnumerator;
    
    //  Add a FhirCapabilityStatementImplementation to the end of the list.
    function Append : TFhirCapabilityStatementImplementation;
    
    // Add an already existing FhirCapabilityStatementImplementation to the end of the list.
    function AddItem(value : TFhirCapabilityStatementImplementation) : TFhirCapabilityStatementImplementation; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCapabilityStatementImplementation) : Integer;
    
    // Insert FhirCapabilityStatementImplementation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCapabilityStatementImplementation;
    
    // Insert an existing FhirCapabilityStatementImplementation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCapabilityStatementImplementation);
    
    // Get the iIndexth FhirCapabilityStatementImplementation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCapabilityStatementImplementation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCapabilityStatementImplementation;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCapabilityStatementImplementations[index : Integer] : TFhirCapabilityStatementImplementation read GetItemN write SetItemN; default;
  End;

  // A definition of the restful capabilities of the solution, if any.
  TFhirCapabilityStatementRest = class (TFhirBackboneElement)
  protected
    FMode : TFhirEnum;
    FDocumentation : TFhirMarkdown;
    FSecurity : TFhirCapabilityStatementRestSecurity;
    FresourceList : TFhirCapabilityStatementRestResourceList;
    FinteractionList : TFhirCapabilityStatementRestInteractionList;
    FsearchParamList : TFhirCapabilityStatementRestResourceSearchParamList;
    FoperationList : TFhirCapabilityStatementRestResourceOperationList;
    FcompartmentList : TFhirCanonicalList;
    procedure SetMode(value : TFhirEnum);
    function GetModeST : TFhirRestfulCapabilityModeEnum;
    procedure SetModeST(value : TFhirRestfulCapabilityModeEnum);
    procedure SetDocumentation(value : TFhirMarkdown);
    function GetDocumentationST : String;
    procedure SetDocumentationST(value : String);
    procedure SetSecurity(value : TFhirCapabilityStatementRestSecurity);
    function GetResourceList : TFhirCapabilityStatementRestResourceList;
    function GetHasResourceList : Boolean;
    function GetInteractionList : TFhirCapabilityStatementRestInteractionList;
    function GetHasInteractionList : Boolean;
    function GetSearchParamList : TFhirCapabilityStatementRestResourceSearchParamList;
    function GetHasSearchParamList : Boolean;
    function GetOperationList : TFhirCapabilityStatementRestResourceOperationList;
    function GetHasOperationList : Boolean;
    function GetCompartmentList : TFhirCanonicalList;
    function GetHasCompartmentList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCapabilityStatementRest; overload;
    function Clone : TFhirCapabilityStatementRest; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Identifies whether this portion of the statement is describing the ability to initiate or receive restful operations.
    property mode : TFhirRestfulCapabilityModeEnum read GetModeST write SetModeST;
    property modeElement : TFhirEnum read FMode write SetMode;

    // Typed access to Information about the system's restful capabilities that apply across all applications, such as security.
    property documentation : String read GetDocumentationST write SetDocumentationST;
    // Information about the system's restful capabilities that apply across all applications, such as security.
    property documentationElement : TFhirMarkdown read FDocumentation write SetDocumentation;

    // Typed access to Information about security implementation from an interface perspective - what a client needs to know. (defined for API consistency)
    property security : TFhirCapabilityStatementRestSecurity read FSecurity write SetSecurity;
    // Information about security implementation from an interface perspective - what a client needs to know.
    property securityElement : TFhirCapabilityStatementRestSecurity read FSecurity write SetSecurity;

    // A specification of the restful capabilities of the solution for a specific resource type.
    property resourceList : TFhirCapabilityStatementRestResourceList read GetResourceList;
    property hasResourceList : boolean read GetHasResourceList;

    // A specification of restful operations supported by the system.
    property interactionList : TFhirCapabilityStatementRestInteractionList read GetInteractionList;
    property hasInteractionList : boolean read GetHasInteractionList;

    // Search parameters that are supported for searching all resources for implementations to support and/or make use of - either references to ones defined in the specification, or additional ones defined for/by the implementation.
    property searchParamList : TFhirCapabilityStatementRestResourceSearchParamList read GetSearchParamList;
    property hasSearchParamList : boolean read GetHasSearchParamList;

    // Definition of an operation or a named query together with its parameters and their meaning and type.
    property operationList : TFhirCapabilityStatementRestResourceOperationList read GetOperationList;
    property hasOperationList : boolean read GetHasOperationList;

    // An absolute URI which is a reference to the definition of a compartment that the system supports. The reference is to a CompartmentDefinition resource by its canonical URL .
    property compartmentList : TFhirCanonicalList read GetCompartmentList;
    property hasCompartmentList : boolean read GetHasCompartmentList;

  end;

  TFhirCapabilityStatementRestListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCapabilityStatementRestList;
    function GetCurrent : TFhirCapabilityStatementRest;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCapabilityStatementRestList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCapabilityStatementRest read GetCurrent;
  end;

  TFhirCapabilityStatementRestList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCapabilityStatementRest;
    procedure SetItemN(index : Integer; value : TFhirCapabilityStatementRest);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCapabilityStatementRestList; overload;
    function Clone : TFhirCapabilityStatementRestList; overload;
    function GetEnumerator : TFhirCapabilityStatementRestListEnumerator;
    
    //  Add a FhirCapabilityStatementRest to the end of the list.
    function Append : TFhirCapabilityStatementRest;
    
    // Add an already existing FhirCapabilityStatementRest to the end of the list.
    function AddItem(value : TFhirCapabilityStatementRest) : TFhirCapabilityStatementRest; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCapabilityStatementRest) : Integer;
    
    // Insert FhirCapabilityStatementRest before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCapabilityStatementRest;
    
    // Insert an existing FhirCapabilityStatementRest before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCapabilityStatementRest);
    
    // Get the iIndexth FhirCapabilityStatementRest. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCapabilityStatementRest);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCapabilityStatementRest;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCapabilityStatementRests[index : Integer] : TFhirCapabilityStatementRest read GetItemN write SetItemN; default;
  End;

  // Information about security implementation from an interface perspective - what a client needs to know.
  TFhirCapabilityStatementRestSecurity = class (TFhirBackboneElement)
  protected
    FCors : TFhirBoolean;
    FserviceList : TFhirCodeableConceptList;
    FDescription : TFhirMarkdown;
    procedure SetCors(value : TFhirBoolean);
    function GetCorsST : Boolean;
    procedure SetCorsST(value : Boolean);
    function GetServiceList : TFhirCodeableConceptList;
    function GetHasServiceList : Boolean;
    procedure SetDescription(value : TFhirMarkdown);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCapabilityStatementRestSecurity; overload;
    function Clone : TFhirCapabilityStatementRestSecurity; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Server adds CORS headers when responding to requests - this enables Javascript applications to use the server.
    property cors : Boolean read GetCorsST write SetCorsST;
    // Server adds CORS headers when responding to requests - this enables Javascript applications to use the server.
    property corsElement : TFhirBoolean read FCors write SetCors;

    // Types of security services that are supported/required by the system.
    property serviceList : TFhirCodeableConceptList read GetServiceList;
    property hasServiceList : boolean read GetHasServiceList;

    // Typed access to General description of how security works.
    property description : String read GetDescriptionST write SetDescriptionST;
    // General description of how security works.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

  end;

  TFhirCapabilityStatementRestSecurityListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCapabilityStatementRestSecurityList;
    function GetCurrent : TFhirCapabilityStatementRestSecurity;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCapabilityStatementRestSecurityList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCapabilityStatementRestSecurity read GetCurrent;
  end;

  TFhirCapabilityStatementRestSecurityList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCapabilityStatementRestSecurity;
    procedure SetItemN(index : Integer; value : TFhirCapabilityStatementRestSecurity);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCapabilityStatementRestSecurityList; overload;
    function Clone : TFhirCapabilityStatementRestSecurityList; overload;
    function GetEnumerator : TFhirCapabilityStatementRestSecurityListEnumerator;
    
    //  Add a FhirCapabilityStatementRestSecurity to the end of the list.
    function Append : TFhirCapabilityStatementRestSecurity;
    
    // Add an already existing FhirCapabilityStatementRestSecurity to the end of the list.
    function AddItem(value : TFhirCapabilityStatementRestSecurity) : TFhirCapabilityStatementRestSecurity; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCapabilityStatementRestSecurity) : Integer;
    
    // Insert FhirCapabilityStatementRestSecurity before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCapabilityStatementRestSecurity;
    
    // Insert an existing FhirCapabilityStatementRestSecurity before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCapabilityStatementRestSecurity);
    
    // Get the iIndexth FhirCapabilityStatementRestSecurity. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCapabilityStatementRestSecurity);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCapabilityStatementRestSecurity;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCapabilityStatementRestSecurities[index : Integer] : TFhirCapabilityStatementRestSecurity read GetItemN write SetItemN; default;
  End;

  // A specification of the restful capabilities of the solution for a specific resource type.
  TFhirCapabilityStatementRestResource = class (TFhirBackboneElement)
  protected
    FType_ : TFhirEnum;
    FProfile : TFhirCanonical;
    FsupportedProfileList : TFhirCanonicalList;
    FDocumentation : TFhirMarkdown;
    FinteractionList : TFhirCapabilityStatementRestResourceInteractionList;
    FVersioning : TFhirEnum;
    FReadHistory : TFhirBoolean;
    FUpdateCreate : TFhirBoolean;
    FConditionalCreate : TFhirBoolean;
    FConditionalRead : TFhirEnum;
    FConditionalUpdate : TFhirBoolean;
    FConditionalDelete : TFhirEnum;
    FReferencePolicy : TFhirEnumList;
    FsearchIncludeList : TFhirStringList;
    FsearchRevIncludeList : TFhirStringList;
    FsearchParamList : TFhirCapabilityStatementRestResourceSearchParamList;
    FoperationList : TFhirCapabilityStatementRestResourceOperationList;
    procedure SetType_(value : TFhirEnum);
    function GetType_ST : TFhirResourceTypesEnum;
    procedure SetType_ST(value : TFhirResourceTypesEnum);
    procedure SetProfile(value : TFhirCanonical);
    function GetProfileST : String;
    procedure SetProfileST(value : String);
    function GetSupportedProfileList : TFhirCanonicalList;
    function GetHasSupportedProfileList : Boolean;
    procedure SetDocumentation(value : TFhirMarkdown);
    function GetDocumentationST : String;
    procedure SetDocumentationST(value : String);
    function GetInteractionList : TFhirCapabilityStatementRestResourceInteractionList;
    function GetHasInteractionList : Boolean;
    procedure SetVersioning(value : TFhirEnum);
    function GetVersioningST : TFhirResourceVersionPolicyEnum;
    procedure SetVersioningST(value : TFhirResourceVersionPolicyEnum);
    procedure SetReadHistory(value : TFhirBoolean);
    function GetReadHistoryST : Boolean;
    procedure SetReadHistoryST(value : Boolean);
    procedure SetUpdateCreate(value : TFhirBoolean);
    function GetUpdateCreateST : Boolean;
    procedure SetUpdateCreateST(value : Boolean);
    procedure SetConditionalCreate(value : TFhirBoolean);
    function GetConditionalCreateST : Boolean;
    procedure SetConditionalCreateST(value : Boolean);
    procedure SetConditionalRead(value : TFhirEnum);
    function GetConditionalReadST : TFhirConditionalReadStatusEnum;
    procedure SetConditionalReadST(value : TFhirConditionalReadStatusEnum);
    procedure SetConditionalUpdate(value : TFhirBoolean);
    function GetConditionalUpdateST : Boolean;
    procedure SetConditionalUpdateST(value : Boolean);
    procedure SetConditionalDelete(value : TFhirEnum);
    function GetConditionalDeleteST : TFhirConditionalDeleteStatusEnum;
    procedure SetConditionalDeleteST(value : TFhirConditionalDeleteStatusEnum);
    function GetReferencePolicy : TFhirEnumList;
    function GetHasReferencePolicy : Boolean;
    function GetReferencePolicyST : TFhirReferenceHandlingPolicyEnumList;
    procedure SetReferencePolicyST(value : TFhirReferenceHandlingPolicyEnumList);
    function GetSearchIncludeList : TFhirStringList;
    function GetHasSearchIncludeList : Boolean;
    function GetSearchRevIncludeList : TFhirStringList;
    function GetHasSearchRevIncludeList : Boolean;
    function GetSearchParamList : TFhirCapabilityStatementRestResourceSearchParamList;
    function GetHasSearchParamList : Boolean;
    function GetOperationList : TFhirCapabilityStatementRestResourceOperationList;
    function GetHasOperationList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCapabilityStatementRestResource; overload;
    function Clone : TFhirCapabilityStatementRestResource; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // A type of resource exposed via the restful interface.
    property type_ : TFhirResourceTypesEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to A specification of the profile that describes the solution's overall support for the resource, including any constraints on cardinality, bindings, lengths or other limitations. See further discussion in [Using Profiles](profiling.html#profile-uses).
    property profile : String read GetProfileST write SetProfileST;
    // A specification of the profile that describes the solution's overall support for the resource, including any constraints on cardinality, bindings, lengths or other limitations. See further discussion in [Using Profiles](profiling.html#profile-uses).
    property profileElement : TFhirCanonical read FProfile write SetProfile;

    // A list of profiles that represent different use cases supported by the system. For a server, "supported by the system" means the system hosts/produces a set of resources that are conformant to a particular profile, and allows clients that use its services to search using this profile and to find appropriate data. For a client, it means the system will search by this profile and process data according to the guidance implicit in the profile. See further discussion in [Using Profiles](profiling.html#profile-uses).
    property supportedProfileList : TFhirCanonicalList read GetSupportedProfileList;
    property hasSupportedProfileList : boolean read GetHasSupportedProfileList;

    // Typed access to Additional information about the resource type used by the system.
    property documentation : String read GetDocumentationST write SetDocumentationST;
    // Additional information about the resource type used by the system.
    property documentationElement : TFhirMarkdown read FDocumentation write SetDocumentation;

    // Identifies a restful operation supported by the solution.
    property interactionList : TFhirCapabilityStatementRestResourceInteractionList read GetInteractionList;
    property hasInteractionList : boolean read GetHasInteractionList;

    // This field is set to no-version to specify that the system does not support (server) or use (client) versioning for this resource type. If this has some other value, the server must at least correctly track and populate the versionId meta-property on resources. If the value is 'versioned-update', then the server supports all the versioning features, including using e-tags for version integrity in the API.
    property versioning : TFhirResourceVersionPolicyEnum read GetVersioningST write SetVersioningST;
    property versioningElement : TFhirEnum read FVersioning write SetVersioning;

    // Typed access to A flag for whether the server is able to return past versions as part of the vRead operation.
    property readHistory : Boolean read GetReadHistoryST write SetReadHistoryST;
    // A flag for whether the server is able to return past versions as part of the vRead operation.
    property readHistoryElement : TFhirBoolean read FReadHistory write SetReadHistory;

    // Typed access to A flag to indicate that the server allows or needs to allow the client to create new identities on the server (that is, the client PUTs to a location where there is no existing resource). Allowing this operation means that the server allows the client to create new identities on the server.
    property updateCreate : Boolean read GetUpdateCreateST write SetUpdateCreateST;
    // A flag to indicate that the server allows or needs to allow the client to create new identities on the server (that is, the client PUTs to a location where there is no existing resource). Allowing this operation means that the server allows the client to create new identities on the server.
    property updateCreateElement : TFhirBoolean read FUpdateCreate write SetUpdateCreate;

    // Typed access to A flag that indicates that the server supports conditional create.
    property conditionalCreate : Boolean read GetConditionalCreateST write SetConditionalCreateST;
    // A flag that indicates that the server supports conditional create.
    property conditionalCreateElement : TFhirBoolean read FConditionalCreate write SetConditionalCreate;

    // A code that indicates how the server supports conditional read.
    property conditionalRead : TFhirConditionalReadStatusEnum read GetConditionalReadST write SetConditionalReadST;
    property conditionalReadElement : TFhirEnum read FConditionalRead write SetConditionalRead;

    // Typed access to A flag that indicates that the server supports conditional update.
    property conditionalUpdate : Boolean read GetConditionalUpdateST write SetConditionalUpdateST;
    // A flag that indicates that the server supports conditional update.
    property conditionalUpdateElement : TFhirBoolean read FConditionalUpdate write SetConditionalUpdate;

    // A code that indicates how the server supports conditional delete.
    property conditionalDelete : TFhirConditionalDeleteStatusEnum read GetConditionalDeleteST write SetConditionalDeleteST;
    property conditionalDeleteElement : TFhirEnum read FConditionalDelete write SetConditionalDelete;

    // A set of flags that defines how references are supported.
    property referencePolicy : TFhirReferenceHandlingPolicyEnumList read GetReferencePolicyST write SetReferencePolicyST;
    property referencePolicyList : TFhirEnumList read GetReferencePolicy;
    property hasReferencePolicy : boolean read GetHasReferencePolicy;
    // A list of _include values supported by the server.
    property searchIncludeList : TFhirStringList read GetSearchIncludeList;
    property hasSearchIncludeList : boolean read GetHasSearchIncludeList;

    // A list of _revinclude (reverse include) values supported by the server.
    property searchRevIncludeList : TFhirStringList read GetSearchRevIncludeList;
    property hasSearchRevIncludeList : boolean read GetHasSearchRevIncludeList;

    // Search parameters for implementations to support and/or make use of - either references to ones defined in the specification, or additional ones defined for/by the implementation.
    property searchParamList : TFhirCapabilityStatementRestResourceSearchParamList read GetSearchParamList;
    property hasSearchParamList : boolean read GetHasSearchParamList;

    // Definition of an operation or a named query together with its parameters and their meaning and type. Consult the definition of the operation for details about how to invoke the operation, and the parameters.
    property operationList : TFhirCapabilityStatementRestResourceOperationList read GetOperationList;
    property hasOperationList : boolean read GetHasOperationList;

  end;

  TFhirCapabilityStatementRestResourceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCapabilityStatementRestResourceList;
    function GetCurrent : TFhirCapabilityStatementRestResource;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCapabilityStatementRestResourceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCapabilityStatementRestResource read GetCurrent;
  end;

  TFhirCapabilityStatementRestResourceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCapabilityStatementRestResource;
    procedure SetItemN(index : Integer; value : TFhirCapabilityStatementRestResource);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCapabilityStatementRestResourceList; overload;
    function Clone : TFhirCapabilityStatementRestResourceList; overload;
    function GetEnumerator : TFhirCapabilityStatementRestResourceListEnumerator;
    
    //  Add a FhirCapabilityStatementRestResource to the end of the list.
    function Append : TFhirCapabilityStatementRestResource;
    
    // Add an already existing FhirCapabilityStatementRestResource to the end of the list.
    function AddItem(value : TFhirCapabilityStatementRestResource) : TFhirCapabilityStatementRestResource; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCapabilityStatementRestResource) : Integer;
    
    // Insert FhirCapabilityStatementRestResource before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCapabilityStatementRestResource;
    
    // Insert an existing FhirCapabilityStatementRestResource before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCapabilityStatementRestResource);
    
    // Get the iIndexth FhirCapabilityStatementRestResource. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCapabilityStatementRestResource);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCapabilityStatementRestResource;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCapabilityStatementRestResources[index : Integer] : TFhirCapabilityStatementRestResource read GetItemN write SetItemN; default;
  End;

  // Identifies a restful operation supported by the solution.
  TFhirCapabilityStatementRestResourceInteraction = class (TFhirBackboneElement)
  protected
    FCode : TFhirEnum;
    FDocumentation : TFhirMarkdown;
    procedure SetCode(value : TFhirEnum);
    function GetCodeST : TFhirTypeRestfulInteractionEnum;
    procedure SetCodeST(value : TFhirTypeRestfulInteractionEnum);
    procedure SetDocumentation(value : TFhirMarkdown);
    function GetDocumentationST : String;
    procedure SetDocumentationST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCapabilityStatementRestResourceInteraction; overload;
    function Clone : TFhirCapabilityStatementRestResourceInteraction; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Coded identifier of the operation, supported by the system resource.
    property code : TFhirTypeRestfulInteractionEnum read GetCodeST write SetCodeST;
    property codeElement : TFhirEnum read FCode write SetCode;

    // Typed access to Guidance specific to the implementation of this operation, such as 'delete is a logical delete' or 'updates are only allowed with version id' or 'creates permitted from pre-authorized certificates only'.
    property documentation : String read GetDocumentationST write SetDocumentationST;
    // Guidance specific to the implementation of this operation, such as 'delete is a logical delete' or 'updates are only allowed with version id' or 'creates permitted from pre-authorized certificates only'.
    property documentationElement : TFhirMarkdown read FDocumentation write SetDocumentation;

  end;

  TFhirCapabilityStatementRestResourceInteractionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCapabilityStatementRestResourceInteractionList;
    function GetCurrent : TFhirCapabilityStatementRestResourceInteraction;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCapabilityStatementRestResourceInteractionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCapabilityStatementRestResourceInteraction read GetCurrent;
  end;

  TFhirCapabilityStatementRestResourceInteractionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCapabilityStatementRestResourceInteraction;
    procedure SetItemN(index : Integer; value : TFhirCapabilityStatementRestResourceInteraction);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCapabilityStatementRestResourceInteractionList; overload;
    function Clone : TFhirCapabilityStatementRestResourceInteractionList; overload;
    function GetEnumerator : TFhirCapabilityStatementRestResourceInteractionListEnumerator;
    
    //  Add a FhirCapabilityStatementRestResourceInteraction to the end of the list.
    function Append : TFhirCapabilityStatementRestResourceInteraction;
    
    // Add an already existing FhirCapabilityStatementRestResourceInteraction to the end of the list.
    function AddItem(value : TFhirCapabilityStatementRestResourceInteraction) : TFhirCapabilityStatementRestResourceInteraction; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCapabilityStatementRestResourceInteraction) : Integer;
    
    // Insert FhirCapabilityStatementRestResourceInteraction before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCapabilityStatementRestResourceInteraction;
    
    // Insert an existing FhirCapabilityStatementRestResourceInteraction before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCapabilityStatementRestResourceInteraction);
    
    // Get the iIndexth FhirCapabilityStatementRestResourceInteraction. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCapabilityStatementRestResourceInteraction);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCapabilityStatementRestResourceInteraction;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCapabilityStatementRestResourceInteractions[index : Integer] : TFhirCapabilityStatementRestResourceInteraction read GetItemN write SetItemN; default;
  End;

  // Search parameters for implementations to support and/or make use of - either references to ones defined in the specification, or additional ones defined for/by the implementation.
  TFhirCapabilityStatementRestResourceSearchParam = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FDefinition : TFhirCanonical;
    FType_ : TFhirEnum;
    FDocumentation : TFhirMarkdown;
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetDefinition(value : TFhirCanonical);
    function GetDefinitionST : String;
    procedure SetDefinitionST(value : String);
    procedure SetType_(value : TFhirEnum);
    function GetType_ST : TFhirSearchParamTypeEnum;
    procedure SetType_ST(value : TFhirSearchParamTypeEnum);
    procedure SetDocumentation(value : TFhirMarkdown);
    function GetDocumentationST : String;
    procedure SetDocumentationST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCapabilityStatementRestResourceSearchParam; overload;
    function Clone : TFhirCapabilityStatementRestResourceSearchParam; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The name of the search parameter used in the interface.
    property name : String read GetNameST write SetNameST;
    // The name of the search parameter used in the interface.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to An absolute URI that is a formal reference to where this parameter was first defined, so that a client can be confident of the meaning of the search parameter (a reference to [SearchParameter.url](searchparameter-definitions.html#SearchParameter.url)). This element SHALL be populated if the search parameter refers to a SearchParameter defined by the FHIR core specification or externally defined IGs.
    property definition : String read GetDefinitionST write SetDefinitionST;
    // An absolute URI that is a formal reference to where this parameter was first defined, so that a client can be confident of the meaning of the search parameter (a reference to [SearchParameter.url](searchparameter-definitions.html#SearchParameter.url)). This element SHALL be populated if the search parameter refers to a SearchParameter defined by the FHIR core specification or externally defined IGs.
    property definitionElement : TFhirCanonical read FDefinition write SetDefinition;

    // The type of value a search parameter refers to, and how the content is interpreted.
    property type_ : TFhirSearchParamTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to This allows documentation of any distinct behaviors about how the search parameter is used.  For example, text matching algorithms.
    property documentation : String read GetDocumentationST write SetDocumentationST;
    // This allows documentation of any distinct behaviors about how the search parameter is used.  For example, text matching algorithms.
    property documentationElement : TFhirMarkdown read FDocumentation write SetDocumentation;

  end;

  TFhirCapabilityStatementRestResourceSearchParamListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCapabilityStatementRestResourceSearchParamList;
    function GetCurrent : TFhirCapabilityStatementRestResourceSearchParam;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCapabilityStatementRestResourceSearchParamList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCapabilityStatementRestResourceSearchParam read GetCurrent;
  end;

  TFhirCapabilityStatementRestResourceSearchParamList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCapabilityStatementRestResourceSearchParam;
    procedure SetItemN(index : Integer; value : TFhirCapabilityStatementRestResourceSearchParam);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCapabilityStatementRestResourceSearchParamList; overload;
    function Clone : TFhirCapabilityStatementRestResourceSearchParamList; overload;
    function GetEnumerator : TFhirCapabilityStatementRestResourceSearchParamListEnumerator;
    
    //  Add a FhirCapabilityStatementRestResourceSearchParam to the end of the list.
    function Append : TFhirCapabilityStatementRestResourceSearchParam;
    
    // Add an already existing FhirCapabilityStatementRestResourceSearchParam to the end of the list.
    function AddItem(value : TFhirCapabilityStatementRestResourceSearchParam) : TFhirCapabilityStatementRestResourceSearchParam; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCapabilityStatementRestResourceSearchParam) : Integer;
    
    // Insert FhirCapabilityStatementRestResourceSearchParam before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCapabilityStatementRestResourceSearchParam;
    
    // Insert an existing FhirCapabilityStatementRestResourceSearchParam before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCapabilityStatementRestResourceSearchParam);
    
    // Get the iIndexth FhirCapabilityStatementRestResourceSearchParam. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCapabilityStatementRestResourceSearchParam);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCapabilityStatementRestResourceSearchParam;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCapabilityStatementRestResourceSearchParams[index : Integer] : TFhirCapabilityStatementRestResourceSearchParam read GetItemN write SetItemN; default;
  End;

  // Definition of an operation or a named query together with its parameters and their meaning and type. Consult the definition of the operation for details about how to invoke the operation, and the parameters.
  TFhirCapabilityStatementRestResourceOperation = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FDefinition : TFhirCanonical;
    FDocumentation : TFhirMarkdown;
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetDefinition(value : TFhirCanonical);
    function GetDefinitionST : String;
    procedure SetDefinitionST(value : String);
    procedure SetDocumentation(value : TFhirMarkdown);
    function GetDocumentationST : String;
    procedure SetDocumentationST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCapabilityStatementRestResourceOperation; overload;
    function Clone : TFhirCapabilityStatementRestResourceOperation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The name of the operation or query. For an operation, this is the name  prefixed with $ and used in the URL. For a query, this is the name used in the _query parameter when the query is called.
    property name : String read GetNameST write SetNameST;
    // The name of the operation or query. For an operation, this is the name  prefixed with $ and used in the URL. For a query, this is the name used in the _query parameter when the query is called.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to Where the formal definition can be found. If a server references the base definition of an Operation (i.e. from the specification itself such as ```http://hl7.org/fhir/OperationDefinition/ValueSet-expand```), that means it supports the full capabilities of the operation - e.g. both GET and POST invocation.  If it only supports a subset, it must define its own custom [OperationDefinition](operationdefinition.html#) with a 'base' of the original OperationDefinition.  The custom definition would describe the specific subset of functionality supported.
    property definition : String read GetDefinitionST write SetDefinitionST;
    // Where the formal definition can be found. If a server references the base definition of an Operation (i.e. from the specification itself such as ```http://hl7.org/fhir/OperationDefinition/ValueSet-expand```), that means it supports the full capabilities of the operation - e.g. both GET and POST invocation.  If it only supports a subset, it must define its own custom [OperationDefinition](operationdefinition.html#) with a 'base' of the original OperationDefinition.  The custom definition would describe the specific subset of functionality supported.
    property definitionElement : TFhirCanonical read FDefinition write SetDefinition;

    // Typed access to Documentation that describes anything special about the operation behavior, possibly detailing different behavior for system, type and instance-level invocation of the operation.
    property documentation : String read GetDocumentationST write SetDocumentationST;
    // Documentation that describes anything special about the operation behavior, possibly detailing different behavior for system, type and instance-level invocation of the operation.
    property documentationElement : TFhirMarkdown read FDocumentation write SetDocumentation;

  end;

  TFhirCapabilityStatementRestResourceOperationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCapabilityStatementRestResourceOperationList;
    function GetCurrent : TFhirCapabilityStatementRestResourceOperation;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCapabilityStatementRestResourceOperationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCapabilityStatementRestResourceOperation read GetCurrent;
  end;

  TFhirCapabilityStatementRestResourceOperationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCapabilityStatementRestResourceOperation;
    procedure SetItemN(index : Integer; value : TFhirCapabilityStatementRestResourceOperation);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCapabilityStatementRestResourceOperationList; overload;
    function Clone : TFhirCapabilityStatementRestResourceOperationList; overload;
    function GetEnumerator : TFhirCapabilityStatementRestResourceOperationListEnumerator;
    
    //  Add a FhirCapabilityStatementRestResourceOperation to the end of the list.
    function Append : TFhirCapabilityStatementRestResourceOperation;
    
    // Add an already existing FhirCapabilityStatementRestResourceOperation to the end of the list.
    function AddItem(value : TFhirCapabilityStatementRestResourceOperation) : TFhirCapabilityStatementRestResourceOperation; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCapabilityStatementRestResourceOperation) : Integer;
    
    // Insert FhirCapabilityStatementRestResourceOperation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCapabilityStatementRestResourceOperation;
    
    // Insert an existing FhirCapabilityStatementRestResourceOperation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCapabilityStatementRestResourceOperation);
    
    // Get the iIndexth FhirCapabilityStatementRestResourceOperation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCapabilityStatementRestResourceOperation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCapabilityStatementRestResourceOperation;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCapabilityStatementRestResourceOperations[index : Integer] : TFhirCapabilityStatementRestResourceOperation read GetItemN write SetItemN; default;
  End;

  // A specification of restful operations supported by the system.
  TFhirCapabilityStatementRestInteraction = class (TFhirBackboneElement)
  protected
    FCode : TFhirEnum;
    FDocumentation : TFhirMarkdown;
    procedure SetCode(value : TFhirEnum);
    function GetCodeST : TFhirSystemRestfulInteractionEnum;
    procedure SetCodeST(value : TFhirSystemRestfulInteractionEnum);
    procedure SetDocumentation(value : TFhirMarkdown);
    function GetDocumentationST : String;
    procedure SetDocumentationST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCapabilityStatementRestInteraction; overload;
    function Clone : TFhirCapabilityStatementRestInteraction; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // A coded identifier of the operation, supported by the system.
    property code : TFhirSystemRestfulInteractionEnum read GetCodeST write SetCodeST;
    property codeElement : TFhirEnum read FCode write SetCode;

    // Typed access to Guidance specific to the implementation of this operation, such as limitations on the kind of transactions allowed, or information about system wide search is implemented.
    property documentation : String read GetDocumentationST write SetDocumentationST;
    // Guidance specific to the implementation of this operation, such as limitations on the kind of transactions allowed, or information about system wide search is implemented.
    property documentationElement : TFhirMarkdown read FDocumentation write SetDocumentation;

  end;

  TFhirCapabilityStatementRestInteractionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCapabilityStatementRestInteractionList;
    function GetCurrent : TFhirCapabilityStatementRestInteraction;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCapabilityStatementRestInteractionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCapabilityStatementRestInteraction read GetCurrent;
  end;

  TFhirCapabilityStatementRestInteractionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCapabilityStatementRestInteraction;
    procedure SetItemN(index : Integer; value : TFhirCapabilityStatementRestInteraction);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCapabilityStatementRestInteractionList; overload;
    function Clone : TFhirCapabilityStatementRestInteractionList; overload;
    function GetEnumerator : TFhirCapabilityStatementRestInteractionListEnumerator;
    
    //  Add a FhirCapabilityStatementRestInteraction to the end of the list.
    function Append : TFhirCapabilityStatementRestInteraction;
    
    // Add an already existing FhirCapabilityStatementRestInteraction to the end of the list.
    function AddItem(value : TFhirCapabilityStatementRestInteraction) : TFhirCapabilityStatementRestInteraction; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCapabilityStatementRestInteraction) : Integer;
    
    // Insert FhirCapabilityStatementRestInteraction before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCapabilityStatementRestInteraction;
    
    // Insert an existing FhirCapabilityStatementRestInteraction before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCapabilityStatementRestInteraction);
    
    // Get the iIndexth FhirCapabilityStatementRestInteraction. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCapabilityStatementRestInteraction);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCapabilityStatementRestInteraction;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCapabilityStatementRestInteractions[index : Integer] : TFhirCapabilityStatementRestInteraction read GetItemN write SetItemN; default;
  End;

  // A description of the messaging capabilities of the solution.
  TFhirCapabilityStatementMessaging = class (TFhirBackboneElement)
  protected
    FendpointList : TFhirCapabilityStatementMessagingEndpointList;
    FReliableCache : TFhirUnsignedInt;
    FDocumentation : TFhirMarkdown;
    FsupportedMessageList : TFhirCapabilityStatementMessagingSupportedMessageList;
    function GetEndpointList : TFhirCapabilityStatementMessagingEndpointList;
    function GetHasEndpointList : Boolean;
    procedure SetReliableCache(value : TFhirUnsignedInt);
    function GetReliableCacheST : String;
    procedure SetReliableCacheST(value : String);
    procedure SetDocumentation(value : TFhirMarkdown);
    function GetDocumentationST : String;
    procedure SetDocumentationST(value : String);
    function GetSupportedMessageList : TFhirCapabilityStatementMessagingSupportedMessageList;
    function GetHasSupportedMessageList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCapabilityStatementMessaging; overload;
    function Clone : TFhirCapabilityStatementMessaging; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // An endpoint (network accessible address) to which messages and/or replies are to be sent.
    property endpointList : TFhirCapabilityStatementMessagingEndpointList read GetEndpointList;
    property hasEndpointList : boolean read GetHasEndpointList;

    // Typed access to Length if the receiver's reliable messaging cache in minutes (if a receiver) or how long the cache length on the receiver should be (if a sender).
    property reliableCache : String read GetReliableCacheST write SetReliableCacheST;
    // Length if the receiver's reliable messaging cache in minutes (if a receiver) or how long the cache length on the receiver should be (if a sender).
    property reliableCacheElement : TFhirUnsignedInt read FReliableCache write SetReliableCache;

    // Typed access to Documentation about the system's messaging capabilities for this endpoint not otherwise documented by the capability statement.  For example, the process for becoming an authorized messaging exchange partner.
    property documentation : String read GetDocumentationST write SetDocumentationST;
    // Documentation about the system's messaging capabilities for this endpoint not otherwise documented by the capability statement.  For example, the process for becoming an authorized messaging exchange partner.
    property documentationElement : TFhirMarkdown read FDocumentation write SetDocumentation;

    // References to message definitions for messages this system can send or receive.
    property supportedMessageList : TFhirCapabilityStatementMessagingSupportedMessageList read GetSupportedMessageList;
    property hasSupportedMessageList : boolean read GetHasSupportedMessageList;

  end;

  TFhirCapabilityStatementMessagingListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCapabilityStatementMessagingList;
    function GetCurrent : TFhirCapabilityStatementMessaging;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCapabilityStatementMessagingList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCapabilityStatementMessaging read GetCurrent;
  end;

  TFhirCapabilityStatementMessagingList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCapabilityStatementMessaging;
    procedure SetItemN(index : Integer; value : TFhirCapabilityStatementMessaging);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCapabilityStatementMessagingList; overload;
    function Clone : TFhirCapabilityStatementMessagingList; overload;
    function GetEnumerator : TFhirCapabilityStatementMessagingListEnumerator;
    
    //  Add a FhirCapabilityStatementMessaging to the end of the list.
    function Append : TFhirCapabilityStatementMessaging;
    
    // Add an already existing FhirCapabilityStatementMessaging to the end of the list.
    function AddItem(value : TFhirCapabilityStatementMessaging) : TFhirCapabilityStatementMessaging; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCapabilityStatementMessaging) : Integer;
    
    // Insert FhirCapabilityStatementMessaging before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCapabilityStatementMessaging;
    
    // Insert an existing FhirCapabilityStatementMessaging before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCapabilityStatementMessaging);
    
    // Get the iIndexth FhirCapabilityStatementMessaging. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCapabilityStatementMessaging);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCapabilityStatementMessaging;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCapabilityStatementMessagings[index : Integer] : TFhirCapabilityStatementMessaging read GetItemN write SetItemN; default;
  End;

  // An endpoint (network accessible address) to which messages and/or replies are to be sent.
  TFhirCapabilityStatementMessagingEndpoint = class (TFhirBackboneElement)
  protected
    FProtocol : TFhirCoding;
    FAddress : TFhirUrl;
    procedure SetProtocol(value : TFhirCoding);
    procedure SetAddress(value : TFhirUrl);
    function GetAddressST : String;
    procedure SetAddressST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCapabilityStatementMessagingEndpoint; overload;
    function Clone : TFhirCapabilityStatementMessagingEndpoint; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A list of the messaging transport protocol(s) identifiers, supported by this endpoint. (defined for API consistency)
    property protocol : TFhirCoding read FProtocol write SetProtocol;
    // A list of the messaging transport protocol(s) identifiers, supported by this endpoint.
    property protocolElement : TFhirCoding read FProtocol write SetProtocol;

    // Typed access to The network address of the endpoint. For solutions that do not use network addresses for routing, it can be just an identifier.
    property address : String read GetAddressST write SetAddressST;
    // The network address of the endpoint. For solutions that do not use network addresses for routing, it can be just an identifier.
    property addressElement : TFhirUrl read FAddress write SetAddress;

  end;

  TFhirCapabilityStatementMessagingEndpointListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCapabilityStatementMessagingEndpointList;
    function GetCurrent : TFhirCapabilityStatementMessagingEndpoint;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCapabilityStatementMessagingEndpointList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCapabilityStatementMessagingEndpoint read GetCurrent;
  end;

  TFhirCapabilityStatementMessagingEndpointList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCapabilityStatementMessagingEndpoint;
    procedure SetItemN(index : Integer; value : TFhirCapabilityStatementMessagingEndpoint);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCapabilityStatementMessagingEndpointList; overload;
    function Clone : TFhirCapabilityStatementMessagingEndpointList; overload;
    function GetEnumerator : TFhirCapabilityStatementMessagingEndpointListEnumerator;
    
    //  Add a FhirCapabilityStatementMessagingEndpoint to the end of the list.
    function Append : TFhirCapabilityStatementMessagingEndpoint;
    
    // Add an already existing FhirCapabilityStatementMessagingEndpoint to the end of the list.
    function AddItem(value : TFhirCapabilityStatementMessagingEndpoint) : TFhirCapabilityStatementMessagingEndpoint; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCapabilityStatementMessagingEndpoint) : Integer;
    
    // Insert FhirCapabilityStatementMessagingEndpoint before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCapabilityStatementMessagingEndpoint;
    
    // Insert an existing FhirCapabilityStatementMessagingEndpoint before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCapabilityStatementMessagingEndpoint);
    
    // Get the iIndexth FhirCapabilityStatementMessagingEndpoint. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCapabilityStatementMessagingEndpoint);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCapabilityStatementMessagingEndpoint;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCapabilityStatementMessagingEndpoints[index : Integer] : TFhirCapabilityStatementMessagingEndpoint read GetItemN write SetItemN; default;
  End;

  // References to message definitions for messages this system can send or receive.
  TFhirCapabilityStatementMessagingSupportedMessage = class (TFhirBackboneElement)
  protected
    FMode : TFhirEnum;
    FDefinition : TFhirCanonical;
    procedure SetMode(value : TFhirEnum);
    function GetModeST : TFhirEventCapabilityModeEnum;
    procedure SetModeST(value : TFhirEventCapabilityModeEnum);
    procedure SetDefinition(value : TFhirCanonical);
    function GetDefinitionST : String;
    procedure SetDefinitionST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCapabilityStatementMessagingSupportedMessage; overload;
    function Clone : TFhirCapabilityStatementMessagingSupportedMessage; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The mode of this event declaration - whether application is sender or receiver.
    property mode : TFhirEventCapabilityModeEnum read GetModeST write SetModeST;
    property modeElement : TFhirEnum read FMode write SetMode;

    // Typed access to Points to a message definition that identifies the messaging event, message structure, allowed responses, etc.
    property definition : String read GetDefinitionST write SetDefinitionST;
    // Points to a message definition that identifies the messaging event, message structure, allowed responses, etc.
    property definitionElement : TFhirCanonical read FDefinition write SetDefinition;

  end;

  TFhirCapabilityStatementMessagingSupportedMessageListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCapabilityStatementMessagingSupportedMessageList;
    function GetCurrent : TFhirCapabilityStatementMessagingSupportedMessage;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCapabilityStatementMessagingSupportedMessageList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCapabilityStatementMessagingSupportedMessage read GetCurrent;
  end;

  TFhirCapabilityStatementMessagingSupportedMessageList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCapabilityStatementMessagingSupportedMessage;
    procedure SetItemN(index : Integer; value : TFhirCapabilityStatementMessagingSupportedMessage);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCapabilityStatementMessagingSupportedMessageList; overload;
    function Clone : TFhirCapabilityStatementMessagingSupportedMessageList; overload;
    function GetEnumerator : TFhirCapabilityStatementMessagingSupportedMessageListEnumerator;
    
    //  Add a FhirCapabilityStatementMessagingSupportedMessage to the end of the list.
    function Append : TFhirCapabilityStatementMessagingSupportedMessage;
    
    // Add an already existing FhirCapabilityStatementMessagingSupportedMessage to the end of the list.
    function AddItem(value : TFhirCapabilityStatementMessagingSupportedMessage) : TFhirCapabilityStatementMessagingSupportedMessage; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCapabilityStatementMessagingSupportedMessage) : Integer;
    
    // Insert FhirCapabilityStatementMessagingSupportedMessage before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCapabilityStatementMessagingSupportedMessage;
    
    // Insert an existing FhirCapabilityStatementMessagingSupportedMessage before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCapabilityStatementMessagingSupportedMessage);
    
    // Get the iIndexth FhirCapabilityStatementMessagingSupportedMessage. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCapabilityStatementMessagingSupportedMessage);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCapabilityStatementMessagingSupportedMessage;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCapabilityStatementMessagingSupportedMessages[index : Integer] : TFhirCapabilityStatementMessagingSupportedMessage read GetItemN write SetItemN; default;
  End;

  // A document definition.
  TFhirCapabilityStatementDocument = class (TFhirBackboneElement)
  protected
    FMode : TFhirEnum;
    FDocumentation : TFhirMarkdown;
    FProfile : TFhirCanonical;
    procedure SetMode(value : TFhirEnum);
    function GetModeST : TFhirDocumentModeEnum;
    procedure SetModeST(value : TFhirDocumentModeEnum);
    procedure SetDocumentation(value : TFhirMarkdown);
    function GetDocumentationST : String;
    procedure SetDocumentationST(value : String);
    procedure SetProfile(value : TFhirCanonical);
    function GetProfileST : String;
    procedure SetProfileST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCapabilityStatementDocument; overload;
    function Clone : TFhirCapabilityStatementDocument; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Mode of this document declaration - whether an application is a producer or consumer.
    property mode : TFhirDocumentModeEnum read GetModeST write SetModeST;
    property modeElement : TFhirEnum read FMode write SetMode;

    // Typed access to A description of how the application supports or uses the specified document profile.  For example, when documents are created, what action is taken with consumed documents, etc.
    property documentation : String read GetDocumentationST write SetDocumentationST;
    // A description of how the application supports or uses the specified document profile.  For example, when documents are created, what action is taken with consumed documents, etc.
    property documentationElement : TFhirMarkdown read FDocumentation write SetDocumentation;

    // Typed access to A profile on the document Bundle that constrains which resources are present, and their contents.
    property profile : String read GetProfileST write SetProfileST;
    // A profile on the document Bundle that constrains which resources are present, and their contents.
    property profileElement : TFhirCanonical read FProfile write SetProfile;

  end;

  TFhirCapabilityStatementDocumentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCapabilityStatementDocumentList;
    function GetCurrent : TFhirCapabilityStatementDocument;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCapabilityStatementDocumentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCapabilityStatementDocument read GetCurrent;
  end;

  TFhirCapabilityStatementDocumentList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCapabilityStatementDocument;
    procedure SetItemN(index : Integer; value : TFhirCapabilityStatementDocument);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCapabilityStatementDocumentList; overload;
    function Clone : TFhirCapabilityStatementDocumentList; overload;
    function GetEnumerator : TFhirCapabilityStatementDocumentListEnumerator;
    
    //  Add a FhirCapabilityStatementDocument to the end of the list.
    function Append : TFhirCapabilityStatementDocument;
    
    // Add an already existing FhirCapabilityStatementDocument to the end of the list.
    function AddItem(value : TFhirCapabilityStatementDocument) : TFhirCapabilityStatementDocument; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCapabilityStatementDocument) : Integer;
    
    // Insert FhirCapabilityStatementDocument before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCapabilityStatementDocument;
    
    // Insert an existing FhirCapabilityStatementDocument before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCapabilityStatementDocument);
    
    // Get the iIndexth FhirCapabilityStatementDocument. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCapabilityStatementDocument);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCapabilityStatementDocument;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCapabilityStatementDocuments[index : Integer] : TFhirCapabilityStatementDocument read GetItemN write SetItemN; default;
  End;

  // A Capability Statement documents a set of capabilities (behaviors) of a FHIR Server for a particular version of FHIR that may be used as a statement of actual server functionality or a statement of required or desired server implementation.
  TFhirCapabilityStatement = class (TFhirDomainResource)
  protected
    FUrl : TFhirUri;
    FVersion : TFhirString;
    FName : TFhirString;
    FTitle : TFhirString;
    FStatus : TFhirEnum;
    FExperimental : TFhirBoolean;
    FDate : TFhirDateTime;
    FPublisher : TFhirString;
    FcontactList : TFhirContactDetailList;
    FDescription : TFhirMarkdown;
    FuseContextList : TFhirUsageContextList;
    FjurisdictionList : TFhirCodeableConceptList;
    FPurpose : TFhirMarkdown;
    FCopyright : TFhirMarkdown;
    FKind : TFhirEnum;
    FinstantiatesList : TFhirCanonicalList;
    FimportsList : TFhirCanonicalList;
    FSoftware : TFhirCapabilityStatementSoftware;
    FImplementation_ : TFhirCapabilityStatementImplementation;
    FFhirVersion : TFhirEnum;
    FformatList : TFhirCodeList;
    FpatchFormatList : TFhirCodeList;
    FimplementationGuideList : TFhirCanonicalList;
    FrestList : TFhirCapabilityStatementRestList;
    FmessagingList : TFhirCapabilityStatementMessagingList;
    FdocumentList : TFhirCapabilityStatementDocumentList;
    procedure SetUrl(value : TFhirUri);
    function GetUrlST : String;
    procedure SetUrlST(value : String);
    procedure SetVersion(value : TFhirString);
    function GetVersionST : String;
    procedure SetVersionST(value : String);
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetTitle(value : TFhirString);
    function GetTitleST : String;
    procedure SetTitleST(value : String);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirPublicationStatusEnum;
    procedure SetStatusST(value : TFhirPublicationStatusEnum);
    procedure SetExperimental(value : TFhirBoolean);
    function GetExperimentalST : Boolean;
    procedure SetExperimentalST(value : Boolean);
    procedure SetDate(value : TFhirDateTime);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    procedure SetPublisher(value : TFhirString);
    function GetPublisherST : String;
    procedure SetPublisherST(value : String);
    function GetContactList : TFhirContactDetailList;
    function GetHasContactList : Boolean;
    procedure SetDescription(value : TFhirMarkdown);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetUseContextList : TFhirUsageContextList;
    function GetHasUseContextList : Boolean;
    function GetJurisdictionList : TFhirCodeableConceptList;
    function GetHasJurisdictionList : Boolean;
    procedure SetPurpose(value : TFhirMarkdown);
    function GetPurposeST : String;
    procedure SetPurposeST(value : String);
    procedure SetCopyright(value : TFhirMarkdown);
    function GetCopyrightST : String;
    procedure SetCopyrightST(value : String);
    procedure SetKind(value : TFhirEnum);
    function GetKindST : TFhirCapabilityStatementKindEnum;
    procedure SetKindST(value : TFhirCapabilityStatementKindEnum);
    function GetInstantiatesList : TFhirCanonicalList;
    function GetHasInstantiatesList : Boolean;
    function GetImportsList : TFhirCanonicalList;
    function GetHasImportsList : Boolean;
    procedure SetSoftware(value : TFhirCapabilityStatementSoftware);
    procedure SetImplementation_(value : TFhirCapabilityStatementImplementation);
    procedure SetFhirVersion(value : TFhirEnum);
    function GetFhirVersionST : TFhirFHIRVersionEnum;
    procedure SetFhirVersionST(value : TFhirFHIRVersionEnum);
    function GetFormatList : TFhirCodeList;
    function GetHasFormatList : Boolean;
    function GetPatchFormatList : TFhirCodeList;
    function GetHasPatchFormatList : Boolean;
    function GetImplementationGuideList : TFhirCanonicalList;
    function GetHasImplementationGuideList : Boolean;
    function GetRestList : TFhirCapabilityStatementRestList;
    function GetHasRestList : Boolean;
    function GetMessagingList : TFhirCapabilityStatementMessagingList;
    function GetHasMessagingList : Boolean;
    function GetDocumentList : TFhirCapabilityStatementDocumentList;
    function GetHasDocumentList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCapabilityStatement; overload;
    function Clone : TFhirCapabilityStatement; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An absolute URI that is used to identify this capability statement when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this capability statement is (or will be) published. This URL can be the target of a canonical reference. It SHALL remain the same when the capability statement is stored on different servers.
    property url : String read GetUrlST write SetUrlST;
    // An absolute URI that is used to identify this capability statement when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this capability statement is (or will be) published. This URL can be the target of a canonical reference. It SHALL remain the same when the capability statement is stored on different servers.
    property urlElement : TFhirUri read FUrl write SetUrl;

    // Typed access to The identifier that is used to identify this version of the capability statement when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the capability statement author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
    property version : String read GetVersionST write SetVersionST;
    // The identifier that is used to identify this version of the capability statement when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the capability statement author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to A natural language name identifying the capability statement. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property name : String read GetNameST write SetNameST;
    // A natural language name identifying the capability statement. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A short, descriptive, user-friendly title for the capability statement.
    property title : String read GetTitleST write SetTitleST;
    // A short, descriptive, user-friendly title for the capability statement.
    property titleElement : TFhirString read FTitle write SetTitle;

    // The status of this capability statement. Enables tracking the life-cycle of the content.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A Boolean value to indicate that this capability statement is authored for testing purposes (or education/evaluation/marketing) and is not intended to be used for genuine usage.
    property experimental : Boolean read GetExperimentalST write SetExperimentalST;
    // A Boolean value to indicate that this capability statement is authored for testing purposes (or education/evaluation/marketing) and is not intended to be used for genuine usage.
    property experimentalElement : TFhirBoolean read FExperimental write SetExperimental;

    // Typed access to The date  (and optionally time) when the capability statement was published. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the capability statement changes.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date  (and optionally time) when the capability statement was published. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the capability statement changes.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The name of the organization or individual that published the capability statement.
    property publisher : String read GetPublisherST write SetPublisherST;
    // The name of the organization or individual that published the capability statement.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Contact details to assist a user in finding and communicating with the publisher.
    property contactList : TFhirContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to A free text natural language description of the capability statement from a consumer's perspective. Typically, this is used when the capability statement describes a desired rather than an actual solution, for example as a formal expression of requirements as part of an RFP.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A free text natural language description of the capability statement from a consumer's perspective. Typically, this is used when the capability statement describes a desired rather than an actual solution, for example as a formal expression of requirements as part of an RFP.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // The content was developed with a focus and intent of supporting the contexts that are listed. These contexts may be general categories (gender, age, ...) or may be references to specific programs (insurance plans, studies, ...) and may be used to assist with indexing and searching for appropriate capability statement instances.
    property useContextList : TFhirUsageContextList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // A legal or geographic region in which the capability statement is intended to be used.
    property jurisdictionList : TFhirCodeableConceptList read GetJurisdictionList;
    property hasJurisdictionList : boolean read GetHasJurisdictionList;

    // Typed access to Explanation of why this capability statement is needed and why it has been designed as it has.
    property purpose : String read GetPurposeST write SetPurposeST;
    // Explanation of why this capability statement is needed and why it has been designed as it has.
    property purposeElement : TFhirMarkdown read FPurpose write SetPurpose;

    // Typed access to A copyright statement relating to the capability statement and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the capability statement.
    property copyright : String read GetCopyrightST write SetCopyrightST;
    // A copyright statement relating to the capability statement and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the capability statement.
    property copyrightElement : TFhirMarkdown read FCopyright write SetCopyright;

    // The way that this statement is intended to be used, to describe an actual running instance of software, a particular product (kind, not instance of software) or a class of implementation (e.g. a desired purchase).
    property kind : TFhirCapabilityStatementKindEnum read GetKindST write SetKindST;
    property kindElement : TFhirEnum read FKind write SetKind;

    // Reference to a canonical URL of another CapabilityStatement that this software implements. This capability statement is a published API description that corresponds to a business service. The server may actually implement a subset of the capability statement it claims to implement, so the capability statement must specify the full capability details.
    property instantiatesList : TFhirCanonicalList read GetInstantiatesList;
    property hasInstantiatesList : boolean read GetHasInstantiatesList;

    // Reference to a canonical URL of another CapabilityStatement that this software adds to. The capability statement automatically includes everything in the other statement, and it is not duplicated, though the server may repeat the same resources, interactions and operations to add additional details to them.
    property importsList : TFhirCanonicalList read GetImportsList;
    property hasImportsList : boolean read GetHasImportsList;

    // Typed access to Software that is covered by this capability statement.  It is used when the capability statement describes the capabilities of a particular software version, independent of an installation. (defined for API consistency)
    property software : TFhirCapabilityStatementSoftware read FSoftware write SetSoftware;
    // Software that is covered by this capability statement.  It is used when the capability statement describes the capabilities of a particular software version, independent of an installation.
    property softwareElement : TFhirCapabilityStatementSoftware read FSoftware write SetSoftware;

    // Typed access to Identifies a specific implementation instance that is described by the capability statement - i.e. a particular installation, rather than the capabilities of a software program. (defined for API consistency)
    property implementation_ : TFhirCapabilityStatementImplementation read FImplementation_ write SetImplementation_;
    // Identifies a specific implementation instance that is described by the capability statement - i.e. a particular installation, rather than the capabilities of a software program.
    property implementation_Element : TFhirCapabilityStatementImplementation read FImplementation_ write SetImplementation_;

    // The version of the FHIR specification that this CapabilityStatement describes (which SHALL be the same as the FHIR version of the CapabilityStatement itself). There is no default value.
    property fhirVersion : TFhirFHIRVersionEnum read GetFhirVersionST write SetFhirVersionST;
    property fhirVersionElement : TFhirEnum read FFhirVersion write SetFhirVersion;

    // A list of the formats supported by this implementation using their content types.
    property formatList : TFhirCodeList read GetFormatList;
    property hasFormatList : boolean read GetHasFormatList;

    // A list of the patch formats supported by this implementation using their content types.
    property patchFormatList : TFhirCodeList read GetPatchFormatList;
    property hasPatchFormatList : boolean read GetHasPatchFormatList;

    // A list of implementation guides that the server does (or should) support in their entirety.
    property implementationGuideList : TFhirCanonicalList read GetImplementationGuideList;
    property hasImplementationGuideList : boolean read GetHasImplementationGuideList;

    // A definition of the restful capabilities of the solution, if any.
    property restList : TFhirCapabilityStatementRestList read GetRestList;
    property hasRestList : boolean read GetHasRestList;

    // A description of the messaging capabilities of the solution.
    property messagingList : TFhirCapabilityStatementMessagingList read GetMessagingList;
    property hasMessagingList : boolean read GetHasMessagingList;

    // A document definition.
    property documentList : TFhirCapabilityStatementDocumentList read GetDocumentList;
    property hasDocumentList : boolean read GetHasDocumentList;

  end;

  TFhirCapabilityStatementListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCapabilityStatementList;
    function GetCurrent : TFhirCapabilityStatement;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCapabilityStatementList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCapabilityStatement read GetCurrent;
  end;

  TFhirCapabilityStatementList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCapabilityStatement;
    procedure SetItemN(index : Integer; value : TFhirCapabilityStatement);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCapabilityStatementList; overload;
    function Clone : TFhirCapabilityStatementList; overload;
    function GetEnumerator : TFhirCapabilityStatementListEnumerator;
    
    //  Add a FhirCapabilityStatement to the end of the list.
    function Append : TFhirCapabilityStatement;
    
    // Add an already existing FhirCapabilityStatement to the end of the list.
    function AddItem(value : TFhirCapabilityStatement) : TFhirCapabilityStatement; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCapabilityStatement) : Integer;
    
    // Insert FhirCapabilityStatement before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCapabilityStatement;
    
    // Insert an existing FhirCapabilityStatement before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCapabilityStatement);
    
    // Get the iIndexth FhirCapabilityStatement. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCapabilityStatement);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCapabilityStatement;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCapabilityStatements[index : Integer] : TFhirCapabilityStatement read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_CAPABILITYSTATEMENT}
{$IFDEF FHIR_CODESYSTEM}
  // A filter that can be used in a value set compose statement when selecting concepts using a filter.
  TFhirCodeSystemFilter = class (TFhirBackboneElement)
  protected
    FCode : TFhirCode;
    FDescription : TFhirString;
    FOperator : TFhirEnumList;
    FValue : TFhirString;
    procedure SetCode(value : TFhirCode);
    function GetCodeST : String;
    procedure SetCodeST(value : String);
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetOperator : TFhirEnumList;
    function GetHasOperator : Boolean;
    function GetOperatorST : TFhirFilterOperatorEnumList;
    procedure SetOperatorST(value : TFhirFilterOperatorEnumList);
    procedure SetValue(value : TFhirString);
    function GetValueST : String;
    procedure SetValueST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCodeSystemFilter; overload;
    function Clone : TFhirCodeSystemFilter; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The code that identifies this filter when it is used as a filter in [ValueSet](valueset.html#).compose.include.filter.
    property code : String read GetCodeST write SetCodeST;
    // The code that identifies this filter when it is used as a filter in [ValueSet](valueset.html#).compose.include.filter.
    property codeElement : TFhirCode read FCode write SetCode;

    // Typed access to A description of how or why the filter is used.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A description of how or why the filter is used.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // A list of operators that can be used with the filter.
    property operator : TFhirFilterOperatorEnumList read GetOperatorST write SetOperatorST;
    property operatorList : TFhirEnumList read GetOperator;
    property hasOperator : boolean read GetHasOperator;
    // Typed access to A description of what the value for the filter should be.
    property value : String read GetValueST write SetValueST;
    // A description of what the value for the filter should be.
    property valueElement : TFhirString read FValue write SetValue;

  end;

  TFhirCodeSystemFilterListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCodeSystemFilterList;
    function GetCurrent : TFhirCodeSystemFilter;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCodeSystemFilterList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCodeSystemFilter read GetCurrent;
  end;

  TFhirCodeSystemFilterList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCodeSystemFilter;
    procedure SetItemN(index : Integer; value : TFhirCodeSystemFilter);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCodeSystemFilterList; overload;
    function Clone : TFhirCodeSystemFilterList; overload;
    function GetEnumerator : TFhirCodeSystemFilterListEnumerator;
    
    //  Add a FhirCodeSystemFilter to the end of the list.
    function Append : TFhirCodeSystemFilter;
    
    // Add an already existing FhirCodeSystemFilter to the end of the list.
    function AddItem(value : TFhirCodeSystemFilter) : TFhirCodeSystemFilter; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCodeSystemFilter) : Integer;
    
    // Insert FhirCodeSystemFilter before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCodeSystemFilter;
    
    // Insert an existing FhirCodeSystemFilter before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCodeSystemFilter);
    
    // Get the iIndexth FhirCodeSystemFilter. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCodeSystemFilter);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCodeSystemFilter;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCodeSystemFilters[index : Integer] : TFhirCodeSystemFilter read GetItemN write SetItemN; default;
  End;

  // A property defines an additional slot through which additional information can be provided about a concept.
  TFhirCodeSystemProperty = class (TFhirBackboneElement)
  protected
    FCode : TFhirCode;
    FUri : TFhirUri;
    FDescription : TFhirString;
    FType_ : TFhirEnum;
    procedure SetCode(value : TFhirCode);
    function GetCodeST : String;
    procedure SetCodeST(value : String);
    procedure SetUri(value : TFhirUri);
    function GetUriST : String;
    procedure SetUriST(value : String);
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetType_(value : TFhirEnum);
    function GetType_ST : TFhirConceptPropertyTypeEnum;
    procedure SetType_ST(value : TFhirConceptPropertyTypeEnum);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCodeSystemProperty; overload;
    function Clone : TFhirCodeSystemProperty; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A code that is used to identify the property. The code is used internally (in CodeSystem.concept.property.code) and also externally, such as in property filters.
    property code : String read GetCodeST write SetCodeST;
    // A code that is used to identify the property. The code is used internally (in CodeSystem.concept.property.code) and also externally, such as in property filters.
    property codeElement : TFhirCode read FCode write SetCode;

    // Typed access to Reference to the formal meaning of the property. One possible source of meaning is the [Concept Properties](codesystem-concept-properties.html) code system.
    property uri : String read GetUriST write SetUriST;
    // Reference to the formal meaning of the property. One possible source of meaning is the [Concept Properties](codesystem-concept-properties.html) code system.
    property uriElement : TFhirUri read FUri write SetUri;

    // Typed access to A description of the property- why it is defined, and how its value might be used.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A description of the property- why it is defined, and how its value might be used.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // The type of the property value. Properties of type "code" contain a code defined by the code system (e.g. a reference to another defined concept).
    property type_ : TFhirConceptPropertyTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

  end;

  TFhirCodeSystemPropertyListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCodeSystemPropertyList;
    function GetCurrent : TFhirCodeSystemProperty;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCodeSystemPropertyList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCodeSystemProperty read GetCurrent;
  end;

  TFhirCodeSystemPropertyList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCodeSystemProperty;
    procedure SetItemN(index : Integer; value : TFhirCodeSystemProperty);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCodeSystemPropertyList; overload;
    function Clone : TFhirCodeSystemPropertyList; overload;
    function GetEnumerator : TFhirCodeSystemPropertyListEnumerator;
    
    //  Add a FhirCodeSystemProperty to the end of the list.
    function Append : TFhirCodeSystemProperty;
    
    // Add an already existing FhirCodeSystemProperty to the end of the list.
    function AddItem(value : TFhirCodeSystemProperty) : TFhirCodeSystemProperty; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCodeSystemProperty) : Integer;
    
    // Insert FhirCodeSystemProperty before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCodeSystemProperty;
    
    // Insert an existing FhirCodeSystemProperty before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCodeSystemProperty);
    
    // Get the iIndexth FhirCodeSystemProperty. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCodeSystemProperty);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCodeSystemProperty;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCodeSystemProperties[index : Integer] : TFhirCodeSystemProperty read GetItemN write SetItemN; default;
  End;

  // Concepts that are in the code system. The concept definitions are inherently hierarchical, but the definitions must be consulted to determine what the meanings of the hierarchical relationships are.
  TFhirCodeSystemConcept = class (TFhirBackboneElement)
  protected
    FCode : TFhirCode;
    FDisplay : TFhirString;
    FDefinition : TFhirString;
    FdesignationList : TFhirCodeSystemConceptDesignationList;
    Fproperty_List : TFhirCodeSystemConceptPropertyList;
    FconceptList : TFhirCodeSystemConceptList;
    procedure SetCode(value : TFhirCode);
    function GetCodeST : String;
    procedure SetCodeST(value : String);
    procedure SetDisplay(value : TFhirString);
    function GetDisplayST : String;
    procedure SetDisplayST(value : String);
    procedure SetDefinition(value : TFhirString);
    function GetDefinitionST : String;
    procedure SetDefinitionST(value : String);
    function GetDesignationList : TFhirCodeSystemConceptDesignationList;
    function GetHasDesignationList : Boolean;
    function GetProperty_List : TFhirCodeSystemConceptPropertyList;
    function GetHasProperty_List : Boolean;
    function GetConceptList : TFhirCodeSystemConceptList;
    function GetHasConceptList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCodeSystemConcept; overload;
    function Clone : TFhirCodeSystemConcept; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A code - a text symbol - that uniquely identifies the concept within the code system.
    property code : String read GetCodeST write SetCodeST;
    // A code - a text symbol - that uniquely identifies the concept within the code system.
    property codeElement : TFhirCode read FCode write SetCode;

    // Typed access to A human readable string that is the recommended default way to present this concept to a user.
    property display : String read GetDisplayST write SetDisplayST;
    // A human readable string that is the recommended default way to present this concept to a user.
    property displayElement : TFhirString read FDisplay write SetDisplay;

    // Typed access to The formal definition of the concept. The code system resource does not make formal definitions required, because of the prevalence of legacy systems. However, they are highly recommended, as without them there is no formal meaning associated with the concept.
    property definition : String read GetDefinitionST write SetDefinitionST;
    // The formal definition of the concept. The code system resource does not make formal definitions required, because of the prevalence of legacy systems. However, they are highly recommended, as without them there is no formal meaning associated with the concept.
    property definitionElement : TFhirString read FDefinition write SetDefinition;

    // Additional representations for the concept - other languages, aliases, specialized purposes, used for particular purposes, etc.
    property designationList : TFhirCodeSystemConceptDesignationList read GetDesignationList;
    property hasDesignationList : boolean read GetHasDesignationList;

    // A property value for this concept.
    property property_List : TFhirCodeSystemConceptPropertyList read GetProperty_List;
    property hasProperty_List : boolean read GetHasProperty_List;

    // Defines children of a concept to produce a hierarchy of concepts. The nature of the relationships is variable (is-a/contains/categorizes) - see hierarchyMeaning.
    property conceptList : TFhirCodeSystemConceptList read GetConceptList;
    property hasConceptList : boolean read GetHasConceptList;

  end;

  TFhirCodeSystemConceptListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCodeSystemConceptList;
    function GetCurrent : TFhirCodeSystemConcept;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCodeSystemConceptList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCodeSystemConcept read GetCurrent;
  end;

  TFhirCodeSystemConceptList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCodeSystemConcept;
    procedure SetItemN(index : Integer; value : TFhirCodeSystemConcept);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCodeSystemConceptList; overload;
    function Clone : TFhirCodeSystemConceptList; overload;
    function GetEnumerator : TFhirCodeSystemConceptListEnumerator;
    
    //  Add a FhirCodeSystemConcept to the end of the list.
    function Append : TFhirCodeSystemConcept;
    
    // Add an already existing FhirCodeSystemConcept to the end of the list.
    function AddItem(value : TFhirCodeSystemConcept) : TFhirCodeSystemConcept; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCodeSystemConcept) : Integer;
    
    // Insert FhirCodeSystemConcept before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCodeSystemConcept;
    
    // Insert an existing FhirCodeSystemConcept before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCodeSystemConcept);
    
    // Get the iIndexth FhirCodeSystemConcept. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCodeSystemConcept);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCodeSystemConcept;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCodeSystemConcepts[index : Integer] : TFhirCodeSystemConcept read GetItemN write SetItemN; default;
  End;

  // Additional representations for the concept - other languages, aliases, specialized purposes, used for particular purposes, etc.
  TFhirCodeSystemConceptDesignation = class (TFhirBackboneElement)
  protected
    FLanguage : TFhirCode;
    FUse : TFhirCoding;
    FValue : TFhirString;
    procedure SetLanguage(value : TFhirCode);
    function GetLanguageST : String;
    procedure SetLanguageST(value : String);
    procedure SetUse(value : TFhirCoding);
    procedure SetValue(value : TFhirString);
    function GetValueST : String;
    procedure SetValueST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCodeSystemConceptDesignation; overload;
    function Clone : TFhirCodeSystemConceptDesignation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The language this designation is defined for.
    property language : String read GetLanguageST write SetLanguageST;
    // The language this designation is defined for.
    property languageElement : TFhirCode read FLanguage write SetLanguage;

    // Typed access to A code that details how this designation would be used. (defined for API consistency)
    property use : TFhirCoding read FUse write SetUse;
    // A code that details how this designation would be used.
    property useElement : TFhirCoding read FUse write SetUse;

    // Typed access to The text value for this designation.
    property value : String read GetValueST write SetValueST;
    // The text value for this designation.
    property valueElement : TFhirString read FValue write SetValue;

  end;

  TFhirCodeSystemConceptDesignationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCodeSystemConceptDesignationList;
    function GetCurrent : TFhirCodeSystemConceptDesignation;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCodeSystemConceptDesignationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCodeSystemConceptDesignation read GetCurrent;
  end;

  TFhirCodeSystemConceptDesignationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCodeSystemConceptDesignation;
    procedure SetItemN(index : Integer; value : TFhirCodeSystemConceptDesignation);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCodeSystemConceptDesignationList; overload;
    function Clone : TFhirCodeSystemConceptDesignationList; overload;
    function GetEnumerator : TFhirCodeSystemConceptDesignationListEnumerator;
    
    //  Add a FhirCodeSystemConceptDesignation to the end of the list.
    function Append : TFhirCodeSystemConceptDesignation;
    
    // Add an already existing FhirCodeSystemConceptDesignation to the end of the list.
    function AddItem(value : TFhirCodeSystemConceptDesignation) : TFhirCodeSystemConceptDesignation; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCodeSystemConceptDesignation) : Integer;
    
    // Insert FhirCodeSystemConceptDesignation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCodeSystemConceptDesignation;
    
    // Insert an existing FhirCodeSystemConceptDesignation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCodeSystemConceptDesignation);
    
    // Get the iIndexth FhirCodeSystemConceptDesignation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCodeSystemConceptDesignation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCodeSystemConceptDesignation;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCodeSystemConceptDesignations[index : Integer] : TFhirCodeSystemConceptDesignation read GetItemN write SetItemN; default;
  End;

  // A property value for this concept.
  TFhirCodeSystemConceptProperty = class (TFhirBackboneElement)
  protected
    FCode : TFhirCode;
    FValue : TFhirDataType;
    procedure SetCode(value : TFhirCode);
    function GetCodeST : String;
    procedure SetCodeST(value : String);
    procedure SetValue(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCodeSystemConceptProperty; overload;
    function Clone : TFhirCodeSystemConceptProperty; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A code that is a reference to CodeSystem.property.code.
    property code : String read GetCodeST write SetCodeST;
    // A code that is a reference to CodeSystem.property.code.
    property codeElement : TFhirCode read FCode write SetCode;

    // Typed access to The value of this property. (defined for API consistency)
    property value : TFhirDataType read FValue write SetValue;
    // The value of this property.
    property valueElement : TFhirDataType read FValue write SetValue;

  end;

  TFhirCodeSystemConceptPropertyListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCodeSystemConceptPropertyList;
    function GetCurrent : TFhirCodeSystemConceptProperty;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCodeSystemConceptPropertyList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCodeSystemConceptProperty read GetCurrent;
  end;

  TFhirCodeSystemConceptPropertyList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCodeSystemConceptProperty;
    procedure SetItemN(index : Integer; value : TFhirCodeSystemConceptProperty);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCodeSystemConceptPropertyList; overload;
    function Clone : TFhirCodeSystemConceptPropertyList; overload;
    function GetEnumerator : TFhirCodeSystemConceptPropertyListEnumerator;
    
    //  Add a FhirCodeSystemConceptProperty to the end of the list.
    function Append : TFhirCodeSystemConceptProperty;
    
    // Add an already existing FhirCodeSystemConceptProperty to the end of the list.
    function AddItem(value : TFhirCodeSystemConceptProperty) : TFhirCodeSystemConceptProperty; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCodeSystemConceptProperty) : Integer;
    
    // Insert FhirCodeSystemConceptProperty before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCodeSystemConceptProperty;
    
    // Insert an existing FhirCodeSystemConceptProperty before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCodeSystemConceptProperty);
    
    // Get the iIndexth FhirCodeSystemConceptProperty. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCodeSystemConceptProperty);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCodeSystemConceptProperty;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCodeSystemConceptProperties[index : Integer] : TFhirCodeSystemConceptProperty read GetItemN write SetItemN; default;
  End;

  // The CodeSystem resource is used to declare the existence of and describe a code system or code system supplement and its key properties, and optionally define a part or all of its content.
  TFhirCodeSystem = class (TFhirDomainResource)
  protected
    FUrl : TFhirUri;
    FidentifierList : TFhirIdentifierList;
    FVersion : TFhirString;
    FName : TFhirString;
    FTitle : TFhirString;
    FStatus : TFhirEnum;
    FExperimental : TFhirBoolean;
    FDate : TFhirDateTime;
    FPublisher : TFhirString;
    FcontactList : TFhirContactDetailList;
    FDescription : TFhirMarkdown;
    FuseContextList : TFhirUsageContextList;
    FjurisdictionList : TFhirCodeableConceptList;
    FPurpose : TFhirMarkdown;
    FCopyright : TFhirMarkdown;
    FCaseSensitive : TFhirBoolean;
    FValueSet : TFhirCanonical;
    FHierarchyMeaning : TFhirEnum;
    FCompositional : TFhirBoolean;
    FVersionNeeded : TFhirBoolean;
    FContent : TFhirEnum;
    FSupplements : TFhirCanonical;
    FCount : TFhirUnsignedInt;
    FfilterList : TFhirCodeSystemFilterList;
    Fproperty_List : TFhirCodeSystemPropertyList;
    FconceptList : TFhirCodeSystemConceptList;
    procedure SetUrl(value : TFhirUri);
    function GetUrlST : String;
    procedure SetUrlST(value : String);
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetVersion(value : TFhirString);
    function GetVersionST : String;
    procedure SetVersionST(value : String);
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetTitle(value : TFhirString);
    function GetTitleST : String;
    procedure SetTitleST(value : String);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirPublicationStatusEnum;
    procedure SetStatusST(value : TFhirPublicationStatusEnum);
    procedure SetExperimental(value : TFhirBoolean);
    function GetExperimentalST : Boolean;
    procedure SetExperimentalST(value : Boolean);
    procedure SetDate(value : TFhirDateTime);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    procedure SetPublisher(value : TFhirString);
    function GetPublisherST : String;
    procedure SetPublisherST(value : String);
    function GetContactList : TFhirContactDetailList;
    function GetHasContactList : Boolean;
    procedure SetDescription(value : TFhirMarkdown);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetUseContextList : TFhirUsageContextList;
    function GetHasUseContextList : Boolean;
    function GetJurisdictionList : TFhirCodeableConceptList;
    function GetHasJurisdictionList : Boolean;
    procedure SetPurpose(value : TFhirMarkdown);
    function GetPurposeST : String;
    procedure SetPurposeST(value : String);
    procedure SetCopyright(value : TFhirMarkdown);
    function GetCopyrightST : String;
    procedure SetCopyrightST(value : String);
    procedure SetCaseSensitive(value : TFhirBoolean);
    function GetCaseSensitiveST : Boolean;
    procedure SetCaseSensitiveST(value : Boolean);
    procedure SetValueSet(value : TFhirCanonical);
    function GetValueSetST : String;
    procedure SetValueSetST(value : String);
    procedure SetHierarchyMeaning(value : TFhirEnum);
    function GetHierarchyMeaningST : TFhirCodeSystemHierarchyMeaningEnum;
    procedure SetHierarchyMeaningST(value : TFhirCodeSystemHierarchyMeaningEnum);
    procedure SetCompositional(value : TFhirBoolean);
    function GetCompositionalST : Boolean;
    procedure SetCompositionalST(value : Boolean);
    procedure SetVersionNeeded(value : TFhirBoolean);
    function GetVersionNeededST : Boolean;
    procedure SetVersionNeededST(value : Boolean);
    procedure SetContent(value : TFhirEnum);
    function GetContentST : TFhirCodeSystemContentModeEnum;
    procedure SetContentST(value : TFhirCodeSystemContentModeEnum);
    procedure SetSupplements(value : TFhirCanonical);
    function GetSupplementsST : String;
    procedure SetSupplementsST(value : String);
    procedure SetCount(value : TFhirUnsignedInt);
    function GetCountST : String;
    procedure SetCountST(value : String);
    function GetFilterList : TFhirCodeSystemFilterList;
    function GetHasFilterList : Boolean;
    function GetProperty_List : TFhirCodeSystemPropertyList;
    function GetHasProperty_List : Boolean;
    function GetConceptList : TFhirCodeSystemConceptList;
    function GetHasConceptList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCodeSystem; overload;
    function Clone : TFhirCodeSystem; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An absolute URI that is used to identify this code system when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this code system is (or will be) published. This URL can be the target of a canonical reference. It SHALL remain the same when the code system is stored on different servers. This is used in [Coding](datatypes.html#Coding).system.
    property url : String read GetUrlST write SetUrlST;
    // An absolute URI that is used to identify this code system when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this code system is (or will be) published. This URL can be the target of a canonical reference. It SHALL remain the same when the code system is stored on different servers. This is used in [Coding](datatypes.html#Coding).system.
    property urlElement : TFhirUri read FUrl write SetUrl;

    // A formal identifier that is used to identify this code system when it is represented in other formats, or referenced in a specification, model, design or an instance.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The identifier that is used to identify this version of the code system when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the code system author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence. This is used in [Coding](datatypes.html#Coding).version.
    property version : String read GetVersionST write SetVersionST;
    // The identifier that is used to identify this version of the code system when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the code system author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence. This is used in [Coding](datatypes.html#Coding).version.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to A natural language name identifying the code system. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property name : String read GetNameST write SetNameST;
    // A natural language name identifying the code system. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A short, descriptive, user-friendly title for the code system.
    property title : String read GetTitleST write SetTitleST;
    // A short, descriptive, user-friendly title for the code system.
    property titleElement : TFhirString read FTitle write SetTitle;

    // The date (and optionally time) when the code system resource was created or revised.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A Boolean value to indicate that this code system is authored for testing purposes (or education/evaluation/marketing) and is not intended to be used for genuine usage.
    property experimental : Boolean read GetExperimentalST write SetExperimentalST;
    // A Boolean value to indicate that this code system is authored for testing purposes (or education/evaluation/marketing) and is not intended to be used for genuine usage.
    property experimentalElement : TFhirBoolean read FExperimental write SetExperimental;

    // Typed access to The date  (and optionally time) when the code system was published. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the code system changes.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date  (and optionally time) when the code system was published. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the code system changes.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The name of the organization or individual that published the code system.
    property publisher : String read GetPublisherST write SetPublisherST;
    // The name of the organization or individual that published the code system.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Contact details to assist a user in finding and communicating with the publisher.
    property contactList : TFhirContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to A free text natural language description of the code system from a consumer's perspective.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A free text natural language description of the code system from a consumer's perspective.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // The content was developed with a focus and intent of supporting the contexts that are listed. These contexts may be general categories (gender, age, ...) or may be references to specific programs (insurance plans, studies, ...) and may be used to assist with indexing and searching for appropriate code system instances.
    property useContextList : TFhirUsageContextList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // A legal or geographic region in which the code system is intended to be used.
    property jurisdictionList : TFhirCodeableConceptList read GetJurisdictionList;
    property hasJurisdictionList : boolean read GetHasJurisdictionList;

    // Typed access to Explanation of why this code system is needed and why it has been designed as it has.
    property purpose : String read GetPurposeST write SetPurposeST;
    // Explanation of why this code system is needed and why it has been designed as it has.
    property purposeElement : TFhirMarkdown read FPurpose write SetPurpose;

    // Typed access to A copyright statement relating to the code system and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the code system.
    property copyright : String read GetCopyrightST write SetCopyrightST;
    // A copyright statement relating to the code system and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the code system.
    property copyrightElement : TFhirMarkdown read FCopyright write SetCopyright;

    // Typed access to If code comparison is case sensitive when codes within this system are compared to each other.
    property caseSensitive : Boolean read GetCaseSensitiveST write SetCaseSensitiveST;
    // If code comparison is case sensitive when codes within this system are compared to each other.
    property caseSensitiveElement : TFhirBoolean read FCaseSensitive write SetCaseSensitive;

    // Typed access to Canonical reference to the value set that contains the entire code system.
    property valueSet : String read GetValueSetST write SetValueSetST;
    // Canonical reference to the value set that contains the entire code system.
    property valueSetElement : TFhirCanonical read FValueSet write SetValueSet;

    // The meaning of the hierarchy of concepts as represented in this resource.
    property hierarchyMeaning : TFhirCodeSystemHierarchyMeaningEnum read GetHierarchyMeaningST write SetHierarchyMeaningST;
    property hierarchyMeaningElement : TFhirEnum read FHierarchyMeaning write SetHierarchyMeaning;

    // Typed access to The code system defines a compositional (post-coordination) grammar.
    property compositional : Boolean read GetCompositionalST write SetCompositionalST;
    // The code system defines a compositional (post-coordination) grammar.
    property compositionalElement : TFhirBoolean read FCompositional write SetCompositional;

    // Typed access to This flag is used to signify that the code system does not commit to concept permanence across versions. If true, a version must be specified when referencing this code system.
    property versionNeeded : Boolean read GetVersionNeededST write SetVersionNeededST;
    // This flag is used to signify that the code system does not commit to concept permanence across versions. If true, a version must be specified when referencing this code system.
    property versionNeededElement : TFhirBoolean read FVersionNeeded write SetVersionNeeded;

    // The extent of the content of the code system (the concepts and codes it defines) are represented in this resource instance.
    property content : TFhirCodeSystemContentModeEnum read GetContentST write SetContentST;
    property contentElement : TFhirEnum read FContent write SetContent;

    // Typed access to The canonical URL of the code system that this code system supplement is adding designations and properties to.
    property supplements : String read GetSupplementsST write SetSupplementsST;
    // The canonical URL of the code system that this code system supplement is adding designations and properties to.
    property supplementsElement : TFhirCanonical read FSupplements write SetSupplements;

    // Typed access to The total number of concepts defined by the code system. Where the code system has a compositional grammar, the basis of this count is defined by the system steward.
    property count : String read GetCountST write SetCountST;
    // The total number of concepts defined by the code system. Where the code system has a compositional grammar, the basis of this count is defined by the system steward.
    property countElement : TFhirUnsignedInt read FCount write SetCount;

    // A filter that can be used in a value set compose statement when selecting concepts using a filter.
    property filterList : TFhirCodeSystemFilterList read GetFilterList;
    property hasFilterList : boolean read GetHasFilterList;

    // A property defines an additional slot through which additional information can be provided about a concept.
    property property_List : TFhirCodeSystemPropertyList read GetProperty_List;
    property hasProperty_List : boolean read GetHasProperty_List;

    // Concepts that are in the code system. The concept definitions are inherently hierarchical, but the definitions must be consulted to determine what the meanings of the hierarchical relationships are.
    property conceptList : TFhirCodeSystemConceptList read GetConceptList;
    property hasConceptList : boolean read GetHasConceptList;

  end;

  TFhirCodeSystemListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCodeSystemList;
    function GetCurrent : TFhirCodeSystem;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCodeSystemList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCodeSystem read GetCurrent;
  end;

  TFhirCodeSystemList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCodeSystem;
    procedure SetItemN(index : Integer; value : TFhirCodeSystem);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCodeSystemList; overload;
    function Clone : TFhirCodeSystemList; overload;
    function GetEnumerator : TFhirCodeSystemListEnumerator;
    
    //  Add a FhirCodeSystem to the end of the list.
    function Append : TFhirCodeSystem;
    
    // Add an already existing FhirCodeSystem to the end of the list.
    function AddItem(value : TFhirCodeSystem) : TFhirCodeSystem; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCodeSystem) : Integer;
    
    // Insert FhirCodeSystem before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCodeSystem;
    
    // Insert an existing FhirCodeSystem before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCodeSystem);
    
    // Get the iIndexth FhirCodeSystem. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCodeSystem);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCodeSystem;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCodeSystems[index : Integer] : TFhirCodeSystem read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_CODESYSTEM}
{$IFDEF FHIR_COMPARTMENTDEFINITION}
  // Information about how a resource is related to the compartment.
  TFhirCompartmentDefinitionResource = class (TFhirBackboneElement)
  protected
    FCode : TFhirEnum;
    FparamList : TFhirStringList;
    FDocumentation : TFhirString;
    procedure SetCode(value : TFhirEnum);
    function GetCodeST : TFhirResourceTypesEnum;
    procedure SetCodeST(value : TFhirResourceTypesEnum);
    function GetParamList : TFhirStringList;
    function GetHasParamList : Boolean;
    procedure SetDocumentation(value : TFhirString);
    function GetDocumentationST : String;
    procedure SetDocumentationST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCompartmentDefinitionResource; overload;
    function Clone : TFhirCompartmentDefinitionResource; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The name of a resource supported by the server.
    property code : TFhirResourceTypesEnum read GetCodeST write SetCodeST;
    property codeElement : TFhirEnum read FCode write SetCode;

    // The name of a search parameter that represents the link to the compartment. More than one may be listed because a resource may be linked to a compartment in more than one way,.
    property paramList : TFhirStringList read GetParamList;
    property hasParamList : boolean read GetHasParamList;

    // Typed access to Additional documentation about the resource and compartment.
    property documentation : String read GetDocumentationST write SetDocumentationST;
    // Additional documentation about the resource and compartment.
    property documentationElement : TFhirString read FDocumentation write SetDocumentation;

  end;

  TFhirCompartmentDefinitionResourceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCompartmentDefinitionResourceList;
    function GetCurrent : TFhirCompartmentDefinitionResource;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCompartmentDefinitionResourceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCompartmentDefinitionResource read GetCurrent;
  end;

  TFhirCompartmentDefinitionResourceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCompartmentDefinitionResource;
    procedure SetItemN(index : Integer; value : TFhirCompartmentDefinitionResource);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCompartmentDefinitionResourceList; overload;
    function Clone : TFhirCompartmentDefinitionResourceList; overload;
    function GetEnumerator : TFhirCompartmentDefinitionResourceListEnumerator;
    
    //  Add a FhirCompartmentDefinitionResource to the end of the list.
    function Append : TFhirCompartmentDefinitionResource;
    
    // Add an already existing FhirCompartmentDefinitionResource to the end of the list.
    function AddItem(value : TFhirCompartmentDefinitionResource) : TFhirCompartmentDefinitionResource; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCompartmentDefinitionResource) : Integer;
    
    // Insert FhirCompartmentDefinitionResource before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCompartmentDefinitionResource;
    
    // Insert an existing FhirCompartmentDefinitionResource before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCompartmentDefinitionResource);
    
    // Get the iIndexth FhirCompartmentDefinitionResource. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCompartmentDefinitionResource);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCompartmentDefinitionResource;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCompartmentDefinitionResources[index : Integer] : TFhirCompartmentDefinitionResource read GetItemN write SetItemN; default;
  End;

  // A compartment definition that defines how resources are accessed on a server.
  TFhirCompartmentDefinition = class (TFhirDomainResource)
  protected
    FUrl : TFhirUri;
    FVersion : TFhirString;
    FName : TFhirString;
    FStatus : TFhirEnum;
    FExperimental : TFhirBoolean;
    FDate : TFhirDateTime;
    FPublisher : TFhirString;
    FcontactList : TFhirContactDetailList;
    FDescription : TFhirMarkdown;
    FuseContextList : TFhirUsageContextList;
    FPurpose : TFhirMarkdown;
    FCode : TFhirEnum;
    FSearch : TFhirBoolean;
    FresourceList : TFhirCompartmentDefinitionResourceList;
    procedure SetUrl(value : TFhirUri);
    function GetUrlST : String;
    procedure SetUrlST(value : String);
    procedure SetVersion(value : TFhirString);
    function GetVersionST : String;
    procedure SetVersionST(value : String);
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirPublicationStatusEnum;
    procedure SetStatusST(value : TFhirPublicationStatusEnum);
    procedure SetExperimental(value : TFhirBoolean);
    function GetExperimentalST : Boolean;
    procedure SetExperimentalST(value : Boolean);
    procedure SetDate(value : TFhirDateTime);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    procedure SetPublisher(value : TFhirString);
    function GetPublisherST : String;
    procedure SetPublisherST(value : String);
    function GetContactList : TFhirContactDetailList;
    function GetHasContactList : Boolean;
    procedure SetDescription(value : TFhirMarkdown);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetUseContextList : TFhirUsageContextList;
    function GetHasUseContextList : Boolean;
    procedure SetPurpose(value : TFhirMarkdown);
    function GetPurposeST : String;
    procedure SetPurposeST(value : String);
    procedure SetCode(value : TFhirEnum);
    function GetCodeST : TFhirCompartmentTypeEnum;
    procedure SetCodeST(value : TFhirCompartmentTypeEnum);
    procedure SetSearch(value : TFhirBoolean);
    function GetSearchST : Boolean;
    procedure SetSearchST(value : Boolean);
    function GetResourceList : TFhirCompartmentDefinitionResourceList;
    function GetHasResourceList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCompartmentDefinition; overload;
    function Clone : TFhirCompartmentDefinition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An absolute URI that is used to identify this compartment definition when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this compartment definition is (or will be) published. This URL can be the target of a canonical reference. It SHALL remain the same when the compartment definition is stored on different servers.
    property url : String read GetUrlST write SetUrlST;
    // An absolute URI that is used to identify this compartment definition when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this compartment definition is (or will be) published. This URL can be the target of a canonical reference. It SHALL remain the same when the compartment definition is stored on different servers.
    property urlElement : TFhirUri read FUrl write SetUrl;

    // Typed access to The identifier that is used to identify this version of the compartment definition when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the compartment definition author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
    property version : String read GetVersionST write SetVersionST;
    // The identifier that is used to identify this version of the compartment definition when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the compartment definition author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to A natural language name identifying the compartment definition. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property name : String read GetNameST write SetNameST;
    // A natural language name identifying the compartment definition. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property nameElement : TFhirString read FName write SetName;

    // The status of this compartment definition. Enables tracking the life-cycle of the content.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A Boolean value to indicate that this compartment definition is authored for testing purposes (or education/evaluation/marketing) and is not intended to be used for genuine usage.
    property experimental : Boolean read GetExperimentalST write SetExperimentalST;
    // A Boolean value to indicate that this compartment definition is authored for testing purposes (or education/evaluation/marketing) and is not intended to be used for genuine usage.
    property experimentalElement : TFhirBoolean read FExperimental write SetExperimental;

    // Typed access to The date  (and optionally time) when the compartment definition was published. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the compartment definition changes.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date  (and optionally time) when the compartment definition was published. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the compartment definition changes.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The name of the organization or individual that published the compartment definition.
    property publisher : String read GetPublisherST write SetPublisherST;
    // The name of the organization or individual that published the compartment definition.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Contact details to assist a user in finding and communicating with the publisher.
    property contactList : TFhirContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to A free text natural language description of the compartment definition from a consumer's perspective.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A free text natural language description of the compartment definition from a consumer's perspective.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // The content was developed with a focus and intent of supporting the contexts that are listed. These contexts may be general categories (gender, age, ...) or may be references to specific programs (insurance plans, studies, ...) and may be used to assist with indexing and searching for appropriate compartment definition instances.
    property useContextList : TFhirUsageContextList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // Typed access to Explanation of why this compartment definition is needed and why it has been designed as it has.
    property purpose : String read GetPurposeST write SetPurposeST;
    // Explanation of why this compartment definition is needed and why it has been designed as it has.
    property purposeElement : TFhirMarkdown read FPurpose write SetPurpose;

    // Which compartment this definition describes.
    property code : TFhirCompartmentTypeEnum read GetCodeST write SetCodeST;
    property codeElement : TFhirEnum read FCode write SetCode;

    // Typed access to Whether the search syntax is supported,.
    property search : Boolean read GetSearchST write SetSearchST;
    // Whether the search syntax is supported,.
    property searchElement : TFhirBoolean read FSearch write SetSearch;

    // Information about how a resource is related to the compartment.
    property resourceList : TFhirCompartmentDefinitionResourceList read GetResourceList;
    property hasResourceList : boolean read GetHasResourceList;

  end;

  TFhirCompartmentDefinitionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCompartmentDefinitionList;
    function GetCurrent : TFhirCompartmentDefinition;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCompartmentDefinitionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCompartmentDefinition read GetCurrent;
  end;

  TFhirCompartmentDefinitionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCompartmentDefinition;
    procedure SetItemN(index : Integer; value : TFhirCompartmentDefinition);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCompartmentDefinitionList; overload;
    function Clone : TFhirCompartmentDefinitionList; overload;
    function GetEnumerator : TFhirCompartmentDefinitionListEnumerator;
    
    //  Add a FhirCompartmentDefinition to the end of the list.
    function Append : TFhirCompartmentDefinition;
    
    // Add an already existing FhirCompartmentDefinition to the end of the list.
    function AddItem(value : TFhirCompartmentDefinition) : TFhirCompartmentDefinition; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCompartmentDefinition) : Integer;
    
    // Insert FhirCompartmentDefinition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCompartmentDefinition;
    
    // Insert an existing FhirCompartmentDefinition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCompartmentDefinition);
    
    // Get the iIndexth FhirCompartmentDefinition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCompartmentDefinition);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCompartmentDefinition;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCompartmentDefinitions[index : Integer] : TFhirCompartmentDefinition read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_COMPARTMENTDEFINITION}
{$IFDEF FHIR_CONCEPTMAP}
  // A group of mappings that all have the same source and target system.
  TFhirConceptMapGroup = class (TFhirBackboneElement)
  protected
    FSource : TFhirUri;
    FSourceVersion : TFhirString;
    FTarget : TFhirUri;
    FTargetVersion : TFhirString;
    FelementList : TFhirConceptMapGroupElementList;
    FUnmapped : TFhirConceptMapGroupUnmapped;
    procedure SetSource(value : TFhirUri);
    function GetSourceST : String;
    procedure SetSourceST(value : String);
    procedure SetSourceVersion(value : TFhirString);
    function GetSourceVersionST : String;
    procedure SetSourceVersionST(value : String);
    procedure SetTarget(value : TFhirUri);
    function GetTargetST : String;
    procedure SetTargetST(value : String);
    procedure SetTargetVersion(value : TFhirString);
    function GetTargetVersionST : String;
    procedure SetTargetVersionST(value : String);
    function GetElementList : TFhirConceptMapGroupElementList;
    function GetHasElementList : Boolean;
    procedure SetUnmapped(value : TFhirConceptMapGroupUnmapped);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirConceptMapGroup; overload;
    function Clone : TFhirConceptMapGroup; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An absolute URI that identifies the source system where the concepts to be mapped are defined.
    property source : String read GetSourceST write SetSourceST;
    // An absolute URI that identifies the source system where the concepts to be mapped are defined.
    property sourceElement : TFhirUri read FSource write SetSource;

    // Typed access to The specific version of the code system, as determined by the code system authority.
    property sourceVersion : String read GetSourceVersionST write SetSourceVersionST;
    // The specific version of the code system, as determined by the code system authority.
    property sourceVersionElement : TFhirString read FSourceVersion write SetSourceVersion;

    // Typed access to An absolute URI that identifies the target system that the concepts will be mapped to.
    property target : String read GetTargetST write SetTargetST;
    // An absolute URI that identifies the target system that the concepts will be mapped to.
    property targetElement : TFhirUri read FTarget write SetTarget;

    // Typed access to The specific version of the code system, as determined by the code system authority.
    property targetVersion : String read GetTargetVersionST write SetTargetVersionST;
    // The specific version of the code system, as determined by the code system authority.
    property targetVersionElement : TFhirString read FTargetVersion write SetTargetVersion;

    // Mappings for an individual concept in the source to one or more concepts in the target.
    property elementList : TFhirConceptMapGroupElementList read GetElementList;
    property hasElementList : boolean read GetHasElementList;

    // Typed access to What to do when there is no mapping for the source concept. "Unmapped" does not include codes that are unmatched, and the unmapped element is ignored in a code is specified to have equivalence = unmatched. (defined for API consistency)
    property unmapped : TFhirConceptMapGroupUnmapped read FUnmapped write SetUnmapped;
    // What to do when there is no mapping for the source concept. "Unmapped" does not include codes that are unmatched, and the unmapped element is ignored in a code is specified to have equivalence = unmatched.
    property unmappedElement : TFhirConceptMapGroupUnmapped read FUnmapped write SetUnmapped;

  end;

  TFhirConceptMapGroupListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirConceptMapGroupList;
    function GetCurrent : TFhirConceptMapGroup;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirConceptMapGroupList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConceptMapGroup read GetCurrent;
  end;

  TFhirConceptMapGroupList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConceptMapGroup;
    procedure SetItemN(index : Integer; value : TFhirConceptMapGroup);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirConceptMapGroupList; overload;
    function Clone : TFhirConceptMapGroupList; overload;
    function GetEnumerator : TFhirConceptMapGroupListEnumerator;
    
    //  Add a FhirConceptMapGroup to the end of the list.
    function Append : TFhirConceptMapGroup;
    
    // Add an already existing FhirConceptMapGroup to the end of the list.
    function AddItem(value : TFhirConceptMapGroup) : TFhirConceptMapGroup; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirConceptMapGroup) : Integer;
    
    // Insert FhirConceptMapGroup before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirConceptMapGroup;
    
    // Insert an existing FhirConceptMapGroup before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirConceptMapGroup);
    
    // Get the iIndexth FhirConceptMapGroup. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirConceptMapGroup);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirConceptMapGroup;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirConceptMapGroups[index : Integer] : TFhirConceptMapGroup read GetItemN write SetItemN; default;
  End;

  // Mappings for an individual concept in the source to one or more concepts in the target.
  TFhirConceptMapGroupElement = class (TFhirBackboneElement)
  protected
    FCode : TFhirCode;
    FDisplay : TFhirString;
    FtargetList : TFhirConceptMapGroupElementTargetList;
    procedure SetCode(value : TFhirCode);
    function GetCodeST : String;
    procedure SetCodeST(value : String);
    procedure SetDisplay(value : TFhirString);
    function GetDisplayST : String;
    procedure SetDisplayST(value : String);
    function GetTargetList : TFhirConceptMapGroupElementTargetList;
    function GetHasTargetList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirConceptMapGroupElement; overload;
    function Clone : TFhirConceptMapGroupElement; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Identity (code or path) or the element/item being mapped.
    property code : String read GetCodeST write SetCodeST;
    // Identity (code or path) or the element/item being mapped.
    property codeElement : TFhirCode read FCode write SetCode;

    // Typed access to The display for the code. The display is only provided to help editors when editing the concept map.
    property display : String read GetDisplayST write SetDisplayST;
    // The display for the code. The display is only provided to help editors when editing the concept map.
    property displayElement : TFhirString read FDisplay write SetDisplay;

    // A concept from the target value set that this concept maps to.
    property targetList : TFhirConceptMapGroupElementTargetList read GetTargetList;
    property hasTargetList : boolean read GetHasTargetList;

  end;

  TFhirConceptMapGroupElementListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirConceptMapGroupElementList;
    function GetCurrent : TFhirConceptMapGroupElement;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirConceptMapGroupElementList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConceptMapGroupElement read GetCurrent;
  end;

  TFhirConceptMapGroupElementList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConceptMapGroupElement;
    procedure SetItemN(index : Integer; value : TFhirConceptMapGroupElement);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirConceptMapGroupElementList; overload;
    function Clone : TFhirConceptMapGroupElementList; overload;
    function GetEnumerator : TFhirConceptMapGroupElementListEnumerator;
    
    //  Add a FhirConceptMapGroupElement to the end of the list.
    function Append : TFhirConceptMapGroupElement;
    
    // Add an already existing FhirConceptMapGroupElement to the end of the list.
    function AddItem(value : TFhirConceptMapGroupElement) : TFhirConceptMapGroupElement; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirConceptMapGroupElement) : Integer;
    
    // Insert FhirConceptMapGroupElement before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirConceptMapGroupElement;
    
    // Insert an existing FhirConceptMapGroupElement before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirConceptMapGroupElement);
    
    // Get the iIndexth FhirConceptMapGroupElement. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirConceptMapGroupElement);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirConceptMapGroupElement;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirConceptMapGroupElements[index : Integer] : TFhirConceptMapGroupElement read GetItemN write SetItemN; default;
  End;

  // A concept from the target value set that this concept maps to.
  TFhirConceptMapGroupElementTarget = class (TFhirBackboneElement)
  protected
    FCode : TFhirCode;
    FDisplay : TFhirString;
    FEquivalence : TFhirEnum;
    FComment : TFhirString;
    FdependsOnList : TFhirConceptMapGroupElementTargetDependsOnList;
    FproductList : TFhirConceptMapGroupElementTargetDependsOnList;
    procedure SetCode(value : TFhirCode);
    function GetCodeST : String;
    procedure SetCodeST(value : String);
    procedure SetDisplay(value : TFhirString);
    function GetDisplayST : String;
    procedure SetDisplayST(value : String);
    procedure SetEquivalence(value : TFhirEnum);
    function GetEquivalenceST : TFhirConceptMapEquivalenceEnum;
    procedure SetEquivalenceST(value : TFhirConceptMapEquivalenceEnum);
    procedure SetComment(value : TFhirString);
    function GetCommentST : String;
    procedure SetCommentST(value : String);
    function GetDependsOnList : TFhirConceptMapGroupElementTargetDependsOnList;
    function GetHasDependsOnList : Boolean;
    function GetProductList : TFhirConceptMapGroupElementTargetDependsOnList;
    function GetHasProductList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirConceptMapGroupElementTarget; overload;
    function Clone : TFhirConceptMapGroupElementTarget; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Identity (code or path) or the element/item that the map refers to.
    property code : String read GetCodeST write SetCodeST;
    // Identity (code or path) or the element/item that the map refers to.
    property codeElement : TFhirCode read FCode write SetCode;

    // Typed access to The display for the code. The display is only provided to help editors when editing the concept map.
    property display : String read GetDisplayST write SetDisplayST;
    // The display for the code. The display is only provided to help editors when editing the concept map.
    property displayElement : TFhirString read FDisplay write SetDisplay;

    // The equivalence between the source and target concepts (counting for the dependencies and products). The equivalence is read from target to source (e.g. the target is 'wider' than the source).
    property equivalence : TFhirConceptMapEquivalenceEnum read GetEquivalenceST write SetEquivalenceST;
    property equivalenceElement : TFhirEnum read FEquivalence write SetEquivalence;

    // Typed access to A description of status/issues in mapping that conveys additional information not represented in  the structured data.
    property comment : String read GetCommentST write SetCommentST;
    // A description of status/issues in mapping that conveys additional information not represented in  the structured data.
    property commentElement : TFhirString read FComment write SetComment;

    // A set of additional dependencies for this mapping to hold. This mapping is only applicable if the specified element can be resolved, and it has the specified value.
    property dependsOnList : TFhirConceptMapGroupElementTargetDependsOnList read GetDependsOnList;
    property hasDependsOnList : boolean read GetHasDependsOnList;

    // A set of additional outcomes from this mapping to other elements. To properly execute this mapping, the specified element must be mapped to some data element or source that is in context. The mapping may still be useful without a place for the additional data elements, but the equivalence cannot be relied on.
    property productList : TFhirConceptMapGroupElementTargetDependsOnList read GetProductList;
    property hasProductList : boolean read GetHasProductList;

  end;

  TFhirConceptMapGroupElementTargetListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirConceptMapGroupElementTargetList;
    function GetCurrent : TFhirConceptMapGroupElementTarget;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirConceptMapGroupElementTargetList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConceptMapGroupElementTarget read GetCurrent;
  end;

  TFhirConceptMapGroupElementTargetList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConceptMapGroupElementTarget;
    procedure SetItemN(index : Integer; value : TFhirConceptMapGroupElementTarget);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirConceptMapGroupElementTargetList; overload;
    function Clone : TFhirConceptMapGroupElementTargetList; overload;
    function GetEnumerator : TFhirConceptMapGroupElementTargetListEnumerator;
    
    //  Add a FhirConceptMapGroupElementTarget to the end of the list.
    function Append : TFhirConceptMapGroupElementTarget;
    
    // Add an already existing FhirConceptMapGroupElementTarget to the end of the list.
    function AddItem(value : TFhirConceptMapGroupElementTarget) : TFhirConceptMapGroupElementTarget; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirConceptMapGroupElementTarget) : Integer;
    
    // Insert FhirConceptMapGroupElementTarget before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirConceptMapGroupElementTarget;
    
    // Insert an existing FhirConceptMapGroupElementTarget before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirConceptMapGroupElementTarget);
    
    // Get the iIndexth FhirConceptMapGroupElementTarget. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirConceptMapGroupElementTarget);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirConceptMapGroupElementTarget;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirConceptMapGroupElementTargets[index : Integer] : TFhirConceptMapGroupElementTarget read GetItemN write SetItemN; default;
  End;

  // A set of additional dependencies for this mapping to hold. This mapping is only applicable if the specified element can be resolved, and it has the specified value.
  TFhirConceptMapGroupElementTargetDependsOn = class (TFhirBackboneElement)
  protected
    FProperty_ : TFhirUri;
    FSystem : TFhirCanonical;
    FValue : TFhirString;
    FDisplay : TFhirString;
    procedure SetProperty_(value : TFhirUri);
    function GetProperty_ST : String;
    procedure SetProperty_ST(value : String);
    procedure SetSystem(value : TFhirCanonical);
    function GetSystemST : String;
    procedure SetSystemST(value : String);
    procedure SetValue(value : TFhirString);
    function GetValueST : String;
    procedure SetValueST(value : String);
    procedure SetDisplay(value : TFhirString);
    function GetDisplayST : String;
    procedure SetDisplayST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirConceptMapGroupElementTargetDependsOn; overload;
    function Clone : TFhirConceptMapGroupElementTargetDependsOn; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A reference to an element that holds a coded value that corresponds to a code system property. The idea is that the information model carries an element somewhere that is labeled to correspond with a code system property.
    property property_ : String read GetProperty_ST write SetProperty_ST;
    // A reference to an element that holds a coded value that corresponds to a code system property. The idea is that the information model carries an element somewhere that is labeled to correspond with a code system property.
    property property_Element : TFhirUri read FProperty_ write SetProperty_;

    // Typed access to An absolute URI that identifies the code system of the dependency code (if the source/dependency is a value set that crosses code systems).
    property system : String read GetSystemST write SetSystemST;
    // An absolute URI that identifies the code system of the dependency code (if the source/dependency is a value set that crosses code systems).
    property systemElement : TFhirCanonical read FSystem write SetSystem;

    // Typed access to Identity (code or path) or the element/item/ValueSet/text that the map depends on / refers to.
    property value : String read GetValueST write SetValueST;
    // Identity (code or path) or the element/item/ValueSet/text that the map depends on / refers to.
    property valueElement : TFhirString read FValue write SetValue;

    // Typed access to The display for the code. The display is only provided to help editors when editing the concept map.
    property display : String read GetDisplayST write SetDisplayST;
    // The display for the code. The display is only provided to help editors when editing the concept map.
    property displayElement : TFhirString read FDisplay write SetDisplay;

  end;

  TFhirConceptMapGroupElementTargetDependsOnListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirConceptMapGroupElementTargetDependsOnList;
    function GetCurrent : TFhirConceptMapGroupElementTargetDependsOn;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirConceptMapGroupElementTargetDependsOnList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConceptMapGroupElementTargetDependsOn read GetCurrent;
  end;

  TFhirConceptMapGroupElementTargetDependsOnList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConceptMapGroupElementTargetDependsOn;
    procedure SetItemN(index : Integer; value : TFhirConceptMapGroupElementTargetDependsOn);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirConceptMapGroupElementTargetDependsOnList; overload;
    function Clone : TFhirConceptMapGroupElementTargetDependsOnList; overload;
    function GetEnumerator : TFhirConceptMapGroupElementTargetDependsOnListEnumerator;
    
    //  Add a FhirConceptMapGroupElementTargetDependsOn to the end of the list.
    function Append : TFhirConceptMapGroupElementTargetDependsOn;
    
    // Add an already existing FhirConceptMapGroupElementTargetDependsOn to the end of the list.
    function AddItem(value : TFhirConceptMapGroupElementTargetDependsOn) : TFhirConceptMapGroupElementTargetDependsOn; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirConceptMapGroupElementTargetDependsOn) : Integer;
    
    // Insert FhirConceptMapGroupElementTargetDependsOn before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirConceptMapGroupElementTargetDependsOn;
    
    // Insert an existing FhirConceptMapGroupElementTargetDependsOn before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirConceptMapGroupElementTargetDependsOn);
    
    // Get the iIndexth FhirConceptMapGroupElementTargetDependsOn. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirConceptMapGroupElementTargetDependsOn);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirConceptMapGroupElementTargetDependsOn;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirConceptMapGroupElementTargetDependsOns[index : Integer] : TFhirConceptMapGroupElementTargetDependsOn read GetItemN write SetItemN; default;
  End;

  // What to do when there is no mapping for the source concept. "Unmapped" does not include codes that are unmatched, and the unmapped element is ignored in a code is specified to have equivalence = unmatched.
  TFhirConceptMapGroupUnmapped = class (TFhirBackboneElement)
  protected
    FMode : TFhirEnum;
    FCode : TFhirCode;
    FDisplay : TFhirString;
    FUrl : TFhirCanonical;
    procedure SetMode(value : TFhirEnum);
    function GetModeST : TFhirConceptMapGroupUnmappedModeEnum;
    procedure SetModeST(value : TFhirConceptMapGroupUnmappedModeEnum);
    procedure SetCode(value : TFhirCode);
    function GetCodeST : String;
    procedure SetCodeST(value : String);
    procedure SetDisplay(value : TFhirString);
    function GetDisplayST : String;
    procedure SetDisplayST(value : String);
    procedure SetUrl(value : TFhirCanonical);
    function GetUrlST : String;
    procedure SetUrlST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirConceptMapGroupUnmapped; overload;
    function Clone : TFhirConceptMapGroupUnmapped; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Defines which action to take if there is no match for the source concept in the target system designated for the group. One of 3 actions are possible: use the unmapped code (this is useful when doing a mapping between versions, and only a few codes have changed), use a fixed code (a default code), or alternatively, a reference to a different concept map can be provided (by canonical URL).
    property mode : TFhirConceptMapGroupUnmappedModeEnum read GetModeST write SetModeST;
    property modeElement : TFhirEnum read FMode write SetMode;

    // Typed access to The fixed code to use when the mode = 'fixed'  - all unmapped codes are mapped to a single fixed code.
    property code : String read GetCodeST write SetCodeST;
    // The fixed code to use when the mode = 'fixed'  - all unmapped codes are mapped to a single fixed code.
    property codeElement : TFhirCode read FCode write SetCode;

    // Typed access to The display for the code. The display is only provided to help editors when editing the concept map.
    property display : String read GetDisplayST write SetDisplayST;
    // The display for the code. The display is only provided to help editors when editing the concept map.
    property displayElement : TFhirString read FDisplay write SetDisplay;

    // Typed access to The canonical reference to an additional ConceptMap resource instance to use for mapping if this ConceptMap resource contains no matching mapping for the source concept.
    property url : String read GetUrlST write SetUrlST;
    // The canonical reference to an additional ConceptMap resource instance to use for mapping if this ConceptMap resource contains no matching mapping for the source concept.
    property urlElement : TFhirCanonical read FUrl write SetUrl;

  end;

  TFhirConceptMapGroupUnmappedListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirConceptMapGroupUnmappedList;
    function GetCurrent : TFhirConceptMapGroupUnmapped;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirConceptMapGroupUnmappedList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConceptMapGroupUnmapped read GetCurrent;
  end;

  TFhirConceptMapGroupUnmappedList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConceptMapGroupUnmapped;
    procedure SetItemN(index : Integer; value : TFhirConceptMapGroupUnmapped);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirConceptMapGroupUnmappedList; overload;
    function Clone : TFhirConceptMapGroupUnmappedList; overload;
    function GetEnumerator : TFhirConceptMapGroupUnmappedListEnumerator;
    
    //  Add a FhirConceptMapGroupUnmapped to the end of the list.
    function Append : TFhirConceptMapGroupUnmapped;
    
    // Add an already existing FhirConceptMapGroupUnmapped to the end of the list.
    function AddItem(value : TFhirConceptMapGroupUnmapped) : TFhirConceptMapGroupUnmapped; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirConceptMapGroupUnmapped) : Integer;
    
    // Insert FhirConceptMapGroupUnmapped before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirConceptMapGroupUnmapped;
    
    // Insert an existing FhirConceptMapGroupUnmapped before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirConceptMapGroupUnmapped);
    
    // Get the iIndexth FhirConceptMapGroupUnmapped. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirConceptMapGroupUnmapped);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirConceptMapGroupUnmapped;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirConceptMapGroupUnmappeds[index : Integer] : TFhirConceptMapGroupUnmapped read GetItemN write SetItemN; default;
  End;

  // A statement of relationships from one set of concepts to one or more other concepts - either concepts in code systems, or data element/data element concepts, or classes in class models.
  TFhirConceptMap = class (TFhirDomainResource)
  protected
    FUrl : TFhirUri;
    FIdentifier : TFhirIdentifier;
    FVersion : TFhirString;
    FName : TFhirString;
    FTitle : TFhirString;
    FStatus : TFhirEnum;
    FExperimental : TFhirBoolean;
    FDate : TFhirDateTime;
    FPublisher : TFhirString;
    FcontactList : TFhirContactDetailList;
    FDescription : TFhirMarkdown;
    FuseContextList : TFhirUsageContextList;
    FjurisdictionList : TFhirCodeableConceptList;
    FPurpose : TFhirMarkdown;
    FCopyright : TFhirMarkdown;
    FSource : TFhirDataType;
    FTarget : TFhirDataType;
    FgroupList : TFhirConceptMapGroupList;
    procedure SetUrl(value : TFhirUri);
    function GetUrlST : String;
    procedure SetUrlST(value : String);
    procedure SetIdentifier(value : TFhirIdentifier);
    procedure SetVersion(value : TFhirString);
    function GetVersionST : String;
    procedure SetVersionST(value : String);
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetTitle(value : TFhirString);
    function GetTitleST : String;
    procedure SetTitleST(value : String);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirPublicationStatusEnum;
    procedure SetStatusST(value : TFhirPublicationStatusEnum);
    procedure SetExperimental(value : TFhirBoolean);
    function GetExperimentalST : Boolean;
    procedure SetExperimentalST(value : Boolean);
    procedure SetDate(value : TFhirDateTime);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    procedure SetPublisher(value : TFhirString);
    function GetPublisherST : String;
    procedure SetPublisherST(value : String);
    function GetContactList : TFhirContactDetailList;
    function GetHasContactList : Boolean;
    procedure SetDescription(value : TFhirMarkdown);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetUseContextList : TFhirUsageContextList;
    function GetHasUseContextList : Boolean;
    function GetJurisdictionList : TFhirCodeableConceptList;
    function GetHasJurisdictionList : Boolean;
    procedure SetPurpose(value : TFhirMarkdown);
    function GetPurposeST : String;
    procedure SetPurposeST(value : String);
    procedure SetCopyright(value : TFhirMarkdown);
    function GetCopyrightST : String;
    procedure SetCopyrightST(value : String);
    procedure SetSource(value : TFhirDataType);
    procedure SetTarget(value : TFhirDataType);
    function GetGroupList : TFhirConceptMapGroupList;
    function GetHasGroupList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirConceptMap; overload;
    function Clone : TFhirConceptMap; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An absolute URI that is used to identify this concept map when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this concept map is (or will be) published. This URL can be the target of a canonical reference. It SHALL remain the same when the concept map is stored on different servers.
    property url : String read GetUrlST write SetUrlST;
    // An absolute URI that is used to identify this concept map when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this concept map is (or will be) published. This URL can be the target of a canonical reference. It SHALL remain the same when the concept map is stored on different servers.
    property urlElement : TFhirUri read FUrl write SetUrl;

    // Typed access to A formal identifier that is used to identify this concept map when it is represented in other formats, or referenced in a specification, model, design or an instance. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // A formal identifier that is used to identify this concept map when it is represented in other formats, or referenced in a specification, model, design or an instance.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to The identifier that is used to identify this version of the concept map when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the concept map author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
    property version : String read GetVersionST write SetVersionST;
    // The identifier that is used to identify this version of the concept map when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the concept map author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to A natural language name identifying the concept map. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property name : String read GetNameST write SetNameST;
    // A natural language name identifying the concept map. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A short, descriptive, user-friendly title for the concept map.
    property title : String read GetTitleST write SetTitleST;
    // A short, descriptive, user-friendly title for the concept map.
    property titleElement : TFhirString read FTitle write SetTitle;

    // The status of this concept map. Enables tracking the life-cycle of the content.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A Boolean value to indicate that this concept map is authored for testing purposes (or education/evaluation/marketing) and is not intended to be used for genuine usage.
    property experimental : Boolean read GetExperimentalST write SetExperimentalST;
    // A Boolean value to indicate that this concept map is authored for testing purposes (or education/evaluation/marketing) and is not intended to be used for genuine usage.
    property experimentalElement : TFhirBoolean read FExperimental write SetExperimental;

    // Typed access to The date  (and optionally time) when the concept map was published. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the concept map changes.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date  (and optionally time) when the concept map was published. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the concept map changes.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The name of the organization or individual that published the concept map.
    property publisher : String read GetPublisherST write SetPublisherST;
    // The name of the organization or individual that published the concept map.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Contact details to assist a user in finding and communicating with the publisher.
    property contactList : TFhirContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to A free text natural language description of the concept map from a consumer's perspective.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A free text natural language description of the concept map from a consumer's perspective.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // The content was developed with a focus and intent of supporting the contexts that are listed. These contexts may be general categories (gender, age, ...) or may be references to specific programs (insurance plans, studies, ...) and may be used to assist with indexing and searching for appropriate concept map instances.
    property useContextList : TFhirUsageContextList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // A legal or geographic region in which the concept map is intended to be used.
    property jurisdictionList : TFhirCodeableConceptList read GetJurisdictionList;
    property hasJurisdictionList : boolean read GetHasJurisdictionList;

    // Typed access to Explanation of why this concept map is needed and why it has been designed as it has.
    property purpose : String read GetPurposeST write SetPurposeST;
    // Explanation of why this concept map is needed and why it has been designed as it has.
    property purposeElement : TFhirMarkdown read FPurpose write SetPurpose;

    // Typed access to A copyright statement relating to the concept map and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the concept map.
    property copyright : String read GetCopyrightST write SetCopyrightST;
    // A copyright statement relating to the concept map and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the concept map.
    property copyrightElement : TFhirMarkdown read FCopyright write SetCopyright;

    // Typed access to Identifier for the source value set that contains the concepts that are being mapped and provides context for the mappings. (defined for API consistency)
    property source : TFhirDataType read FSource write SetSource;
    // Identifier for the source value set that contains the concepts that are being mapped and provides context for the mappings.
    property sourceElement : TFhirDataType read FSource write SetSource;

    // Typed access to The target value set provides context for the mappings. Note that the mapping is made between concepts, not between value sets, but the value set provides important context about how the concept mapping choices are made. (defined for API consistency)
    property target : TFhirDataType read FTarget write SetTarget;
    // The target value set provides context for the mappings. Note that the mapping is made between concepts, not between value sets, but the value set provides important context about how the concept mapping choices are made.
    property targetElement : TFhirDataType read FTarget write SetTarget;

    // A group of mappings that all have the same source and target system.
    property groupList : TFhirConceptMapGroupList read GetGroupList;
    property hasGroupList : boolean read GetHasGroupList;

  end;

  TFhirConceptMapListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirConceptMapList;
    function GetCurrent : TFhirConceptMap;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirConceptMapList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConceptMap read GetCurrent;
  end;

  TFhirConceptMapList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConceptMap;
    procedure SetItemN(index : Integer; value : TFhirConceptMap);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirConceptMapList; overload;
    function Clone : TFhirConceptMapList; overload;
    function GetEnumerator : TFhirConceptMapListEnumerator;
    
    //  Add a FhirConceptMap to the end of the list.
    function Append : TFhirConceptMap;
    
    // Add an already existing FhirConceptMap to the end of the list.
    function AddItem(value : TFhirConceptMap) : TFhirConceptMap; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirConceptMap) : Integer;
    
    // Insert FhirConceptMap before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirConceptMap;
    
    // Insert an existing FhirConceptMap before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirConceptMap);
    
    // Get the iIndexth FhirConceptMap. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirConceptMap);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirConceptMap;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirConceptMaps[index : Integer] : TFhirConceptMap read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_CONCEPTMAP}
{$IFDEF FHIR_EVENTDEFINITION}
  // The EventDefinition resource provides a reusable description of when a particular event can occur.
  TFhirEventDefinition = class (TFhirDomainResource)
  protected
    FUrl : TFhirUri;
    FidentifierList : TFhirIdentifierList;
    FVersion : TFhirString;
    FName : TFhirString;
    FTitle : TFhirString;
    FSubtitle : TFhirString;
    FStatus : TFhirEnum;
    FExperimental : TFhirBoolean;
    FSubject : TFhirDataType;
    FDate : TFhirDateTime;
    FPublisher : TFhirString;
    FcontactList : TFhirContactDetailList;
    FDescription : TFhirMarkdown;
    FuseContextList : TFhirUsageContextList;
    FjurisdictionList : TFhirCodeableConceptList;
    FPurpose : TFhirMarkdown;
    FUsage : TFhirString;
    FCopyright : TFhirMarkdown;
    FApprovalDate : TFhirDate;
    FLastReviewDate : TFhirDate;
    FEffectivePeriod : TFhirPeriod;
    FtopicList : TFhirCodeableConceptList;
    FauthorList : TFhirContactDetailList;
    FeditorList : TFhirContactDetailList;
    FreviewerList : TFhirContactDetailList;
    FendorserList : TFhirContactDetailList;
    FrelatedArtifactList : TFhirRelatedArtifactList;
    FtriggerList : TFhirTriggerDefinitionList;
    procedure SetUrl(value : TFhirUri);
    function GetUrlST : String;
    procedure SetUrlST(value : String);
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetVersion(value : TFhirString);
    function GetVersionST : String;
    procedure SetVersionST(value : String);
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetTitle(value : TFhirString);
    function GetTitleST : String;
    procedure SetTitleST(value : String);
    procedure SetSubtitle(value : TFhirString);
    function GetSubtitleST : String;
    procedure SetSubtitleST(value : String);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirPublicationStatusEnum;
    procedure SetStatusST(value : TFhirPublicationStatusEnum);
    procedure SetExperimental(value : TFhirBoolean);
    function GetExperimentalST : Boolean;
    procedure SetExperimentalST(value : Boolean);
    procedure SetSubject(value : TFhirDataType);
    procedure SetDate(value : TFhirDateTime);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    procedure SetPublisher(value : TFhirString);
    function GetPublisherST : String;
    procedure SetPublisherST(value : String);
    function GetContactList : TFhirContactDetailList;
    function GetHasContactList : Boolean;
    procedure SetDescription(value : TFhirMarkdown);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetUseContextList : TFhirUsageContextList;
    function GetHasUseContextList : Boolean;
    function GetJurisdictionList : TFhirCodeableConceptList;
    function GetHasJurisdictionList : Boolean;
    procedure SetPurpose(value : TFhirMarkdown);
    function GetPurposeST : String;
    procedure SetPurposeST(value : String);
    procedure SetUsage(value : TFhirString);
    function GetUsageST : String;
    procedure SetUsageST(value : String);
    procedure SetCopyright(value : TFhirMarkdown);
    function GetCopyrightST : String;
    procedure SetCopyrightST(value : String);
    procedure SetApprovalDate(value : TFhirDate);
    function GetApprovalDateST : TFslDateTime;
    procedure SetApprovalDateST(value : TFslDateTime);
    procedure SetLastReviewDate(value : TFhirDate);
    function GetLastReviewDateST : TFslDateTime;
    procedure SetLastReviewDateST(value : TFslDateTime);
    procedure SetEffectivePeriod(value : TFhirPeriod);
    function GetTopicList : TFhirCodeableConceptList;
    function GetHasTopicList : Boolean;
    function GetAuthorList : TFhirContactDetailList;
    function GetHasAuthorList : Boolean;
    function GetEditorList : TFhirContactDetailList;
    function GetHasEditorList : Boolean;
    function GetReviewerList : TFhirContactDetailList;
    function GetHasReviewerList : Boolean;
    function GetEndorserList : TFhirContactDetailList;
    function GetHasEndorserList : Boolean;
    function GetRelatedArtifactList : TFhirRelatedArtifactList;
    function GetHasRelatedArtifactList : Boolean;
    function GetTriggerList : TFhirTriggerDefinitionList;
    function GetHasTriggerList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEventDefinition; overload;
    function Clone : TFhirEventDefinition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An absolute URI that is used to identify this event definition when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this event definition is (or will be) published. This URL can be the target of a canonical reference. It SHALL remain the same when the event definition is stored on different servers.
    property url : String read GetUrlST write SetUrlST;
    // An absolute URI that is used to identify this event definition when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this event definition is (or will be) published. This URL can be the target of a canonical reference. It SHALL remain the same when the event definition is stored on different servers.
    property urlElement : TFhirUri read FUrl write SetUrl;

    // A formal identifier that is used to identify this event definition when it is represented in other formats, or referenced in a specification, model, design or an instance.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The identifier that is used to identify this version of the event definition when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the event definition author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
    property version : String read GetVersionST write SetVersionST;
    // The identifier that is used to identify this version of the event definition when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the event definition author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to A natural language name identifying the event definition. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property name : String read GetNameST write SetNameST;
    // A natural language name identifying the event definition. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A short, descriptive, user-friendly title for the event definition.
    property title : String read GetTitleST write SetTitleST;
    // A short, descriptive, user-friendly title for the event definition.
    property titleElement : TFhirString read FTitle write SetTitle;

    // Typed access to An explanatory or alternate title for the event definition giving additional information about its content.
    property subtitle : String read GetSubtitleST write SetSubtitleST;
    // An explanatory or alternate title for the event definition giving additional information about its content.
    property subtitleElement : TFhirString read FSubtitle write SetSubtitle;

    // The status of this event definition. Enables tracking the life-cycle of the content.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A Boolean value to indicate that this event definition is authored for testing purposes (or education/evaluation/marketing) and is not intended to be used for genuine usage.
    property experimental : Boolean read GetExperimentalST write SetExperimentalST;
    // A Boolean value to indicate that this event definition is authored for testing purposes (or education/evaluation/marketing) and is not intended to be used for genuine usage.
    property experimentalElement : TFhirBoolean read FExperimental write SetExperimental;

    // Typed access to A code or group definition that describes the intended subject of the event definition. (defined for API consistency)
    property subject : TFhirDataType read FSubject write SetSubject;
    // A code or group definition that describes the intended subject of the event definition.
    property subjectElement : TFhirDataType read FSubject write SetSubject;

    // Typed access to The date  (and optionally time) when the event definition was published. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the event definition changes.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date  (and optionally time) when the event definition was published. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the event definition changes.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The name of the organization or individual that published the event definition.
    property publisher : String read GetPublisherST write SetPublisherST;
    // The name of the organization or individual that published the event definition.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Contact details to assist a user in finding and communicating with the publisher.
    property contactList : TFhirContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to A free text natural language description of the event definition from a consumer's perspective.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A free text natural language description of the event definition from a consumer's perspective.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // The content was developed with a focus and intent of supporting the contexts that are listed. These contexts may be general categories (gender, age, ...) or may be references to specific programs (insurance plans, studies, ...) and may be used to assist with indexing and searching for appropriate event definition instances.
    property useContextList : TFhirUsageContextList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // A legal or geographic region in which the event definition is intended to be used.
    property jurisdictionList : TFhirCodeableConceptList read GetJurisdictionList;
    property hasJurisdictionList : boolean read GetHasJurisdictionList;

    // Typed access to Explanation of why this event definition is needed and why it has been designed as it has.
    property purpose : String read GetPurposeST write SetPurposeST;
    // Explanation of why this event definition is needed and why it has been designed as it has.
    property purposeElement : TFhirMarkdown read FPurpose write SetPurpose;

    // Typed access to A detailed description of how the event definition is used from a clinical perspective.
    property usage : String read GetUsageST write SetUsageST;
    // A detailed description of how the event definition is used from a clinical perspective.
    property usageElement : TFhirString read FUsage write SetUsage;

    // Typed access to A copyright statement relating to the event definition and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the event definition.
    property copyright : String read GetCopyrightST write SetCopyrightST;
    // A copyright statement relating to the event definition and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the event definition.
    property copyrightElement : TFhirMarkdown read FCopyright write SetCopyright;

    // Typed access to The date on which the resource content was approved by the publisher. Approval happens once when the content is officially approved for usage.
    property approvalDate : TFslDateTime read GetApprovalDateST write SetApprovalDateST;
    // The date on which the resource content was approved by the publisher. Approval happens once when the content is officially approved for usage.
    property approvalDateElement : TFhirDate read FApprovalDate write SetApprovalDate;

    // Typed access to The date on which the resource content was last reviewed. Review happens periodically after approval but does not change the original approval date.
    property lastReviewDate : TFslDateTime read GetLastReviewDateST write SetLastReviewDateST;
    // The date on which the resource content was last reviewed. Review happens periodically after approval but does not change the original approval date.
    property lastReviewDateElement : TFhirDate read FLastReviewDate write SetLastReviewDate;

    // Typed access to The period during which the event definition content was or is planned to be in active use. (defined for API consistency)
    property effectivePeriod : TFhirPeriod read FEffectivePeriod write SetEffectivePeriod;
    // The period during which the event definition content was or is planned to be in active use.
    property effectivePeriodElement : TFhirPeriod read FEffectivePeriod write SetEffectivePeriod;

    // Descriptive topics related to the module. Topics provide a high-level categorization of the module that can be useful for filtering and searching.
    property topicList : TFhirCodeableConceptList read GetTopicList;
    property hasTopicList : boolean read GetHasTopicList;

    // An individiual or organization primarily involved in the creation and maintenance of the content.
    property authorList : TFhirContactDetailList read GetAuthorList;
    property hasAuthorList : boolean read GetHasAuthorList;

    // An individual or organization primarily responsible for internal coherence of the content.
    property editorList : TFhirContactDetailList read GetEditorList;
    property hasEditorList : boolean read GetHasEditorList;

    // An individual or organization primarily responsible for review of some aspect of the content.
    property reviewerList : TFhirContactDetailList read GetReviewerList;
    property hasReviewerList : boolean read GetHasReviewerList;

    // An individual or organization responsible for officially endorsing the content for use in some setting.
    property endorserList : TFhirContactDetailList read GetEndorserList;
    property hasEndorserList : boolean read GetHasEndorserList;

    // Related resources such as additional documentation, justification, or bibliographic references.
    property relatedArtifactList : TFhirRelatedArtifactList read GetRelatedArtifactList;
    property hasRelatedArtifactList : boolean read GetHasRelatedArtifactList;

    // The trigger element defines when the event occurs. If more than one trigger condition is specified, the event fires whenever any one of the trigger conditions is met.
    property triggerList : TFhirTriggerDefinitionList read GetTriggerList;
    property hasTriggerList : boolean read GetHasTriggerList;

  end;

  TFhirEventDefinitionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEventDefinitionList;
    function GetCurrent : TFhirEventDefinition;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirEventDefinitionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEventDefinition read GetCurrent;
  end;

  TFhirEventDefinitionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEventDefinition;
    procedure SetItemN(index : Integer; value : TFhirEventDefinition);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirEventDefinitionList; overload;
    function Clone : TFhirEventDefinitionList; overload;
    function GetEnumerator : TFhirEventDefinitionListEnumerator;
    
    //  Add a FhirEventDefinition to the end of the list.
    function Append : TFhirEventDefinition;
    
    // Add an already existing FhirEventDefinition to the end of the list.
    function AddItem(value : TFhirEventDefinition) : TFhirEventDefinition; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEventDefinition) : Integer;
    
    // Insert FhirEventDefinition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEventDefinition;
    
    // Insert an existing FhirEventDefinition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEventDefinition);
    
    // Get the iIndexth FhirEventDefinition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEventDefinition);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEventDefinition;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirEventDefinitions[index : Integer] : TFhirEventDefinition read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_EVENTDEFINITION}
{$IFDEF FHIR_EXAMPLESCENARIO}
  // Actor participating in the resource.
  TFhirExampleScenarioActor = class (TFhirBackboneElement)
  protected
    FActorId : TFhirString;
    FType_ : TFhirEnum;
    FName : TFhirString;
    FDescription : TFhirMarkdown;
    procedure SetActorId(value : TFhirString);
    function GetActorIdST : String;
    procedure SetActorIdST(value : String);
    procedure SetType_(value : TFhirEnum);
    function GetType_ST : TFhirExampleScenarioActorTypeEnum;
    procedure SetType_ST(value : TFhirExampleScenarioActorTypeEnum);
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetDescription(value : TFhirMarkdown);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExampleScenarioActor; overload;
    function Clone : TFhirExampleScenarioActor; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to ID or acronym of actor.
    property actorId : String read GetActorIdST write SetActorIdST;
    // ID or acronym of actor.
    property actorIdElement : TFhirString read FActorId write SetActorId;

    // The type of actor - person or system.
    property type_ : TFhirExampleScenarioActorTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to The name of the actor as shown in the page.
    property name : String read GetNameST write SetNameST;
    // The name of the actor as shown in the page.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to The description of the actor.
    property description : String read GetDescriptionST write SetDescriptionST;
    // The description of the actor.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

  end;

  TFhirExampleScenarioActorListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExampleScenarioActorList;
    function GetCurrent : TFhirExampleScenarioActor;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirExampleScenarioActorList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExampleScenarioActor read GetCurrent;
  end;

  TFhirExampleScenarioActorList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirExampleScenarioActor;
    procedure SetItemN(index : Integer; value : TFhirExampleScenarioActor);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirExampleScenarioActorList; overload;
    function Clone : TFhirExampleScenarioActorList; overload;
    function GetEnumerator : TFhirExampleScenarioActorListEnumerator;
    
    //  Add a FhirExampleScenarioActor to the end of the list.
    function Append : TFhirExampleScenarioActor;
    
    // Add an already existing FhirExampleScenarioActor to the end of the list.
    function AddItem(value : TFhirExampleScenarioActor) : TFhirExampleScenarioActor; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExampleScenarioActor) : Integer;
    
    // Insert FhirExampleScenarioActor before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExampleScenarioActor;
    
    // Insert an existing FhirExampleScenarioActor before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExampleScenarioActor);
    
    // Get the iIndexth FhirExampleScenarioActor. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExampleScenarioActor);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirExampleScenarioActor;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirExampleScenarioActors[index : Integer] : TFhirExampleScenarioActor read GetItemN write SetItemN; default;
  End;

  // Each resource and each version that is present in the workflow.
  TFhirExampleScenarioInstance = class (TFhirBackboneElement)
  protected
    FResourceId : TFhirString;
    FResourceType : TFhirEnum;
    FName : TFhirString;
    FDescription : TFhirMarkdown;
    FversionList : TFhirExampleScenarioInstanceVersionList;
    FcontainedInstanceList : TFhirExampleScenarioInstanceContainedInstanceList;
    procedure SetResourceId(value : TFhirString);
    function GetResourceIdST : String;
    procedure SetResourceIdST(value : String);
    procedure SetResourceType(value : TFhirEnum);
    function GetResourceTypeST : TFhirResourceTypesEnum;
    procedure SetResourceTypeST(value : TFhirResourceTypesEnum);
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetDescription(value : TFhirMarkdown);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetVersionList : TFhirExampleScenarioInstanceVersionList;
    function GetHasVersionList : Boolean;
    function GetContainedInstanceList : TFhirExampleScenarioInstanceContainedInstanceList;
    function GetHasContainedInstanceList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExampleScenarioInstance; overload;
    function Clone : TFhirExampleScenarioInstance; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The id of the resource for referencing.
    property resourceId : String read GetResourceIdST write SetResourceIdST;
    // The id of the resource for referencing.
    property resourceIdElement : TFhirString read FResourceId write SetResourceId;

    // The type of the resource.
    property resourceType : TFhirResourceTypesEnum read GetResourceTypeST write SetResourceTypeST;
    property resourceTypeElement : TFhirEnum read FResourceType write SetResourceType;

    // Typed access to A short name for the resource instance.
    property name : String read GetNameST write SetNameST;
    // A short name for the resource instance.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to Human-friendly description of the resource instance.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Human-friendly description of the resource instance.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // A specific version of the resource.
    property versionList : TFhirExampleScenarioInstanceVersionList read GetVersionList;
    property hasVersionList : boolean read GetHasVersionList;

    // Resources contained in the instance (e.g. the observations contained in a bundle).
    property containedInstanceList : TFhirExampleScenarioInstanceContainedInstanceList read GetContainedInstanceList;
    property hasContainedInstanceList : boolean read GetHasContainedInstanceList;

  end;

  TFhirExampleScenarioInstanceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExampleScenarioInstanceList;
    function GetCurrent : TFhirExampleScenarioInstance;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirExampleScenarioInstanceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExampleScenarioInstance read GetCurrent;
  end;

  TFhirExampleScenarioInstanceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirExampleScenarioInstance;
    procedure SetItemN(index : Integer; value : TFhirExampleScenarioInstance);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirExampleScenarioInstanceList; overload;
    function Clone : TFhirExampleScenarioInstanceList; overload;
    function GetEnumerator : TFhirExampleScenarioInstanceListEnumerator;
    
    //  Add a FhirExampleScenarioInstance to the end of the list.
    function Append : TFhirExampleScenarioInstance;
    
    // Add an already existing FhirExampleScenarioInstance to the end of the list.
    function AddItem(value : TFhirExampleScenarioInstance) : TFhirExampleScenarioInstance; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExampleScenarioInstance) : Integer;
    
    // Insert FhirExampleScenarioInstance before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExampleScenarioInstance;
    
    // Insert an existing FhirExampleScenarioInstance before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExampleScenarioInstance);
    
    // Get the iIndexth FhirExampleScenarioInstance. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExampleScenarioInstance);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirExampleScenarioInstance;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirExampleScenarioInstances[index : Integer] : TFhirExampleScenarioInstance read GetItemN write SetItemN; default;
  End;

  // A specific version of the resource.
  TFhirExampleScenarioInstanceVersion = class (TFhirBackboneElement)
  protected
    FVersionId : TFhirString;
    FDescription : TFhirMarkdown;
    procedure SetVersionId(value : TFhirString);
    function GetVersionIdST : String;
    procedure SetVersionIdST(value : String);
    procedure SetDescription(value : TFhirMarkdown);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExampleScenarioInstanceVersion; overload;
    function Clone : TFhirExampleScenarioInstanceVersion; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The identifier of a specific version of a resource.
    property versionId : String read GetVersionIdST write SetVersionIdST;
    // The identifier of a specific version of a resource.
    property versionIdElement : TFhirString read FVersionId write SetVersionId;

    // Typed access to The description of the resource version.
    property description : String read GetDescriptionST write SetDescriptionST;
    // The description of the resource version.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

  end;

  TFhirExampleScenarioInstanceVersionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExampleScenarioInstanceVersionList;
    function GetCurrent : TFhirExampleScenarioInstanceVersion;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirExampleScenarioInstanceVersionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExampleScenarioInstanceVersion read GetCurrent;
  end;

  TFhirExampleScenarioInstanceVersionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirExampleScenarioInstanceVersion;
    procedure SetItemN(index : Integer; value : TFhirExampleScenarioInstanceVersion);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirExampleScenarioInstanceVersionList; overload;
    function Clone : TFhirExampleScenarioInstanceVersionList; overload;
    function GetEnumerator : TFhirExampleScenarioInstanceVersionListEnumerator;
    
    //  Add a FhirExampleScenarioInstanceVersion to the end of the list.
    function Append : TFhirExampleScenarioInstanceVersion;
    
    // Add an already existing FhirExampleScenarioInstanceVersion to the end of the list.
    function AddItem(value : TFhirExampleScenarioInstanceVersion) : TFhirExampleScenarioInstanceVersion; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExampleScenarioInstanceVersion) : Integer;
    
    // Insert FhirExampleScenarioInstanceVersion before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExampleScenarioInstanceVersion;
    
    // Insert an existing FhirExampleScenarioInstanceVersion before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExampleScenarioInstanceVersion);
    
    // Get the iIndexth FhirExampleScenarioInstanceVersion. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExampleScenarioInstanceVersion);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirExampleScenarioInstanceVersion;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirExampleScenarioInstanceVersions[index : Integer] : TFhirExampleScenarioInstanceVersion read GetItemN write SetItemN; default;
  End;

  // Resources contained in the instance (e.g. the observations contained in a bundle).
  TFhirExampleScenarioInstanceContainedInstance = class (TFhirBackboneElement)
  protected
    FResourceId : TFhirString;
    FVersionId : TFhirString;
    procedure SetResourceId(value : TFhirString);
    function GetResourceIdST : String;
    procedure SetResourceIdST(value : String);
    procedure SetVersionId(value : TFhirString);
    function GetVersionIdST : String;
    procedure SetVersionIdST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExampleScenarioInstanceContainedInstance; overload;
    function Clone : TFhirExampleScenarioInstanceContainedInstance; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Each resource contained in the instance.
    property resourceId : String read GetResourceIdST write SetResourceIdST;
    // Each resource contained in the instance.
    property resourceIdElement : TFhirString read FResourceId write SetResourceId;

    // Typed access to A specific version of a resource contained in the instance.
    property versionId : String read GetVersionIdST write SetVersionIdST;
    // A specific version of a resource contained in the instance.
    property versionIdElement : TFhirString read FVersionId write SetVersionId;

  end;

  TFhirExampleScenarioInstanceContainedInstanceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExampleScenarioInstanceContainedInstanceList;
    function GetCurrent : TFhirExampleScenarioInstanceContainedInstance;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirExampleScenarioInstanceContainedInstanceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExampleScenarioInstanceContainedInstance read GetCurrent;
  end;

  TFhirExampleScenarioInstanceContainedInstanceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirExampleScenarioInstanceContainedInstance;
    procedure SetItemN(index : Integer; value : TFhirExampleScenarioInstanceContainedInstance);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirExampleScenarioInstanceContainedInstanceList; overload;
    function Clone : TFhirExampleScenarioInstanceContainedInstanceList; overload;
    function GetEnumerator : TFhirExampleScenarioInstanceContainedInstanceListEnumerator;
    
    //  Add a FhirExampleScenarioInstanceContainedInstance to the end of the list.
    function Append : TFhirExampleScenarioInstanceContainedInstance;
    
    // Add an already existing FhirExampleScenarioInstanceContainedInstance to the end of the list.
    function AddItem(value : TFhirExampleScenarioInstanceContainedInstance) : TFhirExampleScenarioInstanceContainedInstance; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExampleScenarioInstanceContainedInstance) : Integer;
    
    // Insert FhirExampleScenarioInstanceContainedInstance before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExampleScenarioInstanceContainedInstance;
    
    // Insert an existing FhirExampleScenarioInstanceContainedInstance before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExampleScenarioInstanceContainedInstance);
    
    // Get the iIndexth FhirExampleScenarioInstanceContainedInstance. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExampleScenarioInstanceContainedInstance);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirExampleScenarioInstanceContainedInstance;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirExampleScenarioInstanceContainedInstances[index : Integer] : TFhirExampleScenarioInstanceContainedInstance read GetItemN write SetItemN; default;
  End;

  // Each major process - a group of operations.
  TFhirExampleScenarioProcess = class (TFhirBackboneElement)
  protected
    FTitle : TFhirString;
    FDescription : TFhirMarkdown;
    FPreConditions : TFhirMarkdown;
    FPostConditions : TFhirMarkdown;
    FstepList : TFhirExampleScenarioProcessStepList;
    procedure SetTitle(value : TFhirString);
    function GetTitleST : String;
    procedure SetTitleST(value : String);
    procedure SetDescription(value : TFhirMarkdown);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetPreConditions(value : TFhirMarkdown);
    function GetPreConditionsST : String;
    procedure SetPreConditionsST(value : String);
    procedure SetPostConditions(value : TFhirMarkdown);
    function GetPostConditionsST : String;
    procedure SetPostConditionsST(value : String);
    function GetStepList : TFhirExampleScenarioProcessStepList;
    function GetHasStepList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExampleScenarioProcess; overload;
    function Clone : TFhirExampleScenarioProcess; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The diagram title of the group of operations.
    property title : String read GetTitleST write SetTitleST;
    // The diagram title of the group of operations.
    property titleElement : TFhirString read FTitle write SetTitle;

    // Typed access to A longer description of the group of operations.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A longer description of the group of operations.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // Typed access to Description of initial status before the process starts.
    property preConditions : String read GetPreConditionsST write SetPreConditionsST;
    // Description of initial status before the process starts.
    property preConditionsElement : TFhirMarkdown read FPreConditions write SetPreConditions;

    // Typed access to Description of final status after the process ends.
    property postConditions : String read GetPostConditionsST write SetPostConditionsST;
    // Description of final status after the process ends.
    property postConditionsElement : TFhirMarkdown read FPostConditions write SetPostConditions;

    // Each step of the process.
    property stepList : TFhirExampleScenarioProcessStepList read GetStepList;
    property hasStepList : boolean read GetHasStepList;

  end;

  TFhirExampleScenarioProcessListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExampleScenarioProcessList;
    function GetCurrent : TFhirExampleScenarioProcess;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirExampleScenarioProcessList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExampleScenarioProcess read GetCurrent;
  end;

  TFhirExampleScenarioProcessList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirExampleScenarioProcess;
    procedure SetItemN(index : Integer; value : TFhirExampleScenarioProcess);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirExampleScenarioProcessList; overload;
    function Clone : TFhirExampleScenarioProcessList; overload;
    function GetEnumerator : TFhirExampleScenarioProcessListEnumerator;
    
    //  Add a FhirExampleScenarioProcess to the end of the list.
    function Append : TFhirExampleScenarioProcess;
    
    // Add an already existing FhirExampleScenarioProcess to the end of the list.
    function AddItem(value : TFhirExampleScenarioProcess) : TFhirExampleScenarioProcess; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExampleScenarioProcess) : Integer;
    
    // Insert FhirExampleScenarioProcess before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExampleScenarioProcess;
    
    // Insert an existing FhirExampleScenarioProcess before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExampleScenarioProcess);
    
    // Get the iIndexth FhirExampleScenarioProcess. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExampleScenarioProcess);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirExampleScenarioProcess;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirExampleScenarioProcesses[index : Integer] : TFhirExampleScenarioProcess read GetItemN write SetItemN; default;
  End;

  // Each step of the process.
  TFhirExampleScenarioProcessStep = class (TFhirBackboneElement)
  protected
    FprocessList : TFhirExampleScenarioProcessList;
    FPause : TFhirBoolean;
    FOperation : TFhirExampleScenarioProcessStepOperation;
    FalternativeList : TFhirExampleScenarioProcessStepAlternativeList;
    function GetProcessList : TFhirExampleScenarioProcessList;
    function GetHasProcessList : Boolean;
    procedure SetPause(value : TFhirBoolean);
    function GetPauseST : Boolean;
    procedure SetPauseST(value : Boolean);
    procedure SetOperation(value : TFhirExampleScenarioProcessStepOperation);
    function GetAlternativeList : TFhirExampleScenarioProcessStepAlternativeList;
    function GetHasAlternativeList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExampleScenarioProcessStep; overload;
    function Clone : TFhirExampleScenarioProcessStep; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Nested process.
    property processList : TFhirExampleScenarioProcessList read GetProcessList;
    property hasProcessList : boolean read GetHasProcessList;

    // Typed access to If there is a pause in the flow.
    property pause : Boolean read GetPauseST write SetPauseST;
    // If there is a pause in the flow.
    property pauseElement : TFhirBoolean read FPause write SetPause;

    // Typed access to Each interaction or action. (defined for API consistency)
    property operation : TFhirExampleScenarioProcessStepOperation read FOperation write SetOperation;
    // Each interaction or action.
    property operationElement : TFhirExampleScenarioProcessStepOperation read FOperation write SetOperation;

    // Indicates an alternative step that can be taken instead of the operations on the base step in exceptional/atypical circumstances.
    property alternativeList : TFhirExampleScenarioProcessStepAlternativeList read GetAlternativeList;
    property hasAlternativeList : boolean read GetHasAlternativeList;

  end;

  TFhirExampleScenarioProcessStepListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExampleScenarioProcessStepList;
    function GetCurrent : TFhirExampleScenarioProcessStep;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirExampleScenarioProcessStepList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExampleScenarioProcessStep read GetCurrent;
  end;

  TFhirExampleScenarioProcessStepList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirExampleScenarioProcessStep;
    procedure SetItemN(index : Integer; value : TFhirExampleScenarioProcessStep);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirExampleScenarioProcessStepList; overload;
    function Clone : TFhirExampleScenarioProcessStepList; overload;
    function GetEnumerator : TFhirExampleScenarioProcessStepListEnumerator;
    
    //  Add a FhirExampleScenarioProcessStep to the end of the list.
    function Append : TFhirExampleScenarioProcessStep;
    
    // Add an already existing FhirExampleScenarioProcessStep to the end of the list.
    function AddItem(value : TFhirExampleScenarioProcessStep) : TFhirExampleScenarioProcessStep; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExampleScenarioProcessStep) : Integer;
    
    // Insert FhirExampleScenarioProcessStep before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExampleScenarioProcessStep;
    
    // Insert an existing FhirExampleScenarioProcessStep before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExampleScenarioProcessStep);
    
    // Get the iIndexth FhirExampleScenarioProcessStep. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExampleScenarioProcessStep);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirExampleScenarioProcessStep;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirExampleScenarioProcessSteps[index : Integer] : TFhirExampleScenarioProcessStep read GetItemN write SetItemN; default;
  End;

  // Each interaction or action.
  TFhirExampleScenarioProcessStepOperation = class (TFhirBackboneElement)
  protected
    FNumber : TFhirString;
    FType_ : TFhirString;
    FName : TFhirString;
    FInitiator : TFhirString;
    FReceiver : TFhirString;
    FDescription : TFhirMarkdown;
    FInitiatorActive : TFhirBoolean;
    FReceiverActive : TFhirBoolean;
    FRequest : TFhirExampleScenarioInstanceContainedInstance;
    FResponse : TFhirExampleScenarioInstanceContainedInstance;
    procedure SetNumber(value : TFhirString);
    function GetNumberST : String;
    procedure SetNumberST(value : String);
    procedure SetType_(value : TFhirString);
    function GetType_ST : String;
    procedure SetType_ST(value : String);
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetInitiator(value : TFhirString);
    function GetInitiatorST : String;
    procedure SetInitiatorST(value : String);
    procedure SetReceiver(value : TFhirString);
    function GetReceiverST : String;
    procedure SetReceiverST(value : String);
    procedure SetDescription(value : TFhirMarkdown);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetInitiatorActive(value : TFhirBoolean);
    function GetInitiatorActiveST : Boolean;
    procedure SetInitiatorActiveST(value : Boolean);
    procedure SetReceiverActive(value : TFhirBoolean);
    function GetReceiverActiveST : Boolean;
    procedure SetReceiverActiveST(value : Boolean);
    procedure SetRequest(value : TFhirExampleScenarioInstanceContainedInstance);
    procedure SetResponse(value : TFhirExampleScenarioInstanceContainedInstance);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExampleScenarioProcessStepOperation; overload;
    function Clone : TFhirExampleScenarioProcessStepOperation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The sequential number of the interaction, e.g. 1.2.5.
    property number : String read GetNumberST write SetNumberST;
    // The sequential number of the interaction, e.g. 1.2.5.
    property numberElement : TFhirString read FNumber write SetNumber;

    // Typed access to The type of operation - CRUD.
    property type_ : String read GetType_ST write SetType_ST;
    // The type of operation - CRUD.
    property type_Element : TFhirString read FType_ write SetType_;

    // Typed access to The human-friendly name of the interaction.
    property name : String read GetNameST write SetNameST;
    // The human-friendly name of the interaction.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to Who starts the transaction.
    property initiator : String read GetInitiatorST write SetInitiatorST;
    // Who starts the transaction.
    property initiatorElement : TFhirString read FInitiator write SetInitiator;

    // Typed access to Who receives the transaction.
    property receiver : String read GetReceiverST write SetReceiverST;
    // Who receives the transaction.
    property receiverElement : TFhirString read FReceiver write SetReceiver;

    // Typed access to A comment to be inserted in the diagram.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A comment to be inserted in the diagram.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // Typed access to Whether the initiator is deactivated right after the transaction.
    property initiatorActive : Boolean read GetInitiatorActiveST write SetInitiatorActiveST;
    // Whether the initiator is deactivated right after the transaction.
    property initiatorActiveElement : TFhirBoolean read FInitiatorActive write SetInitiatorActive;

    // Typed access to Whether the receiver is deactivated right after the transaction.
    property receiverActive : Boolean read GetReceiverActiveST write SetReceiverActiveST;
    // Whether the receiver is deactivated right after the transaction.
    property receiverActiveElement : TFhirBoolean read FReceiverActive write SetReceiverActive;

    // Typed access to Each resource instance used by the initiator. (defined for API consistency)
    property request : TFhirExampleScenarioInstanceContainedInstance read FRequest write SetRequest;
    // Each resource instance used by the initiator.
    property requestElement : TFhirExampleScenarioInstanceContainedInstance read FRequest write SetRequest;

    // Typed access to Each resource instance used by the responder. (defined for API consistency)
    property response : TFhirExampleScenarioInstanceContainedInstance read FResponse write SetResponse;
    // Each resource instance used by the responder.
    property responseElement : TFhirExampleScenarioInstanceContainedInstance read FResponse write SetResponse;

  end;

  TFhirExampleScenarioProcessStepOperationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExampleScenarioProcessStepOperationList;
    function GetCurrent : TFhirExampleScenarioProcessStepOperation;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirExampleScenarioProcessStepOperationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExampleScenarioProcessStepOperation read GetCurrent;
  end;

  TFhirExampleScenarioProcessStepOperationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirExampleScenarioProcessStepOperation;
    procedure SetItemN(index : Integer; value : TFhirExampleScenarioProcessStepOperation);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirExampleScenarioProcessStepOperationList; overload;
    function Clone : TFhirExampleScenarioProcessStepOperationList; overload;
    function GetEnumerator : TFhirExampleScenarioProcessStepOperationListEnumerator;
    
    //  Add a FhirExampleScenarioProcessStepOperation to the end of the list.
    function Append : TFhirExampleScenarioProcessStepOperation;
    
    // Add an already existing FhirExampleScenarioProcessStepOperation to the end of the list.
    function AddItem(value : TFhirExampleScenarioProcessStepOperation) : TFhirExampleScenarioProcessStepOperation; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExampleScenarioProcessStepOperation) : Integer;
    
    // Insert FhirExampleScenarioProcessStepOperation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExampleScenarioProcessStepOperation;
    
    // Insert an existing FhirExampleScenarioProcessStepOperation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExampleScenarioProcessStepOperation);
    
    // Get the iIndexth FhirExampleScenarioProcessStepOperation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExampleScenarioProcessStepOperation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirExampleScenarioProcessStepOperation;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirExampleScenarioProcessStepOperations[index : Integer] : TFhirExampleScenarioProcessStepOperation read GetItemN write SetItemN; default;
  End;

  // Indicates an alternative step that can be taken instead of the operations on the base step in exceptional/atypical circumstances.
  TFhirExampleScenarioProcessStepAlternative = class (TFhirBackboneElement)
  protected
    FTitle : TFhirString;
    FDescription : TFhirMarkdown;
    FstepList : TFhirExampleScenarioProcessStepList;
    procedure SetTitle(value : TFhirString);
    function GetTitleST : String;
    procedure SetTitleST(value : String);
    procedure SetDescription(value : TFhirMarkdown);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetStepList : TFhirExampleScenarioProcessStepList;
    function GetHasStepList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExampleScenarioProcessStepAlternative; overload;
    function Clone : TFhirExampleScenarioProcessStepAlternative; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The label to display for the alternative that gives a sense of the circumstance in which the alternative should be invoked.
    property title : String read GetTitleST write SetTitleST;
    // The label to display for the alternative that gives a sense of the circumstance in which the alternative should be invoked.
    property titleElement : TFhirString read FTitle write SetTitle;

    // Typed access to A human-readable description of the alternative explaining when the alternative should occur rather than the base step.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A human-readable description of the alternative explaining when the alternative should occur rather than the base step.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // What happens in each alternative option.
    property stepList : TFhirExampleScenarioProcessStepList read GetStepList;
    property hasStepList : boolean read GetHasStepList;

  end;

  TFhirExampleScenarioProcessStepAlternativeListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExampleScenarioProcessStepAlternativeList;
    function GetCurrent : TFhirExampleScenarioProcessStepAlternative;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirExampleScenarioProcessStepAlternativeList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExampleScenarioProcessStepAlternative read GetCurrent;
  end;

  TFhirExampleScenarioProcessStepAlternativeList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirExampleScenarioProcessStepAlternative;
    procedure SetItemN(index : Integer; value : TFhirExampleScenarioProcessStepAlternative);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirExampleScenarioProcessStepAlternativeList; overload;
    function Clone : TFhirExampleScenarioProcessStepAlternativeList; overload;
    function GetEnumerator : TFhirExampleScenarioProcessStepAlternativeListEnumerator;
    
    //  Add a FhirExampleScenarioProcessStepAlternative to the end of the list.
    function Append : TFhirExampleScenarioProcessStepAlternative;
    
    // Add an already existing FhirExampleScenarioProcessStepAlternative to the end of the list.
    function AddItem(value : TFhirExampleScenarioProcessStepAlternative) : TFhirExampleScenarioProcessStepAlternative; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExampleScenarioProcessStepAlternative) : Integer;
    
    // Insert FhirExampleScenarioProcessStepAlternative before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExampleScenarioProcessStepAlternative;
    
    // Insert an existing FhirExampleScenarioProcessStepAlternative before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExampleScenarioProcessStepAlternative);
    
    // Get the iIndexth FhirExampleScenarioProcessStepAlternative. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExampleScenarioProcessStepAlternative);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirExampleScenarioProcessStepAlternative;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirExampleScenarioProcessStepAlternatives[index : Integer] : TFhirExampleScenarioProcessStepAlternative read GetItemN write SetItemN; default;
  End;

  // Example of workflow instance.
  TFhirExampleScenario = class (TFhirDomainResource)
  protected
    FUrl : TFhirUri;
    FidentifierList : TFhirIdentifierList;
    FVersion : TFhirString;
    FName : TFhirString;
    FStatus : TFhirEnum;
    FExperimental : TFhirBoolean;
    FDate : TFhirDateTime;
    FPublisher : TFhirString;
    FcontactList : TFhirContactDetailList;
    FuseContextList : TFhirUsageContextList;
    FjurisdictionList : TFhirCodeableConceptList;
    FCopyright : TFhirMarkdown;
    FPurpose : TFhirMarkdown;
    FactorList : TFhirExampleScenarioActorList;
    FinstanceList : TFhirExampleScenarioInstanceList;
    FprocessList : TFhirExampleScenarioProcessList;
    FworkflowList : TFhirCanonicalList;
    procedure SetUrl(value : TFhirUri);
    function GetUrlST : String;
    procedure SetUrlST(value : String);
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetVersion(value : TFhirString);
    function GetVersionST : String;
    procedure SetVersionST(value : String);
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirPublicationStatusEnum;
    procedure SetStatusST(value : TFhirPublicationStatusEnum);
    procedure SetExperimental(value : TFhirBoolean);
    function GetExperimentalST : Boolean;
    procedure SetExperimentalST(value : Boolean);
    procedure SetDate(value : TFhirDateTime);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    procedure SetPublisher(value : TFhirString);
    function GetPublisherST : String;
    procedure SetPublisherST(value : String);
    function GetContactList : TFhirContactDetailList;
    function GetHasContactList : Boolean;
    function GetUseContextList : TFhirUsageContextList;
    function GetHasUseContextList : Boolean;
    function GetJurisdictionList : TFhirCodeableConceptList;
    function GetHasJurisdictionList : Boolean;
    procedure SetCopyright(value : TFhirMarkdown);
    function GetCopyrightST : String;
    procedure SetCopyrightST(value : String);
    procedure SetPurpose(value : TFhirMarkdown);
    function GetPurposeST : String;
    procedure SetPurposeST(value : String);
    function GetActorList : TFhirExampleScenarioActorList;
    function GetHasActorList : Boolean;
    function GetInstanceList : TFhirExampleScenarioInstanceList;
    function GetHasInstanceList : Boolean;
    function GetProcessList : TFhirExampleScenarioProcessList;
    function GetHasProcessList : Boolean;
    function GetWorkflowList : TFhirCanonicalList;
    function GetHasWorkflowList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExampleScenario; overload;
    function Clone : TFhirExampleScenario; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An absolute URI that is used to identify this example scenario when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this example scenario is (or will be) published. This URL can be the target of a canonical reference. It SHALL remain the same when the example scenario is stored on different servers.
    property url : String read GetUrlST write SetUrlST;
    // An absolute URI that is used to identify this example scenario when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this example scenario is (or will be) published. This URL can be the target of a canonical reference. It SHALL remain the same when the example scenario is stored on different servers.
    property urlElement : TFhirUri read FUrl write SetUrl;

    // A formal identifier that is used to identify this example scenario when it is represented in other formats, or referenced in a specification, model, design or an instance.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The identifier that is used to identify this version of the example scenario when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the example scenario author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
    property version : String read GetVersionST write SetVersionST;
    // The identifier that is used to identify this version of the example scenario when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the example scenario author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to A natural language name identifying the example scenario. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property name : String read GetNameST write SetNameST;
    // A natural language name identifying the example scenario. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property nameElement : TFhirString read FName write SetName;

    // The status of this example scenario. Enables tracking the life-cycle of the content.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A Boolean value to indicate that this example scenario is authored for testing purposes (or education/evaluation/marketing) and is not intended to be used for genuine usage.
    property experimental : Boolean read GetExperimentalST write SetExperimentalST;
    // A Boolean value to indicate that this example scenario is authored for testing purposes (or education/evaluation/marketing) and is not intended to be used for genuine usage.
    property experimentalElement : TFhirBoolean read FExperimental write SetExperimental;

    // Typed access to The date  (and optionally time) when the example scenario was published. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the example scenario changes. (e.g. the 'content logical definition').
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date  (and optionally time) when the example scenario was published. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the example scenario changes. (e.g. the 'content logical definition').
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The name of the organization or individual that published the example scenario.
    property publisher : String read GetPublisherST write SetPublisherST;
    // The name of the organization or individual that published the example scenario.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Contact details to assist a user in finding and communicating with the publisher.
    property contactList : TFhirContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // The content was developed with a focus and intent of supporting the contexts that are listed. These contexts may be general categories (gender, age, ...) or may be references to specific programs (insurance plans, studies, ...) and may be used to assist with indexing and searching for appropriate example scenario instances.
    property useContextList : TFhirUsageContextList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // A legal or geographic region in which the example scenario is intended to be used.
    property jurisdictionList : TFhirCodeableConceptList read GetJurisdictionList;
    property hasJurisdictionList : boolean read GetHasJurisdictionList;

    // Typed access to A copyright statement relating to the example scenario and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the example scenario.
    property copyright : String read GetCopyrightST write SetCopyrightST;
    // A copyright statement relating to the example scenario and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the example scenario.
    property copyrightElement : TFhirMarkdown read FCopyright write SetCopyright;

    // Typed access to What the example scenario resource is created for. This should not be used to show the business purpose of the scenario itself, but the purpose of documenting a scenario.
    property purpose : String read GetPurposeST write SetPurposeST;
    // What the example scenario resource is created for. This should not be used to show the business purpose of the scenario itself, but the purpose of documenting a scenario.
    property purposeElement : TFhirMarkdown read FPurpose write SetPurpose;

    // Actor participating in the resource.
    property actorList : TFhirExampleScenarioActorList read GetActorList;
    property hasActorList : boolean read GetHasActorList;

    // Each resource and each version that is present in the workflow.
    property instanceList : TFhirExampleScenarioInstanceList read GetInstanceList;
    property hasInstanceList : boolean read GetHasInstanceList;

    // Each major process - a group of operations.
    property processList : TFhirExampleScenarioProcessList read GetProcessList;
    property hasProcessList : boolean read GetHasProcessList;

    // Another nested workflow.
    property workflowList : TFhirCanonicalList read GetWorkflowList;
    property hasWorkflowList : boolean read GetHasWorkflowList;

  end;

  TFhirExampleScenarioListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExampleScenarioList;
    function GetCurrent : TFhirExampleScenario;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirExampleScenarioList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExampleScenario read GetCurrent;
  end;

  TFhirExampleScenarioList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirExampleScenario;
    procedure SetItemN(index : Integer; value : TFhirExampleScenario);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirExampleScenarioList; overload;
    function Clone : TFhirExampleScenarioList; overload;
    function GetEnumerator : TFhirExampleScenarioListEnumerator;
    
    //  Add a FhirExampleScenario to the end of the list.
    function Append : TFhirExampleScenario;
    
    // Add an already existing FhirExampleScenario to the end of the list.
    function AddItem(value : TFhirExampleScenario) : TFhirExampleScenario; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExampleScenario) : Integer;
    
    // Insert FhirExampleScenario before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExampleScenario;
    
    // Insert an existing FhirExampleScenario before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExampleScenario);
    
    // Get the iIndexth FhirExampleScenario. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExampleScenario);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirExampleScenario;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirExampleScenarios[index : Integer] : TFhirExampleScenario read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_EXAMPLESCENARIO}
{$IFDEF FHIR_GRAPHDEFINITION}
  // Links this graph makes rules about.
  TFhirGraphDefinitionLink = class (TFhirBackboneElement)
  protected
    FPath : TFhirString;
    FSliceName : TFhirString;
    FMin : TFhirInteger;
    FMax : TFhirString;
    FDescription : TFhirString;
    FtargetList : TFhirGraphDefinitionLinkTargetList;
    procedure SetPath(value : TFhirString);
    function GetPathST : String;
    procedure SetPathST(value : String);
    procedure SetSliceName(value : TFhirString);
    function GetSliceNameST : String;
    procedure SetSliceNameST(value : String);
    procedure SetMin(value : TFhirInteger);
    function GetMinST : String;
    procedure SetMinST(value : String);
    procedure SetMax(value : TFhirString);
    function GetMaxST : String;
    procedure SetMaxST(value : String);
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetTargetList : TFhirGraphDefinitionLinkTargetList;
    function GetHasTargetList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirGraphDefinitionLink; overload;
    function Clone : TFhirGraphDefinitionLink; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A FHIR expression that identifies one of FHIR References to other resources.
    property path : String read GetPathST write SetPathST;
    // A FHIR expression that identifies one of FHIR References to other resources.
    property pathElement : TFhirString read FPath write SetPath;

    // Typed access to Which slice (if profiled).
    property sliceName : String read GetSliceNameST write SetSliceNameST;
    // Which slice (if profiled).
    property sliceNameElement : TFhirString read FSliceName write SetSliceName;

    // Typed access to Minimum occurrences for this link.
    property min : String read GetMinST write SetMinST;
    // Minimum occurrences for this link.
    property minElement : TFhirInteger read FMin write SetMin;

    // Typed access to Maximum occurrences for this link.
    property max : String read GetMaxST write SetMaxST;
    // Maximum occurrences for this link.
    property maxElement : TFhirString read FMax write SetMax;

    // Typed access to Information about why this link is of interest in this graph definition.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Information about why this link is of interest in this graph definition.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Potential target for the link.
    property targetList : TFhirGraphDefinitionLinkTargetList read GetTargetList;
    property hasTargetList : boolean read GetHasTargetList;

  end;

  TFhirGraphDefinitionLinkListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirGraphDefinitionLinkList;
    function GetCurrent : TFhirGraphDefinitionLink;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirGraphDefinitionLinkList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirGraphDefinitionLink read GetCurrent;
  end;

  TFhirGraphDefinitionLinkList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirGraphDefinitionLink;
    procedure SetItemN(index : Integer; value : TFhirGraphDefinitionLink);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirGraphDefinitionLinkList; overload;
    function Clone : TFhirGraphDefinitionLinkList; overload;
    function GetEnumerator : TFhirGraphDefinitionLinkListEnumerator;
    
    //  Add a FhirGraphDefinitionLink to the end of the list.
    function Append : TFhirGraphDefinitionLink;
    
    // Add an already existing FhirGraphDefinitionLink to the end of the list.
    function AddItem(value : TFhirGraphDefinitionLink) : TFhirGraphDefinitionLink; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirGraphDefinitionLink) : Integer;
    
    // Insert FhirGraphDefinitionLink before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirGraphDefinitionLink;
    
    // Insert an existing FhirGraphDefinitionLink before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirGraphDefinitionLink);
    
    // Get the iIndexth FhirGraphDefinitionLink. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirGraphDefinitionLink);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirGraphDefinitionLink;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirGraphDefinitionLinks[index : Integer] : TFhirGraphDefinitionLink read GetItemN write SetItemN; default;
  End;

  // Potential target for the link.
  TFhirGraphDefinitionLinkTarget = class (TFhirBackboneElement)
  protected
    FType_ : TFhirEnum;
    FParams : TFhirString;
    FProfile : TFhirCanonical;
    FcompartmentList : TFhirGraphDefinitionLinkTargetCompartmentList;
    Flink_List : TFhirGraphDefinitionLinkList;
    procedure SetType_(value : TFhirEnum);
    function GetType_ST : TFhirResourceTypesEnum;
    procedure SetType_ST(value : TFhirResourceTypesEnum);
    procedure SetParams(value : TFhirString);
    function GetParamsST : String;
    procedure SetParamsST(value : String);
    procedure SetProfile(value : TFhirCanonical);
    function GetProfileST : String;
    procedure SetProfileST(value : String);
    function GetCompartmentList : TFhirGraphDefinitionLinkTargetCompartmentList;
    function GetHasCompartmentList : Boolean;
    function GetLink_List : TFhirGraphDefinitionLinkList;
    function GetHasLink_List : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirGraphDefinitionLinkTarget; overload;
    function Clone : TFhirGraphDefinitionLinkTarget; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Type of resource this link refers to.
    property type_ : TFhirResourceTypesEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to A set of parameters to look up.
    property params : String read GetParamsST write SetParamsST;
    // A set of parameters to look up.
    property paramsElement : TFhirString read FParams write SetParams;

    // Typed access to Profile for the target resource.
    property profile : String read GetProfileST write SetProfileST;
    // Profile for the target resource.
    property profileElement : TFhirCanonical read FProfile write SetProfile;

    // Compartment Consistency Rules.
    property compartmentList : TFhirGraphDefinitionLinkTargetCompartmentList read GetCompartmentList;
    property hasCompartmentList : boolean read GetHasCompartmentList;

    // Additional links from target resource.
    property link_List : TFhirGraphDefinitionLinkList read GetLink_List;
    property hasLink_List : boolean read GetHasLink_List;

  end;

  TFhirGraphDefinitionLinkTargetListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirGraphDefinitionLinkTargetList;
    function GetCurrent : TFhirGraphDefinitionLinkTarget;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirGraphDefinitionLinkTargetList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirGraphDefinitionLinkTarget read GetCurrent;
  end;

  TFhirGraphDefinitionLinkTargetList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirGraphDefinitionLinkTarget;
    procedure SetItemN(index : Integer; value : TFhirGraphDefinitionLinkTarget);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirGraphDefinitionLinkTargetList; overload;
    function Clone : TFhirGraphDefinitionLinkTargetList; overload;
    function GetEnumerator : TFhirGraphDefinitionLinkTargetListEnumerator;
    
    //  Add a FhirGraphDefinitionLinkTarget to the end of the list.
    function Append : TFhirGraphDefinitionLinkTarget;
    
    // Add an already existing FhirGraphDefinitionLinkTarget to the end of the list.
    function AddItem(value : TFhirGraphDefinitionLinkTarget) : TFhirGraphDefinitionLinkTarget; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirGraphDefinitionLinkTarget) : Integer;
    
    // Insert FhirGraphDefinitionLinkTarget before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirGraphDefinitionLinkTarget;
    
    // Insert an existing FhirGraphDefinitionLinkTarget before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirGraphDefinitionLinkTarget);
    
    // Get the iIndexth FhirGraphDefinitionLinkTarget. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirGraphDefinitionLinkTarget);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirGraphDefinitionLinkTarget;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirGraphDefinitionLinkTargets[index : Integer] : TFhirGraphDefinitionLinkTarget read GetItemN write SetItemN; default;
  End;

  // Compartment Consistency Rules.
  TFhirGraphDefinitionLinkTargetCompartment = class (TFhirBackboneElement)
  protected
    FUse : TFhirEnum;
    FCode : TFhirEnum;
    FRule : TFhirEnum;
    FExpression : TFhirString;
    FDescription : TFhirString;
    procedure SetUse(value : TFhirEnum);
    function GetUseST : TFhirGraphCompartmentUseEnum;
    procedure SetUseST(value : TFhirGraphCompartmentUseEnum);
    procedure SetCode(value : TFhirEnum);
    function GetCodeST : TFhirCompartmentTypeEnum;
    procedure SetCodeST(value : TFhirCompartmentTypeEnum);
    procedure SetRule(value : TFhirEnum);
    function GetRuleST : TFhirGraphCompartmentRuleEnum;
    procedure SetRuleST(value : TFhirGraphCompartmentRuleEnum);
    procedure SetExpression(value : TFhirString);
    function GetExpressionST : String;
    procedure SetExpressionST(value : String);
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirGraphDefinitionLinkTargetCompartment; overload;
    function Clone : TFhirGraphDefinitionLinkTargetCompartment; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Defines how the compartment rule is used - whether it it is used to test whether resources are subject to the rule, or whether it is a rule that must be followed.
    property use : TFhirGraphCompartmentUseEnum read GetUseST write SetUseST;
    property useElement : TFhirEnum read FUse write SetUse;

    // Identifies the compartment.
    property code : TFhirCompartmentTypeEnum read GetCodeST write SetCodeST;
    property codeElement : TFhirEnum read FCode write SetCode;

    // identical | matching | different | no-rule | custom.
    property rule : TFhirGraphCompartmentRuleEnum read GetRuleST write SetRuleST;
    property ruleElement : TFhirEnum read FRule write SetRule;

    // Typed access to Custom rule, as a FHIRPath expression.
    property expression : String read GetExpressionST write SetExpressionST;
    // Custom rule, as a FHIRPath expression.
    property expressionElement : TFhirString read FExpression write SetExpression;

    // Typed access to Documentation for FHIRPath expression.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Documentation for FHIRPath expression.
    property descriptionElement : TFhirString read FDescription write SetDescription;

  end;

  TFhirGraphDefinitionLinkTargetCompartmentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirGraphDefinitionLinkTargetCompartmentList;
    function GetCurrent : TFhirGraphDefinitionLinkTargetCompartment;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirGraphDefinitionLinkTargetCompartmentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirGraphDefinitionLinkTargetCompartment read GetCurrent;
  end;

  TFhirGraphDefinitionLinkTargetCompartmentList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirGraphDefinitionLinkTargetCompartment;
    procedure SetItemN(index : Integer; value : TFhirGraphDefinitionLinkTargetCompartment);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirGraphDefinitionLinkTargetCompartmentList; overload;
    function Clone : TFhirGraphDefinitionLinkTargetCompartmentList; overload;
    function GetEnumerator : TFhirGraphDefinitionLinkTargetCompartmentListEnumerator;
    
    //  Add a FhirGraphDefinitionLinkTargetCompartment to the end of the list.
    function Append : TFhirGraphDefinitionLinkTargetCompartment;
    
    // Add an already existing FhirGraphDefinitionLinkTargetCompartment to the end of the list.
    function AddItem(value : TFhirGraphDefinitionLinkTargetCompartment) : TFhirGraphDefinitionLinkTargetCompartment; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirGraphDefinitionLinkTargetCompartment) : Integer;
    
    // Insert FhirGraphDefinitionLinkTargetCompartment before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirGraphDefinitionLinkTargetCompartment;
    
    // Insert an existing FhirGraphDefinitionLinkTargetCompartment before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirGraphDefinitionLinkTargetCompartment);
    
    // Get the iIndexth FhirGraphDefinitionLinkTargetCompartment. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirGraphDefinitionLinkTargetCompartment);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirGraphDefinitionLinkTargetCompartment;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirGraphDefinitionLinkTargetCompartments[index : Integer] : TFhirGraphDefinitionLinkTargetCompartment read GetItemN write SetItemN; default;
  End;

  // A formal computable definition of a graph of resources - that is, a coherent set of resources that form a graph by following references. The Graph Definition resource defines a set and makes rules about the set.
  TFhirGraphDefinition = class (TFhirDomainResource)
  protected
    FUrl : TFhirUri;
    FVersion : TFhirString;
    FName : TFhirString;
    FStatus : TFhirEnum;
    FExperimental : TFhirBoolean;
    FDate : TFhirDateTime;
    FPublisher : TFhirString;
    FcontactList : TFhirContactDetailList;
    FDescription : TFhirMarkdown;
    FuseContextList : TFhirUsageContextList;
    FjurisdictionList : TFhirCodeableConceptList;
    FPurpose : TFhirMarkdown;
    FStart : TFhirEnum;
    FProfile : TFhirCanonical;
    Flink_List : TFhirGraphDefinitionLinkList;
    procedure SetUrl(value : TFhirUri);
    function GetUrlST : String;
    procedure SetUrlST(value : String);
    procedure SetVersion(value : TFhirString);
    function GetVersionST : String;
    procedure SetVersionST(value : String);
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirPublicationStatusEnum;
    procedure SetStatusST(value : TFhirPublicationStatusEnum);
    procedure SetExperimental(value : TFhirBoolean);
    function GetExperimentalST : Boolean;
    procedure SetExperimentalST(value : Boolean);
    procedure SetDate(value : TFhirDateTime);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    procedure SetPublisher(value : TFhirString);
    function GetPublisherST : String;
    procedure SetPublisherST(value : String);
    function GetContactList : TFhirContactDetailList;
    function GetHasContactList : Boolean;
    procedure SetDescription(value : TFhirMarkdown);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetUseContextList : TFhirUsageContextList;
    function GetHasUseContextList : Boolean;
    function GetJurisdictionList : TFhirCodeableConceptList;
    function GetHasJurisdictionList : Boolean;
    procedure SetPurpose(value : TFhirMarkdown);
    function GetPurposeST : String;
    procedure SetPurposeST(value : String);
    procedure SetStart(value : TFhirEnum);
    function GetStartST : TFhirResourceTypesEnum;
    procedure SetStartST(value : TFhirResourceTypesEnum);
    procedure SetProfile(value : TFhirCanonical);
    function GetProfileST : String;
    procedure SetProfileST(value : String);
    function GetLink_List : TFhirGraphDefinitionLinkList;
    function GetHasLink_List : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirGraphDefinition; overload;
    function Clone : TFhirGraphDefinition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An absolute URI that is used to identify this graph definition when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this graph definition is (or will be) published. This URL can be the target of a canonical reference. It SHALL remain the same when the graph definition is stored on different servers.
    property url : String read GetUrlST write SetUrlST;
    // An absolute URI that is used to identify this graph definition when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this graph definition is (or will be) published. This URL can be the target of a canonical reference. It SHALL remain the same when the graph definition is stored on different servers.
    property urlElement : TFhirUri read FUrl write SetUrl;

    // Typed access to The identifier that is used to identify this version of the graph definition when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the graph definition author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
    property version : String read GetVersionST write SetVersionST;
    // The identifier that is used to identify this version of the graph definition when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the graph definition author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to A natural language name identifying the graph definition. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property name : String read GetNameST write SetNameST;
    // A natural language name identifying the graph definition. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property nameElement : TFhirString read FName write SetName;

    // The status of this graph definition. Enables tracking the life-cycle of the content.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A Boolean value to indicate that this graph definition is authored for testing purposes (or education/evaluation/marketing) and is not intended to be used for genuine usage.
    property experimental : Boolean read GetExperimentalST write SetExperimentalST;
    // A Boolean value to indicate that this graph definition is authored for testing purposes (or education/evaluation/marketing) and is not intended to be used for genuine usage.
    property experimentalElement : TFhirBoolean read FExperimental write SetExperimental;

    // Typed access to The date  (and optionally time) when the graph definition was published. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the graph definition changes.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date  (and optionally time) when the graph definition was published. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the graph definition changes.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The name of the organization or individual that published the graph definition.
    property publisher : String read GetPublisherST write SetPublisherST;
    // The name of the organization or individual that published the graph definition.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Contact details to assist a user in finding and communicating with the publisher.
    property contactList : TFhirContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to A free text natural language description of the graph definition from a consumer's perspective.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A free text natural language description of the graph definition from a consumer's perspective.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // The content was developed with a focus and intent of supporting the contexts that are listed. These contexts may be general categories (gender, age, ...) or may be references to specific programs (insurance plans, studies, ...) and may be used to assist with indexing and searching for appropriate graph definition instances.
    property useContextList : TFhirUsageContextList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // A legal or geographic region in which the graph definition is intended to be used.
    property jurisdictionList : TFhirCodeableConceptList read GetJurisdictionList;
    property hasJurisdictionList : boolean read GetHasJurisdictionList;

    // Typed access to Explanation of why this graph definition is needed and why it has been designed as it has.
    property purpose : String read GetPurposeST write SetPurposeST;
    // Explanation of why this graph definition is needed and why it has been designed as it has.
    property purposeElement : TFhirMarkdown read FPurpose write SetPurpose;

    // The type of FHIR resource at which instances of this graph start.
    property start : TFhirResourceTypesEnum read GetStartST write SetStartST;
    property startElement : TFhirEnum read FStart write SetStart;

    // Typed access to The profile that describes the use of the base resource.
    property profile : String read GetProfileST write SetProfileST;
    // The profile that describes the use of the base resource.
    property profileElement : TFhirCanonical read FProfile write SetProfile;

    // Links this graph makes rules about.
    property link_List : TFhirGraphDefinitionLinkList read GetLink_List;
    property hasLink_List : boolean read GetHasLink_List;

  end;

  TFhirGraphDefinitionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirGraphDefinitionList;
    function GetCurrent : TFhirGraphDefinition;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirGraphDefinitionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirGraphDefinition read GetCurrent;
  end;

  TFhirGraphDefinitionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirGraphDefinition;
    procedure SetItemN(index : Integer; value : TFhirGraphDefinition);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirGraphDefinitionList; overload;
    function Clone : TFhirGraphDefinitionList; overload;
    function GetEnumerator : TFhirGraphDefinitionListEnumerator;
    
    //  Add a FhirGraphDefinition to the end of the list.
    function Append : TFhirGraphDefinition;
    
    // Add an already existing FhirGraphDefinition to the end of the list.
    function AddItem(value : TFhirGraphDefinition) : TFhirGraphDefinition; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirGraphDefinition) : Integer;
    
    // Insert FhirGraphDefinition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirGraphDefinition;
    
    // Insert an existing FhirGraphDefinition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirGraphDefinition);
    
    // Get the iIndexth FhirGraphDefinition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirGraphDefinition);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirGraphDefinition;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirGraphDefinitions[index : Integer] : TFhirGraphDefinition read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_GRAPHDEFINITION}
{$IFDEF FHIR_IMPLEMENTATIONGUIDE}
  // Another implementation guide that this implementation depends on. Typically, an implementation guide uses value sets, profiles etc.defined in other implementation guides.
  TFhirImplementationGuideDependsOn = class (TFhirBackboneElement)
  protected
    FUri : TFhirCanonical;
    FPackageId : TFhirId;
    FVersion : TFhirString;
    procedure SetUri(value : TFhirCanonical);
    function GetUriST : String;
    procedure SetUriST(value : String);
    procedure SetPackageId(value : TFhirId);
    function GetPackageIdST : String;
    procedure SetPackageIdST(value : String);
    procedure SetVersion(value : TFhirString);
    function GetVersionST : String;
    procedure SetVersionST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImplementationGuideDependsOn; overload;
    function Clone : TFhirImplementationGuideDependsOn; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A canonical reference to the Implementation guide for the dependency.
    property uri : String read GetUriST write SetUriST;
    // A canonical reference to the Implementation guide for the dependency.
    property uriElement : TFhirCanonical read FUri write SetUri;

    // Typed access to The NPM package name for the Implementation Guide that this IG depends on.
    property packageId : String read GetPackageIdST write SetPackageIdST;
    // The NPM package name for the Implementation Guide that this IG depends on.
    property packageIdElement : TFhirId read FPackageId write SetPackageId;

    // Typed access to The version of the IG that is depended on, when the correct version is required to understand the IG correctly.
    property version : String read GetVersionST write SetVersionST;
    // The version of the IG that is depended on, when the correct version is required to understand the IG correctly.
    property versionElement : TFhirString read FVersion write SetVersion;

  end;

  TFhirImplementationGuideDependsOnListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImplementationGuideDependsOnList;
    function GetCurrent : TFhirImplementationGuideDependsOn;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirImplementationGuideDependsOnList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImplementationGuideDependsOn read GetCurrent;
  end;

  TFhirImplementationGuideDependsOnList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirImplementationGuideDependsOn;
    procedure SetItemN(index : Integer; value : TFhirImplementationGuideDependsOn);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirImplementationGuideDependsOnList; overload;
    function Clone : TFhirImplementationGuideDependsOnList; overload;
    function GetEnumerator : TFhirImplementationGuideDependsOnListEnumerator;
    
    //  Add a FhirImplementationGuideDependsOn to the end of the list.
    function Append : TFhirImplementationGuideDependsOn;
    
    // Add an already existing FhirImplementationGuideDependsOn to the end of the list.
    function AddItem(value : TFhirImplementationGuideDependsOn) : TFhirImplementationGuideDependsOn; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImplementationGuideDependsOn) : Integer;
    
    // Insert FhirImplementationGuideDependsOn before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImplementationGuideDependsOn;
    
    // Insert an existing FhirImplementationGuideDependsOn before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImplementationGuideDependsOn);
    
    // Get the iIndexth FhirImplementationGuideDependsOn. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImplementationGuideDependsOn);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirImplementationGuideDependsOn;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirImplementationGuideDependsOns[index : Integer] : TFhirImplementationGuideDependsOn read GetItemN write SetItemN; default;
  End;

  // A set of profiles that all resources covered by this implementation guide must conform to.
  TFhirImplementationGuideGlobal = class (TFhirBackboneElement)
  protected
    FType_ : TFhirEnum;
    FProfile : TFhirCanonical;
    procedure SetType_(value : TFhirEnum);
    function GetType_ST : TFhirResourceTypesEnum;
    procedure SetType_ST(value : TFhirResourceTypesEnum);
    procedure SetProfile(value : TFhirCanonical);
    function GetProfileST : String;
    procedure SetProfileST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImplementationGuideGlobal; overload;
    function Clone : TFhirImplementationGuideGlobal; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The type of resource that all instances must conform to.
    property type_ : TFhirResourceTypesEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to A reference to the profile that all instances must conform to.
    property profile : String read GetProfileST write SetProfileST;
    // A reference to the profile that all instances must conform to.
    property profileElement : TFhirCanonical read FProfile write SetProfile;

  end;

  TFhirImplementationGuideGlobalListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImplementationGuideGlobalList;
    function GetCurrent : TFhirImplementationGuideGlobal;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirImplementationGuideGlobalList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImplementationGuideGlobal read GetCurrent;
  end;

  TFhirImplementationGuideGlobalList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirImplementationGuideGlobal;
    procedure SetItemN(index : Integer; value : TFhirImplementationGuideGlobal);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirImplementationGuideGlobalList; overload;
    function Clone : TFhirImplementationGuideGlobalList; overload;
    function GetEnumerator : TFhirImplementationGuideGlobalListEnumerator;
    
    //  Add a FhirImplementationGuideGlobal to the end of the list.
    function Append : TFhirImplementationGuideGlobal;
    
    // Add an already existing FhirImplementationGuideGlobal to the end of the list.
    function AddItem(value : TFhirImplementationGuideGlobal) : TFhirImplementationGuideGlobal; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImplementationGuideGlobal) : Integer;
    
    // Insert FhirImplementationGuideGlobal before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImplementationGuideGlobal;
    
    // Insert an existing FhirImplementationGuideGlobal before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImplementationGuideGlobal);
    
    // Get the iIndexth FhirImplementationGuideGlobal. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImplementationGuideGlobal);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirImplementationGuideGlobal;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirImplementationGuideGlobals[index : Integer] : TFhirImplementationGuideGlobal read GetItemN write SetItemN; default;
  End;

  // The information needed by an IG publisher tool to publish the whole implementation guide.
  TFhirImplementationGuideDefinition = class (TFhirBackboneElement)
  protected
    FgroupingList : TFhirImplementationGuideDefinitionGroupingList;
    FresourceList : TFhirImplementationGuideDefinitionResourceList;
    FPage : TFhirImplementationGuideDefinitionPage;
    FparameterList : TFhirImplementationGuideDefinitionParameterList;
    FtemplateList : TFhirImplementationGuideDefinitionTemplateList;
    function GetGroupingList : TFhirImplementationGuideDefinitionGroupingList;
    function GetHasGroupingList : Boolean;
    function GetResourceList : TFhirImplementationGuideDefinitionResourceList;
    function GetHasResourceList : Boolean;
    procedure SetPage(value : TFhirImplementationGuideDefinitionPage);
    function GetParameterList : TFhirImplementationGuideDefinitionParameterList;
    function GetHasParameterList : Boolean;
    function GetTemplateList : TFhirImplementationGuideDefinitionTemplateList;
    function GetHasTemplateList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImplementationGuideDefinition; overload;
    function Clone : TFhirImplementationGuideDefinition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // A logical group of resources. Logical groups can be used when building pages.
    property groupingList : TFhirImplementationGuideDefinitionGroupingList read GetGroupingList;
    property hasGroupingList : boolean read GetHasGroupingList;

    // A resource that is part of the implementation guide. Conformance resources (value set, structure definition, capability statements etc.) are obvious candidates for inclusion, but any kind of resource can be included as an example resource.
    property resourceList : TFhirImplementationGuideDefinitionResourceList read GetResourceList;
    property hasResourceList : boolean read GetHasResourceList;

    // Typed access to A page / section in the implementation guide. The root page is the implementation guide home page. (defined for API consistency)
    property page : TFhirImplementationGuideDefinitionPage read FPage write SetPage;
    // A page / section in the implementation guide. The root page is the implementation guide home page.
    property pageElement : TFhirImplementationGuideDefinitionPage read FPage write SetPage;

    // Defines how IG is built by tools.
    property parameterList : TFhirImplementationGuideDefinitionParameterList read GetParameterList;
    property hasParameterList : boolean read GetHasParameterList;

    // A template for building resources.
    property templateList : TFhirImplementationGuideDefinitionTemplateList read GetTemplateList;
    property hasTemplateList : boolean read GetHasTemplateList;

  end;

  TFhirImplementationGuideDefinitionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImplementationGuideDefinitionList;
    function GetCurrent : TFhirImplementationGuideDefinition;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirImplementationGuideDefinitionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImplementationGuideDefinition read GetCurrent;
  end;

  TFhirImplementationGuideDefinitionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirImplementationGuideDefinition;
    procedure SetItemN(index : Integer; value : TFhirImplementationGuideDefinition);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirImplementationGuideDefinitionList; overload;
    function Clone : TFhirImplementationGuideDefinitionList; overload;
    function GetEnumerator : TFhirImplementationGuideDefinitionListEnumerator;
    
    //  Add a FhirImplementationGuideDefinition to the end of the list.
    function Append : TFhirImplementationGuideDefinition;
    
    // Add an already existing FhirImplementationGuideDefinition to the end of the list.
    function AddItem(value : TFhirImplementationGuideDefinition) : TFhirImplementationGuideDefinition; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImplementationGuideDefinition) : Integer;
    
    // Insert FhirImplementationGuideDefinition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImplementationGuideDefinition;
    
    // Insert an existing FhirImplementationGuideDefinition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImplementationGuideDefinition);
    
    // Get the iIndexth FhirImplementationGuideDefinition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImplementationGuideDefinition);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirImplementationGuideDefinition;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirImplementationGuideDefinitions[index : Integer] : TFhirImplementationGuideDefinition read GetItemN write SetItemN; default;
  End;

  // A logical group of resources. Logical groups can be used when building pages.
  TFhirImplementationGuideDefinitionGrouping = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FDescription : TFhirString;
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImplementationGuideDefinitionGrouping; overload;
    function Clone : TFhirImplementationGuideDefinitionGrouping; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The human-readable title to display for the package of resources when rendering the implementation guide.
    property name : String read GetNameST write SetNameST;
    // The human-readable title to display for the package of resources when rendering the implementation guide.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to Human readable text describing the package.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Human readable text describing the package.
    property descriptionElement : TFhirString read FDescription write SetDescription;

  end;

  TFhirImplementationGuideDefinitionGroupingListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImplementationGuideDefinitionGroupingList;
    function GetCurrent : TFhirImplementationGuideDefinitionGrouping;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirImplementationGuideDefinitionGroupingList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImplementationGuideDefinitionGrouping read GetCurrent;
  end;

  TFhirImplementationGuideDefinitionGroupingList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirImplementationGuideDefinitionGrouping;
    procedure SetItemN(index : Integer; value : TFhirImplementationGuideDefinitionGrouping);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirImplementationGuideDefinitionGroupingList; overload;
    function Clone : TFhirImplementationGuideDefinitionGroupingList; overload;
    function GetEnumerator : TFhirImplementationGuideDefinitionGroupingListEnumerator;
    
    //  Add a FhirImplementationGuideDefinitionGrouping to the end of the list.
    function Append : TFhirImplementationGuideDefinitionGrouping;
    
    // Add an already existing FhirImplementationGuideDefinitionGrouping to the end of the list.
    function AddItem(value : TFhirImplementationGuideDefinitionGrouping) : TFhirImplementationGuideDefinitionGrouping; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImplementationGuideDefinitionGrouping) : Integer;
    
    // Insert FhirImplementationGuideDefinitionGrouping before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImplementationGuideDefinitionGrouping;
    
    // Insert an existing FhirImplementationGuideDefinitionGrouping before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImplementationGuideDefinitionGrouping);
    
    // Get the iIndexth FhirImplementationGuideDefinitionGrouping. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImplementationGuideDefinitionGrouping);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirImplementationGuideDefinitionGrouping;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirImplementationGuideDefinitionGroupings[index : Integer] : TFhirImplementationGuideDefinitionGrouping read GetItemN write SetItemN; default;
  End;

  // A resource that is part of the implementation guide. Conformance resources (value set, structure definition, capability statements etc.) are obvious candidates for inclusion, but any kind of resource can be included as an example resource.
  TFhirImplementationGuideDefinitionResource = class (TFhirBackboneElement)
  protected
    FReference : TFhirReference;
    FFhirVersion : TFhirEnumList;
    FName : TFhirString;
    FDescription : TFhirString;
    FExample : TFhirDataType;
    FGroupingId : TFhirId;
    procedure SetReference(value : TFhirReference);
    function GetFhirVersion : TFhirEnumList;
    function GetHasFhirVersion : Boolean;
    function GetFhirVersionST : TFhirFHIRVersionEnumList;
    procedure SetFhirVersionST(value : TFhirFHIRVersionEnumList);
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetExample(value : TFhirDataType);
    procedure SetGroupingId(value : TFhirId);
    function GetGroupingIdST : String;
    procedure SetGroupingIdST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImplementationGuideDefinitionResource; overload;
    function Clone : TFhirImplementationGuideDefinitionResource; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Where this resource is found. (defined for API consistency)
    property reference : TFhirReference read FReference write SetReference;
    // Where this resource is found.
    property referenceElement : TFhirReference read FReference write SetReference;

    // Indicates the FHIR Version(s) this artifact is intended to apply to. If no versions are specified, the resource is assumed to apply to all the versions stated in ImplementationGuide.fhirVersion.
    property fhirVersion : TFhirFHIRVersionEnumList read GetFhirVersionST write SetFhirVersionST;
    property fhirVersionList : TFhirEnumList read GetFhirVersion;
    property hasFhirVersion : boolean read GetHasFhirVersion;
    // Typed access to A human assigned name for the resource. All resources SHOULD have a name, but the name may be extracted from the resource (e.g. ValueSet.name).
    property name : String read GetNameST write SetNameST;
    // A human assigned name for the resource. All resources SHOULD have a name, but the name may be extracted from the resource (e.g. ValueSet.name).
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A description of the reason that a resource has been included in the implementation guide.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A description of the reason that a resource has been included in the implementation guide.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to If true or a reference, indicates the resource is an example instance.  If a reference is present, indicates that the example is an example of the specified profile. (defined for API consistency)
    property example : TFhirDataType read FExample write SetExample;
    // If true or a reference, indicates the resource is an example instance.  If a reference is present, indicates that the example is an example of the specified profile.
    property exampleElement : TFhirDataType read FExample write SetExample;

    // Typed access to Reference to the id of the grouping this resource appears in.
    property groupingId : String read GetGroupingIdST write SetGroupingIdST;
    // Reference to the id of the grouping this resource appears in.
    property groupingIdElement : TFhirId read FGroupingId write SetGroupingId;

  end;

  TFhirImplementationGuideDefinitionResourceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImplementationGuideDefinitionResourceList;
    function GetCurrent : TFhirImplementationGuideDefinitionResource;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirImplementationGuideDefinitionResourceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImplementationGuideDefinitionResource read GetCurrent;
  end;

  TFhirImplementationGuideDefinitionResourceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirImplementationGuideDefinitionResource;
    procedure SetItemN(index : Integer; value : TFhirImplementationGuideDefinitionResource);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirImplementationGuideDefinitionResourceList; overload;
    function Clone : TFhirImplementationGuideDefinitionResourceList; overload;
    function GetEnumerator : TFhirImplementationGuideDefinitionResourceListEnumerator;
    
    //  Add a FhirImplementationGuideDefinitionResource to the end of the list.
    function Append : TFhirImplementationGuideDefinitionResource;
    
    // Add an already existing FhirImplementationGuideDefinitionResource to the end of the list.
    function AddItem(value : TFhirImplementationGuideDefinitionResource) : TFhirImplementationGuideDefinitionResource; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImplementationGuideDefinitionResource) : Integer;
    
    // Insert FhirImplementationGuideDefinitionResource before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImplementationGuideDefinitionResource;
    
    // Insert an existing FhirImplementationGuideDefinitionResource before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImplementationGuideDefinitionResource);
    
    // Get the iIndexth FhirImplementationGuideDefinitionResource. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImplementationGuideDefinitionResource);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirImplementationGuideDefinitionResource;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirImplementationGuideDefinitionResources[index : Integer] : TFhirImplementationGuideDefinitionResource read GetItemN write SetItemN; default;
  End;

  // A page / section in the implementation guide. The root page is the implementation guide home page.
  TFhirImplementationGuideDefinitionPage = class (TFhirBackboneElement)
  protected
    FName : TFhirDataType;
    FTitle : TFhirString;
    FGeneration : TFhirEnum;
    FpageList : TFhirImplementationGuideDefinitionPageList;
    procedure SetName(value : TFhirDataType);
    procedure SetTitle(value : TFhirString);
    function GetTitleST : String;
    procedure SetTitleST(value : String);
    procedure SetGeneration(value : TFhirEnum);
    function GetGenerationST : TFhirGuidePageGenerationEnum;
    procedure SetGenerationST(value : TFhirGuidePageGenerationEnum);
    function GetPageList : TFhirImplementationGuideDefinitionPageList;
    function GetHasPageList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImplementationGuideDefinitionPage; overload;
    function Clone : TFhirImplementationGuideDefinitionPage; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The source address for the page. (defined for API consistency)
    property name : TFhirDataType read FName write SetName;
    // The source address for the page.
    property nameElement : TFhirDataType read FName write SetName;

    // Typed access to A short title used to represent this page in navigational structures such as table of contents, bread crumbs, etc.
    property title : String read GetTitleST write SetTitleST;
    // A short title used to represent this page in navigational structures such as table of contents, bread crumbs, etc.
    property titleElement : TFhirString read FTitle write SetTitle;

    // A code that indicates how the page is generated.
    property generation : TFhirGuidePageGenerationEnum read GetGenerationST write SetGenerationST;
    property generationElement : TFhirEnum read FGeneration write SetGeneration;

    // Nested Pages/Sections under this page.
    property pageList : TFhirImplementationGuideDefinitionPageList read GetPageList;
    property hasPageList : boolean read GetHasPageList;

  end;

  TFhirImplementationGuideDefinitionPageListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImplementationGuideDefinitionPageList;
    function GetCurrent : TFhirImplementationGuideDefinitionPage;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirImplementationGuideDefinitionPageList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImplementationGuideDefinitionPage read GetCurrent;
  end;

  TFhirImplementationGuideDefinitionPageList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirImplementationGuideDefinitionPage;
    procedure SetItemN(index : Integer; value : TFhirImplementationGuideDefinitionPage);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirImplementationGuideDefinitionPageList; overload;
    function Clone : TFhirImplementationGuideDefinitionPageList; overload;
    function GetEnumerator : TFhirImplementationGuideDefinitionPageListEnumerator;
    
    //  Add a FhirImplementationGuideDefinitionPage to the end of the list.
    function Append : TFhirImplementationGuideDefinitionPage;
    
    // Add an already existing FhirImplementationGuideDefinitionPage to the end of the list.
    function AddItem(value : TFhirImplementationGuideDefinitionPage) : TFhirImplementationGuideDefinitionPage; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImplementationGuideDefinitionPage) : Integer;
    
    // Insert FhirImplementationGuideDefinitionPage before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImplementationGuideDefinitionPage;
    
    // Insert an existing FhirImplementationGuideDefinitionPage before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImplementationGuideDefinitionPage);
    
    // Get the iIndexth FhirImplementationGuideDefinitionPage. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImplementationGuideDefinitionPage);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirImplementationGuideDefinitionPage;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirImplementationGuideDefinitionPages[index : Integer] : TFhirImplementationGuideDefinitionPage read GetItemN write SetItemN; default;
  End;

  // Defines how IG is built by tools.
  TFhirImplementationGuideDefinitionParameter = class (TFhirBackboneElement)
  protected
    FCode : TFhirEnum;
    FValue : TFhirString;
    procedure SetCode(value : TFhirEnum);
    function GetCodeST : TFhirGuideParameterCodeEnum;
    procedure SetCodeST(value : TFhirGuideParameterCodeEnum);
    procedure SetValue(value : TFhirString);
    function GetValueST : String;
    procedure SetValueST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImplementationGuideDefinitionParameter; overload;
    function Clone : TFhirImplementationGuideDefinitionParameter; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // apply | path-resource | path-pages | path-tx-cache | expansion-parameter | rule-broken-links | generate-xml | generate-json | generate-turtle | html-template.
    property code : TFhirGuideParameterCodeEnum read GetCodeST write SetCodeST;
    property codeElement : TFhirEnum read FCode write SetCode;

    // Typed access to Value for named type.
    property value : String read GetValueST write SetValueST;
    // Value for named type.
    property valueElement : TFhirString read FValue write SetValue;

  end;

  TFhirImplementationGuideDefinitionParameterListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImplementationGuideDefinitionParameterList;
    function GetCurrent : TFhirImplementationGuideDefinitionParameter;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirImplementationGuideDefinitionParameterList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImplementationGuideDefinitionParameter read GetCurrent;
  end;

  TFhirImplementationGuideDefinitionParameterList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirImplementationGuideDefinitionParameter;
    procedure SetItemN(index : Integer; value : TFhirImplementationGuideDefinitionParameter);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirImplementationGuideDefinitionParameterList; overload;
    function Clone : TFhirImplementationGuideDefinitionParameterList; overload;
    function GetEnumerator : TFhirImplementationGuideDefinitionParameterListEnumerator;
    
    //  Add a FhirImplementationGuideDefinitionParameter to the end of the list.
    function Append : TFhirImplementationGuideDefinitionParameter;
    
    // Add an already existing FhirImplementationGuideDefinitionParameter to the end of the list.
    function AddItem(value : TFhirImplementationGuideDefinitionParameter) : TFhirImplementationGuideDefinitionParameter; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImplementationGuideDefinitionParameter) : Integer;
    
    // Insert FhirImplementationGuideDefinitionParameter before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImplementationGuideDefinitionParameter;
    
    // Insert an existing FhirImplementationGuideDefinitionParameter before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImplementationGuideDefinitionParameter);
    
    // Get the iIndexth FhirImplementationGuideDefinitionParameter. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImplementationGuideDefinitionParameter);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirImplementationGuideDefinitionParameter;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirImplementationGuideDefinitionParameters[index : Integer] : TFhirImplementationGuideDefinitionParameter read GetItemN write SetItemN; default;
  End;

  // A template for building resources.
  TFhirImplementationGuideDefinitionTemplate = class (TFhirBackboneElement)
  protected
    FCode : TFhirCode;
    FSource : TFhirString;
    FScope : TFhirString;
    procedure SetCode(value : TFhirCode);
    function GetCodeST : String;
    procedure SetCodeST(value : String);
    procedure SetSource(value : TFhirString);
    function GetSourceST : String;
    procedure SetSourceST(value : String);
    procedure SetScope(value : TFhirString);
    function GetScopeST : String;
    procedure SetScopeST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImplementationGuideDefinitionTemplate; overload;
    function Clone : TFhirImplementationGuideDefinitionTemplate; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Type of template specified.
    property code : String read GetCodeST write SetCodeST;
    // Type of template specified.
    property codeElement : TFhirCode read FCode write SetCode;

    // Typed access to The source location for the template.
    property source : String read GetSourceST write SetSourceST;
    // The source location for the template.
    property sourceElement : TFhirString read FSource write SetSource;

    // Typed access to The scope in which the template applies.
    property scope : String read GetScopeST write SetScopeST;
    // The scope in which the template applies.
    property scopeElement : TFhirString read FScope write SetScope;

  end;

  TFhirImplementationGuideDefinitionTemplateListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImplementationGuideDefinitionTemplateList;
    function GetCurrent : TFhirImplementationGuideDefinitionTemplate;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirImplementationGuideDefinitionTemplateList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImplementationGuideDefinitionTemplate read GetCurrent;
  end;

  TFhirImplementationGuideDefinitionTemplateList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirImplementationGuideDefinitionTemplate;
    procedure SetItemN(index : Integer; value : TFhirImplementationGuideDefinitionTemplate);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirImplementationGuideDefinitionTemplateList; overload;
    function Clone : TFhirImplementationGuideDefinitionTemplateList; overload;
    function GetEnumerator : TFhirImplementationGuideDefinitionTemplateListEnumerator;
    
    //  Add a FhirImplementationGuideDefinitionTemplate to the end of the list.
    function Append : TFhirImplementationGuideDefinitionTemplate;
    
    // Add an already existing FhirImplementationGuideDefinitionTemplate to the end of the list.
    function AddItem(value : TFhirImplementationGuideDefinitionTemplate) : TFhirImplementationGuideDefinitionTemplate; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImplementationGuideDefinitionTemplate) : Integer;
    
    // Insert FhirImplementationGuideDefinitionTemplate before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImplementationGuideDefinitionTemplate;
    
    // Insert an existing FhirImplementationGuideDefinitionTemplate before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImplementationGuideDefinitionTemplate);
    
    // Get the iIndexth FhirImplementationGuideDefinitionTemplate. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImplementationGuideDefinitionTemplate);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirImplementationGuideDefinitionTemplate;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirImplementationGuideDefinitionTemplates[index : Integer] : TFhirImplementationGuideDefinitionTemplate read GetItemN write SetItemN; default;
  End;

  // Information about an assembled implementation guide, created by the publication tooling.
  TFhirImplementationGuideManifest = class (TFhirBackboneElement)
  protected
    FRendering : TFhirUrl;
    FresourceList : TFhirImplementationGuideManifestResourceList;
    FpageList : TFhirImplementationGuideManifestPageList;
    FimageList : TFhirStringList;
    FotherList : TFhirStringList;
    procedure SetRendering(value : TFhirUrl);
    function GetRenderingST : String;
    procedure SetRenderingST(value : String);
    function GetResourceList : TFhirImplementationGuideManifestResourceList;
    function GetHasResourceList : Boolean;
    function GetPageList : TFhirImplementationGuideManifestPageList;
    function GetHasPageList : Boolean;
    function GetImageList : TFhirStringList;
    function GetHasImageList : Boolean;
    function GetOtherList : TFhirStringList;
    function GetHasOtherList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImplementationGuideManifest; overload;
    function Clone : TFhirImplementationGuideManifest; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A pointer to official web page, PDF or other rendering of the implementation guide.
    property rendering : String read GetRenderingST write SetRenderingST;
    // A pointer to official web page, PDF or other rendering of the implementation guide.
    property renderingElement : TFhirUrl read FRendering write SetRendering;

    // A resource that is part of the implementation guide. Conformance resources (value set, structure definition, capability statements etc.) are obvious candidates for inclusion, but any kind of resource can be included as an example resource.
    property resourceList : TFhirImplementationGuideManifestResourceList read GetResourceList;
    property hasResourceList : boolean read GetHasResourceList;

    // Information about a page within the IG.
    property pageList : TFhirImplementationGuideManifestPageList read GetPageList;
    property hasPageList : boolean read GetHasPageList;

    // Indicates a relative path to an image that exists within the IG.
    property imageList : TFhirStringList read GetImageList;
    property hasImageList : boolean read GetHasImageList;

    // Indicates the relative path of an additional non-page, non-image file that is part of the IG - e.g. zip, jar and similar files that could be the target of a hyperlink in a derived IG.
    property otherList : TFhirStringList read GetOtherList;
    property hasOtherList : boolean read GetHasOtherList;

  end;

  TFhirImplementationGuideManifestListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImplementationGuideManifestList;
    function GetCurrent : TFhirImplementationGuideManifest;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirImplementationGuideManifestList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImplementationGuideManifest read GetCurrent;
  end;

  TFhirImplementationGuideManifestList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirImplementationGuideManifest;
    procedure SetItemN(index : Integer; value : TFhirImplementationGuideManifest);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirImplementationGuideManifestList; overload;
    function Clone : TFhirImplementationGuideManifestList; overload;
    function GetEnumerator : TFhirImplementationGuideManifestListEnumerator;
    
    //  Add a FhirImplementationGuideManifest to the end of the list.
    function Append : TFhirImplementationGuideManifest;
    
    // Add an already existing FhirImplementationGuideManifest to the end of the list.
    function AddItem(value : TFhirImplementationGuideManifest) : TFhirImplementationGuideManifest; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImplementationGuideManifest) : Integer;
    
    // Insert FhirImplementationGuideManifest before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImplementationGuideManifest;
    
    // Insert an existing FhirImplementationGuideManifest before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImplementationGuideManifest);
    
    // Get the iIndexth FhirImplementationGuideManifest. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImplementationGuideManifest);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirImplementationGuideManifest;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirImplementationGuideManifests[index : Integer] : TFhirImplementationGuideManifest read GetItemN write SetItemN; default;
  End;

  // A resource that is part of the implementation guide. Conformance resources (value set, structure definition, capability statements etc.) are obvious candidates for inclusion, but any kind of resource can be included as an example resource.
  TFhirImplementationGuideManifestResource = class (TFhirBackboneElement)
  protected
    FReference : TFhirReference;
    FExample : TFhirDataType;
    FRelativePath : TFhirUrl;
    procedure SetReference(value : TFhirReference);
    procedure SetExample(value : TFhirDataType);
    procedure SetRelativePath(value : TFhirUrl);
    function GetRelativePathST : String;
    procedure SetRelativePathST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImplementationGuideManifestResource; overload;
    function Clone : TFhirImplementationGuideManifestResource; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Where this resource is found. (defined for API consistency)
    property reference : TFhirReference read FReference write SetReference;
    // Where this resource is found.
    property referenceElement : TFhirReference read FReference write SetReference;

    // Typed access to If true or a reference, indicates the resource is an example instance.  If a reference is present, indicates that the example is an example of the specified profile. (defined for API consistency)
    property example : TFhirDataType read FExample write SetExample;
    // If true or a reference, indicates the resource is an example instance.  If a reference is present, indicates that the example is an example of the specified profile.
    property exampleElement : TFhirDataType read FExample write SetExample;

    // Typed access to The relative path for primary page for this resource within the IG.
    property relativePath : String read GetRelativePathST write SetRelativePathST;
    // The relative path for primary page for this resource within the IG.
    property relativePathElement : TFhirUrl read FRelativePath write SetRelativePath;

  end;

  TFhirImplementationGuideManifestResourceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImplementationGuideManifestResourceList;
    function GetCurrent : TFhirImplementationGuideManifestResource;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirImplementationGuideManifestResourceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImplementationGuideManifestResource read GetCurrent;
  end;

  TFhirImplementationGuideManifestResourceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirImplementationGuideManifestResource;
    procedure SetItemN(index : Integer; value : TFhirImplementationGuideManifestResource);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirImplementationGuideManifestResourceList; overload;
    function Clone : TFhirImplementationGuideManifestResourceList; overload;
    function GetEnumerator : TFhirImplementationGuideManifestResourceListEnumerator;
    
    //  Add a FhirImplementationGuideManifestResource to the end of the list.
    function Append : TFhirImplementationGuideManifestResource;
    
    // Add an already existing FhirImplementationGuideManifestResource to the end of the list.
    function AddItem(value : TFhirImplementationGuideManifestResource) : TFhirImplementationGuideManifestResource; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImplementationGuideManifestResource) : Integer;
    
    // Insert FhirImplementationGuideManifestResource before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImplementationGuideManifestResource;
    
    // Insert an existing FhirImplementationGuideManifestResource before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImplementationGuideManifestResource);
    
    // Get the iIndexth FhirImplementationGuideManifestResource. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImplementationGuideManifestResource);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirImplementationGuideManifestResource;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirImplementationGuideManifestResources[index : Integer] : TFhirImplementationGuideManifestResource read GetItemN write SetItemN; default;
  End;

  // Information about a page within the IG.
  TFhirImplementationGuideManifestPage = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FTitle : TFhirString;
    FanchorList : TFhirStringList;
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetTitle(value : TFhirString);
    function GetTitleST : String;
    procedure SetTitleST(value : String);
    function GetAnchorList : TFhirStringList;
    function GetHasAnchorList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImplementationGuideManifestPage; overload;
    function Clone : TFhirImplementationGuideManifestPage; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Relative path to the page.
    property name : String read GetNameST write SetNameST;
    // Relative path to the page.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to Label for the page intended for human display.
    property title : String read GetTitleST write SetTitleST;
    // Label for the page intended for human display.
    property titleElement : TFhirString read FTitle write SetTitle;

    // The name of an anchor available on the page.
    property anchorList : TFhirStringList read GetAnchorList;
    property hasAnchorList : boolean read GetHasAnchorList;

  end;

  TFhirImplementationGuideManifestPageListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImplementationGuideManifestPageList;
    function GetCurrent : TFhirImplementationGuideManifestPage;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirImplementationGuideManifestPageList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImplementationGuideManifestPage read GetCurrent;
  end;

  TFhirImplementationGuideManifestPageList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirImplementationGuideManifestPage;
    procedure SetItemN(index : Integer; value : TFhirImplementationGuideManifestPage);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirImplementationGuideManifestPageList; overload;
    function Clone : TFhirImplementationGuideManifestPageList; overload;
    function GetEnumerator : TFhirImplementationGuideManifestPageListEnumerator;
    
    //  Add a FhirImplementationGuideManifestPage to the end of the list.
    function Append : TFhirImplementationGuideManifestPage;
    
    // Add an already existing FhirImplementationGuideManifestPage to the end of the list.
    function AddItem(value : TFhirImplementationGuideManifestPage) : TFhirImplementationGuideManifestPage; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImplementationGuideManifestPage) : Integer;
    
    // Insert FhirImplementationGuideManifestPage before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImplementationGuideManifestPage;
    
    // Insert an existing FhirImplementationGuideManifestPage before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImplementationGuideManifestPage);
    
    // Get the iIndexth FhirImplementationGuideManifestPage. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImplementationGuideManifestPage);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirImplementationGuideManifestPage;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirImplementationGuideManifestPages[index : Integer] : TFhirImplementationGuideManifestPage read GetItemN write SetItemN; default;
  End;

  // A set of rules of how a particular interoperability or standards problem is solved - typically through the use of FHIR resources. This resource is used to gather all the parts of an implementation guide into a logical whole and to publish a computable definition of all the parts.
  TFhirImplementationGuide = class (TFhirDomainResource)
  protected
    FUrl : TFhirUri;
    FVersion : TFhirString;
    FName : TFhirString;
    FTitle : TFhirString;
    FStatus : TFhirEnum;
    FExperimental : TFhirBoolean;
    FDate : TFhirDateTime;
    FPublisher : TFhirString;
    FcontactList : TFhirContactDetailList;
    FDescription : TFhirMarkdown;
    FuseContextList : TFhirUsageContextList;
    FjurisdictionList : TFhirCodeableConceptList;
    FCopyright : TFhirMarkdown;
    FPackageId : TFhirId;
    FLicense : TFhirEnum;
    FFhirVersion : TFhirEnumList;
    FdependsOnList : TFhirImplementationGuideDependsOnList;
    FglobalList : TFhirImplementationGuideGlobalList;
    FDefinition : TFhirImplementationGuideDefinition;
    FManifest : TFhirImplementationGuideManifest;
    procedure SetUrl(value : TFhirUri);
    function GetUrlST : String;
    procedure SetUrlST(value : String);
    procedure SetVersion(value : TFhirString);
    function GetVersionST : String;
    procedure SetVersionST(value : String);
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetTitle(value : TFhirString);
    function GetTitleST : String;
    procedure SetTitleST(value : String);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirPublicationStatusEnum;
    procedure SetStatusST(value : TFhirPublicationStatusEnum);
    procedure SetExperimental(value : TFhirBoolean);
    function GetExperimentalST : Boolean;
    procedure SetExperimentalST(value : Boolean);
    procedure SetDate(value : TFhirDateTime);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    procedure SetPublisher(value : TFhirString);
    function GetPublisherST : String;
    procedure SetPublisherST(value : String);
    function GetContactList : TFhirContactDetailList;
    function GetHasContactList : Boolean;
    procedure SetDescription(value : TFhirMarkdown);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetUseContextList : TFhirUsageContextList;
    function GetHasUseContextList : Boolean;
    function GetJurisdictionList : TFhirCodeableConceptList;
    function GetHasJurisdictionList : Boolean;
    procedure SetCopyright(value : TFhirMarkdown);
    function GetCopyrightST : String;
    procedure SetCopyrightST(value : String);
    procedure SetPackageId(value : TFhirId);
    function GetPackageIdST : String;
    procedure SetPackageIdST(value : String);
    procedure SetLicense(value : TFhirEnum);
    function GetLicenseST : TFhirSPDXLicenseEnum;
    procedure SetLicenseST(value : TFhirSPDXLicenseEnum);
    function GetFhirVersion : TFhirEnumList;
    function GetHasFhirVersion : Boolean;
    function GetFhirVersionST : TFhirFHIRVersionEnumList;
    procedure SetFhirVersionST(value : TFhirFHIRVersionEnumList);
    function GetDependsOnList : TFhirImplementationGuideDependsOnList;
    function GetHasDependsOnList : Boolean;
    function GetGlobalList : TFhirImplementationGuideGlobalList;
    function GetHasGlobalList : Boolean;
    procedure SetDefinition(value : TFhirImplementationGuideDefinition);
    procedure SetManifest(value : TFhirImplementationGuideManifest);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImplementationGuide; overload;
    function Clone : TFhirImplementationGuide; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An absolute URI that is used to identify this implementation guide when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this implementation guide is (or will be) published. This URL can be the target of a canonical reference. It SHALL remain the same when the implementation guide is stored on different servers.
    property url : String read GetUrlST write SetUrlST;
    // An absolute URI that is used to identify this implementation guide when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this implementation guide is (or will be) published. This URL can be the target of a canonical reference. It SHALL remain the same when the implementation guide is stored on different servers.
    property urlElement : TFhirUri read FUrl write SetUrl;

    // Typed access to The identifier that is used to identify this version of the implementation guide when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the implementation guide author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
    property version : String read GetVersionST write SetVersionST;
    // The identifier that is used to identify this version of the implementation guide when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the implementation guide author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to A natural language name identifying the implementation guide. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property name : String read GetNameST write SetNameST;
    // A natural language name identifying the implementation guide. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A short, descriptive, user-friendly title for the implementation guide.
    property title : String read GetTitleST write SetTitleST;
    // A short, descriptive, user-friendly title for the implementation guide.
    property titleElement : TFhirString read FTitle write SetTitle;

    // The status of this implementation guide. Enables tracking the life-cycle of the content.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A Boolean value to indicate that this implementation guide is authored for testing purposes (or education/evaluation/marketing) and is not intended to be used for genuine usage.
    property experimental : Boolean read GetExperimentalST write SetExperimentalST;
    // A Boolean value to indicate that this implementation guide is authored for testing purposes (or education/evaluation/marketing) and is not intended to be used for genuine usage.
    property experimentalElement : TFhirBoolean read FExperimental write SetExperimental;

    // Typed access to The date  (and optionally time) when the implementation guide was published. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the implementation guide changes.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date  (and optionally time) when the implementation guide was published. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the implementation guide changes.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The name of the organization or individual that published the implementation guide.
    property publisher : String read GetPublisherST write SetPublisherST;
    // The name of the organization or individual that published the implementation guide.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Contact details to assist a user in finding and communicating with the publisher.
    property contactList : TFhirContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to A free text natural language description of the implementation guide from a consumer's perspective.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A free text natural language description of the implementation guide from a consumer's perspective.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // The content was developed with a focus and intent of supporting the contexts that are listed. These contexts may be general categories (gender, age, ...) or may be references to specific programs (insurance plans, studies, ...) and may be used to assist with indexing and searching for appropriate implementation guide instances.
    property useContextList : TFhirUsageContextList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // A legal or geographic region in which the implementation guide is intended to be used.
    property jurisdictionList : TFhirCodeableConceptList read GetJurisdictionList;
    property hasJurisdictionList : boolean read GetHasJurisdictionList;

    // Typed access to A copyright statement relating to the implementation guide and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the implementation guide.
    property copyright : String read GetCopyrightST write SetCopyrightST;
    // A copyright statement relating to the implementation guide and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the implementation guide.
    property copyrightElement : TFhirMarkdown read FCopyright write SetCopyright;

    // Typed access to The NPM package name for this Implementation Guide, used in the NPM package distribution, which is the primary mechanism by which FHIR based tooling manages IG dependencies. This value must be globally unique, and should be assigned with care.
    property packageId : String read GetPackageIdST write SetPackageIdST;
    // The NPM package name for this Implementation Guide, used in the NPM package distribution, which is the primary mechanism by which FHIR based tooling manages IG dependencies. This value must be globally unique, and should be assigned with care.
    property packageIdElement : TFhirId read FPackageId write SetPackageId;

    // The license that applies to this Implementation Guide, using an SPDX license code, or 'not-open-source'.
    property license : TFhirSPDXLicenseEnum read GetLicenseST write SetLicenseST;
    property licenseElement : TFhirEnum read FLicense write SetLicense;

    // The version(s) of the FHIR specification that this ImplementationGuide targets - e.g. describes how to use. The value of this element is the formal version of the specification, without the revision number, e.g. [publication].[major].[minor], which is 4.3.0-snapshot1. for this version.
    property fhirVersion : TFhirFHIRVersionEnumList read GetFhirVersionST write SetFhirVersionST;
    property fhirVersionList : TFhirEnumList read GetFhirVersion;
    property hasFhirVersion : boolean read GetHasFhirVersion;
    // Another implementation guide that this implementation depends on. Typically, an implementation guide uses value sets, profiles etc.defined in other implementation guides.
    property dependsOnList : TFhirImplementationGuideDependsOnList read GetDependsOnList;
    property hasDependsOnList : boolean read GetHasDependsOnList;

    // A set of profiles that all resources covered by this implementation guide must conform to.
    property globalList : TFhirImplementationGuideGlobalList read GetGlobalList;
    property hasGlobalList : boolean read GetHasGlobalList;

    // Typed access to The information needed by an IG publisher tool to publish the whole implementation guide. (defined for API consistency)
    property definition : TFhirImplementationGuideDefinition read FDefinition write SetDefinition;
    // The information needed by an IG publisher tool to publish the whole implementation guide.
    property definitionElement : TFhirImplementationGuideDefinition read FDefinition write SetDefinition;

    // Typed access to Information about an assembled implementation guide, created by the publication tooling. (defined for API consistency)
    property manifest : TFhirImplementationGuideManifest read FManifest write SetManifest;
    // Information about an assembled implementation guide, created by the publication tooling.
    property manifestElement : TFhirImplementationGuideManifest read FManifest write SetManifest;

  end;

  TFhirImplementationGuideListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImplementationGuideList;
    function GetCurrent : TFhirImplementationGuide;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirImplementationGuideList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImplementationGuide read GetCurrent;
  end;

  TFhirImplementationGuideList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirImplementationGuide;
    procedure SetItemN(index : Integer; value : TFhirImplementationGuide);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirImplementationGuideList; overload;
    function Clone : TFhirImplementationGuideList; overload;
    function GetEnumerator : TFhirImplementationGuideListEnumerator;
    
    //  Add a FhirImplementationGuide to the end of the list.
    function Append : TFhirImplementationGuide;
    
    // Add an already existing FhirImplementationGuide to the end of the list.
    function AddItem(value : TFhirImplementationGuide) : TFhirImplementationGuide; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImplementationGuide) : Integer;
    
    // Insert FhirImplementationGuide before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImplementationGuide;
    
    // Insert an existing FhirImplementationGuide before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImplementationGuide);
    
    // Get the iIndexth FhirImplementationGuide. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImplementationGuide);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirImplementationGuide;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirImplementationGuides[index : Integer] : TFhirImplementationGuide read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_IMPLEMENTATIONGUIDE}
{$IFDEF FHIR_LIBRARY}
  // The Library resource is a general-purpose container for knowledge asset definitions. It can be used to describe and expose existing knowledge assets such as logic libraries and information model descriptions, as well as to describe a collection of knowledge assets.
  TFhirLibrary = class (TFhirDomainResource)
  protected
    FUrl : TFhirUri;
    FidentifierList : TFhirIdentifierList;
    FVersion : TFhirString;
    FName : TFhirString;
    FTitle : TFhirString;
    FSubtitle : TFhirString;
    FStatus : TFhirEnum;
    FExperimental : TFhirBoolean;
    FType_ : TFhirCodeableConcept;
    FSubject : TFhirDataType;
    FDate : TFhirDateTime;
    FPublisher : TFhirString;
    FcontactList : TFhirContactDetailList;
    FDescription : TFhirMarkdown;
    FuseContextList : TFhirUsageContextList;
    FjurisdictionList : TFhirCodeableConceptList;
    FPurpose : TFhirMarkdown;
    FUsage : TFhirString;
    FCopyright : TFhirMarkdown;
    FApprovalDate : TFhirDate;
    FLastReviewDate : TFhirDate;
    FEffectivePeriod : TFhirPeriod;
    FtopicList : TFhirCodeableConceptList;
    FauthorList : TFhirContactDetailList;
    FeditorList : TFhirContactDetailList;
    FreviewerList : TFhirContactDetailList;
    FendorserList : TFhirContactDetailList;
    FrelatedArtifactList : TFhirRelatedArtifactList;
    FparameterList : TFhirParameterDefinitionList;
    FdataRequirementList : TFhirDataRequirementList;
    FcontentList : TFhirAttachmentList;
    procedure SetUrl(value : TFhirUri);
    function GetUrlST : String;
    procedure SetUrlST(value : String);
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetVersion(value : TFhirString);
    function GetVersionST : String;
    procedure SetVersionST(value : String);
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetTitle(value : TFhirString);
    function GetTitleST : String;
    procedure SetTitleST(value : String);
    procedure SetSubtitle(value : TFhirString);
    function GetSubtitleST : String;
    procedure SetSubtitleST(value : String);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirPublicationStatusEnum;
    procedure SetStatusST(value : TFhirPublicationStatusEnum);
    procedure SetExperimental(value : TFhirBoolean);
    function GetExperimentalST : Boolean;
    procedure SetExperimentalST(value : Boolean);
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetSubject(value : TFhirDataType);
    procedure SetDate(value : TFhirDateTime);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    procedure SetPublisher(value : TFhirString);
    function GetPublisherST : String;
    procedure SetPublisherST(value : String);
    function GetContactList : TFhirContactDetailList;
    function GetHasContactList : Boolean;
    procedure SetDescription(value : TFhirMarkdown);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetUseContextList : TFhirUsageContextList;
    function GetHasUseContextList : Boolean;
    function GetJurisdictionList : TFhirCodeableConceptList;
    function GetHasJurisdictionList : Boolean;
    procedure SetPurpose(value : TFhirMarkdown);
    function GetPurposeST : String;
    procedure SetPurposeST(value : String);
    procedure SetUsage(value : TFhirString);
    function GetUsageST : String;
    procedure SetUsageST(value : String);
    procedure SetCopyright(value : TFhirMarkdown);
    function GetCopyrightST : String;
    procedure SetCopyrightST(value : String);
    procedure SetApprovalDate(value : TFhirDate);
    function GetApprovalDateST : TFslDateTime;
    procedure SetApprovalDateST(value : TFslDateTime);
    procedure SetLastReviewDate(value : TFhirDate);
    function GetLastReviewDateST : TFslDateTime;
    procedure SetLastReviewDateST(value : TFslDateTime);
    procedure SetEffectivePeriod(value : TFhirPeriod);
    function GetTopicList : TFhirCodeableConceptList;
    function GetHasTopicList : Boolean;
    function GetAuthorList : TFhirContactDetailList;
    function GetHasAuthorList : Boolean;
    function GetEditorList : TFhirContactDetailList;
    function GetHasEditorList : Boolean;
    function GetReviewerList : TFhirContactDetailList;
    function GetHasReviewerList : Boolean;
    function GetEndorserList : TFhirContactDetailList;
    function GetHasEndorserList : Boolean;
    function GetRelatedArtifactList : TFhirRelatedArtifactList;
    function GetHasRelatedArtifactList : Boolean;
    function GetParameterList : TFhirParameterDefinitionList;
    function GetHasParameterList : Boolean;
    function GetDataRequirementList : TFhirDataRequirementList;
    function GetHasDataRequirementList : Boolean;
    function GetContentList : TFhirAttachmentList;
    function GetHasContentList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirLibrary; overload;
    function Clone : TFhirLibrary; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An absolute URI that is used to identify this library when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this library is (or will be) published. This URL can be the target of a canonical reference. It SHALL remain the same when the library is stored on different servers.
    property url : String read GetUrlST write SetUrlST;
    // An absolute URI that is used to identify this library when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this library is (or will be) published. This URL can be the target of a canonical reference. It SHALL remain the same when the library is stored on different servers.
    property urlElement : TFhirUri read FUrl write SetUrl;

    // A formal identifier that is used to identify this library when it is represented in other formats, or referenced in a specification, model, design or an instance. e.g. CMS or NQF identifiers for a measure artifact. Note that at least one identifier is required for non-experimental active artifacts.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The identifier that is used to identify this version of the library when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the library author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence. To provide a version consistent with the Decision Support Service specification, use the format Major.Minor.Revision (e.g. 1.0.0). For more information on versioning knowledge assets, refer to the Decision Support Service specification. Note that a version is required for non-experimental active artifacts.
    property version : String read GetVersionST write SetVersionST;
    // The identifier that is used to identify this version of the library when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the library author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence. To provide a version consistent with the Decision Support Service specification, use the format Major.Minor.Revision (e.g. 1.0.0). For more information on versioning knowledge assets, refer to the Decision Support Service specification. Note that a version is required for non-experimental active artifacts.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to A natural language name identifying the library. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property name : String read GetNameST write SetNameST;
    // A natural language name identifying the library. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A short, descriptive, user-friendly title for the library.
    property title : String read GetTitleST write SetTitleST;
    // A short, descriptive, user-friendly title for the library.
    property titleElement : TFhirString read FTitle write SetTitle;

    // Typed access to An explanatory or alternate title for the library giving additional information about its content.
    property subtitle : String read GetSubtitleST write SetSubtitleST;
    // An explanatory or alternate title for the library giving additional information about its content.
    property subtitleElement : TFhirString read FSubtitle write SetSubtitle;

    // The status of this library. Enables tracking the life-cycle of the content.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A Boolean value to indicate that this library is authored for testing purposes (or education/evaluation/marketing) and is not intended to be used for genuine usage.
    property experimental : Boolean read GetExperimentalST write SetExperimentalST;
    // A Boolean value to indicate that this library is authored for testing purposes (or education/evaluation/marketing) and is not intended to be used for genuine usage.
    property experimentalElement : TFhirBoolean read FExperimental write SetExperimental;

    // Typed access to Identifies the type of library such as a Logic Library, Model Definition, Asset Collection, or Module Definition. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Identifies the type of library such as a Logic Library, Model Definition, Asset Collection, or Module Definition.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to A code or group definition that describes the intended subject of the contents of the library. (defined for API consistency)
    property subject : TFhirDataType read FSubject write SetSubject;
    // A code or group definition that describes the intended subject of the contents of the library.
    property subjectElement : TFhirDataType read FSubject write SetSubject;

    // Typed access to The date  (and optionally time) when the library was published. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the library changes.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date  (and optionally time) when the library was published. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the library changes.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The name of the organization or individual that published the library.
    property publisher : String read GetPublisherST write SetPublisherST;
    // The name of the organization or individual that published the library.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Contact details to assist a user in finding and communicating with the publisher.
    property contactList : TFhirContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to A free text natural language description of the library from a consumer's perspective.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A free text natural language description of the library from a consumer's perspective.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // The content was developed with a focus and intent of supporting the contexts that are listed. These contexts may be general categories (gender, age, ...) or may be references to specific programs (insurance plans, studies, ...) and may be used to assist with indexing and searching for appropriate library instances.
    property useContextList : TFhirUsageContextList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // A legal or geographic region in which the library is intended to be used.
    property jurisdictionList : TFhirCodeableConceptList read GetJurisdictionList;
    property hasJurisdictionList : boolean read GetHasJurisdictionList;

    // Typed access to Explanation of why this library is needed and why it has been designed as it has.
    property purpose : String read GetPurposeST write SetPurposeST;
    // Explanation of why this library is needed and why it has been designed as it has.
    property purposeElement : TFhirMarkdown read FPurpose write SetPurpose;

    // Typed access to A detailed description of how the library is used from a clinical perspective.
    property usage : String read GetUsageST write SetUsageST;
    // A detailed description of how the library is used from a clinical perspective.
    property usageElement : TFhirString read FUsage write SetUsage;

    // Typed access to A copyright statement relating to the library and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the library.
    property copyright : String read GetCopyrightST write SetCopyrightST;
    // A copyright statement relating to the library and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the library.
    property copyrightElement : TFhirMarkdown read FCopyright write SetCopyright;

    // Typed access to The date on which the resource content was approved by the publisher. Approval happens once when the content is officially approved for usage.
    property approvalDate : TFslDateTime read GetApprovalDateST write SetApprovalDateST;
    // The date on which the resource content was approved by the publisher. Approval happens once when the content is officially approved for usage.
    property approvalDateElement : TFhirDate read FApprovalDate write SetApprovalDate;

    // Typed access to The date on which the resource content was last reviewed. Review happens periodically after approval but does not change the original approval date.
    property lastReviewDate : TFslDateTime read GetLastReviewDateST write SetLastReviewDateST;
    // The date on which the resource content was last reviewed. Review happens periodically after approval but does not change the original approval date.
    property lastReviewDateElement : TFhirDate read FLastReviewDate write SetLastReviewDate;

    // Typed access to The period during which the library content was or is planned to be in active use. (defined for API consistency)
    property effectivePeriod : TFhirPeriod read FEffectivePeriod write SetEffectivePeriod;
    // The period during which the library content was or is planned to be in active use.
    property effectivePeriodElement : TFhirPeriod read FEffectivePeriod write SetEffectivePeriod;

    // Descriptive topics related to the content of the library. Topics provide a high-level categorization of the library that can be useful for filtering and searching.
    property topicList : TFhirCodeableConceptList read GetTopicList;
    property hasTopicList : boolean read GetHasTopicList;

    // An individiual or organization primarily involved in the creation and maintenance of the content.
    property authorList : TFhirContactDetailList read GetAuthorList;
    property hasAuthorList : boolean read GetHasAuthorList;

    // An individual or organization primarily responsible for internal coherence of the content.
    property editorList : TFhirContactDetailList read GetEditorList;
    property hasEditorList : boolean read GetHasEditorList;

    // An individual or organization primarily responsible for review of some aspect of the content.
    property reviewerList : TFhirContactDetailList read GetReviewerList;
    property hasReviewerList : boolean read GetHasReviewerList;

    // An individual or organization responsible for officially endorsing the content for use in some setting.
    property endorserList : TFhirContactDetailList read GetEndorserList;
    property hasEndorserList : boolean read GetHasEndorserList;

    // Related artifacts such as additional documentation, justification, or bibliographic references.
    property relatedArtifactList : TFhirRelatedArtifactList read GetRelatedArtifactList;
    property hasRelatedArtifactList : boolean read GetHasRelatedArtifactList;

    // The parameter element defines parameters used by the library.
    property parameterList : TFhirParameterDefinitionList read GetParameterList;
    property hasParameterList : boolean read GetHasParameterList;

    // Describes a set of data that must be provided in order to be able to successfully perform the computations defined by the library.
    property dataRequirementList : TFhirDataRequirementList read GetDataRequirementList;
    property hasDataRequirementList : boolean read GetHasDataRequirementList;

    // The content of the library as an Attachment. The content may be a reference to a url, or may be directly embedded as a base-64 string. Either way, the contentType of the attachment determines how to interpret the content.
    property contentList : TFhirAttachmentList read GetContentList;
    property hasContentList : boolean read GetHasContentList;

  end;

  TFhirLibraryListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirLibraryList;
    function GetCurrent : TFhirLibrary;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirLibraryList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirLibrary read GetCurrent;
  end;

  TFhirLibraryList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirLibrary;
    procedure SetItemN(index : Integer; value : TFhirLibrary);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirLibraryList; overload;
    function Clone : TFhirLibraryList; overload;
    function GetEnumerator : TFhirLibraryListEnumerator;
    
    //  Add a FhirLibrary to the end of the list.
    function Append : TFhirLibrary;
    
    // Add an already existing FhirLibrary to the end of the list.
    function AddItem(value : TFhirLibrary) : TFhirLibrary; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirLibrary) : Integer;
    
    // Insert FhirLibrary before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirLibrary;
    
    // Insert an existing FhirLibrary before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirLibrary);
    
    // Get the iIndexth FhirLibrary. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirLibrary);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirLibrary;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirLibraries[index : Integer] : TFhirLibrary read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_LIBRARY}
{$IFDEF FHIR_MEASURE}
  // A group of population criteria for the measure.
  TFhirMeasureGroup = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    FDescription : TFhirString;
    FpopulationList : TFhirMeasureGroupPopulationList;
    FstratifierList : TFhirMeasureGroupStratifierList;
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetPopulationList : TFhirMeasureGroupPopulationList;
    function GetHasPopulationList : Boolean;
    function GetStratifierList : TFhirMeasureGroupStratifierList;
    function GetHasStratifierList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMeasureGroup; overload;
    function Clone : TFhirMeasureGroup; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Indicates a meaning for the group. This can be as simple as a unique identifier, or it can establish meaning in a broader context by drawing from a terminology, allowing groups to be correlated across measures. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // Indicates a meaning for the group. This can be as simple as a unique identifier, or it can establish meaning in a broader context by drawing from a terminology, allowing groups to be correlated across measures.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The human readable description of this population group.
    property description : String read GetDescriptionST write SetDescriptionST;
    // The human readable description of this population group.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // A population criteria for the measure.
    property populationList : TFhirMeasureGroupPopulationList read GetPopulationList;
    property hasPopulationList : boolean read GetHasPopulationList;

    // The stratifier criteria for the measure report, specified as either the name of a valid CQL expression defined within a referenced library or a valid FHIR Resource Path.
    property stratifierList : TFhirMeasureGroupStratifierList read GetStratifierList;
    property hasStratifierList : boolean read GetHasStratifierList;

  end;

  TFhirMeasureGroupListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMeasureGroupList;
    function GetCurrent : TFhirMeasureGroup;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMeasureGroupList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMeasureGroup read GetCurrent;
  end;

  TFhirMeasureGroupList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMeasureGroup;
    procedure SetItemN(index : Integer; value : TFhirMeasureGroup);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMeasureGroupList; overload;
    function Clone : TFhirMeasureGroupList; overload;
    function GetEnumerator : TFhirMeasureGroupListEnumerator;
    
    //  Add a FhirMeasureGroup to the end of the list.
    function Append : TFhirMeasureGroup;
    
    // Add an already existing FhirMeasureGroup to the end of the list.
    function AddItem(value : TFhirMeasureGroup) : TFhirMeasureGroup; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMeasureGroup) : Integer;
    
    // Insert FhirMeasureGroup before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMeasureGroup;
    
    // Insert an existing FhirMeasureGroup before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMeasureGroup);
    
    // Get the iIndexth FhirMeasureGroup. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMeasureGroup);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMeasureGroup;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMeasureGroups[index : Integer] : TFhirMeasureGroup read GetItemN write SetItemN; default;
  End;

  // A population criteria for the measure.
  TFhirMeasureGroupPopulation = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    FDescription : TFhirString;
    FCriteria : TFhirExpression;
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetCriteria(value : TFhirExpression);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMeasureGroupPopulation; overload;
    function Clone : TFhirMeasureGroupPopulation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The type of population criteria. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // The type of population criteria.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The human readable description of this population criteria.
    property description : String read GetDescriptionST write SetDescriptionST;
    // The human readable description of this population criteria.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to An expression that specifies the criteria for the population, typically the name of an expression in a library. (defined for API consistency)
    property criteria : TFhirExpression read FCriteria write SetCriteria;
    // An expression that specifies the criteria for the population, typically the name of an expression in a library.
    property criteriaElement : TFhirExpression read FCriteria write SetCriteria;

  end;

  TFhirMeasureGroupPopulationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMeasureGroupPopulationList;
    function GetCurrent : TFhirMeasureGroupPopulation;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMeasureGroupPopulationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMeasureGroupPopulation read GetCurrent;
  end;

  TFhirMeasureGroupPopulationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMeasureGroupPopulation;
    procedure SetItemN(index : Integer; value : TFhirMeasureGroupPopulation);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMeasureGroupPopulationList; overload;
    function Clone : TFhirMeasureGroupPopulationList; overload;
    function GetEnumerator : TFhirMeasureGroupPopulationListEnumerator;
    
    //  Add a FhirMeasureGroupPopulation to the end of the list.
    function Append : TFhirMeasureGroupPopulation;
    
    // Add an already existing FhirMeasureGroupPopulation to the end of the list.
    function AddItem(value : TFhirMeasureGroupPopulation) : TFhirMeasureGroupPopulation; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMeasureGroupPopulation) : Integer;
    
    // Insert FhirMeasureGroupPopulation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMeasureGroupPopulation;
    
    // Insert an existing FhirMeasureGroupPopulation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMeasureGroupPopulation);
    
    // Get the iIndexth FhirMeasureGroupPopulation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMeasureGroupPopulation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMeasureGroupPopulation;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMeasureGroupPopulations[index : Integer] : TFhirMeasureGroupPopulation read GetItemN write SetItemN; default;
  End;

  // The stratifier criteria for the measure report, specified as either the name of a valid CQL expression defined within a referenced library or a valid FHIR Resource Path.
  TFhirMeasureGroupStratifier = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    FDescription : TFhirString;
    FCriteria : TFhirExpression;
    FcomponentList : TFhirMeasureGroupStratifierComponentList;
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetCriteria(value : TFhirExpression);
    function GetComponentList : TFhirMeasureGroupStratifierComponentList;
    function GetHasComponentList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMeasureGroupStratifier; overload;
    function Clone : TFhirMeasureGroupStratifier; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Indicates a meaning for the stratifier. This can be as simple as a unique identifier, or it can establish meaning in a broader context by drawing from a terminology, allowing stratifiers to be correlated across measures. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // Indicates a meaning for the stratifier. This can be as simple as a unique identifier, or it can establish meaning in a broader context by drawing from a terminology, allowing stratifiers to be correlated across measures.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The human readable description of this stratifier criteria.
    property description : String read GetDescriptionST write SetDescriptionST;
    // The human readable description of this stratifier criteria.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to An expression that specifies the criteria for the stratifier. This is typically the name of an expression defined within a referenced library, but it may also be a path to a stratifier element. (defined for API consistency)
    property criteria : TFhirExpression read FCriteria write SetCriteria;
    // An expression that specifies the criteria for the stratifier. This is typically the name of an expression defined within a referenced library, but it may also be a path to a stratifier element.
    property criteriaElement : TFhirExpression read FCriteria write SetCriteria;

    // A component of the stratifier criteria for the measure report, specified as either the name of a valid CQL expression defined within a referenced library or a valid FHIR Resource Path.
    property componentList : TFhirMeasureGroupStratifierComponentList read GetComponentList;
    property hasComponentList : boolean read GetHasComponentList;

  end;

  TFhirMeasureGroupStratifierListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMeasureGroupStratifierList;
    function GetCurrent : TFhirMeasureGroupStratifier;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMeasureGroupStratifierList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMeasureGroupStratifier read GetCurrent;
  end;

  TFhirMeasureGroupStratifierList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMeasureGroupStratifier;
    procedure SetItemN(index : Integer; value : TFhirMeasureGroupStratifier);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMeasureGroupStratifierList; overload;
    function Clone : TFhirMeasureGroupStratifierList; overload;
    function GetEnumerator : TFhirMeasureGroupStratifierListEnumerator;
    
    //  Add a FhirMeasureGroupStratifier to the end of the list.
    function Append : TFhirMeasureGroupStratifier;
    
    // Add an already existing FhirMeasureGroupStratifier to the end of the list.
    function AddItem(value : TFhirMeasureGroupStratifier) : TFhirMeasureGroupStratifier; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMeasureGroupStratifier) : Integer;
    
    // Insert FhirMeasureGroupStratifier before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMeasureGroupStratifier;
    
    // Insert an existing FhirMeasureGroupStratifier before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMeasureGroupStratifier);
    
    // Get the iIndexth FhirMeasureGroupStratifier. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMeasureGroupStratifier);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMeasureGroupStratifier;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMeasureGroupStratifiers[index : Integer] : TFhirMeasureGroupStratifier read GetItemN write SetItemN; default;
  End;

  // A component of the stratifier criteria for the measure report, specified as either the name of a valid CQL expression defined within a referenced library or a valid FHIR Resource Path.
  TFhirMeasureGroupStratifierComponent = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    FDescription : TFhirString;
    FCriteria : TFhirExpression;
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetCriteria(value : TFhirExpression);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMeasureGroupStratifierComponent; overload;
    function Clone : TFhirMeasureGroupStratifierComponent; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Indicates a meaning for the stratifier component. This can be as simple as a unique identifier, or it can establish meaning in a broader context by drawing from a terminology, allowing stratifiers to be correlated across measures. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // Indicates a meaning for the stratifier component. This can be as simple as a unique identifier, or it can establish meaning in a broader context by drawing from a terminology, allowing stratifiers to be correlated across measures.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The human readable description of this stratifier criteria component.
    property description : String read GetDescriptionST write SetDescriptionST;
    // The human readable description of this stratifier criteria component.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to An expression that specifies the criteria for this component of the stratifier. This is typically the name of an expression defined within a referenced library, but it may also be a path to a stratifier element. (defined for API consistency)
    property criteria : TFhirExpression read FCriteria write SetCriteria;
    // An expression that specifies the criteria for this component of the stratifier. This is typically the name of an expression defined within a referenced library, but it may also be a path to a stratifier element.
    property criteriaElement : TFhirExpression read FCriteria write SetCriteria;

  end;

  TFhirMeasureGroupStratifierComponentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMeasureGroupStratifierComponentList;
    function GetCurrent : TFhirMeasureGroupStratifierComponent;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMeasureGroupStratifierComponentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMeasureGroupStratifierComponent read GetCurrent;
  end;

  TFhirMeasureGroupStratifierComponentList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMeasureGroupStratifierComponent;
    procedure SetItemN(index : Integer; value : TFhirMeasureGroupStratifierComponent);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMeasureGroupStratifierComponentList; overload;
    function Clone : TFhirMeasureGroupStratifierComponentList; overload;
    function GetEnumerator : TFhirMeasureGroupStratifierComponentListEnumerator;
    
    //  Add a FhirMeasureGroupStratifierComponent to the end of the list.
    function Append : TFhirMeasureGroupStratifierComponent;
    
    // Add an already existing FhirMeasureGroupStratifierComponent to the end of the list.
    function AddItem(value : TFhirMeasureGroupStratifierComponent) : TFhirMeasureGroupStratifierComponent; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMeasureGroupStratifierComponent) : Integer;
    
    // Insert FhirMeasureGroupStratifierComponent before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMeasureGroupStratifierComponent;
    
    // Insert an existing FhirMeasureGroupStratifierComponent before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMeasureGroupStratifierComponent);
    
    // Get the iIndexth FhirMeasureGroupStratifierComponent. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMeasureGroupStratifierComponent);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMeasureGroupStratifierComponent;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMeasureGroupStratifierComponents[index : Integer] : TFhirMeasureGroupStratifierComponent read GetItemN write SetItemN; default;
  End;

  // The supplemental data criteria for the measure report, specified as either the name of a valid CQL expression within a referenced library, or a valid FHIR Resource Path.
  TFhirMeasureSupplementalData = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    FusageList : TFhirCodeableConceptList;
    FDescription : TFhirString;
    FCriteria : TFhirExpression;
    procedure SetCode(value : TFhirCodeableConcept);
    function GetUsageList : TFhirCodeableConceptList;
    function GetHasUsageList : Boolean;
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetCriteria(value : TFhirExpression);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMeasureSupplementalData; overload;
    function Clone : TFhirMeasureSupplementalData; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Indicates a meaning for the supplemental data. This can be as simple as a unique identifier, or it can establish meaning in a broader context by drawing from a terminology, allowing supplemental data to be correlated across measures. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // Indicates a meaning for the supplemental data. This can be as simple as a unique identifier, or it can establish meaning in a broader context by drawing from a terminology, allowing supplemental data to be correlated across measures.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // An indicator of the intended usage for the supplemental data element. Supplemental data indicates the data is additional information requested to augment the measure information. Risk adjustment factor indicates the data is additional information used to calculate risk adjustment factors when applying a risk model to the measure calculation.
    property usageList : TFhirCodeableConceptList read GetUsageList;
    property hasUsageList : boolean read GetHasUsageList;

    // Typed access to The human readable description of this supplemental data.
    property description : String read GetDescriptionST write SetDescriptionST;
    // The human readable description of this supplemental data.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to The criteria for the supplemental data. This is typically the name of a valid expression defined within a referenced library, but it may also be a path to a specific data element. The criteria defines the data to be returned for this element. (defined for API consistency)
    property criteria : TFhirExpression read FCriteria write SetCriteria;
    // The criteria for the supplemental data. This is typically the name of a valid expression defined within a referenced library, but it may also be a path to a specific data element. The criteria defines the data to be returned for this element.
    property criteriaElement : TFhirExpression read FCriteria write SetCriteria;

  end;

  TFhirMeasureSupplementalDataListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMeasureSupplementalDataList;
    function GetCurrent : TFhirMeasureSupplementalData;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMeasureSupplementalDataList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMeasureSupplementalData read GetCurrent;
  end;

  TFhirMeasureSupplementalDataList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMeasureSupplementalData;
    procedure SetItemN(index : Integer; value : TFhirMeasureSupplementalData);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMeasureSupplementalDataList; overload;
    function Clone : TFhirMeasureSupplementalDataList; overload;
    function GetEnumerator : TFhirMeasureSupplementalDataListEnumerator;
    
    //  Add a FhirMeasureSupplementalData to the end of the list.
    function Append : TFhirMeasureSupplementalData;
    
    // Add an already existing FhirMeasureSupplementalData to the end of the list.
    function AddItem(value : TFhirMeasureSupplementalData) : TFhirMeasureSupplementalData; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMeasureSupplementalData) : Integer;
    
    // Insert FhirMeasureSupplementalData before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMeasureSupplementalData;
    
    // Insert an existing FhirMeasureSupplementalData before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMeasureSupplementalData);
    
    // Get the iIndexth FhirMeasureSupplementalData. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMeasureSupplementalData);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMeasureSupplementalData;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMeasureSupplementalData[index : Integer] : TFhirMeasureSupplementalData read GetItemN write SetItemN; default;
  End;

  // The Measure resource provides the definition of a quality measure.
  TFhirMeasure = class (TFhirDomainResource)
  protected
    FUrl : TFhirUri;
    FidentifierList : TFhirIdentifierList;
    FVersion : TFhirString;
    FName : TFhirString;
    FTitle : TFhirString;
    FSubtitle : TFhirString;
    FStatus : TFhirEnum;
    FExperimental : TFhirBoolean;
    FSubject : TFhirDataType;
    FDate : TFhirDateTime;
    FPublisher : TFhirString;
    FcontactList : TFhirContactDetailList;
    FDescription : TFhirMarkdown;
    FuseContextList : TFhirUsageContextList;
    FjurisdictionList : TFhirCodeableConceptList;
    FPurpose : TFhirMarkdown;
    FUsage : TFhirString;
    FCopyright : TFhirMarkdown;
    FApprovalDate : TFhirDate;
    FLastReviewDate : TFhirDate;
    FEffectivePeriod : TFhirPeriod;
    FtopicList : TFhirCodeableConceptList;
    FauthorList : TFhirContactDetailList;
    FeditorList : TFhirContactDetailList;
    FreviewerList : TFhirContactDetailList;
    FendorserList : TFhirContactDetailList;
    FrelatedArtifactList : TFhirRelatedArtifactList;
    Flibrary_List : TFhirCanonicalList;
    FDisclaimer : TFhirMarkdown;
    FScoring : TFhirCodeableConcept;
    FCompositeScoring : TFhirCodeableConcept;
    Ftype_List : TFhirCodeableConceptList;
    FRiskAdjustment : TFhirString;
    FRateAggregation : TFhirString;
    FRationale : TFhirMarkdown;
    FClinicalRecommendationStatement : TFhirMarkdown;
    FImprovementNotation : TFhirCodeableConcept;
    FdefinitionList : TFhirMarkdownList;
    FGuidance : TFhirMarkdown;
    FgroupList : TFhirMeasureGroupList;
    FsupplementalDataList : TFhirMeasureSupplementalDataList;
    procedure SetUrl(value : TFhirUri);
    function GetUrlST : String;
    procedure SetUrlST(value : String);
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetVersion(value : TFhirString);
    function GetVersionST : String;
    procedure SetVersionST(value : String);
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetTitle(value : TFhirString);
    function GetTitleST : String;
    procedure SetTitleST(value : String);
    procedure SetSubtitle(value : TFhirString);
    function GetSubtitleST : String;
    procedure SetSubtitleST(value : String);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirPublicationStatusEnum;
    procedure SetStatusST(value : TFhirPublicationStatusEnum);
    procedure SetExperimental(value : TFhirBoolean);
    function GetExperimentalST : Boolean;
    procedure SetExperimentalST(value : Boolean);
    procedure SetSubject(value : TFhirDataType);
    procedure SetDate(value : TFhirDateTime);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    procedure SetPublisher(value : TFhirString);
    function GetPublisherST : String;
    procedure SetPublisherST(value : String);
    function GetContactList : TFhirContactDetailList;
    function GetHasContactList : Boolean;
    procedure SetDescription(value : TFhirMarkdown);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetUseContextList : TFhirUsageContextList;
    function GetHasUseContextList : Boolean;
    function GetJurisdictionList : TFhirCodeableConceptList;
    function GetHasJurisdictionList : Boolean;
    procedure SetPurpose(value : TFhirMarkdown);
    function GetPurposeST : String;
    procedure SetPurposeST(value : String);
    procedure SetUsage(value : TFhirString);
    function GetUsageST : String;
    procedure SetUsageST(value : String);
    procedure SetCopyright(value : TFhirMarkdown);
    function GetCopyrightST : String;
    procedure SetCopyrightST(value : String);
    procedure SetApprovalDate(value : TFhirDate);
    function GetApprovalDateST : TFslDateTime;
    procedure SetApprovalDateST(value : TFslDateTime);
    procedure SetLastReviewDate(value : TFhirDate);
    function GetLastReviewDateST : TFslDateTime;
    procedure SetLastReviewDateST(value : TFslDateTime);
    procedure SetEffectivePeriod(value : TFhirPeriod);
    function GetTopicList : TFhirCodeableConceptList;
    function GetHasTopicList : Boolean;
    function GetAuthorList : TFhirContactDetailList;
    function GetHasAuthorList : Boolean;
    function GetEditorList : TFhirContactDetailList;
    function GetHasEditorList : Boolean;
    function GetReviewerList : TFhirContactDetailList;
    function GetHasReviewerList : Boolean;
    function GetEndorserList : TFhirContactDetailList;
    function GetHasEndorserList : Boolean;
    function GetRelatedArtifactList : TFhirRelatedArtifactList;
    function GetHasRelatedArtifactList : Boolean;
    function GetLibrary_List : TFhirCanonicalList;
    function GetHasLibrary_List : Boolean;
    procedure SetDisclaimer(value : TFhirMarkdown);
    function GetDisclaimerST : String;
    procedure SetDisclaimerST(value : String);
    procedure SetScoring(value : TFhirCodeableConcept);
    procedure SetCompositeScoring(value : TFhirCodeableConcept);
    function GetType_List : TFhirCodeableConceptList;
    function GetHasType_List : Boolean;
    procedure SetRiskAdjustment(value : TFhirString);
    function GetRiskAdjustmentST : String;
    procedure SetRiskAdjustmentST(value : String);
    procedure SetRateAggregation(value : TFhirString);
    function GetRateAggregationST : String;
    procedure SetRateAggregationST(value : String);
    procedure SetRationale(value : TFhirMarkdown);
    function GetRationaleST : String;
    procedure SetRationaleST(value : String);
    procedure SetClinicalRecommendationStatement(value : TFhirMarkdown);
    function GetClinicalRecommendationStatementST : String;
    procedure SetClinicalRecommendationStatementST(value : String);
    procedure SetImprovementNotation(value : TFhirCodeableConcept);
    function GetDefinitionList : TFhirMarkdownList;
    function GetHasDefinitionList : Boolean;
    procedure SetGuidance(value : TFhirMarkdown);
    function GetGuidanceST : String;
    procedure SetGuidanceST(value : String);
    function GetGroupList : TFhirMeasureGroupList;
    function GetHasGroupList : Boolean;
    function GetSupplementalDataList : TFhirMeasureSupplementalDataList;
    function GetHasSupplementalDataList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMeasure; overload;
    function Clone : TFhirMeasure; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An absolute URI that is used to identify this measure when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this measure is (or will be) published. This URL can be the target of a canonical reference. It SHALL remain the same when the measure is stored on different servers.
    property url : String read GetUrlST write SetUrlST;
    // An absolute URI that is used to identify this measure when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this measure is (or will be) published. This URL can be the target of a canonical reference. It SHALL remain the same when the measure is stored on different servers.
    property urlElement : TFhirUri read FUrl write SetUrl;

    // A formal identifier that is used to identify this measure when it is represented in other formats, or referenced in a specification, model, design or an instance.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The identifier that is used to identify this version of the measure when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the measure author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence. To provide a version consistent with the Decision Support Service specification, use the format Major.Minor.Revision (e.g. 1.0.0). For more information on versioning knowledge assets, refer to the Decision Support Service specification. Note that a version is required for non-experimental active artifacts.
    property version : String read GetVersionST write SetVersionST;
    // The identifier that is used to identify this version of the measure when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the measure author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence. To provide a version consistent with the Decision Support Service specification, use the format Major.Minor.Revision (e.g. 1.0.0). For more information on versioning knowledge assets, refer to the Decision Support Service specification. Note that a version is required for non-experimental active artifacts.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to A natural language name identifying the measure. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property name : String read GetNameST write SetNameST;
    // A natural language name identifying the measure. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A short, descriptive, user-friendly title for the measure.
    property title : String read GetTitleST write SetTitleST;
    // A short, descriptive, user-friendly title for the measure.
    property titleElement : TFhirString read FTitle write SetTitle;

    // Typed access to An explanatory or alternate title for the measure giving additional information about its content.
    property subtitle : String read GetSubtitleST write SetSubtitleST;
    // An explanatory or alternate title for the measure giving additional information about its content.
    property subtitleElement : TFhirString read FSubtitle write SetSubtitle;

    // The status of this measure. Enables tracking the life-cycle of the content.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A Boolean value to indicate that this measure is authored for testing purposes (or education/evaluation/marketing) and is not intended to be used for genuine usage.
    property experimental : Boolean read GetExperimentalST write SetExperimentalST;
    // A Boolean value to indicate that this measure is authored for testing purposes (or education/evaluation/marketing) and is not intended to be used for genuine usage.
    property experimentalElement : TFhirBoolean read FExperimental write SetExperimental;

    // Typed access to The intended subjects for the measure. If this element is not provided, a Patient subject is assumed, but the subject of the measure can be anything. (defined for API consistency)
    property subject : TFhirDataType read FSubject write SetSubject;
    // The intended subjects for the measure. If this element is not provided, a Patient subject is assumed, but the subject of the measure can be anything.
    property subjectElement : TFhirDataType read FSubject write SetSubject;

    // Typed access to The date  (and optionally time) when the measure was published. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the measure changes.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date  (and optionally time) when the measure was published. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the measure changes.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The name of the organization or individual that published the measure.
    property publisher : String read GetPublisherST write SetPublisherST;
    // The name of the organization or individual that published the measure.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Contact details to assist a user in finding and communicating with the publisher.
    property contactList : TFhirContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to A free text natural language description of the measure from a consumer's perspective.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A free text natural language description of the measure from a consumer's perspective.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // The content was developed with a focus and intent of supporting the contexts that are listed. These contexts may be general categories (gender, age, ...) or may be references to specific programs (insurance plans, studies, ...) and may be used to assist with indexing and searching for appropriate measure instances.
    property useContextList : TFhirUsageContextList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // A legal or geographic region in which the measure is intended to be used.
    property jurisdictionList : TFhirCodeableConceptList read GetJurisdictionList;
    property hasJurisdictionList : boolean read GetHasJurisdictionList;

    // Typed access to Explanation of why this measure is needed and why it has been designed as it has.
    property purpose : String read GetPurposeST write SetPurposeST;
    // Explanation of why this measure is needed and why it has been designed as it has.
    property purposeElement : TFhirMarkdown read FPurpose write SetPurpose;

    // Typed access to A detailed description, from a clinical perspective, of how the measure is used.
    property usage : String read GetUsageST write SetUsageST;
    // A detailed description, from a clinical perspective, of how the measure is used.
    property usageElement : TFhirString read FUsage write SetUsage;

    // Typed access to A copyright statement relating to the measure and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the measure.
    property copyright : String read GetCopyrightST write SetCopyrightST;
    // A copyright statement relating to the measure and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the measure.
    property copyrightElement : TFhirMarkdown read FCopyright write SetCopyright;

    // Typed access to The date on which the resource content was approved by the publisher. Approval happens once when the content is officially approved for usage.
    property approvalDate : TFslDateTime read GetApprovalDateST write SetApprovalDateST;
    // The date on which the resource content was approved by the publisher. Approval happens once when the content is officially approved for usage.
    property approvalDateElement : TFhirDate read FApprovalDate write SetApprovalDate;

    // Typed access to The date on which the resource content was last reviewed. Review happens periodically after approval but does not change the original approval date.
    property lastReviewDate : TFslDateTime read GetLastReviewDateST write SetLastReviewDateST;
    // The date on which the resource content was last reviewed. Review happens periodically after approval but does not change the original approval date.
    property lastReviewDateElement : TFhirDate read FLastReviewDate write SetLastReviewDate;

    // Typed access to The period during which the measure content was or is planned to be in active use. (defined for API consistency)
    property effectivePeriod : TFhirPeriod read FEffectivePeriod write SetEffectivePeriod;
    // The period during which the measure content was or is planned to be in active use.
    property effectivePeriodElement : TFhirPeriod read FEffectivePeriod write SetEffectivePeriod;

    // Descriptive topics related to the content of the measure. Topics provide a high-level categorization grouping types of measures that can be useful for filtering and searching.
    property topicList : TFhirCodeableConceptList read GetTopicList;
    property hasTopicList : boolean read GetHasTopicList;

    // An individiual or organization primarily involved in the creation and maintenance of the content.
    property authorList : TFhirContactDetailList read GetAuthorList;
    property hasAuthorList : boolean read GetHasAuthorList;

    // An individual or organization primarily responsible for internal coherence of the content.
    property editorList : TFhirContactDetailList read GetEditorList;
    property hasEditorList : boolean read GetHasEditorList;

    // An individual or organization primarily responsible for review of some aspect of the content.
    property reviewerList : TFhirContactDetailList read GetReviewerList;
    property hasReviewerList : boolean read GetHasReviewerList;

    // An individual or organization responsible for officially endorsing the content for use in some setting.
    property endorserList : TFhirContactDetailList read GetEndorserList;
    property hasEndorserList : boolean read GetHasEndorserList;

    // Related artifacts such as additional documentation, justification, or bibliographic references.
    property relatedArtifactList : TFhirRelatedArtifactList read GetRelatedArtifactList;
    property hasRelatedArtifactList : boolean read GetHasRelatedArtifactList;

    // A reference to a Library resource containing the formal logic used by the measure.
    property library_List : TFhirCanonicalList read GetLibrary_List;
    property hasLibrary_List : boolean read GetHasLibrary_List;

    // Typed access to Notices and disclaimers regarding the use of the measure or related to intellectual property (such as code systems) referenced by the measure.
    property disclaimer : String read GetDisclaimerST write SetDisclaimerST;
    // Notices and disclaimers regarding the use of the measure or related to intellectual property (such as code systems) referenced by the measure.
    property disclaimerElement : TFhirMarkdown read FDisclaimer write SetDisclaimer;

    // Typed access to Indicates how the calculation is performed for the measure, including proportion, ratio, continuous-variable, and cohort. The value set is extensible, allowing additional measure scoring types to be represented. (defined for API consistency)
    property scoring : TFhirCodeableConcept read FScoring write SetScoring;
    // Indicates how the calculation is performed for the measure, including proportion, ratio, continuous-variable, and cohort. The value set is extensible, allowing additional measure scoring types to be represented.
    property scoringElement : TFhirCodeableConcept read FScoring write SetScoring;

    // Typed access to If this is a composite measure, the scoring method used to combine the component measures to determine the composite score. (defined for API consistency)
    property compositeScoring : TFhirCodeableConcept read FCompositeScoring write SetCompositeScoring;
    // If this is a composite measure, the scoring method used to combine the component measures to determine the composite score.
    property compositeScoringElement : TFhirCodeableConcept read FCompositeScoring write SetCompositeScoring;

    // Indicates whether the measure is used to examine a process, an outcome over time, a patient-reported outcome, or a structure measure such as utilization.
    property type_List : TFhirCodeableConceptList read GetType_List;
    property hasType_List : boolean read GetHasType_List;

    // Typed access to A description of the risk adjustment factors that may impact the resulting score for the measure and how they may be accounted for when computing and reporting measure results.
    property riskAdjustment : String read GetRiskAdjustmentST write SetRiskAdjustmentST;
    // A description of the risk adjustment factors that may impact the resulting score for the measure and how they may be accounted for when computing and reporting measure results.
    property riskAdjustmentElement : TFhirString read FRiskAdjustment write SetRiskAdjustment;

    // Typed access to Describes how to combine the information calculated, based on logic in each of several populations, into one summarized result.
    property rateAggregation : String read GetRateAggregationST write SetRateAggregationST;
    // Describes how to combine the information calculated, based on logic in each of several populations, into one summarized result.
    property rateAggregationElement : TFhirString read FRateAggregation write SetRateAggregation;

    // Typed access to Provides a succinct statement of the need for the measure. Usually includes statements pertaining to importance criterion: impact, gap in care, and evidence.
    property rationale : String read GetRationaleST write SetRationaleST;
    // Provides a succinct statement of the need for the measure. Usually includes statements pertaining to importance criterion: impact, gap in care, and evidence.
    property rationaleElement : TFhirMarkdown read FRationale write SetRationale;

    // Typed access to Provides a summary of relevant clinical guidelines or other clinical recommendations supporting the measure.
    property clinicalRecommendationStatement : String read GetClinicalRecommendationStatementST write SetClinicalRecommendationStatementST;
    // Provides a summary of relevant clinical guidelines or other clinical recommendations supporting the measure.
    property clinicalRecommendationStatementElement : TFhirMarkdown read FClinicalRecommendationStatement write SetClinicalRecommendationStatement;

    // Typed access to Information on whether an increase or decrease in score is the preferred result (e.g., a higher score indicates better quality OR a lower score indicates better quality OR quality is within a range). (defined for API consistency)
    property improvementNotation : TFhirCodeableConcept read FImprovementNotation write SetImprovementNotation;
    // Information on whether an increase or decrease in score is the preferred result (e.g., a higher score indicates better quality OR a lower score indicates better quality OR quality is within a range).
    property improvementNotationElement : TFhirCodeableConcept read FImprovementNotation write SetImprovementNotation;

    // Provides a description of an individual term used within the measure.
    property definitionList : TFhirMarkdownList read GetDefinitionList;
    property hasDefinitionList : boolean read GetHasDefinitionList;

    // Typed access to Additional guidance for the measure including how it can be used in a clinical context, and the intent of the measure.
    property guidance : String read GetGuidanceST write SetGuidanceST;
    // Additional guidance for the measure including how it can be used in a clinical context, and the intent of the measure.
    property guidanceElement : TFhirMarkdown read FGuidance write SetGuidance;

    // A group of population criteria for the measure.
    property groupList : TFhirMeasureGroupList read GetGroupList;
    property hasGroupList : boolean read GetHasGroupList;

    // The supplemental data criteria for the measure report, specified as either the name of a valid CQL expression within a referenced library, or a valid FHIR Resource Path.
    property supplementalDataList : TFhirMeasureSupplementalDataList read GetSupplementalDataList;
    property hasSupplementalDataList : boolean read GetHasSupplementalDataList;

  end;

  TFhirMeasureListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMeasureList;
    function GetCurrent : TFhirMeasure;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMeasureList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMeasure read GetCurrent;
  end;

  TFhirMeasureList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMeasure;
    procedure SetItemN(index : Integer; value : TFhirMeasure);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMeasureList; overload;
    function Clone : TFhirMeasureList; overload;
    function GetEnumerator : TFhirMeasureListEnumerator;
    
    //  Add a FhirMeasure to the end of the list.
    function Append : TFhirMeasure;
    
    // Add an already existing FhirMeasure to the end of the list.
    function AddItem(value : TFhirMeasure) : TFhirMeasure; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMeasure) : Integer;
    
    // Insert FhirMeasure before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMeasure;
    
    // Insert an existing FhirMeasure before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMeasure);
    
    // Get the iIndexth FhirMeasure. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMeasure);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMeasure;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMeasures[index : Integer] : TFhirMeasure read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_MEASURE}
{$IFDEF FHIR_MESSAGEDEFINITION}
  // Identifies the resource (or resources) that are being addressed by the event.  For example, the Encounter for an admit message or two Account records for a merge.
  TFhirMessageDefinitionFocus = class (TFhirBackboneElement)
  protected
    FCode : TFhirEnum;
    FProfile : TFhirCanonical;
    FMin : TFhirUnsignedInt;
    FMax : TFhirString;
    procedure SetCode(value : TFhirEnum);
    function GetCodeST : TFhirResourceTypesEnum;
    procedure SetCodeST(value : TFhirResourceTypesEnum);
    procedure SetProfile(value : TFhirCanonical);
    function GetProfileST : String;
    procedure SetProfileST(value : String);
    procedure SetMin(value : TFhirUnsignedInt);
    function GetMinST : String;
    procedure SetMinST(value : String);
    procedure SetMax(value : TFhirString);
    function GetMaxST : String;
    procedure SetMaxST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMessageDefinitionFocus; overload;
    function Clone : TFhirMessageDefinitionFocus; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The kind of resource that must be the focus for this message.
    property code : TFhirResourceTypesEnum read GetCodeST write SetCodeST;
    property codeElement : TFhirEnum read FCode write SetCode;

    // Typed access to A profile that reflects constraints for the focal resource (and potentially for related resources).
    property profile : String read GetProfileST write SetProfileST;
    // A profile that reflects constraints for the focal resource (and potentially for related resources).
    property profileElement : TFhirCanonical read FProfile write SetProfile;

    // Typed access to Identifies the minimum number of resources of this type that must be pointed to by a message in order for it to be valid against this MessageDefinition.
    property min : String read GetMinST write SetMinST;
    // Identifies the minimum number of resources of this type that must be pointed to by a message in order for it to be valid against this MessageDefinition.
    property minElement : TFhirUnsignedInt read FMin write SetMin;

    // Typed access to Identifies the maximum number of resources of this type that must be pointed to by a message in order for it to be valid against this MessageDefinition.
    property max : String read GetMaxST write SetMaxST;
    // Identifies the maximum number of resources of this type that must be pointed to by a message in order for it to be valid against this MessageDefinition.
    property maxElement : TFhirString read FMax write SetMax;

  end;

  TFhirMessageDefinitionFocusListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMessageDefinitionFocusList;
    function GetCurrent : TFhirMessageDefinitionFocus;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMessageDefinitionFocusList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMessageDefinitionFocus read GetCurrent;
  end;

  TFhirMessageDefinitionFocusList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMessageDefinitionFocus;
    procedure SetItemN(index : Integer; value : TFhirMessageDefinitionFocus);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMessageDefinitionFocusList; overload;
    function Clone : TFhirMessageDefinitionFocusList; overload;
    function GetEnumerator : TFhirMessageDefinitionFocusListEnumerator;
    
    //  Add a FhirMessageDefinitionFocus to the end of the list.
    function Append : TFhirMessageDefinitionFocus;
    
    // Add an already existing FhirMessageDefinitionFocus to the end of the list.
    function AddItem(value : TFhirMessageDefinitionFocus) : TFhirMessageDefinitionFocus; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMessageDefinitionFocus) : Integer;
    
    // Insert FhirMessageDefinitionFocus before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMessageDefinitionFocus;
    
    // Insert an existing FhirMessageDefinitionFocus before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMessageDefinitionFocus);
    
    // Get the iIndexth FhirMessageDefinitionFocus. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMessageDefinitionFocus);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMessageDefinitionFocus;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMessageDefinitionFocus[index : Integer] : TFhirMessageDefinitionFocus read GetItemN write SetItemN; default;
  End;

  // Indicates what types of messages may be sent as an application-level response to this message.
  TFhirMessageDefinitionAllowedResponse = class (TFhirBackboneElement)
  protected
    FMessage : TFhirCanonical;
    FSituation : TFhirMarkdown;
    procedure SetMessage(value : TFhirCanonical);
    function GetMessageST : String;
    procedure SetMessageST(value : String);
    procedure SetSituation(value : TFhirMarkdown);
    function GetSituationST : String;
    procedure SetSituationST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMessageDefinitionAllowedResponse; overload;
    function Clone : TFhirMessageDefinitionAllowedResponse; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A reference to the message definition that must be adhered to by this supported response.
    property message : String read GetMessageST write SetMessageST;
    // A reference to the message definition that must be adhered to by this supported response.
    property messageElement : TFhirCanonical read FMessage write SetMessage;

    // Typed access to Provides a description of the circumstances in which this response should be used (as opposed to one of the alternative responses).
    property situation : String read GetSituationST write SetSituationST;
    // Provides a description of the circumstances in which this response should be used (as opposed to one of the alternative responses).
    property situationElement : TFhirMarkdown read FSituation write SetSituation;

  end;

  TFhirMessageDefinitionAllowedResponseListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMessageDefinitionAllowedResponseList;
    function GetCurrent : TFhirMessageDefinitionAllowedResponse;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMessageDefinitionAllowedResponseList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMessageDefinitionAllowedResponse read GetCurrent;
  end;

  TFhirMessageDefinitionAllowedResponseList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMessageDefinitionAllowedResponse;
    procedure SetItemN(index : Integer; value : TFhirMessageDefinitionAllowedResponse);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMessageDefinitionAllowedResponseList; overload;
    function Clone : TFhirMessageDefinitionAllowedResponseList; overload;
    function GetEnumerator : TFhirMessageDefinitionAllowedResponseListEnumerator;
    
    //  Add a FhirMessageDefinitionAllowedResponse to the end of the list.
    function Append : TFhirMessageDefinitionAllowedResponse;
    
    // Add an already existing FhirMessageDefinitionAllowedResponse to the end of the list.
    function AddItem(value : TFhirMessageDefinitionAllowedResponse) : TFhirMessageDefinitionAllowedResponse; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMessageDefinitionAllowedResponse) : Integer;
    
    // Insert FhirMessageDefinitionAllowedResponse before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMessageDefinitionAllowedResponse;
    
    // Insert an existing FhirMessageDefinitionAllowedResponse before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMessageDefinitionAllowedResponse);
    
    // Get the iIndexth FhirMessageDefinitionAllowedResponse. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMessageDefinitionAllowedResponse);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMessageDefinitionAllowedResponse;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMessageDefinitionAllowedResponses[index : Integer] : TFhirMessageDefinitionAllowedResponse read GetItemN write SetItemN; default;
  End;

  // Defines the characteristics of a message that can be shared between systems, including the type of event that initiates the message, the content to be transmitted and what response(s), if any, are permitted.
  TFhirMessageDefinition = class (TFhirDomainResource)
  protected
    FUrl : TFhirUri;
    FidentifierList : TFhirIdentifierList;
    FVersion : TFhirString;
    FName : TFhirString;
    FTitle : TFhirString;
    FreplacesList : TFhirCanonicalList;
    FStatus : TFhirEnum;
    FExperimental : TFhirBoolean;
    FDate : TFhirDateTime;
    FPublisher : TFhirString;
    FcontactList : TFhirContactDetailList;
    FDescription : TFhirMarkdown;
    FuseContextList : TFhirUsageContextList;
    FjurisdictionList : TFhirCodeableConceptList;
    FPurpose : TFhirMarkdown;
    FCopyright : TFhirMarkdown;
    FBase : TFhirCanonical;
    FparentList : TFhirCanonicalList;
    FEvent : TFhirDataType;
    FCategory : TFhirEnum;
    FfocusList : TFhirMessageDefinitionFocusList;
    FResponseRequired : TFhirEnum;
    FallowedResponseList : TFhirMessageDefinitionAllowedResponseList;
    FgraphList : TFhirCanonicalList;
    procedure SetUrl(value : TFhirUri);
    function GetUrlST : String;
    procedure SetUrlST(value : String);
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetVersion(value : TFhirString);
    function GetVersionST : String;
    procedure SetVersionST(value : String);
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetTitle(value : TFhirString);
    function GetTitleST : String;
    procedure SetTitleST(value : String);
    function GetReplacesList : TFhirCanonicalList;
    function GetHasReplacesList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirPublicationStatusEnum;
    procedure SetStatusST(value : TFhirPublicationStatusEnum);
    procedure SetExperimental(value : TFhirBoolean);
    function GetExperimentalST : Boolean;
    procedure SetExperimentalST(value : Boolean);
    procedure SetDate(value : TFhirDateTime);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    procedure SetPublisher(value : TFhirString);
    function GetPublisherST : String;
    procedure SetPublisherST(value : String);
    function GetContactList : TFhirContactDetailList;
    function GetHasContactList : Boolean;
    procedure SetDescription(value : TFhirMarkdown);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetUseContextList : TFhirUsageContextList;
    function GetHasUseContextList : Boolean;
    function GetJurisdictionList : TFhirCodeableConceptList;
    function GetHasJurisdictionList : Boolean;
    procedure SetPurpose(value : TFhirMarkdown);
    function GetPurposeST : String;
    procedure SetPurposeST(value : String);
    procedure SetCopyright(value : TFhirMarkdown);
    function GetCopyrightST : String;
    procedure SetCopyrightST(value : String);
    procedure SetBase(value : TFhirCanonical);
    function GetBaseST : String;
    procedure SetBaseST(value : String);
    function GetParentList : TFhirCanonicalList;
    function GetHasParentList : Boolean;
    procedure SetEvent(value : TFhirDataType);
    procedure SetCategory(value : TFhirEnum);
    function GetCategoryST : TFhirMessageSignificanceCategoryEnum;
    procedure SetCategoryST(value : TFhirMessageSignificanceCategoryEnum);
    function GetFocusList : TFhirMessageDefinitionFocusList;
    function GetHasFocusList : Boolean;
    procedure SetResponseRequired(value : TFhirEnum);
    function GetResponseRequiredST : TFhirMessageheaderResponseRequestEnum;
    procedure SetResponseRequiredST(value : TFhirMessageheaderResponseRequestEnum);
    function GetAllowedResponseList : TFhirMessageDefinitionAllowedResponseList;
    function GetHasAllowedResponseList : Boolean;
    function GetGraphList : TFhirCanonicalList;
    function GetHasGraphList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMessageDefinition; overload;
    function Clone : TFhirMessageDefinition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The business identifier that is used to reference the MessageDefinition and *is* expected to be consistent from server to server.
    property url : String read GetUrlST write SetUrlST;
    // The business identifier that is used to reference the MessageDefinition and *is* expected to be consistent from server to server.
    property urlElement : TFhirUri read FUrl write SetUrl;

    // A formal identifier that is used to identify this message definition when it is represented in other formats, or referenced in a specification, model, design or an instance.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The identifier that is used to identify this version of the message definition when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the message definition author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
    property version : String read GetVersionST write SetVersionST;
    // The identifier that is used to identify this version of the message definition when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the message definition author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to A natural language name identifying the message definition. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property name : String read GetNameST write SetNameST;
    // A natural language name identifying the message definition. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A short, descriptive, user-friendly title for the message definition.
    property title : String read GetTitleST write SetTitleST;
    // A short, descriptive, user-friendly title for the message definition.
    property titleElement : TFhirString read FTitle write SetTitle;

    // A MessageDefinition that is superseded by this definition.
    property replacesList : TFhirCanonicalList read GetReplacesList;
    property hasReplacesList : boolean read GetHasReplacesList;

    // The status of this message definition. Enables tracking the life-cycle of the content.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A Boolean value to indicate that this message definition is authored for testing purposes (or education/evaluation/marketing) and is not intended to be used for genuine usage.
    property experimental : Boolean read GetExperimentalST write SetExperimentalST;
    // A Boolean value to indicate that this message definition is authored for testing purposes (or education/evaluation/marketing) and is not intended to be used for genuine usage.
    property experimentalElement : TFhirBoolean read FExperimental write SetExperimental;

    // Typed access to The date  (and optionally time) when the message definition was published. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the message definition changes.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date  (and optionally time) when the message definition was published. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the message definition changes.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The name of the organization or individual that published the message definition.
    property publisher : String read GetPublisherST write SetPublisherST;
    // The name of the organization or individual that published the message definition.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Contact details to assist a user in finding and communicating with the publisher.
    property contactList : TFhirContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to A free text natural language description of the message definition from a consumer's perspective.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A free text natural language description of the message definition from a consumer's perspective.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // The content was developed with a focus and intent of supporting the contexts that are listed. These contexts may be general categories (gender, age, ...) or may be references to specific programs (insurance plans, studies, ...) and may be used to assist with indexing and searching for appropriate message definition instances.
    property useContextList : TFhirUsageContextList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // A legal or geographic region in which the message definition is intended to be used.
    property jurisdictionList : TFhirCodeableConceptList read GetJurisdictionList;
    property hasJurisdictionList : boolean read GetHasJurisdictionList;

    // Typed access to Explanation of why this message definition is needed and why it has been designed as it has.
    property purpose : String read GetPurposeST write SetPurposeST;
    // Explanation of why this message definition is needed and why it has been designed as it has.
    property purposeElement : TFhirMarkdown read FPurpose write SetPurpose;

    // Typed access to A copyright statement relating to the message definition and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the message definition.
    property copyright : String read GetCopyrightST write SetCopyrightST;
    // A copyright statement relating to the message definition and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the message definition.
    property copyrightElement : TFhirMarkdown read FCopyright write SetCopyright;

    // Typed access to The MessageDefinition that is the basis for the contents of this resource.
    property base : String read GetBaseST write SetBaseST;
    // The MessageDefinition that is the basis for the contents of this resource.
    property baseElement : TFhirCanonical read FBase write SetBase;

    // Identifies a protocol or workflow that this MessageDefinition represents a step in.
    property parentList : TFhirCanonicalList read GetParentList;
    property hasParentList : boolean read GetHasParentList;

    // Typed access to Event code or link to the EventDefinition. (defined for API consistency)
    property event : TFhirDataType read FEvent write SetEvent;
    // Event code or link to the EventDefinition.
    property eventElement : TFhirDataType read FEvent write SetEvent;

    // The impact of the content of the message.
    property category : TFhirMessageSignificanceCategoryEnum read GetCategoryST write SetCategoryST;
    property categoryElement : TFhirEnum read FCategory write SetCategory;

    // Identifies the resource (or resources) that are being addressed by the event.  For example, the Encounter for an admit message or two Account records for a merge.
    property focusList : TFhirMessageDefinitionFocusList read GetFocusList;
    property hasFocusList : boolean read GetHasFocusList;

    // Declare at a message definition level whether a response is required or only upon error or success, or never.
    property responseRequired : TFhirMessageheaderResponseRequestEnum read GetResponseRequiredST write SetResponseRequiredST;
    property responseRequiredElement : TFhirEnum read FResponseRequired write SetResponseRequired;

    // Indicates what types of messages may be sent as an application-level response to this message.
    property allowedResponseList : TFhirMessageDefinitionAllowedResponseList read GetAllowedResponseList;
    property hasAllowedResponseList : boolean read GetHasAllowedResponseList;

    // Canonical reference to a GraphDefinition. If a URL is provided, it is the canonical reference to a [GraphDefinition](graphdefinition.html) that it controls what resources are to be added to the bundle when building the document. The GraphDefinition can also specify profiles that apply to the various resources.
    property graphList : TFhirCanonicalList read GetGraphList;
    property hasGraphList : boolean read GetHasGraphList;

  end;

  TFhirMessageDefinitionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMessageDefinitionList;
    function GetCurrent : TFhirMessageDefinition;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMessageDefinitionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMessageDefinition read GetCurrent;
  end;

  TFhirMessageDefinitionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMessageDefinition;
    procedure SetItemN(index : Integer; value : TFhirMessageDefinition);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMessageDefinitionList; overload;
    function Clone : TFhirMessageDefinitionList; overload;
    function GetEnumerator : TFhirMessageDefinitionListEnumerator;
    
    //  Add a FhirMessageDefinition to the end of the list.
    function Append : TFhirMessageDefinition;
    
    // Add an already existing FhirMessageDefinition to the end of the list.
    function AddItem(value : TFhirMessageDefinition) : TFhirMessageDefinition; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMessageDefinition) : Integer;
    
    // Insert FhirMessageDefinition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMessageDefinition;
    
    // Insert an existing FhirMessageDefinition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMessageDefinition);
    
    // Get the iIndexth FhirMessageDefinition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMessageDefinition);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMessageDefinition;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMessageDefinitions[index : Integer] : TFhirMessageDefinition read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_MESSAGEDEFINITION}
{$IFDEF FHIR_NAMINGSYSTEM}
  // Indicates how the system may be identified when referenced in electronic exchange.
  TFhirNamingSystemUniqueId = class (TFhirBackboneElement)
  protected
    FType_ : TFhirEnum;
    FValue : TFhirString;
    FPreferred : TFhirBoolean;
    FComment : TFhirString;
    FPeriod : TFhirPeriod;
    procedure SetType_(value : TFhirEnum);
    function GetType_ST : TFhirNamingSystemIdentifierTypeEnum;
    procedure SetType_ST(value : TFhirNamingSystemIdentifierTypeEnum);
    procedure SetValue(value : TFhirString);
    function GetValueST : String;
    procedure SetValueST(value : String);
    procedure SetPreferred(value : TFhirBoolean);
    function GetPreferredST : Boolean;
    procedure SetPreferredST(value : Boolean);
    procedure SetComment(value : TFhirString);
    function GetCommentST : String;
    procedure SetCommentST(value : String);
    procedure SetPeriod(value : TFhirPeriod);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirNamingSystemUniqueId; overload;
    function Clone : TFhirNamingSystemUniqueId; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Identifies the unique identifier scheme used for this particular identifier.
    property type_ : TFhirNamingSystemIdentifierTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to The string that should be sent over the wire to identify the code system or identifier system.
    property value : String read GetValueST write SetValueST;
    // The string that should be sent over the wire to identify the code system or identifier system.
    property valueElement : TFhirString read FValue write SetValue;

    // Typed access to Indicates whether this identifier is the "preferred" identifier of this type.
    property preferred : Boolean read GetPreferredST write SetPreferredST;
    // Indicates whether this identifier is the "preferred" identifier of this type.
    property preferredElement : TFhirBoolean read FPreferred write SetPreferred;

    // Typed access to Notes about the past or intended usage of this identifier.
    property comment : String read GetCommentST write SetCommentST;
    // Notes about the past or intended usage of this identifier.
    property commentElement : TFhirString read FComment write SetComment;

    // Typed access to Identifies the period of time over which this identifier is considered appropriate to refer to the naming system.  Outside of this window, the identifier might be non-deterministic. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // Identifies the period of time over which this identifier is considered appropriate to refer to the naming system.  Outside of this window, the identifier might be non-deterministic.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

  end;

  TFhirNamingSystemUniqueIdListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirNamingSystemUniqueIdList;
    function GetCurrent : TFhirNamingSystemUniqueId;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirNamingSystemUniqueIdList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirNamingSystemUniqueId read GetCurrent;
  end;

  TFhirNamingSystemUniqueIdList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirNamingSystemUniqueId;
    procedure SetItemN(index : Integer; value : TFhirNamingSystemUniqueId);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirNamingSystemUniqueIdList; overload;
    function Clone : TFhirNamingSystemUniqueIdList; overload;
    function GetEnumerator : TFhirNamingSystemUniqueIdListEnumerator;
    
    //  Add a FhirNamingSystemUniqueId to the end of the list.
    function Append : TFhirNamingSystemUniqueId;
    
    // Add an already existing FhirNamingSystemUniqueId to the end of the list.
    function AddItem(value : TFhirNamingSystemUniqueId) : TFhirNamingSystemUniqueId; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirNamingSystemUniqueId) : Integer;
    
    // Insert FhirNamingSystemUniqueId before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirNamingSystemUniqueId;
    
    // Insert an existing FhirNamingSystemUniqueId before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirNamingSystemUniqueId);
    
    // Get the iIndexth FhirNamingSystemUniqueId. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirNamingSystemUniqueId);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirNamingSystemUniqueId;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirNamingSystemUniqueIds[index : Integer] : TFhirNamingSystemUniqueId read GetItemN write SetItemN; default;
  End;

  // A curated namespace that issues unique symbols within that namespace for the identification of concepts, people, devices, etc.  Represents a "System" used within the Identifier and Coding data types.
  TFhirNamingSystem = class (TFhirDomainResource)
  protected
    FName : TFhirString;
    FStatus : TFhirEnum;
    FKind : TFhirEnum;
    FDate : TFhirDateTime;
    FPublisher : TFhirString;
    FcontactList : TFhirContactDetailList;
    FResponsible : TFhirString;
    FType_ : TFhirCodeableConcept;
    FDescription : TFhirMarkdown;
    FuseContextList : TFhirUsageContextList;
    FjurisdictionList : TFhirCodeableConceptList;
    FUsage : TFhirString;
    FuniqueIdList : TFhirNamingSystemUniqueIdList;
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirPublicationStatusEnum;
    procedure SetStatusST(value : TFhirPublicationStatusEnum);
    procedure SetKind(value : TFhirEnum);
    function GetKindST : TFhirNamingSystemTypeEnum;
    procedure SetKindST(value : TFhirNamingSystemTypeEnum);
    procedure SetDate(value : TFhirDateTime);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    procedure SetPublisher(value : TFhirString);
    function GetPublisherST : String;
    procedure SetPublisherST(value : String);
    function GetContactList : TFhirContactDetailList;
    function GetHasContactList : Boolean;
    procedure SetResponsible(value : TFhirString);
    function GetResponsibleST : String;
    procedure SetResponsibleST(value : String);
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetDescription(value : TFhirMarkdown);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetUseContextList : TFhirUsageContextList;
    function GetHasUseContextList : Boolean;
    function GetJurisdictionList : TFhirCodeableConceptList;
    function GetHasJurisdictionList : Boolean;
    procedure SetUsage(value : TFhirString);
    function GetUsageST : String;
    procedure SetUsageST(value : String);
    function GetUniqueIdList : TFhirNamingSystemUniqueIdList;
    function GetHasUniqueIdList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirNamingSystem; overload;
    function Clone : TFhirNamingSystem; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A natural language name identifying the naming system. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property name : String read GetNameST write SetNameST;
    // A natural language name identifying the naming system. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property nameElement : TFhirString read FName write SetName;

    // The status of this naming system. Enables tracking the life-cycle of the content.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Indicates the purpose for the naming system - what kinds of things does it make unique?
    property kind : TFhirNamingSystemTypeEnum read GetKindST write SetKindST;
    property kindElement : TFhirEnum read FKind write SetKind;

    // Typed access to The date  (and optionally time) when the naming system was published. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the naming system changes.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date  (and optionally time) when the naming system was published. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the naming system changes.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The name of the organization or individual that published the naming system.
    property publisher : String read GetPublisherST write SetPublisherST;
    // The name of the organization or individual that published the naming system.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Contact details to assist a user in finding and communicating with the publisher.
    property contactList : TFhirContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to The name of the organization that is responsible for issuing identifiers or codes for this namespace and ensuring their non-collision.
    property responsible : String read GetResponsibleST write SetResponsibleST;
    // The name of the organization that is responsible for issuing identifiers or codes for this namespace and ensuring their non-collision.
    property responsibleElement : TFhirString read FResponsible write SetResponsible;

    // Typed access to Categorizes a naming system for easier search by grouping related naming systems. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Categorizes a naming system for easier search by grouping related naming systems.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to A free text natural language description of the naming system from a consumer's perspective. Details about what the namespace identifies including scope, granularity, version labeling, etc.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A free text natural language description of the naming system from a consumer's perspective. Details about what the namespace identifies including scope, granularity, version labeling, etc.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // The content was developed with a focus and intent of supporting the contexts that are listed. These contexts may be general categories (gender, age, ...) or may be references to specific programs (insurance plans, studies, ...) and may be used to assist with indexing and searching for appropriate naming system instances.
    property useContextList : TFhirUsageContextList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // A legal or geographic region in which the naming system is intended to be used.
    property jurisdictionList : TFhirCodeableConceptList read GetJurisdictionList;
    property hasJurisdictionList : boolean read GetHasJurisdictionList;

    // Typed access to Provides guidance on the use of the namespace, including the handling of formatting characters, use of upper vs. lower case, etc.
    property usage : String read GetUsageST write SetUsageST;
    // Provides guidance on the use of the namespace, including the handling of formatting characters, use of upper vs. lower case, etc.
    property usageElement : TFhirString read FUsage write SetUsage;

    // Indicates how the system may be identified when referenced in electronic exchange.
    property uniqueIdList : TFhirNamingSystemUniqueIdList read GetUniqueIdList;
    property hasUniqueIdList : boolean read GetHasUniqueIdList;

  end;

  TFhirNamingSystemListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirNamingSystemList;
    function GetCurrent : TFhirNamingSystem;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirNamingSystemList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirNamingSystem read GetCurrent;
  end;

  TFhirNamingSystemList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirNamingSystem;
    procedure SetItemN(index : Integer; value : TFhirNamingSystem);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirNamingSystemList; overload;
    function Clone : TFhirNamingSystemList; overload;
    function GetEnumerator : TFhirNamingSystemListEnumerator;
    
    //  Add a FhirNamingSystem to the end of the list.
    function Append : TFhirNamingSystem;
    
    // Add an already existing FhirNamingSystem to the end of the list.
    function AddItem(value : TFhirNamingSystem) : TFhirNamingSystem; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirNamingSystem) : Integer;
    
    // Insert FhirNamingSystem before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirNamingSystem;
    
    // Insert an existing FhirNamingSystem before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirNamingSystem);
    
    // Get the iIndexth FhirNamingSystem. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirNamingSystem);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirNamingSystem;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirNamingSystems[index : Integer] : TFhirNamingSystem read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_NAMINGSYSTEM}
{$IFDEF FHIR_OBSERVATIONDEFINITION}
  // Characteristics for quantitative results of this observation.
  TFhirObservationDefinitionQuantitativeDetails = class (TFhirBackboneElement)
  protected
    FCustomaryUnit : TFhirCodeableConcept;
    FUnit_ : TFhirCodeableConcept;
    FConversionFactor : TFhirDecimal;
    FDecimalPrecision : TFhirInteger;
    procedure SetCustomaryUnit(value : TFhirCodeableConcept);
    procedure SetUnit_(value : TFhirCodeableConcept);
    procedure SetConversionFactor(value : TFhirDecimal);
    function GetConversionFactorST : String;
    procedure SetConversionFactorST(value : String);
    procedure SetDecimalPrecision(value : TFhirInteger);
    function GetDecimalPrecisionST : String;
    procedure SetDecimalPrecisionST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirObservationDefinitionQuantitativeDetails; overload;
    function Clone : TFhirObservationDefinitionQuantitativeDetails; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Customary unit used to report quantitative results of observations conforming to this ObservationDefinition. (defined for API consistency)
    property customaryUnit : TFhirCodeableConcept read FCustomaryUnit write SetCustomaryUnit;
    // Customary unit used to report quantitative results of observations conforming to this ObservationDefinition.
    property customaryUnitElement : TFhirCodeableConcept read FCustomaryUnit write SetCustomaryUnit;

    // Typed access to SI unit used to report quantitative results of observations conforming to this ObservationDefinition. (defined for API consistency)
    property unit_ : TFhirCodeableConcept read FUnit_ write SetUnit_;
    // SI unit used to report quantitative results of observations conforming to this ObservationDefinition.
    property unit_Element : TFhirCodeableConcept read FUnit_ write SetUnit_;

    // Typed access to Factor for converting value expressed with SI unit to value expressed with customary unit.
    property conversionFactor : String read GetConversionFactorST write SetConversionFactorST;
    // Factor for converting value expressed with SI unit to value expressed with customary unit.
    property conversionFactorElement : TFhirDecimal read FConversionFactor write SetConversionFactor;

    // Typed access to Number of digits after decimal separator when the results of such observations are of type Quantity.
    property decimalPrecision : String read GetDecimalPrecisionST write SetDecimalPrecisionST;
    // Number of digits after decimal separator when the results of such observations are of type Quantity.
    property decimalPrecisionElement : TFhirInteger read FDecimalPrecision write SetDecimalPrecision;

  end;

  TFhirObservationDefinitionQuantitativeDetailsListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirObservationDefinitionQuantitativeDetailsList;
    function GetCurrent : TFhirObservationDefinitionQuantitativeDetails;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirObservationDefinitionQuantitativeDetailsList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirObservationDefinitionQuantitativeDetails read GetCurrent;
  end;

  TFhirObservationDefinitionQuantitativeDetailsList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirObservationDefinitionQuantitativeDetails;
    procedure SetItemN(index : Integer; value : TFhirObservationDefinitionQuantitativeDetails);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirObservationDefinitionQuantitativeDetailsList; overload;
    function Clone : TFhirObservationDefinitionQuantitativeDetailsList; overload;
    function GetEnumerator : TFhirObservationDefinitionQuantitativeDetailsListEnumerator;
    
    //  Add a FhirObservationDefinitionQuantitativeDetails to the end of the list.
    function Append : TFhirObservationDefinitionQuantitativeDetails;
    
    // Add an already existing FhirObservationDefinitionQuantitativeDetails to the end of the list.
    function AddItem(value : TFhirObservationDefinitionQuantitativeDetails) : TFhirObservationDefinitionQuantitativeDetails; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirObservationDefinitionQuantitativeDetails) : Integer;
    
    // Insert FhirObservationDefinitionQuantitativeDetails before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirObservationDefinitionQuantitativeDetails;
    
    // Insert an existing FhirObservationDefinitionQuantitativeDetails before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirObservationDefinitionQuantitativeDetails);
    
    // Get the iIndexth FhirObservationDefinitionQuantitativeDetails. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirObservationDefinitionQuantitativeDetails);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirObservationDefinitionQuantitativeDetails;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirObservationDefinitionQuantitativeDetails[index : Integer] : TFhirObservationDefinitionQuantitativeDetails read GetItemN write SetItemN; default;
  End;

  // Multiple  ranges of results qualified by different contexts for ordinal or continuous observations conforming to this ObservationDefinition.
  TFhirObservationDefinitionQualifiedInterval = class (TFhirBackboneElement)
  protected
    FCategory : TFhirEnum;
    FRange : TFhirRange;
    FContext : TFhirCodeableConcept;
    FappliesToList : TFhirCodeableConceptList;
    FGender : TFhirEnum;
    FAge : TFhirRange;
    FGestationalAge : TFhirRange;
    FCondition : TFhirString;
    procedure SetCategory(value : TFhirEnum);
    function GetCategoryST : TFhirObservationRangeCategoryEnum;
    procedure SetCategoryST(value : TFhirObservationRangeCategoryEnum);
    procedure SetRange(value : TFhirRange);
    procedure SetContext(value : TFhirCodeableConcept);
    function GetAppliesToList : TFhirCodeableConceptList;
    function GetHasAppliesToList : Boolean;
    procedure SetGender(value : TFhirEnum);
    function GetGenderST : TFhirAdministrativeGenderEnum;
    procedure SetGenderST(value : TFhirAdministrativeGenderEnum);
    procedure SetAge(value : TFhirRange);
    procedure SetGestationalAge(value : TFhirRange);
    procedure SetCondition(value : TFhirString);
    function GetConditionST : String;
    procedure SetConditionST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirObservationDefinitionQualifiedInterval; overload;
    function Clone : TFhirObservationDefinitionQualifiedInterval; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The category of interval of values for continuous or ordinal observations conforming to this ObservationDefinition.
    property category : TFhirObservationRangeCategoryEnum read GetCategoryST write SetCategoryST;
    property categoryElement : TFhirEnum read FCategory write SetCategory;

    // Typed access to The low and high values determining the interval. There may be only one of the two. (defined for API consistency)
    property range : TFhirRange read FRange write SetRange;
    // The low and high values determining the interval. There may be only one of the two.
    property rangeElement : TFhirRange read FRange write SetRange;

    // Typed access to Codes to indicate the health context the range applies to. For example, the normal or therapeutic range. (defined for API consistency)
    property context : TFhirCodeableConcept read FContext write SetContext;
    // Codes to indicate the health context the range applies to. For example, the normal or therapeutic range.
    property contextElement : TFhirCodeableConcept read FContext write SetContext;

    // Codes to indicate the target population this reference range applies to.
    property appliesToList : TFhirCodeableConceptList read GetAppliesToList;
    property hasAppliesToList : boolean read GetHasAppliesToList;

    // Sex of the population the range applies to.
    property gender : TFhirAdministrativeGenderEnum read GetGenderST write SetGenderST;
    property genderElement : TFhirEnum read FGender write SetGender;

    // Typed access to The age at which this reference range is applicable. This is a neonatal age (e.g. number of weeks at term) if the meaning says so. (defined for API consistency)
    property age : TFhirRange read FAge write SetAge;
    // The age at which this reference range is applicable. This is a neonatal age (e.g. number of weeks at term) if the meaning says so.
    property ageElement : TFhirRange read FAge write SetAge;

    // Typed access to The gestational age to which this reference range is applicable, in the context of pregnancy. (defined for API consistency)
    property gestationalAge : TFhirRange read FGestationalAge write SetGestationalAge;
    // The gestational age to which this reference range is applicable, in the context of pregnancy.
    property gestationalAgeElement : TFhirRange read FGestationalAge write SetGestationalAge;

    // Typed access to Text based condition for which the reference range is valid.
    property condition : String read GetConditionST write SetConditionST;
    // Text based condition for which the reference range is valid.
    property conditionElement : TFhirString read FCondition write SetCondition;

  end;

  TFhirObservationDefinitionQualifiedIntervalListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirObservationDefinitionQualifiedIntervalList;
    function GetCurrent : TFhirObservationDefinitionQualifiedInterval;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirObservationDefinitionQualifiedIntervalList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirObservationDefinitionQualifiedInterval read GetCurrent;
  end;

  TFhirObservationDefinitionQualifiedIntervalList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirObservationDefinitionQualifiedInterval;
    procedure SetItemN(index : Integer; value : TFhirObservationDefinitionQualifiedInterval);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirObservationDefinitionQualifiedIntervalList; overload;
    function Clone : TFhirObservationDefinitionQualifiedIntervalList; overload;
    function GetEnumerator : TFhirObservationDefinitionQualifiedIntervalListEnumerator;
    
    //  Add a FhirObservationDefinitionQualifiedInterval to the end of the list.
    function Append : TFhirObservationDefinitionQualifiedInterval;
    
    // Add an already existing FhirObservationDefinitionQualifiedInterval to the end of the list.
    function AddItem(value : TFhirObservationDefinitionQualifiedInterval) : TFhirObservationDefinitionQualifiedInterval; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirObservationDefinitionQualifiedInterval) : Integer;
    
    // Insert FhirObservationDefinitionQualifiedInterval before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirObservationDefinitionQualifiedInterval;
    
    // Insert an existing FhirObservationDefinitionQualifiedInterval before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirObservationDefinitionQualifiedInterval);
    
    // Get the iIndexth FhirObservationDefinitionQualifiedInterval. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirObservationDefinitionQualifiedInterval);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirObservationDefinitionQualifiedInterval;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirObservationDefinitionQualifiedIntervals[index : Integer] : TFhirObservationDefinitionQualifiedInterval read GetItemN write SetItemN; default;
  End;

  // Set of definitional characteristics for a kind of observation or measurement produced or consumed by an orderable health care service.
  TFhirObservationDefinition = class (TFhirDomainResource)
  protected
    FcategoryList : TFhirCodeableConceptList;
    FCode : TFhirCodeableConcept;
    FidentifierList : TFhirIdentifierList;
    FPermittedDataType : TFhirEnumList;
    FMultipleResultsAllowed : TFhirBoolean;
    FMethod : TFhirCodeableConcept;
    FPreferredReportName : TFhirString;
    FQuantitativeDetails : TFhirObservationDefinitionQuantitativeDetails;
    FqualifiedIntervalList : TFhirObservationDefinitionQualifiedIntervalList;
    FValidCodedValueSet : TFhirReference;
    FNormalCodedValueSet : TFhirReference;
    FAbnormalCodedValueSet : TFhirReference;
    FCriticalCodedValueSet : TFhirReference;
    function GetCategoryList : TFhirCodeableConceptList;
    function GetHasCategoryList : Boolean;
    procedure SetCode(value : TFhirCodeableConcept);
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetPermittedDataType : TFhirEnumList;
    function GetHasPermittedDataType : Boolean;
    function GetPermittedDataTypeST : TFhirObservationDataTypeEnumList;
    procedure SetPermittedDataTypeST(value : TFhirObservationDataTypeEnumList);
    procedure SetMultipleResultsAllowed(value : TFhirBoolean);
    function GetMultipleResultsAllowedST : Boolean;
    procedure SetMultipleResultsAllowedST(value : Boolean);
    procedure SetMethod(value : TFhirCodeableConcept);
    procedure SetPreferredReportName(value : TFhirString);
    function GetPreferredReportNameST : String;
    procedure SetPreferredReportNameST(value : String);
    procedure SetQuantitativeDetails(value : TFhirObservationDefinitionQuantitativeDetails);
    function GetQualifiedIntervalList : TFhirObservationDefinitionQualifiedIntervalList;
    function GetHasQualifiedIntervalList : Boolean;
    procedure SetValidCodedValueSet(value : TFhirReference);
    procedure SetNormalCodedValueSet(value : TFhirReference);
    procedure SetAbnormalCodedValueSet(value : TFhirReference);
    procedure SetCriticalCodedValueSet(value : TFhirReference);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirObservationDefinition; overload;
    function Clone : TFhirObservationDefinition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // A code that classifies the general type of observation.
    property categoryList : TFhirCodeableConceptList read GetCategoryList;
    property hasCategoryList : boolean read GetHasCategoryList;

    // Typed access to Describes what will be observed. Sometimes this is called the observation "name". (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // Describes what will be observed. Sometimes this is called the observation "name".
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // A unique identifier assigned to this ObservationDefinition artifact.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The data types allowed for the value element of the instance observations conforming to this ObservationDefinition.
    property permittedDataType : TFhirObservationDataTypeEnumList read GetPermittedDataTypeST write SetPermittedDataTypeST;
    property permittedDataTypeList : TFhirEnumList read GetPermittedDataType;
    property hasPermittedDataType : boolean read GetHasPermittedDataType;
    // Typed access to Multiple results allowed for observations conforming to this ObservationDefinition.
    property multipleResultsAllowed : Boolean read GetMultipleResultsAllowedST write SetMultipleResultsAllowedST;
    // Multiple results allowed for observations conforming to this ObservationDefinition.
    property multipleResultsAllowedElement : TFhirBoolean read FMultipleResultsAllowed write SetMultipleResultsAllowed;

    // Typed access to The method or technique used to perform the observation. (defined for API consistency)
    property method : TFhirCodeableConcept read FMethod write SetMethod;
    // The method or technique used to perform the observation.
    property methodElement : TFhirCodeableConcept read FMethod write SetMethod;

    // Typed access to The preferred name to be used when reporting the results of observations conforming to this ObservationDefinition.
    property preferredReportName : String read GetPreferredReportNameST write SetPreferredReportNameST;
    // The preferred name to be used when reporting the results of observations conforming to this ObservationDefinition.
    property preferredReportNameElement : TFhirString read FPreferredReportName write SetPreferredReportName;

    // Typed access to Characteristics for quantitative results of this observation. (defined for API consistency)
    property quantitativeDetails : TFhirObservationDefinitionQuantitativeDetails read FQuantitativeDetails write SetQuantitativeDetails;
    // Characteristics for quantitative results of this observation.
    property quantitativeDetailsElement : TFhirObservationDefinitionQuantitativeDetails read FQuantitativeDetails write SetQuantitativeDetails;

    // Multiple  ranges of results qualified by different contexts for ordinal or continuous observations conforming to this ObservationDefinition.
    property qualifiedIntervalList : TFhirObservationDefinitionQualifiedIntervalList read GetQualifiedIntervalList;
    property hasQualifiedIntervalList : boolean read GetHasQualifiedIntervalList;

    // Typed access to The set of valid coded results for the observations  conforming to this ObservationDefinition. (defined for API consistency)
    property validCodedValueSet : TFhirReference read FValidCodedValueSet write SetValidCodedValueSet;
    // The set of valid coded results for the observations  conforming to this ObservationDefinition.
    property validCodedValueSetElement : TFhirReference read FValidCodedValueSet write SetValidCodedValueSet;

    // Typed access to The set of normal coded results for the observations conforming to this ObservationDefinition. (defined for API consistency)
    property normalCodedValueSet : TFhirReference read FNormalCodedValueSet write SetNormalCodedValueSet;
    // The set of normal coded results for the observations conforming to this ObservationDefinition.
    property normalCodedValueSetElement : TFhirReference read FNormalCodedValueSet write SetNormalCodedValueSet;

    // Typed access to The set of abnormal coded results for the observation conforming to this ObservationDefinition. (defined for API consistency)
    property abnormalCodedValueSet : TFhirReference read FAbnormalCodedValueSet write SetAbnormalCodedValueSet;
    // The set of abnormal coded results for the observation conforming to this ObservationDefinition.
    property abnormalCodedValueSetElement : TFhirReference read FAbnormalCodedValueSet write SetAbnormalCodedValueSet;

    // Typed access to The set of critical coded results for the observation conforming to this ObservationDefinition. (defined for API consistency)
    property criticalCodedValueSet : TFhirReference read FCriticalCodedValueSet write SetCriticalCodedValueSet;
    // The set of critical coded results for the observation conforming to this ObservationDefinition.
    property criticalCodedValueSetElement : TFhirReference read FCriticalCodedValueSet write SetCriticalCodedValueSet;

  end;

  TFhirObservationDefinitionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirObservationDefinitionList;
    function GetCurrent : TFhirObservationDefinition;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirObservationDefinitionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirObservationDefinition read GetCurrent;
  end;

  TFhirObservationDefinitionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirObservationDefinition;
    procedure SetItemN(index : Integer; value : TFhirObservationDefinition);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirObservationDefinitionList; overload;
    function Clone : TFhirObservationDefinitionList; overload;
    function GetEnumerator : TFhirObservationDefinitionListEnumerator;
    
    //  Add a FhirObservationDefinition to the end of the list.
    function Append : TFhirObservationDefinition;
    
    // Add an already existing FhirObservationDefinition to the end of the list.
    function AddItem(value : TFhirObservationDefinition) : TFhirObservationDefinition; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirObservationDefinition) : Integer;
    
    // Insert FhirObservationDefinition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirObservationDefinition;
    
    // Insert an existing FhirObservationDefinition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirObservationDefinition);
    
    // Get the iIndexth FhirObservationDefinition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirObservationDefinition);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirObservationDefinition;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirObservationDefinitions[index : Integer] : TFhirObservationDefinition read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_OBSERVATIONDEFINITION}
{$IFDEF FHIR_OPERATIONDEFINITION}
  // The parameters for the operation/query.
  TFhirOperationDefinitionParameter = class (TFhirBackboneElement)
  protected
    FName : TFhirCode;
    FUse : TFhirEnum;
    FMin : TFhirInteger;
    FMax : TFhirString;
    FDocumentation : TFhirString;
    FType_ : TFhirEnum;
    FtargetProfileList : TFhirCanonicalList;
    FSearchType : TFhirEnum;
    FBinding : TFhirOperationDefinitionParameterBinding;
    FreferencedFromList : TFhirOperationDefinitionParameterReferencedFromList;
    FpartList : TFhirOperationDefinitionParameterList;
    procedure SetName(value : TFhirCode);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetUse(value : TFhirEnum);
    function GetUseST : TFhirOperationParameterUseEnum;
    procedure SetUseST(value : TFhirOperationParameterUseEnum);
    procedure SetMin(value : TFhirInteger);
    function GetMinST : String;
    procedure SetMinST(value : String);
    procedure SetMax(value : TFhirString);
    function GetMaxST : String;
    procedure SetMaxST(value : String);
    procedure SetDocumentation(value : TFhirString);
    function GetDocumentationST : String;
    procedure SetDocumentationST(value : String);
    procedure SetType_(value : TFhirEnum);
    function GetType_ST : TFhirAllTypesEnum;
    procedure SetType_ST(value : TFhirAllTypesEnum);
    function GetTargetProfileList : TFhirCanonicalList;
    function GetHasTargetProfileList : Boolean;
    procedure SetSearchType(value : TFhirEnum);
    function GetSearchTypeST : TFhirSearchParamTypeEnum;
    procedure SetSearchTypeST(value : TFhirSearchParamTypeEnum);
    procedure SetBinding(value : TFhirOperationDefinitionParameterBinding);
    function GetReferencedFromList : TFhirOperationDefinitionParameterReferencedFromList;
    function GetHasReferencedFromList : Boolean;
    function GetPartList : TFhirOperationDefinitionParameterList;
    function GetHasPartList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirOperationDefinitionParameter; overload;
    function Clone : TFhirOperationDefinitionParameter; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The name of used to identify the parameter.
    property name : String read GetNameST write SetNameST;
    // The name of used to identify the parameter.
    property nameElement : TFhirCode read FName write SetName;

    // Whether this is an input or an output parameter.
    property use : TFhirOperationParameterUseEnum read GetUseST write SetUseST;
    property useElement : TFhirEnum read FUse write SetUse;

    // Typed access to The minimum number of times this parameter SHALL appear in the request or response.
    property min : String read GetMinST write SetMinST;
    // The minimum number of times this parameter SHALL appear in the request or response.
    property minElement : TFhirInteger read FMin write SetMin;

    // Typed access to The maximum number of times this element is permitted to appear in the request or response.
    property max : String read GetMaxST write SetMaxST;
    // The maximum number of times this element is permitted to appear in the request or response.
    property maxElement : TFhirString read FMax write SetMax;

    // Typed access to Describes the meaning or use of this parameter.
    property documentation : String read GetDocumentationST write SetDocumentationST;
    // Describes the meaning or use of this parameter.
    property documentationElement : TFhirString read FDocumentation write SetDocumentation;

    // The type for this parameter.
    property type_ : TFhirAllTypesEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Used when the type is "Reference" or "canonical", and identifies a profile structure or implementation Guide that applies to the target of the reference this parameter refers to. If any profiles are specified, then the content must conform to at least one of them. The URL can be a local reference - to a contained StructureDefinition, or a reference to another StructureDefinition or Implementation Guide by a canonical URL. When an implementation guide is specified, the target resource SHALL conform to at least one profile defined in the implementation guide.
    property targetProfileList : TFhirCanonicalList read GetTargetProfileList;
    property hasTargetProfileList : boolean read GetHasTargetProfileList;

    // How the parameter is understood as a search parameter. This is only used if the parameter type is 'string'.
    property searchType : TFhirSearchParamTypeEnum read GetSearchTypeST write SetSearchTypeST;
    property searchTypeElement : TFhirEnum read FSearchType write SetSearchType;

    // Typed access to Binds to a value set if this parameter is coded (code, Coding, CodeableConcept). (defined for API consistency)
    property binding : TFhirOperationDefinitionParameterBinding read FBinding write SetBinding;
    // Binds to a value set if this parameter is coded (code, Coding, CodeableConcept).
    property bindingElement : TFhirOperationDefinitionParameterBinding read FBinding write SetBinding;

    // Identifies other resource parameters within the operation invocation that are expected to resolve to this resource.
    property referencedFromList : TFhirOperationDefinitionParameterReferencedFromList read GetReferencedFromList;
    property hasReferencedFromList : boolean read GetHasReferencedFromList;

    // The parts of a nested Parameter.
    property partList : TFhirOperationDefinitionParameterList read GetPartList;
    property hasPartList : boolean read GetHasPartList;

  end;

  TFhirOperationDefinitionParameterListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirOperationDefinitionParameterList;
    function GetCurrent : TFhirOperationDefinitionParameter;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirOperationDefinitionParameterList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirOperationDefinitionParameter read GetCurrent;
  end;

  TFhirOperationDefinitionParameterList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirOperationDefinitionParameter;
    procedure SetItemN(index : Integer; value : TFhirOperationDefinitionParameter);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirOperationDefinitionParameterList; overload;
    function Clone : TFhirOperationDefinitionParameterList; overload;
    function GetEnumerator : TFhirOperationDefinitionParameterListEnumerator;
    
    //  Add a FhirOperationDefinitionParameter to the end of the list.
    function Append : TFhirOperationDefinitionParameter;
    
    // Add an already existing FhirOperationDefinitionParameter to the end of the list.
    function AddItem(value : TFhirOperationDefinitionParameter) : TFhirOperationDefinitionParameter; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirOperationDefinitionParameter) : Integer;
    
    // Insert FhirOperationDefinitionParameter before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirOperationDefinitionParameter;
    
    // Insert an existing FhirOperationDefinitionParameter before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirOperationDefinitionParameter);
    
    // Get the iIndexth FhirOperationDefinitionParameter. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirOperationDefinitionParameter);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirOperationDefinitionParameter;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirOperationDefinitionParameters[index : Integer] : TFhirOperationDefinitionParameter read GetItemN write SetItemN; default;
  End;

  // Binds to a value set if this parameter is coded (code, Coding, CodeableConcept).
  TFhirOperationDefinitionParameterBinding = class (TFhirBackboneElement)
  protected
    FStrength : TFhirEnum;
    FValueSet : TFhirCanonical;
    procedure SetStrength(value : TFhirEnum);
    function GetStrengthST : TFhirBindingStrengthEnum;
    procedure SetStrengthST(value : TFhirBindingStrengthEnum);
    procedure SetValueSet(value : TFhirCanonical);
    function GetValueSetST : String;
    procedure SetValueSetST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirOperationDefinitionParameterBinding; overload;
    function Clone : TFhirOperationDefinitionParameterBinding; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Indicates the degree of conformance expectations associated with this binding - that is, the degree to which the provided value set must be adhered to in the instances.
    property strength : TFhirBindingStrengthEnum read GetStrengthST write SetStrengthST;
    property strengthElement : TFhirEnum read FStrength write SetStrength;

    // Typed access to Points to the value set or external definition (e.g. implicit value set) that identifies the set of codes to be used.
    property valueSet : String read GetValueSetST write SetValueSetST;
    // Points to the value set or external definition (e.g. implicit value set) that identifies the set of codes to be used.
    property valueSetElement : TFhirCanonical read FValueSet write SetValueSet;

  end;

  TFhirOperationDefinitionParameterBindingListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirOperationDefinitionParameterBindingList;
    function GetCurrent : TFhirOperationDefinitionParameterBinding;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirOperationDefinitionParameterBindingList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirOperationDefinitionParameterBinding read GetCurrent;
  end;

  TFhirOperationDefinitionParameterBindingList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirOperationDefinitionParameterBinding;
    procedure SetItemN(index : Integer; value : TFhirOperationDefinitionParameterBinding);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirOperationDefinitionParameterBindingList; overload;
    function Clone : TFhirOperationDefinitionParameterBindingList; overload;
    function GetEnumerator : TFhirOperationDefinitionParameterBindingListEnumerator;
    
    //  Add a FhirOperationDefinitionParameterBinding to the end of the list.
    function Append : TFhirOperationDefinitionParameterBinding;
    
    // Add an already existing FhirOperationDefinitionParameterBinding to the end of the list.
    function AddItem(value : TFhirOperationDefinitionParameterBinding) : TFhirOperationDefinitionParameterBinding; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirOperationDefinitionParameterBinding) : Integer;
    
    // Insert FhirOperationDefinitionParameterBinding before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirOperationDefinitionParameterBinding;
    
    // Insert an existing FhirOperationDefinitionParameterBinding before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirOperationDefinitionParameterBinding);
    
    // Get the iIndexth FhirOperationDefinitionParameterBinding. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirOperationDefinitionParameterBinding);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirOperationDefinitionParameterBinding;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirOperationDefinitionParameterBindings[index : Integer] : TFhirOperationDefinitionParameterBinding read GetItemN write SetItemN; default;
  End;

  // Identifies other resource parameters within the operation invocation that are expected to resolve to this resource.
  TFhirOperationDefinitionParameterReferencedFrom = class (TFhirBackboneElement)
  protected
    FSource : TFhirString;
    FSourceId : TFhirString;
    procedure SetSource(value : TFhirString);
    function GetSourceST : String;
    procedure SetSourceST(value : String);
    procedure SetSourceId(value : TFhirString);
    function GetSourceIdST : String;
    procedure SetSourceIdST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirOperationDefinitionParameterReferencedFrom; overload;
    function Clone : TFhirOperationDefinitionParameterReferencedFrom; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The name of the parameter or dot-separated path of parameter names pointing to the resource parameter that is expected to contain a reference to this resource.
    property source : String read GetSourceST write SetSourceST;
    // The name of the parameter or dot-separated path of parameter names pointing to the resource parameter that is expected to contain a reference to this resource.
    property sourceElement : TFhirString read FSource write SetSource;

    // Typed access to The id of the element in the referencing resource that is expected to resolve to this resource.
    property sourceId : String read GetSourceIdST write SetSourceIdST;
    // The id of the element in the referencing resource that is expected to resolve to this resource.
    property sourceIdElement : TFhirString read FSourceId write SetSourceId;

  end;

  TFhirOperationDefinitionParameterReferencedFromListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirOperationDefinitionParameterReferencedFromList;
    function GetCurrent : TFhirOperationDefinitionParameterReferencedFrom;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirOperationDefinitionParameterReferencedFromList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirOperationDefinitionParameterReferencedFrom read GetCurrent;
  end;

  TFhirOperationDefinitionParameterReferencedFromList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirOperationDefinitionParameterReferencedFrom;
    procedure SetItemN(index : Integer; value : TFhirOperationDefinitionParameterReferencedFrom);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirOperationDefinitionParameterReferencedFromList; overload;
    function Clone : TFhirOperationDefinitionParameterReferencedFromList; overload;
    function GetEnumerator : TFhirOperationDefinitionParameterReferencedFromListEnumerator;
    
    //  Add a FhirOperationDefinitionParameterReferencedFrom to the end of the list.
    function Append : TFhirOperationDefinitionParameterReferencedFrom;
    
    // Add an already existing FhirOperationDefinitionParameterReferencedFrom to the end of the list.
    function AddItem(value : TFhirOperationDefinitionParameterReferencedFrom) : TFhirOperationDefinitionParameterReferencedFrom; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirOperationDefinitionParameterReferencedFrom) : Integer;
    
    // Insert FhirOperationDefinitionParameterReferencedFrom before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirOperationDefinitionParameterReferencedFrom;
    
    // Insert an existing FhirOperationDefinitionParameterReferencedFrom before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirOperationDefinitionParameterReferencedFrom);
    
    // Get the iIndexth FhirOperationDefinitionParameterReferencedFrom. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirOperationDefinitionParameterReferencedFrom);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirOperationDefinitionParameterReferencedFrom;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirOperationDefinitionParameterReferencedFroms[index : Integer] : TFhirOperationDefinitionParameterReferencedFrom read GetItemN write SetItemN; default;
  End;

  // Defines an appropriate combination of parameters to use when invoking this operation, to help code generators when generating overloaded parameter sets for this operation.
  TFhirOperationDefinitionOverload = class (TFhirBackboneElement)
  protected
    FparameterNameList : TFhirStringList;
    FComment : TFhirString;
    function GetParameterNameList : TFhirStringList;
    function GetHasParameterNameList : Boolean;
    procedure SetComment(value : TFhirString);
    function GetCommentST : String;
    procedure SetCommentST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirOperationDefinitionOverload; overload;
    function Clone : TFhirOperationDefinitionOverload; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Name of parameter to include in overload.
    property parameterNameList : TFhirStringList read GetParameterNameList;
    property hasParameterNameList : boolean read GetHasParameterNameList;

    // Typed access to Comments to go on overload.
    property comment : String read GetCommentST write SetCommentST;
    // Comments to go on overload.
    property commentElement : TFhirString read FComment write SetComment;

  end;

  TFhirOperationDefinitionOverloadListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirOperationDefinitionOverloadList;
    function GetCurrent : TFhirOperationDefinitionOverload;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirOperationDefinitionOverloadList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirOperationDefinitionOverload read GetCurrent;
  end;

  TFhirOperationDefinitionOverloadList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirOperationDefinitionOverload;
    procedure SetItemN(index : Integer; value : TFhirOperationDefinitionOverload);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirOperationDefinitionOverloadList; overload;
    function Clone : TFhirOperationDefinitionOverloadList; overload;
    function GetEnumerator : TFhirOperationDefinitionOverloadListEnumerator;
    
    //  Add a FhirOperationDefinitionOverload to the end of the list.
    function Append : TFhirOperationDefinitionOverload;
    
    // Add an already existing FhirOperationDefinitionOverload to the end of the list.
    function AddItem(value : TFhirOperationDefinitionOverload) : TFhirOperationDefinitionOverload; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirOperationDefinitionOverload) : Integer;
    
    // Insert FhirOperationDefinitionOverload before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirOperationDefinitionOverload;
    
    // Insert an existing FhirOperationDefinitionOverload before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirOperationDefinitionOverload);
    
    // Get the iIndexth FhirOperationDefinitionOverload. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirOperationDefinitionOverload);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirOperationDefinitionOverload;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirOperationDefinitionOverloads[index : Integer] : TFhirOperationDefinitionOverload read GetItemN write SetItemN; default;
  End;

  // A formal computable definition of an operation (on the RESTful interface) or a named query (using the search interaction).
  TFhirOperationDefinition = class (TFhirDomainResource)
  protected
    FUrl : TFhirUri;
    FVersion : TFhirString;
    FName : TFhirString;
    FTitle : TFhirString;
    FStatus : TFhirEnum;
    FKind : TFhirEnum;
    FExperimental : TFhirBoolean;
    FDate : TFhirDateTime;
    FPublisher : TFhirString;
    FcontactList : TFhirContactDetailList;
    FDescription : TFhirMarkdown;
    FuseContextList : TFhirUsageContextList;
    FjurisdictionList : TFhirCodeableConceptList;
    FPurpose : TFhirMarkdown;
    FAffectsState : TFhirBoolean;
    FCode : TFhirCode;
    FComment : TFhirMarkdown;
    FBase : TFhirCanonical;
    FResource : TFhirEnumList;
    FSystem : TFhirBoolean;
    FType_ : TFhirBoolean;
    FInstance : TFhirBoolean;
    FInputProfile : TFhirCanonical;
    FOutputProfile : TFhirCanonical;
    FparameterList : TFhirOperationDefinitionParameterList;
    FoverloadList : TFhirOperationDefinitionOverloadList;
    procedure SetUrl(value : TFhirUri);
    function GetUrlST : String;
    procedure SetUrlST(value : String);
    procedure SetVersion(value : TFhirString);
    function GetVersionST : String;
    procedure SetVersionST(value : String);
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetTitle(value : TFhirString);
    function GetTitleST : String;
    procedure SetTitleST(value : String);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirPublicationStatusEnum;
    procedure SetStatusST(value : TFhirPublicationStatusEnum);
    procedure SetKind(value : TFhirEnum);
    function GetKindST : TFhirOperationKindEnum;
    procedure SetKindST(value : TFhirOperationKindEnum);
    procedure SetExperimental(value : TFhirBoolean);
    function GetExperimentalST : Boolean;
    procedure SetExperimentalST(value : Boolean);
    procedure SetDate(value : TFhirDateTime);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    procedure SetPublisher(value : TFhirString);
    function GetPublisherST : String;
    procedure SetPublisherST(value : String);
    function GetContactList : TFhirContactDetailList;
    function GetHasContactList : Boolean;
    procedure SetDescription(value : TFhirMarkdown);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetUseContextList : TFhirUsageContextList;
    function GetHasUseContextList : Boolean;
    function GetJurisdictionList : TFhirCodeableConceptList;
    function GetHasJurisdictionList : Boolean;
    procedure SetPurpose(value : TFhirMarkdown);
    function GetPurposeST : String;
    procedure SetPurposeST(value : String);
    procedure SetAffectsState(value : TFhirBoolean);
    function GetAffectsStateST : Boolean;
    procedure SetAffectsStateST(value : Boolean);
    procedure SetCode(value : TFhirCode);
    function GetCodeST : String;
    procedure SetCodeST(value : String);
    procedure SetComment(value : TFhirMarkdown);
    function GetCommentST : String;
    procedure SetCommentST(value : String);
    procedure SetBase(value : TFhirCanonical);
    function GetBaseST : String;
    procedure SetBaseST(value : String);
    function GetResource : TFhirEnumList;
    function GetHasResource : Boolean;
    procedure SetSystem(value : TFhirBoolean);
    function GetSystemST : Boolean;
    procedure SetSystemST(value : Boolean);
    procedure SetType_(value : TFhirBoolean);
    function GetType_ST : Boolean;
    procedure SetType_ST(value : Boolean);
    procedure SetInstance(value : TFhirBoolean);
    function GetInstanceST : Boolean;
    procedure SetInstanceST(value : Boolean);
    procedure SetInputProfile(value : TFhirCanonical);
    function GetInputProfileST : String;
    procedure SetInputProfileST(value : String);
    procedure SetOutputProfile(value : TFhirCanonical);
    function GetOutputProfileST : String;
    procedure SetOutputProfileST(value : String);
    function GetParameterList : TFhirOperationDefinitionParameterList;
    function GetHasParameterList : Boolean;
    function GetOverloadList : TFhirOperationDefinitionOverloadList;
    function GetHasOverloadList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirOperationDefinition; overload;
    function Clone : TFhirOperationDefinition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An absolute URI that is used to identify this operation definition when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this operation definition is (or will be) published. This URL can be the target of a canonical reference. It SHALL remain the same when the operation definition is stored on different servers.
    property url : String read GetUrlST write SetUrlST;
    // An absolute URI that is used to identify this operation definition when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this operation definition is (or will be) published. This URL can be the target of a canonical reference. It SHALL remain the same when the operation definition is stored on different servers.
    property urlElement : TFhirUri read FUrl write SetUrl;

    // Typed access to The identifier that is used to identify this version of the operation definition when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the operation definition author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
    property version : String read GetVersionST write SetVersionST;
    // The identifier that is used to identify this version of the operation definition when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the operation definition author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to A natural language name identifying the operation definition. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property name : String read GetNameST write SetNameST;
    // A natural language name identifying the operation definition. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A short, descriptive, user-friendly title for the operation definition.
    property title : String read GetTitleST write SetTitleST;
    // A short, descriptive, user-friendly title for the operation definition.
    property titleElement : TFhirString read FTitle write SetTitle;

    // The status of this operation definition. Enables tracking the life-cycle of the content.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Whether this is an operation or a named query.
    property kind : TFhirOperationKindEnum read GetKindST write SetKindST;
    property kindElement : TFhirEnum read FKind write SetKind;

    // Typed access to A Boolean value to indicate that this operation definition is authored for testing purposes (or education/evaluation/marketing) and is not intended to be used for genuine usage.
    property experimental : Boolean read GetExperimentalST write SetExperimentalST;
    // A Boolean value to indicate that this operation definition is authored for testing purposes (or education/evaluation/marketing) and is not intended to be used for genuine usage.
    property experimentalElement : TFhirBoolean read FExperimental write SetExperimental;

    // Typed access to The date  (and optionally time) when the operation definition was published. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the operation definition changes.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date  (and optionally time) when the operation definition was published. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the operation definition changes.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The name of the organization or individual that published the operation definition.
    property publisher : String read GetPublisherST write SetPublisherST;
    // The name of the organization or individual that published the operation definition.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Contact details to assist a user in finding and communicating with the publisher.
    property contactList : TFhirContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to A free text natural language description of the operation definition from a consumer's perspective.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A free text natural language description of the operation definition from a consumer's perspective.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // The content was developed with a focus and intent of supporting the contexts that are listed. These contexts may be general categories (gender, age, ...) or may be references to specific programs (insurance plans, studies, ...) and may be used to assist with indexing and searching for appropriate operation definition instances.
    property useContextList : TFhirUsageContextList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // A legal or geographic region in which the operation definition is intended to be used.
    property jurisdictionList : TFhirCodeableConceptList read GetJurisdictionList;
    property hasJurisdictionList : boolean read GetHasJurisdictionList;

    // Typed access to Explanation of why this operation definition is needed and why it has been designed as it has.
    property purpose : String read GetPurposeST write SetPurposeST;
    // Explanation of why this operation definition is needed and why it has been designed as it has.
    property purposeElement : TFhirMarkdown read FPurpose write SetPurpose;

    // Typed access to Whether the operation affects state. Side effects such as producing audit trail entries do not count as 'affecting  state'.
    property affectsState : Boolean read GetAffectsStateST write SetAffectsStateST;
    // Whether the operation affects state. Side effects such as producing audit trail entries do not count as 'affecting  state'.
    property affectsStateElement : TFhirBoolean read FAffectsState write SetAffectsState;

    // Typed access to The name used to invoke the operation.
    property code : String read GetCodeST write SetCodeST;
    // The name used to invoke the operation.
    property codeElement : TFhirCode read FCode write SetCode;

    // Typed access to Additional information about how to use this operation or named query.
    property comment : String read GetCommentST write SetCommentST;
    // Additional information about how to use this operation or named query.
    property commentElement : TFhirMarkdown read FComment write SetComment;

    // Typed access to Indicates that this operation definition is a constraining profile on the base.
    property base : String read GetBaseST write SetBaseST;
    // Indicates that this operation definition is a constraining profile on the base.
    property baseElement : TFhirCanonical read FBase write SetBase;

    property resource : TFhirEnumList read GetResource;
    property resourceList : TFhirEnumList read GetResource;
    property hasResource : boolean read GetHasResource;
    // Typed access to Indicates whether this operation or named query can be invoked at the system level (e.g. without needing to choose a resource type for the context).
    property system : Boolean read GetSystemST write SetSystemST;
    // Indicates whether this operation or named query can be invoked at the system level (e.g. without needing to choose a resource type for the context).
    property systemElement : TFhirBoolean read FSystem write SetSystem;

    // Typed access to Indicates whether this operation or named query can be invoked at the resource type level for any given resource type level (e.g. without needing to choose a specific resource id for the context).
    property type_ : Boolean read GetType_ST write SetType_ST;
    // Indicates whether this operation or named query can be invoked at the resource type level for any given resource type level (e.g. without needing to choose a specific resource id for the context).
    property type_Element : TFhirBoolean read FType_ write SetType_;

    // Typed access to Indicates whether this operation can be invoked on a particular instance of one of the given types.
    property instance : Boolean read GetInstanceST write SetInstanceST;
    // Indicates whether this operation can be invoked on a particular instance of one of the given types.
    property instanceElement : TFhirBoolean read FInstance write SetInstance;

    // Typed access to Additional validation information for the in parameters - a single profile that covers all the parameters. The profile is a constraint on the parameters resource as a whole.
    property inputProfile : String read GetInputProfileST write SetInputProfileST;
    // Additional validation information for the in parameters - a single profile that covers all the parameters. The profile is a constraint on the parameters resource as a whole.
    property inputProfileElement : TFhirCanonical read FInputProfile write SetInputProfile;

    // Typed access to Additional validation information for the out parameters - a single profile that covers all the parameters. The profile is a constraint on the parameters resource.
    property outputProfile : String read GetOutputProfileST write SetOutputProfileST;
    // Additional validation information for the out parameters - a single profile that covers all the parameters. The profile is a constraint on the parameters resource.
    property outputProfileElement : TFhirCanonical read FOutputProfile write SetOutputProfile;

    // The parameters for the operation/query.
    property parameterList : TFhirOperationDefinitionParameterList read GetParameterList;
    property hasParameterList : boolean read GetHasParameterList;

    // Defines an appropriate combination of parameters to use when invoking this operation, to help code generators when generating overloaded parameter sets for this operation.
    property overloadList : TFhirOperationDefinitionOverloadList read GetOverloadList;
    property hasOverloadList : boolean read GetHasOverloadList;

  end;

  TFhirOperationDefinitionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirOperationDefinitionList;
    function GetCurrent : TFhirOperationDefinition;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirOperationDefinitionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirOperationDefinition read GetCurrent;
  end;

  TFhirOperationDefinitionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirOperationDefinition;
    procedure SetItemN(index : Integer; value : TFhirOperationDefinition);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirOperationDefinitionList; overload;
    function Clone : TFhirOperationDefinitionList; overload;
    function GetEnumerator : TFhirOperationDefinitionListEnumerator;
    
    //  Add a FhirOperationDefinition to the end of the list.
    function Append : TFhirOperationDefinition;
    
    // Add an already existing FhirOperationDefinition to the end of the list.
    function AddItem(value : TFhirOperationDefinition) : TFhirOperationDefinition; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirOperationDefinition) : Integer;
    
    // Insert FhirOperationDefinition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirOperationDefinition;
    
    // Insert an existing FhirOperationDefinition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirOperationDefinition);
    
    // Get the iIndexth FhirOperationDefinition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirOperationDefinition);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirOperationDefinition;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirOperationDefinitions[index : Integer] : TFhirOperationDefinition read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_OPERATIONDEFINITION}
{$IFDEF FHIR_QUESTIONNAIRE}
  // A particular question, question grouping or display text that is part of the questionnaire.
  TFhirQuestionnaireItem = class (TFhirBackboneElement)
  protected
    FLinkId : TFhirString;
    FDefinition : TFhirUri;
    FcodeList : TFhirCodingList;
    FPrefix : TFhirString;
    FText : TFhirString;
    FType_ : TFhirEnum;
    FenableWhenList : TFhirQuestionnaireItemEnableWhenList;
    FEnableBehavior : TFhirEnum;
    FRequired : TFhirBoolean;
    FRepeats : TFhirBoolean;
    FReadOnly : TFhirBoolean;
    FMaxLength : TFhirInteger;
    FAnswerValueSet : TFhirCanonical;
    FanswerOptionList : TFhirQuestionnaireItemAnswerOptionList;
    FinitialList : TFhirQuestionnaireItemInitialList;
    FitemList : TFhirQuestionnaireItemList;
    procedure SetLinkId(value : TFhirString);
    function GetLinkIdST : String;
    procedure SetLinkIdST(value : String);
    procedure SetDefinition(value : TFhirUri);
    function GetDefinitionST : String;
    procedure SetDefinitionST(value : String);
    function GetCodeList : TFhirCodingList;
    function GetHasCodeList : Boolean;
    procedure SetPrefix(value : TFhirString);
    function GetPrefixST : String;
    procedure SetPrefixST(value : String);
    procedure SetText(value : TFhirString);
    function GetTextST : String;
    procedure SetTextST(value : String);
    procedure SetType_(value : TFhirEnum);
    function GetType_ST : TFhirQuestionnaireItemTypeEnum;
    procedure SetType_ST(value : TFhirQuestionnaireItemTypeEnum);
    function GetEnableWhenList : TFhirQuestionnaireItemEnableWhenList;
    function GetHasEnableWhenList : Boolean;
    procedure SetEnableBehavior(value : TFhirEnum);
    function GetEnableBehaviorST : TFhirEnableWhenBehaviorEnum;
    procedure SetEnableBehaviorST(value : TFhirEnableWhenBehaviorEnum);
    procedure SetRequired(value : TFhirBoolean);
    function GetRequiredST : Boolean;
    procedure SetRequiredST(value : Boolean);
    procedure SetRepeats(value : TFhirBoolean);
    function GetRepeatsST : Boolean;
    procedure SetRepeatsST(value : Boolean);
    procedure SetReadOnly(value : TFhirBoolean);
    function GetReadOnlyST : Boolean;
    procedure SetReadOnlyST(value : Boolean);
    procedure SetMaxLength(value : TFhirInteger);
    function GetMaxLengthST : String;
    procedure SetMaxLengthST(value : String);
    procedure SetAnswerValueSet(value : TFhirCanonical);
    function GetAnswerValueSetST : String;
    procedure SetAnswerValueSetST(value : String);
    function GetAnswerOptionList : TFhirQuestionnaireItemAnswerOptionList;
    function GetHasAnswerOptionList : Boolean;
    function GetInitialList : TFhirQuestionnaireItemInitialList;
    function GetHasInitialList : Boolean;
    function GetItemList : TFhirQuestionnaireItemList;
    function GetHasItemList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirQuestionnaireItem; overload;
    function Clone : TFhirQuestionnaireItem; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An identifier that is unique within the Questionnaire allowing linkage to the equivalent item in a QuestionnaireResponse resource.
    property linkId : String read GetLinkIdST write SetLinkIdST;
    // An identifier that is unique within the Questionnaire allowing linkage to the equivalent item in a QuestionnaireResponse resource.
    property linkIdElement : TFhirString read FLinkId write SetLinkId;

    // Typed access to This element is a URI that refers to an [ElementDefinition](elementdefinition.html) that provides information about this item, including information that might otherwise be included in the instance of the Questionnaire resource. A detailed description of the construction of the URI is shown in Comments, below. If this element is present then the following element values MAY be derived from the Element Definition if the corresponding elements of this Questionnaire resource instance have no value:  * code (ElementDefinition.code)  * type (ElementDefinition.type)  * required (ElementDefinition.min)  * repeats (ElementDefinition.max)  * maxLength (ElementDefinition.maxLength)  * answerValueSet (ElementDefinition.binding) * options (ElementDefinition.binding).
    property definition : String read GetDefinitionST write SetDefinitionST;
    // This element is a URI that refers to an [ElementDefinition](elementdefinition.html) that provides information about this item, including information that might otherwise be included in the instance of the Questionnaire resource. A detailed description of the construction of the URI is shown in Comments, below. If this element is present then the following element values MAY be derived from the Element Definition if the corresponding elements of this Questionnaire resource instance have no value:  * code (ElementDefinition.code)  * type (ElementDefinition.type)  * required (ElementDefinition.min)  * repeats (ElementDefinition.max)  * maxLength (ElementDefinition.maxLength)  * answerValueSet (ElementDefinition.binding) * options (ElementDefinition.binding).
    property definitionElement : TFhirUri read FDefinition write SetDefinition;

    // A terminology code that corresponds to this group or question (e.g. a code from LOINC, which defines many questions and answers).
    property codeList : TFhirCodingList read GetCodeList;
    property hasCodeList : boolean read GetHasCodeList;

    // Typed access to A short label for a particular group, question or set of display text within the questionnaire used for reference by the individual completing the questionnaire.
    property prefix : String read GetPrefixST write SetPrefixST;
    // A short label for a particular group, question or set of display text within the questionnaire used for reference by the individual completing the questionnaire.
    property prefixElement : TFhirString read FPrefix write SetPrefix;

    // Typed access to The name of a section, the text of a question or text content for a display item.
    property text : String read GetTextST write SetTextST;
    // The name of a section, the text of a question or text content for a display item.
    property textElement : TFhirString read FText write SetText;

    // The type of questionnaire item this is - whether text for display, a grouping of other items or a particular type of data to be captured (string, integer, coded choice, etc.).
    property type_ : TFhirQuestionnaireItemTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // A constraint indicating that this item should only be enabled (displayed/allow answers to be captured) when the specified condition is true.
    property enableWhenList : TFhirQuestionnaireItemEnableWhenList read GetEnableWhenList;
    property hasEnableWhenList : boolean read GetHasEnableWhenList;

    // Controls how multiple enableWhen values are interpreted -  whether all or any must be true.
    property enableBehavior : TFhirEnableWhenBehaviorEnum read GetEnableBehaviorST write SetEnableBehaviorST;
    property enableBehaviorElement : TFhirEnum read FEnableBehavior write SetEnableBehavior;

    // Typed access to An indication, if true, that the item must be present in a "completed" QuestionnaireResponse.  If false, the item may be skipped when answering the questionnaire.
    property required : Boolean read GetRequiredST write SetRequiredST;
    // An indication, if true, that the item must be present in a "completed" QuestionnaireResponse.  If false, the item may be skipped when answering the questionnaire.
    property requiredElement : TFhirBoolean read FRequired write SetRequired;

    // Typed access to An indication, if true, that the item may occur multiple times in the response, collecting multiple answers for questions or multiple sets of answers for groups.
    property repeats : Boolean read GetRepeatsST write SetRepeatsST;
    // An indication, if true, that the item may occur multiple times in the response, collecting multiple answers for questions or multiple sets of answers for groups.
    property repeatsElement : TFhirBoolean read FRepeats write SetRepeats;

    // Typed access to An indication, when true, that the value cannot be changed by a human respondent to the Questionnaire.
    property readOnly : Boolean read GetReadOnlyST write SetReadOnlyST;
    // An indication, when true, that the value cannot be changed by a human respondent to the Questionnaire.
    property readOnlyElement : TFhirBoolean read FReadOnly write SetReadOnly;

    // Typed access to The maximum number of characters that are permitted in the answer to be considered a "valid" QuestionnaireResponse.
    property maxLength : String read GetMaxLengthST write SetMaxLengthST;
    // The maximum number of characters that are permitted in the answer to be considered a "valid" QuestionnaireResponse.
    property maxLengthElement : TFhirInteger read FMaxLength write SetMaxLength;

    // Typed access to A reference to a value set containing a list of codes representing permitted answers for a "choice" or "open-choice" question.
    property answerValueSet : String read GetAnswerValueSetST write SetAnswerValueSetST;
    // A reference to a value set containing a list of codes representing permitted answers for a "choice" or "open-choice" question.
    property answerValueSetElement : TFhirCanonical read FAnswerValueSet write SetAnswerValueSet;

    // One of the permitted answers for a "choice" or "open-choice" question.
    property answerOptionList : TFhirQuestionnaireItemAnswerOptionList read GetAnswerOptionList;
    property hasAnswerOptionList : boolean read GetHasAnswerOptionList;

    // One or more values that should be pre-populated in the answer when initially rendering the questionnaire for user input.
    property initialList : TFhirQuestionnaireItemInitialList read GetInitialList;
    property hasInitialList : boolean read GetHasInitialList;

    // Text, questions and other groups to be nested beneath a question or group.
    property itemList : TFhirQuestionnaireItemList read GetItemList;
    property hasItemList : boolean read GetHasItemList;

  end;

  TFhirQuestionnaireItemListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirQuestionnaireItemList;
    function GetCurrent : TFhirQuestionnaireItem;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirQuestionnaireItemList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirQuestionnaireItem read GetCurrent;
  end;

  TFhirQuestionnaireItemList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirQuestionnaireItem;
    procedure SetItemN(index : Integer; value : TFhirQuestionnaireItem);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirQuestionnaireItemList; overload;
    function Clone : TFhirQuestionnaireItemList; overload;
    function GetEnumerator : TFhirQuestionnaireItemListEnumerator;
    
    //  Add a FhirQuestionnaireItem to the end of the list.
    function Append : TFhirQuestionnaireItem;
    
    // Add an already existing FhirQuestionnaireItem to the end of the list.
    function AddItem(value : TFhirQuestionnaireItem) : TFhirQuestionnaireItem; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirQuestionnaireItem) : Integer;
    
    // Insert FhirQuestionnaireItem before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirQuestionnaireItem;
    
    // Insert an existing FhirQuestionnaireItem before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirQuestionnaireItem);
    
    // Get the iIndexth FhirQuestionnaireItem. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirQuestionnaireItem);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirQuestionnaireItem;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirQuestionnaireItems[index : Integer] : TFhirQuestionnaireItem read GetItemN write SetItemN; default;
  End;

  // A constraint indicating that this item should only be enabled (displayed/allow answers to be captured) when the specified condition is true.
  TFhirQuestionnaireItemEnableWhen = class (TFhirBackboneElement)
  protected
    FQuestion : TFhirString;
    FOperator : TFhirEnum;
    FAnswer : TFhirDataType;
    procedure SetQuestion(value : TFhirString);
    function GetQuestionST : String;
    procedure SetQuestionST(value : String);
    procedure SetOperator(value : TFhirEnum);
    function GetOperatorST : TFhirQuestionnaireItemOperatorEnum;
    procedure SetOperatorST(value : TFhirQuestionnaireItemOperatorEnum);
    procedure SetAnswer(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirQuestionnaireItemEnableWhen; overload;
    function Clone : TFhirQuestionnaireItemEnableWhen; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The linkId for the question whose answer (or lack of answer) governs whether this item is enabled.
    property question : String read GetQuestionST write SetQuestionST;
    // The linkId for the question whose answer (or lack of answer) governs whether this item is enabled.
    property questionElement : TFhirString read FQuestion write SetQuestion;

    // Specifies the criteria by which the question is enabled.
    property operator : TFhirQuestionnaireItemOperatorEnum read GetOperatorST write SetOperatorST;
    property operatorElement : TFhirEnum read FOperator write SetOperator;

    // Typed access to A value that the referenced question is tested using the specified operator in order for the item to be enabled. (defined for API consistency)
    property answer : TFhirDataType read FAnswer write SetAnswer;
    // A value that the referenced question is tested using the specified operator in order for the item to be enabled.
    property answerElement : TFhirDataType read FAnswer write SetAnswer;

  end;

  TFhirQuestionnaireItemEnableWhenListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirQuestionnaireItemEnableWhenList;
    function GetCurrent : TFhirQuestionnaireItemEnableWhen;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirQuestionnaireItemEnableWhenList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirQuestionnaireItemEnableWhen read GetCurrent;
  end;

  TFhirQuestionnaireItemEnableWhenList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirQuestionnaireItemEnableWhen;
    procedure SetItemN(index : Integer; value : TFhirQuestionnaireItemEnableWhen);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirQuestionnaireItemEnableWhenList; overload;
    function Clone : TFhirQuestionnaireItemEnableWhenList; overload;
    function GetEnumerator : TFhirQuestionnaireItemEnableWhenListEnumerator;
    
    //  Add a FhirQuestionnaireItemEnableWhen to the end of the list.
    function Append : TFhirQuestionnaireItemEnableWhen;
    
    // Add an already existing FhirQuestionnaireItemEnableWhen to the end of the list.
    function AddItem(value : TFhirQuestionnaireItemEnableWhen) : TFhirQuestionnaireItemEnableWhen; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirQuestionnaireItemEnableWhen) : Integer;
    
    // Insert FhirQuestionnaireItemEnableWhen before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirQuestionnaireItemEnableWhen;
    
    // Insert an existing FhirQuestionnaireItemEnableWhen before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirQuestionnaireItemEnableWhen);
    
    // Get the iIndexth FhirQuestionnaireItemEnableWhen. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirQuestionnaireItemEnableWhen);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirQuestionnaireItemEnableWhen;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirQuestionnaireItemEnableWhens[index : Integer] : TFhirQuestionnaireItemEnableWhen read GetItemN write SetItemN; default;
  End;

  // One of the permitted answers for a "choice" or "open-choice" question.
  TFhirQuestionnaireItemAnswerOption = class (TFhirBackboneElement)
  protected
    FValue : TFhirDataType;
    FInitialSelected : TFhirBoolean;
    procedure SetValue(value : TFhirDataType);
    procedure SetInitialSelected(value : TFhirBoolean);
    function GetInitialSelectedST : Boolean;
    procedure SetInitialSelectedST(value : Boolean);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirQuestionnaireItemAnswerOption; overload;
    function Clone : TFhirQuestionnaireItemAnswerOption; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A potential answer that's allowed as the answer to this question. (defined for API consistency)
    property value : TFhirDataType read FValue write SetValue;
    // A potential answer that's allowed as the answer to this question.
    property valueElement : TFhirDataType read FValue write SetValue;

    // Typed access to Indicates whether the answer value is selected when the list of possible answers is initially shown.
    property initialSelected : Boolean read GetInitialSelectedST write SetInitialSelectedST;
    // Indicates whether the answer value is selected when the list of possible answers is initially shown.
    property initialSelectedElement : TFhirBoolean read FInitialSelected write SetInitialSelected;

  end;

  TFhirQuestionnaireItemAnswerOptionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirQuestionnaireItemAnswerOptionList;
    function GetCurrent : TFhirQuestionnaireItemAnswerOption;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirQuestionnaireItemAnswerOptionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirQuestionnaireItemAnswerOption read GetCurrent;
  end;

  TFhirQuestionnaireItemAnswerOptionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirQuestionnaireItemAnswerOption;
    procedure SetItemN(index : Integer; value : TFhirQuestionnaireItemAnswerOption);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirQuestionnaireItemAnswerOptionList; overload;
    function Clone : TFhirQuestionnaireItemAnswerOptionList; overload;
    function GetEnumerator : TFhirQuestionnaireItemAnswerOptionListEnumerator;
    
    //  Add a FhirQuestionnaireItemAnswerOption to the end of the list.
    function Append : TFhirQuestionnaireItemAnswerOption;
    
    // Add an already existing FhirQuestionnaireItemAnswerOption to the end of the list.
    function AddItem(value : TFhirQuestionnaireItemAnswerOption) : TFhirQuestionnaireItemAnswerOption; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirQuestionnaireItemAnswerOption) : Integer;
    
    // Insert FhirQuestionnaireItemAnswerOption before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirQuestionnaireItemAnswerOption;
    
    // Insert an existing FhirQuestionnaireItemAnswerOption before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirQuestionnaireItemAnswerOption);
    
    // Get the iIndexth FhirQuestionnaireItemAnswerOption. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirQuestionnaireItemAnswerOption);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirQuestionnaireItemAnswerOption;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirQuestionnaireItemAnswerOptions[index : Integer] : TFhirQuestionnaireItemAnswerOption read GetItemN write SetItemN; default;
  End;

  // One or more values that should be pre-populated in the answer when initially rendering the questionnaire for user input.
  TFhirQuestionnaireItemInitial = class (TFhirBackboneElement)
  protected
    FValue : TFhirDataType;
    procedure SetValue(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirQuestionnaireItemInitial; overload;
    function Clone : TFhirQuestionnaireItemInitial; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The actual value to for an initial answer. (defined for API consistency)
    property value : TFhirDataType read FValue write SetValue;
    // The actual value to for an initial answer.
    property valueElement : TFhirDataType read FValue write SetValue;

  end;

  TFhirQuestionnaireItemInitialListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirQuestionnaireItemInitialList;
    function GetCurrent : TFhirQuestionnaireItemInitial;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirQuestionnaireItemInitialList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirQuestionnaireItemInitial read GetCurrent;
  end;

  TFhirQuestionnaireItemInitialList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirQuestionnaireItemInitial;
    procedure SetItemN(index : Integer; value : TFhirQuestionnaireItemInitial);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirQuestionnaireItemInitialList; overload;
    function Clone : TFhirQuestionnaireItemInitialList; overload;
    function GetEnumerator : TFhirQuestionnaireItemInitialListEnumerator;
    
    //  Add a FhirQuestionnaireItemInitial to the end of the list.
    function Append : TFhirQuestionnaireItemInitial;
    
    // Add an already existing FhirQuestionnaireItemInitial to the end of the list.
    function AddItem(value : TFhirQuestionnaireItemInitial) : TFhirQuestionnaireItemInitial; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirQuestionnaireItemInitial) : Integer;
    
    // Insert FhirQuestionnaireItemInitial before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirQuestionnaireItemInitial;
    
    // Insert an existing FhirQuestionnaireItemInitial before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirQuestionnaireItemInitial);
    
    // Get the iIndexth FhirQuestionnaireItemInitial. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirQuestionnaireItemInitial);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirQuestionnaireItemInitial;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirQuestionnaireItemInitials[index : Integer] : TFhirQuestionnaireItemInitial read GetItemN write SetItemN; default;
  End;

  // A structured set of questions intended to guide the collection of answers from end-users. Questionnaires provide detailed control over order, presentation, phraseology and grouping to allow coherent, consistent data collection.
  TFhirQuestionnaire = class (TFhirDomainResource)
  protected
    FUrl : TFhirUri;
    FidentifierList : TFhirIdentifierList;
    FVersion : TFhirString;
    FName : TFhirString;
    FTitle : TFhirString;
    FderivedFromList : TFhirCanonicalList;
    FStatus : TFhirEnum;
    FExperimental : TFhirBoolean;
    FSubjectType : TFhirEnumList;
    FDate : TFhirDateTime;
    FPublisher : TFhirString;
    FcontactList : TFhirContactDetailList;
    FDescription : TFhirMarkdown;
    FuseContextList : TFhirUsageContextList;
    FjurisdictionList : TFhirCodeableConceptList;
    FPurpose : TFhirMarkdown;
    FCopyright : TFhirMarkdown;
    FApprovalDate : TFhirDate;
    FLastReviewDate : TFhirDate;
    FEffectivePeriod : TFhirPeriod;
    FcodeList : TFhirCodingList;
    FitemList : TFhirQuestionnaireItemList;
    procedure SetUrl(value : TFhirUri);
    function GetUrlST : String;
    procedure SetUrlST(value : String);
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetVersion(value : TFhirString);
    function GetVersionST : String;
    procedure SetVersionST(value : String);
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetTitle(value : TFhirString);
    function GetTitleST : String;
    procedure SetTitleST(value : String);
    function GetDerivedFromList : TFhirCanonicalList;
    function GetHasDerivedFromList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirPublicationStatusEnum;
    procedure SetStatusST(value : TFhirPublicationStatusEnum);
    procedure SetExperimental(value : TFhirBoolean);
    function GetExperimentalST : Boolean;
    procedure SetExperimentalST(value : Boolean);
    function GetSubjectType : TFhirEnumList;
    function GetHasSubjectType : Boolean;
    procedure SetDate(value : TFhirDateTime);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    procedure SetPublisher(value : TFhirString);
    function GetPublisherST : String;
    procedure SetPublisherST(value : String);
    function GetContactList : TFhirContactDetailList;
    function GetHasContactList : Boolean;
    procedure SetDescription(value : TFhirMarkdown);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetUseContextList : TFhirUsageContextList;
    function GetHasUseContextList : Boolean;
    function GetJurisdictionList : TFhirCodeableConceptList;
    function GetHasJurisdictionList : Boolean;
    procedure SetPurpose(value : TFhirMarkdown);
    function GetPurposeST : String;
    procedure SetPurposeST(value : String);
    procedure SetCopyright(value : TFhirMarkdown);
    function GetCopyrightST : String;
    procedure SetCopyrightST(value : String);
    procedure SetApprovalDate(value : TFhirDate);
    function GetApprovalDateST : TFslDateTime;
    procedure SetApprovalDateST(value : TFslDateTime);
    procedure SetLastReviewDate(value : TFhirDate);
    function GetLastReviewDateST : TFslDateTime;
    procedure SetLastReviewDateST(value : TFslDateTime);
    procedure SetEffectivePeriod(value : TFhirPeriod);
    function GetCodeList : TFhirCodingList;
    function GetHasCodeList : Boolean;
    function GetItemList : TFhirQuestionnaireItemList;
    function GetHasItemList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirQuestionnaire; overload;
    function Clone : TFhirQuestionnaire; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An absolute URI that is used to identify this questionnaire when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this questionnaire is (or will be) published. This URL can be the target of a canonical reference. It SHALL remain the same when the questionnaire is stored on different servers.
    property url : String read GetUrlST write SetUrlST;
    // An absolute URI that is used to identify this questionnaire when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this questionnaire is (or will be) published. This URL can be the target of a canonical reference. It SHALL remain the same when the questionnaire is stored on different servers.
    property urlElement : TFhirUri read FUrl write SetUrl;

    // A formal identifier that is used to identify this questionnaire when it is represented in other formats, or referenced in a specification, model, design or an instance.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The identifier that is used to identify this version of the questionnaire when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the questionnaire author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
    property version : String read GetVersionST write SetVersionST;
    // The identifier that is used to identify this version of the questionnaire when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the questionnaire author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to A natural language name identifying the questionnaire. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property name : String read GetNameST write SetNameST;
    // A natural language name identifying the questionnaire. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A short, descriptive, user-friendly title for the questionnaire.
    property title : String read GetTitleST write SetTitleST;
    // A short, descriptive, user-friendly title for the questionnaire.
    property titleElement : TFhirString read FTitle write SetTitle;

    // The URL of a Questionnaire that this Questionnaire is based on.
    property derivedFromList : TFhirCanonicalList read GetDerivedFromList;
    property hasDerivedFromList : boolean read GetHasDerivedFromList;

    // The status of this questionnaire. Enables tracking the life-cycle of the content.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A Boolean value to indicate that this questionnaire is authored for testing purposes (or education/evaluation/marketing) and is not intended to be used for genuine usage.
    property experimental : Boolean read GetExperimentalST write SetExperimentalST;
    // A Boolean value to indicate that this questionnaire is authored for testing purposes (or education/evaluation/marketing) and is not intended to be used for genuine usage.
    property experimentalElement : TFhirBoolean read FExperimental write SetExperimental;

    property subjectType : TFhirEnumList read GetSubjectType;
    property subjectTypeList : TFhirEnumList read GetSubjectType;
    property hasSubjectType : boolean read GetHasSubjectType;
    // Typed access to The date  (and optionally time) when the questionnaire was published. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the questionnaire changes.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date  (and optionally time) when the questionnaire was published. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the questionnaire changes.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The name of the organization or individual that published the questionnaire.
    property publisher : String read GetPublisherST write SetPublisherST;
    // The name of the organization or individual that published the questionnaire.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Contact details to assist a user in finding and communicating with the publisher.
    property contactList : TFhirContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to A free text natural language description of the questionnaire from a consumer's perspective.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A free text natural language description of the questionnaire from a consumer's perspective.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // The content was developed with a focus and intent of supporting the contexts that are listed. These contexts may be general categories (gender, age, ...) or may be references to specific programs (insurance plans, studies, ...) and may be used to assist with indexing and searching for appropriate questionnaire instances.
    property useContextList : TFhirUsageContextList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // A legal or geographic region in which the questionnaire is intended to be used.
    property jurisdictionList : TFhirCodeableConceptList read GetJurisdictionList;
    property hasJurisdictionList : boolean read GetHasJurisdictionList;

    // Typed access to Explanation of why this questionnaire is needed and why it has been designed as it has.
    property purpose : String read GetPurposeST write SetPurposeST;
    // Explanation of why this questionnaire is needed and why it has been designed as it has.
    property purposeElement : TFhirMarkdown read FPurpose write SetPurpose;

    // Typed access to A copyright statement relating to the questionnaire and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the questionnaire.
    property copyright : String read GetCopyrightST write SetCopyrightST;
    // A copyright statement relating to the questionnaire and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the questionnaire.
    property copyrightElement : TFhirMarkdown read FCopyright write SetCopyright;

    // Typed access to The date on which the resource content was approved by the publisher. Approval happens once when the content is officially approved for usage.
    property approvalDate : TFslDateTime read GetApprovalDateST write SetApprovalDateST;
    // The date on which the resource content was approved by the publisher. Approval happens once when the content is officially approved for usage.
    property approvalDateElement : TFhirDate read FApprovalDate write SetApprovalDate;

    // Typed access to The date on which the resource content was last reviewed. Review happens periodically after approval but does not change the original approval date.
    property lastReviewDate : TFslDateTime read GetLastReviewDateST write SetLastReviewDateST;
    // The date on which the resource content was last reviewed. Review happens periodically after approval but does not change the original approval date.
    property lastReviewDateElement : TFhirDate read FLastReviewDate write SetLastReviewDate;

    // Typed access to The period during which the questionnaire content was or is planned to be in active use. (defined for API consistency)
    property effectivePeriod : TFhirPeriod read FEffectivePeriod write SetEffectivePeriod;
    // The period during which the questionnaire content was or is planned to be in active use.
    property effectivePeriodElement : TFhirPeriod read FEffectivePeriod write SetEffectivePeriod;

    // An identifier for this question or group of questions in a particular terminology such as LOINC.
    property codeList : TFhirCodingList read GetCodeList;
    property hasCodeList : boolean read GetHasCodeList;

    // A particular question, question grouping or display text that is part of the questionnaire.
    property itemList : TFhirQuestionnaireItemList read GetItemList;
    property hasItemList : boolean read GetHasItemList;

  end;

  TFhirQuestionnaireListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirQuestionnaireList;
    function GetCurrent : TFhirQuestionnaire;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirQuestionnaireList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirQuestionnaire read GetCurrent;
  end;

  TFhirQuestionnaireList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirQuestionnaire;
    procedure SetItemN(index : Integer; value : TFhirQuestionnaire);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirQuestionnaireList; overload;
    function Clone : TFhirQuestionnaireList; overload;
    function GetEnumerator : TFhirQuestionnaireListEnumerator;
    
    //  Add a FhirQuestionnaire to the end of the list.
    function Append : TFhirQuestionnaire;
    
    // Add an already existing FhirQuestionnaire to the end of the list.
    function AddItem(value : TFhirQuestionnaire) : TFhirQuestionnaire; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirQuestionnaire) : Integer;
    
    // Insert FhirQuestionnaire before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirQuestionnaire;
    
    // Insert an existing FhirQuestionnaire before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirQuestionnaire);
    
    // Get the iIndexth FhirQuestionnaire. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirQuestionnaire);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirQuestionnaire;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirQuestionnaires[index : Integer] : TFhirQuestionnaire read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_QUESTIONNAIRE}
{$IFDEF FHIR_SEARCHPARAMETER}
  // Used to define the parts of a composite search parameter.
  TFhirSearchParameterComponent = class (TFhirBackboneElement)
  protected
    FDefinition : TFhirCanonical;
    FExpression : TFhirString;
    procedure SetDefinition(value : TFhirCanonical);
    function GetDefinitionST : String;
    procedure SetDefinitionST(value : String);
    procedure SetExpression(value : TFhirString);
    function GetExpressionST : String;
    procedure SetExpressionST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSearchParameterComponent; overload;
    function Clone : TFhirSearchParameterComponent; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The definition of the search parameter that describes this part.
    property definition : String read GetDefinitionST write SetDefinitionST;
    // The definition of the search parameter that describes this part.
    property definitionElement : TFhirCanonical read FDefinition write SetDefinition;

    // Typed access to A sub-expression that defines how to extract values for this component from the output of the main SearchParameter.expression.
    property expression : String read GetExpressionST write SetExpressionST;
    // A sub-expression that defines how to extract values for this component from the output of the main SearchParameter.expression.
    property expressionElement : TFhirString read FExpression write SetExpression;

  end;

  TFhirSearchParameterComponentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSearchParameterComponentList;
    function GetCurrent : TFhirSearchParameterComponent;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSearchParameterComponentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSearchParameterComponent read GetCurrent;
  end;

  TFhirSearchParameterComponentList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSearchParameterComponent;
    procedure SetItemN(index : Integer; value : TFhirSearchParameterComponent);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSearchParameterComponentList; overload;
    function Clone : TFhirSearchParameterComponentList; overload;
    function GetEnumerator : TFhirSearchParameterComponentListEnumerator;
    
    //  Add a FhirSearchParameterComponent to the end of the list.
    function Append : TFhirSearchParameterComponent;
    
    // Add an already existing FhirSearchParameterComponent to the end of the list.
    function AddItem(value : TFhirSearchParameterComponent) : TFhirSearchParameterComponent; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSearchParameterComponent) : Integer;
    
    // Insert FhirSearchParameterComponent before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSearchParameterComponent;
    
    // Insert an existing FhirSearchParameterComponent before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSearchParameterComponent);
    
    // Get the iIndexth FhirSearchParameterComponent. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSearchParameterComponent);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSearchParameterComponent;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSearchParameterComponents[index : Integer] : TFhirSearchParameterComponent read GetItemN write SetItemN; default;
  End;

  // A search parameter that defines a named search item that can be used to search/filter on a resource.
  TFhirSearchParameter = class (TFhirDomainResource)
  protected
    FUrl : TFhirUri;
    FVersion : TFhirString;
    FName : TFhirString;
    FDerivedFrom : TFhirCanonical;
    FStatus : TFhirEnum;
    FExperimental : TFhirBoolean;
    FDate : TFhirDateTime;
    FPublisher : TFhirString;
    FcontactList : TFhirContactDetailList;
    FDescription : TFhirMarkdown;
    FuseContextList : TFhirUsageContextList;
    FjurisdictionList : TFhirCodeableConceptList;
    FPurpose : TFhirMarkdown;
    FCode : TFhirCode;
    FBase : TFhirEnumList;
    FType_ : TFhirEnum;
    FExpression : TFhirString;
    FXpath : TFhirString;
    FXpathUsage : TFhirEnum;
    FTarget : TFhirEnumList;
    FMultipleOr : TFhirBoolean;
    FMultipleAnd : TFhirBoolean;
    FComparator : TFhirEnumList;
    FModifier : TFhirEnumList;
    FchainList : TFhirStringList;
    FcomponentList : TFhirSearchParameterComponentList;
    procedure SetUrl(value : TFhirUri);
    function GetUrlST : String;
    procedure SetUrlST(value : String);
    procedure SetVersion(value : TFhirString);
    function GetVersionST : String;
    procedure SetVersionST(value : String);
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetDerivedFrom(value : TFhirCanonical);
    function GetDerivedFromST : String;
    procedure SetDerivedFromST(value : String);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirPublicationStatusEnum;
    procedure SetStatusST(value : TFhirPublicationStatusEnum);
    procedure SetExperimental(value : TFhirBoolean);
    function GetExperimentalST : Boolean;
    procedure SetExperimentalST(value : Boolean);
    procedure SetDate(value : TFhirDateTime);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    procedure SetPublisher(value : TFhirString);
    function GetPublisherST : String;
    procedure SetPublisherST(value : String);
    function GetContactList : TFhirContactDetailList;
    function GetHasContactList : Boolean;
    procedure SetDescription(value : TFhirMarkdown);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetUseContextList : TFhirUsageContextList;
    function GetHasUseContextList : Boolean;
    function GetJurisdictionList : TFhirCodeableConceptList;
    function GetHasJurisdictionList : Boolean;
    procedure SetPurpose(value : TFhirMarkdown);
    function GetPurposeST : String;
    procedure SetPurposeST(value : String);
    procedure SetCode(value : TFhirCode);
    function GetCodeST : String;
    procedure SetCodeST(value : String);
    function GetBase : TFhirEnumList;
    function GetHasBase : Boolean;
    procedure SetType_(value : TFhirEnum);
    function GetType_ST : TFhirSearchParamTypeEnum;
    procedure SetType_ST(value : TFhirSearchParamTypeEnum);
    procedure SetExpression(value : TFhirString);
    function GetExpressionST : String;
    procedure SetExpressionST(value : String);
    procedure SetXpath(value : TFhirString);
    function GetXpathST : String;
    procedure SetXpathST(value : String);
    procedure SetXpathUsage(value : TFhirEnum);
    function GetXpathUsageST : TFhirXPathUsageTypeEnum;
    procedure SetXpathUsageST(value : TFhirXPathUsageTypeEnum);
    function GetTarget : TFhirEnumList;
    function GetHasTarget : Boolean;
    procedure SetMultipleOr(value : TFhirBoolean);
    function GetMultipleOrST : Boolean;
    procedure SetMultipleOrST(value : Boolean);
    procedure SetMultipleAnd(value : TFhirBoolean);
    function GetMultipleAndST : Boolean;
    procedure SetMultipleAndST(value : Boolean);
    function GetComparator : TFhirEnumList;
    function GetHasComparator : Boolean;
    function GetComparatorST : TFhirSearchComparatorEnumList;
    procedure SetComparatorST(value : TFhirSearchComparatorEnumList);
    function GetModifier : TFhirEnumList;
    function GetHasModifier : Boolean;
    function GetModifierST : TFhirSearchModifierCodeEnumList;
    procedure SetModifierST(value : TFhirSearchModifierCodeEnumList);
    function GetChainList : TFhirStringList;
    function GetHasChainList : Boolean;
    function GetComponentList : TFhirSearchParameterComponentList;
    function GetHasComponentList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSearchParameter; overload;
    function Clone : TFhirSearchParameter; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An absolute URI that is used to identify this search parameter when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this search parameter is (or will be) published. This URL can be the target of a canonical reference. It SHALL remain the same when the search parameter is stored on different servers.
    property url : String read GetUrlST write SetUrlST;
    // An absolute URI that is used to identify this search parameter when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this search parameter is (or will be) published. This URL can be the target of a canonical reference. It SHALL remain the same when the search parameter is stored on different servers.
    property urlElement : TFhirUri read FUrl write SetUrl;

    // Typed access to The identifier that is used to identify this version of the search parameter when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the search parameter author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
    property version : String read GetVersionST write SetVersionST;
    // The identifier that is used to identify this version of the search parameter when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the search parameter author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to A natural language name identifying the search parameter. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property name : String read GetNameST write SetNameST;
    // A natural language name identifying the search parameter. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to Where this search parameter is originally defined. If a derivedFrom is provided, then the details in the search parameter must be consistent with the definition from which it is defined. i.e. the parameter should have the same meaning, and (usually) the functionality should be a proper subset of the underlying search parameter.
    property derivedFrom : String read GetDerivedFromST write SetDerivedFromST;
    // Where this search parameter is originally defined. If a derivedFrom is provided, then the details in the search parameter must be consistent with the definition from which it is defined. i.e. the parameter should have the same meaning, and (usually) the functionality should be a proper subset of the underlying search parameter.
    property derivedFromElement : TFhirCanonical read FDerivedFrom write SetDerivedFrom;

    // The status of this search parameter. Enables tracking the life-cycle of the content.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A Boolean value to indicate that this search parameter is authored for testing purposes (or education/evaluation/marketing) and is not intended to be used for genuine usage.
    property experimental : Boolean read GetExperimentalST write SetExperimentalST;
    // A Boolean value to indicate that this search parameter is authored for testing purposes (or education/evaluation/marketing) and is not intended to be used for genuine usage.
    property experimentalElement : TFhirBoolean read FExperimental write SetExperimental;

    // Typed access to The date  (and optionally time) when the search parameter was published. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the search parameter changes.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date  (and optionally time) when the search parameter was published. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the search parameter changes.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The name of the organization or individual that published the search parameter.
    property publisher : String read GetPublisherST write SetPublisherST;
    // The name of the organization or individual that published the search parameter.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Contact details to assist a user in finding and communicating with the publisher.
    property contactList : TFhirContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to And how it used.
    property description : String read GetDescriptionST write SetDescriptionST;
    // And how it used.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // The content was developed with a focus and intent of supporting the contexts that are listed. These contexts may be general categories (gender, age, ...) or may be references to specific programs (insurance plans, studies, ...) and may be used to assist with indexing and searching for appropriate search parameter instances.
    property useContextList : TFhirUsageContextList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // A legal or geographic region in which the search parameter is intended to be used.
    property jurisdictionList : TFhirCodeableConceptList read GetJurisdictionList;
    property hasJurisdictionList : boolean read GetHasJurisdictionList;

    // Typed access to Explanation of why this search parameter is needed and why it has been designed as it has.
    property purpose : String read GetPurposeST write SetPurposeST;
    // Explanation of why this search parameter is needed and why it has been designed as it has.
    property purposeElement : TFhirMarkdown read FPurpose write SetPurpose;

    // Typed access to The code used in the URL or the parameter name in a parameters resource for this search parameter.
    property code : String read GetCodeST write SetCodeST;
    // The code used in the URL or the parameter name in a parameters resource for this search parameter.
    property codeElement : TFhirCode read FCode write SetCode;

    property base : TFhirEnumList read GetBase;
    property baseList : TFhirEnumList read GetBase;
    property hasBase : boolean read GetHasBase;
    // The type of value that a search parameter may contain, and how the content is interpreted.
    property type_ : TFhirSearchParamTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to A FHIRPath expression that returns a set of elements for the search parameter.
    property expression : String read GetExpressionST write SetExpressionST;
    // A FHIRPath expression that returns a set of elements for the search parameter.
    property expressionElement : TFhirString read FExpression write SetExpression;

    // Typed access to An XPath expression that returns a set of elements for the search parameter.
    property xpath : String read GetXpathST write SetXpathST;
    // An XPath expression that returns a set of elements for the search parameter.
    property xpathElement : TFhirString read FXpath write SetXpath;

    // How the search parameter relates to the set of elements returned by evaluating the xpath query.
    property xpathUsage : TFhirXPathUsageTypeEnum read GetXpathUsageST write SetXpathUsageST;
    property xpathUsageElement : TFhirEnum read FXpathUsage write SetXpathUsage;

    property target : TFhirEnumList read GetTarget;
    property targetList : TFhirEnumList read GetTarget;
    property hasTarget : boolean read GetHasTarget;
    // Typed access to Whether multiple values are allowed for each time the parameter exists. Values are separated by commas, and the parameter matches if any of the values match.
    property multipleOr : Boolean read GetMultipleOrST write SetMultipleOrST;
    // Whether multiple values are allowed for each time the parameter exists. Values are separated by commas, and the parameter matches if any of the values match.
    property multipleOrElement : TFhirBoolean read FMultipleOr write SetMultipleOr;

    // Typed access to Whether multiple parameters are allowed - e.g. more than one parameter with the same name. The search matches if all the parameters match.
    property multipleAnd : Boolean read GetMultipleAndST write SetMultipleAndST;
    // Whether multiple parameters are allowed - e.g. more than one parameter with the same name. The search matches if all the parameters match.
    property multipleAndElement : TFhirBoolean read FMultipleAnd write SetMultipleAnd;

    // Comparators supported for the search parameter.
    property comparator : TFhirSearchComparatorEnumList read GetComparatorST write SetComparatorST;
    property comparatorList : TFhirEnumList read GetComparator;
    property hasComparator : boolean read GetHasComparator;
    // A modifier supported for the search parameter.
    property modifier : TFhirSearchModifierCodeEnumList read GetModifierST write SetModifierST;
    property modifierList : TFhirEnumList read GetModifier;
    property hasModifier : boolean read GetHasModifier;
    // Contains the names of any search parameters which may be chained to the containing search parameter. Chained parameters may be added to search parameters of type reference and specify that resources will only be returned if they contain a reference to a resource which matches the chained parameter value. Values for this field should be drawn from SearchParameter.code for a parameter on the target resource type.
    property chainList : TFhirStringList read GetChainList;
    property hasChainList : boolean read GetHasChainList;

    // Used to define the parts of a composite search parameter.
    property componentList : TFhirSearchParameterComponentList read GetComponentList;
    property hasComponentList : boolean read GetHasComponentList;

  end;

  TFhirSearchParameterListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSearchParameterList;
    function GetCurrent : TFhirSearchParameter;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSearchParameterList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSearchParameter read GetCurrent;
  end;

  TFhirSearchParameterList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSearchParameter;
    procedure SetItemN(index : Integer; value : TFhirSearchParameter);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSearchParameterList; overload;
    function Clone : TFhirSearchParameterList; overload;
    function GetEnumerator : TFhirSearchParameterListEnumerator;
    
    //  Add a FhirSearchParameter to the end of the list.
    function Append : TFhirSearchParameter;
    
    // Add an already existing FhirSearchParameter to the end of the list.
    function AddItem(value : TFhirSearchParameter) : TFhirSearchParameter; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSearchParameter) : Integer;
    
    // Insert FhirSearchParameter before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSearchParameter;
    
    // Insert an existing FhirSearchParameter before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSearchParameter);
    
    // Get the iIndexth FhirSearchParameter. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSearchParameter);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSearchParameter;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSearchParameters[index : Integer] : TFhirSearchParameter read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_SEARCHPARAMETER}
{$IFDEF FHIR_SPECIMENDEFINITION}
  // Specimen conditioned in a container as expected by the testing laboratory.
  TFhirSpecimenDefinitionTypeTested = class (TFhirBackboneElement)
  protected
    FIsDerived : TFhirBoolean;
    FType_ : TFhirCodeableConcept;
    FPreference : TFhirEnum;
    FContainer : TFhirSpecimenDefinitionTypeTestedContainer;
    FRequirement : TFhirString;
    FRetentionTime : TFhirDuration;
    FrejectionCriterionList : TFhirCodeableConceptList;
    FhandlingList : TFhirSpecimenDefinitionTypeTestedHandlingList;
    procedure SetIsDerived(value : TFhirBoolean);
    function GetIsDerivedST : Boolean;
    procedure SetIsDerivedST(value : Boolean);
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetPreference(value : TFhirEnum);
    function GetPreferenceST : TFhirSpecimenContainedPreferenceEnum;
    procedure SetPreferenceST(value : TFhirSpecimenContainedPreferenceEnum);
    procedure SetContainer(value : TFhirSpecimenDefinitionTypeTestedContainer);
    procedure SetRequirement(value : TFhirString);
    function GetRequirementST : String;
    procedure SetRequirementST(value : String);
    procedure SetRetentionTime(value : TFhirDuration);
    function GetRejectionCriterionList : TFhirCodeableConceptList;
    function GetHasRejectionCriterionList : Boolean;
    function GetHandlingList : TFhirSpecimenDefinitionTypeTestedHandlingList;
    function GetHasHandlingList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSpecimenDefinitionTypeTested; overload;
    function Clone : TFhirSpecimenDefinitionTypeTested; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Primary of secondary specimen.
    property isDerived : Boolean read GetIsDerivedST write SetIsDerivedST;
    // Primary of secondary specimen.
    property isDerivedElement : TFhirBoolean read FIsDerived write SetIsDerived;

    // Typed access to The kind of specimen conditioned for testing expected by lab. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The kind of specimen conditioned for testing expected by lab.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // The preference for this type of conditioned specimen.
    property preference : TFhirSpecimenContainedPreferenceEnum read GetPreferenceST write SetPreferenceST;
    property preferenceElement : TFhirEnum read FPreference write SetPreference;

    // Typed access to The specimen's container. (defined for API consistency)
    property container : TFhirSpecimenDefinitionTypeTestedContainer read FContainer write SetContainer;
    // The specimen's container.
    property containerElement : TFhirSpecimenDefinitionTypeTestedContainer read FContainer write SetContainer;

    // Typed access to Requirements for delivery and special handling of this kind of conditioned specimen.
    property requirement : String read GetRequirementST write SetRequirementST;
    // Requirements for delivery and special handling of this kind of conditioned specimen.
    property requirementElement : TFhirString read FRequirement write SetRequirement;

    // Typed access to The usual time that a specimen of this kind is retained after the ordered tests are completed, for the purpose of additional testing. (defined for API consistency)
    property retentionTime : TFhirDuration read FRetentionTime write SetRetentionTime;
    // The usual time that a specimen of this kind is retained after the ordered tests are completed, for the purpose of additional testing.
    property retentionTimeElement : TFhirDuration read FRetentionTime write SetRetentionTime;

    // Criterion for rejection of the specimen in its container by the laboratory.
    property rejectionCriterionList : TFhirCodeableConceptList read GetRejectionCriterionList;
    property hasRejectionCriterionList : boolean read GetHasRejectionCriterionList;

    // Set of instructions for preservation/transport of the specimen at a defined temperature interval, prior the testing process.
    property handlingList : TFhirSpecimenDefinitionTypeTestedHandlingList read GetHandlingList;
    property hasHandlingList : boolean read GetHasHandlingList;

  end;

  TFhirSpecimenDefinitionTypeTestedListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSpecimenDefinitionTypeTestedList;
    function GetCurrent : TFhirSpecimenDefinitionTypeTested;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSpecimenDefinitionTypeTestedList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSpecimenDefinitionTypeTested read GetCurrent;
  end;

  TFhirSpecimenDefinitionTypeTestedList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSpecimenDefinitionTypeTested;
    procedure SetItemN(index : Integer; value : TFhirSpecimenDefinitionTypeTested);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSpecimenDefinitionTypeTestedList; overload;
    function Clone : TFhirSpecimenDefinitionTypeTestedList; overload;
    function GetEnumerator : TFhirSpecimenDefinitionTypeTestedListEnumerator;
    
    //  Add a FhirSpecimenDefinitionTypeTested to the end of the list.
    function Append : TFhirSpecimenDefinitionTypeTested;
    
    // Add an already existing FhirSpecimenDefinitionTypeTested to the end of the list.
    function AddItem(value : TFhirSpecimenDefinitionTypeTested) : TFhirSpecimenDefinitionTypeTested; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSpecimenDefinitionTypeTested) : Integer;
    
    // Insert FhirSpecimenDefinitionTypeTested before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSpecimenDefinitionTypeTested;
    
    // Insert an existing FhirSpecimenDefinitionTypeTested before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSpecimenDefinitionTypeTested);
    
    // Get the iIndexth FhirSpecimenDefinitionTypeTested. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSpecimenDefinitionTypeTested);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSpecimenDefinitionTypeTested;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSpecimenDefinitionTypeTesteds[index : Integer] : TFhirSpecimenDefinitionTypeTested read GetItemN write SetItemN; default;
  End;

  // The specimen's container.
  TFhirSpecimenDefinitionTypeTestedContainer = class (TFhirBackboneElement)
  protected
    FMaterial : TFhirCodeableConcept;
    FType_ : TFhirCodeableConcept;
    FCap : TFhirCodeableConcept;
    FDescription : TFhirString;
    FCapacity : TFhirQuantity;
    FMinimumVolume : TFhirDataType;
    FadditiveList : TFhirSpecimenDefinitionTypeTestedContainerAdditiveList;
    FPreparation : TFhirString;
    procedure SetMaterial(value : TFhirCodeableConcept);
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetCap(value : TFhirCodeableConcept);
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetCapacity(value : TFhirQuantity);
    procedure SetMinimumVolume(value : TFhirDataType);
    function GetAdditiveList : TFhirSpecimenDefinitionTypeTestedContainerAdditiveList;
    function GetHasAdditiveList : Boolean;
    procedure SetPreparation(value : TFhirString);
    function GetPreparationST : String;
    procedure SetPreparationST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSpecimenDefinitionTypeTestedContainer; overload;
    function Clone : TFhirSpecimenDefinitionTypeTestedContainer; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The type of material of the container. (defined for API consistency)
    property material : TFhirCodeableConcept read FMaterial write SetMaterial;
    // The type of material of the container.
    property materialElement : TFhirCodeableConcept read FMaterial write SetMaterial;

    // Typed access to The type of container used to contain this kind of specimen. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The type of container used to contain this kind of specimen.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Color of container cap. (defined for API consistency)
    property cap : TFhirCodeableConcept read FCap write SetCap;
    // Color of container cap.
    property capElement : TFhirCodeableConcept read FCap write SetCap;

    // Typed access to The textual description of the kind of container.
    property description : String read GetDescriptionST write SetDescriptionST;
    // The textual description of the kind of container.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to The capacity (volume or other measure) of this kind of container. (defined for API consistency)
    property capacity : TFhirQuantity read FCapacity write SetCapacity;
    // The capacity (volume or other measure) of this kind of container.
    property capacityElement : TFhirQuantity read FCapacity write SetCapacity;

    // Typed access to The minimum volume to be conditioned in the container. (defined for API consistency)
    property minimumVolume : TFhirDataType read FMinimumVolume write SetMinimumVolume;
    // The minimum volume to be conditioned in the container.
    property minimumVolumeElement : TFhirDataType read FMinimumVolume write SetMinimumVolume;

    // Substance introduced in the kind of container to preserve, maintain or enhance the specimen. Examples: Formalin, Citrate, EDTA.
    property additiveList : TFhirSpecimenDefinitionTypeTestedContainerAdditiveList read GetAdditiveList;
    property hasAdditiveList : boolean read GetHasAdditiveList;

    // Typed access to Special processing that should be applied to the container for this kind of specimen.
    property preparation : String read GetPreparationST write SetPreparationST;
    // Special processing that should be applied to the container for this kind of specimen.
    property preparationElement : TFhirString read FPreparation write SetPreparation;

  end;

  TFhirSpecimenDefinitionTypeTestedContainerListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSpecimenDefinitionTypeTestedContainerList;
    function GetCurrent : TFhirSpecimenDefinitionTypeTestedContainer;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSpecimenDefinitionTypeTestedContainerList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSpecimenDefinitionTypeTestedContainer read GetCurrent;
  end;

  TFhirSpecimenDefinitionTypeTestedContainerList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSpecimenDefinitionTypeTestedContainer;
    procedure SetItemN(index : Integer; value : TFhirSpecimenDefinitionTypeTestedContainer);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSpecimenDefinitionTypeTestedContainerList; overload;
    function Clone : TFhirSpecimenDefinitionTypeTestedContainerList; overload;
    function GetEnumerator : TFhirSpecimenDefinitionTypeTestedContainerListEnumerator;
    
    //  Add a FhirSpecimenDefinitionTypeTestedContainer to the end of the list.
    function Append : TFhirSpecimenDefinitionTypeTestedContainer;
    
    // Add an already existing FhirSpecimenDefinitionTypeTestedContainer to the end of the list.
    function AddItem(value : TFhirSpecimenDefinitionTypeTestedContainer) : TFhirSpecimenDefinitionTypeTestedContainer; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSpecimenDefinitionTypeTestedContainer) : Integer;
    
    // Insert FhirSpecimenDefinitionTypeTestedContainer before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSpecimenDefinitionTypeTestedContainer;
    
    // Insert an existing FhirSpecimenDefinitionTypeTestedContainer before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSpecimenDefinitionTypeTestedContainer);
    
    // Get the iIndexth FhirSpecimenDefinitionTypeTestedContainer. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSpecimenDefinitionTypeTestedContainer);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSpecimenDefinitionTypeTestedContainer;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSpecimenDefinitionTypeTestedContainers[index : Integer] : TFhirSpecimenDefinitionTypeTestedContainer read GetItemN write SetItemN; default;
  End;

  // Substance introduced in the kind of container to preserve, maintain or enhance the specimen. Examples: Formalin, Citrate, EDTA.
  TFhirSpecimenDefinitionTypeTestedContainerAdditive = class (TFhirBackboneElement)
  protected
    FAdditive : TFhirDataType;
    procedure SetAdditive(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSpecimenDefinitionTypeTestedContainerAdditive; overload;
    function Clone : TFhirSpecimenDefinitionTypeTestedContainerAdditive; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Substance introduced in the kind of container to preserve, maintain or enhance the specimen. Examples: Formalin, Citrate, EDTA. (defined for API consistency)
    property additive : TFhirDataType read FAdditive write SetAdditive;
    // Substance introduced in the kind of container to preserve, maintain or enhance the specimen. Examples: Formalin, Citrate, EDTA.
    property additiveElement : TFhirDataType read FAdditive write SetAdditive;

  end;

  TFhirSpecimenDefinitionTypeTestedContainerAdditiveListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSpecimenDefinitionTypeTestedContainerAdditiveList;
    function GetCurrent : TFhirSpecimenDefinitionTypeTestedContainerAdditive;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSpecimenDefinitionTypeTestedContainerAdditiveList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSpecimenDefinitionTypeTestedContainerAdditive read GetCurrent;
  end;

  TFhirSpecimenDefinitionTypeTestedContainerAdditiveList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSpecimenDefinitionTypeTestedContainerAdditive;
    procedure SetItemN(index : Integer; value : TFhirSpecimenDefinitionTypeTestedContainerAdditive);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSpecimenDefinitionTypeTestedContainerAdditiveList; overload;
    function Clone : TFhirSpecimenDefinitionTypeTestedContainerAdditiveList; overload;
    function GetEnumerator : TFhirSpecimenDefinitionTypeTestedContainerAdditiveListEnumerator;
    
    //  Add a FhirSpecimenDefinitionTypeTestedContainerAdditive to the end of the list.
    function Append : TFhirSpecimenDefinitionTypeTestedContainerAdditive;
    
    // Add an already existing FhirSpecimenDefinitionTypeTestedContainerAdditive to the end of the list.
    function AddItem(value : TFhirSpecimenDefinitionTypeTestedContainerAdditive) : TFhirSpecimenDefinitionTypeTestedContainerAdditive; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSpecimenDefinitionTypeTestedContainerAdditive) : Integer;
    
    // Insert FhirSpecimenDefinitionTypeTestedContainerAdditive before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSpecimenDefinitionTypeTestedContainerAdditive;
    
    // Insert an existing FhirSpecimenDefinitionTypeTestedContainerAdditive before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSpecimenDefinitionTypeTestedContainerAdditive);
    
    // Get the iIndexth FhirSpecimenDefinitionTypeTestedContainerAdditive. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSpecimenDefinitionTypeTestedContainerAdditive);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSpecimenDefinitionTypeTestedContainerAdditive;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSpecimenDefinitionTypeTestedContainerAdditives[index : Integer] : TFhirSpecimenDefinitionTypeTestedContainerAdditive read GetItemN write SetItemN; default;
  End;

  // Set of instructions for preservation/transport of the specimen at a defined temperature interval, prior the testing process.
  TFhirSpecimenDefinitionTypeTestedHandling = class (TFhirBackboneElement)
  protected
    FTemperatureQualifier : TFhirCodeableConcept;
    FTemperatureRange : TFhirRange;
    FMaxDuration : TFhirDuration;
    FInstruction : TFhirString;
    procedure SetTemperatureQualifier(value : TFhirCodeableConcept);
    procedure SetTemperatureRange(value : TFhirRange);
    procedure SetMaxDuration(value : TFhirDuration);
    procedure SetInstruction(value : TFhirString);
    function GetInstructionST : String;
    procedure SetInstructionST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSpecimenDefinitionTypeTestedHandling; overload;
    function Clone : TFhirSpecimenDefinitionTypeTestedHandling; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to It qualifies the interval of temperature, which characterizes an occurrence of handling. Conditions that are not related to temperature may be handled in the instruction element. (defined for API consistency)
    property temperatureQualifier : TFhirCodeableConcept read FTemperatureQualifier write SetTemperatureQualifier;
    // It qualifies the interval of temperature, which characterizes an occurrence of handling. Conditions that are not related to temperature may be handled in the instruction element.
    property temperatureQualifierElement : TFhirCodeableConcept read FTemperatureQualifier write SetTemperatureQualifier;

    // Typed access to The temperature interval for this set of handling instructions. (defined for API consistency)
    property temperatureRange : TFhirRange read FTemperatureRange write SetTemperatureRange;
    // The temperature interval for this set of handling instructions.
    property temperatureRangeElement : TFhirRange read FTemperatureRange write SetTemperatureRange;

    // Typed access to The maximum time interval of preservation of the specimen with these conditions. (defined for API consistency)
    property maxDuration : TFhirDuration read FMaxDuration write SetMaxDuration;
    // The maximum time interval of preservation of the specimen with these conditions.
    property maxDurationElement : TFhirDuration read FMaxDuration write SetMaxDuration;

    // Typed access to Additional textual instructions for the preservation or transport of the specimen. For instance, 'Protect from light exposure'.
    property instruction : String read GetInstructionST write SetInstructionST;
    // Additional textual instructions for the preservation or transport of the specimen. For instance, 'Protect from light exposure'.
    property instructionElement : TFhirString read FInstruction write SetInstruction;

  end;

  TFhirSpecimenDefinitionTypeTestedHandlingListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSpecimenDefinitionTypeTestedHandlingList;
    function GetCurrent : TFhirSpecimenDefinitionTypeTestedHandling;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSpecimenDefinitionTypeTestedHandlingList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSpecimenDefinitionTypeTestedHandling read GetCurrent;
  end;

  TFhirSpecimenDefinitionTypeTestedHandlingList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSpecimenDefinitionTypeTestedHandling;
    procedure SetItemN(index : Integer; value : TFhirSpecimenDefinitionTypeTestedHandling);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSpecimenDefinitionTypeTestedHandlingList; overload;
    function Clone : TFhirSpecimenDefinitionTypeTestedHandlingList; overload;
    function GetEnumerator : TFhirSpecimenDefinitionTypeTestedHandlingListEnumerator;
    
    //  Add a FhirSpecimenDefinitionTypeTestedHandling to the end of the list.
    function Append : TFhirSpecimenDefinitionTypeTestedHandling;
    
    // Add an already existing FhirSpecimenDefinitionTypeTestedHandling to the end of the list.
    function AddItem(value : TFhirSpecimenDefinitionTypeTestedHandling) : TFhirSpecimenDefinitionTypeTestedHandling; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSpecimenDefinitionTypeTestedHandling) : Integer;
    
    // Insert FhirSpecimenDefinitionTypeTestedHandling before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSpecimenDefinitionTypeTestedHandling;
    
    // Insert an existing FhirSpecimenDefinitionTypeTestedHandling before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSpecimenDefinitionTypeTestedHandling);
    
    // Get the iIndexth FhirSpecimenDefinitionTypeTestedHandling. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSpecimenDefinitionTypeTestedHandling);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSpecimenDefinitionTypeTestedHandling;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSpecimenDefinitionTypeTestedHandlings[index : Integer] : TFhirSpecimenDefinitionTypeTestedHandling read GetItemN write SetItemN; default;
  End;

  // A kind of specimen with associated set of requirements.
  TFhirSpecimenDefinition = class (TFhirDomainResource)
  protected
    FIdentifier : TFhirIdentifier;
    FTypeCollected : TFhirCodeableConcept;
    FpatientPreparationList : TFhirCodeableConceptList;
    FTimeAspect : TFhirString;
    FcollectionList : TFhirCodeableConceptList;
    FtypeTestedList : TFhirSpecimenDefinitionTypeTestedList;
    procedure SetIdentifier(value : TFhirIdentifier);
    procedure SetTypeCollected(value : TFhirCodeableConcept);
    function GetPatientPreparationList : TFhirCodeableConceptList;
    function GetHasPatientPreparationList : Boolean;
    procedure SetTimeAspect(value : TFhirString);
    function GetTimeAspectST : String;
    procedure SetTimeAspectST(value : String);
    function GetCollectionList : TFhirCodeableConceptList;
    function GetHasCollectionList : Boolean;
    function GetTypeTestedList : TFhirSpecimenDefinitionTypeTestedList;
    function GetHasTypeTestedList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSpecimenDefinition; overload;
    function Clone : TFhirSpecimenDefinition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A business identifier associated with the kind of specimen. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // A business identifier associated with the kind of specimen.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to The kind of material to be collected. (defined for API consistency)
    property typeCollected : TFhirCodeableConcept read FTypeCollected write SetTypeCollected;
    // The kind of material to be collected.
    property typeCollectedElement : TFhirCodeableConcept read FTypeCollected write SetTypeCollected;

    // Preparation of the patient for specimen collection.
    property patientPreparationList : TFhirCodeableConceptList read GetPatientPreparationList;
    property hasPatientPreparationList : boolean read GetHasPatientPreparationList;

    // Typed access to Time aspect of specimen collection (duration or offset).
    property timeAspect : String read GetTimeAspectST write SetTimeAspectST;
    // Time aspect of specimen collection (duration or offset).
    property timeAspectElement : TFhirString read FTimeAspect write SetTimeAspect;

    // The action to be performed for collecting the specimen.
    property collectionList : TFhirCodeableConceptList read GetCollectionList;
    property hasCollectionList : boolean read GetHasCollectionList;

    // Specimen conditioned in a container as expected by the testing laboratory.
    property typeTestedList : TFhirSpecimenDefinitionTypeTestedList read GetTypeTestedList;
    property hasTypeTestedList : boolean read GetHasTypeTestedList;

  end;

  TFhirSpecimenDefinitionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSpecimenDefinitionList;
    function GetCurrent : TFhirSpecimenDefinition;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSpecimenDefinitionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSpecimenDefinition read GetCurrent;
  end;

  TFhirSpecimenDefinitionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSpecimenDefinition;
    procedure SetItemN(index : Integer; value : TFhirSpecimenDefinition);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSpecimenDefinitionList; overload;
    function Clone : TFhirSpecimenDefinitionList; overload;
    function GetEnumerator : TFhirSpecimenDefinitionListEnumerator;
    
    //  Add a FhirSpecimenDefinition to the end of the list.
    function Append : TFhirSpecimenDefinition;
    
    // Add an already existing FhirSpecimenDefinition to the end of the list.
    function AddItem(value : TFhirSpecimenDefinition) : TFhirSpecimenDefinition; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSpecimenDefinition) : Integer;
    
    // Insert FhirSpecimenDefinition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSpecimenDefinition;
    
    // Insert an existing FhirSpecimenDefinition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSpecimenDefinition);
    
    // Get the iIndexth FhirSpecimenDefinition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSpecimenDefinition);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSpecimenDefinition;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSpecimenDefinitions[index : Integer] : TFhirSpecimenDefinition read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_SPECIMENDEFINITION}
{$IFDEF FHIR_STRUCTUREDEFINITION}
  // An external specification that the content is mapped to.
  TFhirStructureDefinitionMapping = class (TFhirBackboneElement)
  protected
    FIdentity : TFhirId;
    FUri : TFhirUri;
    FName : TFhirString;
    FComment : TFhirString;
    procedure SetIdentity(value : TFhirId);
    function GetIdentityST : String;
    procedure SetIdentityST(value : String);
    procedure SetUri(value : TFhirUri);
    function GetUriST : String;
    procedure SetUriST(value : String);
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetComment(value : TFhirString);
    function GetCommentST : String;
    procedure SetCommentST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirStructureDefinitionMapping; overload;
    function Clone : TFhirStructureDefinitionMapping; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An Internal id that is used to identify this mapping set when specific mappings are made.
    property identity : String read GetIdentityST write SetIdentityST;
    // An Internal id that is used to identify this mapping set when specific mappings are made.
    property identityElement : TFhirId read FIdentity write SetIdentity;

    // Typed access to An absolute URI that identifies the specification that this mapping is expressed to.
    property uri : String read GetUriST write SetUriST;
    // An absolute URI that identifies the specification that this mapping is expressed to.
    property uriElement : TFhirUri read FUri write SetUri;

    // Typed access to A name for the specification that is being mapped to.
    property name : String read GetNameST write SetNameST;
    // A name for the specification that is being mapped to.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to Comments about this mapping, including version notes, issues, scope limitations, and other important notes for usage.
    property comment : String read GetCommentST write SetCommentST;
    // Comments about this mapping, including version notes, issues, scope limitations, and other important notes for usage.
    property commentElement : TFhirString read FComment write SetComment;

  end;

  TFhirStructureDefinitionMappingListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirStructureDefinitionMappingList;
    function GetCurrent : TFhirStructureDefinitionMapping;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirStructureDefinitionMappingList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirStructureDefinitionMapping read GetCurrent;
  end;

  TFhirStructureDefinitionMappingList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirStructureDefinitionMapping;
    procedure SetItemN(index : Integer; value : TFhirStructureDefinitionMapping);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirStructureDefinitionMappingList; overload;
    function Clone : TFhirStructureDefinitionMappingList; overload;
    function GetEnumerator : TFhirStructureDefinitionMappingListEnumerator;
    
    //  Add a FhirStructureDefinitionMapping to the end of the list.
    function Append : TFhirStructureDefinitionMapping;
    
    // Add an already existing FhirStructureDefinitionMapping to the end of the list.
    function AddItem(value : TFhirStructureDefinitionMapping) : TFhirStructureDefinitionMapping; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirStructureDefinitionMapping) : Integer;
    
    // Insert FhirStructureDefinitionMapping before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirStructureDefinitionMapping;
    
    // Insert an existing FhirStructureDefinitionMapping before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirStructureDefinitionMapping);
    
    // Get the iIndexth FhirStructureDefinitionMapping. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirStructureDefinitionMapping);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirStructureDefinitionMapping;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirStructureDefinitionMappings[index : Integer] : TFhirStructureDefinitionMapping read GetItemN write SetItemN; default;
  End;

  // Identifies the types of resource or data type elements to which the extension can be applied.
  TFhirStructureDefinitionContext = class (TFhirBackboneElement)
  protected
    FType_ : TFhirEnum;
    FExpression : TFhirString;
    procedure SetType_(value : TFhirEnum);
    function GetType_ST : TFhirExtensionContextTypeEnum;
    procedure SetType_ST(value : TFhirExtensionContextTypeEnum);
    procedure SetExpression(value : TFhirString);
    function GetExpressionST : String;
    procedure SetExpressionST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirStructureDefinitionContext; overload;
    function Clone : TFhirStructureDefinitionContext; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Defines how to interpret the expression that defines what the context of the extension is.
    property type_ : TFhirExtensionContextTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to An expression that defines where an extension can be used in resources.
    property expression : String read GetExpressionST write SetExpressionST;
    // An expression that defines where an extension can be used in resources.
    property expressionElement : TFhirString read FExpression write SetExpression;

  end;

  TFhirStructureDefinitionContextListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirStructureDefinitionContextList;
    function GetCurrent : TFhirStructureDefinitionContext;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirStructureDefinitionContextList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirStructureDefinitionContext read GetCurrent;
  end;

  TFhirStructureDefinitionContextList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirStructureDefinitionContext;
    procedure SetItemN(index : Integer; value : TFhirStructureDefinitionContext);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirStructureDefinitionContextList; overload;
    function Clone : TFhirStructureDefinitionContextList; overload;
    function GetEnumerator : TFhirStructureDefinitionContextListEnumerator;
    
    //  Add a FhirStructureDefinitionContext to the end of the list.
    function Append : TFhirStructureDefinitionContext;
    
    // Add an already existing FhirStructureDefinitionContext to the end of the list.
    function AddItem(value : TFhirStructureDefinitionContext) : TFhirStructureDefinitionContext; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirStructureDefinitionContext) : Integer;
    
    // Insert FhirStructureDefinitionContext before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirStructureDefinitionContext;
    
    // Insert an existing FhirStructureDefinitionContext before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirStructureDefinitionContext);
    
    // Get the iIndexth FhirStructureDefinitionContext. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirStructureDefinitionContext);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirStructureDefinitionContext;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirStructureDefinitionContexts[index : Integer] : TFhirStructureDefinitionContext read GetItemN write SetItemN; default;
  End;

  // A snapshot view is expressed in a standalone form that can be used and interpreted without considering the base StructureDefinition.
  TFhirStructureDefinitionSnapshot = class (TFhirBackboneElement)
  protected
    FelementList : TFhirElementDefinitionList;
    function GetElementList : TFhirElementDefinitionList;
    function GetHasElementList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirStructureDefinitionSnapshot; overload;
    function Clone : TFhirStructureDefinitionSnapshot; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Captures constraints on each element within the resource.
    property elementList : TFhirElementDefinitionList read GetElementList;
    property hasElementList : boolean read GetHasElementList;

  end;

  TFhirStructureDefinitionSnapshotListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirStructureDefinitionSnapshotList;
    function GetCurrent : TFhirStructureDefinitionSnapshot;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirStructureDefinitionSnapshotList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirStructureDefinitionSnapshot read GetCurrent;
  end;

  TFhirStructureDefinitionSnapshotList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirStructureDefinitionSnapshot;
    procedure SetItemN(index : Integer; value : TFhirStructureDefinitionSnapshot);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirStructureDefinitionSnapshotList; overload;
    function Clone : TFhirStructureDefinitionSnapshotList; overload;
    function GetEnumerator : TFhirStructureDefinitionSnapshotListEnumerator;
    
    //  Add a FhirStructureDefinitionSnapshot to the end of the list.
    function Append : TFhirStructureDefinitionSnapshot;
    
    // Add an already existing FhirStructureDefinitionSnapshot to the end of the list.
    function AddItem(value : TFhirStructureDefinitionSnapshot) : TFhirStructureDefinitionSnapshot; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirStructureDefinitionSnapshot) : Integer;
    
    // Insert FhirStructureDefinitionSnapshot before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirStructureDefinitionSnapshot;
    
    // Insert an existing FhirStructureDefinitionSnapshot before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirStructureDefinitionSnapshot);
    
    // Get the iIndexth FhirStructureDefinitionSnapshot. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirStructureDefinitionSnapshot);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirStructureDefinitionSnapshot;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirStructureDefinitionSnapshots[index : Integer] : TFhirStructureDefinitionSnapshot read GetItemN write SetItemN; default;
  End;

  // A differential view is expressed relative to the base StructureDefinition - a statement of differences that it applies.
  TFhirStructureDefinitionDifferential = class (TFhirBackboneElement)
  protected
    FelementList : TFhirElementDefinitionList;
    function GetElementList : TFhirElementDefinitionList;
    function GetHasElementList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirStructureDefinitionDifferential; overload;
    function Clone : TFhirStructureDefinitionDifferential; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Captures constraints on each element within the resource.
    property elementList : TFhirElementDefinitionList read GetElementList;
    property hasElementList : boolean read GetHasElementList;

  end;

  TFhirStructureDefinitionDifferentialListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirStructureDefinitionDifferentialList;
    function GetCurrent : TFhirStructureDefinitionDifferential;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirStructureDefinitionDifferentialList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirStructureDefinitionDifferential read GetCurrent;
  end;

  TFhirStructureDefinitionDifferentialList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirStructureDefinitionDifferential;
    procedure SetItemN(index : Integer; value : TFhirStructureDefinitionDifferential);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirStructureDefinitionDifferentialList; overload;
    function Clone : TFhirStructureDefinitionDifferentialList; overload;
    function GetEnumerator : TFhirStructureDefinitionDifferentialListEnumerator;
    
    //  Add a FhirStructureDefinitionDifferential to the end of the list.
    function Append : TFhirStructureDefinitionDifferential;
    
    // Add an already existing FhirStructureDefinitionDifferential to the end of the list.
    function AddItem(value : TFhirStructureDefinitionDifferential) : TFhirStructureDefinitionDifferential; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirStructureDefinitionDifferential) : Integer;
    
    // Insert FhirStructureDefinitionDifferential before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirStructureDefinitionDifferential;
    
    // Insert an existing FhirStructureDefinitionDifferential before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirStructureDefinitionDifferential);
    
    // Get the iIndexth FhirStructureDefinitionDifferential. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirStructureDefinitionDifferential);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirStructureDefinitionDifferential;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirStructureDefinitionDifferentials[index : Integer] : TFhirStructureDefinitionDifferential read GetItemN write SetItemN; default;
  End;

  // A definition of a FHIR structure. This resource is used to describe the underlying resources, data types defined in FHIR, and also for describing extensions and constraints on resources and data types.
  TFhirStructureDefinition = class (TFhirDomainResource)
  protected
    FUrl : TFhirUri;
    FidentifierList : TFhirIdentifierList;
    FVersion : TFhirString;
    FName : TFhirString;
    FTitle : TFhirString;
    FStatus : TFhirEnum;
    FExperimental : TFhirBoolean;
    FDate : TFhirDateTime;
    FPublisher : TFhirString;
    FcontactList : TFhirContactDetailList;
    FDescription : TFhirMarkdown;
    FuseContextList : TFhirUsageContextList;
    FjurisdictionList : TFhirCodeableConceptList;
    FPurpose : TFhirMarkdown;
    FCopyright : TFhirMarkdown;
    FkeywordList : TFhirCodingList;
    FFhirVersion : TFhirEnum;
    FmappingList : TFhirStructureDefinitionMappingList;
    FKind : TFhirEnum;
    FAbstract : TFhirBoolean;
    FcontextList : TFhirStructureDefinitionContextList;
    FcontextInvariantList : TFhirStringList;
    FType_ : TFhirUri;
    FBaseDefinition : TFhirCanonical;
    FDerivation : TFhirEnum;
    FSnapshot : TFhirStructureDefinitionSnapshot;
    FDifferential : TFhirStructureDefinitionDifferential;
    procedure SetUrl(value : TFhirUri);
    function GetUrlST : String;
    procedure SetUrlST(value : String);
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetVersion(value : TFhirString);
    function GetVersionST : String;
    procedure SetVersionST(value : String);
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetTitle(value : TFhirString);
    function GetTitleST : String;
    procedure SetTitleST(value : String);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirPublicationStatusEnum;
    procedure SetStatusST(value : TFhirPublicationStatusEnum);
    procedure SetExperimental(value : TFhirBoolean);
    function GetExperimentalST : Boolean;
    procedure SetExperimentalST(value : Boolean);
    procedure SetDate(value : TFhirDateTime);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    procedure SetPublisher(value : TFhirString);
    function GetPublisherST : String;
    procedure SetPublisherST(value : String);
    function GetContactList : TFhirContactDetailList;
    function GetHasContactList : Boolean;
    procedure SetDescription(value : TFhirMarkdown);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetUseContextList : TFhirUsageContextList;
    function GetHasUseContextList : Boolean;
    function GetJurisdictionList : TFhirCodeableConceptList;
    function GetHasJurisdictionList : Boolean;
    procedure SetPurpose(value : TFhirMarkdown);
    function GetPurposeST : String;
    procedure SetPurposeST(value : String);
    procedure SetCopyright(value : TFhirMarkdown);
    function GetCopyrightST : String;
    procedure SetCopyrightST(value : String);
    function GetKeywordList : TFhirCodingList;
    function GetHasKeywordList : Boolean;
    procedure SetFhirVersion(value : TFhirEnum);
    function GetFhirVersionST : TFhirFHIRVersionEnum;
    procedure SetFhirVersionST(value : TFhirFHIRVersionEnum);
    function GetMappingList : TFhirStructureDefinitionMappingList;
    function GetHasMappingList : Boolean;
    procedure SetKind(value : TFhirEnum);
    function GetKindST : TFhirStructureDefinitionKindEnum;
    procedure SetKindST(value : TFhirStructureDefinitionKindEnum);
    procedure SetAbstract(value : TFhirBoolean);
    function GetAbstractST : Boolean;
    procedure SetAbstractST(value : Boolean);
    function GetContextList : TFhirStructureDefinitionContextList;
    function GetHasContextList : Boolean;
    function GetContextInvariantList : TFhirStringList;
    function GetHasContextInvariantList : Boolean;
    procedure SetType_(value : TFhirUri);
    function GetType_ST : String;
    procedure SetType_ST(value : String);
    procedure SetBaseDefinition(value : TFhirCanonical);
    function GetBaseDefinitionST : String;
    procedure SetBaseDefinitionST(value : String);
    procedure SetDerivation(value : TFhirEnum);
    function GetDerivationST : TFhirTypeDerivationRuleEnum;
    procedure SetDerivationST(value : TFhirTypeDerivationRuleEnum);
    procedure SetSnapshot(value : TFhirStructureDefinitionSnapshot);
    procedure SetDifferential(value : TFhirStructureDefinitionDifferential);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirStructureDefinition; overload;
    function Clone : TFhirStructureDefinition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An absolute URI that is used to identify this structure definition when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this structure definition is (or will be) published. This URL can be the target of a canonical reference. It SHALL remain the same when the structure definition is stored on different servers.
    property url : String read GetUrlST write SetUrlST;
    // An absolute URI that is used to identify this structure definition when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this structure definition is (or will be) published. This URL can be the target of a canonical reference. It SHALL remain the same when the structure definition is stored on different servers.
    property urlElement : TFhirUri read FUrl write SetUrl;

    // A formal identifier that is used to identify this structure definition when it is represented in other formats, or referenced in a specification, model, design or an instance.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The identifier that is used to identify this version of the structure definition when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the structure definition author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
    property version : String read GetVersionST write SetVersionST;
    // The identifier that is used to identify this version of the structure definition when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the structure definition author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to A natural language name identifying the structure definition. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property name : String read GetNameST write SetNameST;
    // A natural language name identifying the structure definition. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A short, descriptive, user-friendly title for the structure definition.
    property title : String read GetTitleST write SetTitleST;
    // A short, descriptive, user-friendly title for the structure definition.
    property titleElement : TFhirString read FTitle write SetTitle;

    // The status of this structure definition. Enables tracking the life-cycle of the content.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A Boolean value to indicate that this structure definition is authored for testing purposes (or education/evaluation/marketing) and is not intended to be used for genuine usage.
    property experimental : Boolean read GetExperimentalST write SetExperimentalST;
    // A Boolean value to indicate that this structure definition is authored for testing purposes (or education/evaluation/marketing) and is not intended to be used for genuine usage.
    property experimentalElement : TFhirBoolean read FExperimental write SetExperimental;

    // Typed access to The date  (and optionally time) when the structure definition was published. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the structure definition changes.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date  (and optionally time) when the structure definition was published. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the structure definition changes.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The name of the organization or individual that published the structure definition.
    property publisher : String read GetPublisherST write SetPublisherST;
    // The name of the organization or individual that published the structure definition.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Contact details to assist a user in finding and communicating with the publisher.
    property contactList : TFhirContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to A free text natural language description of the structure definition from a consumer's perspective.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A free text natural language description of the structure definition from a consumer's perspective.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // The content was developed with a focus and intent of supporting the contexts that are listed. These contexts may be general categories (gender, age, ...) or may be references to specific programs (insurance plans, studies, ...) and may be used to assist with indexing and searching for appropriate structure definition instances.
    property useContextList : TFhirUsageContextList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // A legal or geographic region in which the structure definition is intended to be used.
    property jurisdictionList : TFhirCodeableConceptList read GetJurisdictionList;
    property hasJurisdictionList : boolean read GetHasJurisdictionList;

    // Typed access to Explanation of why this structure definition is needed and why it has been designed as it has.
    property purpose : String read GetPurposeST write SetPurposeST;
    // Explanation of why this structure definition is needed and why it has been designed as it has.
    property purposeElement : TFhirMarkdown read FPurpose write SetPurpose;

    // Typed access to A copyright statement relating to the structure definition and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the structure definition.
    property copyright : String read GetCopyrightST write SetCopyrightST;
    // A copyright statement relating to the structure definition and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the structure definition.
    property copyrightElement : TFhirMarkdown read FCopyright write SetCopyright;

    // A set of key words or terms from external terminologies that may be used to assist with indexing and searching of templates nby describing the use of this structure definition, or the content it describes.
    property keywordList : TFhirCodingList read GetKeywordList;
    property hasKeywordList : boolean read GetHasKeywordList;

    // The version of the FHIR specification on which this StructureDefinition is based - this is the formal version of the specification, without the revision number, e.g. [publication].[major].[minor], which is 4.3.0-snapshot1 for this version.
    property fhirVersion : TFhirFHIRVersionEnum read GetFhirVersionST write SetFhirVersionST;
    property fhirVersionElement : TFhirEnum read FFhirVersion write SetFhirVersion;

    // An external specification that the content is mapped to.
    property mappingList : TFhirStructureDefinitionMappingList read GetMappingList;
    property hasMappingList : boolean read GetHasMappingList;

    // Defines the kind of structure that this definition is describing.
    property kind : TFhirStructureDefinitionKindEnum read GetKindST write SetKindST;
    property kindElement : TFhirEnum read FKind write SetKind;

    // Typed access to Whether structure this definition describes is abstract or not  - that is, whether the structure is not intended to be instantiated. For Resources and Data types, abstract types will never be exchanged  between systems.
    property abstract : Boolean read GetAbstractST write SetAbstractST;
    // Whether structure this definition describes is abstract or not  - that is, whether the structure is not intended to be instantiated. For Resources and Data types, abstract types will never be exchanged  between systems.
    property abstractElement : TFhirBoolean read FAbstract write SetAbstract;

    // Identifies the types of resource or data type elements to which the extension can be applied.
    property contextList : TFhirStructureDefinitionContextList read GetContextList;
    property hasContextList : boolean read GetHasContextList;

    // A set of rules as FHIRPath Invariants about when the extension can be used (e.g. co-occurrence variants for the extension). All the rules must be true.
    property contextInvariantList : TFhirStringList read GetContextInvariantList;
    property hasContextInvariantList : boolean read GetHasContextInvariantList;

    // Typed access to The type this structure describes. If the derivation kind is 'specialization' then this is the master definition for a type, and there is always one of these (a data type, an extension, a resource, including abstract ones). Otherwise the structure definition is a constraint on the stated type (and in this case, the type cannot be an abstract type).  References are URLs that are relative to http://hl7.org/fhir/StructureDefinition e.g. "string" is a reference to http://hl7.org/fhir/StructureDefinition/string. Absolute URLs are only allowed in logical models.
    property type_ : String read GetType_ST write SetType_ST;
    // The type this structure describes. If the derivation kind is 'specialization' then this is the master definition for a type, and there is always one of these (a data type, an extension, a resource, including abstract ones). Otherwise the structure definition is a constraint on the stated type (and in this case, the type cannot be an abstract type).  References are URLs that are relative to http://hl7.org/fhir/StructureDefinition e.g. "string" is a reference to http://hl7.org/fhir/StructureDefinition/string. Absolute URLs are only allowed in logical models.
    property type_Element : TFhirUri read FType_ write SetType_;

    // Typed access to An absolute URI that is the base structure from which this type is derived, either by specialization or constraint.
    property baseDefinition : String read GetBaseDefinitionST write SetBaseDefinitionST;
    // An absolute URI that is the base structure from which this type is derived, either by specialization or constraint.
    property baseDefinitionElement : TFhirCanonical read FBaseDefinition write SetBaseDefinition;

    // How the type relates to the baseDefinition.
    property derivation : TFhirTypeDerivationRuleEnum read GetDerivationST write SetDerivationST;
    property derivationElement : TFhirEnum read FDerivation write SetDerivation;

    // Typed access to A snapshot view is expressed in a standalone form that can be used and interpreted without considering the base StructureDefinition. (defined for API consistency)
    property snapshot : TFhirStructureDefinitionSnapshot read FSnapshot write SetSnapshot;
    // A snapshot view is expressed in a standalone form that can be used and interpreted without considering the base StructureDefinition.
    property snapshotElement : TFhirStructureDefinitionSnapshot read FSnapshot write SetSnapshot;

    // Typed access to A differential view is expressed relative to the base StructureDefinition - a statement of differences that it applies. (defined for API consistency)
    property differential : TFhirStructureDefinitionDifferential read FDifferential write SetDifferential;
    // A differential view is expressed relative to the base StructureDefinition - a statement of differences that it applies.
    property differentialElement : TFhirStructureDefinitionDifferential read FDifferential write SetDifferential;

  end;

  TFhirStructureDefinitionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirStructureDefinitionList;
    function GetCurrent : TFhirStructureDefinition;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirStructureDefinitionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirStructureDefinition read GetCurrent;
  end;

  TFhirStructureDefinitionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirStructureDefinition;
    procedure SetItemN(index : Integer; value : TFhirStructureDefinition);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirStructureDefinitionList; overload;
    function Clone : TFhirStructureDefinitionList; overload;
    function GetEnumerator : TFhirStructureDefinitionListEnumerator;
    
    //  Add a FhirStructureDefinition to the end of the list.
    function Append : TFhirStructureDefinition;
    
    // Add an already existing FhirStructureDefinition to the end of the list.
    function AddItem(value : TFhirStructureDefinition) : TFhirStructureDefinition; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirStructureDefinition) : Integer;
    
    // Insert FhirStructureDefinition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirStructureDefinition;
    
    // Insert an existing FhirStructureDefinition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirStructureDefinition);
    
    // Get the iIndexth FhirStructureDefinition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirStructureDefinition);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirStructureDefinition;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirStructureDefinitions[index : Integer] : TFhirStructureDefinition read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_STRUCTUREDEFINITION}
{$IFDEF FHIR_STRUCTUREMAP}
  // A structure definition used by this map. The structure definition may describe instances that are converted, or the instances that are produced.
  TFhirStructureMapStructure = class (TFhirBackboneElement)
  protected
    FUrl : TFhirCanonical;
    FMode : TFhirEnum;
    FAlias : TFhirString;
    FDocumentation : TFhirString;
    procedure SetUrl(value : TFhirCanonical);
    function GetUrlST : String;
    procedure SetUrlST(value : String);
    procedure SetMode(value : TFhirEnum);
    function GetModeST : TFhirStructureMapModelModeEnum;
    procedure SetModeST(value : TFhirStructureMapModelModeEnum);
    procedure SetAlias(value : TFhirString);
    function GetAliasST : String;
    procedure SetAliasST(value : String);
    procedure SetDocumentation(value : TFhirString);
    function GetDocumentationST : String;
    procedure SetDocumentationST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirStructureMapStructure; overload;
    function Clone : TFhirStructureMapStructure; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The canonical reference to the structure.
    property url : String read GetUrlST write SetUrlST;
    // The canonical reference to the structure.
    property urlElement : TFhirCanonical read FUrl write SetUrl;

    // How the referenced structure is used in this mapping.
    property mode : TFhirStructureMapModelModeEnum read GetModeST write SetModeST;
    property modeElement : TFhirEnum read FMode write SetMode;

    // Typed access to The name used for this type in the map.
    property alias : String read GetAliasST write SetAliasST;
    // The name used for this type in the map.
    property aliasElement : TFhirString read FAlias write SetAlias;

    // Typed access to Documentation that describes how the structure is used in the mapping.
    property documentation : String read GetDocumentationST write SetDocumentationST;
    // Documentation that describes how the structure is used in the mapping.
    property documentationElement : TFhirString read FDocumentation write SetDocumentation;

  end;

  TFhirStructureMapStructureListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirStructureMapStructureList;
    function GetCurrent : TFhirStructureMapStructure;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirStructureMapStructureList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirStructureMapStructure read GetCurrent;
  end;

  TFhirStructureMapStructureList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirStructureMapStructure;
    procedure SetItemN(index : Integer; value : TFhirStructureMapStructure);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirStructureMapStructureList; overload;
    function Clone : TFhirStructureMapStructureList; overload;
    function GetEnumerator : TFhirStructureMapStructureListEnumerator;
    
    //  Add a FhirStructureMapStructure to the end of the list.
    function Append : TFhirStructureMapStructure;
    
    // Add an already existing FhirStructureMapStructure to the end of the list.
    function AddItem(value : TFhirStructureMapStructure) : TFhirStructureMapStructure; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirStructureMapStructure) : Integer;
    
    // Insert FhirStructureMapStructure before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirStructureMapStructure;
    
    // Insert an existing FhirStructureMapStructure before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirStructureMapStructure);
    
    // Get the iIndexth FhirStructureMapStructure. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirStructureMapStructure);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirStructureMapStructure;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirStructureMapStructures[index : Integer] : TFhirStructureMapStructure read GetItemN write SetItemN; default;
  End;

  // Organizes the mapping into manageable chunks for human review/ease of maintenance.
  TFhirStructureMapGroup = class (TFhirBackboneElement)
  protected
    FName : TFhirId;
    FExtends : TFhirId;
    FTypeMode : TFhirEnum;
    FDocumentation : TFhirString;
    FinputList : TFhirStructureMapGroupInputList;
    FruleList : TFhirStructureMapGroupRuleList;
    procedure SetName(value : TFhirId);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetExtends(value : TFhirId);
    function GetExtendsST : String;
    procedure SetExtendsST(value : String);
    procedure SetTypeMode(value : TFhirEnum);
    function GetTypeModeST : TFhirStructureMapGroupTypeModeEnum;
    procedure SetTypeModeST(value : TFhirStructureMapGroupTypeModeEnum);
    procedure SetDocumentation(value : TFhirString);
    function GetDocumentationST : String;
    procedure SetDocumentationST(value : String);
    function GetInputList : TFhirStructureMapGroupInputList;
    function GetHasInputList : Boolean;
    function GetRuleList : TFhirStructureMapGroupRuleList;
    function GetHasRuleList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirStructureMapGroup; overload;
    function Clone : TFhirStructureMapGroup; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A unique name for the group for the convenience of human readers.
    property name : String read GetNameST write SetNameST;
    // A unique name for the group for the convenience of human readers.
    property nameElement : TFhirId read FName write SetName;

    // Typed access to Another group that this group adds rules to.
    property extends : String read GetExtendsST write SetExtendsST;
    // Another group that this group adds rules to.
    property extendsElement : TFhirId read FExtends write SetExtends;

    // If this is the default rule set to apply for the source type or this combination of types.
    property typeMode : TFhirStructureMapGroupTypeModeEnum read GetTypeModeST write SetTypeModeST;
    property typeModeElement : TFhirEnum read FTypeMode write SetTypeMode;

    // Typed access to Additional supporting documentation that explains the purpose of the group and the types of mappings within it.
    property documentation : String read GetDocumentationST write SetDocumentationST;
    // Additional supporting documentation that explains the purpose of the group and the types of mappings within it.
    property documentationElement : TFhirString read FDocumentation write SetDocumentation;

    // A name assigned to an instance of data. The instance must be provided when the mapping is invoked.
    property inputList : TFhirStructureMapGroupInputList read GetInputList;
    property hasInputList : boolean read GetHasInputList;

    // Transform Rule from source to target.
    property ruleList : TFhirStructureMapGroupRuleList read GetRuleList;
    property hasRuleList : boolean read GetHasRuleList;

  end;

  TFhirStructureMapGroupListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirStructureMapGroupList;
    function GetCurrent : TFhirStructureMapGroup;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirStructureMapGroupList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirStructureMapGroup read GetCurrent;
  end;

  TFhirStructureMapGroupList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirStructureMapGroup;
    procedure SetItemN(index : Integer; value : TFhirStructureMapGroup);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirStructureMapGroupList; overload;
    function Clone : TFhirStructureMapGroupList; overload;
    function GetEnumerator : TFhirStructureMapGroupListEnumerator;
    
    //  Add a FhirStructureMapGroup to the end of the list.
    function Append : TFhirStructureMapGroup;
    
    // Add an already existing FhirStructureMapGroup to the end of the list.
    function AddItem(value : TFhirStructureMapGroup) : TFhirStructureMapGroup; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirStructureMapGroup) : Integer;
    
    // Insert FhirStructureMapGroup before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirStructureMapGroup;
    
    // Insert an existing FhirStructureMapGroup before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirStructureMapGroup);
    
    // Get the iIndexth FhirStructureMapGroup. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirStructureMapGroup);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirStructureMapGroup;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirStructureMapGroups[index : Integer] : TFhirStructureMapGroup read GetItemN write SetItemN; default;
  End;

  // A name assigned to an instance of data. The instance must be provided when the mapping is invoked.
  TFhirStructureMapGroupInput = class (TFhirBackboneElement)
  protected
    FName : TFhirId;
    FType_ : TFhirString;
    FMode : TFhirEnum;
    FDocumentation : TFhirString;
    procedure SetName(value : TFhirId);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetType_(value : TFhirString);
    function GetType_ST : String;
    procedure SetType_ST(value : String);
    procedure SetMode(value : TFhirEnum);
    function GetModeST : TFhirStructureMapInputModeEnum;
    procedure SetModeST(value : TFhirStructureMapInputModeEnum);
    procedure SetDocumentation(value : TFhirString);
    function GetDocumentationST : String;
    procedure SetDocumentationST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirStructureMapGroupInput; overload;
    function Clone : TFhirStructureMapGroupInput; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Name for this instance of data.
    property name : String read GetNameST write SetNameST;
    // Name for this instance of data.
    property nameElement : TFhirId read FName write SetName;

    // Typed access to Type for this instance of data.
    property type_ : String read GetType_ST write SetType_ST;
    // Type for this instance of data.
    property type_Element : TFhirString read FType_ write SetType_;

    // Mode for this instance of data.
    property mode : TFhirStructureMapInputModeEnum read GetModeST write SetModeST;
    property modeElement : TFhirEnum read FMode write SetMode;

    // Typed access to Documentation for this instance of data.
    property documentation : String read GetDocumentationST write SetDocumentationST;
    // Documentation for this instance of data.
    property documentationElement : TFhirString read FDocumentation write SetDocumentation;

  end;

  TFhirStructureMapGroupInputListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirStructureMapGroupInputList;
    function GetCurrent : TFhirStructureMapGroupInput;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirStructureMapGroupInputList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirStructureMapGroupInput read GetCurrent;
  end;

  TFhirStructureMapGroupInputList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirStructureMapGroupInput;
    procedure SetItemN(index : Integer; value : TFhirStructureMapGroupInput);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirStructureMapGroupInputList; overload;
    function Clone : TFhirStructureMapGroupInputList; overload;
    function GetEnumerator : TFhirStructureMapGroupInputListEnumerator;
    
    //  Add a FhirStructureMapGroupInput to the end of the list.
    function Append : TFhirStructureMapGroupInput;
    
    // Add an already existing FhirStructureMapGroupInput to the end of the list.
    function AddItem(value : TFhirStructureMapGroupInput) : TFhirStructureMapGroupInput; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirStructureMapGroupInput) : Integer;
    
    // Insert FhirStructureMapGroupInput before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirStructureMapGroupInput;
    
    // Insert an existing FhirStructureMapGroupInput before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirStructureMapGroupInput);
    
    // Get the iIndexth FhirStructureMapGroupInput. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirStructureMapGroupInput);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirStructureMapGroupInput;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirStructureMapGroupInputs[index : Integer] : TFhirStructureMapGroupInput read GetItemN write SetItemN; default;
  End;

  // Transform Rule from source to target.
  TFhirStructureMapGroupRule = class (TFhirBackboneElement)
  protected
    FName : TFhirId;
    FsourceList : TFhirStructureMapGroupRuleSourceList;
    FtargetList : TFhirStructureMapGroupRuleTargetList;
    FruleList : TFhirStructureMapGroupRuleList;
    FdependentList : TFhirStructureMapGroupRuleDependentList;
    FDocumentation : TFhirString;
    procedure SetName(value : TFhirId);
    function GetNameST : String;
    procedure SetNameST(value : String);
    function GetSourceList : TFhirStructureMapGroupRuleSourceList;
    function GetHasSourceList : Boolean;
    function GetTargetList : TFhirStructureMapGroupRuleTargetList;
    function GetHasTargetList : Boolean;
    function GetRuleList : TFhirStructureMapGroupRuleList;
    function GetHasRuleList : Boolean;
    function GetDependentList : TFhirStructureMapGroupRuleDependentList;
    function GetHasDependentList : Boolean;
    procedure SetDocumentation(value : TFhirString);
    function GetDocumentationST : String;
    procedure SetDocumentationST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirStructureMapGroupRule; overload;
    function Clone : TFhirStructureMapGroupRule; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Name of the rule for internal references.
    property name : String read GetNameST write SetNameST;
    // Name of the rule for internal references.
    property nameElement : TFhirId read FName write SetName;

    // Source inputs to the mapping.
    property sourceList : TFhirStructureMapGroupRuleSourceList read GetSourceList;
    property hasSourceList : boolean read GetHasSourceList;

    // Content to create because of this mapping rule.
    property targetList : TFhirStructureMapGroupRuleTargetList read GetTargetList;
    property hasTargetList : boolean read GetHasTargetList;

    // Rules contained in this rule.
    property ruleList : TFhirStructureMapGroupRuleList read GetRuleList;
    property hasRuleList : boolean read GetHasRuleList;

    // Which other rules to apply in the context of this rule.
    property dependentList : TFhirStructureMapGroupRuleDependentList read GetDependentList;
    property hasDependentList : boolean read GetHasDependentList;

    // Typed access to Documentation for this instance of data.
    property documentation : String read GetDocumentationST write SetDocumentationST;
    // Documentation for this instance of data.
    property documentationElement : TFhirString read FDocumentation write SetDocumentation;

  end;

  TFhirStructureMapGroupRuleListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirStructureMapGroupRuleList;
    function GetCurrent : TFhirStructureMapGroupRule;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirStructureMapGroupRuleList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirStructureMapGroupRule read GetCurrent;
  end;

  TFhirStructureMapGroupRuleList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirStructureMapGroupRule;
    procedure SetItemN(index : Integer; value : TFhirStructureMapGroupRule);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirStructureMapGroupRuleList; overload;
    function Clone : TFhirStructureMapGroupRuleList; overload;
    function GetEnumerator : TFhirStructureMapGroupRuleListEnumerator;
    
    //  Add a FhirStructureMapGroupRule to the end of the list.
    function Append : TFhirStructureMapGroupRule;
    
    // Add an already existing FhirStructureMapGroupRule to the end of the list.
    function AddItem(value : TFhirStructureMapGroupRule) : TFhirStructureMapGroupRule; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirStructureMapGroupRule) : Integer;
    
    // Insert FhirStructureMapGroupRule before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirStructureMapGroupRule;
    
    // Insert an existing FhirStructureMapGroupRule before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirStructureMapGroupRule);
    
    // Get the iIndexth FhirStructureMapGroupRule. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirStructureMapGroupRule);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirStructureMapGroupRule;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirStructureMapGroupRules[index : Integer] : TFhirStructureMapGroupRule read GetItemN write SetItemN; default;
  End;

  // Source inputs to the mapping.
  TFhirStructureMapGroupRuleSource = class (TFhirBackboneElement)
  protected
    FContext : TFhirId;
    FMin : TFhirInteger;
    FMax : TFhirString;
    FType_ : TFhirString;
    FDefaultValue : TFhirDataType;
    FElement : TFhirString;
    FListMode : TFhirEnum;
    FVariable : TFhirId;
    FCondition : TFhirString;
    FCheck : TFhirString;
    FLogMessage : TFhirString;
    procedure SetContext(value : TFhirId);
    function GetContextST : String;
    procedure SetContextST(value : String);
    procedure SetMin(value : TFhirInteger);
    function GetMinST : String;
    procedure SetMinST(value : String);
    procedure SetMax(value : TFhirString);
    function GetMaxST : String;
    procedure SetMaxST(value : String);
    procedure SetType_(value : TFhirString);
    function GetType_ST : String;
    procedure SetType_ST(value : String);
    procedure SetDefaultValue(value : TFhirDataType);
    procedure SetElement(value : TFhirString);
    function GetElementST : String;
    procedure SetElementST(value : String);
    procedure SetListMode(value : TFhirEnum);
    function GetListModeST : TFhirStructureMapSourceListModeEnum;
    procedure SetListModeST(value : TFhirStructureMapSourceListModeEnum);
    procedure SetVariable(value : TFhirId);
    function GetVariableST : String;
    procedure SetVariableST(value : String);
    procedure SetCondition(value : TFhirString);
    function GetConditionST : String;
    procedure SetConditionST(value : String);
    procedure SetCheck(value : TFhirString);
    function GetCheckST : String;
    procedure SetCheckST(value : String);
    procedure SetLogMessage(value : TFhirString);
    function GetLogMessageST : String;
    procedure SetLogMessageST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirStructureMapGroupRuleSource; overload;
    function Clone : TFhirStructureMapGroupRuleSource; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Type or variable this rule applies to.
    property context : String read GetContextST write SetContextST;
    // Type or variable this rule applies to.
    property contextElement : TFhirId read FContext write SetContext;

    // Typed access to Specified minimum cardinality for the element. This is optional; if present, it acts an implicit check on the input content.
    property min : String read GetMinST write SetMinST;
    // Specified minimum cardinality for the element. This is optional; if present, it acts an implicit check on the input content.
    property minElement : TFhirInteger read FMin write SetMin;

    // Typed access to Specified maximum cardinality for the element - a number or a "*". This is optional; if present, it acts an implicit check on the input content (* just serves as documentation; it's the default value).
    property max : String read GetMaxST write SetMaxST;
    // Specified maximum cardinality for the element - a number or a "*". This is optional; if present, it acts an implicit check on the input content (* just serves as documentation; it's the default value).
    property maxElement : TFhirString read FMax write SetMax;

    // Typed access to Specified type for the element. This works as a condition on the mapping - use for polymorphic elements.
    property type_ : String read GetType_ST write SetType_ST;
    // Specified type for the element. This works as a condition on the mapping - use for polymorphic elements.
    property type_Element : TFhirString read FType_ write SetType_;

    // Typed access to A value to use if there is no existing value in the source object. (defined for API consistency)
    property defaultValue : TFhirDataType read FDefaultValue write SetDefaultValue;
    // A value to use if there is no existing value in the source object.
    property defaultValueElement : TFhirDataType read FDefaultValue write SetDefaultValue;

    // Typed access to Optional field for this source.
    property element : String read GetElementST write SetElementST;
    // Optional field for this source.
    property elementElement : TFhirString read FElement write SetElement;

    // How to handle the list mode for this element.
    property listMode : TFhirStructureMapSourceListModeEnum read GetListModeST write SetListModeST;
    property listModeElement : TFhirEnum read FListMode write SetListMode;

    // Typed access to Named context for field, if a field is specified.
    property variable : String read GetVariableST write SetVariableST;
    // Named context for field, if a field is specified.
    property variableElement : TFhirId read FVariable write SetVariable;

    // Typed access to FHIRPath expression  - must be true or the rule does not apply.
    property condition : String read GetConditionST write SetConditionST;
    // FHIRPath expression  - must be true or the rule does not apply.
    property conditionElement : TFhirString read FCondition write SetCondition;

    // Typed access to FHIRPath expression  - must be true or the mapping engine throws an error instead of completing.
    property check : String read GetCheckST write SetCheckST;
    // FHIRPath expression  - must be true or the mapping engine throws an error instead of completing.
    property checkElement : TFhirString read FCheck write SetCheck;

    // Typed access to A FHIRPath expression which specifies a message to put in the transform log when content matching the source rule is found.
    property logMessage : String read GetLogMessageST write SetLogMessageST;
    // A FHIRPath expression which specifies a message to put in the transform log when content matching the source rule is found.
    property logMessageElement : TFhirString read FLogMessage write SetLogMessage;

  end;

  TFhirStructureMapGroupRuleSourceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirStructureMapGroupRuleSourceList;
    function GetCurrent : TFhirStructureMapGroupRuleSource;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirStructureMapGroupRuleSourceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirStructureMapGroupRuleSource read GetCurrent;
  end;

  TFhirStructureMapGroupRuleSourceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirStructureMapGroupRuleSource;
    procedure SetItemN(index : Integer; value : TFhirStructureMapGroupRuleSource);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirStructureMapGroupRuleSourceList; overload;
    function Clone : TFhirStructureMapGroupRuleSourceList; overload;
    function GetEnumerator : TFhirStructureMapGroupRuleSourceListEnumerator;
    
    //  Add a FhirStructureMapGroupRuleSource to the end of the list.
    function Append : TFhirStructureMapGroupRuleSource;
    
    // Add an already existing FhirStructureMapGroupRuleSource to the end of the list.
    function AddItem(value : TFhirStructureMapGroupRuleSource) : TFhirStructureMapGroupRuleSource; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirStructureMapGroupRuleSource) : Integer;
    
    // Insert FhirStructureMapGroupRuleSource before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirStructureMapGroupRuleSource;
    
    // Insert an existing FhirStructureMapGroupRuleSource before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirStructureMapGroupRuleSource);
    
    // Get the iIndexth FhirStructureMapGroupRuleSource. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirStructureMapGroupRuleSource);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirStructureMapGroupRuleSource;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirStructureMapGroupRuleSources[index : Integer] : TFhirStructureMapGroupRuleSource read GetItemN write SetItemN; default;
  End;

  // Content to create because of this mapping rule.
  TFhirStructureMapGroupRuleTarget = class (TFhirBackboneElement)
  protected
    FContext : TFhirId;
    FContextType : TFhirEnum;
    FElement : TFhirString;
    FVariable : TFhirId;
    FListMode : TFhirEnumList;
    FListRuleId : TFhirId;
    FTransform : TFhirEnum;
    FparameterList : TFhirStructureMapGroupRuleTargetParameterList;
    procedure SetContext(value : TFhirId);
    function GetContextST : String;
    procedure SetContextST(value : String);
    procedure SetContextType(value : TFhirEnum);
    function GetContextTypeST : TFhirStructureMapContextTypeEnum;
    procedure SetContextTypeST(value : TFhirStructureMapContextTypeEnum);
    procedure SetElement(value : TFhirString);
    function GetElementST : String;
    procedure SetElementST(value : String);
    procedure SetVariable(value : TFhirId);
    function GetVariableST : String;
    procedure SetVariableST(value : String);
    function GetListMode : TFhirEnumList;
    function GetHasListMode : Boolean;
    function GetListModeST : TFhirStructureMapTargetListModeEnumList;
    procedure SetListModeST(value : TFhirStructureMapTargetListModeEnumList);
    procedure SetListRuleId(value : TFhirId);
    function GetListRuleIdST : String;
    procedure SetListRuleIdST(value : String);
    procedure SetTransform(value : TFhirEnum);
    function GetTransformST : TFhirStructureMapTransformEnum;
    procedure SetTransformST(value : TFhirStructureMapTransformEnum);
    function GetParameterList : TFhirStructureMapGroupRuleTargetParameterList;
    function GetHasParameterList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirStructureMapGroupRuleTarget; overload;
    function Clone : TFhirStructureMapGroupRuleTarget; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Type or variable this rule applies to.
    property context : String read GetContextST write SetContextST;
    // Type or variable this rule applies to.
    property contextElement : TFhirId read FContext write SetContext;

    // How to interpret the context.
    property contextType : TFhirStructureMapContextTypeEnum read GetContextTypeST write SetContextTypeST;
    property contextTypeElement : TFhirEnum read FContextType write SetContextType;

    // Typed access to Field to create in the context.
    property element : String read GetElementST write SetElementST;
    // Field to create in the context.
    property elementElement : TFhirString read FElement write SetElement;

    // Typed access to Named context for field, if desired, and a field is specified.
    property variable : String read GetVariableST write SetVariableST;
    // Named context for field, if desired, and a field is specified.
    property variableElement : TFhirId read FVariable write SetVariable;

    // If field is a list, how to manage the list.
    property listMode : TFhirStructureMapTargetListModeEnumList read GetListModeST write SetListModeST;
    property listModeList : TFhirEnumList read GetListMode;
    property hasListMode : boolean read GetHasListMode;
    // Typed access to Internal rule reference for shared list items.
    property listRuleId : String read GetListRuleIdST write SetListRuleIdST;
    // Internal rule reference for shared list items.
    property listRuleIdElement : TFhirId read FListRuleId write SetListRuleId;

    // How the data is copied / created.
    property transform : TFhirStructureMapTransformEnum read GetTransformST write SetTransformST;
    property transformElement : TFhirEnum read FTransform write SetTransform;

    // Parameters to the transform.
    property parameterList : TFhirStructureMapGroupRuleTargetParameterList read GetParameterList;
    property hasParameterList : boolean read GetHasParameterList;

  end;

  TFhirStructureMapGroupRuleTargetListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirStructureMapGroupRuleTargetList;
    function GetCurrent : TFhirStructureMapGroupRuleTarget;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirStructureMapGroupRuleTargetList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirStructureMapGroupRuleTarget read GetCurrent;
  end;

  TFhirStructureMapGroupRuleTargetList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirStructureMapGroupRuleTarget;
    procedure SetItemN(index : Integer; value : TFhirStructureMapGroupRuleTarget);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirStructureMapGroupRuleTargetList; overload;
    function Clone : TFhirStructureMapGroupRuleTargetList; overload;
    function GetEnumerator : TFhirStructureMapGroupRuleTargetListEnumerator;
    
    //  Add a FhirStructureMapGroupRuleTarget to the end of the list.
    function Append : TFhirStructureMapGroupRuleTarget;
    
    // Add an already existing FhirStructureMapGroupRuleTarget to the end of the list.
    function AddItem(value : TFhirStructureMapGroupRuleTarget) : TFhirStructureMapGroupRuleTarget; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirStructureMapGroupRuleTarget) : Integer;
    
    // Insert FhirStructureMapGroupRuleTarget before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirStructureMapGroupRuleTarget;
    
    // Insert an existing FhirStructureMapGroupRuleTarget before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirStructureMapGroupRuleTarget);
    
    // Get the iIndexth FhirStructureMapGroupRuleTarget. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirStructureMapGroupRuleTarget);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirStructureMapGroupRuleTarget;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirStructureMapGroupRuleTargets[index : Integer] : TFhirStructureMapGroupRuleTarget read GetItemN write SetItemN; default;
  End;

  // Parameters to the transform.
  TFhirStructureMapGroupRuleTargetParameter = class (TFhirBackboneElement)
  protected
    FValue : TFhirDataType;
    procedure SetValue(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirStructureMapGroupRuleTargetParameter; overload;
    function Clone : TFhirStructureMapGroupRuleTargetParameter; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Parameter value - variable or literal. (defined for API consistency)
    property value : TFhirDataType read FValue write SetValue;
    // Parameter value - variable or literal.
    property valueElement : TFhirDataType read FValue write SetValue;

  end;

  TFhirStructureMapGroupRuleTargetParameterListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirStructureMapGroupRuleTargetParameterList;
    function GetCurrent : TFhirStructureMapGroupRuleTargetParameter;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirStructureMapGroupRuleTargetParameterList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirStructureMapGroupRuleTargetParameter read GetCurrent;
  end;

  TFhirStructureMapGroupRuleTargetParameterList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirStructureMapGroupRuleTargetParameter;
    procedure SetItemN(index : Integer; value : TFhirStructureMapGroupRuleTargetParameter);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirStructureMapGroupRuleTargetParameterList; overload;
    function Clone : TFhirStructureMapGroupRuleTargetParameterList; overload;
    function GetEnumerator : TFhirStructureMapGroupRuleTargetParameterListEnumerator;
    
    //  Add a FhirStructureMapGroupRuleTargetParameter to the end of the list.
    function Append : TFhirStructureMapGroupRuleTargetParameter;
    
    // Add an already existing FhirStructureMapGroupRuleTargetParameter to the end of the list.
    function AddItem(value : TFhirStructureMapGroupRuleTargetParameter) : TFhirStructureMapGroupRuleTargetParameter; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirStructureMapGroupRuleTargetParameter) : Integer;
    
    // Insert FhirStructureMapGroupRuleTargetParameter before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirStructureMapGroupRuleTargetParameter;
    
    // Insert an existing FhirStructureMapGroupRuleTargetParameter before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirStructureMapGroupRuleTargetParameter);
    
    // Get the iIndexth FhirStructureMapGroupRuleTargetParameter. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirStructureMapGroupRuleTargetParameter);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirStructureMapGroupRuleTargetParameter;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirStructureMapGroupRuleTargetParameters[index : Integer] : TFhirStructureMapGroupRuleTargetParameter read GetItemN write SetItemN; default;
  End;

  // Which other rules to apply in the context of this rule.
  TFhirStructureMapGroupRuleDependent = class (TFhirBackboneElement)
  protected
    FName : TFhirId;
    FvariableList : TFhirStringList;
    procedure SetName(value : TFhirId);
    function GetNameST : String;
    procedure SetNameST(value : String);
    function GetVariableList : TFhirStringList;
    function GetHasVariableList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirStructureMapGroupRuleDependent; overload;
    function Clone : TFhirStructureMapGroupRuleDependent; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Name of a rule or group to apply.
    property name : String read GetNameST write SetNameST;
    // Name of a rule or group to apply.
    property nameElement : TFhirId read FName write SetName;

    // Variable to pass to the rule or group.
    property variableList : TFhirStringList read GetVariableList;
    property hasVariableList : boolean read GetHasVariableList;

  end;

  TFhirStructureMapGroupRuleDependentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirStructureMapGroupRuleDependentList;
    function GetCurrent : TFhirStructureMapGroupRuleDependent;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirStructureMapGroupRuleDependentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirStructureMapGroupRuleDependent read GetCurrent;
  end;

  TFhirStructureMapGroupRuleDependentList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirStructureMapGroupRuleDependent;
    procedure SetItemN(index : Integer; value : TFhirStructureMapGroupRuleDependent);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirStructureMapGroupRuleDependentList; overload;
    function Clone : TFhirStructureMapGroupRuleDependentList; overload;
    function GetEnumerator : TFhirStructureMapGroupRuleDependentListEnumerator;
    
    //  Add a FhirStructureMapGroupRuleDependent to the end of the list.
    function Append : TFhirStructureMapGroupRuleDependent;
    
    // Add an already existing FhirStructureMapGroupRuleDependent to the end of the list.
    function AddItem(value : TFhirStructureMapGroupRuleDependent) : TFhirStructureMapGroupRuleDependent; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirStructureMapGroupRuleDependent) : Integer;
    
    // Insert FhirStructureMapGroupRuleDependent before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirStructureMapGroupRuleDependent;
    
    // Insert an existing FhirStructureMapGroupRuleDependent before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirStructureMapGroupRuleDependent);
    
    // Get the iIndexth FhirStructureMapGroupRuleDependent. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirStructureMapGroupRuleDependent);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirStructureMapGroupRuleDependent;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirStructureMapGroupRuleDependents[index : Integer] : TFhirStructureMapGroupRuleDependent read GetItemN write SetItemN; default;
  End;

  // A Map of relationships between 2 structures that can be used to transform data.
  TFhirStructureMap = class (TFhirDomainResource)
  protected
    FUrl : TFhirUri;
    FidentifierList : TFhirIdentifierList;
    FVersion : TFhirString;
    FName : TFhirString;
    FTitle : TFhirString;
    FStatus : TFhirEnum;
    FExperimental : TFhirBoolean;
    FDate : TFhirDateTime;
    FPublisher : TFhirString;
    FcontactList : TFhirContactDetailList;
    FDescription : TFhirMarkdown;
    FuseContextList : TFhirUsageContextList;
    FjurisdictionList : TFhirCodeableConceptList;
    FPurpose : TFhirMarkdown;
    FCopyright : TFhirMarkdown;
    FstructureList : TFhirStructureMapStructureList;
    FimportList : TFhirCanonicalList;
    FgroupList : TFhirStructureMapGroupList;
    procedure SetUrl(value : TFhirUri);
    function GetUrlST : String;
    procedure SetUrlST(value : String);
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetVersion(value : TFhirString);
    function GetVersionST : String;
    procedure SetVersionST(value : String);
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetTitle(value : TFhirString);
    function GetTitleST : String;
    procedure SetTitleST(value : String);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirPublicationStatusEnum;
    procedure SetStatusST(value : TFhirPublicationStatusEnum);
    procedure SetExperimental(value : TFhirBoolean);
    function GetExperimentalST : Boolean;
    procedure SetExperimentalST(value : Boolean);
    procedure SetDate(value : TFhirDateTime);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    procedure SetPublisher(value : TFhirString);
    function GetPublisherST : String;
    procedure SetPublisherST(value : String);
    function GetContactList : TFhirContactDetailList;
    function GetHasContactList : Boolean;
    procedure SetDescription(value : TFhirMarkdown);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetUseContextList : TFhirUsageContextList;
    function GetHasUseContextList : Boolean;
    function GetJurisdictionList : TFhirCodeableConceptList;
    function GetHasJurisdictionList : Boolean;
    procedure SetPurpose(value : TFhirMarkdown);
    function GetPurposeST : String;
    procedure SetPurposeST(value : String);
    procedure SetCopyright(value : TFhirMarkdown);
    function GetCopyrightST : String;
    procedure SetCopyrightST(value : String);
    function GetStructureList : TFhirStructureMapStructureList;
    function GetHasStructureList : Boolean;
    function GetImportList : TFhirCanonicalList;
    function GetHasImportList : Boolean;
    function GetGroupList : TFhirStructureMapGroupList;
    function GetHasGroupList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirStructureMap; overload;
    function Clone : TFhirStructureMap; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An absolute URI that is used to identify this structure map when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this structure map is (or will be) published. This URL can be the target of a canonical reference. It SHALL remain the same when the structure map is stored on different servers.
    property url : String read GetUrlST write SetUrlST;
    // An absolute URI that is used to identify this structure map when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this structure map is (or will be) published. This URL can be the target of a canonical reference. It SHALL remain the same when the structure map is stored on different servers.
    property urlElement : TFhirUri read FUrl write SetUrl;

    // A formal identifier that is used to identify this structure map when it is represented in other formats, or referenced in a specification, model, design or an instance.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The identifier that is used to identify this version of the structure map when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the structure map author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
    property version : String read GetVersionST write SetVersionST;
    // The identifier that is used to identify this version of the structure map when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the structure map author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to A natural language name identifying the structure map. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property name : String read GetNameST write SetNameST;
    // A natural language name identifying the structure map. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A short, descriptive, user-friendly title for the structure map.
    property title : String read GetTitleST write SetTitleST;
    // A short, descriptive, user-friendly title for the structure map.
    property titleElement : TFhirString read FTitle write SetTitle;

    // The status of this structure map. Enables tracking the life-cycle of the content.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A Boolean value to indicate that this structure map is authored for testing purposes (or education/evaluation/marketing) and is not intended to be used for genuine usage.
    property experimental : Boolean read GetExperimentalST write SetExperimentalST;
    // A Boolean value to indicate that this structure map is authored for testing purposes (or education/evaluation/marketing) and is not intended to be used for genuine usage.
    property experimentalElement : TFhirBoolean read FExperimental write SetExperimental;

    // Typed access to The date  (and optionally time) when the structure map was published. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the structure map changes.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date  (and optionally time) when the structure map was published. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the structure map changes.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The name of the organization or individual that published the structure map.
    property publisher : String read GetPublisherST write SetPublisherST;
    // The name of the organization or individual that published the structure map.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Contact details to assist a user in finding and communicating with the publisher.
    property contactList : TFhirContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to A free text natural language description of the structure map from a consumer's perspective.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A free text natural language description of the structure map from a consumer's perspective.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // The content was developed with a focus and intent of supporting the contexts that are listed. These contexts may be general categories (gender, age, ...) or may be references to specific programs (insurance plans, studies, ...) and may be used to assist with indexing and searching for appropriate structure map instances.
    property useContextList : TFhirUsageContextList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // A legal or geographic region in which the structure map is intended to be used.
    property jurisdictionList : TFhirCodeableConceptList read GetJurisdictionList;
    property hasJurisdictionList : boolean read GetHasJurisdictionList;

    // Typed access to Explanation of why this structure map is needed and why it has been designed as it has.
    property purpose : String read GetPurposeST write SetPurposeST;
    // Explanation of why this structure map is needed and why it has been designed as it has.
    property purposeElement : TFhirMarkdown read FPurpose write SetPurpose;

    // Typed access to A copyright statement relating to the structure map and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the structure map.
    property copyright : String read GetCopyrightST write SetCopyrightST;
    // A copyright statement relating to the structure map and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the structure map.
    property copyrightElement : TFhirMarkdown read FCopyright write SetCopyright;

    // A structure definition used by this map. The structure definition may describe instances that are converted, or the instances that are produced.
    property structureList : TFhirStructureMapStructureList read GetStructureList;
    property hasStructureList : boolean read GetHasStructureList;

    // Other maps used by this map (canonical URLs).
    property importList : TFhirCanonicalList read GetImportList;
    property hasImportList : boolean read GetHasImportList;

    // Organizes the mapping into manageable chunks for human review/ease of maintenance.
    property groupList : TFhirStructureMapGroupList read GetGroupList;
    property hasGroupList : boolean read GetHasGroupList;

  end;

  TFhirStructureMapListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirStructureMapList;
    function GetCurrent : TFhirStructureMap;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirStructureMapList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirStructureMap read GetCurrent;
  end;

  TFhirStructureMapList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirStructureMap;
    procedure SetItemN(index : Integer; value : TFhirStructureMap);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirStructureMapList; overload;
    function Clone : TFhirStructureMapList; overload;
    function GetEnumerator : TFhirStructureMapListEnumerator;
    
    //  Add a FhirStructureMap to the end of the list.
    function Append : TFhirStructureMap;
    
    // Add an already existing FhirStructureMap to the end of the list.
    function AddItem(value : TFhirStructureMap) : TFhirStructureMap; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirStructureMap) : Integer;
    
    // Insert FhirStructureMap before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirStructureMap;
    
    // Insert an existing FhirStructureMap before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirStructureMap);
    
    // Get the iIndexth FhirStructureMap. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirStructureMap);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirStructureMap;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirStructureMaps[index : Integer] : TFhirStructureMap read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_STRUCTUREMAP}
{$IFDEF FHIR_TERMINOLOGYCAPABILITIES}
  // Software that is covered by this terminology capability statement.  It is used when the statement describes the capabilities of a particular software version, independent of an installation.
  TFhirTerminologyCapabilitiesSoftware = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FVersion : TFhirString;
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetVersion(value : TFhirString);
    function GetVersionST : String;
    procedure SetVersionST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTerminologyCapabilitiesSoftware; overload;
    function Clone : TFhirTerminologyCapabilitiesSoftware; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Name the software is known by.
    property name : String read GetNameST write SetNameST;
    // Name the software is known by.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to The version identifier for the software covered by this statement.
    property version : String read GetVersionST write SetVersionST;
    // The version identifier for the software covered by this statement.
    property versionElement : TFhirString read FVersion write SetVersion;

  end;

  TFhirTerminologyCapabilitiesSoftwareListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTerminologyCapabilitiesSoftwareList;
    function GetCurrent : TFhirTerminologyCapabilitiesSoftware;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirTerminologyCapabilitiesSoftwareList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTerminologyCapabilitiesSoftware read GetCurrent;
  end;

  TFhirTerminologyCapabilitiesSoftwareList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirTerminologyCapabilitiesSoftware;
    procedure SetItemN(index : Integer; value : TFhirTerminologyCapabilitiesSoftware);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirTerminologyCapabilitiesSoftwareList; overload;
    function Clone : TFhirTerminologyCapabilitiesSoftwareList; overload;
    function GetEnumerator : TFhirTerminologyCapabilitiesSoftwareListEnumerator;
    
    //  Add a FhirTerminologyCapabilitiesSoftware to the end of the list.
    function Append : TFhirTerminologyCapabilitiesSoftware;
    
    // Add an already existing FhirTerminologyCapabilitiesSoftware to the end of the list.
    function AddItem(value : TFhirTerminologyCapabilitiesSoftware) : TFhirTerminologyCapabilitiesSoftware; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTerminologyCapabilitiesSoftware) : Integer;
    
    // Insert FhirTerminologyCapabilitiesSoftware before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTerminologyCapabilitiesSoftware;
    
    // Insert an existing FhirTerminologyCapabilitiesSoftware before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTerminologyCapabilitiesSoftware);
    
    // Get the iIndexth FhirTerminologyCapabilitiesSoftware. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTerminologyCapabilitiesSoftware);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTerminologyCapabilitiesSoftware;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirTerminologyCapabilitiesSoftwares[index : Integer] : TFhirTerminologyCapabilitiesSoftware read GetItemN write SetItemN; default;
  End;

  // Identifies a specific implementation instance that is described by the terminology capability statement - i.e. a particular installation, rather than the capabilities of a software program.
  TFhirTerminologyCapabilitiesImplementation = class (TFhirBackboneElement)
  protected
    FDescription : TFhirString;
    FUrl : TFhirUrl;
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetUrl(value : TFhirUrl);
    function GetUrlST : String;
    procedure SetUrlST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTerminologyCapabilitiesImplementation; overload;
    function Clone : TFhirTerminologyCapabilitiesImplementation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Information about the specific installation that this terminology capability statement relates to.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Information about the specific installation that this terminology capability statement relates to.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to An absolute base URL for the implementation.
    property url : String read GetUrlST write SetUrlST;
    // An absolute base URL for the implementation.
    property urlElement : TFhirUrl read FUrl write SetUrl;

  end;

  TFhirTerminologyCapabilitiesImplementationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTerminologyCapabilitiesImplementationList;
    function GetCurrent : TFhirTerminologyCapabilitiesImplementation;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirTerminologyCapabilitiesImplementationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTerminologyCapabilitiesImplementation read GetCurrent;
  end;

  TFhirTerminologyCapabilitiesImplementationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirTerminologyCapabilitiesImplementation;
    procedure SetItemN(index : Integer; value : TFhirTerminologyCapabilitiesImplementation);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirTerminologyCapabilitiesImplementationList; overload;
    function Clone : TFhirTerminologyCapabilitiesImplementationList; overload;
    function GetEnumerator : TFhirTerminologyCapabilitiesImplementationListEnumerator;
    
    //  Add a FhirTerminologyCapabilitiesImplementation to the end of the list.
    function Append : TFhirTerminologyCapabilitiesImplementation;
    
    // Add an already existing FhirTerminologyCapabilitiesImplementation to the end of the list.
    function AddItem(value : TFhirTerminologyCapabilitiesImplementation) : TFhirTerminologyCapabilitiesImplementation; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTerminologyCapabilitiesImplementation) : Integer;
    
    // Insert FhirTerminologyCapabilitiesImplementation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTerminologyCapabilitiesImplementation;
    
    // Insert an existing FhirTerminologyCapabilitiesImplementation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTerminologyCapabilitiesImplementation);
    
    // Get the iIndexth FhirTerminologyCapabilitiesImplementation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTerminologyCapabilitiesImplementation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTerminologyCapabilitiesImplementation;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirTerminologyCapabilitiesImplementations[index : Integer] : TFhirTerminologyCapabilitiesImplementation read GetItemN write SetItemN; default;
  End;

  // Identifies a code system that is supported by the server. If there is a no code system URL, then this declares the general assumptions a client can make about support for any CodeSystem resource.
  TFhirTerminologyCapabilitiesCodeSystem = class (TFhirBackboneElement)
  protected
    FUri : TFhirCanonical;
    FversionList : TFhirTerminologyCapabilitiesCodeSystemVersionList;
    FSubsumption : TFhirBoolean;
    procedure SetUri(value : TFhirCanonical);
    function GetUriST : String;
    procedure SetUriST(value : String);
    function GetVersionList : TFhirTerminologyCapabilitiesCodeSystemVersionList;
    function GetHasVersionList : Boolean;
    procedure SetSubsumption(value : TFhirBoolean);
    function GetSubsumptionST : Boolean;
    procedure SetSubsumptionST(value : Boolean);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTerminologyCapabilitiesCodeSystem; overload;
    function Clone : TFhirTerminologyCapabilitiesCodeSystem; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to URI for the Code System.
    property uri : String read GetUriST write SetUriST;
    // URI for the Code System.
    property uriElement : TFhirCanonical read FUri write SetUri;

    // For the code system, a list of versions that are supported by the server.
    property versionList : TFhirTerminologyCapabilitiesCodeSystemVersionList read GetVersionList;
    property hasVersionList : boolean read GetHasVersionList;

    // Typed access to True if subsumption is supported for this version of the code system.
    property subsumption : Boolean read GetSubsumptionST write SetSubsumptionST;
    // True if subsumption is supported for this version of the code system.
    property subsumptionElement : TFhirBoolean read FSubsumption write SetSubsumption;

  end;

  TFhirTerminologyCapabilitiesCodeSystemListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTerminologyCapabilitiesCodeSystemList;
    function GetCurrent : TFhirTerminologyCapabilitiesCodeSystem;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirTerminologyCapabilitiesCodeSystemList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTerminologyCapabilitiesCodeSystem read GetCurrent;
  end;

  TFhirTerminologyCapabilitiesCodeSystemList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirTerminologyCapabilitiesCodeSystem;
    procedure SetItemN(index : Integer; value : TFhirTerminologyCapabilitiesCodeSystem);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirTerminologyCapabilitiesCodeSystemList; overload;
    function Clone : TFhirTerminologyCapabilitiesCodeSystemList; overload;
    function GetEnumerator : TFhirTerminologyCapabilitiesCodeSystemListEnumerator;
    
    //  Add a FhirTerminologyCapabilitiesCodeSystem to the end of the list.
    function Append : TFhirTerminologyCapabilitiesCodeSystem;
    
    // Add an already existing FhirTerminologyCapabilitiesCodeSystem to the end of the list.
    function AddItem(value : TFhirTerminologyCapabilitiesCodeSystem) : TFhirTerminologyCapabilitiesCodeSystem; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTerminologyCapabilitiesCodeSystem) : Integer;
    
    // Insert FhirTerminologyCapabilitiesCodeSystem before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTerminologyCapabilitiesCodeSystem;
    
    // Insert an existing FhirTerminologyCapabilitiesCodeSystem before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTerminologyCapabilitiesCodeSystem);
    
    // Get the iIndexth FhirTerminologyCapabilitiesCodeSystem. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTerminologyCapabilitiesCodeSystem);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTerminologyCapabilitiesCodeSystem;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirTerminologyCapabilitiesCodeSystems[index : Integer] : TFhirTerminologyCapabilitiesCodeSystem read GetItemN write SetItemN; default;
  End;

  // For the code system, a list of versions that are supported by the server.
  TFhirTerminologyCapabilitiesCodeSystemVersion = class (TFhirBackboneElement)
  protected
    FCode : TFhirString;
    FIsDefault : TFhirBoolean;
    FCompositional : TFhirBoolean;
    FlanguageList : TFhirCodeList;
    FfilterList : TFhirTerminologyCapabilitiesCodeSystemVersionFilterList;
    Fproperty_List : TFhirCodeList;
    procedure SetCode(value : TFhirString);
    function GetCodeST : String;
    procedure SetCodeST(value : String);
    procedure SetIsDefault(value : TFhirBoolean);
    function GetIsDefaultST : Boolean;
    procedure SetIsDefaultST(value : Boolean);
    procedure SetCompositional(value : TFhirBoolean);
    function GetCompositionalST : Boolean;
    procedure SetCompositionalST(value : Boolean);
    function GetLanguageList : TFhirCodeList;
    function GetHasLanguageList : Boolean;
    function GetFilterList : TFhirTerminologyCapabilitiesCodeSystemVersionFilterList;
    function GetHasFilterList : Boolean;
    function GetProperty_List : TFhirCodeList;
    function GetHasProperty_List : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTerminologyCapabilitiesCodeSystemVersion; overload;
    function Clone : TFhirTerminologyCapabilitiesCodeSystemVersion; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to For version-less code systems, there should be a single version with no identifier.
    property code : String read GetCodeST write SetCodeST;
    // For version-less code systems, there should be a single version with no identifier.
    property codeElement : TFhirString read FCode write SetCode;

    // Typed access to If this is the default version for this code system.
    property isDefault : Boolean read GetIsDefaultST write SetIsDefaultST;
    // If this is the default version for this code system.
    property isDefaultElement : TFhirBoolean read FIsDefault write SetIsDefault;

    // Typed access to If the compositional grammar defined by the code system is supported.
    property compositional : Boolean read GetCompositionalST write SetCompositionalST;
    // If the compositional grammar defined by the code system is supported.
    property compositionalElement : TFhirBoolean read FCompositional write SetCompositional;

    // Language Displays supported.
    property languageList : TFhirCodeList read GetLanguageList;
    property hasLanguageList : boolean read GetHasLanguageList;

    // Filter Properties supported.
    property filterList : TFhirTerminologyCapabilitiesCodeSystemVersionFilterList read GetFilterList;
    property hasFilterList : boolean read GetHasFilterList;

    // Properties supported for $lookup.
    property property_List : TFhirCodeList read GetProperty_List;
    property hasProperty_List : boolean read GetHasProperty_List;

  end;

  TFhirTerminologyCapabilitiesCodeSystemVersionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTerminologyCapabilitiesCodeSystemVersionList;
    function GetCurrent : TFhirTerminologyCapabilitiesCodeSystemVersion;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirTerminologyCapabilitiesCodeSystemVersionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTerminologyCapabilitiesCodeSystemVersion read GetCurrent;
  end;

  TFhirTerminologyCapabilitiesCodeSystemVersionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirTerminologyCapabilitiesCodeSystemVersion;
    procedure SetItemN(index : Integer; value : TFhirTerminologyCapabilitiesCodeSystemVersion);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirTerminologyCapabilitiesCodeSystemVersionList; overload;
    function Clone : TFhirTerminologyCapabilitiesCodeSystemVersionList; overload;
    function GetEnumerator : TFhirTerminologyCapabilitiesCodeSystemVersionListEnumerator;
    
    //  Add a FhirTerminologyCapabilitiesCodeSystemVersion to the end of the list.
    function Append : TFhirTerminologyCapabilitiesCodeSystemVersion;
    
    // Add an already existing FhirTerminologyCapabilitiesCodeSystemVersion to the end of the list.
    function AddItem(value : TFhirTerminologyCapabilitiesCodeSystemVersion) : TFhirTerminologyCapabilitiesCodeSystemVersion; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTerminologyCapabilitiesCodeSystemVersion) : Integer;
    
    // Insert FhirTerminologyCapabilitiesCodeSystemVersion before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTerminologyCapabilitiesCodeSystemVersion;
    
    // Insert an existing FhirTerminologyCapabilitiesCodeSystemVersion before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTerminologyCapabilitiesCodeSystemVersion);
    
    // Get the iIndexth FhirTerminologyCapabilitiesCodeSystemVersion. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTerminologyCapabilitiesCodeSystemVersion);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTerminologyCapabilitiesCodeSystemVersion;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirTerminologyCapabilitiesCodeSystemVersions[index : Integer] : TFhirTerminologyCapabilitiesCodeSystemVersion read GetItemN write SetItemN; default;
  End;

  // Filter Properties supported.
  TFhirTerminologyCapabilitiesCodeSystemVersionFilter = class (TFhirBackboneElement)
  protected
    FCode : TFhirCode;
    FopList : TFhirCodeList;
    procedure SetCode(value : TFhirCode);
    function GetCodeST : String;
    procedure SetCodeST(value : String);
    function GetOpList : TFhirCodeList;
    function GetHasOpList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTerminologyCapabilitiesCodeSystemVersionFilter; overload;
    function Clone : TFhirTerminologyCapabilitiesCodeSystemVersionFilter; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Code of the property supported.
    property code : String read GetCodeST write SetCodeST;
    // Code of the property supported.
    property codeElement : TFhirCode read FCode write SetCode;

    // Operations supported for the property.
    property opList : TFhirCodeList read GetOpList;
    property hasOpList : boolean read GetHasOpList;

  end;

  TFhirTerminologyCapabilitiesCodeSystemVersionFilterListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTerminologyCapabilitiesCodeSystemVersionFilterList;
    function GetCurrent : TFhirTerminologyCapabilitiesCodeSystemVersionFilter;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirTerminologyCapabilitiesCodeSystemVersionFilterList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTerminologyCapabilitiesCodeSystemVersionFilter read GetCurrent;
  end;

  TFhirTerminologyCapabilitiesCodeSystemVersionFilterList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirTerminologyCapabilitiesCodeSystemVersionFilter;
    procedure SetItemN(index : Integer; value : TFhirTerminologyCapabilitiesCodeSystemVersionFilter);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirTerminologyCapabilitiesCodeSystemVersionFilterList; overload;
    function Clone : TFhirTerminologyCapabilitiesCodeSystemVersionFilterList; overload;
    function GetEnumerator : TFhirTerminologyCapabilitiesCodeSystemVersionFilterListEnumerator;
    
    //  Add a FhirTerminologyCapabilitiesCodeSystemVersionFilter to the end of the list.
    function Append : TFhirTerminologyCapabilitiesCodeSystemVersionFilter;
    
    // Add an already existing FhirTerminologyCapabilitiesCodeSystemVersionFilter to the end of the list.
    function AddItem(value : TFhirTerminologyCapabilitiesCodeSystemVersionFilter) : TFhirTerminologyCapabilitiesCodeSystemVersionFilter; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTerminologyCapabilitiesCodeSystemVersionFilter) : Integer;
    
    // Insert FhirTerminologyCapabilitiesCodeSystemVersionFilter before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTerminologyCapabilitiesCodeSystemVersionFilter;
    
    // Insert an existing FhirTerminologyCapabilitiesCodeSystemVersionFilter before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTerminologyCapabilitiesCodeSystemVersionFilter);
    
    // Get the iIndexth FhirTerminologyCapabilitiesCodeSystemVersionFilter. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTerminologyCapabilitiesCodeSystemVersionFilter);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTerminologyCapabilitiesCodeSystemVersionFilter;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirTerminologyCapabilitiesCodeSystemVersionFilters[index : Integer] : TFhirTerminologyCapabilitiesCodeSystemVersionFilter read GetItemN write SetItemN; default;
  End;

  // Information about the [ValueSet/$expand](valueset-operation-expand.html) operation.
  TFhirTerminologyCapabilitiesExpansion = class (TFhirBackboneElement)
  protected
    FHierarchical : TFhirBoolean;
    FPaging : TFhirBoolean;
    FIncomplete : TFhirBoolean;
    FparameterList : TFhirTerminologyCapabilitiesExpansionParameterList;
    FTextFilter : TFhirMarkdown;
    procedure SetHierarchical(value : TFhirBoolean);
    function GetHierarchicalST : Boolean;
    procedure SetHierarchicalST(value : Boolean);
    procedure SetPaging(value : TFhirBoolean);
    function GetPagingST : Boolean;
    procedure SetPagingST(value : Boolean);
    procedure SetIncomplete(value : TFhirBoolean);
    function GetIncompleteST : Boolean;
    procedure SetIncompleteST(value : Boolean);
    function GetParameterList : TFhirTerminologyCapabilitiesExpansionParameterList;
    function GetHasParameterList : Boolean;
    procedure SetTextFilter(value : TFhirMarkdown);
    function GetTextFilterST : String;
    procedure SetTextFilterST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTerminologyCapabilitiesExpansion; overload;
    function Clone : TFhirTerminologyCapabilitiesExpansion; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Whether the server can return nested value sets.
    property hierarchical : Boolean read GetHierarchicalST write SetHierarchicalST;
    // Whether the server can return nested value sets.
    property hierarchicalElement : TFhirBoolean read FHierarchical write SetHierarchical;

    // Typed access to Whether the server supports paging on expansion.
    property paging : Boolean read GetPagingST write SetPagingST;
    // Whether the server supports paging on expansion.
    property pagingElement : TFhirBoolean read FPaging write SetPaging;

    // Typed access to Allow request for incomplete expansions?
    property incomplete : Boolean read GetIncompleteST write SetIncompleteST;
    // Allow request for incomplete expansions?
    property incompleteElement : TFhirBoolean read FIncomplete write SetIncomplete;

    // Supported expansion parameter.
    property parameterList : TFhirTerminologyCapabilitiesExpansionParameterList read GetParameterList;
    property hasParameterList : boolean read GetHasParameterList;

    // Typed access to Documentation about text searching works.
    property textFilter : String read GetTextFilterST write SetTextFilterST;
    // Documentation about text searching works.
    property textFilterElement : TFhirMarkdown read FTextFilter write SetTextFilter;

  end;

  TFhirTerminologyCapabilitiesExpansionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTerminologyCapabilitiesExpansionList;
    function GetCurrent : TFhirTerminologyCapabilitiesExpansion;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirTerminologyCapabilitiesExpansionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTerminologyCapabilitiesExpansion read GetCurrent;
  end;

  TFhirTerminologyCapabilitiesExpansionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirTerminologyCapabilitiesExpansion;
    procedure SetItemN(index : Integer; value : TFhirTerminologyCapabilitiesExpansion);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirTerminologyCapabilitiesExpansionList; overload;
    function Clone : TFhirTerminologyCapabilitiesExpansionList; overload;
    function GetEnumerator : TFhirTerminologyCapabilitiesExpansionListEnumerator;
    
    //  Add a FhirTerminologyCapabilitiesExpansion to the end of the list.
    function Append : TFhirTerminologyCapabilitiesExpansion;
    
    // Add an already existing FhirTerminologyCapabilitiesExpansion to the end of the list.
    function AddItem(value : TFhirTerminologyCapabilitiesExpansion) : TFhirTerminologyCapabilitiesExpansion; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTerminologyCapabilitiesExpansion) : Integer;
    
    // Insert FhirTerminologyCapabilitiesExpansion before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTerminologyCapabilitiesExpansion;
    
    // Insert an existing FhirTerminologyCapabilitiesExpansion before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTerminologyCapabilitiesExpansion);
    
    // Get the iIndexth FhirTerminologyCapabilitiesExpansion. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTerminologyCapabilitiesExpansion);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTerminologyCapabilitiesExpansion;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirTerminologyCapabilitiesExpansions[index : Integer] : TFhirTerminologyCapabilitiesExpansion read GetItemN write SetItemN; default;
  End;

  // Supported expansion parameter.
  TFhirTerminologyCapabilitiesExpansionParameter = class (TFhirBackboneElement)
  protected
    FName : TFhirCode;
    FDocumentation : TFhirString;
    procedure SetName(value : TFhirCode);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetDocumentation(value : TFhirString);
    function GetDocumentationST : String;
    procedure SetDocumentationST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTerminologyCapabilitiesExpansionParameter; overload;
    function Clone : TFhirTerminologyCapabilitiesExpansionParameter; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Expansion Parameter name.
    property name : String read GetNameST write SetNameST;
    // Expansion Parameter name.
    property nameElement : TFhirCode read FName write SetName;

    // Typed access to Description of support for parameter.
    property documentation : String read GetDocumentationST write SetDocumentationST;
    // Description of support for parameter.
    property documentationElement : TFhirString read FDocumentation write SetDocumentation;

  end;

  TFhirTerminologyCapabilitiesExpansionParameterListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTerminologyCapabilitiesExpansionParameterList;
    function GetCurrent : TFhirTerminologyCapabilitiesExpansionParameter;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirTerminologyCapabilitiesExpansionParameterList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTerminologyCapabilitiesExpansionParameter read GetCurrent;
  end;

  TFhirTerminologyCapabilitiesExpansionParameterList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirTerminologyCapabilitiesExpansionParameter;
    procedure SetItemN(index : Integer; value : TFhirTerminologyCapabilitiesExpansionParameter);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirTerminologyCapabilitiesExpansionParameterList; overload;
    function Clone : TFhirTerminologyCapabilitiesExpansionParameterList; overload;
    function GetEnumerator : TFhirTerminologyCapabilitiesExpansionParameterListEnumerator;
    
    //  Add a FhirTerminologyCapabilitiesExpansionParameter to the end of the list.
    function Append : TFhirTerminologyCapabilitiesExpansionParameter;
    
    // Add an already existing FhirTerminologyCapabilitiesExpansionParameter to the end of the list.
    function AddItem(value : TFhirTerminologyCapabilitiesExpansionParameter) : TFhirTerminologyCapabilitiesExpansionParameter; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTerminologyCapabilitiesExpansionParameter) : Integer;
    
    // Insert FhirTerminologyCapabilitiesExpansionParameter before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTerminologyCapabilitiesExpansionParameter;
    
    // Insert an existing FhirTerminologyCapabilitiesExpansionParameter before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTerminologyCapabilitiesExpansionParameter);
    
    // Get the iIndexth FhirTerminologyCapabilitiesExpansionParameter. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTerminologyCapabilitiesExpansionParameter);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTerminologyCapabilitiesExpansionParameter;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirTerminologyCapabilitiesExpansionParameters[index : Integer] : TFhirTerminologyCapabilitiesExpansionParameter read GetItemN write SetItemN; default;
  End;

  // Information about the [ValueSet/$validate-code](valueset-operation-validate-code.html) operation.
  TFhirTerminologyCapabilitiesValidateCode = class (TFhirBackboneElement)
  protected
    FTranslations : TFhirBoolean;
    procedure SetTranslations(value : TFhirBoolean);
    function GetTranslationsST : Boolean;
    procedure SetTranslationsST(value : Boolean);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTerminologyCapabilitiesValidateCode; overload;
    function Clone : TFhirTerminologyCapabilitiesValidateCode; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Whether translations are validated.
    property translations : Boolean read GetTranslationsST write SetTranslationsST;
    // Whether translations are validated.
    property translationsElement : TFhirBoolean read FTranslations write SetTranslations;

  end;

  TFhirTerminologyCapabilitiesValidateCodeListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTerminologyCapabilitiesValidateCodeList;
    function GetCurrent : TFhirTerminologyCapabilitiesValidateCode;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirTerminologyCapabilitiesValidateCodeList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTerminologyCapabilitiesValidateCode read GetCurrent;
  end;

  TFhirTerminologyCapabilitiesValidateCodeList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirTerminologyCapabilitiesValidateCode;
    procedure SetItemN(index : Integer; value : TFhirTerminologyCapabilitiesValidateCode);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirTerminologyCapabilitiesValidateCodeList; overload;
    function Clone : TFhirTerminologyCapabilitiesValidateCodeList; overload;
    function GetEnumerator : TFhirTerminologyCapabilitiesValidateCodeListEnumerator;
    
    //  Add a FhirTerminologyCapabilitiesValidateCode to the end of the list.
    function Append : TFhirTerminologyCapabilitiesValidateCode;
    
    // Add an already existing FhirTerminologyCapabilitiesValidateCode to the end of the list.
    function AddItem(value : TFhirTerminologyCapabilitiesValidateCode) : TFhirTerminologyCapabilitiesValidateCode; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTerminologyCapabilitiesValidateCode) : Integer;
    
    // Insert FhirTerminologyCapabilitiesValidateCode before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTerminologyCapabilitiesValidateCode;
    
    // Insert an existing FhirTerminologyCapabilitiesValidateCode before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTerminologyCapabilitiesValidateCode);
    
    // Get the iIndexth FhirTerminologyCapabilitiesValidateCode. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTerminologyCapabilitiesValidateCode);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTerminologyCapabilitiesValidateCode;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirTerminologyCapabilitiesValidateCodes[index : Integer] : TFhirTerminologyCapabilitiesValidateCode read GetItemN write SetItemN; default;
  End;

  // Information about the [ConceptMap/$translate](conceptmap-operation-translate.html) operation.
  TFhirTerminologyCapabilitiesTranslation = class (TFhirBackboneElement)
  protected
    FNeedsMap : TFhirBoolean;
    procedure SetNeedsMap(value : TFhirBoolean);
    function GetNeedsMapST : Boolean;
    procedure SetNeedsMapST(value : Boolean);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTerminologyCapabilitiesTranslation; overload;
    function Clone : TFhirTerminologyCapabilitiesTranslation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Whether the client must identify the map.
    property needsMap : Boolean read GetNeedsMapST write SetNeedsMapST;
    // Whether the client must identify the map.
    property needsMapElement : TFhirBoolean read FNeedsMap write SetNeedsMap;

  end;

  TFhirTerminologyCapabilitiesTranslationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTerminologyCapabilitiesTranslationList;
    function GetCurrent : TFhirTerminologyCapabilitiesTranslation;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirTerminologyCapabilitiesTranslationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTerminologyCapabilitiesTranslation read GetCurrent;
  end;

  TFhirTerminologyCapabilitiesTranslationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirTerminologyCapabilitiesTranslation;
    procedure SetItemN(index : Integer; value : TFhirTerminologyCapabilitiesTranslation);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirTerminologyCapabilitiesTranslationList; overload;
    function Clone : TFhirTerminologyCapabilitiesTranslationList; overload;
    function GetEnumerator : TFhirTerminologyCapabilitiesTranslationListEnumerator;
    
    //  Add a FhirTerminologyCapabilitiesTranslation to the end of the list.
    function Append : TFhirTerminologyCapabilitiesTranslation;
    
    // Add an already existing FhirTerminologyCapabilitiesTranslation to the end of the list.
    function AddItem(value : TFhirTerminologyCapabilitiesTranslation) : TFhirTerminologyCapabilitiesTranslation; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTerminologyCapabilitiesTranslation) : Integer;
    
    // Insert FhirTerminologyCapabilitiesTranslation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTerminologyCapabilitiesTranslation;
    
    // Insert an existing FhirTerminologyCapabilitiesTranslation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTerminologyCapabilitiesTranslation);
    
    // Get the iIndexth FhirTerminologyCapabilitiesTranslation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTerminologyCapabilitiesTranslation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTerminologyCapabilitiesTranslation;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirTerminologyCapabilitiesTranslations[index : Integer] : TFhirTerminologyCapabilitiesTranslation read GetItemN write SetItemN; default;
  End;

  // Whether the $closure operation is supported.
  TFhirTerminologyCapabilitiesClosure = class (TFhirBackboneElement)
  protected
    FTranslation : TFhirBoolean;
    procedure SetTranslation(value : TFhirBoolean);
    function GetTranslationST : Boolean;
    procedure SetTranslationST(value : Boolean);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTerminologyCapabilitiesClosure; overload;
    function Clone : TFhirTerminologyCapabilitiesClosure; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to If cross-system closure is supported.
    property translation : Boolean read GetTranslationST write SetTranslationST;
    // If cross-system closure is supported.
    property translationElement : TFhirBoolean read FTranslation write SetTranslation;

  end;

  TFhirTerminologyCapabilitiesClosureListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTerminologyCapabilitiesClosureList;
    function GetCurrent : TFhirTerminologyCapabilitiesClosure;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirTerminologyCapabilitiesClosureList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTerminologyCapabilitiesClosure read GetCurrent;
  end;

  TFhirTerminologyCapabilitiesClosureList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirTerminologyCapabilitiesClosure;
    procedure SetItemN(index : Integer; value : TFhirTerminologyCapabilitiesClosure);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirTerminologyCapabilitiesClosureList; overload;
    function Clone : TFhirTerminologyCapabilitiesClosureList; overload;
    function GetEnumerator : TFhirTerminologyCapabilitiesClosureListEnumerator;
    
    //  Add a FhirTerminologyCapabilitiesClosure to the end of the list.
    function Append : TFhirTerminologyCapabilitiesClosure;
    
    // Add an already existing FhirTerminologyCapabilitiesClosure to the end of the list.
    function AddItem(value : TFhirTerminologyCapabilitiesClosure) : TFhirTerminologyCapabilitiesClosure; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTerminologyCapabilitiesClosure) : Integer;
    
    // Insert FhirTerminologyCapabilitiesClosure before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTerminologyCapabilitiesClosure;
    
    // Insert an existing FhirTerminologyCapabilitiesClosure before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTerminologyCapabilitiesClosure);
    
    // Get the iIndexth FhirTerminologyCapabilitiesClosure. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTerminologyCapabilitiesClosure);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTerminologyCapabilitiesClosure;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirTerminologyCapabilitiesClosures[index : Integer] : TFhirTerminologyCapabilitiesClosure read GetItemN write SetItemN; default;
  End;

  // A TerminologyCapabilities resource documents a set of capabilities (behaviors) of a FHIR Terminology Server that may be used as a statement of actual server functionality or a statement of required or desired server implementation.
  TFhirTerminologyCapabilities = class (TFhirDomainResource)
  protected
    FUrl : TFhirUri;
    FVersion : TFhirString;
    FName : TFhirString;
    FTitle : TFhirString;
    FStatus : TFhirEnum;
    FExperimental : TFhirBoolean;
    FDate : TFhirDateTime;
    FPublisher : TFhirString;
    FcontactList : TFhirContactDetailList;
    FDescription : TFhirMarkdown;
    FuseContextList : TFhirUsageContextList;
    FjurisdictionList : TFhirCodeableConceptList;
    FPurpose : TFhirMarkdown;
    FCopyright : TFhirMarkdown;
    FKind : TFhirEnum;
    FSoftware : TFhirTerminologyCapabilitiesSoftware;
    FImplementation_ : TFhirTerminologyCapabilitiesImplementation;
    FLockedDate : TFhirBoolean;
    FcodeSystemList : TFhirTerminologyCapabilitiesCodeSystemList;
    FExpansion : TFhirTerminologyCapabilitiesExpansion;
    FCodeSearch : TFhirEnum;
    FValidateCode : TFhirTerminologyCapabilitiesValidateCode;
    FTranslation : TFhirTerminologyCapabilitiesTranslation;
    FClosure : TFhirTerminologyCapabilitiesClosure;
    procedure SetUrl(value : TFhirUri);
    function GetUrlST : String;
    procedure SetUrlST(value : String);
    procedure SetVersion(value : TFhirString);
    function GetVersionST : String;
    procedure SetVersionST(value : String);
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetTitle(value : TFhirString);
    function GetTitleST : String;
    procedure SetTitleST(value : String);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirPublicationStatusEnum;
    procedure SetStatusST(value : TFhirPublicationStatusEnum);
    procedure SetExperimental(value : TFhirBoolean);
    function GetExperimentalST : Boolean;
    procedure SetExperimentalST(value : Boolean);
    procedure SetDate(value : TFhirDateTime);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    procedure SetPublisher(value : TFhirString);
    function GetPublisherST : String;
    procedure SetPublisherST(value : String);
    function GetContactList : TFhirContactDetailList;
    function GetHasContactList : Boolean;
    procedure SetDescription(value : TFhirMarkdown);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetUseContextList : TFhirUsageContextList;
    function GetHasUseContextList : Boolean;
    function GetJurisdictionList : TFhirCodeableConceptList;
    function GetHasJurisdictionList : Boolean;
    procedure SetPurpose(value : TFhirMarkdown);
    function GetPurposeST : String;
    procedure SetPurposeST(value : String);
    procedure SetCopyright(value : TFhirMarkdown);
    function GetCopyrightST : String;
    procedure SetCopyrightST(value : String);
    procedure SetKind(value : TFhirEnum);
    function GetKindST : TFhirCapabilityStatementKindEnum;
    procedure SetKindST(value : TFhirCapabilityStatementKindEnum);
    procedure SetSoftware(value : TFhirTerminologyCapabilitiesSoftware);
    procedure SetImplementation_(value : TFhirTerminologyCapabilitiesImplementation);
    procedure SetLockedDate(value : TFhirBoolean);
    function GetLockedDateST : Boolean;
    procedure SetLockedDateST(value : Boolean);
    function GetCodeSystemList : TFhirTerminologyCapabilitiesCodeSystemList;
    function GetHasCodeSystemList : Boolean;
    procedure SetExpansion(value : TFhirTerminologyCapabilitiesExpansion);
    procedure SetCodeSearch(value : TFhirEnum);
    function GetCodeSearchST : TFhirCodeSearchSupportEnum;
    procedure SetCodeSearchST(value : TFhirCodeSearchSupportEnum);
    procedure SetValidateCode(value : TFhirTerminologyCapabilitiesValidateCode);
    procedure SetTranslation(value : TFhirTerminologyCapabilitiesTranslation);
    procedure SetClosure(value : TFhirTerminologyCapabilitiesClosure);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTerminologyCapabilities; overload;
    function Clone : TFhirTerminologyCapabilities; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An absolute URI that is used to identify this terminology capabilities when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this terminology capabilities is (or will be) published. This URL can be the target of a canonical reference. It SHALL remain the same when the terminology capabilities is stored on different servers.
    property url : String read GetUrlST write SetUrlST;
    // An absolute URI that is used to identify this terminology capabilities when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this terminology capabilities is (or will be) published. This URL can be the target of a canonical reference. It SHALL remain the same when the terminology capabilities is stored on different servers.
    property urlElement : TFhirUri read FUrl write SetUrl;

    // Typed access to The identifier that is used to identify this version of the terminology capabilities when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the terminology capabilities author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
    property version : String read GetVersionST write SetVersionST;
    // The identifier that is used to identify this version of the terminology capabilities when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the terminology capabilities author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to A natural language name identifying the terminology capabilities. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property name : String read GetNameST write SetNameST;
    // A natural language name identifying the terminology capabilities. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A short, descriptive, user-friendly title for the terminology capabilities.
    property title : String read GetTitleST write SetTitleST;
    // A short, descriptive, user-friendly title for the terminology capabilities.
    property titleElement : TFhirString read FTitle write SetTitle;

    // The status of this terminology capabilities. Enables tracking the life-cycle of the content.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A Boolean value to indicate that this terminology capabilities is authored for testing purposes (or education/evaluation/marketing) and is not intended to be used for genuine usage.
    property experimental : Boolean read GetExperimentalST write SetExperimentalST;
    // A Boolean value to indicate that this terminology capabilities is authored for testing purposes (or education/evaluation/marketing) and is not intended to be used for genuine usage.
    property experimentalElement : TFhirBoolean read FExperimental write SetExperimental;

    // Typed access to The date  (and optionally time) when the terminology capabilities was published. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the terminology capabilities changes.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date  (and optionally time) when the terminology capabilities was published. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the terminology capabilities changes.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The name of the organization or individual that published the terminology capabilities.
    property publisher : String read GetPublisherST write SetPublisherST;
    // The name of the organization or individual that published the terminology capabilities.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Contact details to assist a user in finding and communicating with the publisher.
    property contactList : TFhirContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to A free text natural language description of the terminology capabilities from a consumer's perspective. Typically, this is used when the capability statement describes a desired rather than an actual solution, for example as a formal expression of requirements as part of an RFP.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A free text natural language description of the terminology capabilities from a consumer's perspective. Typically, this is used when the capability statement describes a desired rather than an actual solution, for example as a formal expression of requirements as part of an RFP.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // The content was developed with a focus and intent of supporting the contexts that are listed. These contexts may be general categories (gender, age, ...) or may be references to specific programs (insurance plans, studies, ...) and may be used to assist with indexing and searching for appropriate terminology capabilities instances.
    property useContextList : TFhirUsageContextList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // A legal or geographic region in which the terminology capabilities is intended to be used.
    property jurisdictionList : TFhirCodeableConceptList read GetJurisdictionList;
    property hasJurisdictionList : boolean read GetHasJurisdictionList;

    // Typed access to Explanation of why this terminology capabilities is needed and why it has been designed as it has.
    property purpose : String read GetPurposeST write SetPurposeST;
    // Explanation of why this terminology capabilities is needed and why it has been designed as it has.
    property purposeElement : TFhirMarkdown read FPurpose write SetPurpose;

    // Typed access to A copyright statement relating to the terminology capabilities and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the terminology capabilities.
    property copyright : String read GetCopyrightST write SetCopyrightST;
    // A copyright statement relating to the terminology capabilities and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the terminology capabilities.
    property copyrightElement : TFhirMarkdown read FCopyright write SetCopyright;

    // The way that this statement is intended to be used, to describe an actual running instance of software, a particular product (kind, not instance of software) or a class of implementation (e.g. a desired purchase).
    property kind : TFhirCapabilityStatementKindEnum read GetKindST write SetKindST;
    property kindElement : TFhirEnum read FKind write SetKind;

    // Typed access to Software that is covered by this terminology capability statement.  It is used when the statement describes the capabilities of a particular software version, independent of an installation. (defined for API consistency)
    property software : TFhirTerminologyCapabilitiesSoftware read FSoftware write SetSoftware;
    // Software that is covered by this terminology capability statement.  It is used when the statement describes the capabilities of a particular software version, independent of an installation.
    property softwareElement : TFhirTerminologyCapabilitiesSoftware read FSoftware write SetSoftware;

    // Typed access to Identifies a specific implementation instance that is described by the terminology capability statement - i.e. a particular installation, rather than the capabilities of a software program. (defined for API consistency)
    property implementation_ : TFhirTerminologyCapabilitiesImplementation read FImplementation_ write SetImplementation_;
    // Identifies a specific implementation instance that is described by the terminology capability statement - i.e. a particular installation, rather than the capabilities of a software program.
    property implementation_Element : TFhirTerminologyCapabilitiesImplementation read FImplementation_ write SetImplementation_;

    // Typed access to Whether the server supports lockedDate.
    property lockedDate : Boolean read GetLockedDateST write SetLockedDateST;
    // Whether the server supports lockedDate.
    property lockedDateElement : TFhirBoolean read FLockedDate write SetLockedDate;

    // Identifies a code system that is supported by the server. If there is a no code system URL, then this declares the general assumptions a client can make about support for any CodeSystem resource.
    property codeSystemList : TFhirTerminologyCapabilitiesCodeSystemList read GetCodeSystemList;
    property hasCodeSystemList : boolean read GetHasCodeSystemList;

    // Typed access to Information about the [ValueSet/$expand](valueset-operation-expand.html) operation. (defined for API consistency)
    property expansion : TFhirTerminologyCapabilitiesExpansion read FExpansion write SetExpansion;
    // Information about the [ValueSet/$expand](valueset-operation-expand.html) operation.
    property expansionElement : TFhirTerminologyCapabilitiesExpansion read FExpansion write SetExpansion;

    // The degree to which the server supports the code search parameter on ValueSet, if it is supported.
    property codeSearch : TFhirCodeSearchSupportEnum read GetCodeSearchST write SetCodeSearchST;
    property codeSearchElement : TFhirEnum read FCodeSearch write SetCodeSearch;

    // Typed access to Information about the [ValueSet/$validate-code](valueset-operation-validate-code.html) operation. (defined for API consistency)
    property validateCode : TFhirTerminologyCapabilitiesValidateCode read FValidateCode write SetValidateCode;
    // Information about the [ValueSet/$validate-code](valueset-operation-validate-code.html) operation.
    property validateCodeElement : TFhirTerminologyCapabilitiesValidateCode read FValidateCode write SetValidateCode;

    // Typed access to Information about the [ConceptMap/$translate](conceptmap-operation-translate.html) operation. (defined for API consistency)
    property translation : TFhirTerminologyCapabilitiesTranslation read FTranslation write SetTranslation;
    // Information about the [ConceptMap/$translate](conceptmap-operation-translate.html) operation.
    property translationElement : TFhirTerminologyCapabilitiesTranslation read FTranslation write SetTranslation;

    // Typed access to Whether the $closure operation is supported. (defined for API consistency)
    property closure : TFhirTerminologyCapabilitiesClosure read FClosure write SetClosure;
    // Whether the $closure operation is supported.
    property closureElement : TFhirTerminologyCapabilitiesClosure read FClosure write SetClosure;

  end;

  TFhirTerminologyCapabilitiesListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTerminologyCapabilitiesList;
    function GetCurrent : TFhirTerminologyCapabilities;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirTerminologyCapabilitiesList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTerminologyCapabilities read GetCurrent;
  end;

  TFhirTerminologyCapabilitiesList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirTerminologyCapabilities;
    procedure SetItemN(index : Integer; value : TFhirTerminologyCapabilities);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirTerminologyCapabilitiesList; overload;
    function Clone : TFhirTerminologyCapabilitiesList; overload;
    function GetEnumerator : TFhirTerminologyCapabilitiesListEnumerator;
    
    //  Add a FhirTerminologyCapabilities to the end of the list.
    function Append : TFhirTerminologyCapabilities;
    
    // Add an already existing FhirTerminologyCapabilities to the end of the list.
    function AddItem(value : TFhirTerminologyCapabilities) : TFhirTerminologyCapabilities; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTerminologyCapabilities) : Integer;
    
    // Insert FhirTerminologyCapabilities before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTerminologyCapabilities;
    
    // Insert an existing FhirTerminologyCapabilities before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTerminologyCapabilities);
    
    // Get the iIndexth FhirTerminologyCapabilities. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTerminologyCapabilities);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTerminologyCapabilities;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirTerminologyCapabilities[index : Integer] : TFhirTerminologyCapabilities read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_TERMINOLOGYCAPABILITIES}
{$IFDEF FHIR_TESTSCRIPT}
  // An abstract server used in operations within this test script in the origin element.
  TFhirTestScriptOrigin = class (TFhirBackboneElement)
  protected
    FIndex : TFhirInteger;
    FProfile : TFhirCoding;
    procedure SetIndex(value : TFhirInteger);
    function GetIndexST : String;
    procedure SetIndexST(value : String);
    procedure SetProfile(value : TFhirCoding);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestScriptOrigin; overload;
    function Clone : TFhirTestScriptOrigin; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Abstract name given to an origin server in this test script.  The name is provided as a number starting at 1.
    property index : String read GetIndexST write SetIndexST;
    // Abstract name given to an origin server in this test script.  The name is provided as a number starting at 1.
    property indexElement : TFhirInteger read FIndex write SetIndex;

    // Typed access to The type of origin profile the test system supports. (defined for API consistency)
    property profile : TFhirCoding read FProfile write SetProfile;
    // The type of origin profile the test system supports.
    property profileElement : TFhirCoding read FProfile write SetProfile;

  end;

  TFhirTestScriptOriginListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestScriptOriginList;
    function GetCurrent : TFhirTestScriptOrigin;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirTestScriptOriginList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestScriptOrigin read GetCurrent;
  end;

  TFhirTestScriptOriginList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirTestScriptOrigin;
    procedure SetItemN(index : Integer; value : TFhirTestScriptOrigin);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirTestScriptOriginList; overload;
    function Clone : TFhirTestScriptOriginList; overload;
    function GetEnumerator : TFhirTestScriptOriginListEnumerator;
    
    //  Add a FhirTestScriptOrigin to the end of the list.
    function Append : TFhirTestScriptOrigin;
    
    // Add an already existing FhirTestScriptOrigin to the end of the list.
    function AddItem(value : TFhirTestScriptOrigin) : TFhirTestScriptOrigin; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestScriptOrigin) : Integer;
    
    // Insert FhirTestScriptOrigin before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestScriptOrigin;
    
    // Insert an existing FhirTestScriptOrigin before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestScriptOrigin);
    
    // Get the iIndexth FhirTestScriptOrigin. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestScriptOrigin);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTestScriptOrigin;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirTestScriptOrigins[index : Integer] : TFhirTestScriptOrigin read GetItemN write SetItemN; default;
  End;

  // An abstract server used in operations within this test script in the destination element.
  TFhirTestScriptDestination = class (TFhirBackboneElement)
  protected
    FIndex : TFhirInteger;
    FProfile : TFhirCoding;
    procedure SetIndex(value : TFhirInteger);
    function GetIndexST : String;
    procedure SetIndexST(value : String);
    procedure SetProfile(value : TFhirCoding);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestScriptDestination; overload;
    function Clone : TFhirTestScriptDestination; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Abstract name given to a destination server in this test script.  The name is provided as a number starting at 1.
    property index : String read GetIndexST write SetIndexST;
    // Abstract name given to a destination server in this test script.  The name is provided as a number starting at 1.
    property indexElement : TFhirInteger read FIndex write SetIndex;

    // Typed access to The type of destination profile the test system supports. (defined for API consistency)
    property profile : TFhirCoding read FProfile write SetProfile;
    // The type of destination profile the test system supports.
    property profileElement : TFhirCoding read FProfile write SetProfile;

  end;

  TFhirTestScriptDestinationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestScriptDestinationList;
    function GetCurrent : TFhirTestScriptDestination;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirTestScriptDestinationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestScriptDestination read GetCurrent;
  end;

  TFhirTestScriptDestinationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirTestScriptDestination;
    procedure SetItemN(index : Integer; value : TFhirTestScriptDestination);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirTestScriptDestinationList; overload;
    function Clone : TFhirTestScriptDestinationList; overload;
    function GetEnumerator : TFhirTestScriptDestinationListEnumerator;
    
    //  Add a FhirTestScriptDestination to the end of the list.
    function Append : TFhirTestScriptDestination;
    
    // Add an already existing FhirTestScriptDestination to the end of the list.
    function AddItem(value : TFhirTestScriptDestination) : TFhirTestScriptDestination; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestScriptDestination) : Integer;
    
    // Insert FhirTestScriptDestination before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestScriptDestination;
    
    // Insert an existing FhirTestScriptDestination before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestScriptDestination);
    
    // Get the iIndexth FhirTestScriptDestination. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestScriptDestination);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTestScriptDestination;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirTestScriptDestinations[index : Integer] : TFhirTestScriptDestination read GetItemN write SetItemN; default;
  End;

  // The required capability must exist and are assumed to function correctly on the FHIR server being tested.
  TFhirTestScriptMetadata = class (TFhirBackboneElement)
  protected
    Flink_List : TFhirTestScriptMetadataLinkList;
    FcapabilityList : TFhirTestScriptMetadataCapabilityList;
    function GetLink_List : TFhirTestScriptMetadataLinkList;
    function GetHasLink_List : Boolean;
    function GetCapabilityList : TFhirTestScriptMetadataCapabilityList;
    function GetHasCapabilityList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestScriptMetadata; overload;
    function Clone : TFhirTestScriptMetadata; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // A link to the FHIR specification that this test is covering.
    property link_List : TFhirTestScriptMetadataLinkList read GetLink_List;
    property hasLink_List : boolean read GetHasLink_List;

    // Capabilities that must exist and are assumed to function correctly on the FHIR server being tested.
    property capabilityList : TFhirTestScriptMetadataCapabilityList read GetCapabilityList;
    property hasCapabilityList : boolean read GetHasCapabilityList;

  end;

  TFhirTestScriptMetadataListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestScriptMetadataList;
    function GetCurrent : TFhirTestScriptMetadata;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirTestScriptMetadataList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestScriptMetadata read GetCurrent;
  end;

  TFhirTestScriptMetadataList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirTestScriptMetadata;
    procedure SetItemN(index : Integer; value : TFhirTestScriptMetadata);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirTestScriptMetadataList; overload;
    function Clone : TFhirTestScriptMetadataList; overload;
    function GetEnumerator : TFhirTestScriptMetadataListEnumerator;
    
    //  Add a FhirTestScriptMetadata to the end of the list.
    function Append : TFhirTestScriptMetadata;
    
    // Add an already existing FhirTestScriptMetadata to the end of the list.
    function AddItem(value : TFhirTestScriptMetadata) : TFhirTestScriptMetadata; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestScriptMetadata) : Integer;
    
    // Insert FhirTestScriptMetadata before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestScriptMetadata;
    
    // Insert an existing FhirTestScriptMetadata before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestScriptMetadata);
    
    // Get the iIndexth FhirTestScriptMetadata. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestScriptMetadata);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTestScriptMetadata;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirTestScriptMetadata[index : Integer] : TFhirTestScriptMetadata read GetItemN write SetItemN; default;
  End;

  // A link to the FHIR specification that this test is covering.
  TFhirTestScriptMetadataLink = class (TFhirBackboneElement)
  protected
    FUrl : TFhirUri;
    FDescription : TFhirString;
    procedure SetUrl(value : TFhirUri);
    function GetUrlST : String;
    procedure SetUrlST(value : String);
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestScriptMetadataLink; overload;
    function Clone : TFhirTestScriptMetadataLink; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to URL to a particular requirement or feature within the FHIR specification.
    property url : String read GetUrlST write SetUrlST;
    // URL to a particular requirement or feature within the FHIR specification.
    property urlElement : TFhirUri read FUrl write SetUrl;

    // Typed access to Short description of the link.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Short description of the link.
    property descriptionElement : TFhirString read FDescription write SetDescription;

  end;

  TFhirTestScriptMetadataLinkListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestScriptMetadataLinkList;
    function GetCurrent : TFhirTestScriptMetadataLink;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirTestScriptMetadataLinkList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestScriptMetadataLink read GetCurrent;
  end;

  TFhirTestScriptMetadataLinkList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirTestScriptMetadataLink;
    procedure SetItemN(index : Integer; value : TFhirTestScriptMetadataLink);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirTestScriptMetadataLinkList; overload;
    function Clone : TFhirTestScriptMetadataLinkList; overload;
    function GetEnumerator : TFhirTestScriptMetadataLinkListEnumerator;
    
    //  Add a FhirTestScriptMetadataLink to the end of the list.
    function Append : TFhirTestScriptMetadataLink;
    
    // Add an already existing FhirTestScriptMetadataLink to the end of the list.
    function AddItem(value : TFhirTestScriptMetadataLink) : TFhirTestScriptMetadataLink; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestScriptMetadataLink) : Integer;
    
    // Insert FhirTestScriptMetadataLink before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestScriptMetadataLink;
    
    // Insert an existing FhirTestScriptMetadataLink before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestScriptMetadataLink);
    
    // Get the iIndexth FhirTestScriptMetadataLink. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestScriptMetadataLink);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTestScriptMetadataLink;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirTestScriptMetadataLinks[index : Integer] : TFhirTestScriptMetadataLink read GetItemN write SetItemN; default;
  End;

  // Capabilities that must exist and are assumed to function correctly on the FHIR server being tested.
  TFhirTestScriptMetadataCapability = class (TFhirBackboneElement)
  protected
    FRequired : TFhirBoolean;
    FValidated : TFhirBoolean;
    FDescription : TFhirString;
    ForiginList : TFhirIntegerList;
    FDestination : TFhirInteger;
    Flink_List : TFhirUriList;
    FCapabilities : TFhirCanonical;
    procedure SetRequired(value : TFhirBoolean);
    function GetRequiredST : Boolean;
    procedure SetRequiredST(value : Boolean);
    procedure SetValidated(value : TFhirBoolean);
    function GetValidatedST : Boolean;
    procedure SetValidatedST(value : Boolean);
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetOriginList : TFhirIntegerList;
    function GetHasOriginList : Boolean;
    procedure SetDestination(value : TFhirInteger);
    function GetDestinationST : String;
    procedure SetDestinationST(value : String);
    function GetLink_List : TFhirUriList;
    function GetHasLink_List : Boolean;
    procedure SetCapabilities(value : TFhirCanonical);
    function GetCapabilitiesST : String;
    procedure SetCapabilitiesST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestScriptMetadataCapability; overload;
    function Clone : TFhirTestScriptMetadataCapability; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Whether or not the test execution will require the given capabilities of the server in order for this test script to execute.
    property required : Boolean read GetRequiredST write SetRequiredST;
    // Whether or not the test execution will require the given capabilities of the server in order for this test script to execute.
    property requiredElement : TFhirBoolean read FRequired write SetRequired;

    // Typed access to Whether or not the test execution will validate the given capabilities of the server in order for this test script to execute.
    property validated : Boolean read GetValidatedST write SetValidatedST;
    // Whether or not the test execution will validate the given capabilities of the server in order for this test script to execute.
    property validatedElement : TFhirBoolean read FValidated write SetValidated;

    // Typed access to Description of the capabilities that this test script is requiring the server to support.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Description of the capabilities that this test script is requiring the server to support.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Which origin server these requirements apply to.
    property originList : TFhirIntegerList read GetOriginList;
    property hasOriginList : boolean read GetHasOriginList;

    // Typed access to Which server these requirements apply to.
    property destination : String read GetDestinationST write SetDestinationST;
    // Which server these requirements apply to.
    property destinationElement : TFhirInteger read FDestination write SetDestination;

    // Links to the FHIR specification that describes this interaction and the resources involved in more detail.
    property link_List : TFhirUriList read GetLink_List;
    property hasLink_List : boolean read GetHasLink_List;

    // Typed access to Minimum capabilities required of server for test script to execute successfully.   If server does not meet at a minimum the referenced capability statement, then all tests in this script are skipped.
    property capabilities : String read GetCapabilitiesST write SetCapabilitiesST;
    // Minimum capabilities required of server for test script to execute successfully.   If server does not meet at a minimum the referenced capability statement, then all tests in this script are skipped.
    property capabilitiesElement : TFhirCanonical read FCapabilities write SetCapabilities;

  end;

  TFhirTestScriptMetadataCapabilityListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestScriptMetadataCapabilityList;
    function GetCurrent : TFhirTestScriptMetadataCapability;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirTestScriptMetadataCapabilityList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestScriptMetadataCapability read GetCurrent;
  end;

  TFhirTestScriptMetadataCapabilityList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirTestScriptMetadataCapability;
    procedure SetItemN(index : Integer; value : TFhirTestScriptMetadataCapability);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirTestScriptMetadataCapabilityList; overload;
    function Clone : TFhirTestScriptMetadataCapabilityList; overload;
    function GetEnumerator : TFhirTestScriptMetadataCapabilityListEnumerator;
    
    //  Add a FhirTestScriptMetadataCapability to the end of the list.
    function Append : TFhirTestScriptMetadataCapability;
    
    // Add an already existing FhirTestScriptMetadataCapability to the end of the list.
    function AddItem(value : TFhirTestScriptMetadataCapability) : TFhirTestScriptMetadataCapability; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestScriptMetadataCapability) : Integer;
    
    // Insert FhirTestScriptMetadataCapability before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestScriptMetadataCapability;
    
    // Insert an existing FhirTestScriptMetadataCapability before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestScriptMetadataCapability);
    
    // Get the iIndexth FhirTestScriptMetadataCapability. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestScriptMetadataCapability);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTestScriptMetadataCapability;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirTestScriptMetadataCapabilities[index : Integer] : TFhirTestScriptMetadataCapability read GetItemN write SetItemN; default;
  End;

  // Fixture in the test script - by reference (uri). All fixtures are required for the test script to execute.
  TFhirTestScriptFixture = class (TFhirBackboneElement)
  protected
    FAutocreate : TFhirBoolean;
    FAutodelete : TFhirBoolean;
    FResource : TFhirReference;
    procedure SetAutocreate(value : TFhirBoolean);
    function GetAutocreateST : Boolean;
    procedure SetAutocreateST(value : Boolean);
    procedure SetAutodelete(value : TFhirBoolean);
    function GetAutodeleteST : Boolean;
    procedure SetAutodeleteST(value : Boolean);
    procedure SetResource(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestScriptFixture; overload;
    function Clone : TFhirTestScriptFixture; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Whether or not to implicitly create the fixture during setup. If true, the fixture is automatically created on each server being tested during setup, therefore no create operation is required for this fixture in the TestScript.setup section.
    property autocreate : Boolean read GetAutocreateST write SetAutocreateST;
    // Whether or not to implicitly create the fixture during setup. If true, the fixture is automatically created on each server being tested during setup, therefore no create operation is required for this fixture in the TestScript.setup section.
    property autocreateElement : TFhirBoolean read FAutocreate write SetAutocreate;

    // Typed access to Whether or not to implicitly delete the fixture during teardown. If true, the fixture is automatically deleted on each server being tested during teardown, therefore no delete operation is required for this fixture in the TestScript.teardown section.
    property autodelete : Boolean read GetAutodeleteST write SetAutodeleteST;
    // Whether or not to implicitly delete the fixture during teardown. If true, the fixture is automatically deleted on each server being tested during teardown, therefore no delete operation is required for this fixture in the TestScript.teardown section.
    property autodeleteElement : TFhirBoolean read FAutodelete write SetAutodelete;

    // Typed access to Reference to the resource (containing the contents of the resource needed for operations). (defined for API consistency)
    property resource : TFhirReference read FResource write SetResource;
    // Reference to the resource (containing the contents of the resource needed for operations).
    property resourceElement : TFhirReference read FResource write SetResource;

  end;

  TFhirTestScriptFixtureListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestScriptFixtureList;
    function GetCurrent : TFhirTestScriptFixture;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirTestScriptFixtureList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestScriptFixture read GetCurrent;
  end;

  TFhirTestScriptFixtureList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirTestScriptFixture;
    procedure SetItemN(index : Integer; value : TFhirTestScriptFixture);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirTestScriptFixtureList; overload;
    function Clone : TFhirTestScriptFixtureList; overload;
    function GetEnumerator : TFhirTestScriptFixtureListEnumerator;
    
    //  Add a FhirTestScriptFixture to the end of the list.
    function Append : TFhirTestScriptFixture;
    
    // Add an already existing FhirTestScriptFixture to the end of the list.
    function AddItem(value : TFhirTestScriptFixture) : TFhirTestScriptFixture; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestScriptFixture) : Integer;
    
    // Insert FhirTestScriptFixture before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestScriptFixture;
    
    // Insert an existing FhirTestScriptFixture before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestScriptFixture);
    
    // Get the iIndexth FhirTestScriptFixture. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestScriptFixture);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTestScriptFixture;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirTestScriptFixtures[index : Integer] : TFhirTestScriptFixture read GetItemN write SetItemN; default;
  End;

  // Variable is set based either on element value in response body or on header field value in the response headers.
  TFhirTestScriptVariable = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FDefaultValue : TFhirString;
    FDescription : TFhirString;
    FExpression : TFhirString;
    FHeaderField : TFhirString;
    FHint : TFhirString;
    FPath : TFhirString;
    FSourceId : TFhirId;
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetDefaultValue(value : TFhirString);
    function GetDefaultValueST : String;
    procedure SetDefaultValueST(value : String);
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetExpression(value : TFhirString);
    function GetExpressionST : String;
    procedure SetExpressionST(value : String);
    procedure SetHeaderField(value : TFhirString);
    function GetHeaderFieldST : String;
    procedure SetHeaderFieldST(value : String);
    procedure SetHint(value : TFhirString);
    function GetHintST : String;
    procedure SetHintST(value : String);
    procedure SetPath(value : TFhirString);
    function GetPathST : String;
    procedure SetPathST(value : String);
    procedure SetSourceId(value : TFhirId);
    function GetSourceIdST : String;
    procedure SetSourceIdST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestScriptVariable; overload;
    function Clone : TFhirTestScriptVariable; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Descriptive name for this variable.
    property name : String read GetNameST write SetNameST;
    // Descriptive name for this variable.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A default, hard-coded, or user-defined value for this variable.
    property defaultValue : String read GetDefaultValueST write SetDefaultValueST;
    // A default, hard-coded, or user-defined value for this variable.
    property defaultValueElement : TFhirString read FDefaultValue write SetDefaultValue;

    // Typed access to A free text natural language description of the variable and its purpose.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A free text natural language description of the variable and its purpose.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to The FHIRPath expression to evaluate against the fixture body. When variables are defined, only one of either expression, headerField or path must be specified.
    property expression : String read GetExpressionST write SetExpressionST;
    // The FHIRPath expression to evaluate against the fixture body. When variables are defined, only one of either expression, headerField or path must be specified.
    property expressionElement : TFhirString read FExpression write SetExpression;

    // Typed access to Will be used to grab the HTTP header field value from the headers that sourceId is pointing to.
    property headerField : String read GetHeaderFieldST write SetHeaderFieldST;
    // Will be used to grab the HTTP header field value from the headers that sourceId is pointing to.
    property headerFieldElement : TFhirString read FHeaderField write SetHeaderField;

    // Typed access to Displayable text string with hint help information to the user when entering a default value.
    property hint : String read GetHintST write SetHintST;
    // Displayable text string with hint help information to the user when entering a default value.
    property hintElement : TFhirString read FHint write SetHint;

    // Typed access to XPath or JSONPath to evaluate against the fixture body.  When variables are defined, only one of either expression, headerField or path must be specified.
    property path : String read GetPathST write SetPathST;
    // XPath or JSONPath to evaluate against the fixture body.  When variables are defined, only one of either expression, headerField or path must be specified.
    property pathElement : TFhirString read FPath write SetPath;

    // Typed access to Fixture to evaluate the XPath/JSONPath expression or the headerField  against within this variable.
    property sourceId : String read GetSourceIdST write SetSourceIdST;
    // Fixture to evaluate the XPath/JSONPath expression or the headerField  against within this variable.
    property sourceIdElement : TFhirId read FSourceId write SetSourceId;

  end;

  TFhirTestScriptVariableListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestScriptVariableList;
    function GetCurrent : TFhirTestScriptVariable;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirTestScriptVariableList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestScriptVariable read GetCurrent;
  end;

  TFhirTestScriptVariableList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirTestScriptVariable;
    procedure SetItemN(index : Integer; value : TFhirTestScriptVariable);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirTestScriptVariableList; overload;
    function Clone : TFhirTestScriptVariableList; overload;
    function GetEnumerator : TFhirTestScriptVariableListEnumerator;
    
    //  Add a FhirTestScriptVariable to the end of the list.
    function Append : TFhirTestScriptVariable;
    
    // Add an already existing FhirTestScriptVariable to the end of the list.
    function AddItem(value : TFhirTestScriptVariable) : TFhirTestScriptVariable; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestScriptVariable) : Integer;
    
    // Insert FhirTestScriptVariable before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestScriptVariable;
    
    // Insert an existing FhirTestScriptVariable before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestScriptVariable);
    
    // Get the iIndexth FhirTestScriptVariable. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestScriptVariable);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTestScriptVariable;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirTestScriptVariables[index : Integer] : TFhirTestScriptVariable read GetItemN write SetItemN; default;
  End;

  // A series of required setup operations before tests are executed.
  TFhirTestScriptSetup = class (TFhirBackboneElement)
  protected
    FactionList : TFhirTestScriptSetupActionList;
    function GetActionList : TFhirTestScriptSetupActionList;
    function GetHasActionList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestScriptSetup; overload;
    function Clone : TFhirTestScriptSetup; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Action would contain either an operation or an assertion.
    property actionList : TFhirTestScriptSetupActionList read GetActionList;
    property hasActionList : boolean read GetHasActionList;

  end;

  TFhirTestScriptSetupListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestScriptSetupList;
    function GetCurrent : TFhirTestScriptSetup;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirTestScriptSetupList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestScriptSetup read GetCurrent;
  end;

  TFhirTestScriptSetupList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirTestScriptSetup;
    procedure SetItemN(index : Integer; value : TFhirTestScriptSetup);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirTestScriptSetupList; overload;
    function Clone : TFhirTestScriptSetupList; overload;
    function GetEnumerator : TFhirTestScriptSetupListEnumerator;
    
    //  Add a FhirTestScriptSetup to the end of the list.
    function Append : TFhirTestScriptSetup;
    
    // Add an already existing FhirTestScriptSetup to the end of the list.
    function AddItem(value : TFhirTestScriptSetup) : TFhirTestScriptSetup; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestScriptSetup) : Integer;
    
    // Insert FhirTestScriptSetup before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestScriptSetup;
    
    // Insert an existing FhirTestScriptSetup before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestScriptSetup);
    
    // Get the iIndexth FhirTestScriptSetup. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestScriptSetup);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTestScriptSetup;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirTestScriptSetups[index : Integer] : TFhirTestScriptSetup read GetItemN write SetItemN; default;
  End;

  // Action would contain either an operation or an assertion.
  TFhirTestScriptSetupAction = class (TFhirBackboneElement)
  protected
    FOperation : TFhirTestScriptSetupActionOperation;
    FAssert : TFhirTestScriptSetupActionAssert;
    procedure SetOperation(value : TFhirTestScriptSetupActionOperation);
    procedure SetAssert(value : TFhirTestScriptSetupActionAssert);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestScriptSetupAction; overload;
    function Clone : TFhirTestScriptSetupAction; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The operation to perform. (defined for API consistency)
    property operation : TFhirTestScriptSetupActionOperation read FOperation write SetOperation;
    // The operation to perform.
    property operationElement : TFhirTestScriptSetupActionOperation read FOperation write SetOperation;

    // Typed access to Evaluates the results of previous operations to determine if the server under test behaves appropriately. (defined for API consistency)
    property assert : TFhirTestScriptSetupActionAssert read FAssert write SetAssert;
    // Evaluates the results of previous operations to determine if the server under test behaves appropriately.
    property assertElement : TFhirTestScriptSetupActionAssert read FAssert write SetAssert;

  end;

  TFhirTestScriptSetupActionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestScriptSetupActionList;
    function GetCurrent : TFhirTestScriptSetupAction;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirTestScriptSetupActionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestScriptSetupAction read GetCurrent;
  end;

  TFhirTestScriptSetupActionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirTestScriptSetupAction;
    procedure SetItemN(index : Integer; value : TFhirTestScriptSetupAction);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirTestScriptSetupActionList; overload;
    function Clone : TFhirTestScriptSetupActionList; overload;
    function GetEnumerator : TFhirTestScriptSetupActionListEnumerator;
    
    //  Add a FhirTestScriptSetupAction to the end of the list.
    function Append : TFhirTestScriptSetupAction;
    
    // Add an already existing FhirTestScriptSetupAction to the end of the list.
    function AddItem(value : TFhirTestScriptSetupAction) : TFhirTestScriptSetupAction; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestScriptSetupAction) : Integer;
    
    // Insert FhirTestScriptSetupAction before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestScriptSetupAction;
    
    // Insert an existing FhirTestScriptSetupAction before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestScriptSetupAction);
    
    // Get the iIndexth FhirTestScriptSetupAction. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestScriptSetupAction);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTestScriptSetupAction;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirTestScriptSetupActions[index : Integer] : TFhirTestScriptSetupAction read GetItemN write SetItemN; default;
  End;

  // The operation to perform.
  TFhirTestScriptSetupActionOperation = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCoding;
    FResource : TFhirEnum;
    FLabel_ : TFhirString;
    FDescription : TFhirString;
    FAccept : TFhirCode;
    FContentType : TFhirCode;
    FDestination : TFhirInteger;
    FEncodeRequestUrl : TFhirBoolean;
    FMethod : TFhirEnum;
    FOrigin : TFhirInteger;
    FParams : TFhirString;
    FrequestHeaderList : TFhirTestScriptSetupActionOperationRequestHeaderList;
    FRequestId : TFhirId;
    FResponseId : TFhirId;
    FSourceId : TFhirId;
    FTargetId : TFhirId;
    FUrl : TFhirString;
    procedure SetType_(value : TFhirCoding);
    procedure SetResource(value : TFhirEnum);
    function GetResourceST : TFhirFHIRDefinedTypeEnum;
    procedure SetResourceST(value : TFhirFHIRDefinedTypeEnum);
    procedure SetLabel_(value : TFhirString);
    function GetLabel_ST : String;
    procedure SetLabel_ST(value : String);
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetAccept(value : TFhirCode);
    function GetAcceptST : String;
    procedure SetAcceptST(value : String);
    procedure SetContentType(value : TFhirCode);
    function GetContentTypeST : String;
    procedure SetContentTypeST(value : String);
    procedure SetDestination(value : TFhirInteger);
    function GetDestinationST : String;
    procedure SetDestinationST(value : String);
    procedure SetEncodeRequestUrl(value : TFhirBoolean);
    function GetEncodeRequestUrlST : Boolean;
    procedure SetEncodeRequestUrlST(value : Boolean);
    procedure SetMethod(value : TFhirEnum);
    function GetMethodST : TFhirTestScriptRequestMethodCodeEnum;
    procedure SetMethodST(value : TFhirTestScriptRequestMethodCodeEnum);
    procedure SetOrigin(value : TFhirInteger);
    function GetOriginST : String;
    procedure SetOriginST(value : String);
    procedure SetParams(value : TFhirString);
    function GetParamsST : String;
    procedure SetParamsST(value : String);
    function GetRequestHeaderList : TFhirTestScriptSetupActionOperationRequestHeaderList;
    function GetHasRequestHeaderList : Boolean;
    procedure SetRequestId(value : TFhirId);
    function GetRequestIdST : String;
    procedure SetRequestIdST(value : String);
    procedure SetResponseId(value : TFhirId);
    function GetResponseIdST : String;
    procedure SetResponseIdST(value : String);
    procedure SetSourceId(value : TFhirId);
    function GetSourceIdST : String;
    procedure SetSourceIdST(value : String);
    procedure SetTargetId(value : TFhirId);
    function GetTargetIdST : String;
    procedure SetTargetIdST(value : String);
    procedure SetUrl(value : TFhirString);
    function GetUrlST : String;
    procedure SetUrlST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestScriptSetupActionOperation; overload;
    function Clone : TFhirTestScriptSetupActionOperation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Server interaction or operation type. (defined for API consistency)
    property type_ : TFhirCoding read FType_ write SetType_;
    // Server interaction or operation type.
    property type_Element : TFhirCoding read FType_ write SetType_;

    // The type of the resource.  See http://build.fhir.org/resourcelist.html.
    property resource : TFhirFHIRDefinedTypeEnum read GetResourceST write SetResourceST;
    property resourceElement : TFhirEnum read FResource write SetResource;

    // Typed access to The label would be used for tracking/logging purposes by test engines.
    property label_ : String read GetLabel_ST write SetLabel_ST;
    // The label would be used for tracking/logging purposes by test engines.
    property label_Element : TFhirString read FLabel_ write SetLabel_;

    // Typed access to The description would be used by test engines for tracking and reporting purposes.
    property description : String read GetDescriptionST write SetDescriptionST;
    // The description would be used by test engines for tracking and reporting purposes.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to The mime-type to use for RESTful operation in the 'Accept' header.
    property accept : String read GetAcceptST write SetAcceptST;
    // The mime-type to use for RESTful operation in the 'Accept' header.
    property acceptElement : TFhirCode read FAccept write SetAccept;

    // Typed access to The mime-type to use for RESTful operation in the 'Content-Type' header.
    property contentType : String read GetContentTypeST write SetContentTypeST;
    // The mime-type to use for RESTful operation in the 'Content-Type' header.
    property contentTypeElement : TFhirCode read FContentType write SetContentType;

    // Typed access to The server where the request message is destined for.  Must be one of the server numbers listed in TestScript.destination section.
    property destination : String read GetDestinationST write SetDestinationST;
    // The server where the request message is destined for.  Must be one of the server numbers listed in TestScript.destination section.
    property destinationElement : TFhirInteger read FDestination write SetDestination;

    // Typed access to Whether or not to implicitly send the request url in encoded format. The default is true to match the standard RESTful client behavior. Set to false when communicating with a server that does not support encoded url paths.
    property encodeRequestUrl : Boolean read GetEncodeRequestUrlST write SetEncodeRequestUrlST;
    // Whether or not to implicitly send the request url in encoded format. The default is true to match the standard RESTful client behavior. Set to false when communicating with a server that does not support encoded url paths.
    property encodeRequestUrlElement : TFhirBoolean read FEncodeRequestUrl write SetEncodeRequestUrl;

    // The HTTP method the test engine MUST use for this operation regardless of any other operation details.
    property method : TFhirTestScriptRequestMethodCodeEnum read GetMethodST write SetMethodST;
    property methodElement : TFhirEnum read FMethod write SetMethod;

    // Typed access to The server where the request message originates from.  Must be one of the server numbers listed in TestScript.origin section.
    property origin : String read GetOriginST write SetOriginST;
    // The server where the request message originates from.  Must be one of the server numbers listed in TestScript.origin section.
    property originElement : TFhirInteger read FOrigin write SetOrigin;

    // Typed access to Path plus parameters after [type].  Used to set parts of the request URL explicitly.
    property params : String read GetParamsST write SetParamsST;
    // Path plus parameters after [type].  Used to set parts of the request URL explicitly.
    property paramsElement : TFhirString read FParams write SetParams;

    // Header elements would be used to set HTTP headers.
    property requestHeaderList : TFhirTestScriptSetupActionOperationRequestHeaderList read GetRequestHeaderList;
    property hasRequestHeaderList : boolean read GetHasRequestHeaderList;

    // Typed access to The fixture id (maybe new) to map to the request.
    property requestId : String read GetRequestIdST write SetRequestIdST;
    // The fixture id (maybe new) to map to the request.
    property requestIdElement : TFhirId read FRequestId write SetRequestId;

    // Typed access to The fixture id (maybe new) to map to the response.
    property responseId : String read GetResponseIdST write SetResponseIdST;
    // The fixture id (maybe new) to map to the response.
    property responseIdElement : TFhirId read FResponseId write SetResponseId;

    // Typed access to The id of the fixture used as the body of a PUT or POST request.
    property sourceId : String read GetSourceIdST write SetSourceIdST;
    // The id of the fixture used as the body of a PUT or POST request.
    property sourceIdElement : TFhirId read FSourceId write SetSourceId;

    // Typed access to Id of fixture used for extracting the [id],  [type], and [vid] for GET requests.
    property targetId : String read GetTargetIdST write SetTargetIdST;
    // Id of fixture used for extracting the [id],  [type], and [vid] for GET requests.
    property targetIdElement : TFhirId read FTargetId write SetTargetId;

    // Typed access to Complete request URL.
    property url : String read GetUrlST write SetUrlST;
    // Complete request URL.
    property urlElement : TFhirString read FUrl write SetUrl;

  end;

  TFhirTestScriptSetupActionOperationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestScriptSetupActionOperationList;
    function GetCurrent : TFhirTestScriptSetupActionOperation;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirTestScriptSetupActionOperationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestScriptSetupActionOperation read GetCurrent;
  end;

  TFhirTestScriptSetupActionOperationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirTestScriptSetupActionOperation;
    procedure SetItemN(index : Integer; value : TFhirTestScriptSetupActionOperation);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirTestScriptSetupActionOperationList; overload;
    function Clone : TFhirTestScriptSetupActionOperationList; overload;
    function GetEnumerator : TFhirTestScriptSetupActionOperationListEnumerator;
    
    //  Add a FhirTestScriptSetupActionOperation to the end of the list.
    function Append : TFhirTestScriptSetupActionOperation;
    
    // Add an already existing FhirTestScriptSetupActionOperation to the end of the list.
    function AddItem(value : TFhirTestScriptSetupActionOperation) : TFhirTestScriptSetupActionOperation; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestScriptSetupActionOperation) : Integer;
    
    // Insert FhirTestScriptSetupActionOperation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestScriptSetupActionOperation;
    
    // Insert an existing FhirTestScriptSetupActionOperation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestScriptSetupActionOperation);
    
    // Get the iIndexth FhirTestScriptSetupActionOperation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestScriptSetupActionOperation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTestScriptSetupActionOperation;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirTestScriptSetupActionOperations[index : Integer] : TFhirTestScriptSetupActionOperation read GetItemN write SetItemN; default;
  End;

  // Header elements would be used to set HTTP headers.
  TFhirTestScriptSetupActionOperationRequestHeader = class (TFhirBackboneElement)
  protected
    FField : TFhirString;
    FValue : TFhirString;
    procedure SetField(value : TFhirString);
    function GetFieldST : String;
    procedure SetFieldST(value : String);
    procedure SetValue(value : TFhirString);
    function GetValueST : String;
    procedure SetValueST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestScriptSetupActionOperationRequestHeader; overload;
    function Clone : TFhirTestScriptSetupActionOperationRequestHeader; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The HTTP header field e.g. "Accept".
    property field : String read GetFieldST write SetFieldST;
    // The HTTP header field e.g. "Accept".
    property fieldElement : TFhirString read FField write SetField;

    // Typed access to The value of the header e.g. "application/fhir+xml".
    property value : String read GetValueST write SetValueST;
    // The value of the header e.g. "application/fhir+xml".
    property valueElement : TFhirString read FValue write SetValue;

  end;

  TFhirTestScriptSetupActionOperationRequestHeaderListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestScriptSetupActionOperationRequestHeaderList;
    function GetCurrent : TFhirTestScriptSetupActionOperationRequestHeader;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirTestScriptSetupActionOperationRequestHeaderList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestScriptSetupActionOperationRequestHeader read GetCurrent;
  end;

  TFhirTestScriptSetupActionOperationRequestHeaderList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirTestScriptSetupActionOperationRequestHeader;
    procedure SetItemN(index : Integer; value : TFhirTestScriptSetupActionOperationRequestHeader);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirTestScriptSetupActionOperationRequestHeaderList; overload;
    function Clone : TFhirTestScriptSetupActionOperationRequestHeaderList; overload;
    function GetEnumerator : TFhirTestScriptSetupActionOperationRequestHeaderListEnumerator;
    
    //  Add a FhirTestScriptSetupActionOperationRequestHeader to the end of the list.
    function Append : TFhirTestScriptSetupActionOperationRequestHeader;
    
    // Add an already existing FhirTestScriptSetupActionOperationRequestHeader to the end of the list.
    function AddItem(value : TFhirTestScriptSetupActionOperationRequestHeader) : TFhirTestScriptSetupActionOperationRequestHeader; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestScriptSetupActionOperationRequestHeader) : Integer;
    
    // Insert FhirTestScriptSetupActionOperationRequestHeader before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestScriptSetupActionOperationRequestHeader;
    
    // Insert an existing FhirTestScriptSetupActionOperationRequestHeader before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestScriptSetupActionOperationRequestHeader);
    
    // Get the iIndexth FhirTestScriptSetupActionOperationRequestHeader. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestScriptSetupActionOperationRequestHeader);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTestScriptSetupActionOperationRequestHeader;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirTestScriptSetupActionOperationRequestHeaders[index : Integer] : TFhirTestScriptSetupActionOperationRequestHeader read GetItemN write SetItemN; default;
  End;

  // Evaluates the results of previous operations to determine if the server under test behaves appropriately.
  TFhirTestScriptSetupActionAssert = class (TFhirBackboneElement)
  protected
    FLabel_ : TFhirString;
    FDescription : TFhirString;
    FDirection : TFhirEnum;
    FCompareToSourceId : TFhirString;
    FCompareToSourceExpression : TFhirString;
    FCompareToSourcePath : TFhirString;
    FContentType : TFhirCode;
    FExpression : TFhirString;
    FHeaderField : TFhirString;
    FMinimumId : TFhirString;
    FNavigationLinks : TFhirBoolean;
    FOperator : TFhirEnum;
    FPath : TFhirString;
    FRequestMethod : TFhirEnum;
    FRequestURL : TFhirString;
    FResource : TFhirEnum;
    FResponse : TFhirEnum;
    FResponseCode : TFhirString;
    FSourceId : TFhirId;
    FValidateProfileId : TFhirId;
    FValue : TFhirString;
    FWarningOnly : TFhirBoolean;
    procedure SetLabel_(value : TFhirString);
    function GetLabel_ST : String;
    procedure SetLabel_ST(value : String);
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetDirection(value : TFhirEnum);
    function GetDirectionST : TFhirAssertionDirectionTypeEnum;
    procedure SetDirectionST(value : TFhirAssertionDirectionTypeEnum);
    procedure SetCompareToSourceId(value : TFhirString);
    function GetCompareToSourceIdST : String;
    procedure SetCompareToSourceIdST(value : String);
    procedure SetCompareToSourceExpression(value : TFhirString);
    function GetCompareToSourceExpressionST : String;
    procedure SetCompareToSourceExpressionST(value : String);
    procedure SetCompareToSourcePath(value : TFhirString);
    function GetCompareToSourcePathST : String;
    procedure SetCompareToSourcePathST(value : String);
    procedure SetContentType(value : TFhirCode);
    function GetContentTypeST : String;
    procedure SetContentTypeST(value : String);
    procedure SetExpression(value : TFhirString);
    function GetExpressionST : String;
    procedure SetExpressionST(value : String);
    procedure SetHeaderField(value : TFhirString);
    function GetHeaderFieldST : String;
    procedure SetHeaderFieldST(value : String);
    procedure SetMinimumId(value : TFhirString);
    function GetMinimumIdST : String;
    procedure SetMinimumIdST(value : String);
    procedure SetNavigationLinks(value : TFhirBoolean);
    function GetNavigationLinksST : Boolean;
    procedure SetNavigationLinksST(value : Boolean);
    procedure SetOperator(value : TFhirEnum);
    function GetOperatorST : TFhirAssertionOperatorTypeEnum;
    procedure SetOperatorST(value : TFhirAssertionOperatorTypeEnum);
    procedure SetPath(value : TFhirString);
    function GetPathST : String;
    procedure SetPathST(value : String);
    procedure SetRequestMethod(value : TFhirEnum);
    function GetRequestMethodST : TFhirTestScriptRequestMethodCodeEnum;
    procedure SetRequestMethodST(value : TFhirTestScriptRequestMethodCodeEnum);
    procedure SetRequestURL(value : TFhirString);
    function GetRequestURLST : String;
    procedure SetRequestURLST(value : String);
    procedure SetResource(value : TFhirEnum);
    function GetResourceST : TFhirFHIRDefinedTypeEnum;
    procedure SetResourceST(value : TFhirFHIRDefinedTypeEnum);
    procedure SetResponse(value : TFhirEnum);
    function GetResponseST : TFhirAssertionResponseTypesEnum;
    procedure SetResponseST(value : TFhirAssertionResponseTypesEnum);
    procedure SetResponseCode(value : TFhirString);
    function GetResponseCodeST : String;
    procedure SetResponseCodeST(value : String);
    procedure SetSourceId(value : TFhirId);
    function GetSourceIdST : String;
    procedure SetSourceIdST(value : String);
    procedure SetValidateProfileId(value : TFhirId);
    function GetValidateProfileIdST : String;
    procedure SetValidateProfileIdST(value : String);
    procedure SetValue(value : TFhirString);
    function GetValueST : String;
    procedure SetValueST(value : String);
    procedure SetWarningOnly(value : TFhirBoolean);
    function GetWarningOnlyST : Boolean;
    procedure SetWarningOnlyST(value : Boolean);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestScriptSetupActionAssert; overload;
    function Clone : TFhirTestScriptSetupActionAssert; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The label would be used for tracking/logging purposes by test engines.
    property label_ : String read GetLabel_ST write SetLabel_ST;
    // The label would be used for tracking/logging purposes by test engines.
    property label_Element : TFhirString read FLabel_ write SetLabel_;

    // Typed access to The description would be used by test engines for tracking and reporting purposes.
    property description : String read GetDescriptionST write SetDescriptionST;
    // The description would be used by test engines for tracking and reporting purposes.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // The direction to use for the assertion.
    property direction : TFhirAssertionDirectionTypeEnum read GetDirectionST write SetDirectionST;
    property directionElement : TFhirEnum read FDirection write SetDirection;

    // Typed access to Id of the source fixture used as the contents to be evaluated by either the "source/expression" or "sourceId/path" definition.
    property compareToSourceId : String read GetCompareToSourceIdST write SetCompareToSourceIdST;
    // Id of the source fixture used as the contents to be evaluated by either the "source/expression" or "sourceId/path" definition.
    property compareToSourceIdElement : TFhirString read FCompareToSourceId write SetCompareToSourceId;

    // Typed access to The FHIRPath expression to evaluate against the source fixture. When compareToSourceId is defined, either compareToSourceExpression or compareToSourcePath must be defined, but not both.
    property compareToSourceExpression : String read GetCompareToSourceExpressionST write SetCompareToSourceExpressionST;
    // The FHIRPath expression to evaluate against the source fixture. When compareToSourceId is defined, either compareToSourceExpression or compareToSourcePath must be defined, but not both.
    property compareToSourceExpressionElement : TFhirString read FCompareToSourceExpression write SetCompareToSourceExpression;

    // Typed access to XPath or JSONPath expression to evaluate against the source fixture. When compareToSourceId is defined, either compareToSourceExpression or compareToSourcePath must be defined, but not both.
    property compareToSourcePath : String read GetCompareToSourcePathST write SetCompareToSourcePathST;
    // XPath or JSONPath expression to evaluate against the source fixture. When compareToSourceId is defined, either compareToSourceExpression or compareToSourcePath must be defined, but not both.
    property compareToSourcePathElement : TFhirString read FCompareToSourcePath write SetCompareToSourcePath;

    // Typed access to The mime-type contents to compare against the request or response message 'Content-Type' header.
    property contentType : String read GetContentTypeST write SetContentTypeST;
    // The mime-type contents to compare against the request or response message 'Content-Type' header.
    property contentTypeElement : TFhirCode read FContentType write SetContentType;

    // Typed access to The FHIRPath expression to be evaluated against the request or response message contents - HTTP headers and payload.
    property expression : String read GetExpressionST write SetExpressionST;
    // The FHIRPath expression to be evaluated against the request or response message contents - HTTP headers and payload.
    property expressionElement : TFhirString read FExpression write SetExpression;

    // Typed access to The HTTP header field name e.g. 'Location'.
    property headerField : String read GetHeaderFieldST write SetHeaderFieldST;
    // The HTTP header field name e.g. 'Location'.
    property headerFieldElement : TFhirString read FHeaderField write SetHeaderField;

    // Typed access to The ID of a fixture.  Asserts that the response contains at a minimum the fixture specified by minimumId.
    property minimumId : String read GetMinimumIdST write SetMinimumIdST;
    // The ID of a fixture.  Asserts that the response contains at a minimum the fixture specified by minimumId.
    property minimumIdElement : TFhirString read FMinimumId write SetMinimumId;

    // Typed access to Whether or not the test execution performs validation on the bundle navigation links.
    property navigationLinks : Boolean read GetNavigationLinksST write SetNavigationLinksST;
    // Whether or not the test execution performs validation on the bundle navigation links.
    property navigationLinksElement : TFhirBoolean read FNavigationLinks write SetNavigationLinks;

    // The operator type defines the conditional behavior of the assert. If not defined, the default is equals.
    property operator : TFhirAssertionOperatorTypeEnum read GetOperatorST write SetOperatorST;
    property operatorElement : TFhirEnum read FOperator write SetOperator;

    // Typed access to The XPath or JSONPath expression to be evaluated against the fixture representing the response received from server.
    property path : String read GetPathST write SetPathST;
    // The XPath or JSONPath expression to be evaluated against the fixture representing the response received from server.
    property pathElement : TFhirString read FPath write SetPath;

    // The request method or HTTP operation code to compare against that used by the client system under test.
    property requestMethod : TFhirTestScriptRequestMethodCodeEnum read GetRequestMethodST write SetRequestMethodST;
    property requestMethodElement : TFhirEnum read FRequestMethod write SetRequestMethod;

    // Typed access to The value to use in a comparison against the request URL path string.
    property requestURL : String read GetRequestURLST write SetRequestURLST;
    // The value to use in a comparison against the request URL path string.
    property requestURLElement : TFhirString read FRequestURL write SetRequestURL;

    // The type of the resource.  See http://build.fhir.org/resourcelist.html.
    property resource : TFhirFHIRDefinedTypeEnum read GetResourceST write SetResourceST;
    property resourceElement : TFhirEnum read FResource write SetResource;

    // okay | created | noContent | notModified | bad | forbidden | notFound | methodNotAllowed | conflict | gone | preconditionFailed | unprocessable.
    property response : TFhirAssertionResponseTypesEnum read GetResponseST write SetResponseST;
    property responseElement : TFhirEnum read FResponse write SetResponse;

    // Typed access to The value of the HTTP response code to be tested.
    property responseCode : String read GetResponseCodeST write SetResponseCodeST;
    // The value of the HTTP response code to be tested.
    property responseCodeElement : TFhirString read FResponseCode write SetResponseCode;

    // Typed access to Fixture to evaluate the XPath/JSONPath expression or the headerField  against.
    property sourceId : String read GetSourceIdST write SetSourceIdST;
    // Fixture to evaluate the XPath/JSONPath expression or the headerField  against.
    property sourceIdElement : TFhirId read FSourceId write SetSourceId;

    // Typed access to The ID of the Profile to validate against.
    property validateProfileId : String read GetValidateProfileIdST write SetValidateProfileIdST;
    // The ID of the Profile to validate against.
    property validateProfileIdElement : TFhirId read FValidateProfileId write SetValidateProfileId;

    // Typed access to The value to compare to.
    property value : String read GetValueST write SetValueST;
    // The value to compare to.
    property valueElement : TFhirString read FValue write SetValue;

    // Typed access to Whether or not the test execution will produce a warning only on error for this assert.
    property warningOnly : Boolean read GetWarningOnlyST write SetWarningOnlyST;
    // Whether or not the test execution will produce a warning only on error for this assert.
    property warningOnlyElement : TFhirBoolean read FWarningOnly write SetWarningOnly;

  end;

  TFhirTestScriptSetupActionAssertListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestScriptSetupActionAssertList;
    function GetCurrent : TFhirTestScriptSetupActionAssert;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirTestScriptSetupActionAssertList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestScriptSetupActionAssert read GetCurrent;
  end;

  TFhirTestScriptSetupActionAssertList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirTestScriptSetupActionAssert;
    procedure SetItemN(index : Integer; value : TFhirTestScriptSetupActionAssert);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirTestScriptSetupActionAssertList; overload;
    function Clone : TFhirTestScriptSetupActionAssertList; overload;
    function GetEnumerator : TFhirTestScriptSetupActionAssertListEnumerator;
    
    //  Add a FhirTestScriptSetupActionAssert to the end of the list.
    function Append : TFhirTestScriptSetupActionAssert;
    
    // Add an already existing FhirTestScriptSetupActionAssert to the end of the list.
    function AddItem(value : TFhirTestScriptSetupActionAssert) : TFhirTestScriptSetupActionAssert; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestScriptSetupActionAssert) : Integer;
    
    // Insert FhirTestScriptSetupActionAssert before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestScriptSetupActionAssert;
    
    // Insert an existing FhirTestScriptSetupActionAssert before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestScriptSetupActionAssert);
    
    // Get the iIndexth FhirTestScriptSetupActionAssert. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestScriptSetupActionAssert);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTestScriptSetupActionAssert;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirTestScriptSetupActionAsserts[index : Integer] : TFhirTestScriptSetupActionAssert read GetItemN write SetItemN; default;
  End;

  // A test in this script.
  TFhirTestScriptTest = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FDescription : TFhirString;
    FactionList : TFhirTestScriptTestActionList;
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetActionList : TFhirTestScriptTestActionList;
    function GetHasActionList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestScriptTest; overload;
    function Clone : TFhirTestScriptTest; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The name of this test used for tracking/logging purposes by test engines.
    property name : String read GetNameST write SetNameST;
    // The name of this test used for tracking/logging purposes by test engines.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A short description of the test used by test engines for tracking and reporting purposes.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A short description of the test used by test engines for tracking and reporting purposes.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Action would contain either an operation or an assertion.
    property actionList : TFhirTestScriptTestActionList read GetActionList;
    property hasActionList : boolean read GetHasActionList;

  end;

  TFhirTestScriptTestListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestScriptTestList;
    function GetCurrent : TFhirTestScriptTest;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirTestScriptTestList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestScriptTest read GetCurrent;
  end;

  TFhirTestScriptTestList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirTestScriptTest;
    procedure SetItemN(index : Integer; value : TFhirTestScriptTest);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirTestScriptTestList; overload;
    function Clone : TFhirTestScriptTestList; overload;
    function GetEnumerator : TFhirTestScriptTestListEnumerator;
    
    //  Add a FhirTestScriptTest to the end of the list.
    function Append : TFhirTestScriptTest;
    
    // Add an already existing FhirTestScriptTest to the end of the list.
    function AddItem(value : TFhirTestScriptTest) : TFhirTestScriptTest; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestScriptTest) : Integer;
    
    // Insert FhirTestScriptTest before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestScriptTest;
    
    // Insert an existing FhirTestScriptTest before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestScriptTest);
    
    // Get the iIndexth FhirTestScriptTest. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestScriptTest);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTestScriptTest;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirTestScriptTests[index : Integer] : TFhirTestScriptTest read GetItemN write SetItemN; default;
  End;

  // Action would contain either an operation or an assertion.
  TFhirTestScriptTestAction = class (TFhirBackboneElement)
  protected
    FOperation : TFhirTestScriptSetupActionOperation;
    FAssert : TFhirTestScriptSetupActionAssert;
    procedure SetOperation(value : TFhirTestScriptSetupActionOperation);
    procedure SetAssert(value : TFhirTestScriptSetupActionAssert);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestScriptTestAction; overload;
    function Clone : TFhirTestScriptTestAction; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An operation would involve a REST request to a server. (defined for API consistency)
    property operation : TFhirTestScriptSetupActionOperation read FOperation write SetOperation;
    // An operation would involve a REST request to a server.
    property operationElement : TFhirTestScriptSetupActionOperation read FOperation write SetOperation;

    // Typed access to Evaluates the results of previous operations to determine if the server under test behaves appropriately. (defined for API consistency)
    property assert : TFhirTestScriptSetupActionAssert read FAssert write SetAssert;
    // Evaluates the results of previous operations to determine if the server under test behaves appropriately.
    property assertElement : TFhirTestScriptSetupActionAssert read FAssert write SetAssert;

  end;

  TFhirTestScriptTestActionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestScriptTestActionList;
    function GetCurrent : TFhirTestScriptTestAction;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirTestScriptTestActionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestScriptTestAction read GetCurrent;
  end;

  TFhirTestScriptTestActionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirTestScriptTestAction;
    procedure SetItemN(index : Integer; value : TFhirTestScriptTestAction);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirTestScriptTestActionList; overload;
    function Clone : TFhirTestScriptTestActionList; overload;
    function GetEnumerator : TFhirTestScriptTestActionListEnumerator;
    
    //  Add a FhirTestScriptTestAction to the end of the list.
    function Append : TFhirTestScriptTestAction;
    
    // Add an already existing FhirTestScriptTestAction to the end of the list.
    function AddItem(value : TFhirTestScriptTestAction) : TFhirTestScriptTestAction; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestScriptTestAction) : Integer;
    
    // Insert FhirTestScriptTestAction before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestScriptTestAction;
    
    // Insert an existing FhirTestScriptTestAction before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestScriptTestAction);
    
    // Get the iIndexth FhirTestScriptTestAction. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestScriptTestAction);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTestScriptTestAction;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirTestScriptTestActions[index : Integer] : TFhirTestScriptTestAction read GetItemN write SetItemN; default;
  End;

  // A series of operations required to clean up after all the tests are executed (successfully or otherwise).
  TFhirTestScriptTeardown = class (TFhirBackboneElement)
  protected
    FactionList : TFhirTestScriptTeardownActionList;
    function GetActionList : TFhirTestScriptTeardownActionList;
    function GetHasActionList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestScriptTeardown; overload;
    function Clone : TFhirTestScriptTeardown; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The teardown action will only contain an operation.
    property actionList : TFhirTestScriptTeardownActionList read GetActionList;
    property hasActionList : boolean read GetHasActionList;

  end;

  TFhirTestScriptTeardownListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestScriptTeardownList;
    function GetCurrent : TFhirTestScriptTeardown;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirTestScriptTeardownList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestScriptTeardown read GetCurrent;
  end;

  TFhirTestScriptTeardownList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirTestScriptTeardown;
    procedure SetItemN(index : Integer; value : TFhirTestScriptTeardown);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirTestScriptTeardownList; overload;
    function Clone : TFhirTestScriptTeardownList; overload;
    function GetEnumerator : TFhirTestScriptTeardownListEnumerator;
    
    //  Add a FhirTestScriptTeardown to the end of the list.
    function Append : TFhirTestScriptTeardown;
    
    // Add an already existing FhirTestScriptTeardown to the end of the list.
    function AddItem(value : TFhirTestScriptTeardown) : TFhirTestScriptTeardown; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestScriptTeardown) : Integer;
    
    // Insert FhirTestScriptTeardown before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestScriptTeardown;
    
    // Insert an existing FhirTestScriptTeardown before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestScriptTeardown);
    
    // Get the iIndexth FhirTestScriptTeardown. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestScriptTeardown);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTestScriptTeardown;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirTestScriptTeardowns[index : Integer] : TFhirTestScriptTeardown read GetItemN write SetItemN; default;
  End;

  // The teardown action will only contain an operation.
  TFhirTestScriptTeardownAction = class (TFhirBackboneElement)
  protected
    FOperation : TFhirTestScriptSetupActionOperation;
    procedure SetOperation(value : TFhirTestScriptSetupActionOperation);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestScriptTeardownAction; overload;
    function Clone : TFhirTestScriptTeardownAction; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An operation would involve a REST request to a server. (defined for API consistency)
    property operation : TFhirTestScriptSetupActionOperation read FOperation write SetOperation;
    // An operation would involve a REST request to a server.
    property operationElement : TFhirTestScriptSetupActionOperation read FOperation write SetOperation;

  end;

  TFhirTestScriptTeardownActionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestScriptTeardownActionList;
    function GetCurrent : TFhirTestScriptTeardownAction;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirTestScriptTeardownActionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestScriptTeardownAction read GetCurrent;
  end;

  TFhirTestScriptTeardownActionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirTestScriptTeardownAction;
    procedure SetItemN(index : Integer; value : TFhirTestScriptTeardownAction);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirTestScriptTeardownActionList; overload;
    function Clone : TFhirTestScriptTeardownActionList; overload;
    function GetEnumerator : TFhirTestScriptTeardownActionListEnumerator;
    
    //  Add a FhirTestScriptTeardownAction to the end of the list.
    function Append : TFhirTestScriptTeardownAction;
    
    // Add an already existing FhirTestScriptTeardownAction to the end of the list.
    function AddItem(value : TFhirTestScriptTeardownAction) : TFhirTestScriptTeardownAction; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestScriptTeardownAction) : Integer;
    
    // Insert FhirTestScriptTeardownAction before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestScriptTeardownAction;
    
    // Insert an existing FhirTestScriptTeardownAction before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestScriptTeardownAction);
    
    // Get the iIndexth FhirTestScriptTeardownAction. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestScriptTeardownAction);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTestScriptTeardownAction;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirTestScriptTeardownActions[index : Integer] : TFhirTestScriptTeardownAction read GetItemN write SetItemN; default;
  End;

  // A structured set of tests against a FHIR server or client implementation to determine compliance against the FHIR specification.
  TFhirTestScript = class (TFhirDomainResource)
  protected
    FUrl : TFhirUri;
    FIdentifier : TFhirIdentifier;
    FVersion : TFhirString;
    FName : TFhirString;
    FTitle : TFhirString;
    FStatus : TFhirEnum;
    FExperimental : TFhirBoolean;
    FDate : TFhirDateTime;
    FPublisher : TFhirString;
    FcontactList : TFhirContactDetailList;
    FDescription : TFhirMarkdown;
    FuseContextList : TFhirUsageContextList;
    FjurisdictionList : TFhirCodeableConceptList;
    FPurpose : TFhirMarkdown;
    FCopyright : TFhirMarkdown;
    ForiginList : TFhirTestScriptOriginList;
    FdestinationList : TFhirTestScriptDestinationList;
    FMetadata : TFhirTestScriptMetadata;
    FfixtureList : TFhirTestScriptFixtureList;
    FprofileList : TFhirReferenceList;
    FvariableList : TFhirTestScriptVariableList;
    FSetup : TFhirTestScriptSetup;
    FtestList : TFhirTestScriptTestList;
    FTeardown : TFhirTestScriptTeardown;
    procedure SetUrl(value : TFhirUri);
    function GetUrlST : String;
    procedure SetUrlST(value : String);
    procedure SetIdentifier(value : TFhirIdentifier);
    procedure SetVersion(value : TFhirString);
    function GetVersionST : String;
    procedure SetVersionST(value : String);
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetTitle(value : TFhirString);
    function GetTitleST : String;
    procedure SetTitleST(value : String);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirPublicationStatusEnum;
    procedure SetStatusST(value : TFhirPublicationStatusEnum);
    procedure SetExperimental(value : TFhirBoolean);
    function GetExperimentalST : Boolean;
    procedure SetExperimentalST(value : Boolean);
    procedure SetDate(value : TFhirDateTime);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    procedure SetPublisher(value : TFhirString);
    function GetPublisherST : String;
    procedure SetPublisherST(value : String);
    function GetContactList : TFhirContactDetailList;
    function GetHasContactList : Boolean;
    procedure SetDescription(value : TFhirMarkdown);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetUseContextList : TFhirUsageContextList;
    function GetHasUseContextList : Boolean;
    function GetJurisdictionList : TFhirCodeableConceptList;
    function GetHasJurisdictionList : Boolean;
    procedure SetPurpose(value : TFhirMarkdown);
    function GetPurposeST : String;
    procedure SetPurposeST(value : String);
    procedure SetCopyright(value : TFhirMarkdown);
    function GetCopyrightST : String;
    procedure SetCopyrightST(value : String);
    function GetOriginList : TFhirTestScriptOriginList;
    function GetHasOriginList : Boolean;
    function GetDestinationList : TFhirTestScriptDestinationList;
    function GetHasDestinationList : Boolean;
    procedure SetMetadata(value : TFhirTestScriptMetadata);
    function GetFixtureList : TFhirTestScriptFixtureList;
    function GetHasFixtureList : Boolean;
    function GetProfileList : TFhirReferenceList;
    function GetHasProfileList : Boolean;
    function GetVariableList : TFhirTestScriptVariableList;
    function GetHasVariableList : Boolean;
    procedure SetSetup(value : TFhirTestScriptSetup);
    function GetTestList : TFhirTestScriptTestList;
    function GetHasTestList : Boolean;
    procedure SetTeardown(value : TFhirTestScriptTeardown);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestScript; overload;
    function Clone : TFhirTestScript; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An absolute URI that is used to identify this test script when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this test script is (or will be) published. This URL can be the target of a canonical reference. It SHALL remain the same when the test script is stored on different servers.
    property url : String read GetUrlST write SetUrlST;
    // An absolute URI that is used to identify this test script when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this test script is (or will be) published. This URL can be the target of a canonical reference. It SHALL remain the same when the test script is stored on different servers.
    property urlElement : TFhirUri read FUrl write SetUrl;

    // Typed access to A formal identifier that is used to identify this test script when it is represented in other formats, or referenced in a specification, model, design or an instance. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // A formal identifier that is used to identify this test script when it is represented in other formats, or referenced in a specification, model, design or an instance.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to The identifier that is used to identify this version of the test script when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the test script author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
    property version : String read GetVersionST write SetVersionST;
    // The identifier that is used to identify this version of the test script when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the test script author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to A natural language name identifying the test script. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property name : String read GetNameST write SetNameST;
    // A natural language name identifying the test script. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A short, descriptive, user-friendly title for the test script.
    property title : String read GetTitleST write SetTitleST;
    // A short, descriptive, user-friendly title for the test script.
    property titleElement : TFhirString read FTitle write SetTitle;

    // The status of this test script. Enables tracking the life-cycle of the content.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A Boolean value to indicate that this test script is authored for testing purposes (or education/evaluation/marketing) and is not intended to be used for genuine usage.
    property experimental : Boolean read GetExperimentalST write SetExperimentalST;
    // A Boolean value to indicate that this test script is authored for testing purposes (or education/evaluation/marketing) and is not intended to be used for genuine usage.
    property experimentalElement : TFhirBoolean read FExperimental write SetExperimental;

    // Typed access to The date  (and optionally time) when the test script was published. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the test script changes.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date  (and optionally time) when the test script was published. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the test script changes.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The name of the organization or individual that published the test script.
    property publisher : String read GetPublisherST write SetPublisherST;
    // The name of the organization or individual that published the test script.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Contact details to assist a user in finding and communicating with the publisher.
    property contactList : TFhirContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to A free text natural language description of the test script from a consumer's perspective.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A free text natural language description of the test script from a consumer's perspective.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // The content was developed with a focus and intent of supporting the contexts that are listed. These contexts may be general categories (gender, age, ...) or may be references to specific programs (insurance plans, studies, ...) and may be used to assist with indexing and searching for appropriate test script instances.
    property useContextList : TFhirUsageContextList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // A legal or geographic region in which the test script is intended to be used.
    property jurisdictionList : TFhirCodeableConceptList read GetJurisdictionList;
    property hasJurisdictionList : boolean read GetHasJurisdictionList;

    // Typed access to Explanation of why this test script is needed and why it has been designed as it has.
    property purpose : String read GetPurposeST write SetPurposeST;
    // Explanation of why this test script is needed and why it has been designed as it has.
    property purposeElement : TFhirMarkdown read FPurpose write SetPurpose;

    // Typed access to A copyright statement relating to the test script and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the test script.
    property copyright : String read GetCopyrightST write SetCopyrightST;
    // A copyright statement relating to the test script and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the test script.
    property copyrightElement : TFhirMarkdown read FCopyright write SetCopyright;

    // An abstract server used in operations within this test script in the origin element.
    property originList : TFhirTestScriptOriginList read GetOriginList;
    property hasOriginList : boolean read GetHasOriginList;

    // An abstract server used in operations within this test script in the destination element.
    property destinationList : TFhirTestScriptDestinationList read GetDestinationList;
    property hasDestinationList : boolean read GetHasDestinationList;

    // Typed access to The required capability must exist and are assumed to function correctly on the FHIR server being tested. (defined for API consistency)
    property metadata : TFhirTestScriptMetadata read FMetadata write SetMetadata;
    // The required capability must exist and are assumed to function correctly on the FHIR server being tested.
    property metadataElement : TFhirTestScriptMetadata read FMetadata write SetMetadata;

    // Fixture in the test script - by reference (uri). All fixtures are required for the test script to execute.
    property fixtureList : TFhirTestScriptFixtureList read GetFixtureList;
    property hasFixtureList : boolean read GetHasFixtureList;

    // Reference to the profile to be used for validation.
    property profileList : TFhirReferenceList read GetProfileList;
    property hasProfileList : boolean read GetHasProfileList;

    // Variable is set based either on element value in response body or on header field value in the response headers.
    property variableList : TFhirTestScriptVariableList read GetVariableList;
    property hasVariableList : boolean read GetHasVariableList;

    // Typed access to A series of required setup operations before tests are executed. (defined for API consistency)
    property setup : TFhirTestScriptSetup read FSetup write SetSetup;
    // A series of required setup operations before tests are executed.
    property setupElement : TFhirTestScriptSetup read FSetup write SetSetup;

    // A test in this script.
    property testList : TFhirTestScriptTestList read GetTestList;
    property hasTestList : boolean read GetHasTestList;

    // Typed access to A series of operations required to clean up after all the tests are executed (successfully or otherwise). (defined for API consistency)
    property teardown : TFhirTestScriptTeardown read FTeardown write SetTeardown;
    // A series of operations required to clean up after all the tests are executed (successfully or otherwise).
    property teardownElement : TFhirTestScriptTeardown read FTeardown write SetTeardown;

  end;

  TFhirTestScriptListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestScriptList;
    function GetCurrent : TFhirTestScript;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirTestScriptList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestScript read GetCurrent;
  end;

  TFhirTestScriptList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirTestScript;
    procedure SetItemN(index : Integer; value : TFhirTestScript);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirTestScriptList; overload;
    function Clone : TFhirTestScriptList; overload;
    function GetEnumerator : TFhirTestScriptListEnumerator;
    
    //  Add a FhirTestScript to the end of the list.
    function Append : TFhirTestScript;
    
    // Add an already existing FhirTestScript to the end of the list.
    function AddItem(value : TFhirTestScript) : TFhirTestScript; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestScript) : Integer;
    
    // Insert FhirTestScript before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestScript;
    
    // Insert an existing FhirTestScript before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestScript);
    
    // Get the iIndexth FhirTestScript. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestScript);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTestScript;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirTestScripts[index : Integer] : TFhirTestScript read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_TESTSCRIPT}
{$IFDEF FHIR_VALUESET}
  // A set of criteria that define the contents of the value set by including or excluding codes selected from the specified code system(s) that the value set draws from. This is also known as the Content Logical Definition (CLD).
  TFhirValueSetCompose = class (TFhirBackboneElement)
  protected
    FLockedDate : TFhirDate;
    FInactive : TFhirBoolean;
    FincludeList : TFhirValueSetComposeIncludeList;
    FexcludeList : TFhirValueSetComposeIncludeList;
    procedure SetLockedDate(value : TFhirDate);
    function GetLockedDateST : TFslDateTime;
    procedure SetLockedDateST(value : TFslDateTime);
    procedure SetInactive(value : TFhirBoolean);
    function GetInactiveST : Boolean;
    procedure SetInactiveST(value : Boolean);
    function GetIncludeList : TFhirValueSetComposeIncludeList;
    function GetHasIncludeList : Boolean;
    function GetExcludeList : TFhirValueSetComposeIncludeList;
    function GetHasExcludeList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirValueSetCompose; overload;
    function Clone : TFhirValueSetCompose; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The Locked Date is  the effective date that is used to determine the version of all referenced Code Systems and Value Set Definitions included in the compose that are not already tied to a specific version.
    property lockedDate : TFslDateTime read GetLockedDateST write SetLockedDateST;
    // The Locked Date is  the effective date that is used to determine the version of all referenced Code Systems and Value Set Definitions included in the compose that are not already tied to a specific version.
    property lockedDateElement : TFhirDate read FLockedDate write SetLockedDate;

    // Typed access to Whether inactive codes - codes that are not approved for current use - are in the value set. If inactive = true, inactive codes are to be included in the expansion, if inactive = false, the inactive codes will not be included in the expansion. If absent, the behavior is determined by the implementation, or by the applicable $expand parameters (but generally, inactive codes would be expected to be included).
    property inactive : Boolean read GetInactiveST write SetInactiveST;
    // Whether inactive codes - codes that are not approved for current use - are in the value set. If inactive = true, inactive codes are to be included in the expansion, if inactive = false, the inactive codes will not be included in the expansion. If absent, the behavior is determined by the implementation, or by the applicable $expand parameters (but generally, inactive codes would be expected to be included).
    property inactiveElement : TFhirBoolean read FInactive write SetInactive;

    // Include one or more codes from a code system or other value set(s).
    property includeList : TFhirValueSetComposeIncludeList read GetIncludeList;
    property hasIncludeList : boolean read GetHasIncludeList;

    // Exclude one or more codes from the value set based on code system filters and/or other value sets.
    property excludeList : TFhirValueSetComposeIncludeList read GetExcludeList;
    property hasExcludeList : boolean read GetHasExcludeList;

  end;

  TFhirValueSetComposeListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirValueSetComposeList;
    function GetCurrent : TFhirValueSetCompose;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirValueSetComposeList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirValueSetCompose read GetCurrent;
  end;

  TFhirValueSetComposeList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirValueSetCompose;
    procedure SetItemN(index : Integer; value : TFhirValueSetCompose);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirValueSetComposeList; overload;
    function Clone : TFhirValueSetComposeList; overload;
    function GetEnumerator : TFhirValueSetComposeListEnumerator;
    
    //  Add a FhirValueSetCompose to the end of the list.
    function Append : TFhirValueSetCompose;
    
    // Add an already existing FhirValueSetCompose to the end of the list.
    function AddItem(value : TFhirValueSetCompose) : TFhirValueSetCompose; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirValueSetCompose) : Integer;
    
    // Insert FhirValueSetCompose before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirValueSetCompose;
    
    // Insert an existing FhirValueSetCompose before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirValueSetCompose);
    
    // Get the iIndexth FhirValueSetCompose. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirValueSetCompose);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirValueSetCompose;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirValueSetComposes[index : Integer] : TFhirValueSetCompose read GetItemN write SetItemN; default;
  End;

  // Include one or more codes from a code system or other value set(s).
  TFhirValueSetComposeInclude = class (TFhirBackboneElement)
  protected
    FSystem : TFhirUri;
    FVersion : TFhirString;
    FconceptList : TFhirValueSetComposeIncludeConceptList;
    FfilterList : TFhirValueSetComposeIncludeFilterList;
    FvalueSetList : TFhirCanonicalList;
    procedure SetSystem(value : TFhirUri);
    function GetSystemST : String;
    procedure SetSystemST(value : String);
    procedure SetVersion(value : TFhirString);
    function GetVersionST : String;
    procedure SetVersionST(value : String);
    function GetConceptList : TFhirValueSetComposeIncludeConceptList;
    function GetHasConceptList : Boolean;
    function GetFilterList : TFhirValueSetComposeIncludeFilterList;
    function GetHasFilterList : Boolean;
    function GetValueSetList : TFhirCanonicalList;
    function GetHasValueSetList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirValueSetComposeInclude; overload;
    function Clone : TFhirValueSetComposeInclude; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An absolute URI which is the code system from which the selected codes come from.
    property system : String read GetSystemST write SetSystemST;
    // An absolute URI which is the code system from which the selected codes come from.
    property systemElement : TFhirUri read FSystem write SetSystem;

    // Typed access to The version of the code system that the codes are selected from, or the special version '*' for all versions.
    property version : String read GetVersionST write SetVersionST;
    // The version of the code system that the codes are selected from, or the special version '*' for all versions.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Specifies a concept to be included or excluded.
    property conceptList : TFhirValueSetComposeIncludeConceptList read GetConceptList;
    property hasConceptList : boolean read GetHasConceptList;

    // Select concepts by specify a matching criterion based on the properties (including relationships) defined by the system, or on filters defined by the system. If multiple filters are specified, they SHALL all be true.
    property filterList : TFhirValueSetComposeIncludeFilterList read GetFilterList;
    property hasFilterList : boolean read GetHasFilterList;

    // Selects the concepts found in this value set (based on its value set definition). This is an absolute URI that is a reference to ValueSet.url.  If multiple value sets are specified this includes the union of the contents of all of the referenced value sets.
    property valueSetList : TFhirCanonicalList read GetValueSetList;
    property hasValueSetList : boolean read GetHasValueSetList;

  end;

  TFhirValueSetComposeIncludeListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirValueSetComposeIncludeList;
    function GetCurrent : TFhirValueSetComposeInclude;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirValueSetComposeIncludeList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirValueSetComposeInclude read GetCurrent;
  end;

  TFhirValueSetComposeIncludeList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirValueSetComposeInclude;
    procedure SetItemN(index : Integer; value : TFhirValueSetComposeInclude);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirValueSetComposeIncludeList; overload;
    function Clone : TFhirValueSetComposeIncludeList; overload;
    function GetEnumerator : TFhirValueSetComposeIncludeListEnumerator;
    
    //  Add a FhirValueSetComposeInclude to the end of the list.
    function Append : TFhirValueSetComposeInclude;
    
    // Add an already existing FhirValueSetComposeInclude to the end of the list.
    function AddItem(value : TFhirValueSetComposeInclude) : TFhirValueSetComposeInclude; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirValueSetComposeInclude) : Integer;
    
    // Insert FhirValueSetComposeInclude before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirValueSetComposeInclude;
    
    // Insert an existing FhirValueSetComposeInclude before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirValueSetComposeInclude);
    
    // Get the iIndexth FhirValueSetComposeInclude. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirValueSetComposeInclude);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirValueSetComposeInclude;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirValueSetComposeIncludes[index : Integer] : TFhirValueSetComposeInclude read GetItemN write SetItemN; default;
  End;

  // Specifies a concept to be included or excluded.
  TFhirValueSetComposeIncludeConcept = class (TFhirBackboneElement)
  protected
    FCode : TFhirCode;
    FDisplay : TFhirString;
    FdesignationList : TFhirValueSetComposeIncludeConceptDesignationList;
    procedure SetCode(value : TFhirCode);
    function GetCodeST : String;
    procedure SetCodeST(value : String);
    procedure SetDisplay(value : TFhirString);
    function GetDisplayST : String;
    procedure SetDisplayST(value : String);
    function GetDesignationList : TFhirValueSetComposeIncludeConceptDesignationList;
    function GetHasDesignationList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirValueSetComposeIncludeConcept; overload;
    function Clone : TFhirValueSetComposeIncludeConcept; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Specifies a code for the concept to be included or excluded.
    property code : String read GetCodeST write SetCodeST;
    // Specifies a code for the concept to be included or excluded.
    property codeElement : TFhirCode read FCode write SetCode;

    // Typed access to The text to display to the user for this concept in the context of this valueset. If no display is provided, then applications using the value set use the display specified for the code by the system.
    property display : String read GetDisplayST write SetDisplayST;
    // The text to display to the user for this concept in the context of this valueset. If no display is provided, then applications using the value set use the display specified for the code by the system.
    property displayElement : TFhirString read FDisplay write SetDisplay;

    // Additional representations for this concept when used in this value set - other languages, aliases, specialized purposes, used for particular purposes, etc.
    property designationList : TFhirValueSetComposeIncludeConceptDesignationList read GetDesignationList;
    property hasDesignationList : boolean read GetHasDesignationList;

  end;

  TFhirValueSetComposeIncludeConceptListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirValueSetComposeIncludeConceptList;
    function GetCurrent : TFhirValueSetComposeIncludeConcept;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirValueSetComposeIncludeConceptList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirValueSetComposeIncludeConcept read GetCurrent;
  end;

  TFhirValueSetComposeIncludeConceptList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirValueSetComposeIncludeConcept;
    procedure SetItemN(index : Integer; value : TFhirValueSetComposeIncludeConcept);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirValueSetComposeIncludeConceptList; overload;
    function Clone : TFhirValueSetComposeIncludeConceptList; overload;
    function GetEnumerator : TFhirValueSetComposeIncludeConceptListEnumerator;
    
    //  Add a FhirValueSetComposeIncludeConcept to the end of the list.
    function Append : TFhirValueSetComposeIncludeConcept;
    
    // Add an already existing FhirValueSetComposeIncludeConcept to the end of the list.
    function AddItem(value : TFhirValueSetComposeIncludeConcept) : TFhirValueSetComposeIncludeConcept; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirValueSetComposeIncludeConcept) : Integer;
    
    // Insert FhirValueSetComposeIncludeConcept before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirValueSetComposeIncludeConcept;
    
    // Insert an existing FhirValueSetComposeIncludeConcept before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirValueSetComposeIncludeConcept);
    
    // Get the iIndexth FhirValueSetComposeIncludeConcept. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirValueSetComposeIncludeConcept);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirValueSetComposeIncludeConcept;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirValueSetComposeIncludeConcepts[index : Integer] : TFhirValueSetComposeIncludeConcept read GetItemN write SetItemN; default;
  End;

  // Additional representations for this concept when used in this value set - other languages, aliases, specialized purposes, used for particular purposes, etc.
  TFhirValueSetComposeIncludeConceptDesignation = class (TFhirBackboneElement)
  protected
    FLanguage : TFhirCode;
    FUse : TFhirCoding;
    FValue : TFhirString;
    procedure SetLanguage(value : TFhirCode);
    function GetLanguageST : String;
    procedure SetLanguageST(value : String);
    procedure SetUse(value : TFhirCoding);
    procedure SetValue(value : TFhirString);
    function GetValueST : String;
    procedure SetValueST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirValueSetComposeIncludeConceptDesignation; overload;
    function Clone : TFhirValueSetComposeIncludeConceptDesignation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The language this designation is defined for.
    property language : String read GetLanguageST write SetLanguageST;
    // The language this designation is defined for.
    property languageElement : TFhirCode read FLanguage write SetLanguage;

    // Typed access to A code that represents types of uses of designations. (defined for API consistency)
    property use : TFhirCoding read FUse write SetUse;
    // A code that represents types of uses of designations.
    property useElement : TFhirCoding read FUse write SetUse;

    // Typed access to The text value for this designation.
    property value : String read GetValueST write SetValueST;
    // The text value for this designation.
    property valueElement : TFhirString read FValue write SetValue;

  end;

  TFhirValueSetComposeIncludeConceptDesignationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirValueSetComposeIncludeConceptDesignationList;
    function GetCurrent : TFhirValueSetComposeIncludeConceptDesignation;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirValueSetComposeIncludeConceptDesignationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirValueSetComposeIncludeConceptDesignation read GetCurrent;
  end;

  TFhirValueSetComposeIncludeConceptDesignationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirValueSetComposeIncludeConceptDesignation;
    procedure SetItemN(index : Integer; value : TFhirValueSetComposeIncludeConceptDesignation);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirValueSetComposeIncludeConceptDesignationList; overload;
    function Clone : TFhirValueSetComposeIncludeConceptDesignationList; overload;
    function GetEnumerator : TFhirValueSetComposeIncludeConceptDesignationListEnumerator;
    
    //  Add a FhirValueSetComposeIncludeConceptDesignation to the end of the list.
    function Append : TFhirValueSetComposeIncludeConceptDesignation;
    
    // Add an already existing FhirValueSetComposeIncludeConceptDesignation to the end of the list.
    function AddItem(value : TFhirValueSetComposeIncludeConceptDesignation) : TFhirValueSetComposeIncludeConceptDesignation; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirValueSetComposeIncludeConceptDesignation) : Integer;
    
    // Insert FhirValueSetComposeIncludeConceptDesignation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirValueSetComposeIncludeConceptDesignation;
    
    // Insert an existing FhirValueSetComposeIncludeConceptDesignation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirValueSetComposeIncludeConceptDesignation);
    
    // Get the iIndexth FhirValueSetComposeIncludeConceptDesignation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirValueSetComposeIncludeConceptDesignation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirValueSetComposeIncludeConceptDesignation;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirValueSetComposeIncludeConceptDesignations[index : Integer] : TFhirValueSetComposeIncludeConceptDesignation read GetItemN write SetItemN; default;
  End;

  // Select concepts by specify a matching criterion based on the properties (including relationships) defined by the system, or on filters defined by the system. If multiple filters are specified, they SHALL all be true.
  TFhirValueSetComposeIncludeFilter = class (TFhirBackboneElement)
  protected
    FProperty_ : TFhirCode;
    FOp : TFhirEnum;
    FValue : TFhirString;
    procedure SetProperty_(value : TFhirCode);
    function GetProperty_ST : String;
    procedure SetProperty_ST(value : String);
    procedure SetOp(value : TFhirEnum);
    function GetOpST : TFhirFilterOperatorEnum;
    procedure SetOpST(value : TFhirFilterOperatorEnum);
    procedure SetValue(value : TFhirString);
    function GetValueST : String;
    procedure SetValueST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirValueSetComposeIncludeFilter; overload;
    function Clone : TFhirValueSetComposeIncludeFilter; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A code that identifies a property or a filter defined in the code system.
    property property_ : String read GetProperty_ST write SetProperty_ST;
    // A code that identifies a property or a filter defined in the code system.
    property property_Element : TFhirCode read FProperty_ write SetProperty_;

    // The kind of operation to perform as a part of the filter criteria.
    property op : TFhirFilterOperatorEnum read GetOpST write SetOpST;
    property opElement : TFhirEnum read FOp write SetOp;

    // Typed access to The match value may be either a code defined by the system, or a string value, which is a regex match on the literal string of the property value  (if the filter represents a property defined in CodeSystem) or of the system filter value (if the filter represents a filter defined in CodeSystem) when the operation is 'regex', or one of the values (true and false), when the operation is 'exists'.
    property value : String read GetValueST write SetValueST;
    // The match value may be either a code defined by the system, or a string value, which is a regex match on the literal string of the property value  (if the filter represents a property defined in CodeSystem) or of the system filter value (if the filter represents a filter defined in CodeSystem) when the operation is 'regex', or one of the values (true and false), when the operation is 'exists'.
    property valueElement : TFhirString read FValue write SetValue;

  end;

  TFhirValueSetComposeIncludeFilterListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirValueSetComposeIncludeFilterList;
    function GetCurrent : TFhirValueSetComposeIncludeFilter;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirValueSetComposeIncludeFilterList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirValueSetComposeIncludeFilter read GetCurrent;
  end;

  TFhirValueSetComposeIncludeFilterList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirValueSetComposeIncludeFilter;
    procedure SetItemN(index : Integer; value : TFhirValueSetComposeIncludeFilter);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirValueSetComposeIncludeFilterList; overload;
    function Clone : TFhirValueSetComposeIncludeFilterList; overload;
    function GetEnumerator : TFhirValueSetComposeIncludeFilterListEnumerator;
    
    //  Add a FhirValueSetComposeIncludeFilter to the end of the list.
    function Append : TFhirValueSetComposeIncludeFilter;
    
    // Add an already existing FhirValueSetComposeIncludeFilter to the end of the list.
    function AddItem(value : TFhirValueSetComposeIncludeFilter) : TFhirValueSetComposeIncludeFilter; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirValueSetComposeIncludeFilter) : Integer;
    
    // Insert FhirValueSetComposeIncludeFilter before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirValueSetComposeIncludeFilter;
    
    // Insert an existing FhirValueSetComposeIncludeFilter before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirValueSetComposeIncludeFilter);
    
    // Get the iIndexth FhirValueSetComposeIncludeFilter. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirValueSetComposeIncludeFilter);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirValueSetComposeIncludeFilter;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirValueSetComposeIncludeFilters[index : Integer] : TFhirValueSetComposeIncludeFilter read GetItemN write SetItemN; default;
  End;

  // A value set can also be "expanded", where the value set is turned into a simple collection of enumerated codes. This element holds the expansion, if it has been performed.
  TFhirValueSetExpansion = class (TFhirBackboneElement)
  protected
    FIdentifier : TFhirUri;
    FTimestamp : TFhirDateTime;
    FTotal : TFhirInteger;
    FOffset : TFhirInteger;
    FparameterList : TFhirValueSetExpansionParameterList;
    FcontainsList : TFhirValueSetExpansionContainsList;
    procedure SetIdentifier(value : TFhirUri);
    function GetIdentifierST : String;
    procedure SetIdentifierST(value : String);
    procedure SetTimestamp(value : TFhirDateTime);
    function GetTimestampST : TFslDateTime;
    procedure SetTimestampST(value : TFslDateTime);
    procedure SetTotal(value : TFhirInteger);
    function GetTotalST : String;
    procedure SetTotalST(value : String);
    procedure SetOffset(value : TFhirInteger);
    function GetOffsetST : String;
    procedure SetOffsetST(value : String);
    function GetParameterList : TFhirValueSetExpansionParameterList;
    function GetHasParameterList : Boolean;
    function GetContainsList : TFhirValueSetExpansionContainsList;
    function GetHasContainsList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirValueSetExpansion; overload;
    function Clone : TFhirValueSetExpansion; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An identifier that uniquely identifies this expansion of the valueset, based on a unique combination of the provided parameters, the system default parameters, and the underlying system code system versions etc. Systems may re-use the same identifier as long as those factors remain the same, and the expansion is the same, but are not required to do so. This is a business identifier.
    property identifier : String read GetIdentifierST write SetIdentifierST;
    // An identifier that uniquely identifies this expansion of the valueset, based on a unique combination of the provided parameters, the system default parameters, and the underlying system code system versions etc. Systems may re-use the same identifier as long as those factors remain the same, and the expansion is the same, but are not required to do so. This is a business identifier.
    property identifierElement : TFhirUri read FIdentifier write SetIdentifier;

    // Typed access to The time at which the expansion was produced by the expanding system.
    property timestamp : TFslDateTime read GetTimestampST write SetTimestampST;
    // The time at which the expansion was produced by the expanding system.
    property timestampElement : TFhirDateTime read FTimestamp write SetTimestamp;

    // Typed access to The total number of concepts in the expansion. If the number of concept nodes in this resource is less than the stated number, then the server can return more using the offset parameter.
    property total : String read GetTotalST write SetTotalST;
    // The total number of concepts in the expansion. If the number of concept nodes in this resource is less than the stated number, then the server can return more using the offset parameter.
    property totalElement : TFhirInteger read FTotal write SetTotal;

    // Typed access to If paging is being used, the offset at which this resource starts.  I.e. this resource is a partial view into the expansion. If paging is not being used, this element SHALL NOT be present.
    property offset : String read GetOffsetST write SetOffsetST;
    // If paging is being used, the offset at which this resource starts.  I.e. this resource is a partial view into the expansion. If paging is not being used, this element SHALL NOT be present.
    property offsetElement : TFhirInteger read FOffset write SetOffset;

    // A parameter that controlled the expansion process. These parameters may be used by users of expanded value sets to check whether the expansion is suitable for a particular purpose, or to pick the correct expansion.
    property parameterList : TFhirValueSetExpansionParameterList read GetParameterList;
    property hasParameterList : boolean read GetHasParameterList;

    // The codes that are contained in the value set expansion.
    property containsList : TFhirValueSetExpansionContainsList read GetContainsList;
    property hasContainsList : boolean read GetHasContainsList;

  end;

  TFhirValueSetExpansionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirValueSetExpansionList;
    function GetCurrent : TFhirValueSetExpansion;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirValueSetExpansionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirValueSetExpansion read GetCurrent;
  end;

  TFhirValueSetExpansionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirValueSetExpansion;
    procedure SetItemN(index : Integer; value : TFhirValueSetExpansion);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirValueSetExpansionList; overload;
    function Clone : TFhirValueSetExpansionList; overload;
    function GetEnumerator : TFhirValueSetExpansionListEnumerator;
    
    //  Add a FhirValueSetExpansion to the end of the list.
    function Append : TFhirValueSetExpansion;
    
    // Add an already existing FhirValueSetExpansion to the end of the list.
    function AddItem(value : TFhirValueSetExpansion) : TFhirValueSetExpansion; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirValueSetExpansion) : Integer;
    
    // Insert FhirValueSetExpansion before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirValueSetExpansion;
    
    // Insert an existing FhirValueSetExpansion before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirValueSetExpansion);
    
    // Get the iIndexth FhirValueSetExpansion. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirValueSetExpansion);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirValueSetExpansion;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirValueSetExpansions[index : Integer] : TFhirValueSetExpansion read GetItemN write SetItemN; default;
  End;

  // A parameter that controlled the expansion process. These parameters may be used by users of expanded value sets to check whether the expansion is suitable for a particular purpose, or to pick the correct expansion.
  TFhirValueSetExpansionParameter = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FValue : TFhirDataType;
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetValue(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirValueSetExpansionParameter; overload;
    function Clone : TFhirValueSetExpansionParameter; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Name of the input parameter to the $expand operation; may be a server-assigned name for additional default or other server-supplied parameters used to control the expansion process.
    property name : String read GetNameST write SetNameST;
    // Name of the input parameter to the $expand operation; may be a server-assigned name for additional default or other server-supplied parameters used to control the expansion process.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to The value of the parameter. (defined for API consistency)
    property value : TFhirDataType read FValue write SetValue;
    // The value of the parameter.
    property valueElement : TFhirDataType read FValue write SetValue;

  end;

  TFhirValueSetExpansionParameterListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirValueSetExpansionParameterList;
    function GetCurrent : TFhirValueSetExpansionParameter;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirValueSetExpansionParameterList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirValueSetExpansionParameter read GetCurrent;
  end;

  TFhirValueSetExpansionParameterList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirValueSetExpansionParameter;
    procedure SetItemN(index : Integer; value : TFhirValueSetExpansionParameter);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirValueSetExpansionParameterList; overload;
    function Clone : TFhirValueSetExpansionParameterList; overload;
    function GetEnumerator : TFhirValueSetExpansionParameterListEnumerator;
    
    //  Add a FhirValueSetExpansionParameter to the end of the list.
    function Append : TFhirValueSetExpansionParameter;
    
    // Add an already existing FhirValueSetExpansionParameter to the end of the list.
    function AddItem(value : TFhirValueSetExpansionParameter) : TFhirValueSetExpansionParameter; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirValueSetExpansionParameter) : Integer;
    
    // Insert FhirValueSetExpansionParameter before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirValueSetExpansionParameter;
    
    // Insert an existing FhirValueSetExpansionParameter before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirValueSetExpansionParameter);
    
    // Get the iIndexth FhirValueSetExpansionParameter. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirValueSetExpansionParameter);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirValueSetExpansionParameter;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirValueSetExpansionParameters[index : Integer] : TFhirValueSetExpansionParameter read GetItemN write SetItemN; default;
  End;

  // The codes that are contained in the value set expansion.
  TFhirValueSetExpansionContains = class (TFhirBackboneElement)
  protected
    FSystem : TFhirUri;
    FAbstract : TFhirBoolean;
    FInactive : TFhirBoolean;
    FVersion : TFhirString;
    FCode : TFhirCode;
    FDisplay : TFhirString;
    FdesignationList : TFhirValueSetComposeIncludeConceptDesignationList;
    FcontainsList : TFhirValueSetExpansionContainsList;
    procedure SetSystem(value : TFhirUri);
    function GetSystemST : String;
    procedure SetSystemST(value : String);
    procedure SetAbstract(value : TFhirBoolean);
    function GetAbstractST : Boolean;
    procedure SetAbstractST(value : Boolean);
    procedure SetInactive(value : TFhirBoolean);
    function GetInactiveST : Boolean;
    procedure SetInactiveST(value : Boolean);
    procedure SetVersion(value : TFhirString);
    function GetVersionST : String;
    procedure SetVersionST(value : String);
    procedure SetCode(value : TFhirCode);
    function GetCodeST : String;
    procedure SetCodeST(value : String);
    procedure SetDisplay(value : TFhirString);
    function GetDisplayST : String;
    procedure SetDisplayST(value : String);
    function GetDesignationList : TFhirValueSetComposeIncludeConceptDesignationList;
    function GetHasDesignationList : Boolean;
    function GetContainsList : TFhirValueSetExpansionContainsList;
    function GetHasContainsList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirValueSetExpansionContains; overload;
    function Clone : TFhirValueSetExpansionContains; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An absolute URI which is the code system in which the code for this item in the expansion is defined.
    property system : String read GetSystemST write SetSystemST;
    // An absolute URI which is the code system in which the code for this item in the expansion is defined.
    property systemElement : TFhirUri read FSystem write SetSystem;

    // Typed access to If true, this entry is included in the expansion for navigational purposes, and the user cannot select the code directly as a proper value.
    property abstract : Boolean read GetAbstractST write SetAbstractST;
    // If true, this entry is included in the expansion for navigational purposes, and the user cannot select the code directly as a proper value.
    property abstractElement : TFhirBoolean read FAbstract write SetAbstract;

    // Typed access to If the concept is inactive in the code system that defines it. Inactive codes are those that are no longer to be used, but are maintained by the code system for understanding legacy data. It might not be known or specified whether an concept is inactive (and it may depend on the context of use).
    property inactive : Boolean read GetInactiveST write SetInactiveST;
    // If the concept is inactive in the code system that defines it. Inactive codes are those that are no longer to be used, but are maintained by the code system for understanding legacy data. It might not be known or specified whether an concept is inactive (and it may depend on the context of use).
    property inactiveElement : TFhirBoolean read FInactive write SetInactive;

    // Typed access to The version of the code system from this code was taken. Note that a well-maintained code system does not need the version reported, because the meaning of codes is consistent across versions. However this cannot consistently be assured, and when the meaning is not guaranteed to be consistent, the version SHOULD be exchanged.
    property version : String read GetVersionST write SetVersionST;
    // The version of the code system from this code was taken. Note that a well-maintained code system does not need the version reported, because the meaning of codes is consistent across versions. However this cannot consistently be assured, and when the meaning is not guaranteed to be consistent, the version SHOULD be exchanged.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to The code for this item in the expansion hierarchy. If this code is missing the entry in the hierarchy is a place holder (abstract) and does not represent a valid code in the value set.
    property code : String read GetCodeST write SetCodeST;
    // The code for this item in the expansion hierarchy. If this code is missing the entry in the hierarchy is a place holder (abstract) and does not represent a valid code in the value set.
    property codeElement : TFhirCode read FCode write SetCode;

    // Typed access to The recommended display for this item in the expansion.
    property display : String read GetDisplayST write SetDisplayST;
    // The recommended display for this item in the expansion.
    property displayElement : TFhirString read FDisplay write SetDisplay;

    // Additional representations for this item - other languages, aliases, specialized purposes, used for particular purposes, etc. These are relevant when the conditions of the expansion do not fix to a single correct representation.
    property designationList : TFhirValueSetComposeIncludeConceptDesignationList read GetDesignationList;
    property hasDesignationList : boolean read GetHasDesignationList;

    // Other codes and entries contained under this entry in the hierarchy.
    property containsList : TFhirValueSetExpansionContainsList read GetContainsList;
    property hasContainsList : boolean read GetHasContainsList;

  end;

  TFhirValueSetExpansionContainsListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirValueSetExpansionContainsList;
    function GetCurrent : TFhirValueSetExpansionContains;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirValueSetExpansionContainsList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirValueSetExpansionContains read GetCurrent;
  end;

  TFhirValueSetExpansionContainsList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirValueSetExpansionContains;
    procedure SetItemN(index : Integer; value : TFhirValueSetExpansionContains);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirValueSetExpansionContainsList; overload;
    function Clone : TFhirValueSetExpansionContainsList; overload;
    function GetEnumerator : TFhirValueSetExpansionContainsListEnumerator;
    
    //  Add a FhirValueSetExpansionContains to the end of the list.
    function Append : TFhirValueSetExpansionContains;
    
    // Add an already existing FhirValueSetExpansionContains to the end of the list.
    function AddItem(value : TFhirValueSetExpansionContains) : TFhirValueSetExpansionContains; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirValueSetExpansionContains) : Integer;
    
    // Insert FhirValueSetExpansionContains before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirValueSetExpansionContains;
    
    // Insert an existing FhirValueSetExpansionContains before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirValueSetExpansionContains);
    
    // Get the iIndexth FhirValueSetExpansionContains. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirValueSetExpansionContains);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirValueSetExpansionContains;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirValueSetExpansionContains[index : Integer] : TFhirValueSetExpansionContains read GetItemN write SetItemN; default;
  End;

  // A ValueSet resource instance specifies a set of codes drawn from one or more code systems, intended for use in a particular context. Value sets link between [CodeSystem](codesystem.html) definitions and their use in [coded elements](terminologies.html).
  TFhirValueSet = class (TFhirDomainResource)
  protected
    FUrl : TFhirUri;
    FidentifierList : TFhirIdentifierList;
    FVersion : TFhirString;
    FName : TFhirString;
    FTitle : TFhirString;
    FStatus : TFhirEnum;
    FExperimental : TFhirBoolean;
    FDate : TFhirDateTime;
    FPublisher : TFhirString;
    FcontactList : TFhirContactDetailList;
    FDescription : TFhirMarkdown;
    FuseContextList : TFhirUsageContextList;
    FjurisdictionList : TFhirCodeableConceptList;
    FImmutable : TFhirBoolean;
    FPurpose : TFhirMarkdown;
    FCopyright : TFhirMarkdown;
    FCompose : TFhirValueSetCompose;
    FExpansion : TFhirValueSetExpansion;
    procedure SetUrl(value : TFhirUri);
    function GetUrlST : String;
    procedure SetUrlST(value : String);
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetVersion(value : TFhirString);
    function GetVersionST : String;
    procedure SetVersionST(value : String);
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetTitle(value : TFhirString);
    function GetTitleST : String;
    procedure SetTitleST(value : String);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirPublicationStatusEnum;
    procedure SetStatusST(value : TFhirPublicationStatusEnum);
    procedure SetExperimental(value : TFhirBoolean);
    function GetExperimentalST : Boolean;
    procedure SetExperimentalST(value : Boolean);
    procedure SetDate(value : TFhirDateTime);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    procedure SetPublisher(value : TFhirString);
    function GetPublisherST : String;
    procedure SetPublisherST(value : String);
    function GetContactList : TFhirContactDetailList;
    function GetHasContactList : Boolean;
    procedure SetDescription(value : TFhirMarkdown);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetUseContextList : TFhirUsageContextList;
    function GetHasUseContextList : Boolean;
    function GetJurisdictionList : TFhirCodeableConceptList;
    function GetHasJurisdictionList : Boolean;
    procedure SetImmutable(value : TFhirBoolean);
    function GetImmutableST : Boolean;
    procedure SetImmutableST(value : Boolean);
    procedure SetPurpose(value : TFhirMarkdown);
    function GetPurposeST : String;
    procedure SetPurposeST(value : String);
    procedure SetCopyright(value : TFhirMarkdown);
    function GetCopyrightST : String;
    procedure SetCopyrightST(value : String);
    procedure SetCompose(value : TFhirValueSetCompose);
    procedure SetExpansion(value : TFhirValueSetExpansion);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirValueSet; overload;
    function Clone : TFhirValueSet; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An absolute URI that is used to identify this value set when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this value set is (or will be) published. This URL can be the target of a canonical reference. It SHALL remain the same when the value set is stored on different servers.
    property url : String read GetUrlST write SetUrlST;
    // An absolute URI that is used to identify this value set when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this value set is (or will be) published. This URL can be the target of a canonical reference. It SHALL remain the same when the value set is stored on different servers.
    property urlElement : TFhirUri read FUrl write SetUrl;

    // A formal identifier that is used to identify this value set when it is represented in other formats, or referenced in a specification, model, design or an instance.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The identifier that is used to identify this version of the value set when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the value set author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
    property version : String read GetVersionST write SetVersionST;
    // The identifier that is used to identify this version of the value set when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the value set author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to A natural language name identifying the value set. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property name : String read GetNameST write SetNameST;
    // A natural language name identifying the value set. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A short, descriptive, user-friendly title for the value set.
    property title : String read GetTitleST write SetTitleST;
    // A short, descriptive, user-friendly title for the value set.
    property titleElement : TFhirString read FTitle write SetTitle;

    // The status of this value set. Enables tracking the life-cycle of the content. The status of the value set applies to the value set definition (ValueSet.compose) and the associated ValueSet metadata. Expansions do not have a state.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A Boolean value to indicate that this value set is authored for testing purposes (or education/evaluation/marketing) and is not intended to be used for genuine usage.
    property experimental : Boolean read GetExperimentalST write SetExperimentalST;
    // A Boolean value to indicate that this value set is authored for testing purposes (or education/evaluation/marketing) and is not intended to be used for genuine usage.
    property experimentalElement : TFhirBoolean read FExperimental write SetExperimental;

    // Typed access to The date (and optionally time) when the value set was created or revised (e.g. the 'content logical definition').
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date (and optionally time) when the value set was created or revised (e.g. the 'content logical definition').
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The name of the organization or individual that published the value set.
    property publisher : String read GetPublisherST write SetPublisherST;
    // The name of the organization or individual that published the value set.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Contact details to assist a user in finding and communicating with the publisher.
    property contactList : TFhirContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to A free text natural language description of the value set from a consumer's perspective. The textual description specifies the span of meanings for concepts to be included within the Value Set Expansion, and also may specify the intended use and limitations of the Value Set.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A free text natural language description of the value set from a consumer's perspective. The textual description specifies the span of meanings for concepts to be included within the Value Set Expansion, and also may specify the intended use and limitations of the Value Set.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // The content was developed with a focus and intent of supporting the contexts that are listed. These contexts may be general categories (gender, age, ...) or may be references to specific programs (insurance plans, studies, ...) and may be used to assist with indexing and searching for appropriate value set instances.
    property useContextList : TFhirUsageContextList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // A legal or geographic region in which the value set is intended to be used.
    property jurisdictionList : TFhirCodeableConceptList read GetJurisdictionList;
    property hasJurisdictionList : boolean read GetHasJurisdictionList;

    // Typed access to If this is set to 'true', then no new versions of the content logical definition can be created.  Note: Other metadata might still change.
    property immutable : Boolean read GetImmutableST write SetImmutableST;
    // If this is set to 'true', then no new versions of the content logical definition can be created.  Note: Other metadata might still change.
    property immutableElement : TFhirBoolean read FImmutable write SetImmutable;

    // Typed access to Explanation of why this value set is needed and why it has been designed as it has.
    property purpose : String read GetPurposeST write SetPurposeST;
    // Explanation of why this value set is needed and why it has been designed as it has.
    property purposeElement : TFhirMarkdown read FPurpose write SetPurpose;

    // Typed access to A copyright statement relating to the value set and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the value set.
    property copyright : String read GetCopyrightST write SetCopyrightST;
    // A copyright statement relating to the value set and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the value set.
    property copyrightElement : TFhirMarkdown read FCopyright write SetCopyright;

    // Typed access to A set of criteria that define the contents of the value set by including or excluding codes selected from the specified code system(s) that the value set draws from. This is also known as the Content Logical Definition (CLD). (defined for API consistency)
    property compose : TFhirValueSetCompose read FCompose write SetCompose;
    // A set of criteria that define the contents of the value set by including or excluding codes selected from the specified code system(s) that the value set draws from. This is also known as the Content Logical Definition (CLD).
    property composeElement : TFhirValueSetCompose read FCompose write SetCompose;

    // Typed access to A value set can also be "expanded", where the value set is turned into a simple collection of enumerated codes. This element holds the expansion, if it has been performed. (defined for API consistency)
    property expansion : TFhirValueSetExpansion read FExpansion write SetExpansion;
    // A value set can also be "expanded", where the value set is turned into a simple collection of enumerated codes. This element holds the expansion, if it has been performed.
    property expansionElement : TFhirValueSetExpansion read FExpansion write SetExpansion;

  end;

  TFhirValueSetListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirValueSetList;
    function GetCurrent : TFhirValueSet;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirValueSetList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirValueSet read GetCurrent;
  end;

  TFhirValueSetList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirValueSet;
    procedure SetItemN(index : Integer; value : TFhirValueSet);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirValueSetList; overload;
    function Clone : TFhirValueSetList; overload;
    function GetEnumerator : TFhirValueSetListEnumerator;
    
    //  Add a FhirValueSet to the end of the list.
    function Append : TFhirValueSet;
    
    // Add an already existing FhirValueSet to the end of the list.
    function AddItem(value : TFhirValueSet) : TFhirValueSet; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirValueSet) : Integer;
    
    // Insert FhirValueSet before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirValueSet;
    
    // Insert an existing FhirValueSet before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirValueSet);
    
    // Get the iIndexth FhirValueSet. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirValueSet);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirValueSet;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirValueSets[index : Integer] : TFhirValueSet read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_VALUESET}



implementation

uses
  fhir4b_utilities;



{$IFDEF FHIR_CAPABILITYSTATEMENT}
{ TFhirCapabilityStatementSoftware }

constructor TFhirCapabilityStatementSoftware.Create;
begin
  inherited;
end;

destructor TFhirCapabilityStatementSoftware.Destroy;
begin
  FName.free;
  FVersion.free;
  FReleaseDate.free;
  inherited;
end;

procedure TFhirCapabilityStatementSoftware.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirCapabilityStatementSoftware(oSource).nameElement.Clone;
  versionElement := TFhirCapabilityStatementSoftware(oSource).versionElement.Clone;
  releaseDateElement := TFhirCapabilityStatementSoftware(oSource).releaseDateElement.Clone;
end;

procedure TFhirCapabilityStatementSoftware.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'version') Then
     list.add(self.link, 'version', FVersion.Link);
  if (child_name = 'releaseDate') Then
     list.add(self.link, 'releaseDate', FReleaseDate.Link);
end;

procedure TFhirCapabilityStatementSoftware.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'version', 'string', false, TFhirString, FVersion.Link));
  oList.add(TFHIRProperty.create(self, 'releaseDate', 'dateTime', false, TFhirDateTime, FReleaseDate.Link));
end;

function TFhirCapabilityStatementSoftware.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'releaseDate') then
  begin
    ReleaseDateElement := asDateTime(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCapabilityStatementSoftware.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCapabilityStatementSoftware.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'version') then result := TFhirString.create()
  else if (propName = 'releaseDate') then result := TFhirDateTime.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirCapabilityStatementSoftware.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'version') then result := 'string'
  else if (propName = 'releaseDate') then result := 'dateTime'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCapabilityStatementSoftware.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'version') then VersionElement := nil
  else if (propName = 'releaseDate') then ReleaseDateElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCapabilityStatementSoftware.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'version') then VersionElement := asString(new)
  else if (propName = 'releaseDate') then ReleaseDateElement := asDateTime(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCapabilityStatementSoftware.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCapabilityStatementSoftware.fhirType : string;
begin
  result := 'CapabilityStatement.software';
end;

function TFhirCapabilityStatementSoftware.Link : TFhirCapabilityStatementSoftware;
begin
  result := TFhirCapabilityStatementSoftware(inherited Link);
end;

function TFhirCapabilityStatementSoftware.Clone : TFhirCapabilityStatementSoftware;
begin
  result := TFhirCapabilityStatementSoftware(inherited Clone);
end;

function TFhirCapabilityStatementSoftware.equals(other : TObject) : boolean; 
var
  o : TFhirCapabilityStatementSoftware;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCapabilityStatementSoftware)) then
    result := false
  else
  begin
    o := TFhirCapabilityStatementSoftware(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(versionElement, o.versionElement, true) and 
      compareDeep(releaseDateElement, o.releaseDateElement, true);
  end;
end;

function TFhirCapabilityStatementSoftware.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FVersion) and isEmptyProp(FReleaseDate);
end;

procedure TFhirCapabilityStatementSoftware.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('name');
  fields.add('version');
  fields.add('releaseDate');
end;

function TFhirCapabilityStatementSoftware.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirCapabilityStatementSoftware.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirCapabilityStatementSoftware.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirCapabilityStatementSoftware.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirCapabilityStatementSoftware.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

function TFhirCapabilityStatementSoftware.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

procedure TFhirCapabilityStatementSoftware.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

procedure TFhirCapabilityStatementSoftware.SetReleaseDate(value : TFhirDateTime);
begin
  FReleaseDate.free;
  FReleaseDate := value;
end;

function TFhirCapabilityStatementSoftware.GetReleaseDateST : TFslDateTime;
begin
  if FReleaseDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FReleaseDate.value;
end;

procedure TFhirCapabilityStatementSoftware.SetReleaseDateST(value : TFslDateTime);
begin
  if FReleaseDate = nil then
    FReleaseDate := TFhirDateTime.create;
  FReleaseDate.value := value
end;

{ TFhirCapabilityStatementSoftwareListEnumerator }

constructor TFhirCapabilityStatementSoftwareListEnumerator.Create(list : TFhirCapabilityStatementSoftwareList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCapabilityStatementSoftwareListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCapabilityStatementSoftwareListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCapabilityStatementSoftwareListEnumerator.GetCurrent : TFhirCapabilityStatementSoftware;
begin
  Result := FList[FIndex];
end;

function TFhirCapabilityStatementSoftwareListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCapabilityStatementSoftwareList }

function TFhirCapabilityStatementSoftwareList.AddItem(value: TFhirCapabilityStatementSoftware): TFhirCapabilityStatementSoftware;
begin
  assert(value.ClassName = 'TFhirCapabilityStatementSoftware', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCapabilityStatementSoftware');
  add(value);
  result := value;
end;

function TFhirCapabilityStatementSoftwareList.Append: TFhirCapabilityStatementSoftware;
begin
  result := TFhirCapabilityStatementSoftware.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCapabilityStatementSoftwareList.ClearItems;
begin
  Clear;
end;

function TFhirCapabilityStatementSoftwareList.GetEnumerator : TFhirCapabilityStatementSoftwareListEnumerator;
begin
  result := TFhirCapabilityStatementSoftwareListEnumerator.Create(self.link);
end;

function TFhirCapabilityStatementSoftwareList.Clone: TFhirCapabilityStatementSoftwareList;
begin
  result := TFhirCapabilityStatementSoftwareList(inherited Clone);
end;

function TFhirCapabilityStatementSoftwareList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCapabilityStatementSoftwareList.GetItemN(index: Integer): TFhirCapabilityStatementSoftware;
begin
  result := TFhirCapabilityStatementSoftware(ObjectByIndex[index]);
end;

function TFhirCapabilityStatementSoftwareList.ItemClass: TFslObjectClass;
begin
  result := TFhirCapabilityStatementSoftware;
end;
function TFhirCapabilityStatementSoftwareList.IndexOf(value: TFhirCapabilityStatementSoftware): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCapabilityStatementSoftwareList.Insert(index: Integer): TFhirCapabilityStatementSoftware;
begin
  result := TFhirCapabilityStatementSoftware.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCapabilityStatementSoftwareList.InsertItem(index: Integer; value: TFhirCapabilityStatementSoftware);
begin
  assert(value is TFhirCapabilityStatementSoftware);
  Inherited Insert(index, value);
end;

function TFhirCapabilityStatementSoftwareList.Item(index: Integer): TFhirCapabilityStatementSoftware;
begin
  result := TFhirCapabilityStatementSoftware(ObjectByIndex[index]);
end;

function TFhirCapabilityStatementSoftwareList.Link: TFhirCapabilityStatementSoftwareList;
begin
  result := TFhirCapabilityStatementSoftwareList(inherited Link);
end;

procedure TFhirCapabilityStatementSoftwareList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCapabilityStatementSoftwareList.SetItemByIndex(index: Integer; value: TFhirCapabilityStatementSoftware);
begin
  assert(value is TFhirCapabilityStatementSoftware);
  FhirCapabilityStatementSoftwares[index] := value;
end;

procedure TFhirCapabilityStatementSoftwareList.SetItemN(index: Integer; value: TFhirCapabilityStatementSoftware);
begin
  assert(value is TFhirCapabilityStatementSoftware);
  ObjectByIndex[index] := value;
end;

{ TFhirCapabilityStatementImplementation }

constructor TFhirCapabilityStatementImplementation.Create;
begin
  inherited;
end;

destructor TFhirCapabilityStatementImplementation.Destroy;
begin
  FDescription.free;
  FUrl.free;
  FCustodian.free;
  inherited;
end;

procedure TFhirCapabilityStatementImplementation.Assign(oSource : TFslObject);
begin
  inherited;
  descriptionElement := TFhirCapabilityStatementImplementation(oSource).descriptionElement.Clone;
  urlElement := TFhirCapabilityStatementImplementation(oSource).urlElement.Clone;
  custodian := TFhirCapabilityStatementImplementation(oSource).custodian.Clone;
end;

procedure TFhirCapabilityStatementImplementation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
  if (child_name = 'custodian') Then
     list.add(self.link, 'custodian', FCustodian.Link);
end;

procedure TFhirCapabilityStatementImplementation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'url', 'url', false, TFhirUrl, FUrl.Link));
  oList.add(TFHIRProperty.create(self, 'custodian', 'Reference', false, TFhirReference, FCustodian.Link));
end;

function TFhirCapabilityStatementImplementation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'url') then
  begin
    UrlElement := asUrl(propValue);
    result := propValue;
  end
  else if (propName = 'custodian') then
  begin
    Custodian := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCapabilityStatementImplementation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCapabilityStatementImplementation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'description') then result := TFhirString.create()
  else if (propName = 'url') then result := TFhirUrl.create()
  else if (propName = 'custodian') then result := TFhirReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirCapabilityStatementImplementation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'description') then result := 'string'
  else if (propName = 'url') then result := 'url'
  else if (propName = 'custodian') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCapabilityStatementImplementation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'url') then UrlElement := nil
  else if (propName = 'custodian') then CustodianElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCapabilityStatementImplementation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := asString(new)
  else if (propName = 'url') then UrlElement := asUrl(new)
  else if (propName = 'custodian') then CustodianElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCapabilityStatementImplementation.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCapabilityStatementImplementation.fhirType : string;
begin
  result := 'CapabilityStatement.implementation';
end;

function TFhirCapabilityStatementImplementation.Link : TFhirCapabilityStatementImplementation;
begin
  result := TFhirCapabilityStatementImplementation(inherited Link);
end;

function TFhirCapabilityStatementImplementation.Clone : TFhirCapabilityStatementImplementation;
begin
  result := TFhirCapabilityStatementImplementation(inherited Clone);
end;

function TFhirCapabilityStatementImplementation.equals(other : TObject) : boolean; 
var
  o : TFhirCapabilityStatementImplementation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCapabilityStatementImplementation)) then
    result := false
  else
  begin
    o := TFhirCapabilityStatementImplementation(other);
    result := compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(urlElement, o.urlElement, true) and 
      compareDeep(custodianElement, o.custodianElement, true);
  end;
end;

function TFhirCapabilityStatementImplementation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDescription) and isEmptyProp(FUrl) and isEmptyProp(FCustodian);
end;

procedure TFhirCapabilityStatementImplementation.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('description');
  fields.add('url');
  fields.add('custodian');
end;

function TFhirCapabilityStatementImplementation.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirCapabilityStatementImplementation.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirCapabilityStatementImplementation.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirCapabilityStatementImplementation.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirCapabilityStatementImplementation.SetUrl(value : TFhirUrl);
begin
  FUrl.free;
  FUrl := value;
end;

function TFhirCapabilityStatementImplementation.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

procedure TFhirCapabilityStatementImplementation.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUrl.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

procedure TFhirCapabilityStatementImplementation.SetCustodian(value : TFhirReference);
begin
  FCustodian.free;
  FCustodian := value;
end;

{ TFhirCapabilityStatementImplementationListEnumerator }

constructor TFhirCapabilityStatementImplementationListEnumerator.Create(list : TFhirCapabilityStatementImplementationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCapabilityStatementImplementationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCapabilityStatementImplementationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCapabilityStatementImplementationListEnumerator.GetCurrent : TFhirCapabilityStatementImplementation;
begin
  Result := FList[FIndex];
end;

function TFhirCapabilityStatementImplementationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCapabilityStatementImplementationList }

function TFhirCapabilityStatementImplementationList.AddItem(value: TFhirCapabilityStatementImplementation): TFhirCapabilityStatementImplementation;
begin
  assert(value.ClassName = 'TFhirCapabilityStatementImplementation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCapabilityStatementImplementation');
  add(value);
  result := value;
end;

function TFhirCapabilityStatementImplementationList.Append: TFhirCapabilityStatementImplementation;
begin
  result := TFhirCapabilityStatementImplementation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCapabilityStatementImplementationList.ClearItems;
begin
  Clear;
end;

function TFhirCapabilityStatementImplementationList.GetEnumerator : TFhirCapabilityStatementImplementationListEnumerator;
begin
  result := TFhirCapabilityStatementImplementationListEnumerator.Create(self.link);
end;

function TFhirCapabilityStatementImplementationList.Clone: TFhirCapabilityStatementImplementationList;
begin
  result := TFhirCapabilityStatementImplementationList(inherited Clone);
end;

function TFhirCapabilityStatementImplementationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCapabilityStatementImplementationList.GetItemN(index: Integer): TFhirCapabilityStatementImplementation;
begin
  result := TFhirCapabilityStatementImplementation(ObjectByIndex[index]);
end;

function TFhirCapabilityStatementImplementationList.ItemClass: TFslObjectClass;
begin
  result := TFhirCapabilityStatementImplementation;
end;
function TFhirCapabilityStatementImplementationList.IndexOf(value: TFhirCapabilityStatementImplementation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCapabilityStatementImplementationList.Insert(index: Integer): TFhirCapabilityStatementImplementation;
begin
  result := TFhirCapabilityStatementImplementation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCapabilityStatementImplementationList.InsertItem(index: Integer; value: TFhirCapabilityStatementImplementation);
begin
  assert(value is TFhirCapabilityStatementImplementation);
  Inherited Insert(index, value);
end;

function TFhirCapabilityStatementImplementationList.Item(index: Integer): TFhirCapabilityStatementImplementation;
begin
  result := TFhirCapabilityStatementImplementation(ObjectByIndex[index]);
end;

function TFhirCapabilityStatementImplementationList.Link: TFhirCapabilityStatementImplementationList;
begin
  result := TFhirCapabilityStatementImplementationList(inherited Link);
end;

procedure TFhirCapabilityStatementImplementationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCapabilityStatementImplementationList.SetItemByIndex(index: Integer; value: TFhirCapabilityStatementImplementation);
begin
  assert(value is TFhirCapabilityStatementImplementation);
  FhirCapabilityStatementImplementations[index] := value;
end;

procedure TFhirCapabilityStatementImplementationList.SetItemN(index: Integer; value: TFhirCapabilityStatementImplementation);
begin
  assert(value is TFhirCapabilityStatementImplementation);
  ObjectByIndex[index] := value;
end;

{ TFhirCapabilityStatementRest }

constructor TFhirCapabilityStatementRest.Create;
begin
  inherited;
end;

destructor TFhirCapabilityStatementRest.Destroy;
begin
  FMode.free;
  FDocumentation.free;
  FSecurity.free;
  FResourceList.Free;
  FInteractionList.Free;
  FSearchParamList.Free;
  FOperationList.Free;
  FCompartmentList.Free;
  inherited;
end;

procedure TFhirCapabilityStatementRest.Assign(oSource : TFslObject);
begin
  inherited;
  modeElement := TFhirCapabilityStatementRest(oSource).modeElement.Clone;
  documentationElement := TFhirCapabilityStatementRest(oSource).documentationElement.Clone;
  security := TFhirCapabilityStatementRest(oSource).security.Clone;
  if (TFhirCapabilityStatementRest(oSource).FResourceList = nil) then
  begin
    FResourceList.free;
    FResourceList := nil;
  end
  else
  begin
    if FResourceList = nil then
      FResourceList := TFhirCapabilityStatementRestResourceList.Create;
    FResourceList.Assign(TFhirCapabilityStatementRest(oSource).FResourceList);
  end;
  if (TFhirCapabilityStatementRest(oSource).FInteractionList = nil) then
  begin
    FInteractionList.free;
    FInteractionList := nil;
  end
  else
  begin
    if FInteractionList = nil then
      FInteractionList := TFhirCapabilityStatementRestInteractionList.Create;
    FInteractionList.Assign(TFhirCapabilityStatementRest(oSource).FInteractionList);
  end;
  if (TFhirCapabilityStatementRest(oSource).FSearchParamList = nil) then
  begin
    FSearchParamList.free;
    FSearchParamList := nil;
  end
  else
  begin
    if FSearchParamList = nil then
      FSearchParamList := TFhirCapabilityStatementRestResourceSearchParamList.Create;
    FSearchParamList.Assign(TFhirCapabilityStatementRest(oSource).FSearchParamList);
  end;
  if (TFhirCapabilityStatementRest(oSource).FOperationList = nil) then
  begin
    FOperationList.free;
    FOperationList := nil;
  end
  else
  begin
    if FOperationList = nil then
      FOperationList := TFhirCapabilityStatementRestResourceOperationList.Create;
    FOperationList.Assign(TFhirCapabilityStatementRest(oSource).FOperationList);
  end;
  if (TFhirCapabilityStatementRest(oSource).FCompartmentList = nil) then
  begin
    FCompartmentList.free;
    FCompartmentList := nil;
  end
  else
  begin
    if FCompartmentList = nil then
      FCompartmentList := TFhirCanonicalList.Create;
    FCompartmentList.Assign(TFhirCapabilityStatementRest(oSource).FCompartmentList);
  end;
end;

procedure TFhirCapabilityStatementRest.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'mode') Then
     list.add(self.link, 'mode', FMode.Link);
  if (child_name = 'documentation') Then
     list.add(self.link, 'documentation', FDocumentation.Link);
  if (child_name = 'security') Then
     list.add(self.link, 'security', FSecurity.Link);
  if (child_name = 'resource') Then
    list.addAll(self, 'resource', FResourceList);
  if (child_name = 'interaction') Then
    list.addAll(self, 'interaction', FInteractionList);
  if (child_name = 'searchParam') Then
    list.addAll(self, 'searchParam', FSearchParamList);
  if (child_name = 'operation') Then
    list.addAll(self, 'operation', FOperationList);
  if (child_name = 'compartment') Then
    list.addAll(self, 'compartment', FCompartmentList);
end;

procedure TFhirCapabilityStatementRest.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'mode', 'code', false, TFhirEnum, FMode.Link));
  oList.add(TFHIRProperty.create(self, 'documentation', 'markdown', false, TFhirMarkdown, FDocumentation.Link));
  oList.add(TFHIRProperty.create(self, 'security', 'BackboneElement', false, TFhirCapabilityStatementRestSecurity, FSecurity.Link));
  oList.add(TFHIRProperty.create(self, 'resource', 'BackboneElement', true, TFhirCapabilityStatementRestResource, FResourceList.Link));
  oList.add(TFHIRProperty.create(self, 'interaction', 'BackboneElement', true, TFhirCapabilityStatementRestInteraction, FInteractionList.Link));
  oList.add(TFHIRProperty.create(self, 'searchParam', '', true, TFhirCapabilityStatementRestResourceSearchParam, FSearchParamList.Link));
  oList.add(TFHIRProperty.create(self, 'operation', '', true, TFhirCapabilityStatementRestResourceOperation, FOperationList.Link));
  oList.add(TFHIRProperty.create(self, 'compartment', 'canonical', true, TFhirCanonical, FCompartmentList.Link));
end;

function TFhirCapabilityStatementRest.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'mode') then
  begin
    ModeElement := asEnum(SYSTEMS_TFhirRestfulCapabilityModeEnum, CODES_TFhirRestfulCapabilityModeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'documentation') then
  begin
    DocumentationElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'security') then
  begin
    Security := propValue as TFhirCapabilityStatementRestSecurity;
    result := propValue;
  end
  else if (propName = 'resource') then
  begin
    ResourceList.add(propValue as TFhirCapabilityStatementRestResource);
    result := propValue;
  end
  else if (propName = 'interaction') then
  begin
    InteractionList.add(propValue as TFhirCapabilityStatementRestInteraction);
    result := propValue;
  end
  else if (propName = 'searchParam') then
  begin
    SearchParamList.add(propValue as TFhirCapabilityStatementRestResourceSearchParam);
    result := propValue;
  end
  else if (propName = 'operation') then
  begin
    OperationList.add(propValue as TFhirCapabilityStatementRestResourceOperation);
    result := propValue;
  end
  else if (propName = 'compartment') then
  begin
    CompartmentList.add(asCanonical(propValue)){2};     result := propValue;

  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCapabilityStatementRest.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'resource') then ResourceList.insertItem(index, propValue as TFhirCapabilityStatementRestResource)
  else if (propName = 'interaction') then InteractionList.insertItem(index, propValue as TFhirCapabilityStatementRestInteraction)
  else if (propName = 'searchParam') then SearchParamList.insertItem(index, propValue as TFhirCapabilityStatementRestResourceSearchParam)
  else if (propName = 'operation') then OperationList.insertItem(index, propValue as TFhirCapabilityStatementRestResourceOperation)
  else if (propName = 'compartment') then CompartmentList.insertItem(index, asCanonical(propValue))
  else inherited;
end;

function TFhirCapabilityStatementRest.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'mode') then result := TFhirEnum.create(SYSTEMS_TFhirRestfulCapabilityModeEnum[RestfulCapabilityModeNull], CODES_TFhirRestfulCapabilityModeEnum[RestfulCapabilityModeNull]) 
  else if (propName = 'documentation') then result := TFhirMarkdown.create()
  else if (propName = 'security') then result := TFhirCapabilityStatementRestSecurity.create()
  else if (propName = 'resource') then result := ResourceList.new()
  else if (propName = 'interaction') then result := InteractionList.new()
  else if (propName = 'searchParam') then result := SearchParamList.new()
  else if (propName = 'operation') then result := OperationList.new()
  else if (propName = 'compartment') then result := CompartmentList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirCapabilityStatementRest.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'mode') then result := 'code'
  else if (propName = 'documentation') then result := 'markdown'
  else if (propName = 'security') then result := 'BackboneElement'
  else if (propName = 'resource') then result := 'BackboneElement'
  else if (propName = 'interaction') then result := 'BackboneElement'
  else if (propName = 'searchParam') then result := ''
  else if (propName = 'operation') then result := ''
  else if (propName = 'compartment') then result := 'canonical'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCapabilityStatementRest.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'mode') then ModeElement := nil
  else if (propName = 'documentation') then DocumentationElement := nil
  else if (propName = 'security') then SecurityElement := nil
  else if (propName = 'resource') then deletePropertyValue('resource', ResourceList, value)
  else if (propName = 'interaction') then deletePropertyValue('interaction', InteractionList, value)
  else if (propName = 'searchParam') then deletePropertyValue('searchParam', SearchParamList, value)
  else if (propName = 'operation') then deletePropertyValue('operation', OperationList, value)
  else if (propName = 'compartment') then deletePropertyValue('compartment', CompartmentList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCapabilityStatementRest.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'mode') then ModeElement := asEnum(SYSTEMS_TFhirRestfulCapabilityModeEnum, CODES_TFhirRestfulCapabilityModeEnum, new)
  else if (propName = 'documentation') then DocumentationElement := asMarkdown(new)
  else if (propName = 'security') then SecurityElement := new as TFhirCapabilityStatementRestSecurity
  else if (propName = 'resource') then replacePropertyValue('resource', ResourceList, existing, new)
  else if (propName = 'interaction') then replacePropertyValue('interaction', InteractionList, existing, new)
  else if (propName = 'searchParam') then replacePropertyValue('searchParam', SearchParamList, existing, new)
  else if (propName = 'operation') then replacePropertyValue('operation', OperationList, existing, new)
  else if (propName = 'compartment') then replacePropertyValue('compartment', CompartmentList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCapabilityStatementRest.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'resource') then ResourceList.move(source, destination)
  else if (propName = 'interaction') then InteractionList.move(source, destination)
  else if (propName = 'searchParam') then SearchParamList.move(source, destination)
  else if (propName = 'operation') then OperationList.move(source, destination)
  else if (propName = 'compartment') then CompartmentList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCapabilityStatementRest.fhirType : string;
begin
  result := 'CapabilityStatement.rest';
end;

function TFhirCapabilityStatementRest.Link : TFhirCapabilityStatementRest;
begin
  result := TFhirCapabilityStatementRest(inherited Link);
end;

function TFhirCapabilityStatementRest.Clone : TFhirCapabilityStatementRest;
begin
  result := TFhirCapabilityStatementRest(inherited Clone);
end;

function TFhirCapabilityStatementRest.equals(other : TObject) : boolean; 
var
  o : TFhirCapabilityStatementRest;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCapabilityStatementRest)) then
    result := false
  else
  begin
    o := TFhirCapabilityStatementRest(other);
    result := compareDeep(modeElement, o.modeElement, true) and compareDeep(documentationElement, o.documentationElement, true) and 
      compareDeep(securityElement, o.securityElement, true) and compareDeep(resourceList, o.resourceList, true) and 
      compareDeep(interactionList, o.interactionList, true) and compareDeep(searchParamList, o.searchParamList, true) and 
      compareDeep(operationList, o.operationList, true) and compareDeep(compartmentList, o.compartmentList, true);
  end;
end;

function TFhirCapabilityStatementRest.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FMode) and isEmptyProp(FDocumentation) and isEmptyProp(FSecurity) and isEmptyProp(FresourceList) and isEmptyProp(FinteractionList) and isEmptyProp(FsearchParamList) and isEmptyProp(FoperationList) and isEmptyProp(FcompartmentList);
end;

procedure TFhirCapabilityStatementRest.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('mode');
  fields.add('documentation');
  fields.add('security');
  fields.add('resource');
  fields.add('interaction');
  fields.add('searchParam');
  fields.add('operation');
  fields.add('compartment');
end;

function TFhirCapabilityStatementRest.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FResourceList.sizeInBytes(magic));
  inc(result, FInteractionList.sizeInBytes(magic));
  inc(result, FSearchParamList.sizeInBytes(magic));
  inc(result, FOperationList.sizeInBytes(magic));
  inc(result, FCompartmentList.sizeInBytes(magic));
end;

procedure TFhirCapabilityStatementRest.SetMode(value : TFhirEnum);
begin
  FMode.free;
  FMode := value;
end;

function TFhirCapabilityStatementRest.GetModeST : TFhirRestfulCapabilityModeEnum;
begin
  if FMode = nil then
    result := TFhirRestfulCapabilityModeEnum(0)
  else
    result := TFhirRestfulCapabilityModeEnum(StringArrayIndexOfSensitive(CODES_TFhirRestfulCapabilityModeEnum, FMode.value));
end;

procedure TFhirCapabilityStatementRest.SetModeST(value : TFhirRestfulCapabilityModeEnum);
begin
  if ord(value) = 0 then
    ModeElement := nil
  else
    ModeElement := TFhirEnum.create(SYSTEMS_TFhirRestfulCapabilityModeEnum[value], CODES_TFhirRestfulCapabilityModeEnum[value]);
end;

procedure TFhirCapabilityStatementRest.SetDocumentation(value : TFhirMarkdown);
begin
  FDocumentation.free;
  FDocumentation := value;
end;

function TFhirCapabilityStatementRest.GetDocumentationST : String;
begin
  if FDocumentation = nil then
    result := ''
  else
    result := FDocumentation.value;
end;

procedure TFhirCapabilityStatementRest.SetDocumentationST(value : String);
begin
  if value <> '' then
  begin
    if FDocumentation = nil then
      FDocumentation := TFhirMarkdown.create;
    FDocumentation.value := value
  end
  else if FDocumentation <> nil then
    FDocumentation.value := '';
end;

procedure TFhirCapabilityStatementRest.SetSecurity(value : TFhirCapabilityStatementRestSecurity);
begin
  FSecurity.free;
  FSecurity := value;
end;

function TFhirCapabilityStatementRest.GetResourceList : TFhirCapabilityStatementRestResourceList;
begin
  if FResourceList = nil then
    FResourceList := TFhirCapabilityStatementRestResourceList.Create;
  result := FResourceList;
end;

function TFhirCapabilityStatementRest.GetHasResourceList : boolean;
begin
  result := (FResourceList <> nil) and (FResourceList.count > 0);
end;

function TFhirCapabilityStatementRest.GetInteractionList : TFhirCapabilityStatementRestInteractionList;
begin
  if FInteractionList = nil then
    FInteractionList := TFhirCapabilityStatementRestInteractionList.Create;
  result := FInteractionList;
end;

function TFhirCapabilityStatementRest.GetHasInteractionList : boolean;
begin
  result := (FInteractionList <> nil) and (FInteractionList.count > 0);
end;

function TFhirCapabilityStatementRest.GetSearchParamList : TFhirCapabilityStatementRestResourceSearchParamList;
begin
  if FSearchParamList = nil then
    FSearchParamList := TFhirCapabilityStatementRestResourceSearchParamList.Create;
  result := FSearchParamList;
end;

function TFhirCapabilityStatementRest.GetHasSearchParamList : boolean;
begin
  result := (FSearchParamList <> nil) and (FSearchParamList.count > 0);
end;

function TFhirCapabilityStatementRest.GetOperationList : TFhirCapabilityStatementRestResourceOperationList;
begin
  if FOperationList = nil then
    FOperationList := TFhirCapabilityStatementRestResourceOperationList.Create;
  result := FOperationList;
end;

function TFhirCapabilityStatementRest.GetHasOperationList : boolean;
begin
  result := (FOperationList <> nil) and (FOperationList.count > 0);
end;

function TFhirCapabilityStatementRest.GetCompartmentList : TFhirCanonicalList;
begin
  if FCompartmentList = nil then
    FCompartmentList := TFhirCanonicalList.Create;
  result := FCompartmentList;
end;

function TFhirCapabilityStatementRest.GetHasCompartmentList : boolean;
begin
  result := (FCompartmentList <> nil) and (FCompartmentList.count > 0);
end;

{ TFhirCapabilityStatementRestListEnumerator }

constructor TFhirCapabilityStatementRestListEnumerator.Create(list : TFhirCapabilityStatementRestList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCapabilityStatementRestListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCapabilityStatementRestListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCapabilityStatementRestListEnumerator.GetCurrent : TFhirCapabilityStatementRest;
begin
  Result := FList[FIndex];
end;

function TFhirCapabilityStatementRestListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCapabilityStatementRestList }

function TFhirCapabilityStatementRestList.AddItem(value: TFhirCapabilityStatementRest): TFhirCapabilityStatementRest;
begin
  assert(value.ClassName = 'TFhirCapabilityStatementRest', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCapabilityStatementRest');
  add(value);
  result := value;
end;

function TFhirCapabilityStatementRestList.Append: TFhirCapabilityStatementRest;
begin
  result := TFhirCapabilityStatementRest.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCapabilityStatementRestList.ClearItems;
begin
  Clear;
end;

function TFhirCapabilityStatementRestList.GetEnumerator : TFhirCapabilityStatementRestListEnumerator;
begin
  result := TFhirCapabilityStatementRestListEnumerator.Create(self.link);
end;

function TFhirCapabilityStatementRestList.Clone: TFhirCapabilityStatementRestList;
begin
  result := TFhirCapabilityStatementRestList(inherited Clone);
end;

function TFhirCapabilityStatementRestList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCapabilityStatementRestList.GetItemN(index: Integer): TFhirCapabilityStatementRest;
begin
  result := TFhirCapabilityStatementRest(ObjectByIndex[index]);
end;

function TFhirCapabilityStatementRestList.ItemClass: TFslObjectClass;
begin
  result := TFhirCapabilityStatementRest;
end;
function TFhirCapabilityStatementRestList.IndexOf(value: TFhirCapabilityStatementRest): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCapabilityStatementRestList.Insert(index: Integer): TFhirCapabilityStatementRest;
begin
  result := TFhirCapabilityStatementRest.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCapabilityStatementRestList.InsertItem(index: Integer; value: TFhirCapabilityStatementRest);
begin
  assert(value is TFhirCapabilityStatementRest);
  Inherited Insert(index, value);
end;

function TFhirCapabilityStatementRestList.Item(index: Integer): TFhirCapabilityStatementRest;
begin
  result := TFhirCapabilityStatementRest(ObjectByIndex[index]);
end;

function TFhirCapabilityStatementRestList.Link: TFhirCapabilityStatementRestList;
begin
  result := TFhirCapabilityStatementRestList(inherited Link);
end;

procedure TFhirCapabilityStatementRestList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCapabilityStatementRestList.SetItemByIndex(index: Integer; value: TFhirCapabilityStatementRest);
begin
  assert(value is TFhirCapabilityStatementRest);
  FhirCapabilityStatementRests[index] := value;
end;

procedure TFhirCapabilityStatementRestList.SetItemN(index: Integer; value: TFhirCapabilityStatementRest);
begin
  assert(value is TFhirCapabilityStatementRest);
  ObjectByIndex[index] := value;
end;

{ TFhirCapabilityStatementRestSecurity }

constructor TFhirCapabilityStatementRestSecurity.Create;
begin
  inherited;
end;

destructor TFhirCapabilityStatementRestSecurity.Destroy;
begin
  FCors.free;
  FServiceList.Free;
  FDescription.free;
  inherited;
end;

procedure TFhirCapabilityStatementRestSecurity.Assign(oSource : TFslObject);
begin
  inherited;
  corsElement := TFhirCapabilityStatementRestSecurity(oSource).corsElement.Clone;
  if (TFhirCapabilityStatementRestSecurity(oSource).FServiceList = nil) then
  begin
    FServiceList.free;
    FServiceList := nil;
  end
  else
  begin
    if FServiceList = nil then
      FServiceList := TFhirCodeableConceptList.Create;
    FServiceList.Assign(TFhirCapabilityStatementRestSecurity(oSource).FServiceList);
  end;
  descriptionElement := TFhirCapabilityStatementRestSecurity(oSource).descriptionElement.Clone;
end;

procedure TFhirCapabilityStatementRestSecurity.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'cors') Then
     list.add(self.link, 'cors', FCors.Link);
  if (child_name = 'service') Then
    list.addAll(self, 'service', FServiceList);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
end;

procedure TFhirCapabilityStatementRestSecurity.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'cors', 'boolean', false, TFhirBoolean, FCors.Link));
  oList.add(TFHIRProperty.create(self, 'service', 'CodeableConcept', true, TFhirCodeableConcept, FServiceList.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'markdown', false, TFhirMarkdown, FDescription.Link));
end;

function TFhirCapabilityStatementRestSecurity.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'cors') then
  begin
    CorsElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'service') then
  begin
    ServiceList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asMarkdown(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCapabilityStatementRestSecurity.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'service') then ServiceList.insertItem(index, propValue as TFhirCodeableConcept)
  else inherited;
end;

function TFhirCapabilityStatementRestSecurity.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'cors') then result := TFhirBoolean.create()
  else if (propName = 'service') then result := ServiceList.new()
  else if (propName = 'description') then result := TFhirMarkdown.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirCapabilityStatementRestSecurity.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'cors') then result := 'boolean'
  else if (propName = 'service') then result := 'CodeableConcept'
  else if (propName = 'description') then result := 'markdown'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCapabilityStatementRestSecurity.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'cors') then CorsElement := nil
  else if (propName = 'service') then deletePropertyValue('service', ServiceList, value)
  else if (propName = 'description') then DescriptionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCapabilityStatementRestSecurity.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'cors') then CorsElement := asBoolean(new)
  else if (propName = 'service') then replacePropertyValue('service', ServiceList, existing, new)
  else if (propName = 'description') then DescriptionElement := asMarkdown(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCapabilityStatementRestSecurity.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'service') then ServiceList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCapabilityStatementRestSecurity.fhirType : string;
begin
  result := 'CapabilityStatement.rest.security';
end;

function TFhirCapabilityStatementRestSecurity.Link : TFhirCapabilityStatementRestSecurity;
begin
  result := TFhirCapabilityStatementRestSecurity(inherited Link);
end;

function TFhirCapabilityStatementRestSecurity.Clone : TFhirCapabilityStatementRestSecurity;
begin
  result := TFhirCapabilityStatementRestSecurity(inherited Clone);
end;

function TFhirCapabilityStatementRestSecurity.equals(other : TObject) : boolean; 
var
  o : TFhirCapabilityStatementRestSecurity;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCapabilityStatementRestSecurity)) then
    result := false
  else
  begin
    o := TFhirCapabilityStatementRestSecurity(other);
    result := compareDeep(corsElement, o.corsElement, true) and compareDeep(serviceList, o.serviceList, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true);
  end;
end;

function TFhirCapabilityStatementRestSecurity.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCors) and isEmptyProp(FserviceList) and isEmptyProp(FDescription);
end;

procedure TFhirCapabilityStatementRestSecurity.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('cors');
  fields.add('service');
  fields.add('description');
end;

function TFhirCapabilityStatementRestSecurity.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FServiceList.sizeInBytes(magic));
end;

procedure TFhirCapabilityStatementRestSecurity.SetCors(value : TFhirBoolean);
begin
  FCors.free;
  FCors := value;
end;

function TFhirCapabilityStatementRestSecurity.GetCorsST : Boolean;
begin
  if FCors = nil then
    result := false
  else
    result := FCors.value;
end;

procedure TFhirCapabilityStatementRestSecurity.SetCorsST(value : Boolean);
begin
  if FCors = nil then
    FCors := TFhirBoolean.create;
  FCors.value := value
end;

function TFhirCapabilityStatementRestSecurity.GetServiceList : TFhirCodeableConceptList;
begin
  if FServiceList = nil then
    FServiceList := TFhirCodeableConceptList.Create;
  result := FServiceList;
end;

function TFhirCapabilityStatementRestSecurity.GetHasServiceList : boolean;
begin
  result := (FServiceList <> nil) and (FServiceList.count > 0);
end;

procedure TFhirCapabilityStatementRestSecurity.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirCapabilityStatementRestSecurity.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirCapabilityStatementRestSecurity.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

{ TFhirCapabilityStatementRestSecurityListEnumerator }

constructor TFhirCapabilityStatementRestSecurityListEnumerator.Create(list : TFhirCapabilityStatementRestSecurityList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCapabilityStatementRestSecurityListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCapabilityStatementRestSecurityListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCapabilityStatementRestSecurityListEnumerator.GetCurrent : TFhirCapabilityStatementRestSecurity;
begin
  Result := FList[FIndex];
end;

function TFhirCapabilityStatementRestSecurityListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCapabilityStatementRestSecurityList }

function TFhirCapabilityStatementRestSecurityList.AddItem(value: TFhirCapabilityStatementRestSecurity): TFhirCapabilityStatementRestSecurity;
begin
  assert(value.ClassName = 'TFhirCapabilityStatementRestSecurity', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCapabilityStatementRestSecurity');
  add(value);
  result := value;
end;

function TFhirCapabilityStatementRestSecurityList.Append: TFhirCapabilityStatementRestSecurity;
begin
  result := TFhirCapabilityStatementRestSecurity.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCapabilityStatementRestSecurityList.ClearItems;
begin
  Clear;
end;

function TFhirCapabilityStatementRestSecurityList.GetEnumerator : TFhirCapabilityStatementRestSecurityListEnumerator;
begin
  result := TFhirCapabilityStatementRestSecurityListEnumerator.Create(self.link);
end;

function TFhirCapabilityStatementRestSecurityList.Clone: TFhirCapabilityStatementRestSecurityList;
begin
  result := TFhirCapabilityStatementRestSecurityList(inherited Clone);
end;

function TFhirCapabilityStatementRestSecurityList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCapabilityStatementRestSecurityList.GetItemN(index: Integer): TFhirCapabilityStatementRestSecurity;
begin
  result := TFhirCapabilityStatementRestSecurity(ObjectByIndex[index]);
end;

function TFhirCapabilityStatementRestSecurityList.ItemClass: TFslObjectClass;
begin
  result := TFhirCapabilityStatementRestSecurity;
end;
function TFhirCapabilityStatementRestSecurityList.IndexOf(value: TFhirCapabilityStatementRestSecurity): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCapabilityStatementRestSecurityList.Insert(index: Integer): TFhirCapabilityStatementRestSecurity;
begin
  result := TFhirCapabilityStatementRestSecurity.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCapabilityStatementRestSecurityList.InsertItem(index: Integer; value: TFhirCapabilityStatementRestSecurity);
begin
  assert(value is TFhirCapabilityStatementRestSecurity);
  Inherited Insert(index, value);
end;

function TFhirCapabilityStatementRestSecurityList.Item(index: Integer): TFhirCapabilityStatementRestSecurity;
begin
  result := TFhirCapabilityStatementRestSecurity(ObjectByIndex[index]);
end;

function TFhirCapabilityStatementRestSecurityList.Link: TFhirCapabilityStatementRestSecurityList;
begin
  result := TFhirCapabilityStatementRestSecurityList(inherited Link);
end;

procedure TFhirCapabilityStatementRestSecurityList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCapabilityStatementRestSecurityList.SetItemByIndex(index: Integer; value: TFhirCapabilityStatementRestSecurity);
begin
  assert(value is TFhirCapabilityStatementRestSecurity);
  FhirCapabilityStatementRestSecurities[index] := value;
end;

procedure TFhirCapabilityStatementRestSecurityList.SetItemN(index: Integer; value: TFhirCapabilityStatementRestSecurity);
begin
  assert(value is TFhirCapabilityStatementRestSecurity);
  ObjectByIndex[index] := value;
end;

{ TFhirCapabilityStatementRestResource }

constructor TFhirCapabilityStatementRestResource.Create;
begin
  inherited;
end;

destructor TFhirCapabilityStatementRestResource.Destroy;
begin
  FType_.free;
  FProfile.free;
  FSupportedProfileList.Free;
  FDocumentation.free;
  FInteractionList.Free;
  FVersioning.free;
  FReadHistory.free;
  FUpdateCreate.free;
  FConditionalCreate.free;
  FConditionalRead.free;
  FConditionalUpdate.free;
  FConditionalDelete.free;
  FReferencePolicy.Free;
  FSearchIncludeList.Free;
  FSearchRevIncludeList.Free;
  FSearchParamList.Free;
  FOperationList.Free;
  inherited;
end;

procedure TFhirCapabilityStatementRestResource.Assign(oSource : TFslObject);
begin
  inherited;
  type_Element := TFhirCapabilityStatementRestResource(oSource).type_Element.Clone;
  profileElement := TFhirCapabilityStatementRestResource(oSource).profileElement.Clone;
  if (TFhirCapabilityStatementRestResource(oSource).FSupportedProfileList = nil) then
  begin
    FSupportedProfileList.free;
    FSupportedProfileList := nil;
  end
  else
  begin
    if FSupportedProfileList = nil then
      FSupportedProfileList := TFhirCanonicalList.Create;
    FSupportedProfileList.Assign(TFhirCapabilityStatementRestResource(oSource).FSupportedProfileList);
  end;
  documentationElement := TFhirCapabilityStatementRestResource(oSource).documentationElement.Clone;
  if (TFhirCapabilityStatementRestResource(oSource).FInteractionList = nil) then
  begin
    FInteractionList.free;
    FInteractionList := nil;
  end
  else
  begin
    if FInteractionList = nil then
      FInteractionList := TFhirCapabilityStatementRestResourceInteractionList.Create;
    FInteractionList.Assign(TFhirCapabilityStatementRestResource(oSource).FInteractionList);
  end;
  versioningElement := TFhirCapabilityStatementRestResource(oSource).versioningElement.Clone;
  readHistoryElement := TFhirCapabilityStatementRestResource(oSource).readHistoryElement.Clone;
  updateCreateElement := TFhirCapabilityStatementRestResource(oSource).updateCreateElement.Clone;
  conditionalCreateElement := TFhirCapabilityStatementRestResource(oSource).conditionalCreateElement.Clone;
  conditionalReadElement := TFhirCapabilityStatementRestResource(oSource).conditionalReadElement.Clone;
  conditionalUpdateElement := TFhirCapabilityStatementRestResource(oSource).conditionalUpdateElement.Clone;
  conditionalDeleteElement := TFhirCapabilityStatementRestResource(oSource).conditionalDeleteElement.Clone;
  if (TFhirCapabilityStatementRestResource(oSource).FReferencePolicy = nil) then
  begin
    FReferencePolicy.free;
    FReferencePolicy := nil;
  end
  else
  begin
    FReferencePolicy := TFhirEnumList.Create(SYSTEMS_TFhirReferenceHandlingPolicyEnum, CODES_TFhirReferenceHandlingPolicyEnum);
    FReferencePolicy.Assign(TFhirCapabilityStatementRestResource(oSource).FReferencePolicy);
  end;
  if (TFhirCapabilityStatementRestResource(oSource).FSearchIncludeList = nil) then
  begin
    FSearchIncludeList.free;
    FSearchIncludeList := nil;
  end
  else
  begin
    if FSearchIncludeList = nil then
      FSearchIncludeList := TFhirStringList.Create;
    FSearchIncludeList.Assign(TFhirCapabilityStatementRestResource(oSource).FSearchIncludeList);
  end;
  if (TFhirCapabilityStatementRestResource(oSource).FSearchRevIncludeList = nil) then
  begin
    FSearchRevIncludeList.free;
    FSearchRevIncludeList := nil;
  end
  else
  begin
    if FSearchRevIncludeList = nil then
      FSearchRevIncludeList := TFhirStringList.Create;
    FSearchRevIncludeList.Assign(TFhirCapabilityStatementRestResource(oSource).FSearchRevIncludeList);
  end;
  if (TFhirCapabilityStatementRestResource(oSource).FSearchParamList = nil) then
  begin
    FSearchParamList.free;
    FSearchParamList := nil;
  end
  else
  begin
    if FSearchParamList = nil then
      FSearchParamList := TFhirCapabilityStatementRestResourceSearchParamList.Create;
    FSearchParamList.Assign(TFhirCapabilityStatementRestResource(oSource).FSearchParamList);
  end;
  if (TFhirCapabilityStatementRestResource(oSource).FOperationList = nil) then
  begin
    FOperationList.free;
    FOperationList := nil;
  end
  else
  begin
    if FOperationList = nil then
      FOperationList := TFhirCapabilityStatementRestResourceOperationList.Create;
    FOperationList.Assign(TFhirCapabilityStatementRestResource(oSource).FOperationList);
  end;
end;

procedure TFhirCapabilityStatementRestResource.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'profile') Then
     list.add(self.link, 'profile', FProfile.Link);
  if (child_name = 'supportedProfile') Then
    list.addAll(self, 'supportedProfile', FSupportedProfileList);
  if (child_name = 'documentation') Then
     list.add(self.link, 'documentation', FDocumentation.Link);
  if (child_name = 'interaction') Then
    list.addAll(self, 'interaction', FInteractionList);
  if (child_name = 'versioning') Then
     list.add(self.link, 'versioning', FVersioning.Link);
  if (child_name = 'readHistory') Then
     list.add(self.link, 'readHistory', FReadHistory.Link);
  if (child_name = 'updateCreate') Then
     list.add(self.link, 'updateCreate', FUpdateCreate.Link);
  if (child_name = 'conditionalCreate') Then
     list.add(self.link, 'conditionalCreate', FConditionalCreate.Link);
  if (child_name = 'conditionalRead') Then
     list.add(self.link, 'conditionalRead', FConditionalRead.Link);
  if (child_name = 'conditionalUpdate') Then
     list.add(self.link, 'conditionalUpdate', FConditionalUpdate.Link);
  if (child_name = 'conditionalDelete') Then
     list.add(self.link, 'conditionalDelete', FConditionalDelete.Link);
  if (child_name = 'referencePolicy') Then
     list.addAll(self, 'referencePolicy', FReferencePolicy);
  if (child_name = 'searchInclude') Then
    list.addAll(self, 'searchInclude', FSearchIncludeList);
  if (child_name = 'searchRevInclude') Then
    list.addAll(self, 'searchRevInclude', FSearchRevIncludeList);
  if (child_name = 'searchParam') Then
    list.addAll(self, 'searchParam', FSearchParamList);
  if (child_name = 'operation') Then
    list.addAll(self, 'operation', FOperationList);
end;

procedure TFhirCapabilityStatementRestResource.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFhirEnum, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'profile', 'canonical', false, TFhirCanonical, FProfile.Link));
  oList.add(TFHIRProperty.create(self, 'supportedProfile', 'canonical', true, TFhirCanonical, FSupportedProfileList.Link));
  oList.add(TFHIRProperty.create(self, 'documentation', 'markdown', false, TFhirMarkdown, FDocumentation.Link));
  oList.add(TFHIRProperty.create(self, 'interaction', 'BackboneElement', true, TFhirCapabilityStatementRestResourceInteraction, FInteractionList.Link));
  oList.add(TFHIRProperty.create(self, 'versioning', 'code', false, TFhirEnum, FVersioning.Link));
  oList.add(TFHIRProperty.create(self, 'readHistory', 'boolean', false, TFhirBoolean, FReadHistory.Link));
  oList.add(TFHIRProperty.create(self, 'updateCreate', 'boolean', false, TFhirBoolean, FUpdateCreate.Link));
  oList.add(TFHIRProperty.create(self, 'conditionalCreate', 'boolean', false, TFhirBoolean, FConditionalCreate.Link));
  oList.add(TFHIRProperty.create(self, 'conditionalRead', 'code', false, TFhirEnum, FConditionalRead.Link));
  oList.add(TFHIRProperty.create(self, 'conditionalUpdate', 'boolean', false, TFhirBoolean, FConditionalUpdate.Link));
  oList.add(TFHIRProperty.create(self, 'conditionalDelete', 'code', false, TFhirEnum, FConditionalDelete.Link));
  oList.add(TFHIRProperty.create(self, 'referencePolicy', 'code', true, TFhirEnum, FReferencePolicy.Link));
  oList.add(TFHIRProperty.create(self, 'searchInclude', 'string', true, TFhirString, FSearchIncludeList.Link));
  oList.add(TFHIRProperty.create(self, 'searchRevInclude', 'string', true, TFhirString, FSearchRevIncludeList.Link));
  oList.add(TFHIRProperty.create(self, 'searchParam', 'BackboneElement', true, TFhirCapabilityStatementRestResourceSearchParam, FSearchParamList.Link));
  oList.add(TFHIRProperty.create(self, 'operation', 'BackboneElement', true, TFhirCapabilityStatementRestResourceOperation, FOperationList.Link));
end;

function TFhirCapabilityStatementRestResource.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum, propValue);
    result := propValue;
  end
  else if (propName = 'profile') then
  begin
    ProfileElement := asCanonical(propValue);
    result := propValue;
  end
  else if (propName = 'supportedProfile') then
  begin
    SupportedProfileList.add(asCanonical(propValue)){2};     result := propValue;

  end
  else if (propName = 'documentation') then
  begin
    DocumentationElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'interaction') then
  begin
    InteractionList.add(propValue as TFhirCapabilityStatementRestResourceInteraction);
    result := propValue;
  end
  else if (propName = 'versioning') then
  begin
    VersioningElement := asEnum(SYSTEMS_TFhirResourceVersionPolicyEnum, CODES_TFhirResourceVersionPolicyEnum, propValue);
    result := propValue;
  end
  else if (propName = 'readHistory') then
  begin
    ReadHistoryElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'updateCreate') then
  begin
    UpdateCreateElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'conditionalCreate') then
  begin
    ConditionalCreateElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'conditionalRead') then
  begin
    ConditionalReadElement := asEnum(SYSTEMS_TFhirConditionalReadStatusEnum, CODES_TFhirConditionalReadStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'conditionalUpdate') then
  begin
    ConditionalUpdateElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'conditionalDelete') then
  begin
    ConditionalDeleteElement := asEnum(SYSTEMS_TFhirConditionalDeleteStatusEnum, CODES_TFhirConditionalDeleteStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'referencePolicy') then
  begin
    ReferencePolicyList.add(asEnum(SYSTEMS_TFhirReferenceHandlingPolicyEnum, CODES_TFhirReferenceHandlingPolicyEnum, propValue));
    result := propValue;
  end
  else if (propName = 'searchInclude') then
  begin
    SearchIncludeList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'searchRevInclude') then
  begin
    SearchRevIncludeList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'searchParam') then
  begin
    SearchParamList.add(propValue as TFhirCapabilityStatementRestResourceSearchParam);
    result := propValue;
  end
  else if (propName = 'operation') then
  begin
    OperationList.add(propValue as TFhirCapabilityStatementRestResourceOperation);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCapabilityStatementRestResource.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'supportedProfile') then SupportedProfileList.insertItem(index, asCanonical(propValue))
  else if (propName = 'interaction') then InteractionList.insertItem(index, propValue as TFhirCapabilityStatementRestResourceInteraction)
  else if (propName = 'referencePolicy') then FReferencePolicy.insertItem(index, asEnum(SYSTEMS_TFhirReferenceHandlingPolicyEnum, CODES_TFhirReferenceHandlingPolicyEnum, propValue))
  else if (propName = 'searchInclude') then SearchIncludeList.insertItem(index, asString(propValue))
  else if (propName = 'searchRevInclude') then SearchRevIncludeList.insertItem(index, asString(propValue))
  else if (propName = 'searchParam') then SearchParamList.insertItem(index, propValue as TFhirCapabilityStatementRestResourceSearchParam)
  else if (propName = 'operation') then OperationList.insertItem(index, propValue as TFhirCapabilityStatementRestResourceOperation)
  else inherited;
end;

function TFhirCapabilityStatementRestResource.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirEnum.create(SYSTEMS_TFhirResourceTypesEnum[ResourceTypesNull], CODES_TFhirResourceTypesEnum[ResourceTypesNull]) 
  else if (propName = 'profile') then result := TFhirCanonical.create()
  else if (propName = 'supportedProfile') then result := SupportedProfileList.new()
  else if (propName = 'documentation') then result := TFhirMarkdown.create()
  else if (propName = 'interaction') then result := InteractionList.new()
  else if (propName = 'versioning') then result := TFhirEnum.create(SYSTEMS_TFhirResourceVersionPolicyEnum[ResourceVersionPolicyNull], CODES_TFhirResourceVersionPolicyEnum[ResourceVersionPolicyNull]) 
  else if (propName = 'readHistory') then result := TFhirBoolean.create()
  else if (propName = 'updateCreate') then result := TFhirBoolean.create()
  else if (propName = 'conditionalCreate') then result := TFhirBoolean.create()
  else if (propName = 'conditionalRead') then result := TFhirEnum.create(SYSTEMS_TFhirConditionalReadStatusEnum[ConditionalReadStatusNull], CODES_TFhirConditionalReadStatusEnum[ConditionalReadStatusNull]) 
  else if (propName = 'conditionalUpdate') then result := TFhirBoolean.create()
  else if (propName = 'conditionalDelete') then result := TFhirEnum.create(SYSTEMS_TFhirConditionalDeleteStatusEnum[ConditionalDeleteStatusNull], CODES_TFhirConditionalDeleteStatusEnum[ConditionalDeleteStatusNull]) 
  else if (propName = 'searchInclude') then result := SearchIncludeList.new()
  else if (propName = 'searchRevInclude') then result := SearchRevIncludeList.new()
  else if (propName = 'searchParam') then result := SearchParamList.new()
  else if (propName = 'operation') then result := OperationList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirCapabilityStatementRestResource.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'code'
  else if (propName = 'profile') then result := 'canonical'
  else if (propName = 'supportedProfile') then result := 'canonical'
  else if (propName = 'documentation') then result := 'markdown'
  else if (propName = 'interaction') then result := 'BackboneElement'
  else if (propName = 'versioning') then result := 'code'
  else if (propName = 'readHistory') then result := 'boolean'
  else if (propName = 'updateCreate') then result := 'boolean'
  else if (propName = 'conditionalCreate') then result := 'boolean'
  else if (propName = 'conditionalRead') then result := 'code'
  else if (propName = 'conditionalUpdate') then result := 'boolean'
  else if (propName = 'conditionalDelete') then result := 'code'
  else if (propName = 'referencePolicy') then result := 'code'
  else if (propName = 'searchInclude') then result := 'string'
  else if (propName = 'searchRevInclude') then result := 'string'
  else if (propName = 'searchParam') then result := 'BackboneElement'
  else if (propName = 'operation') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCapabilityStatementRestResource.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'profile') then ProfileElement := nil
  else if (propName = 'supportedProfile') then deletePropertyValue('supportedProfile', SupportedProfileList, value)
  else if (propName = 'documentation') then DocumentationElement := nil
  else if (propName = 'interaction') then deletePropertyValue('interaction', InteractionList, value)
  else if (propName = 'versioning') then VersioningElement := nil
  else if (propName = 'readHistory') then ReadHistoryElement := nil
  else if (propName = 'updateCreate') then UpdateCreateElement := nil
  else if (propName = 'conditionalCreate') then ConditionalCreateElement := nil
  else if (propName = 'conditionalRead') then ConditionalReadElement := nil
  else if (propName = 'conditionalUpdate') then ConditionalUpdateElement := nil
  else if (propName = 'conditionalDelete') then ConditionalDeleteElement := nil
  else if (propName = 'searchInclude') then deletePropertyValue('searchInclude', SearchIncludeList, value)
  else if (propName = 'searchRevInclude') then deletePropertyValue('searchRevInclude', SearchRevIncludeList, value)
  else if (propName = 'searchParam') then deletePropertyValue('searchParam', SearchParamList, value)
  else if (propName = 'operation') then deletePropertyValue('operation', OperationList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCapabilityStatementRestResource.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum, new)
  else if (propName = 'profile') then ProfileElement := asCanonical(new)
  else if (propName = 'supportedProfile') then replacePropertyValue('supportedProfile', SupportedProfileList, existing, new)
  else if (propName = 'documentation') then DocumentationElement := asMarkdown(new)
  else if (propName = 'interaction') then replacePropertyValue('interaction', InteractionList, existing, new)
  else if (propName = 'versioning') then VersioningElement := asEnum(SYSTEMS_TFhirResourceVersionPolicyEnum, CODES_TFhirResourceVersionPolicyEnum, new)
  else if (propName = 'readHistory') then ReadHistoryElement := asBoolean(new)
  else if (propName = 'updateCreate') then UpdateCreateElement := asBoolean(new)
  else if (propName = 'conditionalCreate') then ConditionalCreateElement := asBoolean(new)
  else if (propName = 'conditionalRead') then ConditionalReadElement := asEnum(SYSTEMS_TFhirConditionalReadStatusEnum, CODES_TFhirConditionalReadStatusEnum, new)
  else if (propName = 'conditionalUpdate') then ConditionalUpdateElement := asBoolean(new)
  else if (propName = 'conditionalDelete') then ConditionalDeleteElement := asEnum(SYSTEMS_TFhirConditionalDeleteStatusEnum, CODES_TFhirConditionalDeleteStatusEnum, new)
  else if (propName = 'searchInclude') then replacePropertyValue('searchInclude', SearchIncludeList, existing, new)
  else if (propName = 'searchRevInclude') then replacePropertyValue('searchRevInclude', SearchRevIncludeList, existing, new)
  else if (propName = 'searchParam') then replacePropertyValue('searchParam', SearchParamList, existing, new)
  else if (propName = 'operation') then replacePropertyValue('operation', OperationList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCapabilityStatementRestResource.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'supportedProfile') then SupportedProfileList.move(source, destination)
  else if (propName = 'interaction') then InteractionList.move(source, destination)
  else if (propName = 'referencePolicy') then FReferencePolicy.move(source, destination)
  else if (propName = 'searchInclude') then SearchIncludeList.move(source, destination)
  else if (propName = 'searchRevInclude') then SearchRevIncludeList.move(source, destination)
  else if (propName = 'searchParam') then SearchParamList.move(source, destination)
  else if (propName = 'operation') then OperationList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCapabilityStatementRestResource.fhirType : string;
begin
  result := 'CapabilityStatement.rest.resource';
end;

function TFhirCapabilityStatementRestResource.Link : TFhirCapabilityStatementRestResource;
begin
  result := TFhirCapabilityStatementRestResource(inherited Link);
end;

function TFhirCapabilityStatementRestResource.Clone : TFhirCapabilityStatementRestResource;
begin
  result := TFhirCapabilityStatementRestResource(inherited Clone);
end;

function TFhirCapabilityStatementRestResource.equals(other : TObject) : boolean; 
var
  o : TFhirCapabilityStatementRestResource;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCapabilityStatementRestResource)) then
    result := false
  else
  begin
    o := TFhirCapabilityStatementRestResource(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(profileElement, o.profileElement, true) and 
      compareDeep(supportedProfileList, o.supportedProfileList, true) and compareDeep(documentationElement, o.documentationElement, true) and 
      compareDeep(interactionList, o.interactionList, true) and compareDeep(versioningElement, o.versioningElement, true) and 
      compareDeep(readHistoryElement, o.readHistoryElement, true) and compareDeep(updateCreateElement, o.updateCreateElement, true) and 
      compareDeep(conditionalCreateElement, o.conditionalCreateElement, true) and compareDeep(conditionalReadElement, o.conditionalReadElement, true) and 
      compareDeep(conditionalUpdateElement, o.conditionalUpdateElement, true) and compareDeep(conditionalDeleteElement, o.conditionalDeleteElement, true) and 
      compareDeep(referencePolicyList, o.referencePolicyList, true) and compareDeep(searchIncludeList, o.searchIncludeList, true) and 
      compareDeep(searchRevIncludeList, o.searchRevIncludeList, true) and compareDeep(searchParamList, o.searchParamList, true) and 
      compareDeep(operationList, o.operationList, true);
  end;
end;

function TFhirCapabilityStatementRestResource.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FProfile) and isEmptyProp(FsupportedProfileList) and isEmptyProp(FDocumentation) and isEmptyProp(FinteractionList) and isEmptyProp(FVersioning) and isEmptyProp(FReadHistory) and isEmptyProp(FUpdateCreate) and isEmptyProp(FConditionalCreate) and isEmptyProp(FConditionalRead) and isEmptyProp(FConditionalUpdate) and isEmptyProp(FConditionalDelete) and isEmptyProp(FReferencePolicy) and isEmptyProp(FsearchIncludeList) and isEmptyProp(FsearchRevIncludeList) and isEmptyProp(FsearchParamList) and isEmptyProp(FoperationList);
end;

procedure TFhirCapabilityStatementRestResource.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('profile');
  fields.add('supportedProfile');
  fields.add('documentation');
  fields.add('interaction');
  fields.add('versioning');
  fields.add('readHistory');
  fields.add('updateCreate');
  fields.add('conditionalCreate');
  fields.add('conditionalRead');
  fields.add('conditionalUpdate');
  fields.add('conditionalDelete');
  fields.add('referencePolicy');
  fields.add('searchInclude');
  fields.add('searchRevInclude');
  fields.add('searchParam');
  fields.add('operation');
end;

function TFhirCapabilityStatementRestResource.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FSupportedProfileList.sizeInBytes(magic));
  inc(result, FInteractionList.sizeInBytes(magic));
  inc(result, FReferencePolicy.sizeInBytes(magic));
  inc(result, FSearchIncludeList.sizeInBytes(magic));
  inc(result, FSearchRevIncludeList.sizeInBytes(magic));
  inc(result, FSearchParamList.sizeInBytes(magic));
  inc(result, FOperationList.sizeInBytes(magic));
end;

procedure TFhirCapabilityStatementRestResource.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirCapabilityStatementRestResource.GetType_ST : TFhirResourceTypesEnum;
begin
  if FType_ = nil then
    result := TFhirResourceTypesEnum(0)
  else
    result := TFhirResourceTypesEnum(StringArrayIndexOfSensitive(CODES_TFhirResourceTypesEnum, FType_.value));
end;

procedure TFhirCapabilityStatementRestResource.SetType_ST(value : TFhirResourceTypesEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirResourceTypesEnum[value], CODES_TFhirResourceTypesEnum[value]);
end;

procedure TFhirCapabilityStatementRestResource.SetProfile(value : TFhirCanonical);
begin
  FProfile.free;
  FProfile := value;
end;

function TFhirCapabilityStatementRestResource.GetProfileST : String;
begin
  if FProfile = nil then
    result := ''
  else
    result := FProfile.value;
end;

procedure TFhirCapabilityStatementRestResource.SetProfileST(value : String);
begin
  if value <> '' then
  begin
    if FProfile = nil then
      FProfile := TFhirCanonical.create;
    FProfile.value := value
  end
  else if FProfile <> nil then
    FProfile.value := '';
end;

function TFhirCapabilityStatementRestResource.GetSupportedProfileList : TFhirCanonicalList;
begin
  if FSupportedProfileList = nil then
    FSupportedProfileList := TFhirCanonicalList.Create;
  result := FSupportedProfileList;
end;

function TFhirCapabilityStatementRestResource.GetHasSupportedProfileList : boolean;
begin
  result := (FSupportedProfileList <> nil) and (FSupportedProfileList.count > 0);
end;

procedure TFhirCapabilityStatementRestResource.SetDocumentation(value : TFhirMarkdown);
begin
  FDocumentation.free;
  FDocumentation := value;
end;

function TFhirCapabilityStatementRestResource.GetDocumentationST : String;
begin
  if FDocumentation = nil then
    result := ''
  else
    result := FDocumentation.value;
end;

procedure TFhirCapabilityStatementRestResource.SetDocumentationST(value : String);
begin
  if value <> '' then
  begin
    if FDocumentation = nil then
      FDocumentation := TFhirMarkdown.create;
    FDocumentation.value := value
  end
  else if FDocumentation <> nil then
    FDocumentation.value := '';
end;

function TFhirCapabilityStatementRestResource.GetInteractionList : TFhirCapabilityStatementRestResourceInteractionList;
begin
  if FInteractionList = nil then
    FInteractionList := TFhirCapabilityStatementRestResourceInteractionList.Create;
  result := FInteractionList;
end;

function TFhirCapabilityStatementRestResource.GetHasInteractionList : boolean;
begin
  result := (FInteractionList <> nil) and (FInteractionList.count > 0);
end;

procedure TFhirCapabilityStatementRestResource.SetVersioning(value : TFhirEnum);
begin
  FVersioning.free;
  FVersioning := value;
end;

function TFhirCapabilityStatementRestResource.GetVersioningST : TFhirResourceVersionPolicyEnum;
begin
  if FVersioning = nil then
    result := TFhirResourceVersionPolicyEnum(0)
  else
    result := TFhirResourceVersionPolicyEnum(StringArrayIndexOfSensitive(CODES_TFhirResourceVersionPolicyEnum, FVersioning.value));
end;

procedure TFhirCapabilityStatementRestResource.SetVersioningST(value : TFhirResourceVersionPolicyEnum);
begin
  if ord(value) = 0 then
    VersioningElement := nil
  else
    VersioningElement := TFhirEnum.create(SYSTEMS_TFhirResourceVersionPolicyEnum[value], CODES_TFhirResourceVersionPolicyEnum[value]);
end;

procedure TFhirCapabilityStatementRestResource.SetReadHistory(value : TFhirBoolean);
begin
  FReadHistory.free;
  FReadHistory := value;
end;

function TFhirCapabilityStatementRestResource.GetReadHistoryST : Boolean;
begin
  if FReadHistory = nil then
    result := false
  else
    result := FReadHistory.value;
end;

procedure TFhirCapabilityStatementRestResource.SetReadHistoryST(value : Boolean);
begin
  if FReadHistory = nil then
    FReadHistory := TFhirBoolean.create;
  FReadHistory.value := value
end;

procedure TFhirCapabilityStatementRestResource.SetUpdateCreate(value : TFhirBoolean);
begin
  FUpdateCreate.free;
  FUpdateCreate := value;
end;

function TFhirCapabilityStatementRestResource.GetUpdateCreateST : Boolean;
begin
  if FUpdateCreate = nil then
    result := false
  else
    result := FUpdateCreate.value;
end;

procedure TFhirCapabilityStatementRestResource.SetUpdateCreateST(value : Boolean);
begin
  if FUpdateCreate = nil then
    FUpdateCreate := TFhirBoolean.create;
  FUpdateCreate.value := value
end;

procedure TFhirCapabilityStatementRestResource.SetConditionalCreate(value : TFhirBoolean);
begin
  FConditionalCreate.free;
  FConditionalCreate := value;
end;

function TFhirCapabilityStatementRestResource.GetConditionalCreateST : Boolean;
begin
  if FConditionalCreate = nil then
    result := false
  else
    result := FConditionalCreate.value;
end;

procedure TFhirCapabilityStatementRestResource.SetConditionalCreateST(value : Boolean);
begin
  if FConditionalCreate = nil then
    FConditionalCreate := TFhirBoolean.create;
  FConditionalCreate.value := value
end;

procedure TFhirCapabilityStatementRestResource.SetConditionalRead(value : TFhirEnum);
begin
  FConditionalRead.free;
  FConditionalRead := value;
end;

function TFhirCapabilityStatementRestResource.GetConditionalReadST : TFhirConditionalReadStatusEnum;
begin
  if FConditionalRead = nil then
    result := TFhirConditionalReadStatusEnum(0)
  else
    result := TFhirConditionalReadStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirConditionalReadStatusEnum, FConditionalRead.value));
end;

procedure TFhirCapabilityStatementRestResource.SetConditionalReadST(value : TFhirConditionalReadStatusEnum);
begin
  if ord(value) = 0 then
    ConditionalReadElement := nil
  else
    ConditionalReadElement := TFhirEnum.create(SYSTEMS_TFhirConditionalReadStatusEnum[value], CODES_TFhirConditionalReadStatusEnum[value]);
end;

procedure TFhirCapabilityStatementRestResource.SetConditionalUpdate(value : TFhirBoolean);
begin
  FConditionalUpdate.free;
  FConditionalUpdate := value;
end;

function TFhirCapabilityStatementRestResource.GetConditionalUpdateST : Boolean;
begin
  if FConditionalUpdate = nil then
    result := false
  else
    result := FConditionalUpdate.value;
end;

procedure TFhirCapabilityStatementRestResource.SetConditionalUpdateST(value : Boolean);
begin
  if FConditionalUpdate = nil then
    FConditionalUpdate := TFhirBoolean.create;
  FConditionalUpdate.value := value
end;

procedure TFhirCapabilityStatementRestResource.SetConditionalDelete(value : TFhirEnum);
begin
  FConditionalDelete.free;
  FConditionalDelete := value;
end;

function TFhirCapabilityStatementRestResource.GetConditionalDeleteST : TFhirConditionalDeleteStatusEnum;
begin
  if FConditionalDelete = nil then
    result := TFhirConditionalDeleteStatusEnum(0)
  else
    result := TFhirConditionalDeleteStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirConditionalDeleteStatusEnum, FConditionalDelete.value));
end;

procedure TFhirCapabilityStatementRestResource.SetConditionalDeleteST(value : TFhirConditionalDeleteStatusEnum);
begin
  if ord(value) = 0 then
    ConditionalDeleteElement := nil
  else
    ConditionalDeleteElement := TFhirEnum.create(SYSTEMS_TFhirConditionalDeleteStatusEnum[value], CODES_TFhirConditionalDeleteStatusEnum[value]);
end;

function TFhirCapabilityStatementRestResource.GetReferencePolicy : TFhirEnumList;
begin
  if FReferencePolicy = nil then
    FReferencePolicy := TFhirEnumList.Create(SYSTEMS_TFhirReferenceHandlingPolicyEnum, CODES_TFhirReferenceHandlingPolicyEnum);
  result := FReferencePolicy;
end;

function TFhirCapabilityStatementRestResource.GetHasReferencePolicy : boolean;
begin
  result := (FReferencePolicy <> nil) and (FReferencePolicy.count > 0);
end;

function TFhirCapabilityStatementRestResource.GetReferencePolicyST : TFhirReferenceHandlingPolicyEnumList;
  var i : integer;
begin
  result := [];
  if FreferencePolicy <> nil then
    for i := 0 to FreferencePolicy.count - 1 do
      result := result + [TFhirReferenceHandlingPolicyEnum(StringArrayIndexOfSensitive(CODES_TFhirReferenceHandlingPolicyEnum, FreferencePolicy[i].value))];
end;

procedure TFhirCapabilityStatementRestResource.SetReferencePolicyST(value : TFhirReferenceHandlingPolicyEnumList);
var a : TFhirReferenceHandlingPolicyEnum;
begin
  if FreferencePolicy = nil then
    FreferencePolicy := TFhirEnumList.create(SYSTEMS_TFhirReferenceHandlingPolicyEnum, CODES_TFhirReferenceHandlingPolicyEnum);
  FreferencePolicy.clear;
  for a := low(TFhirReferenceHandlingPolicyEnum) to high(TFhirReferenceHandlingPolicyEnum) do
    if a in value then
      begin
         if FreferencePolicy = nil then
           FreferencePolicy := TFhirEnumList.create(SYSTEMS_TFhirReferenceHandlingPolicyEnum, CODES_TFhirReferenceHandlingPolicyEnum);
         FreferencePolicy.add(TFhirEnum.create(SYSTEMS_TFhirReferenceHandlingPolicyEnum[a], CODES_TFhirReferenceHandlingPolicyEnum[a]));
      end;
end;

function TFhirCapabilityStatementRestResource.GetSearchIncludeList : TFhirStringList;
begin
  if FSearchIncludeList = nil then
    FSearchIncludeList := TFhirStringList.Create;
  result := FSearchIncludeList;
end;

function TFhirCapabilityStatementRestResource.GetHasSearchIncludeList : boolean;
begin
  result := (FSearchIncludeList <> nil) and (FSearchIncludeList.count > 0);
end;

function TFhirCapabilityStatementRestResource.GetSearchRevIncludeList : TFhirStringList;
begin
  if FSearchRevIncludeList = nil then
    FSearchRevIncludeList := TFhirStringList.Create;
  result := FSearchRevIncludeList;
end;

function TFhirCapabilityStatementRestResource.GetHasSearchRevIncludeList : boolean;
begin
  result := (FSearchRevIncludeList <> nil) and (FSearchRevIncludeList.count > 0);
end;

function TFhirCapabilityStatementRestResource.GetSearchParamList : TFhirCapabilityStatementRestResourceSearchParamList;
begin
  if FSearchParamList = nil then
    FSearchParamList := TFhirCapabilityStatementRestResourceSearchParamList.Create;
  result := FSearchParamList;
end;

function TFhirCapabilityStatementRestResource.GetHasSearchParamList : boolean;
begin
  result := (FSearchParamList <> nil) and (FSearchParamList.count > 0);
end;

function TFhirCapabilityStatementRestResource.GetOperationList : TFhirCapabilityStatementRestResourceOperationList;
begin
  if FOperationList = nil then
    FOperationList := TFhirCapabilityStatementRestResourceOperationList.Create;
  result := FOperationList;
end;

function TFhirCapabilityStatementRestResource.GetHasOperationList : boolean;
begin
  result := (FOperationList <> nil) and (FOperationList.count > 0);
end;

{ TFhirCapabilityStatementRestResourceListEnumerator }

constructor TFhirCapabilityStatementRestResourceListEnumerator.Create(list : TFhirCapabilityStatementRestResourceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCapabilityStatementRestResourceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCapabilityStatementRestResourceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCapabilityStatementRestResourceListEnumerator.GetCurrent : TFhirCapabilityStatementRestResource;
begin
  Result := FList[FIndex];
end;

function TFhirCapabilityStatementRestResourceListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCapabilityStatementRestResourceList }

function TFhirCapabilityStatementRestResourceList.AddItem(value: TFhirCapabilityStatementRestResource): TFhirCapabilityStatementRestResource;
begin
  assert(value.ClassName = 'TFhirCapabilityStatementRestResource', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCapabilityStatementRestResource');
  add(value);
  result := value;
end;

function TFhirCapabilityStatementRestResourceList.Append: TFhirCapabilityStatementRestResource;
begin
  result := TFhirCapabilityStatementRestResource.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCapabilityStatementRestResourceList.ClearItems;
begin
  Clear;
end;

function TFhirCapabilityStatementRestResourceList.GetEnumerator : TFhirCapabilityStatementRestResourceListEnumerator;
begin
  result := TFhirCapabilityStatementRestResourceListEnumerator.Create(self.link);
end;

function TFhirCapabilityStatementRestResourceList.Clone: TFhirCapabilityStatementRestResourceList;
begin
  result := TFhirCapabilityStatementRestResourceList(inherited Clone);
end;

function TFhirCapabilityStatementRestResourceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCapabilityStatementRestResourceList.GetItemN(index: Integer): TFhirCapabilityStatementRestResource;
begin
  result := TFhirCapabilityStatementRestResource(ObjectByIndex[index]);
end;

function TFhirCapabilityStatementRestResourceList.ItemClass: TFslObjectClass;
begin
  result := TFhirCapabilityStatementRestResource;
end;
function TFhirCapabilityStatementRestResourceList.IndexOf(value: TFhirCapabilityStatementRestResource): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCapabilityStatementRestResourceList.Insert(index: Integer): TFhirCapabilityStatementRestResource;
begin
  result := TFhirCapabilityStatementRestResource.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCapabilityStatementRestResourceList.InsertItem(index: Integer; value: TFhirCapabilityStatementRestResource);
begin
  assert(value is TFhirCapabilityStatementRestResource);
  Inherited Insert(index, value);
end;

function TFhirCapabilityStatementRestResourceList.Item(index: Integer): TFhirCapabilityStatementRestResource;
begin
  result := TFhirCapabilityStatementRestResource(ObjectByIndex[index]);
end;

function TFhirCapabilityStatementRestResourceList.Link: TFhirCapabilityStatementRestResourceList;
begin
  result := TFhirCapabilityStatementRestResourceList(inherited Link);
end;

procedure TFhirCapabilityStatementRestResourceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCapabilityStatementRestResourceList.SetItemByIndex(index: Integer; value: TFhirCapabilityStatementRestResource);
begin
  assert(value is TFhirCapabilityStatementRestResource);
  FhirCapabilityStatementRestResources[index] := value;
end;

procedure TFhirCapabilityStatementRestResourceList.SetItemN(index: Integer; value: TFhirCapabilityStatementRestResource);
begin
  assert(value is TFhirCapabilityStatementRestResource);
  ObjectByIndex[index] := value;
end;

{ TFhirCapabilityStatementRestResourceInteraction }

constructor TFhirCapabilityStatementRestResourceInteraction.Create;
begin
  inherited;
end;

destructor TFhirCapabilityStatementRestResourceInteraction.Destroy;
begin
  FCode.free;
  FDocumentation.free;
  inherited;
end;

procedure TFhirCapabilityStatementRestResourceInteraction.Assign(oSource : TFslObject);
begin
  inherited;
  codeElement := TFhirCapabilityStatementRestResourceInteraction(oSource).codeElement.Clone;
  documentationElement := TFhirCapabilityStatementRestResourceInteraction(oSource).documentationElement.Clone;
end;

procedure TFhirCapabilityStatementRestResourceInteraction.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'documentation') Then
     list.add(self.link, 'documentation', FDocumentation.Link);
end;

procedure TFhirCapabilityStatementRestResourceInteraction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'code', false, TFhirEnum, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'documentation', 'markdown', false, TFhirMarkdown, FDocumentation.Link));
end;

function TFhirCapabilityStatementRestResourceInteraction.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    CodeElement := asEnum(SYSTEMS_TFhirTypeRestfulInteractionEnum, CODES_TFhirTypeRestfulInteractionEnum, propValue);
    result := propValue;
  end
  else if (propName = 'documentation') then
  begin
    DocumentationElement := asMarkdown(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCapabilityStatementRestResourceInteraction.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCapabilityStatementRestResourceInteraction.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirEnum.create(SYSTEMS_TFhirTypeRestfulInteractionEnum[TypeRestfulInteractionNull], CODES_TFhirTypeRestfulInteractionEnum[TypeRestfulInteractionNull]) 
  else if (propName = 'documentation') then result := TFhirMarkdown.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirCapabilityStatementRestResourceInteraction.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'code'
  else if (propName = 'documentation') then result := 'markdown'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCapabilityStatementRestResourceInteraction.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'documentation') then DocumentationElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCapabilityStatementRestResourceInteraction.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := asEnum(SYSTEMS_TFhirTypeRestfulInteractionEnum, CODES_TFhirTypeRestfulInteractionEnum, new)
  else if (propName = 'documentation') then DocumentationElement := asMarkdown(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCapabilityStatementRestResourceInteraction.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCapabilityStatementRestResourceInteraction.fhirType : string;
begin
  result := 'CapabilityStatement.rest.resource.interaction';
end;

function TFhirCapabilityStatementRestResourceInteraction.Link : TFhirCapabilityStatementRestResourceInteraction;
begin
  result := TFhirCapabilityStatementRestResourceInteraction(inherited Link);
end;

function TFhirCapabilityStatementRestResourceInteraction.Clone : TFhirCapabilityStatementRestResourceInteraction;
begin
  result := TFhirCapabilityStatementRestResourceInteraction(inherited Clone);
end;

function TFhirCapabilityStatementRestResourceInteraction.equals(other : TObject) : boolean; 
var
  o : TFhirCapabilityStatementRestResourceInteraction;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCapabilityStatementRestResourceInteraction)) then
    result := false
  else
  begin
    o := TFhirCapabilityStatementRestResourceInteraction(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(documentationElement, o.documentationElement, true);
  end;
end;

function TFhirCapabilityStatementRestResourceInteraction.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FDocumentation);
end;

procedure TFhirCapabilityStatementRestResourceInteraction.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('code');
  fields.add('documentation');
end;

function TFhirCapabilityStatementRestResourceInteraction.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirCapabilityStatementRestResourceInteraction.SetCode(value : TFhirEnum);
begin
  FCode.free;
  FCode := value;
end;

function TFhirCapabilityStatementRestResourceInteraction.GetCodeST : TFhirTypeRestfulInteractionEnum;
begin
  if FCode = nil then
    result := TFhirTypeRestfulInteractionEnum(0)
  else
    result := TFhirTypeRestfulInteractionEnum(StringArrayIndexOfSensitive(CODES_TFhirTypeRestfulInteractionEnum, FCode.value));
end;

procedure TFhirCapabilityStatementRestResourceInteraction.SetCodeST(value : TFhirTypeRestfulInteractionEnum);
begin
  if ord(value) = 0 then
    CodeElement := nil
  else
    CodeElement := TFhirEnum.create(SYSTEMS_TFhirTypeRestfulInteractionEnum[value], CODES_TFhirTypeRestfulInteractionEnum[value]);
end;

procedure TFhirCapabilityStatementRestResourceInteraction.SetDocumentation(value : TFhirMarkdown);
begin
  FDocumentation.free;
  FDocumentation := value;
end;

function TFhirCapabilityStatementRestResourceInteraction.GetDocumentationST : String;
begin
  if FDocumentation = nil then
    result := ''
  else
    result := FDocumentation.value;
end;

procedure TFhirCapabilityStatementRestResourceInteraction.SetDocumentationST(value : String);
begin
  if value <> '' then
  begin
    if FDocumentation = nil then
      FDocumentation := TFhirMarkdown.create;
    FDocumentation.value := value
  end
  else if FDocumentation <> nil then
    FDocumentation.value := '';
end;

{ TFhirCapabilityStatementRestResourceInteractionListEnumerator }

constructor TFhirCapabilityStatementRestResourceInteractionListEnumerator.Create(list : TFhirCapabilityStatementRestResourceInteractionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCapabilityStatementRestResourceInteractionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCapabilityStatementRestResourceInteractionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCapabilityStatementRestResourceInteractionListEnumerator.GetCurrent : TFhirCapabilityStatementRestResourceInteraction;
begin
  Result := FList[FIndex];
end;

function TFhirCapabilityStatementRestResourceInteractionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCapabilityStatementRestResourceInteractionList }

function TFhirCapabilityStatementRestResourceInteractionList.AddItem(value: TFhirCapabilityStatementRestResourceInteraction): TFhirCapabilityStatementRestResourceInteraction;
begin
  assert(value.ClassName = 'TFhirCapabilityStatementRestResourceInteraction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCapabilityStatementRestResourceInteraction');
  add(value);
  result := value;
end;

function TFhirCapabilityStatementRestResourceInteractionList.Append: TFhirCapabilityStatementRestResourceInteraction;
begin
  result := TFhirCapabilityStatementRestResourceInteraction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCapabilityStatementRestResourceInteractionList.ClearItems;
begin
  Clear;
end;

function TFhirCapabilityStatementRestResourceInteractionList.GetEnumerator : TFhirCapabilityStatementRestResourceInteractionListEnumerator;
begin
  result := TFhirCapabilityStatementRestResourceInteractionListEnumerator.Create(self.link);
end;

function TFhirCapabilityStatementRestResourceInteractionList.Clone: TFhirCapabilityStatementRestResourceInteractionList;
begin
  result := TFhirCapabilityStatementRestResourceInteractionList(inherited Clone);
end;

function TFhirCapabilityStatementRestResourceInteractionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCapabilityStatementRestResourceInteractionList.GetItemN(index: Integer): TFhirCapabilityStatementRestResourceInteraction;
begin
  result := TFhirCapabilityStatementRestResourceInteraction(ObjectByIndex[index]);
end;

function TFhirCapabilityStatementRestResourceInteractionList.ItemClass: TFslObjectClass;
begin
  result := TFhirCapabilityStatementRestResourceInteraction;
end;
function TFhirCapabilityStatementRestResourceInteractionList.IndexOf(value: TFhirCapabilityStatementRestResourceInteraction): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCapabilityStatementRestResourceInteractionList.Insert(index: Integer): TFhirCapabilityStatementRestResourceInteraction;
begin
  result := TFhirCapabilityStatementRestResourceInteraction.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCapabilityStatementRestResourceInteractionList.InsertItem(index: Integer; value: TFhirCapabilityStatementRestResourceInteraction);
begin
  assert(value is TFhirCapabilityStatementRestResourceInteraction);
  Inherited Insert(index, value);
end;

function TFhirCapabilityStatementRestResourceInteractionList.Item(index: Integer): TFhirCapabilityStatementRestResourceInteraction;
begin
  result := TFhirCapabilityStatementRestResourceInteraction(ObjectByIndex[index]);
end;

function TFhirCapabilityStatementRestResourceInteractionList.Link: TFhirCapabilityStatementRestResourceInteractionList;
begin
  result := TFhirCapabilityStatementRestResourceInteractionList(inherited Link);
end;

procedure TFhirCapabilityStatementRestResourceInteractionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCapabilityStatementRestResourceInteractionList.SetItemByIndex(index: Integer; value: TFhirCapabilityStatementRestResourceInteraction);
begin
  assert(value is TFhirCapabilityStatementRestResourceInteraction);
  FhirCapabilityStatementRestResourceInteractions[index] := value;
end;

procedure TFhirCapabilityStatementRestResourceInteractionList.SetItemN(index: Integer; value: TFhirCapabilityStatementRestResourceInteraction);
begin
  assert(value is TFhirCapabilityStatementRestResourceInteraction);
  ObjectByIndex[index] := value;
end;

{ TFhirCapabilityStatementRestResourceSearchParam }

constructor TFhirCapabilityStatementRestResourceSearchParam.Create;
begin
  inherited;
end;

destructor TFhirCapabilityStatementRestResourceSearchParam.Destroy;
begin
  FName.free;
  FDefinition.free;
  FType_.free;
  FDocumentation.free;
  inherited;
end;

procedure TFhirCapabilityStatementRestResourceSearchParam.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirCapabilityStatementRestResourceSearchParam(oSource).nameElement.Clone;
  definitionElement := TFhirCapabilityStatementRestResourceSearchParam(oSource).definitionElement.Clone;
  type_Element := TFhirCapabilityStatementRestResourceSearchParam(oSource).type_Element.Clone;
  documentationElement := TFhirCapabilityStatementRestResourceSearchParam(oSource).documentationElement.Clone;
end;

procedure TFhirCapabilityStatementRestResourceSearchParam.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'definition') Then
     list.add(self.link, 'definition', FDefinition.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'documentation') Then
     list.add(self.link, 'documentation', FDocumentation.Link);
end;

procedure TFhirCapabilityStatementRestResourceSearchParam.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'definition', 'canonical', false, TFhirCanonical, FDefinition.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFhirEnum, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'documentation', 'markdown', false, TFhirMarkdown, FDocumentation.Link));
end;

function TFhirCapabilityStatementRestResourceSearchParam.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'definition') then
  begin
    DefinitionElement := asCanonical(propValue);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirSearchParamTypeEnum, CODES_TFhirSearchParamTypeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'documentation') then
  begin
    DocumentationElement := asMarkdown(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCapabilityStatementRestResourceSearchParam.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCapabilityStatementRestResourceSearchParam.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'definition') then result := TFhirCanonical.create()
  else if (propName = 'type') then result := TFhirEnum.create(SYSTEMS_TFhirSearchParamTypeEnum[SearchParamTypeNull], CODES_TFhirSearchParamTypeEnum[SearchParamTypeNull]) 
  else if (propName = 'documentation') then result := TFhirMarkdown.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirCapabilityStatementRestResourceSearchParam.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'definition') then result := 'canonical'
  else if (propName = 'type') then result := 'code'
  else if (propName = 'documentation') then result := 'markdown'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCapabilityStatementRestResourceSearchParam.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'definition') then DefinitionElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'documentation') then DocumentationElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCapabilityStatementRestResourceSearchParam.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'definition') then DefinitionElement := asCanonical(new)
  else if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirSearchParamTypeEnum, CODES_TFhirSearchParamTypeEnum, new)
  else if (propName = 'documentation') then DocumentationElement := asMarkdown(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCapabilityStatementRestResourceSearchParam.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCapabilityStatementRestResourceSearchParam.fhirType : string;
begin
  result := 'CapabilityStatement.rest.resource.searchParam';
end;

function TFhirCapabilityStatementRestResourceSearchParam.Link : TFhirCapabilityStatementRestResourceSearchParam;
begin
  result := TFhirCapabilityStatementRestResourceSearchParam(inherited Link);
end;

function TFhirCapabilityStatementRestResourceSearchParam.Clone : TFhirCapabilityStatementRestResourceSearchParam;
begin
  result := TFhirCapabilityStatementRestResourceSearchParam(inherited Clone);
end;

function TFhirCapabilityStatementRestResourceSearchParam.equals(other : TObject) : boolean; 
var
  o : TFhirCapabilityStatementRestResourceSearchParam;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCapabilityStatementRestResourceSearchParam)) then
    result := false
  else
  begin
    o := TFhirCapabilityStatementRestResourceSearchParam(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(definitionElement, o.definitionElement, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(documentationElement, o.documentationElement, true);
  end;
end;

function TFhirCapabilityStatementRestResourceSearchParam.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FDefinition) and isEmptyProp(FType_) and isEmptyProp(FDocumentation);
end;

procedure TFhirCapabilityStatementRestResourceSearchParam.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('name');
  fields.add('definition');
  fields.add('type');
  fields.add('documentation');
end;

function TFhirCapabilityStatementRestResourceSearchParam.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirCapabilityStatementRestResourceSearchParam.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirCapabilityStatementRestResourceSearchParam.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirCapabilityStatementRestResourceSearchParam.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirCapabilityStatementRestResourceSearchParam.SetDefinition(value : TFhirCanonical);
begin
  FDefinition.free;
  FDefinition := value;
end;

function TFhirCapabilityStatementRestResourceSearchParam.GetDefinitionST : String;
begin
  if FDefinition = nil then
    result := ''
  else
    result := FDefinition.value;
end;

procedure TFhirCapabilityStatementRestResourceSearchParam.SetDefinitionST(value : String);
begin
  if value <> '' then
  begin
    if FDefinition = nil then
      FDefinition := TFhirCanonical.create;
    FDefinition.value := value
  end
  else if FDefinition <> nil then
    FDefinition.value := '';
end;

procedure TFhirCapabilityStatementRestResourceSearchParam.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirCapabilityStatementRestResourceSearchParam.GetType_ST : TFhirSearchParamTypeEnum;
begin
  if FType_ = nil then
    result := TFhirSearchParamTypeEnum(0)
  else
    result := TFhirSearchParamTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirSearchParamTypeEnum, FType_.value));
end;

procedure TFhirCapabilityStatementRestResourceSearchParam.SetType_ST(value : TFhirSearchParamTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirSearchParamTypeEnum[value], CODES_TFhirSearchParamTypeEnum[value]);
end;

procedure TFhirCapabilityStatementRestResourceSearchParam.SetDocumentation(value : TFhirMarkdown);
begin
  FDocumentation.free;
  FDocumentation := value;
end;

function TFhirCapabilityStatementRestResourceSearchParam.GetDocumentationST : String;
begin
  if FDocumentation = nil then
    result := ''
  else
    result := FDocumentation.value;
end;

procedure TFhirCapabilityStatementRestResourceSearchParam.SetDocumentationST(value : String);
begin
  if value <> '' then
  begin
    if FDocumentation = nil then
      FDocumentation := TFhirMarkdown.create;
    FDocumentation.value := value
  end
  else if FDocumentation <> nil then
    FDocumentation.value := '';
end;

{ TFhirCapabilityStatementRestResourceSearchParamListEnumerator }

constructor TFhirCapabilityStatementRestResourceSearchParamListEnumerator.Create(list : TFhirCapabilityStatementRestResourceSearchParamList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCapabilityStatementRestResourceSearchParamListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCapabilityStatementRestResourceSearchParamListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCapabilityStatementRestResourceSearchParamListEnumerator.GetCurrent : TFhirCapabilityStatementRestResourceSearchParam;
begin
  Result := FList[FIndex];
end;

function TFhirCapabilityStatementRestResourceSearchParamListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCapabilityStatementRestResourceSearchParamList }

function TFhirCapabilityStatementRestResourceSearchParamList.AddItem(value: TFhirCapabilityStatementRestResourceSearchParam): TFhirCapabilityStatementRestResourceSearchParam;
begin
  assert(value.ClassName = 'TFhirCapabilityStatementRestResourceSearchParam', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCapabilityStatementRestResourceSearchParam');
  add(value);
  result := value;
end;

function TFhirCapabilityStatementRestResourceSearchParamList.Append: TFhirCapabilityStatementRestResourceSearchParam;
begin
  result := TFhirCapabilityStatementRestResourceSearchParam.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCapabilityStatementRestResourceSearchParamList.ClearItems;
begin
  Clear;
end;

function TFhirCapabilityStatementRestResourceSearchParamList.GetEnumerator : TFhirCapabilityStatementRestResourceSearchParamListEnumerator;
begin
  result := TFhirCapabilityStatementRestResourceSearchParamListEnumerator.Create(self.link);
end;

function TFhirCapabilityStatementRestResourceSearchParamList.Clone: TFhirCapabilityStatementRestResourceSearchParamList;
begin
  result := TFhirCapabilityStatementRestResourceSearchParamList(inherited Clone);
end;

function TFhirCapabilityStatementRestResourceSearchParamList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCapabilityStatementRestResourceSearchParamList.GetItemN(index: Integer): TFhirCapabilityStatementRestResourceSearchParam;
begin
  result := TFhirCapabilityStatementRestResourceSearchParam(ObjectByIndex[index]);
end;

function TFhirCapabilityStatementRestResourceSearchParamList.ItemClass: TFslObjectClass;
begin
  result := TFhirCapabilityStatementRestResourceSearchParam;
end;
function TFhirCapabilityStatementRestResourceSearchParamList.IndexOf(value: TFhirCapabilityStatementRestResourceSearchParam): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCapabilityStatementRestResourceSearchParamList.Insert(index: Integer): TFhirCapabilityStatementRestResourceSearchParam;
begin
  result := TFhirCapabilityStatementRestResourceSearchParam.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCapabilityStatementRestResourceSearchParamList.InsertItem(index: Integer; value: TFhirCapabilityStatementRestResourceSearchParam);
begin
  assert(value is TFhirCapabilityStatementRestResourceSearchParam);
  Inherited Insert(index, value);
end;

function TFhirCapabilityStatementRestResourceSearchParamList.Item(index: Integer): TFhirCapabilityStatementRestResourceSearchParam;
begin
  result := TFhirCapabilityStatementRestResourceSearchParam(ObjectByIndex[index]);
end;

function TFhirCapabilityStatementRestResourceSearchParamList.Link: TFhirCapabilityStatementRestResourceSearchParamList;
begin
  result := TFhirCapabilityStatementRestResourceSearchParamList(inherited Link);
end;

procedure TFhirCapabilityStatementRestResourceSearchParamList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCapabilityStatementRestResourceSearchParamList.SetItemByIndex(index: Integer; value: TFhirCapabilityStatementRestResourceSearchParam);
begin
  assert(value is TFhirCapabilityStatementRestResourceSearchParam);
  FhirCapabilityStatementRestResourceSearchParams[index] := value;
end;

procedure TFhirCapabilityStatementRestResourceSearchParamList.SetItemN(index: Integer; value: TFhirCapabilityStatementRestResourceSearchParam);
begin
  assert(value is TFhirCapabilityStatementRestResourceSearchParam);
  ObjectByIndex[index] := value;
end;

{ TFhirCapabilityStatementRestResourceOperation }

constructor TFhirCapabilityStatementRestResourceOperation.Create;
begin
  inherited;
end;

destructor TFhirCapabilityStatementRestResourceOperation.Destroy;
begin
  FName.free;
  FDefinition.free;
  FDocumentation.free;
  inherited;
end;

procedure TFhirCapabilityStatementRestResourceOperation.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirCapabilityStatementRestResourceOperation(oSource).nameElement.Clone;
  definitionElement := TFhirCapabilityStatementRestResourceOperation(oSource).definitionElement.Clone;
  documentationElement := TFhirCapabilityStatementRestResourceOperation(oSource).documentationElement.Clone;
end;

procedure TFhirCapabilityStatementRestResourceOperation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'definition') Then
     list.add(self.link, 'definition', FDefinition.Link);
  if (child_name = 'documentation') Then
     list.add(self.link, 'documentation', FDocumentation.Link);
end;

procedure TFhirCapabilityStatementRestResourceOperation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'definition', 'canonical', false, TFhirCanonical, FDefinition.Link));
  oList.add(TFHIRProperty.create(self, 'documentation', 'markdown', false, TFhirMarkdown, FDocumentation.Link));
end;

function TFhirCapabilityStatementRestResourceOperation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'definition') then
  begin
    DefinitionElement := asCanonical(propValue);
    result := propValue;
  end
  else if (propName = 'documentation') then
  begin
    DocumentationElement := asMarkdown(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCapabilityStatementRestResourceOperation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCapabilityStatementRestResourceOperation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'definition') then result := TFhirCanonical.create()
  else if (propName = 'documentation') then result := TFhirMarkdown.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirCapabilityStatementRestResourceOperation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'definition') then result := 'canonical'
  else if (propName = 'documentation') then result := 'markdown'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCapabilityStatementRestResourceOperation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'definition') then DefinitionElement := nil
  else if (propName = 'documentation') then DocumentationElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCapabilityStatementRestResourceOperation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'definition') then DefinitionElement := asCanonical(new)
  else if (propName = 'documentation') then DocumentationElement := asMarkdown(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCapabilityStatementRestResourceOperation.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCapabilityStatementRestResourceOperation.fhirType : string;
begin
  result := 'CapabilityStatement.rest.resource.operation';
end;

function TFhirCapabilityStatementRestResourceOperation.Link : TFhirCapabilityStatementRestResourceOperation;
begin
  result := TFhirCapabilityStatementRestResourceOperation(inherited Link);
end;

function TFhirCapabilityStatementRestResourceOperation.Clone : TFhirCapabilityStatementRestResourceOperation;
begin
  result := TFhirCapabilityStatementRestResourceOperation(inherited Clone);
end;

function TFhirCapabilityStatementRestResourceOperation.equals(other : TObject) : boolean; 
var
  o : TFhirCapabilityStatementRestResourceOperation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCapabilityStatementRestResourceOperation)) then
    result := false
  else
  begin
    o := TFhirCapabilityStatementRestResourceOperation(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(definitionElement, o.definitionElement, true) and 
      compareDeep(documentationElement, o.documentationElement, true);
  end;
end;

function TFhirCapabilityStatementRestResourceOperation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FDefinition) and isEmptyProp(FDocumentation);
end;

procedure TFhirCapabilityStatementRestResourceOperation.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('name');
  fields.add('definition');
  fields.add('documentation');
end;

function TFhirCapabilityStatementRestResourceOperation.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirCapabilityStatementRestResourceOperation.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirCapabilityStatementRestResourceOperation.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirCapabilityStatementRestResourceOperation.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirCapabilityStatementRestResourceOperation.SetDefinition(value : TFhirCanonical);
begin
  FDefinition.free;
  FDefinition := value;
end;

function TFhirCapabilityStatementRestResourceOperation.GetDefinitionST : String;
begin
  if FDefinition = nil then
    result := ''
  else
    result := FDefinition.value;
end;

procedure TFhirCapabilityStatementRestResourceOperation.SetDefinitionST(value : String);
begin
  if value <> '' then
  begin
    if FDefinition = nil then
      FDefinition := TFhirCanonical.create;
    FDefinition.value := value
  end
  else if FDefinition <> nil then
    FDefinition.value := '';
end;

procedure TFhirCapabilityStatementRestResourceOperation.SetDocumentation(value : TFhirMarkdown);
begin
  FDocumentation.free;
  FDocumentation := value;
end;

function TFhirCapabilityStatementRestResourceOperation.GetDocumentationST : String;
begin
  if FDocumentation = nil then
    result := ''
  else
    result := FDocumentation.value;
end;

procedure TFhirCapabilityStatementRestResourceOperation.SetDocumentationST(value : String);
begin
  if value <> '' then
  begin
    if FDocumentation = nil then
      FDocumentation := TFhirMarkdown.create;
    FDocumentation.value := value
  end
  else if FDocumentation <> nil then
    FDocumentation.value := '';
end;

{ TFhirCapabilityStatementRestResourceOperationListEnumerator }

constructor TFhirCapabilityStatementRestResourceOperationListEnumerator.Create(list : TFhirCapabilityStatementRestResourceOperationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCapabilityStatementRestResourceOperationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCapabilityStatementRestResourceOperationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCapabilityStatementRestResourceOperationListEnumerator.GetCurrent : TFhirCapabilityStatementRestResourceOperation;
begin
  Result := FList[FIndex];
end;

function TFhirCapabilityStatementRestResourceOperationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCapabilityStatementRestResourceOperationList }

function TFhirCapabilityStatementRestResourceOperationList.AddItem(value: TFhirCapabilityStatementRestResourceOperation): TFhirCapabilityStatementRestResourceOperation;
begin
  assert(value.ClassName = 'TFhirCapabilityStatementRestResourceOperation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCapabilityStatementRestResourceOperation');
  add(value);
  result := value;
end;

function TFhirCapabilityStatementRestResourceOperationList.Append: TFhirCapabilityStatementRestResourceOperation;
begin
  result := TFhirCapabilityStatementRestResourceOperation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCapabilityStatementRestResourceOperationList.ClearItems;
begin
  Clear;
end;

function TFhirCapabilityStatementRestResourceOperationList.GetEnumerator : TFhirCapabilityStatementRestResourceOperationListEnumerator;
begin
  result := TFhirCapabilityStatementRestResourceOperationListEnumerator.Create(self.link);
end;

function TFhirCapabilityStatementRestResourceOperationList.Clone: TFhirCapabilityStatementRestResourceOperationList;
begin
  result := TFhirCapabilityStatementRestResourceOperationList(inherited Clone);
end;

function TFhirCapabilityStatementRestResourceOperationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCapabilityStatementRestResourceOperationList.GetItemN(index: Integer): TFhirCapabilityStatementRestResourceOperation;
begin
  result := TFhirCapabilityStatementRestResourceOperation(ObjectByIndex[index]);
end;

function TFhirCapabilityStatementRestResourceOperationList.ItemClass: TFslObjectClass;
begin
  result := TFhirCapabilityStatementRestResourceOperation;
end;
function TFhirCapabilityStatementRestResourceOperationList.IndexOf(value: TFhirCapabilityStatementRestResourceOperation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCapabilityStatementRestResourceOperationList.Insert(index: Integer): TFhirCapabilityStatementRestResourceOperation;
begin
  result := TFhirCapabilityStatementRestResourceOperation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCapabilityStatementRestResourceOperationList.InsertItem(index: Integer; value: TFhirCapabilityStatementRestResourceOperation);
begin
  assert(value is TFhirCapabilityStatementRestResourceOperation);
  Inherited Insert(index, value);
end;

function TFhirCapabilityStatementRestResourceOperationList.Item(index: Integer): TFhirCapabilityStatementRestResourceOperation;
begin
  result := TFhirCapabilityStatementRestResourceOperation(ObjectByIndex[index]);
end;

function TFhirCapabilityStatementRestResourceOperationList.Link: TFhirCapabilityStatementRestResourceOperationList;
begin
  result := TFhirCapabilityStatementRestResourceOperationList(inherited Link);
end;

procedure TFhirCapabilityStatementRestResourceOperationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCapabilityStatementRestResourceOperationList.SetItemByIndex(index: Integer; value: TFhirCapabilityStatementRestResourceOperation);
begin
  assert(value is TFhirCapabilityStatementRestResourceOperation);
  FhirCapabilityStatementRestResourceOperations[index] := value;
end;

procedure TFhirCapabilityStatementRestResourceOperationList.SetItemN(index: Integer; value: TFhirCapabilityStatementRestResourceOperation);
begin
  assert(value is TFhirCapabilityStatementRestResourceOperation);
  ObjectByIndex[index] := value;
end;

{ TFhirCapabilityStatementRestInteraction }

constructor TFhirCapabilityStatementRestInteraction.Create;
begin
  inherited;
end;

destructor TFhirCapabilityStatementRestInteraction.Destroy;
begin
  FCode.free;
  FDocumentation.free;
  inherited;
end;

procedure TFhirCapabilityStatementRestInteraction.Assign(oSource : TFslObject);
begin
  inherited;
  codeElement := TFhirCapabilityStatementRestInteraction(oSource).codeElement.Clone;
  documentationElement := TFhirCapabilityStatementRestInteraction(oSource).documentationElement.Clone;
end;

procedure TFhirCapabilityStatementRestInteraction.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'documentation') Then
     list.add(self.link, 'documentation', FDocumentation.Link);
end;

procedure TFhirCapabilityStatementRestInteraction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'code', false, TFhirEnum, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'documentation', 'markdown', false, TFhirMarkdown, FDocumentation.Link));
end;

function TFhirCapabilityStatementRestInteraction.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    CodeElement := asEnum(SYSTEMS_TFhirSystemRestfulInteractionEnum, CODES_TFhirSystemRestfulInteractionEnum, propValue);
    result := propValue;
  end
  else if (propName = 'documentation') then
  begin
    DocumentationElement := asMarkdown(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCapabilityStatementRestInteraction.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCapabilityStatementRestInteraction.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirEnum.create(SYSTEMS_TFhirSystemRestfulInteractionEnum[SystemRestfulInteractionNull], CODES_TFhirSystemRestfulInteractionEnum[SystemRestfulInteractionNull]) 
  else if (propName = 'documentation') then result := TFhirMarkdown.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirCapabilityStatementRestInteraction.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'code'
  else if (propName = 'documentation') then result := 'markdown'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCapabilityStatementRestInteraction.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'documentation') then DocumentationElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCapabilityStatementRestInteraction.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := asEnum(SYSTEMS_TFhirSystemRestfulInteractionEnum, CODES_TFhirSystemRestfulInteractionEnum, new)
  else if (propName = 'documentation') then DocumentationElement := asMarkdown(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCapabilityStatementRestInteraction.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCapabilityStatementRestInteraction.fhirType : string;
begin
  result := 'CapabilityStatement.rest.interaction';
end;

function TFhirCapabilityStatementRestInteraction.Link : TFhirCapabilityStatementRestInteraction;
begin
  result := TFhirCapabilityStatementRestInteraction(inherited Link);
end;

function TFhirCapabilityStatementRestInteraction.Clone : TFhirCapabilityStatementRestInteraction;
begin
  result := TFhirCapabilityStatementRestInteraction(inherited Clone);
end;

function TFhirCapabilityStatementRestInteraction.equals(other : TObject) : boolean; 
var
  o : TFhirCapabilityStatementRestInteraction;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCapabilityStatementRestInteraction)) then
    result := false
  else
  begin
    o := TFhirCapabilityStatementRestInteraction(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(documentationElement, o.documentationElement, true);
  end;
end;

function TFhirCapabilityStatementRestInteraction.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FDocumentation);
end;

procedure TFhirCapabilityStatementRestInteraction.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('code');
  fields.add('documentation');
end;

function TFhirCapabilityStatementRestInteraction.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirCapabilityStatementRestInteraction.SetCode(value : TFhirEnum);
begin
  FCode.free;
  FCode := value;
end;

function TFhirCapabilityStatementRestInteraction.GetCodeST : TFhirSystemRestfulInteractionEnum;
begin
  if FCode = nil then
    result := TFhirSystemRestfulInteractionEnum(0)
  else
    result := TFhirSystemRestfulInteractionEnum(StringArrayIndexOfSensitive(CODES_TFhirSystemRestfulInteractionEnum, FCode.value));
end;

procedure TFhirCapabilityStatementRestInteraction.SetCodeST(value : TFhirSystemRestfulInteractionEnum);
begin
  if ord(value) = 0 then
    CodeElement := nil
  else
    CodeElement := TFhirEnum.create(SYSTEMS_TFhirSystemRestfulInteractionEnum[value], CODES_TFhirSystemRestfulInteractionEnum[value]);
end;

procedure TFhirCapabilityStatementRestInteraction.SetDocumentation(value : TFhirMarkdown);
begin
  FDocumentation.free;
  FDocumentation := value;
end;

function TFhirCapabilityStatementRestInteraction.GetDocumentationST : String;
begin
  if FDocumentation = nil then
    result := ''
  else
    result := FDocumentation.value;
end;

procedure TFhirCapabilityStatementRestInteraction.SetDocumentationST(value : String);
begin
  if value <> '' then
  begin
    if FDocumentation = nil then
      FDocumentation := TFhirMarkdown.create;
    FDocumentation.value := value
  end
  else if FDocumentation <> nil then
    FDocumentation.value := '';
end;

{ TFhirCapabilityStatementRestInteractionListEnumerator }

constructor TFhirCapabilityStatementRestInteractionListEnumerator.Create(list : TFhirCapabilityStatementRestInteractionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCapabilityStatementRestInteractionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCapabilityStatementRestInteractionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCapabilityStatementRestInteractionListEnumerator.GetCurrent : TFhirCapabilityStatementRestInteraction;
begin
  Result := FList[FIndex];
end;

function TFhirCapabilityStatementRestInteractionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCapabilityStatementRestInteractionList }

function TFhirCapabilityStatementRestInteractionList.AddItem(value: TFhirCapabilityStatementRestInteraction): TFhirCapabilityStatementRestInteraction;
begin
  assert(value.ClassName = 'TFhirCapabilityStatementRestInteraction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCapabilityStatementRestInteraction');
  add(value);
  result := value;
end;

function TFhirCapabilityStatementRestInteractionList.Append: TFhirCapabilityStatementRestInteraction;
begin
  result := TFhirCapabilityStatementRestInteraction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCapabilityStatementRestInteractionList.ClearItems;
begin
  Clear;
end;

function TFhirCapabilityStatementRestInteractionList.GetEnumerator : TFhirCapabilityStatementRestInteractionListEnumerator;
begin
  result := TFhirCapabilityStatementRestInteractionListEnumerator.Create(self.link);
end;

function TFhirCapabilityStatementRestInteractionList.Clone: TFhirCapabilityStatementRestInteractionList;
begin
  result := TFhirCapabilityStatementRestInteractionList(inherited Clone);
end;

function TFhirCapabilityStatementRestInteractionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCapabilityStatementRestInteractionList.GetItemN(index: Integer): TFhirCapabilityStatementRestInteraction;
begin
  result := TFhirCapabilityStatementRestInteraction(ObjectByIndex[index]);
end;

function TFhirCapabilityStatementRestInteractionList.ItemClass: TFslObjectClass;
begin
  result := TFhirCapabilityStatementRestInteraction;
end;
function TFhirCapabilityStatementRestInteractionList.IndexOf(value: TFhirCapabilityStatementRestInteraction): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCapabilityStatementRestInteractionList.Insert(index: Integer): TFhirCapabilityStatementRestInteraction;
begin
  result := TFhirCapabilityStatementRestInteraction.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCapabilityStatementRestInteractionList.InsertItem(index: Integer; value: TFhirCapabilityStatementRestInteraction);
begin
  assert(value is TFhirCapabilityStatementRestInteraction);
  Inherited Insert(index, value);
end;

function TFhirCapabilityStatementRestInteractionList.Item(index: Integer): TFhirCapabilityStatementRestInteraction;
begin
  result := TFhirCapabilityStatementRestInteraction(ObjectByIndex[index]);
end;

function TFhirCapabilityStatementRestInteractionList.Link: TFhirCapabilityStatementRestInteractionList;
begin
  result := TFhirCapabilityStatementRestInteractionList(inherited Link);
end;

procedure TFhirCapabilityStatementRestInteractionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCapabilityStatementRestInteractionList.SetItemByIndex(index: Integer; value: TFhirCapabilityStatementRestInteraction);
begin
  assert(value is TFhirCapabilityStatementRestInteraction);
  FhirCapabilityStatementRestInteractions[index] := value;
end;

procedure TFhirCapabilityStatementRestInteractionList.SetItemN(index: Integer; value: TFhirCapabilityStatementRestInteraction);
begin
  assert(value is TFhirCapabilityStatementRestInteraction);
  ObjectByIndex[index] := value;
end;

{ TFhirCapabilityStatementMessaging }

constructor TFhirCapabilityStatementMessaging.Create;
begin
  inherited;
end;

destructor TFhirCapabilityStatementMessaging.Destroy;
begin
  FEndpointList.Free;
  FReliableCache.free;
  FDocumentation.free;
  FSupportedMessageList.Free;
  inherited;
end;

procedure TFhirCapabilityStatementMessaging.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirCapabilityStatementMessaging(oSource).FEndpointList = nil) then
  begin
    FEndpointList.free;
    FEndpointList := nil;
  end
  else
  begin
    if FEndpointList = nil then
      FEndpointList := TFhirCapabilityStatementMessagingEndpointList.Create;
    FEndpointList.Assign(TFhirCapabilityStatementMessaging(oSource).FEndpointList);
  end;
  reliableCacheElement := TFhirCapabilityStatementMessaging(oSource).reliableCacheElement.Clone;
  documentationElement := TFhirCapabilityStatementMessaging(oSource).documentationElement.Clone;
  if (TFhirCapabilityStatementMessaging(oSource).FSupportedMessageList = nil) then
  begin
    FSupportedMessageList.free;
    FSupportedMessageList := nil;
  end
  else
  begin
    if FSupportedMessageList = nil then
      FSupportedMessageList := TFhirCapabilityStatementMessagingSupportedMessageList.Create;
    FSupportedMessageList.Assign(TFhirCapabilityStatementMessaging(oSource).FSupportedMessageList);
  end;
end;

procedure TFhirCapabilityStatementMessaging.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'endpoint') Then
    list.addAll(self, 'endpoint', FEndpointList);
  if (child_name = 'reliableCache') Then
     list.add(self.link, 'reliableCache', FReliableCache.Link);
  if (child_name = 'documentation') Then
     list.add(self.link, 'documentation', FDocumentation.Link);
  if (child_name = 'supportedMessage') Then
    list.addAll(self, 'supportedMessage', FSupportedMessageList);
end;

procedure TFhirCapabilityStatementMessaging.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'endpoint', 'BackboneElement', true, TFhirCapabilityStatementMessagingEndpoint, FEndpointList.Link));
  oList.add(TFHIRProperty.create(self, 'reliableCache', 'unsignedInt', false, TFhirUnsignedInt, FReliableCache.Link));
  oList.add(TFHIRProperty.create(self, 'documentation', 'markdown', false, TFhirMarkdown, FDocumentation.Link));
  oList.add(TFHIRProperty.create(self, 'supportedMessage', 'BackboneElement', true, TFhirCapabilityStatementMessagingSupportedMessage, FSupportedMessageList.Link));
end;

function TFhirCapabilityStatementMessaging.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'endpoint') then
  begin
    EndpointList.add(propValue as TFhirCapabilityStatementMessagingEndpoint);
    result := propValue;
  end
  else if (propName = 'reliableCache') then
  begin
    ReliableCacheElement := asUnsignedInt(propValue);
    result := propValue;
  end
  else if (propName = 'documentation') then
  begin
    DocumentationElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'supportedMessage') then
  begin
    SupportedMessageList.add(propValue as TFhirCapabilityStatementMessagingSupportedMessage);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCapabilityStatementMessaging.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'endpoint') then EndpointList.insertItem(index, propValue as TFhirCapabilityStatementMessagingEndpoint)
  else if (propName = 'supportedMessage') then SupportedMessageList.insertItem(index, propValue as TFhirCapabilityStatementMessagingSupportedMessage)
  else inherited;
end;

function TFhirCapabilityStatementMessaging.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'endpoint') then result := EndpointList.new()
  else if (propName = 'reliableCache') then result := TFhirUnsignedInt.create()
  else if (propName = 'documentation') then result := TFhirMarkdown.create()
  else if (propName = 'supportedMessage') then result := SupportedMessageList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirCapabilityStatementMessaging.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'endpoint') then result := 'BackboneElement'
  else if (propName = 'reliableCache') then result := 'unsignedInt'
  else if (propName = 'documentation') then result := 'markdown'
  else if (propName = 'supportedMessage') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCapabilityStatementMessaging.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'endpoint') then deletePropertyValue('endpoint', EndpointList, value)
  else if (propName = 'reliableCache') then ReliableCacheElement := nil
  else if (propName = 'documentation') then DocumentationElement := nil
  else if (propName = 'supportedMessage') then deletePropertyValue('supportedMessage', SupportedMessageList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCapabilityStatementMessaging.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'endpoint') then replacePropertyValue('endpoint', EndpointList, existing, new)
  else if (propName = 'reliableCache') then ReliableCacheElement := asUnsignedInt(new)
  else if (propName = 'documentation') then DocumentationElement := asMarkdown(new)
  else if (propName = 'supportedMessage') then replacePropertyValue('supportedMessage', SupportedMessageList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCapabilityStatementMessaging.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'endpoint') then EndpointList.move(source, destination)
  else if (propName = 'supportedMessage') then SupportedMessageList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCapabilityStatementMessaging.fhirType : string;
begin
  result := 'CapabilityStatement.messaging';
end;

function TFhirCapabilityStatementMessaging.Link : TFhirCapabilityStatementMessaging;
begin
  result := TFhirCapabilityStatementMessaging(inherited Link);
end;

function TFhirCapabilityStatementMessaging.Clone : TFhirCapabilityStatementMessaging;
begin
  result := TFhirCapabilityStatementMessaging(inherited Clone);
end;

function TFhirCapabilityStatementMessaging.equals(other : TObject) : boolean; 
var
  o : TFhirCapabilityStatementMessaging;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCapabilityStatementMessaging)) then
    result := false
  else
  begin
    o := TFhirCapabilityStatementMessaging(other);
    result := compareDeep(endpointList, o.endpointList, true) and compareDeep(reliableCacheElement, o.reliableCacheElement, true) and 
      compareDeep(documentationElement, o.documentationElement, true) and compareDeep(supportedMessageList, o.supportedMessageList, true);
  end;
end;

function TFhirCapabilityStatementMessaging.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FendpointList) and isEmptyProp(FReliableCache) and isEmptyProp(FDocumentation) and isEmptyProp(FsupportedMessageList);
end;

procedure TFhirCapabilityStatementMessaging.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('endpoint');
  fields.add('reliableCache');
  fields.add('documentation');
  fields.add('supportedMessage');
end;

function TFhirCapabilityStatementMessaging.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FEndpointList.sizeInBytes(magic));
  inc(result, FSupportedMessageList.sizeInBytes(magic));
end;

function TFhirCapabilityStatementMessaging.GetEndpointList : TFhirCapabilityStatementMessagingEndpointList;
begin
  if FEndpointList = nil then
    FEndpointList := TFhirCapabilityStatementMessagingEndpointList.Create;
  result := FEndpointList;
end;

function TFhirCapabilityStatementMessaging.GetHasEndpointList : boolean;
begin
  result := (FEndpointList <> nil) and (FEndpointList.count > 0);
end;

procedure TFhirCapabilityStatementMessaging.SetReliableCache(value : TFhirUnsignedInt);
begin
  FReliableCache.free;
  FReliableCache := value;
end;

function TFhirCapabilityStatementMessaging.GetReliableCacheST : String;
begin
  if FReliableCache = nil then
    result := ''
  else
    result := FReliableCache.value;
end;

procedure TFhirCapabilityStatementMessaging.SetReliableCacheST(value : String);
begin
  if value <> '' then
  begin
    if FReliableCache = nil then
      FReliableCache := TFhirUnsignedInt.create;
    FReliableCache.value := value
  end
  else if FReliableCache <> nil then
    FReliableCache.value := '';
end;

procedure TFhirCapabilityStatementMessaging.SetDocumentation(value : TFhirMarkdown);
begin
  FDocumentation.free;
  FDocumentation := value;
end;

function TFhirCapabilityStatementMessaging.GetDocumentationST : String;
begin
  if FDocumentation = nil then
    result := ''
  else
    result := FDocumentation.value;
end;

procedure TFhirCapabilityStatementMessaging.SetDocumentationST(value : String);
begin
  if value <> '' then
  begin
    if FDocumentation = nil then
      FDocumentation := TFhirMarkdown.create;
    FDocumentation.value := value
  end
  else if FDocumentation <> nil then
    FDocumentation.value := '';
end;

function TFhirCapabilityStatementMessaging.GetSupportedMessageList : TFhirCapabilityStatementMessagingSupportedMessageList;
begin
  if FSupportedMessageList = nil then
    FSupportedMessageList := TFhirCapabilityStatementMessagingSupportedMessageList.Create;
  result := FSupportedMessageList;
end;

function TFhirCapabilityStatementMessaging.GetHasSupportedMessageList : boolean;
begin
  result := (FSupportedMessageList <> nil) and (FSupportedMessageList.count > 0);
end;

{ TFhirCapabilityStatementMessagingListEnumerator }

constructor TFhirCapabilityStatementMessagingListEnumerator.Create(list : TFhirCapabilityStatementMessagingList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCapabilityStatementMessagingListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCapabilityStatementMessagingListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCapabilityStatementMessagingListEnumerator.GetCurrent : TFhirCapabilityStatementMessaging;
begin
  Result := FList[FIndex];
end;

function TFhirCapabilityStatementMessagingListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCapabilityStatementMessagingList }

function TFhirCapabilityStatementMessagingList.AddItem(value: TFhirCapabilityStatementMessaging): TFhirCapabilityStatementMessaging;
begin
  assert(value.ClassName = 'TFhirCapabilityStatementMessaging', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCapabilityStatementMessaging');
  add(value);
  result := value;
end;

function TFhirCapabilityStatementMessagingList.Append: TFhirCapabilityStatementMessaging;
begin
  result := TFhirCapabilityStatementMessaging.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCapabilityStatementMessagingList.ClearItems;
begin
  Clear;
end;

function TFhirCapabilityStatementMessagingList.GetEnumerator : TFhirCapabilityStatementMessagingListEnumerator;
begin
  result := TFhirCapabilityStatementMessagingListEnumerator.Create(self.link);
end;

function TFhirCapabilityStatementMessagingList.Clone: TFhirCapabilityStatementMessagingList;
begin
  result := TFhirCapabilityStatementMessagingList(inherited Clone);
end;

function TFhirCapabilityStatementMessagingList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCapabilityStatementMessagingList.GetItemN(index: Integer): TFhirCapabilityStatementMessaging;
begin
  result := TFhirCapabilityStatementMessaging(ObjectByIndex[index]);
end;

function TFhirCapabilityStatementMessagingList.ItemClass: TFslObjectClass;
begin
  result := TFhirCapabilityStatementMessaging;
end;
function TFhirCapabilityStatementMessagingList.IndexOf(value: TFhirCapabilityStatementMessaging): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCapabilityStatementMessagingList.Insert(index: Integer): TFhirCapabilityStatementMessaging;
begin
  result := TFhirCapabilityStatementMessaging.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCapabilityStatementMessagingList.InsertItem(index: Integer; value: TFhirCapabilityStatementMessaging);
begin
  assert(value is TFhirCapabilityStatementMessaging);
  Inherited Insert(index, value);
end;

function TFhirCapabilityStatementMessagingList.Item(index: Integer): TFhirCapabilityStatementMessaging;
begin
  result := TFhirCapabilityStatementMessaging(ObjectByIndex[index]);
end;

function TFhirCapabilityStatementMessagingList.Link: TFhirCapabilityStatementMessagingList;
begin
  result := TFhirCapabilityStatementMessagingList(inherited Link);
end;

procedure TFhirCapabilityStatementMessagingList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCapabilityStatementMessagingList.SetItemByIndex(index: Integer; value: TFhirCapabilityStatementMessaging);
begin
  assert(value is TFhirCapabilityStatementMessaging);
  FhirCapabilityStatementMessagings[index] := value;
end;

procedure TFhirCapabilityStatementMessagingList.SetItemN(index: Integer; value: TFhirCapabilityStatementMessaging);
begin
  assert(value is TFhirCapabilityStatementMessaging);
  ObjectByIndex[index] := value;
end;

{ TFhirCapabilityStatementMessagingEndpoint }

constructor TFhirCapabilityStatementMessagingEndpoint.Create;
begin
  inherited;
end;

destructor TFhirCapabilityStatementMessagingEndpoint.Destroy;
begin
  FProtocol.free;
  FAddress.free;
  inherited;
end;

procedure TFhirCapabilityStatementMessagingEndpoint.Assign(oSource : TFslObject);
begin
  inherited;
  protocol := TFhirCapabilityStatementMessagingEndpoint(oSource).protocol.Clone;
  addressElement := TFhirCapabilityStatementMessagingEndpoint(oSource).addressElement.Clone;
end;

procedure TFhirCapabilityStatementMessagingEndpoint.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'protocol') Then
     list.add(self.link, 'protocol', FProtocol.Link);
  if (child_name = 'address') Then
     list.add(self.link, 'address', FAddress.Link);
end;

procedure TFhirCapabilityStatementMessagingEndpoint.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'protocol', 'Coding', false, TFhirCoding, FProtocol.Link));
  oList.add(TFHIRProperty.create(self, 'address', 'url', false, TFhirUrl, FAddress.Link));
end;

function TFhirCapabilityStatementMessagingEndpoint.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'protocol') then
  begin
    Protocol := propValue as TFhirCoding;
    result := propValue;
  end
  else if (propName = 'address') then
  begin
    AddressElement := asUrl(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCapabilityStatementMessagingEndpoint.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCapabilityStatementMessagingEndpoint.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'protocol') then result := TFhirCoding.create()
  else if (propName = 'address') then result := TFhirUrl.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirCapabilityStatementMessagingEndpoint.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'protocol') then result := 'Coding'
  else if (propName = 'address') then result := 'url'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCapabilityStatementMessagingEndpoint.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'protocol') then ProtocolElement := nil
  else if (propName = 'address') then AddressElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCapabilityStatementMessagingEndpoint.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'protocol') then ProtocolElement := new as TFhirCoding
  else if (propName = 'address') then AddressElement := asUrl(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCapabilityStatementMessagingEndpoint.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCapabilityStatementMessagingEndpoint.fhirType : string;
begin
  result := 'CapabilityStatement.messaging.endpoint';
end;

function TFhirCapabilityStatementMessagingEndpoint.Link : TFhirCapabilityStatementMessagingEndpoint;
begin
  result := TFhirCapabilityStatementMessagingEndpoint(inherited Link);
end;

function TFhirCapabilityStatementMessagingEndpoint.Clone : TFhirCapabilityStatementMessagingEndpoint;
begin
  result := TFhirCapabilityStatementMessagingEndpoint(inherited Clone);
end;

function TFhirCapabilityStatementMessagingEndpoint.equals(other : TObject) : boolean; 
var
  o : TFhirCapabilityStatementMessagingEndpoint;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCapabilityStatementMessagingEndpoint)) then
    result := false
  else
  begin
    o := TFhirCapabilityStatementMessagingEndpoint(other);
    result := compareDeep(protocolElement, o.protocolElement, true) and compareDeep(addressElement, o.addressElement, true);
  end;
end;

function TFhirCapabilityStatementMessagingEndpoint.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FProtocol) and isEmptyProp(FAddress);
end;

procedure TFhirCapabilityStatementMessagingEndpoint.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('protocol');
  fields.add('address');
end;

function TFhirCapabilityStatementMessagingEndpoint.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirCapabilityStatementMessagingEndpoint.SetProtocol(value : TFhirCoding);
begin
  FProtocol.free;
  FProtocol := value;
end;

procedure TFhirCapabilityStatementMessagingEndpoint.SetAddress(value : TFhirUrl);
begin
  FAddress.free;
  FAddress := value;
end;

function TFhirCapabilityStatementMessagingEndpoint.GetAddressST : String;
begin
  if FAddress = nil then
    result := ''
  else
    result := FAddress.value;
end;

procedure TFhirCapabilityStatementMessagingEndpoint.SetAddressST(value : String);
begin
  if value <> '' then
  begin
    if FAddress = nil then
      FAddress := TFhirUrl.create;
    FAddress.value := value
  end
  else if FAddress <> nil then
    FAddress.value := '';
end;

{ TFhirCapabilityStatementMessagingEndpointListEnumerator }

constructor TFhirCapabilityStatementMessagingEndpointListEnumerator.Create(list : TFhirCapabilityStatementMessagingEndpointList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCapabilityStatementMessagingEndpointListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCapabilityStatementMessagingEndpointListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCapabilityStatementMessagingEndpointListEnumerator.GetCurrent : TFhirCapabilityStatementMessagingEndpoint;
begin
  Result := FList[FIndex];
end;

function TFhirCapabilityStatementMessagingEndpointListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCapabilityStatementMessagingEndpointList }

function TFhirCapabilityStatementMessagingEndpointList.AddItem(value: TFhirCapabilityStatementMessagingEndpoint): TFhirCapabilityStatementMessagingEndpoint;
begin
  assert(value.ClassName = 'TFhirCapabilityStatementMessagingEndpoint', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCapabilityStatementMessagingEndpoint');
  add(value);
  result := value;
end;

function TFhirCapabilityStatementMessagingEndpointList.Append: TFhirCapabilityStatementMessagingEndpoint;
begin
  result := TFhirCapabilityStatementMessagingEndpoint.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCapabilityStatementMessagingEndpointList.ClearItems;
begin
  Clear;
end;

function TFhirCapabilityStatementMessagingEndpointList.GetEnumerator : TFhirCapabilityStatementMessagingEndpointListEnumerator;
begin
  result := TFhirCapabilityStatementMessagingEndpointListEnumerator.Create(self.link);
end;

function TFhirCapabilityStatementMessagingEndpointList.Clone: TFhirCapabilityStatementMessagingEndpointList;
begin
  result := TFhirCapabilityStatementMessagingEndpointList(inherited Clone);
end;

function TFhirCapabilityStatementMessagingEndpointList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCapabilityStatementMessagingEndpointList.GetItemN(index: Integer): TFhirCapabilityStatementMessagingEndpoint;
begin
  result := TFhirCapabilityStatementMessagingEndpoint(ObjectByIndex[index]);
end;

function TFhirCapabilityStatementMessagingEndpointList.ItemClass: TFslObjectClass;
begin
  result := TFhirCapabilityStatementMessagingEndpoint;
end;
function TFhirCapabilityStatementMessagingEndpointList.IndexOf(value: TFhirCapabilityStatementMessagingEndpoint): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCapabilityStatementMessagingEndpointList.Insert(index: Integer): TFhirCapabilityStatementMessagingEndpoint;
begin
  result := TFhirCapabilityStatementMessagingEndpoint.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCapabilityStatementMessagingEndpointList.InsertItem(index: Integer; value: TFhirCapabilityStatementMessagingEndpoint);
begin
  assert(value is TFhirCapabilityStatementMessagingEndpoint);
  Inherited Insert(index, value);
end;

function TFhirCapabilityStatementMessagingEndpointList.Item(index: Integer): TFhirCapabilityStatementMessagingEndpoint;
begin
  result := TFhirCapabilityStatementMessagingEndpoint(ObjectByIndex[index]);
end;

function TFhirCapabilityStatementMessagingEndpointList.Link: TFhirCapabilityStatementMessagingEndpointList;
begin
  result := TFhirCapabilityStatementMessagingEndpointList(inherited Link);
end;

procedure TFhirCapabilityStatementMessagingEndpointList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCapabilityStatementMessagingEndpointList.SetItemByIndex(index: Integer; value: TFhirCapabilityStatementMessagingEndpoint);
begin
  assert(value is TFhirCapabilityStatementMessagingEndpoint);
  FhirCapabilityStatementMessagingEndpoints[index] := value;
end;

procedure TFhirCapabilityStatementMessagingEndpointList.SetItemN(index: Integer; value: TFhirCapabilityStatementMessagingEndpoint);
begin
  assert(value is TFhirCapabilityStatementMessagingEndpoint);
  ObjectByIndex[index] := value;
end;

{ TFhirCapabilityStatementMessagingSupportedMessage }

constructor TFhirCapabilityStatementMessagingSupportedMessage.Create;
begin
  inherited;
end;

destructor TFhirCapabilityStatementMessagingSupportedMessage.Destroy;
begin
  FMode.free;
  FDefinition.free;
  inherited;
end;

procedure TFhirCapabilityStatementMessagingSupportedMessage.Assign(oSource : TFslObject);
begin
  inherited;
  modeElement := TFhirCapabilityStatementMessagingSupportedMessage(oSource).modeElement.Clone;
  definitionElement := TFhirCapabilityStatementMessagingSupportedMessage(oSource).definitionElement.Clone;
end;

procedure TFhirCapabilityStatementMessagingSupportedMessage.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'mode') Then
     list.add(self.link, 'mode', FMode.Link);
  if (child_name = 'definition') Then
     list.add(self.link, 'definition', FDefinition.Link);
end;

procedure TFhirCapabilityStatementMessagingSupportedMessage.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'mode', 'code', false, TFhirEnum, FMode.Link));
  oList.add(TFHIRProperty.create(self, 'definition', 'canonical', false, TFhirCanonical, FDefinition.Link));
end;

function TFhirCapabilityStatementMessagingSupportedMessage.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'mode') then
  begin
    ModeElement := asEnum(SYSTEMS_TFhirEventCapabilityModeEnum, CODES_TFhirEventCapabilityModeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'definition') then
  begin
    DefinitionElement := asCanonical(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCapabilityStatementMessagingSupportedMessage.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCapabilityStatementMessagingSupportedMessage.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'mode') then result := TFhirEnum.create(SYSTEMS_TFhirEventCapabilityModeEnum[EventCapabilityModeNull], CODES_TFhirEventCapabilityModeEnum[EventCapabilityModeNull]) 
  else if (propName = 'definition') then result := TFhirCanonical.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirCapabilityStatementMessagingSupportedMessage.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'mode') then result := 'code'
  else if (propName = 'definition') then result := 'canonical'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCapabilityStatementMessagingSupportedMessage.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'mode') then ModeElement := nil
  else if (propName = 'definition') then DefinitionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCapabilityStatementMessagingSupportedMessage.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'mode') then ModeElement := asEnum(SYSTEMS_TFhirEventCapabilityModeEnum, CODES_TFhirEventCapabilityModeEnum, new)
  else if (propName = 'definition') then DefinitionElement := asCanonical(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCapabilityStatementMessagingSupportedMessage.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCapabilityStatementMessagingSupportedMessage.fhirType : string;
begin
  result := 'CapabilityStatement.messaging.supportedMessage';
end;

function TFhirCapabilityStatementMessagingSupportedMessage.Link : TFhirCapabilityStatementMessagingSupportedMessage;
begin
  result := TFhirCapabilityStatementMessagingSupportedMessage(inherited Link);
end;

function TFhirCapabilityStatementMessagingSupportedMessage.Clone : TFhirCapabilityStatementMessagingSupportedMessage;
begin
  result := TFhirCapabilityStatementMessagingSupportedMessage(inherited Clone);
end;

function TFhirCapabilityStatementMessagingSupportedMessage.equals(other : TObject) : boolean; 
var
  o : TFhirCapabilityStatementMessagingSupportedMessage;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCapabilityStatementMessagingSupportedMessage)) then
    result := false
  else
  begin
    o := TFhirCapabilityStatementMessagingSupportedMessage(other);
    result := compareDeep(modeElement, o.modeElement, true) and compareDeep(definitionElement, o.definitionElement, true);
  end;
end;

function TFhirCapabilityStatementMessagingSupportedMessage.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FMode) and isEmptyProp(FDefinition);
end;

procedure TFhirCapabilityStatementMessagingSupportedMessage.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('mode');
  fields.add('definition');
end;

function TFhirCapabilityStatementMessagingSupportedMessage.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirCapabilityStatementMessagingSupportedMessage.SetMode(value : TFhirEnum);
begin
  FMode.free;
  FMode := value;
end;

function TFhirCapabilityStatementMessagingSupportedMessage.GetModeST : TFhirEventCapabilityModeEnum;
begin
  if FMode = nil then
    result := TFhirEventCapabilityModeEnum(0)
  else
    result := TFhirEventCapabilityModeEnum(StringArrayIndexOfSensitive(CODES_TFhirEventCapabilityModeEnum, FMode.value));
end;

procedure TFhirCapabilityStatementMessagingSupportedMessage.SetModeST(value : TFhirEventCapabilityModeEnum);
begin
  if ord(value) = 0 then
    ModeElement := nil
  else
    ModeElement := TFhirEnum.create(SYSTEMS_TFhirEventCapabilityModeEnum[value], CODES_TFhirEventCapabilityModeEnum[value]);
end;

procedure TFhirCapabilityStatementMessagingSupportedMessage.SetDefinition(value : TFhirCanonical);
begin
  FDefinition.free;
  FDefinition := value;
end;

function TFhirCapabilityStatementMessagingSupportedMessage.GetDefinitionST : String;
begin
  if FDefinition = nil then
    result := ''
  else
    result := FDefinition.value;
end;

procedure TFhirCapabilityStatementMessagingSupportedMessage.SetDefinitionST(value : String);
begin
  if value <> '' then
  begin
    if FDefinition = nil then
      FDefinition := TFhirCanonical.create;
    FDefinition.value := value
  end
  else if FDefinition <> nil then
    FDefinition.value := '';
end;

{ TFhirCapabilityStatementMessagingSupportedMessageListEnumerator }

constructor TFhirCapabilityStatementMessagingSupportedMessageListEnumerator.Create(list : TFhirCapabilityStatementMessagingSupportedMessageList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCapabilityStatementMessagingSupportedMessageListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCapabilityStatementMessagingSupportedMessageListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCapabilityStatementMessagingSupportedMessageListEnumerator.GetCurrent : TFhirCapabilityStatementMessagingSupportedMessage;
begin
  Result := FList[FIndex];
end;

function TFhirCapabilityStatementMessagingSupportedMessageListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCapabilityStatementMessagingSupportedMessageList }

function TFhirCapabilityStatementMessagingSupportedMessageList.AddItem(value: TFhirCapabilityStatementMessagingSupportedMessage): TFhirCapabilityStatementMessagingSupportedMessage;
begin
  assert(value.ClassName = 'TFhirCapabilityStatementMessagingSupportedMessage', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCapabilityStatementMessagingSupportedMessage');
  add(value);
  result := value;
end;

function TFhirCapabilityStatementMessagingSupportedMessageList.Append: TFhirCapabilityStatementMessagingSupportedMessage;
begin
  result := TFhirCapabilityStatementMessagingSupportedMessage.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCapabilityStatementMessagingSupportedMessageList.ClearItems;
begin
  Clear;
end;

function TFhirCapabilityStatementMessagingSupportedMessageList.GetEnumerator : TFhirCapabilityStatementMessagingSupportedMessageListEnumerator;
begin
  result := TFhirCapabilityStatementMessagingSupportedMessageListEnumerator.Create(self.link);
end;

function TFhirCapabilityStatementMessagingSupportedMessageList.Clone: TFhirCapabilityStatementMessagingSupportedMessageList;
begin
  result := TFhirCapabilityStatementMessagingSupportedMessageList(inherited Clone);
end;

function TFhirCapabilityStatementMessagingSupportedMessageList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCapabilityStatementMessagingSupportedMessageList.GetItemN(index: Integer): TFhirCapabilityStatementMessagingSupportedMessage;
begin
  result := TFhirCapabilityStatementMessagingSupportedMessage(ObjectByIndex[index]);
end;

function TFhirCapabilityStatementMessagingSupportedMessageList.ItemClass: TFslObjectClass;
begin
  result := TFhirCapabilityStatementMessagingSupportedMessage;
end;
function TFhirCapabilityStatementMessagingSupportedMessageList.IndexOf(value: TFhirCapabilityStatementMessagingSupportedMessage): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCapabilityStatementMessagingSupportedMessageList.Insert(index: Integer): TFhirCapabilityStatementMessagingSupportedMessage;
begin
  result := TFhirCapabilityStatementMessagingSupportedMessage.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCapabilityStatementMessagingSupportedMessageList.InsertItem(index: Integer; value: TFhirCapabilityStatementMessagingSupportedMessage);
begin
  assert(value is TFhirCapabilityStatementMessagingSupportedMessage);
  Inherited Insert(index, value);
end;

function TFhirCapabilityStatementMessagingSupportedMessageList.Item(index: Integer): TFhirCapabilityStatementMessagingSupportedMessage;
begin
  result := TFhirCapabilityStatementMessagingSupportedMessage(ObjectByIndex[index]);
end;

function TFhirCapabilityStatementMessagingSupportedMessageList.Link: TFhirCapabilityStatementMessagingSupportedMessageList;
begin
  result := TFhirCapabilityStatementMessagingSupportedMessageList(inherited Link);
end;

procedure TFhirCapabilityStatementMessagingSupportedMessageList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCapabilityStatementMessagingSupportedMessageList.SetItemByIndex(index: Integer; value: TFhirCapabilityStatementMessagingSupportedMessage);
begin
  assert(value is TFhirCapabilityStatementMessagingSupportedMessage);
  FhirCapabilityStatementMessagingSupportedMessages[index] := value;
end;

procedure TFhirCapabilityStatementMessagingSupportedMessageList.SetItemN(index: Integer; value: TFhirCapabilityStatementMessagingSupportedMessage);
begin
  assert(value is TFhirCapabilityStatementMessagingSupportedMessage);
  ObjectByIndex[index] := value;
end;

{ TFhirCapabilityStatementDocument }

constructor TFhirCapabilityStatementDocument.Create;
begin
  inherited;
end;

destructor TFhirCapabilityStatementDocument.Destroy;
begin
  FMode.free;
  FDocumentation.free;
  FProfile.free;
  inherited;
end;

procedure TFhirCapabilityStatementDocument.Assign(oSource : TFslObject);
begin
  inherited;
  modeElement := TFhirCapabilityStatementDocument(oSource).modeElement.Clone;
  documentationElement := TFhirCapabilityStatementDocument(oSource).documentationElement.Clone;
  profileElement := TFhirCapabilityStatementDocument(oSource).profileElement.Clone;
end;

procedure TFhirCapabilityStatementDocument.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'mode') Then
     list.add(self.link, 'mode', FMode.Link);
  if (child_name = 'documentation') Then
     list.add(self.link, 'documentation', FDocumentation.Link);
  if (child_name = 'profile') Then
     list.add(self.link, 'profile', FProfile.Link);
end;

procedure TFhirCapabilityStatementDocument.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'mode', 'code', false, TFhirEnum, FMode.Link));
  oList.add(TFHIRProperty.create(self, 'documentation', 'markdown', false, TFhirMarkdown, FDocumentation.Link));
  oList.add(TFHIRProperty.create(self, 'profile', 'canonical', false, TFhirCanonical, FProfile.Link));
end;

function TFhirCapabilityStatementDocument.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'mode') then
  begin
    ModeElement := asEnum(SYSTEMS_TFhirDocumentModeEnum, CODES_TFhirDocumentModeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'documentation') then
  begin
    DocumentationElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'profile') then
  begin
    ProfileElement := asCanonical(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCapabilityStatementDocument.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCapabilityStatementDocument.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'mode') then result := TFhirEnum.create(SYSTEMS_TFhirDocumentModeEnum[DocumentModeNull], CODES_TFhirDocumentModeEnum[DocumentModeNull]) 
  else if (propName = 'documentation') then result := TFhirMarkdown.create()
  else if (propName = 'profile') then result := TFhirCanonical.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirCapabilityStatementDocument.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'mode') then result := 'code'
  else if (propName = 'documentation') then result := 'markdown'
  else if (propName = 'profile') then result := 'canonical'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCapabilityStatementDocument.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'mode') then ModeElement := nil
  else if (propName = 'documentation') then DocumentationElement := nil
  else if (propName = 'profile') then ProfileElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCapabilityStatementDocument.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'mode') then ModeElement := asEnum(SYSTEMS_TFhirDocumentModeEnum, CODES_TFhirDocumentModeEnum, new)
  else if (propName = 'documentation') then DocumentationElement := asMarkdown(new)
  else if (propName = 'profile') then ProfileElement := asCanonical(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCapabilityStatementDocument.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCapabilityStatementDocument.fhirType : string;
begin
  result := 'CapabilityStatement.document';
end;

function TFhirCapabilityStatementDocument.Link : TFhirCapabilityStatementDocument;
begin
  result := TFhirCapabilityStatementDocument(inherited Link);
end;

function TFhirCapabilityStatementDocument.Clone : TFhirCapabilityStatementDocument;
begin
  result := TFhirCapabilityStatementDocument(inherited Clone);
end;

function TFhirCapabilityStatementDocument.equals(other : TObject) : boolean; 
var
  o : TFhirCapabilityStatementDocument;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCapabilityStatementDocument)) then
    result := false
  else
  begin
    o := TFhirCapabilityStatementDocument(other);
    result := compareDeep(modeElement, o.modeElement, true) and compareDeep(documentationElement, o.documentationElement, true) and 
      compareDeep(profileElement, o.profileElement, true);
  end;
end;

function TFhirCapabilityStatementDocument.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FMode) and isEmptyProp(FDocumentation) and isEmptyProp(FProfile);
end;

procedure TFhirCapabilityStatementDocument.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('mode');
  fields.add('documentation');
  fields.add('profile');
end;

function TFhirCapabilityStatementDocument.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirCapabilityStatementDocument.SetMode(value : TFhirEnum);
begin
  FMode.free;
  FMode := value;
end;

function TFhirCapabilityStatementDocument.GetModeST : TFhirDocumentModeEnum;
begin
  if FMode = nil then
    result := TFhirDocumentModeEnum(0)
  else
    result := TFhirDocumentModeEnum(StringArrayIndexOfSensitive(CODES_TFhirDocumentModeEnum, FMode.value));
end;

procedure TFhirCapabilityStatementDocument.SetModeST(value : TFhirDocumentModeEnum);
begin
  if ord(value) = 0 then
    ModeElement := nil
  else
    ModeElement := TFhirEnum.create(SYSTEMS_TFhirDocumentModeEnum[value], CODES_TFhirDocumentModeEnum[value]);
end;

procedure TFhirCapabilityStatementDocument.SetDocumentation(value : TFhirMarkdown);
begin
  FDocumentation.free;
  FDocumentation := value;
end;

function TFhirCapabilityStatementDocument.GetDocumentationST : String;
begin
  if FDocumentation = nil then
    result := ''
  else
    result := FDocumentation.value;
end;

procedure TFhirCapabilityStatementDocument.SetDocumentationST(value : String);
begin
  if value <> '' then
  begin
    if FDocumentation = nil then
      FDocumentation := TFhirMarkdown.create;
    FDocumentation.value := value
  end
  else if FDocumentation <> nil then
    FDocumentation.value := '';
end;

procedure TFhirCapabilityStatementDocument.SetProfile(value : TFhirCanonical);
begin
  FProfile.free;
  FProfile := value;
end;

function TFhirCapabilityStatementDocument.GetProfileST : String;
begin
  if FProfile = nil then
    result := ''
  else
    result := FProfile.value;
end;

procedure TFhirCapabilityStatementDocument.SetProfileST(value : String);
begin
  if value <> '' then
  begin
    if FProfile = nil then
      FProfile := TFhirCanonical.create;
    FProfile.value := value
  end
  else if FProfile <> nil then
    FProfile.value := '';
end;

{ TFhirCapabilityStatementDocumentListEnumerator }

constructor TFhirCapabilityStatementDocumentListEnumerator.Create(list : TFhirCapabilityStatementDocumentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCapabilityStatementDocumentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCapabilityStatementDocumentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCapabilityStatementDocumentListEnumerator.GetCurrent : TFhirCapabilityStatementDocument;
begin
  Result := FList[FIndex];
end;

function TFhirCapabilityStatementDocumentListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCapabilityStatementDocumentList }

function TFhirCapabilityStatementDocumentList.AddItem(value: TFhirCapabilityStatementDocument): TFhirCapabilityStatementDocument;
begin
  assert(value.ClassName = 'TFhirCapabilityStatementDocument', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCapabilityStatementDocument');
  add(value);
  result := value;
end;

function TFhirCapabilityStatementDocumentList.Append: TFhirCapabilityStatementDocument;
begin
  result := TFhirCapabilityStatementDocument.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCapabilityStatementDocumentList.ClearItems;
begin
  Clear;
end;

function TFhirCapabilityStatementDocumentList.GetEnumerator : TFhirCapabilityStatementDocumentListEnumerator;
begin
  result := TFhirCapabilityStatementDocumentListEnumerator.Create(self.link);
end;

function TFhirCapabilityStatementDocumentList.Clone: TFhirCapabilityStatementDocumentList;
begin
  result := TFhirCapabilityStatementDocumentList(inherited Clone);
end;

function TFhirCapabilityStatementDocumentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCapabilityStatementDocumentList.GetItemN(index: Integer): TFhirCapabilityStatementDocument;
begin
  result := TFhirCapabilityStatementDocument(ObjectByIndex[index]);
end;

function TFhirCapabilityStatementDocumentList.ItemClass: TFslObjectClass;
begin
  result := TFhirCapabilityStatementDocument;
end;
function TFhirCapabilityStatementDocumentList.IndexOf(value: TFhirCapabilityStatementDocument): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCapabilityStatementDocumentList.Insert(index: Integer): TFhirCapabilityStatementDocument;
begin
  result := TFhirCapabilityStatementDocument.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCapabilityStatementDocumentList.InsertItem(index: Integer; value: TFhirCapabilityStatementDocument);
begin
  assert(value is TFhirCapabilityStatementDocument);
  Inherited Insert(index, value);
end;

function TFhirCapabilityStatementDocumentList.Item(index: Integer): TFhirCapabilityStatementDocument;
begin
  result := TFhirCapabilityStatementDocument(ObjectByIndex[index]);
end;

function TFhirCapabilityStatementDocumentList.Link: TFhirCapabilityStatementDocumentList;
begin
  result := TFhirCapabilityStatementDocumentList(inherited Link);
end;

procedure TFhirCapabilityStatementDocumentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCapabilityStatementDocumentList.SetItemByIndex(index: Integer; value: TFhirCapabilityStatementDocument);
begin
  assert(value is TFhirCapabilityStatementDocument);
  FhirCapabilityStatementDocuments[index] := value;
end;

procedure TFhirCapabilityStatementDocumentList.SetItemN(index: Integer; value: TFhirCapabilityStatementDocument);
begin
  assert(value is TFhirCapabilityStatementDocument);
  ObjectByIndex[index] := value;
end;

{ TFhirCapabilityStatement }

constructor TFhirCapabilityStatement.Create;
begin
  inherited;
end;

destructor TFhirCapabilityStatement.Destroy;
begin
  FUrl.free;
  FVersion.free;
  FName.free;
  FTitle.free;
  FStatus.free;
  FExperimental.free;
  FDate.free;
  FPublisher.free;
  FContactList.Free;
  FDescription.free;
  FUseContextList.Free;
  FJurisdictionList.Free;
  FPurpose.free;
  FCopyright.free;
  FKind.free;
  FInstantiatesList.Free;
  FImportsList.Free;
  FSoftware.free;
  FImplementation_.free;
  FFhirVersion.free;
  FFormatList.Free;
  FPatchFormatList.Free;
  FImplementationGuideList.Free;
  FRestList.Free;
  FMessagingList.Free;
  FDocumentList.Free;
  inherited;
end;

procedure TFhirCapabilityStatement.Assign(oSource : TFslObject);
begin
  inherited;
  urlElement := TFhirCapabilityStatement(oSource).urlElement.Clone;
  versionElement := TFhirCapabilityStatement(oSource).versionElement.Clone;
  nameElement := TFhirCapabilityStatement(oSource).nameElement.Clone;
  titleElement := TFhirCapabilityStatement(oSource).titleElement.Clone;
  statusElement := TFhirCapabilityStatement(oSource).statusElement.Clone;
  experimentalElement := TFhirCapabilityStatement(oSource).experimentalElement.Clone;
  dateElement := TFhirCapabilityStatement(oSource).dateElement.Clone;
  publisherElement := TFhirCapabilityStatement(oSource).publisherElement.Clone;
  if (TFhirCapabilityStatement(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirContactDetailList.Create;
    FContactList.Assign(TFhirCapabilityStatement(oSource).FContactList);
  end;
  descriptionElement := TFhirCapabilityStatement(oSource).descriptionElement.Clone;
  if (TFhirCapabilityStatement(oSource).FUseContextList = nil) then
  begin
    FUseContextList.free;
    FUseContextList := nil;
  end
  else
  begin
    if FUseContextList = nil then
      FUseContextList := TFhirUsageContextList.Create;
    FUseContextList.Assign(TFhirCapabilityStatement(oSource).FUseContextList);
  end;
  if (TFhirCapabilityStatement(oSource).FJurisdictionList = nil) then
  begin
    FJurisdictionList.free;
    FJurisdictionList := nil;
  end
  else
  begin
    if FJurisdictionList = nil then
      FJurisdictionList := TFhirCodeableConceptList.Create;
    FJurisdictionList.Assign(TFhirCapabilityStatement(oSource).FJurisdictionList);
  end;
  purposeElement := TFhirCapabilityStatement(oSource).purposeElement.Clone;
  copyrightElement := TFhirCapabilityStatement(oSource).copyrightElement.Clone;
  kindElement := TFhirCapabilityStatement(oSource).kindElement.Clone;
  if (TFhirCapabilityStatement(oSource).FInstantiatesList = nil) then
  begin
    FInstantiatesList.free;
    FInstantiatesList := nil;
  end
  else
  begin
    if FInstantiatesList = nil then
      FInstantiatesList := TFhirCanonicalList.Create;
    FInstantiatesList.Assign(TFhirCapabilityStatement(oSource).FInstantiatesList);
  end;
  if (TFhirCapabilityStatement(oSource).FImportsList = nil) then
  begin
    FImportsList.free;
    FImportsList := nil;
  end
  else
  begin
    if FImportsList = nil then
      FImportsList := TFhirCanonicalList.Create;
    FImportsList.Assign(TFhirCapabilityStatement(oSource).FImportsList);
  end;
  software := TFhirCapabilityStatement(oSource).software.Clone;
  implementation_ := TFhirCapabilityStatement(oSource).implementation_.Clone;
  fhirVersionElement := TFhirCapabilityStatement(oSource).fhirVersionElement.Clone;
  if (TFhirCapabilityStatement(oSource).FFormatList = nil) then
  begin
    FFormatList.free;
    FFormatList := nil;
  end
  else
  begin
    if FFormatList = nil then
      FFormatList := TFhirCodeList.Create;
    FFormatList.Assign(TFhirCapabilityStatement(oSource).FFormatList);
  end;
  if (TFhirCapabilityStatement(oSource).FPatchFormatList = nil) then
  begin
    FPatchFormatList.free;
    FPatchFormatList := nil;
  end
  else
  begin
    if FPatchFormatList = nil then
      FPatchFormatList := TFhirCodeList.Create;
    FPatchFormatList.Assign(TFhirCapabilityStatement(oSource).FPatchFormatList);
  end;
  if (TFhirCapabilityStatement(oSource).FImplementationGuideList = nil) then
  begin
    FImplementationGuideList.free;
    FImplementationGuideList := nil;
  end
  else
  begin
    if FImplementationGuideList = nil then
      FImplementationGuideList := TFhirCanonicalList.Create;
    FImplementationGuideList.Assign(TFhirCapabilityStatement(oSource).FImplementationGuideList);
  end;
  if (TFhirCapabilityStatement(oSource).FRestList = nil) then
  begin
    FRestList.free;
    FRestList := nil;
  end
  else
  begin
    if FRestList = nil then
      FRestList := TFhirCapabilityStatementRestList.Create;
    FRestList.Assign(TFhirCapabilityStatement(oSource).FRestList);
  end;
  if (TFhirCapabilityStatement(oSource).FMessagingList = nil) then
  begin
    FMessagingList.free;
    FMessagingList := nil;
  end
  else
  begin
    if FMessagingList = nil then
      FMessagingList := TFhirCapabilityStatementMessagingList.Create;
    FMessagingList.Assign(TFhirCapabilityStatement(oSource).FMessagingList);
  end;
  if (TFhirCapabilityStatement(oSource).FDocumentList = nil) then
  begin
    FDocumentList.free;
    FDocumentList := nil;
  end
  else
  begin
    if FDocumentList = nil then
      FDocumentList := TFhirCapabilityStatementDocumentList.Create;
    FDocumentList.Assign(TFhirCapabilityStatement(oSource).FDocumentList);
  end;
end;

function TFhirCapabilityStatement.GetResourceType : TFhirResourceType;
begin
  result := frtCapabilityStatement;
end;

procedure TFhirCapabilityStatement.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
  if (child_name = 'version') Then
     list.add(self.link, 'version', FVersion.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'experimental') Then
     list.add(self.link, 'experimental', FExperimental.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'publisher') Then
     list.add(self.link, 'publisher', FPublisher.Link);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'useContext') Then
    list.addAll(self, 'useContext', FUseContextList);
  if (child_name = 'jurisdiction') Then
    list.addAll(self, 'jurisdiction', FJurisdictionList);
  if (child_name = 'purpose') Then
     list.add(self.link, 'purpose', FPurpose.Link);
  if (child_name = 'copyright') Then
     list.add(self.link, 'copyright', FCopyright.Link);
  if (child_name = 'kind') Then
     list.add(self.link, 'kind', FKind.Link);
  if (child_name = 'instantiates') Then
    list.addAll(self, 'instantiates', FInstantiatesList);
  if (child_name = 'imports') Then
    list.addAll(self, 'imports', FImportsList);
  if (child_name = 'software') Then
     list.add(self.link, 'software', FSoftware.Link);
  if (child_name = 'implementation') Then
     list.add(self.link, 'implementation', FImplementation_.Link);
  if (child_name = 'fhirVersion') Then
     list.add(self.link, 'fhirVersion', FFhirVersion.Link);
  if (child_name = 'format') Then
    list.addAll(self, 'format', FFormatList);
  if (child_name = 'patchFormat') Then
    list.addAll(self, 'patchFormat', FPatchFormatList);
  if (child_name = 'implementationGuide') Then
    list.addAll(self, 'implementationGuide', FImplementationGuideList);
  if (child_name = 'rest') Then
    list.addAll(self, 'rest', FRestList);
  if (child_name = 'messaging') Then
    list.addAll(self, 'messaging', FMessagingList);
  if (child_name = 'document') Then
    list.addAll(self, 'document', FDocumentList);
end;

procedure TFhirCapabilityStatement.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'url', 'uri', false, TFhirUri, FUrl.Link));
  oList.add(TFHIRProperty.create(self, 'version', 'string', false, TFhirString, FVersion.Link));
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'experimental', 'boolean', false, TFhirBoolean, FExperimental.Link));
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));
  oList.add(TFHIRProperty.create(self, 'publisher', 'string', false, TFhirString, FPublisher.Link));
  oList.add(TFHIRProperty.create(self, 'contact', 'ContactDetail', true, TFhirContactDetail, FContactList.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'markdown', false, TFhirMarkdown, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'useContext', 'UsageContext', true, TFhirUsageContext, FUseContextList.Link));
  oList.add(TFHIRProperty.create(self, 'jurisdiction', 'CodeableConcept', true, TFhirCodeableConcept, FJurisdictionList.Link));
  oList.add(TFHIRProperty.create(self, 'purpose', 'markdown', false, TFhirMarkdown, FPurpose.Link));
  oList.add(TFHIRProperty.create(self, 'copyright', 'markdown', false, TFhirMarkdown, FCopyright.Link));
  oList.add(TFHIRProperty.create(self, 'kind', 'code', false, TFhirEnum, FKind.Link));
  oList.add(TFHIRProperty.create(self, 'instantiates', 'canonical', true, TFhirCanonical, FInstantiatesList.Link));
  oList.add(TFHIRProperty.create(self, 'imports', 'canonical', true, TFhirCanonical, FImportsList.Link));
  oList.add(TFHIRProperty.create(self, 'software', 'BackboneElement', false, TFhirCapabilityStatementSoftware, FSoftware.Link));
  oList.add(TFHIRProperty.create(self, 'implementation', 'BackboneElement', false, TFhirCapabilityStatementImplementation, FImplementation_.Link));
  oList.add(TFHIRProperty.create(self, 'fhirVersion', 'code', false, TFhirEnum, FFhirVersion.Link));
  oList.add(TFHIRProperty.create(self, 'format', 'code', true, TFhirCode, FFormatList.Link));
  oList.add(TFHIRProperty.create(self, 'patchFormat', 'code', true, TFhirCode, FPatchFormatList.Link));
  oList.add(TFHIRProperty.create(self, 'implementationGuide', 'canonical', true, TFhirCanonical, FImplementationGuideList.Link));
  oList.add(TFHIRProperty.create(self, 'rest', 'BackboneElement', true, TFhirCapabilityStatementRest, FRestList.Link));
  oList.add(TFHIRProperty.create(self, 'messaging', 'BackboneElement', true, TFhirCapabilityStatementMessaging, FMessagingList.Link));
  oList.add(TFHIRProperty.create(self, 'document', 'BackboneElement', true, TFhirCapabilityStatementDocument, FDocumentList.Link));
end;

function TFhirCapabilityStatement.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'url') then
  begin
    UrlElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'title') then
  begin
    TitleElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'experimental') then
  begin
    ExperimentalElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'publisher') then
  begin
    PublisherElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirContactDetail);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'useContext') then
  begin
    UseContextList.add(propValue as TFhirUsageContext);
    result := propValue;
  end
  else if (propName = 'jurisdiction') then
  begin
    JurisdictionList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'purpose') then
  begin
    PurposeElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'copyright') then
  begin
    CopyrightElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'kind') then
  begin
    KindElement := asEnum(SYSTEMS_TFhirCapabilityStatementKindEnum, CODES_TFhirCapabilityStatementKindEnum, propValue);
    result := propValue;
  end
  else if (propName = 'instantiates') then
  begin
    InstantiatesList.add(asCanonical(propValue)){2};     result := propValue;

  end
  else if (propName = 'imports') then
  begin
    ImportsList.add(asCanonical(propValue)){2};     result := propValue;

  end
  else if (propName = 'software') then
  begin
    Software := propValue as TFhirCapabilityStatementSoftware;
    result := propValue;
  end
  else if (propName = 'implementation') then
  begin
    Implementation_ := propValue as TFhirCapabilityStatementImplementation;
    result := propValue;
  end
  else if (propName = 'fhirVersion') then
  begin
    FhirVersionElement := asEnum(SYSTEMS_TFhirFHIRVersionEnum, CODES_TFhirFHIRVersionEnum, propValue);
    result := propValue;
  end
  else if (propName = 'format') then
  begin
    FormatList.add(asCode(propValue)){2};     result := propValue;

  end
  else if (propName = 'patchFormat') then
  begin
    PatchFormatList.add(asCode(propValue)){2};     result := propValue;

  end
  else if (propName = 'implementationGuide') then
  begin
    ImplementationGuideList.add(asCanonical(propValue)){2};     result := propValue;

  end
  else if (propName = 'rest') then
  begin
    RestList.add(propValue as TFhirCapabilityStatementRest);
    result := propValue;
  end
  else if (propName = 'messaging') then
  begin
    MessagingList.add(propValue as TFhirCapabilityStatementMessaging);
    result := propValue;
  end
  else if (propName = 'document') then
  begin
    DocumentList.add(propValue as TFhirCapabilityStatementDocument);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCapabilityStatement.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirContactDetail)
  else if (propName = 'useContext') then UseContextList.insertItem(index, propValue as TFhirUsageContext)
  else if (propName = 'jurisdiction') then JurisdictionList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'instantiates') then InstantiatesList.insertItem(index, asCanonical(propValue))
  else if (propName = 'imports') then ImportsList.insertItem(index, asCanonical(propValue))
  else if (propName = 'format') then FormatList.insertItem(index, asCode(propValue))
  else if (propName = 'patchFormat') then PatchFormatList.insertItem(index, asCode(propValue))
  else if (propName = 'implementationGuide') then ImplementationGuideList.insertItem(index, asCanonical(propValue))
  else if (propName = 'rest') then RestList.insertItem(index, propValue as TFhirCapabilityStatementRest)
  else if (propName = 'messaging') then MessagingList.insertItem(index, propValue as TFhirCapabilityStatementMessaging)
  else if (propName = 'document') then DocumentList.insertItem(index, propValue as TFhirCapabilityStatementDocument)
  else inherited;
end;

function TFhirCapabilityStatement.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'url') then result := TFhirUri.create()
  else if (propName = 'version') then result := TFhirString.create()
  else if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'title') then result := TFhirString.create()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[PublicationStatusNull], CODES_TFhirPublicationStatusEnum[PublicationStatusNull]) 
  else if (propName = 'experimental') then result := TFhirBoolean.create()
  else if (propName = 'date') then result := TFhirDateTime.create()
  else if (propName = 'publisher') then result := TFhirString.create()
  else if (propName = 'contact') then result := ContactList.new()
  else if (propName = 'description') then result := TFhirMarkdown.create()
  else if (propName = 'useContext') then result := UseContextList.new()
  else if (propName = 'jurisdiction') then result := JurisdictionList.new()
  else if (propName = 'purpose') then result := TFhirMarkdown.create()
  else if (propName = 'copyright') then result := TFhirMarkdown.create()
  else if (propName = 'kind') then result := TFhirEnum.create(SYSTEMS_TFhirCapabilityStatementKindEnum[CapabilityStatementKindNull], CODES_TFhirCapabilityStatementKindEnum[CapabilityStatementKindNull]) 
  else if (propName = 'instantiates') then result := InstantiatesList.new()
  else if (propName = 'imports') then result := ImportsList.new()
  else if (propName = 'software') then result := TFhirCapabilityStatementSoftware.create()
  else if (propName = 'implementation') then result := TFhirCapabilityStatementImplementation.create()
  else if (propName = 'fhirVersion') then result := TFhirEnum.create(SYSTEMS_TFhirFHIRVersionEnum[FHIRVersionNull], CODES_TFhirFHIRVersionEnum[FHIRVersionNull]) 
  else if (propName = 'format') then result := FormatList.new()
  else if (propName = 'patchFormat') then result := PatchFormatList.new()
  else if (propName = 'implementationGuide') then result := ImplementationGuideList.new()
  else if (propName = 'rest') then result := RestList.new()
  else if (propName = 'messaging') then result := MessagingList.new()
  else if (propName = 'document') then result := DocumentList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirCapabilityStatement.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'url') then result := 'uri'
  else if (propName = 'version') then result := 'string'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'title') then result := 'string'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'experimental') then result := 'boolean'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'publisher') then result := 'string'
  else if (propName = 'contact') then result := 'ContactDetail'
  else if (propName = 'description') then result := 'markdown'
  else if (propName = 'useContext') then result := 'UsageContext'
  else if (propName = 'jurisdiction') then result := 'CodeableConcept'
  else if (propName = 'purpose') then result := 'markdown'
  else if (propName = 'copyright') then result := 'markdown'
  else if (propName = 'kind') then result := 'code'
  else if (propName = 'instantiates') then result := 'canonical'
  else if (propName = 'imports') then result := 'canonical'
  else if (propName = 'software') then result := 'BackboneElement'
  else if (propName = 'implementation') then result := 'BackboneElement'
  else if (propName = 'fhirVersion') then result := 'code'
  else if (propName = 'format') then result := 'code'
  else if (propName = 'patchFormat') then result := 'code'
  else if (propName = 'implementationGuide') then result := 'canonical'
  else if (propName = 'rest') then result := 'BackboneElement'
  else if (propName = 'messaging') then result := 'BackboneElement'
  else if (propName = 'document') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCapabilityStatement.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := nil
  else if (propName = 'version') then VersionElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'title') then TitleElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'experimental') then ExperimentalElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'publisher') then PublisherElement := nil
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value)
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'useContext') then deletePropertyValue('useContext', UseContextList, value)
  else if (propName = 'jurisdiction') then deletePropertyValue('jurisdiction', JurisdictionList, value)
  else if (propName = 'purpose') then PurposeElement := nil
  else if (propName = 'copyright') then CopyrightElement := nil
  else if (propName = 'kind') then KindElement := nil
  else if (propName = 'instantiates') then deletePropertyValue('instantiates', InstantiatesList, value)
  else if (propName = 'imports') then deletePropertyValue('imports', ImportsList, value)
  else if (propName = 'software') then SoftwareElement := nil
  else if (propName = 'implementation') then Implementation_Element := nil
  else if (propName = 'fhirVersion') then FhirVersionElement := nil
  else if (propName = 'format') then deletePropertyValue('format', FormatList, value)
  else if (propName = 'patchFormat') then deletePropertyValue('patchFormat', PatchFormatList, value)
  else if (propName = 'implementationGuide') then deletePropertyValue('implementationGuide', ImplementationGuideList, value)
  else if (propName = 'rest') then deletePropertyValue('rest', RestList, value)
  else if (propName = 'messaging') then deletePropertyValue('messaging', MessagingList, value)
  else if (propName = 'document') then deletePropertyValue('document', DocumentList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCapabilityStatement.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := asUri(new)
  else if (propName = 'version') then VersionElement := asString(new)
  else if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'title') then TitleElement := asString(new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, new)
  else if (propName = 'experimental') then ExperimentalElement := asBoolean(new)
  else if (propName = 'date') then DateElement := asDateTime(new)
  else if (propName = 'publisher') then PublisherElement := asString(new)
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new)
  else if (propName = 'description') then DescriptionElement := asMarkdown(new)
  else if (propName = 'useContext') then replacePropertyValue('useContext', UseContextList, existing, new)
  else if (propName = 'jurisdiction') then replacePropertyValue('jurisdiction', JurisdictionList, existing, new)
  else if (propName = 'purpose') then PurposeElement := asMarkdown(new)
  else if (propName = 'copyright') then CopyrightElement := asMarkdown(new)
  else if (propName = 'kind') then KindElement := asEnum(SYSTEMS_TFhirCapabilityStatementKindEnum, CODES_TFhirCapabilityStatementKindEnum, new)
  else if (propName = 'instantiates') then replacePropertyValue('instantiates', InstantiatesList, existing, new)
  else if (propName = 'imports') then replacePropertyValue('imports', ImportsList, existing, new)
  else if (propName = 'software') then SoftwareElement := new as TFhirCapabilityStatementSoftware
  else if (propName = 'implementation') then Implementation_Element := new as TFhirCapabilityStatementImplementation
  else if (propName = 'fhirVersion') then FhirVersionElement := asEnum(SYSTEMS_TFhirFHIRVersionEnum, CODES_TFhirFHIRVersionEnum, new)
  else if (propName = 'format') then replacePropertyValue('format', FormatList, existing, new)
  else if (propName = 'patchFormat') then replacePropertyValue('patchFormat', PatchFormatList, existing, new)
  else if (propName = 'implementationGuide') then replacePropertyValue('implementationGuide', ImplementationGuideList, existing, new)
  else if (propName = 'rest') then replacePropertyValue('rest', RestList, existing, new)
  else if (propName = 'messaging') then replacePropertyValue('messaging', MessagingList, existing, new)
  else if (propName = 'document') then replacePropertyValue('document', DocumentList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCapabilityStatement.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'contact') then ContactList.move(source, destination)
  else if (propName = 'useContext') then UseContextList.move(source, destination)
  else if (propName = 'jurisdiction') then JurisdictionList.move(source, destination)
  else if (propName = 'instantiates') then InstantiatesList.move(source, destination)
  else if (propName = 'imports') then ImportsList.move(source, destination)
  else if (propName = 'format') then FormatList.move(source, destination)
  else if (propName = 'patchFormat') then PatchFormatList.move(source, destination)
  else if (propName = 'implementationGuide') then ImplementationGuideList.move(source, destination)
  else if (propName = 'rest') then RestList.move(source, destination)
  else if (propName = 'messaging') then MessagingList.move(source, destination)
  else if (propName = 'document') then DocumentList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCapabilityStatement.fhirType : string;
begin
  result := 'CapabilityStatement';
end;

function TFhirCapabilityStatement.Link : TFhirCapabilityStatement;
begin
  result := TFhirCapabilityStatement(inherited Link);
end;

function TFhirCapabilityStatement.Clone : TFhirCapabilityStatement;
begin
  result := TFhirCapabilityStatement(inherited Clone);
end;

function TFhirCapabilityStatement.equals(other : TObject) : boolean; 
var
  o : TFhirCapabilityStatement;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCapabilityStatement)) then
    result := false
  else
  begin
    o := TFhirCapabilityStatement(other);
    result := compareDeep(urlElement, o.urlElement, true) and compareDeep(versionElement, o.versionElement, true) and 
      compareDeep(nameElement, o.nameElement, true) and compareDeep(titleElement, o.titleElement, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(experimentalElement, o.experimentalElement, true) and 
      compareDeep(dateElement, o.dateElement, true) and compareDeep(publisherElement, o.publisherElement, true) and 
      compareDeep(contactList, o.contactList, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(useContextList, o.useContextList, true) and compareDeep(jurisdictionList, o.jurisdictionList, true) and 
      compareDeep(purposeElement, o.purposeElement, true) and compareDeep(copyrightElement, o.copyrightElement, true) and 
      compareDeep(kindElement, o.kindElement, true) and compareDeep(instantiatesList, o.instantiatesList, true) and 
      compareDeep(importsList, o.importsList, true) and compareDeep(softwareElement, o.softwareElement, true) and 
      compareDeep(implementation_Element, o.implementation_Element, true) and compareDeep(fhirVersionElement, o.fhirVersionElement, true) and 
      compareDeep(formatList, o.formatList, true) and compareDeep(patchFormatList, o.patchFormatList, true) and 
      compareDeep(implementationGuideList, o.implementationGuideList, true) and compareDeep(restList, o.restList, true) and 
      compareDeep(messagingList, o.messagingList, true) and compareDeep(documentList, o.documentList, true);
  end;
end;

function TFhirCapabilityStatement.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FUrl) and isEmptyProp(FVersion) and isEmptyProp(FName) and isEmptyProp(FTitle) and isEmptyProp(FStatus) and isEmptyProp(FExperimental) and isEmptyProp(FDate) and isEmptyProp(FPublisher) and isEmptyProp(FcontactList) and isEmptyProp(FDescription) and isEmptyProp(FuseContextList) and isEmptyProp(FjurisdictionList) and isEmptyProp(FPurpose) and isEmptyProp(FCopyright) and isEmptyProp(FKind) and isEmptyProp(FinstantiatesList) and isEmptyProp(FimportsList) and isEmptyProp(FSoftware) and isEmptyProp(FImplementation_) and isEmptyProp(FFhirVersion) and isEmptyProp(FformatList) and isEmptyProp(FpatchFormatList) and isEmptyProp(FimplementationGuideList) and isEmptyProp(FrestList) and isEmptyProp(FmessagingList) and isEmptyProp(FdocumentList);
end;

procedure TFhirCapabilityStatement.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('url');
  fields.add('version');
  fields.add('name');
  fields.add('title');
  fields.add('status');
  fields.add('experimental');
  fields.add('date');
  fields.add('publisher');
  fields.add('contact');
  fields.add('description');
  fields.add('useContext');
  fields.add('jurisdiction');
  fields.add('purpose');
  fields.add('copyright');
  fields.add('kind');
  fields.add('instantiates');
  fields.add('imports');
  fields.add('software');
  fields.add('implementation');
  fields.add('fhirVersion');
  fields.add('format');
  fields.add('patchFormat');
  fields.add('implementationGuide');
  fields.add('rest');
  fields.add('messaging');
  fields.add('document');
end;

function TFhirCapabilityStatement.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FContactList.sizeInBytes(magic));
  inc(result, FUseContextList.sizeInBytes(magic));
  inc(result, FJurisdictionList.sizeInBytes(magic));
  inc(result, FInstantiatesList.sizeInBytes(magic));
  inc(result, FImportsList.sizeInBytes(magic));
  inc(result, FFormatList.sizeInBytes(magic));
  inc(result, FPatchFormatList.sizeInBytes(magic));
  inc(result, FImplementationGuideList.sizeInBytes(magic));
  inc(result, FRestList.sizeInBytes(magic));
  inc(result, FMessagingList.sizeInBytes(magic));
  inc(result, FDocumentList.sizeInBytes(magic));
end;

procedure TFhirCapabilityStatement.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

function TFhirCapabilityStatement.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

procedure TFhirCapabilityStatement.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

procedure TFhirCapabilityStatement.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

function TFhirCapabilityStatement.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

procedure TFhirCapabilityStatement.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

procedure TFhirCapabilityStatement.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirCapabilityStatement.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirCapabilityStatement.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirCapabilityStatement.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

function TFhirCapabilityStatement.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

procedure TFhirCapabilityStatement.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

procedure TFhirCapabilityStatement.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirCapabilityStatement.GetStatusST : TFhirPublicationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirPublicationStatusEnum(0)
  else
    result := TFhirPublicationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirPublicationStatusEnum, FStatus.value));
end;

procedure TFhirCapabilityStatement.SetStatusST(value : TFhirPublicationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[value], CODES_TFhirPublicationStatusEnum[value]);
end;

procedure TFhirCapabilityStatement.SetExperimental(value : TFhirBoolean);
begin
  FExperimental.free;
  FExperimental := value;
end;

function TFhirCapabilityStatement.GetExperimentalST : Boolean;
begin
  if FExperimental = nil then
    result := false
  else
    result := FExperimental.value;
end;

procedure TFhirCapabilityStatement.SetExperimentalST(value : Boolean);
begin
  if FExperimental = nil then
    FExperimental := TFhirBoolean.create;
  FExperimental.value := value
end;

procedure TFhirCapabilityStatement.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

function TFhirCapabilityStatement.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirCapabilityStatement.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

procedure TFhirCapabilityStatement.SetPublisher(value : TFhirString);
begin
  FPublisher.free;
  FPublisher := value;
end;

function TFhirCapabilityStatement.GetPublisherST : String;
begin
  if FPublisher = nil then
    result := ''
  else
    result := FPublisher.value;
end;

procedure TFhirCapabilityStatement.SetPublisherST(value : String);
begin
  if value <> '' then
  begin
    if FPublisher = nil then
      FPublisher := TFhirString.create;
    FPublisher.value := value
  end
  else if FPublisher <> nil then
    FPublisher.value := '';
end;

function TFhirCapabilityStatement.GetContactList : TFhirContactDetailList;
begin
  if FContactList = nil then
    FContactList := TFhirContactDetailList.Create;
  result := FContactList;
end;

function TFhirCapabilityStatement.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

procedure TFhirCapabilityStatement.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirCapabilityStatement.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirCapabilityStatement.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirCapabilityStatement.GetUseContextList : TFhirUsageContextList;
begin
  if FUseContextList = nil then
    FUseContextList := TFhirUsageContextList.Create;
  result := FUseContextList;
end;

function TFhirCapabilityStatement.GetHasUseContextList : boolean;
begin
  result := (FUseContextList <> nil) and (FUseContextList.count > 0);
end;

function TFhirCapabilityStatement.GetJurisdictionList : TFhirCodeableConceptList;
begin
  if FJurisdictionList = nil then
    FJurisdictionList := TFhirCodeableConceptList.Create;
  result := FJurisdictionList;
end;

function TFhirCapabilityStatement.GetHasJurisdictionList : boolean;
begin
  result := (FJurisdictionList <> nil) and (FJurisdictionList.count > 0);
end;

procedure TFhirCapabilityStatement.SetPurpose(value : TFhirMarkdown);
begin
  FPurpose.free;
  FPurpose := value;
end;

function TFhirCapabilityStatement.GetPurposeST : String;
begin
  if FPurpose = nil then
    result := ''
  else
    result := FPurpose.value;
end;

procedure TFhirCapabilityStatement.SetPurposeST(value : String);
begin
  if value <> '' then
  begin
    if FPurpose = nil then
      FPurpose := TFhirMarkdown.create;
    FPurpose.value := value
  end
  else if FPurpose <> nil then
    FPurpose.value := '';
end;

procedure TFhirCapabilityStatement.SetCopyright(value : TFhirMarkdown);
begin
  FCopyright.free;
  FCopyright := value;
end;

function TFhirCapabilityStatement.GetCopyrightST : String;
begin
  if FCopyright = nil then
    result := ''
  else
    result := FCopyright.value;
end;

procedure TFhirCapabilityStatement.SetCopyrightST(value : String);
begin
  if value <> '' then
  begin
    if FCopyright = nil then
      FCopyright := TFhirMarkdown.create;
    FCopyright.value := value
  end
  else if FCopyright <> nil then
    FCopyright.value := '';
end;

procedure TFhirCapabilityStatement.SetKind(value : TFhirEnum);
begin
  FKind.free;
  FKind := value;
end;

function TFhirCapabilityStatement.GetKindST : TFhirCapabilityStatementKindEnum;
begin
  if FKind = nil then
    result := TFhirCapabilityStatementKindEnum(0)
  else
    result := TFhirCapabilityStatementKindEnum(StringArrayIndexOfSensitive(CODES_TFhirCapabilityStatementKindEnum, FKind.value));
end;

procedure TFhirCapabilityStatement.SetKindST(value : TFhirCapabilityStatementKindEnum);
begin
  if ord(value) = 0 then
    KindElement := nil
  else
    KindElement := TFhirEnum.create(SYSTEMS_TFhirCapabilityStatementKindEnum[value], CODES_TFhirCapabilityStatementKindEnum[value]);
end;

function TFhirCapabilityStatement.GetInstantiatesList : TFhirCanonicalList;
begin
  if FInstantiatesList = nil then
    FInstantiatesList := TFhirCanonicalList.Create;
  result := FInstantiatesList;
end;

function TFhirCapabilityStatement.GetHasInstantiatesList : boolean;
begin
  result := (FInstantiatesList <> nil) and (FInstantiatesList.count > 0);
end;

function TFhirCapabilityStatement.GetImportsList : TFhirCanonicalList;
begin
  if FImportsList = nil then
    FImportsList := TFhirCanonicalList.Create;
  result := FImportsList;
end;

function TFhirCapabilityStatement.GetHasImportsList : boolean;
begin
  result := (FImportsList <> nil) and (FImportsList.count > 0);
end;

procedure TFhirCapabilityStatement.SetSoftware(value : TFhirCapabilityStatementSoftware);
begin
  FSoftware.free;
  FSoftware := value;
end;

procedure TFhirCapabilityStatement.SetImplementation_(value : TFhirCapabilityStatementImplementation);
begin
  FImplementation_.free;
  FImplementation_ := value;
end;

procedure TFhirCapabilityStatement.SetFhirVersion(value : TFhirEnum);
begin
  FFhirVersion.free;
  FFhirVersion := value;
end;

function TFhirCapabilityStatement.GetFhirVersionST : TFhirFHIRVersionEnum;
begin
  if FFhirVersion = nil then
    result := TFhirFHIRVersionEnum(0)
  else
    result := TFhirFHIRVersionEnum(StringArrayIndexOfSensitive(CODES_TFhirFHIRVersionEnum, FFhirVersion.value));
end;

procedure TFhirCapabilityStatement.SetFhirVersionST(value : TFhirFHIRVersionEnum);
begin
  if ord(value) = 0 then
    FhirVersionElement := nil
  else
    FhirVersionElement := TFhirEnum.create(SYSTEMS_TFhirFHIRVersionEnum[value], CODES_TFhirFHIRVersionEnum[value]);
end;

function TFhirCapabilityStatement.GetFormatList : TFhirCodeList;
begin
  if FFormatList = nil then
    FFormatList := TFhirCodeList.Create;
  result := FFormatList;
end;

function TFhirCapabilityStatement.GetHasFormatList : boolean;
begin
  result := (FFormatList <> nil) and (FFormatList.count > 0);
end;

function TFhirCapabilityStatement.GetPatchFormatList : TFhirCodeList;
begin
  if FPatchFormatList = nil then
    FPatchFormatList := TFhirCodeList.Create;
  result := FPatchFormatList;
end;

function TFhirCapabilityStatement.GetHasPatchFormatList : boolean;
begin
  result := (FPatchFormatList <> nil) and (FPatchFormatList.count > 0);
end;

function TFhirCapabilityStatement.GetImplementationGuideList : TFhirCanonicalList;
begin
  if FImplementationGuideList = nil then
    FImplementationGuideList := TFhirCanonicalList.Create;
  result := FImplementationGuideList;
end;

function TFhirCapabilityStatement.GetHasImplementationGuideList : boolean;
begin
  result := (FImplementationGuideList <> nil) and (FImplementationGuideList.count > 0);
end;

function TFhirCapabilityStatement.GetRestList : TFhirCapabilityStatementRestList;
begin
  if FRestList = nil then
    FRestList := TFhirCapabilityStatementRestList.Create;
  result := FRestList;
end;

function TFhirCapabilityStatement.GetHasRestList : boolean;
begin
  result := (FRestList <> nil) and (FRestList.count > 0);
end;

function TFhirCapabilityStatement.GetMessagingList : TFhirCapabilityStatementMessagingList;
begin
  if FMessagingList = nil then
    FMessagingList := TFhirCapabilityStatementMessagingList.Create;
  result := FMessagingList;
end;

function TFhirCapabilityStatement.GetHasMessagingList : boolean;
begin
  result := (FMessagingList <> nil) and (FMessagingList.count > 0);
end;

function TFhirCapabilityStatement.GetDocumentList : TFhirCapabilityStatementDocumentList;
begin
  if FDocumentList = nil then
    FDocumentList := TFhirCapabilityStatementDocumentList.Create;
  result := FDocumentList;
end;

function TFhirCapabilityStatement.GetHasDocumentList : boolean;
begin
  result := (FDocumentList <> nil) and (FDocumentList.count > 0);
end;

{ TFhirCapabilityStatementListEnumerator }

constructor TFhirCapabilityStatementListEnumerator.Create(list : TFhirCapabilityStatementList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCapabilityStatementListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCapabilityStatementListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCapabilityStatementListEnumerator.GetCurrent : TFhirCapabilityStatement;
begin
  Result := FList[FIndex];
end;

function TFhirCapabilityStatementListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCapabilityStatementList }

function TFhirCapabilityStatementList.AddItem(value: TFhirCapabilityStatement): TFhirCapabilityStatement;
begin
  assert(value.ClassName = 'TFhirCapabilityStatement', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCapabilityStatement');
  add(value);
  result := value;
end;

function TFhirCapabilityStatementList.Append: TFhirCapabilityStatement;
begin
  result := TFhirCapabilityStatement.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCapabilityStatementList.ClearItems;
begin
  Clear;
end;

function TFhirCapabilityStatementList.GetEnumerator : TFhirCapabilityStatementListEnumerator;
begin
  result := TFhirCapabilityStatementListEnumerator.Create(self.link);
end;

function TFhirCapabilityStatementList.Clone: TFhirCapabilityStatementList;
begin
  result := TFhirCapabilityStatementList(inherited Clone);
end;

function TFhirCapabilityStatementList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCapabilityStatementList.GetItemN(index: Integer): TFhirCapabilityStatement;
begin
  result := TFhirCapabilityStatement(ObjectByIndex[index]);
end;

function TFhirCapabilityStatementList.ItemClass: TFslObjectClass;
begin
  result := TFhirCapabilityStatement;
end;
function TFhirCapabilityStatementList.IndexOf(value: TFhirCapabilityStatement): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCapabilityStatementList.Insert(index: Integer): TFhirCapabilityStatement;
begin
  result := TFhirCapabilityStatement.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCapabilityStatementList.InsertItem(index: Integer; value: TFhirCapabilityStatement);
begin
  assert(value is TFhirCapabilityStatement);
  Inherited Insert(index, value);
end;

function TFhirCapabilityStatementList.Item(index: Integer): TFhirCapabilityStatement;
begin
  result := TFhirCapabilityStatement(ObjectByIndex[index]);
end;

function TFhirCapabilityStatementList.Link: TFhirCapabilityStatementList;
begin
  result := TFhirCapabilityStatementList(inherited Link);
end;

procedure TFhirCapabilityStatementList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCapabilityStatementList.SetItemByIndex(index: Integer; value: TFhirCapabilityStatement);
begin
  assert(value is TFhirCapabilityStatement);
  FhirCapabilityStatements[index] := value;
end;

procedure TFhirCapabilityStatementList.SetItemN(index: Integer; value: TFhirCapabilityStatement);
begin
  assert(value is TFhirCapabilityStatement);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_CAPABILITYSTATEMENT}
{$IFDEF FHIR_CODESYSTEM}
{ TFhirCodeSystemFilter }

constructor TFhirCodeSystemFilter.Create;
begin
  inherited;
end;

destructor TFhirCodeSystemFilter.Destroy;
begin
  FCode.free;
  FDescription.free;
  FOperator.Free;
  FValue.free;
  inherited;
end;

procedure TFhirCodeSystemFilter.Assign(oSource : TFslObject);
begin
  inherited;
  codeElement := TFhirCodeSystemFilter(oSource).codeElement.Clone;
  descriptionElement := TFhirCodeSystemFilter(oSource).descriptionElement.Clone;
  if (TFhirCodeSystemFilter(oSource).FOperator = nil) then
  begin
    FOperator.free;
    FOperator := nil;
  end
  else
  begin
    FOperator := TFhirEnumList.Create(SYSTEMS_TFhirFilterOperatorEnum, CODES_TFhirFilterOperatorEnum);
    FOperator.Assign(TFhirCodeSystemFilter(oSource).FOperator);
  end;
  valueElement := TFhirCodeSystemFilter(oSource).valueElement.Clone;
end;

procedure TFhirCodeSystemFilter.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'operator') Then
     list.addAll(self, 'operator', FOperator);
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
end;

procedure TFhirCodeSystemFilter.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'code', false, TFhirCode, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'operator', 'code', true, TFhirEnum, FOperator.Link));
  oList.add(TFHIRProperty.create(self, 'value', 'string', false, TFhirString, FValue.Link));
end;

function TFhirCodeSystemFilter.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    CodeElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'operator') then
  begin
    OperatorList.add(asEnum(SYSTEMS_TFhirFilterOperatorEnum, CODES_TFhirFilterOperatorEnum, propValue));
    result := propValue;
  end
  else if (propName = 'value') then
  begin
    ValueElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCodeSystemFilter.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'operator') then FOperator.insertItem(index, asEnum(SYSTEMS_TFhirFilterOperatorEnum, CODES_TFhirFilterOperatorEnum, propValue))
  else inherited;
end;

function TFhirCodeSystemFilter.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCode.create()
  else if (propName = 'description') then result := TFhirString.create()
  else if (propName = 'value') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirCodeSystemFilter.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'code'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'operator') then result := 'code'
  else if (propName = 'value') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCodeSystemFilter.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'value') then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCodeSystemFilter.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := asCode(new)
  else if (propName = 'description') then DescriptionElement := asString(new)
  else if (propName = 'value') then ValueElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCodeSystemFilter.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'operator') then FOperator.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCodeSystemFilter.fhirType : string;
begin
  result := 'CodeSystem.filter';
end;

function TFhirCodeSystemFilter.Link : TFhirCodeSystemFilter;
begin
  result := TFhirCodeSystemFilter(inherited Link);
end;

function TFhirCodeSystemFilter.Clone : TFhirCodeSystemFilter;
begin
  result := TFhirCodeSystemFilter(inherited Clone);
end;

function TFhirCodeSystemFilter.equals(other : TObject) : boolean; 
var
  o : TFhirCodeSystemFilter;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCodeSystemFilter)) then
    result := false
  else
  begin
    o := TFhirCodeSystemFilter(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(operatorList, o.operatorList, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirCodeSystemFilter.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FDescription) and isEmptyProp(FOperator) and isEmptyProp(FValue);
end;

procedure TFhirCodeSystemFilter.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('code');
  fields.add('description');
  fields.add('operator');
  fields.add('value');
end;

function TFhirCodeSystemFilter.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FOperator.sizeInBytes(magic));
end;

procedure TFhirCodeSystemFilter.SetCode(value : TFhirCode);
begin
  FCode.free;
  FCode := value;
end;

function TFhirCodeSystemFilter.GetCodeST : String;
begin
  if FCode = nil then
    result := ''
  else
    result := FCode.value;
end;

procedure TFhirCodeSystemFilter.SetCodeST(value : String);
begin
  if value <> '' then
  begin
    if FCode = nil then
      FCode := TFhirCode.create;
    FCode.value := value
  end
  else if FCode <> nil then
    FCode.value := '';
end;

procedure TFhirCodeSystemFilter.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirCodeSystemFilter.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirCodeSystemFilter.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirCodeSystemFilter.GetOperator : TFhirEnumList;
begin
  if FOperator = nil then
    FOperator := TFhirEnumList.Create(SYSTEMS_TFhirFilterOperatorEnum, CODES_TFhirFilterOperatorEnum);
  result := FOperator;
end;

function TFhirCodeSystemFilter.GetHasOperator : boolean;
begin
  result := (FOperator <> nil) and (FOperator.count > 0);
end;

function TFhirCodeSystemFilter.GetOperatorST : TFhirFilterOperatorEnumList;
  var i : integer;
begin
  result := [];
  if Foperator <> nil then
    for i := 0 to Foperator.count - 1 do
      result := result + [TFhirFilterOperatorEnum(StringArrayIndexOfSensitive(CODES_TFhirFilterOperatorEnum, Foperator[i].value))];
end;

procedure TFhirCodeSystemFilter.SetOperatorST(value : TFhirFilterOperatorEnumList);
var a : TFhirFilterOperatorEnum;
begin
  if Foperator = nil then
    Foperator := TFhirEnumList.create(SYSTEMS_TFhirFilterOperatorEnum, CODES_TFhirFilterOperatorEnum);
  Foperator.clear;
  for a := low(TFhirFilterOperatorEnum) to high(TFhirFilterOperatorEnum) do
    if a in value then
      begin
         if Foperator = nil then
           Foperator := TFhirEnumList.create(SYSTEMS_TFhirFilterOperatorEnum, CODES_TFhirFilterOperatorEnum);
         Foperator.add(TFhirEnum.create(SYSTEMS_TFhirFilterOperatorEnum[a], CODES_TFhirFilterOperatorEnum[a]));
      end;
end;

procedure TFhirCodeSystemFilter.SetValue(value : TFhirString);
begin
  FValue.free;
  FValue := value;
end;

function TFhirCodeSystemFilter.GetValueST : String;
begin
  if FValue = nil then
    result := ''
  else
    result := FValue.value;
end;

procedure TFhirCodeSystemFilter.SetValueST(value : String);
begin
  if value <> '' then
  begin
    if FValue = nil then
      FValue := TFhirString.create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := '';
end;

{ TFhirCodeSystemFilterListEnumerator }

constructor TFhirCodeSystemFilterListEnumerator.Create(list : TFhirCodeSystemFilterList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCodeSystemFilterListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCodeSystemFilterListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCodeSystemFilterListEnumerator.GetCurrent : TFhirCodeSystemFilter;
begin
  Result := FList[FIndex];
end;

function TFhirCodeSystemFilterListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCodeSystemFilterList }

function TFhirCodeSystemFilterList.AddItem(value: TFhirCodeSystemFilter): TFhirCodeSystemFilter;
begin
  assert(value.ClassName = 'TFhirCodeSystemFilter', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCodeSystemFilter');
  add(value);
  result := value;
end;

function TFhirCodeSystemFilterList.Append: TFhirCodeSystemFilter;
begin
  result := TFhirCodeSystemFilter.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCodeSystemFilterList.ClearItems;
begin
  Clear;
end;

function TFhirCodeSystemFilterList.GetEnumerator : TFhirCodeSystemFilterListEnumerator;
begin
  result := TFhirCodeSystemFilterListEnumerator.Create(self.link);
end;

function TFhirCodeSystemFilterList.Clone: TFhirCodeSystemFilterList;
begin
  result := TFhirCodeSystemFilterList(inherited Clone);
end;

function TFhirCodeSystemFilterList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCodeSystemFilterList.GetItemN(index: Integer): TFhirCodeSystemFilter;
begin
  result := TFhirCodeSystemFilter(ObjectByIndex[index]);
end;

function TFhirCodeSystemFilterList.ItemClass: TFslObjectClass;
begin
  result := TFhirCodeSystemFilter;
end;
function TFhirCodeSystemFilterList.IndexOf(value: TFhirCodeSystemFilter): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCodeSystemFilterList.Insert(index: Integer): TFhirCodeSystemFilter;
begin
  result := TFhirCodeSystemFilter.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCodeSystemFilterList.InsertItem(index: Integer; value: TFhirCodeSystemFilter);
begin
  assert(value is TFhirCodeSystemFilter);
  Inherited Insert(index, value);
end;

function TFhirCodeSystemFilterList.Item(index: Integer): TFhirCodeSystemFilter;
begin
  result := TFhirCodeSystemFilter(ObjectByIndex[index]);
end;

function TFhirCodeSystemFilterList.Link: TFhirCodeSystemFilterList;
begin
  result := TFhirCodeSystemFilterList(inherited Link);
end;

procedure TFhirCodeSystemFilterList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCodeSystemFilterList.SetItemByIndex(index: Integer; value: TFhirCodeSystemFilter);
begin
  assert(value is TFhirCodeSystemFilter);
  FhirCodeSystemFilters[index] := value;
end;

procedure TFhirCodeSystemFilterList.SetItemN(index: Integer; value: TFhirCodeSystemFilter);
begin
  assert(value is TFhirCodeSystemFilter);
  ObjectByIndex[index] := value;
end;

{ TFhirCodeSystemProperty }

constructor TFhirCodeSystemProperty.Create;
begin
  inherited;
end;

destructor TFhirCodeSystemProperty.Destroy;
begin
  FCode.free;
  FUri.free;
  FDescription.free;
  FType_.free;
  inherited;
end;

procedure TFhirCodeSystemProperty.Assign(oSource : TFslObject);
begin
  inherited;
  codeElement := TFhirCodeSystemProperty(oSource).codeElement.Clone;
  uriElement := TFhirCodeSystemProperty(oSource).uriElement.Clone;
  descriptionElement := TFhirCodeSystemProperty(oSource).descriptionElement.Clone;
  type_Element := TFhirCodeSystemProperty(oSource).type_Element.Clone;
end;

procedure TFhirCodeSystemProperty.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'uri') Then
     list.add(self.link, 'uri', FUri.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
end;

procedure TFhirCodeSystemProperty.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'code', false, TFhirCode, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'uri', 'uri', false, TFhirUri, FUri.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFhirEnum, FType_.Link));
end;

function TFhirCodeSystemProperty.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    CodeElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'uri') then
  begin
    UriElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirConceptPropertyTypeEnum, CODES_TFhirConceptPropertyTypeEnum, propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCodeSystemProperty.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCodeSystemProperty.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCode.create()
  else if (propName = 'uri') then result := TFhirUri.create()
  else if (propName = 'description') then result := TFhirString.create()
  else if (propName = 'type') then result := TFhirEnum.create(SYSTEMS_TFhirConceptPropertyTypeEnum[ConceptPropertyTypeNull], CODES_TFhirConceptPropertyTypeEnum[ConceptPropertyTypeNull]) 
  else result := inherited createPropertyValue(propName);
end;

function TFhirCodeSystemProperty.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'code'
  else if (propName = 'uri') then result := 'uri'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'type') then result := 'code'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCodeSystemProperty.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'uri') then UriElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'type') then Type_Element := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCodeSystemProperty.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := asCode(new)
  else if (propName = 'uri') then UriElement := asUri(new)
  else if (propName = 'description') then DescriptionElement := asString(new)
  else if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirConceptPropertyTypeEnum, CODES_TFhirConceptPropertyTypeEnum, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCodeSystemProperty.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCodeSystemProperty.fhirType : string;
begin
  result := 'CodeSystem.property';
end;

function TFhirCodeSystemProperty.Link : TFhirCodeSystemProperty;
begin
  result := TFhirCodeSystemProperty(inherited Link);
end;

function TFhirCodeSystemProperty.Clone : TFhirCodeSystemProperty;
begin
  result := TFhirCodeSystemProperty(inherited Clone);
end;

function TFhirCodeSystemProperty.equals(other : TObject) : boolean; 
var
  o : TFhirCodeSystemProperty;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCodeSystemProperty)) then
    result := false
  else
  begin
    o := TFhirCodeSystemProperty(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(uriElement, o.uriElement, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(type_Element, o.type_Element, true);
  end;
end;

function TFhirCodeSystemProperty.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FUri) and isEmptyProp(FDescription) and isEmptyProp(FType_);
end;

procedure TFhirCodeSystemProperty.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('code');
  fields.add('uri');
  fields.add('description');
  fields.add('type');
end;

function TFhirCodeSystemProperty.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirCodeSystemProperty.SetCode(value : TFhirCode);
begin
  FCode.free;
  FCode := value;
end;

function TFhirCodeSystemProperty.GetCodeST : String;
begin
  if FCode = nil then
    result := ''
  else
    result := FCode.value;
end;

procedure TFhirCodeSystemProperty.SetCodeST(value : String);
begin
  if value <> '' then
  begin
    if FCode = nil then
      FCode := TFhirCode.create;
    FCode.value := value
  end
  else if FCode <> nil then
    FCode.value := '';
end;

procedure TFhirCodeSystemProperty.SetUri(value : TFhirUri);
begin
  FUri.free;
  FUri := value;
end;

function TFhirCodeSystemProperty.GetUriST : String;
begin
  if FUri = nil then
    result := ''
  else
    result := FUri.value;
end;

procedure TFhirCodeSystemProperty.SetUriST(value : String);
begin
  if value <> '' then
  begin
    if FUri = nil then
      FUri := TFhirUri.create;
    FUri.value := value
  end
  else if FUri <> nil then
    FUri.value := '';
end;

procedure TFhirCodeSystemProperty.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirCodeSystemProperty.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirCodeSystemProperty.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirCodeSystemProperty.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirCodeSystemProperty.GetType_ST : TFhirConceptPropertyTypeEnum;
begin
  if FType_ = nil then
    result := TFhirConceptPropertyTypeEnum(0)
  else
    result := TFhirConceptPropertyTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirConceptPropertyTypeEnum, FType_.value));
end;

procedure TFhirCodeSystemProperty.SetType_ST(value : TFhirConceptPropertyTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirConceptPropertyTypeEnum[value], CODES_TFhirConceptPropertyTypeEnum[value]);
end;

{ TFhirCodeSystemPropertyListEnumerator }

constructor TFhirCodeSystemPropertyListEnumerator.Create(list : TFhirCodeSystemPropertyList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCodeSystemPropertyListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCodeSystemPropertyListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCodeSystemPropertyListEnumerator.GetCurrent : TFhirCodeSystemProperty;
begin
  Result := FList[FIndex];
end;

function TFhirCodeSystemPropertyListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCodeSystemPropertyList }

function TFhirCodeSystemPropertyList.AddItem(value: TFhirCodeSystemProperty): TFhirCodeSystemProperty;
begin
  assert(value.ClassName = 'TFhirCodeSystemProperty', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCodeSystemProperty');
  add(value);
  result := value;
end;

function TFhirCodeSystemPropertyList.Append: TFhirCodeSystemProperty;
begin
  result := TFhirCodeSystemProperty.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCodeSystemPropertyList.ClearItems;
begin
  Clear;
end;

function TFhirCodeSystemPropertyList.GetEnumerator : TFhirCodeSystemPropertyListEnumerator;
begin
  result := TFhirCodeSystemPropertyListEnumerator.Create(self.link);
end;

function TFhirCodeSystemPropertyList.Clone: TFhirCodeSystemPropertyList;
begin
  result := TFhirCodeSystemPropertyList(inherited Clone);
end;

function TFhirCodeSystemPropertyList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCodeSystemPropertyList.GetItemN(index: Integer): TFhirCodeSystemProperty;
begin
  result := TFhirCodeSystemProperty(ObjectByIndex[index]);
end;

function TFhirCodeSystemPropertyList.ItemClass: TFslObjectClass;
begin
  result := TFhirCodeSystemProperty;
end;
function TFhirCodeSystemPropertyList.IndexOf(value: TFhirCodeSystemProperty): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCodeSystemPropertyList.Insert(index: Integer): TFhirCodeSystemProperty;
begin
  result := TFhirCodeSystemProperty.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCodeSystemPropertyList.InsertItem(index: Integer; value: TFhirCodeSystemProperty);
begin
  assert(value is TFhirCodeSystemProperty);
  Inherited Insert(index, value);
end;

function TFhirCodeSystemPropertyList.Item(index: Integer): TFhirCodeSystemProperty;
begin
  result := TFhirCodeSystemProperty(ObjectByIndex[index]);
end;

function TFhirCodeSystemPropertyList.Link: TFhirCodeSystemPropertyList;
begin
  result := TFhirCodeSystemPropertyList(inherited Link);
end;

procedure TFhirCodeSystemPropertyList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCodeSystemPropertyList.SetItemByIndex(index: Integer; value: TFhirCodeSystemProperty);
begin
  assert(value is TFhirCodeSystemProperty);
  FhirCodeSystemProperties[index] := value;
end;

procedure TFhirCodeSystemPropertyList.SetItemN(index: Integer; value: TFhirCodeSystemProperty);
begin
  assert(value is TFhirCodeSystemProperty);
  ObjectByIndex[index] := value;
end;

{ TFhirCodeSystemConcept }

constructor TFhirCodeSystemConcept.Create;
begin
  inherited;
end;

destructor TFhirCodeSystemConcept.Destroy;
begin
  FCode.free;
  FDisplay.free;
  FDefinition.free;
  FDesignationList.Free;
  FProperty_List.Free;
  FConceptList.Free;
  inherited;
end;

procedure TFhirCodeSystemConcept.Assign(oSource : TFslObject);
begin
  inherited;
  codeElement := TFhirCodeSystemConcept(oSource).codeElement.Clone;
  displayElement := TFhirCodeSystemConcept(oSource).displayElement.Clone;
  definitionElement := TFhirCodeSystemConcept(oSource).definitionElement.Clone;
  if (TFhirCodeSystemConcept(oSource).FDesignationList = nil) then
  begin
    FDesignationList.free;
    FDesignationList := nil;
  end
  else
  begin
    if FDesignationList = nil then
      FDesignationList := TFhirCodeSystemConceptDesignationList.Create;
    FDesignationList.Assign(TFhirCodeSystemConcept(oSource).FDesignationList);
  end;
  if (TFhirCodeSystemConcept(oSource).FProperty_List = nil) then
  begin
    FProperty_List.free;
    FProperty_List := nil;
  end
  else
  begin
    if FProperty_List = nil then
      FProperty_List := TFhirCodeSystemConceptPropertyList.Create;
    FProperty_List.Assign(TFhirCodeSystemConcept(oSource).FProperty_List);
  end;
  if (TFhirCodeSystemConcept(oSource).FConceptList = nil) then
  begin
    FConceptList.free;
    FConceptList := nil;
  end
  else
  begin
    if FConceptList = nil then
      FConceptList := TFhirCodeSystemConceptList.Create;
    FConceptList.Assign(TFhirCodeSystemConcept(oSource).FConceptList);
  end;
end;

procedure TFhirCodeSystemConcept.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'display') Then
     list.add(self.link, 'display', FDisplay.Link);
  if (child_name = 'definition') Then
     list.add(self.link, 'definition', FDefinition.Link);
  if (child_name = 'designation') Then
    list.addAll(self, 'designation', FDesignationList);
  if (child_name = 'property') Then
    list.addAll(self, 'property', FProperty_List);
  if (child_name = 'concept') Then
    list.addAll(self, 'concept', FConceptList);
end;

procedure TFhirCodeSystemConcept.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'code', false, TFhirCode, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'display', 'string', false, TFhirString, FDisplay.Link));
  oList.add(TFHIRProperty.create(self, 'definition', 'string', false, TFhirString, FDefinition.Link));
  oList.add(TFHIRProperty.create(self, 'designation', 'BackboneElement', true, TFhirCodeSystemConceptDesignation, FDesignationList.Link));
  oList.add(TFHIRProperty.create(self, 'property', 'BackboneElement', true, TFhirCodeSystemConceptProperty, FProperty_List.Link));
  oList.add(TFHIRProperty.create(self, 'concept', '', true, TFhirCodeSystemConcept, FConceptList.Link));
end;

function TFhirCodeSystemConcept.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    CodeElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'display') then
  begin
    DisplayElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'definition') then
  begin
    DefinitionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'designation') then
  begin
    DesignationList.add(propValue as TFhirCodeSystemConceptDesignation);
    result := propValue;
  end
  else if (propName = 'property') then
  begin
    Property_List.add(propValue as TFhirCodeSystemConceptProperty);
    result := propValue;
  end
  else if (propName = 'concept') then
  begin
    ConceptList.add(propValue as TFhirCodeSystemConcept);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCodeSystemConcept.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'designation') then DesignationList.insertItem(index, propValue as TFhirCodeSystemConceptDesignation)
  else if (propName = 'property') then Property_List.insertItem(index, propValue as TFhirCodeSystemConceptProperty)
  else if (propName = 'concept') then ConceptList.insertItem(index, propValue as TFhirCodeSystemConcept)
  else inherited;
end;

function TFhirCodeSystemConcept.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCode.create()
  else if (propName = 'display') then result := TFhirString.create()
  else if (propName = 'definition') then result := TFhirString.create()
  else if (propName = 'designation') then result := DesignationList.new()
  else if (propName = 'property') then result := Property_List.new()
  else if (propName = 'concept') then result := ConceptList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirCodeSystemConcept.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'code'
  else if (propName = 'display') then result := 'string'
  else if (propName = 'definition') then result := 'string'
  else if (propName = 'designation') then result := 'BackboneElement'
  else if (propName = 'property') then result := 'BackboneElement'
  else if (propName = 'concept') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCodeSystemConcept.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'display') then DisplayElement := nil
  else if (propName = 'definition') then DefinitionElement := nil
  else if (propName = 'designation') then deletePropertyValue('designation', DesignationList, value)
  else if (propName = 'property') then deletePropertyValue('property', Property_List, value)
  else if (propName = 'concept') then deletePropertyValue('concept', ConceptList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCodeSystemConcept.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := asCode(new)
  else if (propName = 'display') then DisplayElement := asString(new)
  else if (propName = 'definition') then DefinitionElement := asString(new)
  else if (propName = 'designation') then replacePropertyValue('designation', DesignationList, existing, new)
  else if (propName = 'property') then replacePropertyValue('property', Property_List, existing, new)
  else if (propName = 'concept') then replacePropertyValue('concept', ConceptList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCodeSystemConcept.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'designation') then DesignationList.move(source, destination)
  else if (propName = 'property') then Property_List.move(source, destination)
  else if (propName = 'concept') then ConceptList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCodeSystemConcept.fhirType : string;
begin
  result := 'CodeSystem.concept';
end;

function TFhirCodeSystemConcept.Link : TFhirCodeSystemConcept;
begin
  result := TFhirCodeSystemConcept(inherited Link);
end;

function TFhirCodeSystemConcept.Clone : TFhirCodeSystemConcept;
begin
  result := TFhirCodeSystemConcept(inherited Clone);
end;

function TFhirCodeSystemConcept.equals(other : TObject) : boolean; 
var
  o : TFhirCodeSystemConcept;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCodeSystemConcept)) then
    result := false
  else
  begin
    o := TFhirCodeSystemConcept(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(displayElement, o.displayElement, true) and 
      compareDeep(definitionElement, o.definitionElement, true) and compareDeep(designationList, o.designationList, true) and 
      compareDeep(property_List, o.property_List, true) and compareDeep(conceptList, o.conceptList, true);
  end;
end;

function TFhirCodeSystemConcept.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FDisplay) and isEmptyProp(FDefinition) and isEmptyProp(FdesignationList) and isEmptyProp(Fproperty_List) and isEmptyProp(FconceptList);
end;

procedure TFhirCodeSystemConcept.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('code');
  fields.add('display');
  fields.add('definition');
  fields.add('designation');
  fields.add('property');
  fields.add('concept');
end;

function TFhirCodeSystemConcept.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FDesignationList.sizeInBytes(magic));
  inc(result, FProperty_List.sizeInBytes(magic));
  inc(result, FConceptList.sizeInBytes(magic));
end;

procedure TFhirCodeSystemConcept.SetCode(value : TFhirCode);
begin
  FCode.free;
  FCode := value;
end;

function TFhirCodeSystemConcept.GetCodeST : String;
begin
  if FCode = nil then
    result := ''
  else
    result := FCode.value;
end;

procedure TFhirCodeSystemConcept.SetCodeST(value : String);
begin
  if value <> '' then
  begin
    if FCode = nil then
      FCode := TFhirCode.create;
    FCode.value := value
  end
  else if FCode <> nil then
    FCode.value := '';
end;

procedure TFhirCodeSystemConcept.SetDisplay(value : TFhirString);
begin
  FDisplay.free;
  FDisplay := value;
end;

function TFhirCodeSystemConcept.GetDisplayST : String;
begin
  if FDisplay = nil then
    result := ''
  else
    result := FDisplay.value;
end;

procedure TFhirCodeSystemConcept.SetDisplayST(value : String);
begin
  if value <> '' then
  begin
    if FDisplay = nil then
      FDisplay := TFhirString.create;
    FDisplay.value := value
  end
  else if FDisplay <> nil then
    FDisplay.value := '';
end;

procedure TFhirCodeSystemConcept.SetDefinition(value : TFhirString);
begin
  FDefinition.free;
  FDefinition := value;
end;

function TFhirCodeSystemConcept.GetDefinitionST : String;
begin
  if FDefinition = nil then
    result := ''
  else
    result := FDefinition.value;
end;

procedure TFhirCodeSystemConcept.SetDefinitionST(value : String);
begin
  if value <> '' then
  begin
    if FDefinition = nil then
      FDefinition := TFhirString.create;
    FDefinition.value := value
  end
  else if FDefinition <> nil then
    FDefinition.value := '';
end;

function TFhirCodeSystemConcept.GetDesignationList : TFhirCodeSystemConceptDesignationList;
begin
  if FDesignationList = nil then
    FDesignationList := TFhirCodeSystemConceptDesignationList.Create;
  result := FDesignationList;
end;

function TFhirCodeSystemConcept.GetHasDesignationList : boolean;
begin
  result := (FDesignationList <> nil) and (FDesignationList.count > 0);
end;

function TFhirCodeSystemConcept.GetProperty_List : TFhirCodeSystemConceptPropertyList;
begin
  if FProperty_List = nil then
    FProperty_List := TFhirCodeSystemConceptPropertyList.Create;
  result := FProperty_List;
end;

function TFhirCodeSystemConcept.GetHasProperty_List : boolean;
begin
  result := (FProperty_List <> nil) and (FProperty_List.count > 0);
end;

function TFhirCodeSystemConcept.GetConceptList : TFhirCodeSystemConceptList;
begin
  if FConceptList = nil then
    FConceptList := TFhirCodeSystemConceptList.Create;
  result := FConceptList;
end;

function TFhirCodeSystemConcept.GetHasConceptList : boolean;
begin
  result := (FConceptList <> nil) and (FConceptList.count > 0);
end;

{ TFhirCodeSystemConceptListEnumerator }

constructor TFhirCodeSystemConceptListEnumerator.Create(list : TFhirCodeSystemConceptList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCodeSystemConceptListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCodeSystemConceptListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCodeSystemConceptListEnumerator.GetCurrent : TFhirCodeSystemConcept;
begin
  Result := FList[FIndex];
end;

function TFhirCodeSystemConceptListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCodeSystemConceptList }

function TFhirCodeSystemConceptList.AddItem(value: TFhirCodeSystemConcept): TFhirCodeSystemConcept;
begin
  assert(value.ClassName = 'TFhirCodeSystemConcept', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCodeSystemConcept');
  add(value);
  result := value;
end;

function TFhirCodeSystemConceptList.Append: TFhirCodeSystemConcept;
begin
  result := TFhirCodeSystemConcept.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCodeSystemConceptList.ClearItems;
begin
  Clear;
end;

function TFhirCodeSystemConceptList.GetEnumerator : TFhirCodeSystemConceptListEnumerator;
begin
  result := TFhirCodeSystemConceptListEnumerator.Create(self.link);
end;

function TFhirCodeSystemConceptList.Clone: TFhirCodeSystemConceptList;
begin
  result := TFhirCodeSystemConceptList(inherited Clone);
end;

function TFhirCodeSystemConceptList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCodeSystemConceptList.GetItemN(index: Integer): TFhirCodeSystemConcept;
begin
  result := TFhirCodeSystemConcept(ObjectByIndex[index]);
end;

function TFhirCodeSystemConceptList.ItemClass: TFslObjectClass;
begin
  result := TFhirCodeSystemConcept;
end;
function TFhirCodeSystemConceptList.IndexOf(value: TFhirCodeSystemConcept): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCodeSystemConceptList.Insert(index: Integer): TFhirCodeSystemConcept;
begin
  result := TFhirCodeSystemConcept.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCodeSystemConceptList.InsertItem(index: Integer; value: TFhirCodeSystemConcept);
begin
  assert(value is TFhirCodeSystemConcept);
  Inherited Insert(index, value);
end;

function TFhirCodeSystemConceptList.Item(index: Integer): TFhirCodeSystemConcept;
begin
  result := TFhirCodeSystemConcept(ObjectByIndex[index]);
end;

function TFhirCodeSystemConceptList.Link: TFhirCodeSystemConceptList;
begin
  result := TFhirCodeSystemConceptList(inherited Link);
end;

procedure TFhirCodeSystemConceptList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCodeSystemConceptList.SetItemByIndex(index: Integer; value: TFhirCodeSystemConcept);
begin
  assert(value is TFhirCodeSystemConcept);
  FhirCodeSystemConcepts[index] := value;
end;

procedure TFhirCodeSystemConceptList.SetItemN(index: Integer; value: TFhirCodeSystemConcept);
begin
  assert(value is TFhirCodeSystemConcept);
  ObjectByIndex[index] := value;
end;

{ TFhirCodeSystemConceptDesignation }

constructor TFhirCodeSystemConceptDesignation.Create;
begin
  inherited;
end;

destructor TFhirCodeSystemConceptDesignation.Destroy;
begin
  FLanguage.free;
  FUse.free;
  FValue.free;
  inherited;
end;

procedure TFhirCodeSystemConceptDesignation.Assign(oSource : TFslObject);
begin
  inherited;
  languageElement := TFhirCodeSystemConceptDesignation(oSource).languageElement.Clone;
  use := TFhirCodeSystemConceptDesignation(oSource).use.Clone;
  valueElement := TFhirCodeSystemConceptDesignation(oSource).valueElement.Clone;
end;

procedure TFhirCodeSystemConceptDesignation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'language') Then
     list.add(self.link, 'language', FLanguage.Link);
  if (child_name = 'use') Then
     list.add(self.link, 'use', FUse.Link);
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
end;

procedure TFhirCodeSystemConceptDesignation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'language', 'code', false, TFhirCode, FLanguage.Link));
  oList.add(TFHIRProperty.create(self, 'use', 'Coding', false, TFhirCoding, FUse.Link));
  oList.add(TFHIRProperty.create(self, 'value', 'string', false, TFhirString, FValue.Link));
end;

function TFhirCodeSystemConceptDesignation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'language') then
  begin
    LanguageElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'use') then
  begin
    Use := propValue as TFhirCoding;
    result := propValue;
  end
  else if (propName = 'value') then
  begin
    ValueElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCodeSystemConceptDesignation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCodeSystemConceptDesignation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'language') then result := TFhirCode.create()
  else if (propName = 'use') then result := TFhirCoding.create()
  else if (propName = 'value') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirCodeSystemConceptDesignation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'language') then result := 'code'
  else if (propName = 'use') then result := 'Coding'
  else if (propName = 'value') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCodeSystemConceptDesignation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'language') then LanguageElement := nil
  else if (propName = 'use') then UseElement := nil
  else if (propName = 'value') then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCodeSystemConceptDesignation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'language') then LanguageElement := asCode(new)
  else if (propName = 'use') then UseElement := new as TFhirCoding
  else if (propName = 'value') then ValueElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCodeSystemConceptDesignation.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCodeSystemConceptDesignation.fhirType : string;
begin
  result := 'CodeSystem.concept.designation';
end;

function TFhirCodeSystemConceptDesignation.Link : TFhirCodeSystemConceptDesignation;
begin
  result := TFhirCodeSystemConceptDesignation(inherited Link);
end;

function TFhirCodeSystemConceptDesignation.Clone : TFhirCodeSystemConceptDesignation;
begin
  result := TFhirCodeSystemConceptDesignation(inherited Clone);
end;

function TFhirCodeSystemConceptDesignation.equals(other : TObject) : boolean; 
var
  o : TFhirCodeSystemConceptDesignation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCodeSystemConceptDesignation)) then
    result := false
  else
  begin
    o := TFhirCodeSystemConceptDesignation(other);
    result := compareDeep(languageElement, o.languageElement, true) and compareDeep(useElement, o.useElement, true) and 
      compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirCodeSystemConceptDesignation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FLanguage) and isEmptyProp(FUse) and isEmptyProp(FValue);
end;

procedure TFhirCodeSystemConceptDesignation.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('language');
  fields.add('use');
  fields.add('value');
end;

function TFhirCodeSystemConceptDesignation.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirCodeSystemConceptDesignation.SetLanguage(value : TFhirCode);
begin
  FLanguage.free;
  FLanguage := value;
end;

function TFhirCodeSystemConceptDesignation.GetLanguageST : String;
begin
  if FLanguage = nil then
    result := ''
  else
    result := FLanguage.value;
end;

procedure TFhirCodeSystemConceptDesignation.SetLanguageST(value : String);
begin
  if value <> '' then
  begin
    if FLanguage = nil then
      FLanguage := TFhirCode.create;
    FLanguage.value := value
  end
  else if FLanguage <> nil then
    FLanguage.value := '';
end;

procedure TFhirCodeSystemConceptDesignation.SetUse(value : TFhirCoding);
begin
  FUse.free;
  FUse := value;
end;

procedure TFhirCodeSystemConceptDesignation.SetValue(value : TFhirString);
begin
  FValue.free;
  FValue := value;
end;

function TFhirCodeSystemConceptDesignation.GetValueST : String;
begin
  if FValue = nil then
    result := ''
  else
    result := FValue.value;
end;

procedure TFhirCodeSystemConceptDesignation.SetValueST(value : String);
begin
  if value <> '' then
  begin
    if FValue = nil then
      FValue := TFhirString.create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := '';
end;

{ TFhirCodeSystemConceptDesignationListEnumerator }

constructor TFhirCodeSystemConceptDesignationListEnumerator.Create(list : TFhirCodeSystemConceptDesignationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCodeSystemConceptDesignationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCodeSystemConceptDesignationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCodeSystemConceptDesignationListEnumerator.GetCurrent : TFhirCodeSystemConceptDesignation;
begin
  Result := FList[FIndex];
end;

function TFhirCodeSystemConceptDesignationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCodeSystemConceptDesignationList }

function TFhirCodeSystemConceptDesignationList.AddItem(value: TFhirCodeSystemConceptDesignation): TFhirCodeSystemConceptDesignation;
begin
  assert(value.ClassName = 'TFhirCodeSystemConceptDesignation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCodeSystemConceptDesignation');
  add(value);
  result := value;
end;

function TFhirCodeSystemConceptDesignationList.Append: TFhirCodeSystemConceptDesignation;
begin
  result := TFhirCodeSystemConceptDesignation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCodeSystemConceptDesignationList.ClearItems;
begin
  Clear;
end;

function TFhirCodeSystemConceptDesignationList.GetEnumerator : TFhirCodeSystemConceptDesignationListEnumerator;
begin
  result := TFhirCodeSystemConceptDesignationListEnumerator.Create(self.link);
end;

function TFhirCodeSystemConceptDesignationList.Clone: TFhirCodeSystemConceptDesignationList;
begin
  result := TFhirCodeSystemConceptDesignationList(inherited Clone);
end;

function TFhirCodeSystemConceptDesignationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCodeSystemConceptDesignationList.GetItemN(index: Integer): TFhirCodeSystemConceptDesignation;
begin
  result := TFhirCodeSystemConceptDesignation(ObjectByIndex[index]);
end;

function TFhirCodeSystemConceptDesignationList.ItemClass: TFslObjectClass;
begin
  result := TFhirCodeSystemConceptDesignation;
end;
function TFhirCodeSystemConceptDesignationList.IndexOf(value: TFhirCodeSystemConceptDesignation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCodeSystemConceptDesignationList.Insert(index: Integer): TFhirCodeSystemConceptDesignation;
begin
  result := TFhirCodeSystemConceptDesignation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCodeSystemConceptDesignationList.InsertItem(index: Integer; value: TFhirCodeSystemConceptDesignation);
begin
  assert(value is TFhirCodeSystemConceptDesignation);
  Inherited Insert(index, value);
end;

function TFhirCodeSystemConceptDesignationList.Item(index: Integer): TFhirCodeSystemConceptDesignation;
begin
  result := TFhirCodeSystemConceptDesignation(ObjectByIndex[index]);
end;

function TFhirCodeSystemConceptDesignationList.Link: TFhirCodeSystemConceptDesignationList;
begin
  result := TFhirCodeSystemConceptDesignationList(inherited Link);
end;

procedure TFhirCodeSystemConceptDesignationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCodeSystemConceptDesignationList.SetItemByIndex(index: Integer; value: TFhirCodeSystemConceptDesignation);
begin
  assert(value is TFhirCodeSystemConceptDesignation);
  FhirCodeSystemConceptDesignations[index] := value;
end;

procedure TFhirCodeSystemConceptDesignationList.SetItemN(index: Integer; value: TFhirCodeSystemConceptDesignation);
begin
  assert(value is TFhirCodeSystemConceptDesignation);
  ObjectByIndex[index] := value;
end;

{ TFhirCodeSystemConceptProperty }

constructor TFhirCodeSystemConceptProperty.Create;
begin
  inherited;
end;

destructor TFhirCodeSystemConceptProperty.Destroy;
begin
  FCode.free;
  FValue.free;
  inherited;
end;

procedure TFhirCodeSystemConceptProperty.Assign(oSource : TFslObject);
begin
  inherited;
  codeElement := TFhirCodeSystemConceptProperty(oSource).codeElement.Clone;
  value := TFhirCodeSystemConceptProperty(oSource).value.Clone;
end;

procedure TFhirCodeSystemConceptProperty.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
end;

procedure TFhirCodeSystemConceptProperty.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'code', false, TFhirCode, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'value[x]', 'code|Coding|string|integer|boolean|dateTime|decimal', false, TFhirDataType, FValue.Link));
end;

function TFhirCodeSystemConceptProperty.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    CodeElement := asCode(propValue);
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['Code', 'Coding', 'String', 'Integer', 'Boolean', 'DateTime', 'Decimal'])) then
  begin
    Value := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCodeSystemConceptProperty.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCodeSystemConceptProperty.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCode.create()
  else if (isMatchingName(propName, 'value', ['Code', 'Coding', 'String', 'Integer', 'Boolean', 'DateTime', 'Decimal'])) then raise EFHIRException.create('Cannot make property Value')
  else result := inherited createPropertyValue(propName);
end;

function TFhirCodeSystemConceptProperty.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'code'
  else if (propName = 'value[x]') then result := 'code|Coding|string|integer|boolean|dateTime|decimal'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCodeSystemConceptProperty.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (isMatchingName(propName, 'value', ['Code', 'Coding', 'String', 'Integer', 'Boolean', 'DateTime', 'Decimal'])) then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCodeSystemConceptProperty.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := asCode(new)
  else if (isMatchingName(propName, 'value', ['Code', 'Coding', 'String', 'Integer', 'Boolean', 'DateTime', 'Decimal'])) then ValueElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCodeSystemConceptProperty.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCodeSystemConceptProperty.fhirType : string;
begin
  result := 'CodeSystem.concept.property';
end;

function TFhirCodeSystemConceptProperty.Link : TFhirCodeSystemConceptProperty;
begin
  result := TFhirCodeSystemConceptProperty(inherited Link);
end;

function TFhirCodeSystemConceptProperty.Clone : TFhirCodeSystemConceptProperty;
begin
  result := TFhirCodeSystemConceptProperty(inherited Clone);
end;

function TFhirCodeSystemConceptProperty.equals(other : TObject) : boolean; 
var
  o : TFhirCodeSystemConceptProperty;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCodeSystemConceptProperty)) then
    result := false
  else
  begin
    o := TFhirCodeSystemConceptProperty(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirCodeSystemConceptProperty.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FValue);
end;

procedure TFhirCodeSystemConceptProperty.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('code');
  fields.add('value[x]');
end;

function TFhirCodeSystemConceptProperty.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirCodeSystemConceptProperty.SetCode(value : TFhirCode);
begin
  FCode.free;
  FCode := value;
end;

function TFhirCodeSystemConceptProperty.GetCodeST : String;
begin
  if FCode = nil then
    result := ''
  else
    result := FCode.value;
end;

procedure TFhirCodeSystemConceptProperty.SetCodeST(value : String);
begin
  if value <> '' then
  begin
    if FCode = nil then
      FCode := TFhirCode.create;
    FCode.value := value
  end
  else if FCode <> nil then
    FCode.value := '';
end;

procedure TFhirCodeSystemConceptProperty.SetValue(value : TFhirDataType);
begin
  FValue.free;
  FValue := value;
end;

{ TFhirCodeSystemConceptPropertyListEnumerator }

constructor TFhirCodeSystemConceptPropertyListEnumerator.Create(list : TFhirCodeSystemConceptPropertyList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCodeSystemConceptPropertyListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCodeSystemConceptPropertyListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCodeSystemConceptPropertyListEnumerator.GetCurrent : TFhirCodeSystemConceptProperty;
begin
  Result := FList[FIndex];
end;

function TFhirCodeSystemConceptPropertyListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCodeSystemConceptPropertyList }

function TFhirCodeSystemConceptPropertyList.AddItem(value: TFhirCodeSystemConceptProperty): TFhirCodeSystemConceptProperty;
begin
  assert(value.ClassName = 'TFhirCodeSystemConceptProperty', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCodeSystemConceptProperty');
  add(value);
  result := value;
end;

function TFhirCodeSystemConceptPropertyList.Append: TFhirCodeSystemConceptProperty;
begin
  result := TFhirCodeSystemConceptProperty.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCodeSystemConceptPropertyList.ClearItems;
begin
  Clear;
end;

function TFhirCodeSystemConceptPropertyList.GetEnumerator : TFhirCodeSystemConceptPropertyListEnumerator;
begin
  result := TFhirCodeSystemConceptPropertyListEnumerator.Create(self.link);
end;

function TFhirCodeSystemConceptPropertyList.Clone: TFhirCodeSystemConceptPropertyList;
begin
  result := TFhirCodeSystemConceptPropertyList(inherited Clone);
end;

function TFhirCodeSystemConceptPropertyList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCodeSystemConceptPropertyList.GetItemN(index: Integer): TFhirCodeSystemConceptProperty;
begin
  result := TFhirCodeSystemConceptProperty(ObjectByIndex[index]);
end;

function TFhirCodeSystemConceptPropertyList.ItemClass: TFslObjectClass;
begin
  result := TFhirCodeSystemConceptProperty;
end;
function TFhirCodeSystemConceptPropertyList.IndexOf(value: TFhirCodeSystemConceptProperty): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCodeSystemConceptPropertyList.Insert(index: Integer): TFhirCodeSystemConceptProperty;
begin
  result := TFhirCodeSystemConceptProperty.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCodeSystemConceptPropertyList.InsertItem(index: Integer; value: TFhirCodeSystemConceptProperty);
begin
  assert(value is TFhirCodeSystemConceptProperty);
  Inherited Insert(index, value);
end;

function TFhirCodeSystemConceptPropertyList.Item(index: Integer): TFhirCodeSystemConceptProperty;
begin
  result := TFhirCodeSystemConceptProperty(ObjectByIndex[index]);
end;

function TFhirCodeSystemConceptPropertyList.Link: TFhirCodeSystemConceptPropertyList;
begin
  result := TFhirCodeSystemConceptPropertyList(inherited Link);
end;

procedure TFhirCodeSystemConceptPropertyList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCodeSystemConceptPropertyList.SetItemByIndex(index: Integer; value: TFhirCodeSystemConceptProperty);
begin
  assert(value is TFhirCodeSystemConceptProperty);
  FhirCodeSystemConceptProperties[index] := value;
end;

procedure TFhirCodeSystemConceptPropertyList.SetItemN(index: Integer; value: TFhirCodeSystemConceptProperty);
begin
  assert(value is TFhirCodeSystemConceptProperty);
  ObjectByIndex[index] := value;
end;

{ TFhirCodeSystem }

constructor TFhirCodeSystem.Create;
begin
  inherited;
end;

destructor TFhirCodeSystem.Destroy;
begin
  FUrl.free;
  FIdentifierList.Free;
  FVersion.free;
  FName.free;
  FTitle.free;
  FStatus.free;
  FExperimental.free;
  FDate.free;
  FPublisher.free;
  FContactList.Free;
  FDescription.free;
  FUseContextList.Free;
  FJurisdictionList.Free;
  FPurpose.free;
  FCopyright.free;
  FCaseSensitive.free;
  FValueSet.free;
  FHierarchyMeaning.free;
  FCompositional.free;
  FVersionNeeded.free;
  FContent.free;
  FSupplements.free;
  FCount.free;
  FFilterList.Free;
  FProperty_List.Free;
  FConceptList.Free;
  inherited;
end;

procedure TFhirCodeSystem.Assign(oSource : TFslObject);
begin
  inherited;
  urlElement := TFhirCodeSystem(oSource).urlElement.Clone;
  if (TFhirCodeSystem(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirCodeSystem(oSource).FIdentifierList);
  end;
  versionElement := TFhirCodeSystem(oSource).versionElement.Clone;
  nameElement := TFhirCodeSystem(oSource).nameElement.Clone;
  titleElement := TFhirCodeSystem(oSource).titleElement.Clone;
  statusElement := TFhirCodeSystem(oSource).statusElement.Clone;
  experimentalElement := TFhirCodeSystem(oSource).experimentalElement.Clone;
  dateElement := TFhirCodeSystem(oSource).dateElement.Clone;
  publisherElement := TFhirCodeSystem(oSource).publisherElement.Clone;
  if (TFhirCodeSystem(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirContactDetailList.Create;
    FContactList.Assign(TFhirCodeSystem(oSource).FContactList);
  end;
  descriptionElement := TFhirCodeSystem(oSource).descriptionElement.Clone;
  if (TFhirCodeSystem(oSource).FUseContextList = nil) then
  begin
    FUseContextList.free;
    FUseContextList := nil;
  end
  else
  begin
    if FUseContextList = nil then
      FUseContextList := TFhirUsageContextList.Create;
    FUseContextList.Assign(TFhirCodeSystem(oSource).FUseContextList);
  end;
  if (TFhirCodeSystem(oSource).FJurisdictionList = nil) then
  begin
    FJurisdictionList.free;
    FJurisdictionList := nil;
  end
  else
  begin
    if FJurisdictionList = nil then
      FJurisdictionList := TFhirCodeableConceptList.Create;
    FJurisdictionList.Assign(TFhirCodeSystem(oSource).FJurisdictionList);
  end;
  purposeElement := TFhirCodeSystem(oSource).purposeElement.Clone;
  copyrightElement := TFhirCodeSystem(oSource).copyrightElement.Clone;
  caseSensitiveElement := TFhirCodeSystem(oSource).caseSensitiveElement.Clone;
  valueSetElement := TFhirCodeSystem(oSource).valueSetElement.Clone;
  hierarchyMeaningElement := TFhirCodeSystem(oSource).hierarchyMeaningElement.Clone;
  compositionalElement := TFhirCodeSystem(oSource).compositionalElement.Clone;
  versionNeededElement := TFhirCodeSystem(oSource).versionNeededElement.Clone;
  contentElement := TFhirCodeSystem(oSource).contentElement.Clone;
  supplementsElement := TFhirCodeSystem(oSource).supplementsElement.Clone;
  countElement := TFhirCodeSystem(oSource).countElement.Clone;
  if (TFhirCodeSystem(oSource).FFilterList = nil) then
  begin
    FFilterList.free;
    FFilterList := nil;
  end
  else
  begin
    if FFilterList = nil then
      FFilterList := TFhirCodeSystemFilterList.Create;
    FFilterList.Assign(TFhirCodeSystem(oSource).FFilterList);
  end;
  if (TFhirCodeSystem(oSource).FProperty_List = nil) then
  begin
    FProperty_List.free;
    FProperty_List := nil;
  end
  else
  begin
    if FProperty_List = nil then
      FProperty_List := TFhirCodeSystemPropertyList.Create;
    FProperty_List.Assign(TFhirCodeSystem(oSource).FProperty_List);
  end;
  if (TFhirCodeSystem(oSource).FConceptList = nil) then
  begin
    FConceptList.free;
    FConceptList := nil;
  end
  else
  begin
    if FConceptList = nil then
      FConceptList := TFhirCodeSystemConceptList.Create;
    FConceptList.Assign(TFhirCodeSystem(oSource).FConceptList);
  end;
end;

function TFhirCodeSystem.GetResourceType : TFhirResourceType;
begin
  result := frtCodeSystem;
end;

procedure TFhirCodeSystem.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'version') Then
     list.add(self.link, 'version', FVersion.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'experimental') Then
     list.add(self.link, 'experimental', FExperimental.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'publisher') Then
     list.add(self.link, 'publisher', FPublisher.Link);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'useContext') Then
    list.addAll(self, 'useContext', FUseContextList);
  if (child_name = 'jurisdiction') Then
    list.addAll(self, 'jurisdiction', FJurisdictionList);
  if (child_name = 'purpose') Then
     list.add(self.link, 'purpose', FPurpose.Link);
  if (child_name = 'copyright') Then
     list.add(self.link, 'copyright', FCopyright.Link);
  if (child_name = 'caseSensitive') Then
     list.add(self.link, 'caseSensitive', FCaseSensitive.Link);
  if (child_name = 'valueSet') Then
     list.add(self.link, 'valueSet', FValueSet.Link);
  if (child_name = 'hierarchyMeaning') Then
     list.add(self.link, 'hierarchyMeaning', FHierarchyMeaning.Link);
  if (child_name = 'compositional') Then
     list.add(self.link, 'compositional', FCompositional.Link);
  if (child_name = 'versionNeeded') Then
     list.add(self.link, 'versionNeeded', FVersionNeeded.Link);
  if (child_name = 'content') Then
     list.add(self.link, 'content', FContent.Link);
  if (child_name = 'supplements') Then
     list.add(self.link, 'supplements', FSupplements.Link);
  if (child_name = 'count') Then
     list.add(self.link, 'count', FCount.Link);
  if (child_name = 'filter') Then
    list.addAll(self, 'filter', FFilterList);
  if (child_name = 'property') Then
    list.addAll(self, 'property', FProperty_List);
  if (child_name = 'concept') Then
    list.addAll(self, 'concept', FConceptList);
end;

procedure TFhirCodeSystem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'url', 'uri', false, TFhirUri, FUrl.Link));
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'version', 'string', false, TFhirString, FVersion.Link));
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'experimental', 'boolean', false, TFhirBoolean, FExperimental.Link));
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));
  oList.add(TFHIRProperty.create(self, 'publisher', 'string', false, TFhirString, FPublisher.Link));
  oList.add(TFHIRProperty.create(self, 'contact', 'ContactDetail', true, TFhirContactDetail, FContactList.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'markdown', false, TFhirMarkdown, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'useContext', 'UsageContext', true, TFhirUsageContext, FUseContextList.Link));
  oList.add(TFHIRProperty.create(self, 'jurisdiction', 'CodeableConcept', true, TFhirCodeableConcept, FJurisdictionList.Link));
  oList.add(TFHIRProperty.create(self, 'purpose', 'markdown', false, TFhirMarkdown, FPurpose.Link));
  oList.add(TFHIRProperty.create(self, 'copyright', 'markdown', false, TFhirMarkdown, FCopyright.Link));
  oList.add(TFHIRProperty.create(self, 'caseSensitive', 'boolean', false, TFhirBoolean, FCaseSensitive.Link));
  oList.add(TFHIRProperty.create(self, 'valueSet', 'canonical', false, TFhirCanonical, FValueSet.Link));
  oList.add(TFHIRProperty.create(self, 'hierarchyMeaning', 'code', false, TFhirEnum, FHierarchyMeaning.Link));
  oList.add(TFHIRProperty.create(self, 'compositional', 'boolean', false, TFhirBoolean, FCompositional.Link));
  oList.add(TFHIRProperty.create(self, 'versionNeeded', 'boolean', false, TFhirBoolean, FVersionNeeded.Link));
  oList.add(TFHIRProperty.create(self, 'content', 'code', false, TFhirEnum, FContent.Link));
  oList.add(TFHIRProperty.create(self, 'supplements', 'canonical', false, TFhirCanonical, FSupplements.Link));
  oList.add(TFHIRProperty.create(self, 'count', 'unsignedInt', false, TFhirUnsignedInt, FCount.Link));
  oList.add(TFHIRProperty.create(self, 'filter', 'BackboneElement', true, TFhirCodeSystemFilter, FFilterList.Link));
  oList.add(TFHIRProperty.create(self, 'property', 'BackboneElement', true, TFhirCodeSystemProperty, FProperty_List.Link));
  oList.add(TFHIRProperty.create(self, 'concept', 'BackboneElement', true, TFhirCodeSystemConcept, FConceptList.Link));
end;

function TFhirCodeSystem.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'url') then
  begin
    UrlElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'title') then
  begin
    TitleElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'experimental') then
  begin
    ExperimentalElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'publisher') then
  begin
    PublisherElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirContactDetail);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'useContext') then
  begin
    UseContextList.add(propValue as TFhirUsageContext);
    result := propValue;
  end
  else if (propName = 'jurisdiction') then
  begin
    JurisdictionList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'purpose') then
  begin
    PurposeElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'copyright') then
  begin
    CopyrightElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'caseSensitive') then
  begin
    CaseSensitiveElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'valueSet') then
  begin
    ValueSetElement := asCanonical(propValue);
    result := propValue;
  end
  else if (propName = 'hierarchyMeaning') then
  begin
    HierarchyMeaningElement := asEnum(SYSTEMS_TFhirCodeSystemHierarchyMeaningEnum, CODES_TFhirCodeSystemHierarchyMeaningEnum, propValue);
    result := propValue;
  end
  else if (propName = 'compositional') then
  begin
    CompositionalElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'versionNeeded') then
  begin
    VersionNeededElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'content') then
  begin
    ContentElement := asEnum(SYSTEMS_TFhirCodeSystemContentModeEnum, CODES_TFhirCodeSystemContentModeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'supplements') then
  begin
    SupplementsElement := asCanonical(propValue);
    result := propValue;
  end
  else if (propName = 'count') then
  begin
    CountElement := asUnsignedInt(propValue);
    result := propValue;
  end
  else if (propName = 'filter') then
  begin
    FilterList.add(propValue as TFhirCodeSystemFilter);
    result := propValue;
  end
  else if (propName = 'property') then
  begin
    Property_List.add(propValue as TFhirCodeSystemProperty);
    result := propValue;
  end
  else if (propName = 'concept') then
  begin
    ConceptList.add(propValue as TFhirCodeSystemConcept);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCodeSystem.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirContactDetail)
  else if (propName = 'useContext') then UseContextList.insertItem(index, propValue as TFhirUsageContext)
  else if (propName = 'jurisdiction') then JurisdictionList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'filter') then FilterList.insertItem(index, propValue as TFhirCodeSystemFilter)
  else if (propName = 'property') then Property_List.insertItem(index, propValue as TFhirCodeSystemProperty)
  else if (propName = 'concept') then ConceptList.insertItem(index, propValue as TFhirCodeSystemConcept)
  else inherited;
end;

function TFhirCodeSystem.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'url') then result := TFhirUri.create()
  else if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'version') then result := TFhirString.create()
  else if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'title') then result := TFhirString.create()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[PublicationStatusNull], CODES_TFhirPublicationStatusEnum[PublicationStatusNull]) 
  else if (propName = 'experimental') then result := TFhirBoolean.create()
  else if (propName = 'date') then result := TFhirDateTime.create()
  else if (propName = 'publisher') then result := TFhirString.create()
  else if (propName = 'contact') then result := ContactList.new()
  else if (propName = 'description') then result := TFhirMarkdown.create()
  else if (propName = 'useContext') then result := UseContextList.new()
  else if (propName = 'jurisdiction') then result := JurisdictionList.new()
  else if (propName = 'purpose') then result := TFhirMarkdown.create()
  else if (propName = 'copyright') then result := TFhirMarkdown.create()
  else if (propName = 'caseSensitive') then result := TFhirBoolean.create()
  else if (propName = 'valueSet') then result := TFhirCanonical.create()
  else if (propName = 'hierarchyMeaning') then result := TFhirEnum.create(SYSTEMS_TFhirCodeSystemHierarchyMeaningEnum[CodeSystemHierarchyMeaningNull], CODES_TFhirCodeSystemHierarchyMeaningEnum[CodeSystemHierarchyMeaningNull]) 
  else if (propName = 'compositional') then result := TFhirBoolean.create()
  else if (propName = 'versionNeeded') then result := TFhirBoolean.create()
  else if (propName = 'content') then result := TFhirEnum.create(SYSTEMS_TFhirCodeSystemContentModeEnum[CodeSystemContentModeNull], CODES_TFhirCodeSystemContentModeEnum[CodeSystemContentModeNull]) 
  else if (propName = 'supplements') then result := TFhirCanonical.create()
  else if (propName = 'count') then result := TFhirUnsignedInt.create()
  else if (propName = 'filter') then result := FilterList.new()
  else if (propName = 'property') then result := Property_List.new()
  else if (propName = 'concept') then result := ConceptList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirCodeSystem.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'url') then result := 'uri'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'version') then result := 'string'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'title') then result := 'string'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'experimental') then result := 'boolean'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'publisher') then result := 'string'
  else if (propName = 'contact') then result := 'ContactDetail'
  else if (propName = 'description') then result := 'markdown'
  else if (propName = 'useContext') then result := 'UsageContext'
  else if (propName = 'jurisdiction') then result := 'CodeableConcept'
  else if (propName = 'purpose') then result := 'markdown'
  else if (propName = 'copyright') then result := 'markdown'
  else if (propName = 'caseSensitive') then result := 'boolean'
  else if (propName = 'valueSet') then result := 'canonical'
  else if (propName = 'hierarchyMeaning') then result := 'code'
  else if (propName = 'compositional') then result := 'boolean'
  else if (propName = 'versionNeeded') then result := 'boolean'
  else if (propName = 'content') then result := 'code'
  else if (propName = 'supplements') then result := 'canonical'
  else if (propName = 'count') then result := 'unsignedInt'
  else if (propName = 'filter') then result := 'BackboneElement'
  else if (propName = 'property') then result := 'BackboneElement'
  else if (propName = 'concept') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCodeSystem.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := nil
  else if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'version') then VersionElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'title') then TitleElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'experimental') then ExperimentalElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'publisher') then PublisherElement := nil
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value)
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'useContext') then deletePropertyValue('useContext', UseContextList, value)
  else if (propName = 'jurisdiction') then deletePropertyValue('jurisdiction', JurisdictionList, value)
  else if (propName = 'purpose') then PurposeElement := nil
  else if (propName = 'copyright') then CopyrightElement := nil
  else if (propName = 'caseSensitive') then CaseSensitiveElement := nil
  else if (propName = 'valueSet') then ValueSetElement := nil
  else if (propName = 'hierarchyMeaning') then HierarchyMeaningElement := nil
  else if (propName = 'compositional') then CompositionalElement := nil
  else if (propName = 'versionNeeded') then VersionNeededElement := nil
  else if (propName = 'content') then ContentElement := nil
  else if (propName = 'supplements') then SupplementsElement := nil
  else if (propName = 'count') then CountElement := nil
  else if (propName = 'filter') then deletePropertyValue('filter', FilterList, value)
  else if (propName = 'property') then deletePropertyValue('property', Property_List, value)
  else if (propName = 'concept') then deletePropertyValue('concept', ConceptList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCodeSystem.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := asUri(new)
  else if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'version') then VersionElement := asString(new)
  else if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'title') then TitleElement := asString(new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, new)
  else if (propName = 'experimental') then ExperimentalElement := asBoolean(new)
  else if (propName = 'date') then DateElement := asDateTime(new)
  else if (propName = 'publisher') then PublisherElement := asString(new)
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new)
  else if (propName = 'description') then DescriptionElement := asMarkdown(new)
  else if (propName = 'useContext') then replacePropertyValue('useContext', UseContextList, existing, new)
  else if (propName = 'jurisdiction') then replacePropertyValue('jurisdiction', JurisdictionList, existing, new)
  else if (propName = 'purpose') then PurposeElement := asMarkdown(new)
  else if (propName = 'copyright') then CopyrightElement := asMarkdown(new)
  else if (propName = 'caseSensitive') then CaseSensitiveElement := asBoolean(new)
  else if (propName = 'valueSet') then ValueSetElement := asCanonical(new)
  else if (propName = 'hierarchyMeaning') then HierarchyMeaningElement := asEnum(SYSTEMS_TFhirCodeSystemHierarchyMeaningEnum, CODES_TFhirCodeSystemHierarchyMeaningEnum, new)
  else if (propName = 'compositional') then CompositionalElement := asBoolean(new)
  else if (propName = 'versionNeeded') then VersionNeededElement := asBoolean(new)
  else if (propName = 'content') then ContentElement := asEnum(SYSTEMS_TFhirCodeSystemContentModeEnum, CODES_TFhirCodeSystemContentModeEnum, new)
  else if (propName = 'supplements') then SupplementsElement := asCanonical(new)
  else if (propName = 'count') then CountElement := asUnsignedInt(new)
  else if (propName = 'filter') then replacePropertyValue('filter', FilterList, existing, new)
  else if (propName = 'property') then replacePropertyValue('property', Property_List, existing, new)
  else if (propName = 'concept') then replacePropertyValue('concept', ConceptList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCodeSystem.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'contact') then ContactList.move(source, destination)
  else if (propName = 'useContext') then UseContextList.move(source, destination)
  else if (propName = 'jurisdiction') then JurisdictionList.move(source, destination)
  else if (propName = 'filter') then FilterList.move(source, destination)
  else if (propName = 'property') then Property_List.move(source, destination)
  else if (propName = 'concept') then ConceptList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCodeSystem.fhirType : string;
begin
  result := 'CodeSystem';
end;

function TFhirCodeSystem.Link : TFhirCodeSystem;
begin
  result := TFhirCodeSystem(inherited Link);
end;

function TFhirCodeSystem.Clone : TFhirCodeSystem;
begin
  result := TFhirCodeSystem(inherited Clone);
end;

function TFhirCodeSystem.equals(other : TObject) : boolean; 
var
  o : TFhirCodeSystem;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCodeSystem)) then
    result := false
  else
  begin
    o := TFhirCodeSystem(other);
    result := compareDeep(urlElement, o.urlElement, true) and compareDeep(identifierList, o.identifierList, true) and 
      compareDeep(versionElement, o.versionElement, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(titleElement, o.titleElement, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(experimentalElement, o.experimentalElement, true) and compareDeep(dateElement, o.dateElement, true) and 
      compareDeep(publisherElement, o.publisherElement, true) and compareDeep(contactList, o.contactList, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(useContextList, o.useContextList, true) and 
      compareDeep(jurisdictionList, o.jurisdictionList, true) and compareDeep(purposeElement, o.purposeElement, true) and 
      compareDeep(copyrightElement, o.copyrightElement, true) and compareDeep(caseSensitiveElement, o.caseSensitiveElement, true) and 
      compareDeep(valueSetElement, o.valueSetElement, true) and compareDeep(hierarchyMeaningElement, o.hierarchyMeaningElement, true) and 
      compareDeep(compositionalElement, o.compositionalElement, true) and compareDeep(versionNeededElement, o.versionNeededElement, true) and 
      compareDeep(contentElement, o.contentElement, true) and compareDeep(supplementsElement, o.supplementsElement, true) and 
      compareDeep(countElement, o.countElement, true) and compareDeep(filterList, o.filterList, true) and 
      compareDeep(property_List, o.property_List, true) and compareDeep(conceptList, o.conceptList, true);
  end;
end;

function TFhirCodeSystem.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FUrl) and isEmptyProp(FidentifierList) and isEmptyProp(FVersion) and isEmptyProp(FName) and isEmptyProp(FTitle) and isEmptyProp(FStatus) and isEmptyProp(FExperimental) and isEmptyProp(FDate) and isEmptyProp(FPublisher) and isEmptyProp(FcontactList) and isEmptyProp(FDescription) and isEmptyProp(FuseContextList) and isEmptyProp(FjurisdictionList) and isEmptyProp(FPurpose) and isEmptyProp(FCopyright) and isEmptyProp(FCaseSensitive) and isEmptyProp(FValueSet) and isEmptyProp(FHierarchyMeaning) and isEmptyProp(FCompositional) and isEmptyProp(FVersionNeeded) and isEmptyProp(FContent) and isEmptyProp(FSupplements) and isEmptyProp(FCount) and isEmptyProp(FfilterList) and isEmptyProp(Fproperty_List) and isEmptyProp(FconceptList);
end;

procedure TFhirCodeSystem.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('url');
  fields.add('identifier');
  fields.add('version');
  fields.add('name');
  fields.add('title');
  fields.add('status');
  fields.add('experimental');
  fields.add('date');
  fields.add('publisher');
  fields.add('contact');
  fields.add('description');
  fields.add('useContext');
  fields.add('jurisdiction');
  fields.add('purpose');
  fields.add('copyright');
  fields.add('caseSensitive');
  fields.add('valueSet');
  fields.add('hierarchyMeaning');
  fields.add('compositional');
  fields.add('versionNeeded');
  fields.add('content');
  fields.add('supplements');
  fields.add('count');
  fields.add('filter');
  fields.add('property');
  fields.add('concept');
end;

function TFhirCodeSystem.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FContactList.sizeInBytes(magic));
  inc(result, FUseContextList.sizeInBytes(magic));
  inc(result, FJurisdictionList.sizeInBytes(magic));
  inc(result, FFilterList.sizeInBytes(magic));
  inc(result, FProperty_List.sizeInBytes(magic));
  inc(result, FConceptList.sizeInBytes(magic));
end;

procedure TFhirCodeSystem.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

function TFhirCodeSystem.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

procedure TFhirCodeSystem.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

function TFhirCodeSystem.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirCodeSystem.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirCodeSystem.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

function TFhirCodeSystem.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

procedure TFhirCodeSystem.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

procedure TFhirCodeSystem.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirCodeSystem.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirCodeSystem.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirCodeSystem.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

function TFhirCodeSystem.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

procedure TFhirCodeSystem.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

procedure TFhirCodeSystem.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirCodeSystem.GetStatusST : TFhirPublicationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirPublicationStatusEnum(0)
  else
    result := TFhirPublicationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirPublicationStatusEnum, FStatus.value));
end;

procedure TFhirCodeSystem.SetStatusST(value : TFhirPublicationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[value], CODES_TFhirPublicationStatusEnum[value]);
end;

procedure TFhirCodeSystem.SetExperimental(value : TFhirBoolean);
begin
  FExperimental.free;
  FExperimental := value;
end;

function TFhirCodeSystem.GetExperimentalST : Boolean;
begin
  if FExperimental = nil then
    result := false
  else
    result := FExperimental.value;
end;

procedure TFhirCodeSystem.SetExperimentalST(value : Boolean);
begin
  if FExperimental = nil then
    FExperimental := TFhirBoolean.create;
  FExperimental.value := value
end;

procedure TFhirCodeSystem.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

function TFhirCodeSystem.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirCodeSystem.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

procedure TFhirCodeSystem.SetPublisher(value : TFhirString);
begin
  FPublisher.free;
  FPublisher := value;
end;

function TFhirCodeSystem.GetPublisherST : String;
begin
  if FPublisher = nil then
    result := ''
  else
    result := FPublisher.value;
end;

procedure TFhirCodeSystem.SetPublisherST(value : String);
begin
  if value <> '' then
  begin
    if FPublisher = nil then
      FPublisher := TFhirString.create;
    FPublisher.value := value
  end
  else if FPublisher <> nil then
    FPublisher.value := '';
end;

function TFhirCodeSystem.GetContactList : TFhirContactDetailList;
begin
  if FContactList = nil then
    FContactList := TFhirContactDetailList.Create;
  result := FContactList;
end;

function TFhirCodeSystem.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

procedure TFhirCodeSystem.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirCodeSystem.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirCodeSystem.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirCodeSystem.GetUseContextList : TFhirUsageContextList;
begin
  if FUseContextList = nil then
    FUseContextList := TFhirUsageContextList.Create;
  result := FUseContextList;
end;

function TFhirCodeSystem.GetHasUseContextList : boolean;
begin
  result := (FUseContextList <> nil) and (FUseContextList.count > 0);
end;

function TFhirCodeSystem.GetJurisdictionList : TFhirCodeableConceptList;
begin
  if FJurisdictionList = nil then
    FJurisdictionList := TFhirCodeableConceptList.Create;
  result := FJurisdictionList;
end;

function TFhirCodeSystem.GetHasJurisdictionList : boolean;
begin
  result := (FJurisdictionList <> nil) and (FJurisdictionList.count > 0);
end;

procedure TFhirCodeSystem.SetPurpose(value : TFhirMarkdown);
begin
  FPurpose.free;
  FPurpose := value;
end;

function TFhirCodeSystem.GetPurposeST : String;
begin
  if FPurpose = nil then
    result := ''
  else
    result := FPurpose.value;
end;

procedure TFhirCodeSystem.SetPurposeST(value : String);
begin
  if value <> '' then
  begin
    if FPurpose = nil then
      FPurpose := TFhirMarkdown.create;
    FPurpose.value := value
  end
  else if FPurpose <> nil then
    FPurpose.value := '';
end;

procedure TFhirCodeSystem.SetCopyright(value : TFhirMarkdown);
begin
  FCopyright.free;
  FCopyright := value;
end;

function TFhirCodeSystem.GetCopyrightST : String;
begin
  if FCopyright = nil then
    result := ''
  else
    result := FCopyright.value;
end;

procedure TFhirCodeSystem.SetCopyrightST(value : String);
begin
  if value <> '' then
  begin
    if FCopyright = nil then
      FCopyright := TFhirMarkdown.create;
    FCopyright.value := value
  end
  else if FCopyright <> nil then
    FCopyright.value := '';
end;

procedure TFhirCodeSystem.SetCaseSensitive(value : TFhirBoolean);
begin
  FCaseSensitive.free;
  FCaseSensitive := value;
end;

function TFhirCodeSystem.GetCaseSensitiveST : Boolean;
begin
  if FCaseSensitive = nil then
    result := false
  else
    result := FCaseSensitive.value;
end;

procedure TFhirCodeSystem.SetCaseSensitiveST(value : Boolean);
begin
  if FCaseSensitive = nil then
    FCaseSensitive := TFhirBoolean.create;
  FCaseSensitive.value := value
end;

procedure TFhirCodeSystem.SetValueSet(value : TFhirCanonical);
begin
  FValueSet.free;
  FValueSet := value;
end;

function TFhirCodeSystem.GetValueSetST : String;
begin
  if FValueSet = nil then
    result := ''
  else
    result := FValueSet.value;
end;

procedure TFhirCodeSystem.SetValueSetST(value : String);
begin
  if value <> '' then
  begin
    if FValueSet = nil then
      FValueSet := TFhirCanonical.create;
    FValueSet.value := value
  end
  else if FValueSet <> nil then
    FValueSet.value := '';
end;

procedure TFhirCodeSystem.SetHierarchyMeaning(value : TFhirEnum);
begin
  FHierarchyMeaning.free;
  FHierarchyMeaning := value;
end;

function TFhirCodeSystem.GetHierarchyMeaningST : TFhirCodeSystemHierarchyMeaningEnum;
begin
  if FHierarchyMeaning = nil then
    result := TFhirCodeSystemHierarchyMeaningEnum(0)
  else
    result := TFhirCodeSystemHierarchyMeaningEnum(StringArrayIndexOfSensitive(CODES_TFhirCodeSystemHierarchyMeaningEnum, FHierarchyMeaning.value));
end;

procedure TFhirCodeSystem.SetHierarchyMeaningST(value : TFhirCodeSystemHierarchyMeaningEnum);
begin
  if ord(value) = 0 then
    HierarchyMeaningElement := nil
  else
    HierarchyMeaningElement := TFhirEnum.create(SYSTEMS_TFhirCodeSystemHierarchyMeaningEnum[value], CODES_TFhirCodeSystemHierarchyMeaningEnum[value]);
end;

procedure TFhirCodeSystem.SetCompositional(value : TFhirBoolean);
begin
  FCompositional.free;
  FCompositional := value;
end;

function TFhirCodeSystem.GetCompositionalST : Boolean;
begin
  if FCompositional = nil then
    result := false
  else
    result := FCompositional.value;
end;

procedure TFhirCodeSystem.SetCompositionalST(value : Boolean);
begin
  if FCompositional = nil then
    FCompositional := TFhirBoolean.create;
  FCompositional.value := value
end;

procedure TFhirCodeSystem.SetVersionNeeded(value : TFhirBoolean);
begin
  FVersionNeeded.free;
  FVersionNeeded := value;
end;

function TFhirCodeSystem.GetVersionNeededST : Boolean;
begin
  if FVersionNeeded = nil then
    result := false
  else
    result := FVersionNeeded.value;
end;

procedure TFhirCodeSystem.SetVersionNeededST(value : Boolean);
begin
  if FVersionNeeded = nil then
    FVersionNeeded := TFhirBoolean.create;
  FVersionNeeded.value := value
end;

procedure TFhirCodeSystem.SetContent(value : TFhirEnum);
begin
  FContent.free;
  FContent := value;
end;

function TFhirCodeSystem.GetContentST : TFhirCodeSystemContentModeEnum;
begin
  if FContent = nil then
    result := TFhirCodeSystemContentModeEnum(0)
  else
    result := TFhirCodeSystemContentModeEnum(StringArrayIndexOfSensitive(CODES_TFhirCodeSystemContentModeEnum, FContent.value));
end;

procedure TFhirCodeSystem.SetContentST(value : TFhirCodeSystemContentModeEnum);
begin
  if ord(value) = 0 then
    ContentElement := nil
  else
    ContentElement := TFhirEnum.create(SYSTEMS_TFhirCodeSystemContentModeEnum[value], CODES_TFhirCodeSystemContentModeEnum[value]);
end;

procedure TFhirCodeSystem.SetSupplements(value : TFhirCanonical);
begin
  FSupplements.free;
  FSupplements := value;
end;

function TFhirCodeSystem.GetSupplementsST : String;
begin
  if FSupplements = nil then
    result := ''
  else
    result := FSupplements.value;
end;

procedure TFhirCodeSystem.SetSupplementsST(value : String);
begin
  if value <> '' then
  begin
    if FSupplements = nil then
      FSupplements := TFhirCanonical.create;
    FSupplements.value := value
  end
  else if FSupplements <> nil then
    FSupplements.value := '';
end;

procedure TFhirCodeSystem.SetCount(value : TFhirUnsignedInt);
begin
  FCount.free;
  FCount := value;
end;

function TFhirCodeSystem.GetCountST : String;
begin
  if FCount = nil then
    result := ''
  else
    result := FCount.value;
end;

procedure TFhirCodeSystem.SetCountST(value : String);
begin
  if value <> '' then
  begin
    if FCount = nil then
      FCount := TFhirUnsignedInt.create;
    FCount.value := value
  end
  else if FCount <> nil then
    FCount.value := '';
end;

function TFhirCodeSystem.GetFilterList : TFhirCodeSystemFilterList;
begin
  if FFilterList = nil then
    FFilterList := TFhirCodeSystemFilterList.Create;
  result := FFilterList;
end;

function TFhirCodeSystem.GetHasFilterList : boolean;
begin
  result := (FFilterList <> nil) and (FFilterList.count > 0);
end;

function TFhirCodeSystem.GetProperty_List : TFhirCodeSystemPropertyList;
begin
  if FProperty_List = nil then
    FProperty_List := TFhirCodeSystemPropertyList.Create;
  result := FProperty_List;
end;

function TFhirCodeSystem.GetHasProperty_List : boolean;
begin
  result := (FProperty_List <> nil) and (FProperty_List.count > 0);
end;

function TFhirCodeSystem.GetConceptList : TFhirCodeSystemConceptList;
begin
  if FConceptList = nil then
    FConceptList := TFhirCodeSystemConceptList.Create;
  result := FConceptList;
end;

function TFhirCodeSystem.GetHasConceptList : boolean;
begin
  result := (FConceptList <> nil) and (FConceptList.count > 0);
end;

{ TFhirCodeSystemListEnumerator }

constructor TFhirCodeSystemListEnumerator.Create(list : TFhirCodeSystemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCodeSystemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCodeSystemListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCodeSystemListEnumerator.GetCurrent : TFhirCodeSystem;
begin
  Result := FList[FIndex];
end;

function TFhirCodeSystemListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCodeSystemList }

function TFhirCodeSystemList.AddItem(value: TFhirCodeSystem): TFhirCodeSystem;
begin
  assert(value.ClassName = 'TFhirCodeSystem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCodeSystem');
  add(value);
  result := value;
end;

function TFhirCodeSystemList.Append: TFhirCodeSystem;
begin
  result := TFhirCodeSystem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCodeSystemList.ClearItems;
begin
  Clear;
end;

function TFhirCodeSystemList.GetEnumerator : TFhirCodeSystemListEnumerator;
begin
  result := TFhirCodeSystemListEnumerator.Create(self.link);
end;

function TFhirCodeSystemList.Clone: TFhirCodeSystemList;
begin
  result := TFhirCodeSystemList(inherited Clone);
end;

function TFhirCodeSystemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCodeSystemList.GetItemN(index: Integer): TFhirCodeSystem;
begin
  result := TFhirCodeSystem(ObjectByIndex[index]);
end;

function TFhirCodeSystemList.ItemClass: TFslObjectClass;
begin
  result := TFhirCodeSystem;
end;
function TFhirCodeSystemList.IndexOf(value: TFhirCodeSystem): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCodeSystemList.Insert(index: Integer): TFhirCodeSystem;
begin
  result := TFhirCodeSystem.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCodeSystemList.InsertItem(index: Integer; value: TFhirCodeSystem);
begin
  assert(value is TFhirCodeSystem);
  Inherited Insert(index, value);
end;

function TFhirCodeSystemList.Item(index: Integer): TFhirCodeSystem;
begin
  result := TFhirCodeSystem(ObjectByIndex[index]);
end;

function TFhirCodeSystemList.Link: TFhirCodeSystemList;
begin
  result := TFhirCodeSystemList(inherited Link);
end;

procedure TFhirCodeSystemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCodeSystemList.SetItemByIndex(index: Integer; value: TFhirCodeSystem);
begin
  assert(value is TFhirCodeSystem);
  FhirCodeSystems[index] := value;
end;

procedure TFhirCodeSystemList.SetItemN(index: Integer; value: TFhirCodeSystem);
begin
  assert(value is TFhirCodeSystem);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_CODESYSTEM}
{$IFDEF FHIR_COMPARTMENTDEFINITION}
{ TFhirCompartmentDefinitionResource }

constructor TFhirCompartmentDefinitionResource.Create;
begin
  inherited;
end;

destructor TFhirCompartmentDefinitionResource.Destroy;
begin
  FCode.free;
  FParamList.Free;
  FDocumentation.free;
  inherited;
end;

procedure TFhirCompartmentDefinitionResource.Assign(oSource : TFslObject);
begin
  inherited;
  codeElement := TFhirCompartmentDefinitionResource(oSource).codeElement.Clone;
  if (TFhirCompartmentDefinitionResource(oSource).FParamList = nil) then
  begin
    FParamList.free;
    FParamList := nil;
  end
  else
  begin
    if FParamList = nil then
      FParamList := TFhirStringList.Create;
    FParamList.Assign(TFhirCompartmentDefinitionResource(oSource).FParamList);
  end;
  documentationElement := TFhirCompartmentDefinitionResource(oSource).documentationElement.Clone;
end;

procedure TFhirCompartmentDefinitionResource.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'param') Then
    list.addAll(self, 'param', FParamList);
  if (child_name = 'documentation') Then
     list.add(self.link, 'documentation', FDocumentation.Link);
end;

procedure TFhirCompartmentDefinitionResource.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'code', false, TFhirEnum, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'param', 'string', true, TFhirString, FParamList.Link));
  oList.add(TFHIRProperty.create(self, 'documentation', 'string', false, TFhirString, FDocumentation.Link));
end;

function TFhirCompartmentDefinitionResource.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    CodeElement := asEnum(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum, propValue);
    result := propValue;
  end
  else if (propName = 'param') then
  begin
    ParamList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'documentation') then
  begin
    DocumentationElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCompartmentDefinitionResource.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'param') then ParamList.insertItem(index, asString(propValue))
  else inherited;
end;

function TFhirCompartmentDefinitionResource.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirEnum.create(SYSTEMS_TFhirResourceTypesEnum[ResourceTypesNull], CODES_TFhirResourceTypesEnum[ResourceTypesNull]) 
  else if (propName = 'param') then result := ParamList.new()
  else if (propName = 'documentation') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirCompartmentDefinitionResource.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'code'
  else if (propName = 'param') then result := 'string'
  else if (propName = 'documentation') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCompartmentDefinitionResource.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'param') then deletePropertyValue('param', ParamList, value)
  else if (propName = 'documentation') then DocumentationElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCompartmentDefinitionResource.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := asEnum(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum, new)
  else if (propName = 'param') then replacePropertyValue('param', ParamList, existing, new)
  else if (propName = 'documentation') then DocumentationElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCompartmentDefinitionResource.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'param') then ParamList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCompartmentDefinitionResource.fhirType : string;
begin
  result := 'CompartmentDefinition.resource';
end;

function TFhirCompartmentDefinitionResource.Link : TFhirCompartmentDefinitionResource;
begin
  result := TFhirCompartmentDefinitionResource(inherited Link);
end;

function TFhirCompartmentDefinitionResource.Clone : TFhirCompartmentDefinitionResource;
begin
  result := TFhirCompartmentDefinitionResource(inherited Clone);
end;

function TFhirCompartmentDefinitionResource.equals(other : TObject) : boolean; 
var
  o : TFhirCompartmentDefinitionResource;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCompartmentDefinitionResource)) then
    result := false
  else
  begin
    o := TFhirCompartmentDefinitionResource(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(paramList, o.paramList, true) and 
      compareDeep(documentationElement, o.documentationElement, true);
  end;
end;

function TFhirCompartmentDefinitionResource.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FparamList) and isEmptyProp(FDocumentation);
end;

procedure TFhirCompartmentDefinitionResource.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('code');
  fields.add('param');
  fields.add('documentation');
end;

function TFhirCompartmentDefinitionResource.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FParamList.sizeInBytes(magic));
end;

procedure TFhirCompartmentDefinitionResource.SetCode(value : TFhirEnum);
begin
  FCode.free;
  FCode := value;
end;

function TFhirCompartmentDefinitionResource.GetCodeST : TFhirResourceTypesEnum;
begin
  if FCode = nil then
    result := TFhirResourceTypesEnum(0)
  else
    result := TFhirResourceTypesEnum(StringArrayIndexOfSensitive(CODES_TFhirResourceTypesEnum, FCode.value));
end;

procedure TFhirCompartmentDefinitionResource.SetCodeST(value : TFhirResourceTypesEnum);
begin
  if ord(value) = 0 then
    CodeElement := nil
  else
    CodeElement := TFhirEnum.create(SYSTEMS_TFhirResourceTypesEnum[value], CODES_TFhirResourceTypesEnum[value]);
end;

function TFhirCompartmentDefinitionResource.GetParamList : TFhirStringList;
begin
  if FParamList = nil then
    FParamList := TFhirStringList.Create;
  result := FParamList;
end;

function TFhirCompartmentDefinitionResource.GetHasParamList : boolean;
begin
  result := (FParamList <> nil) and (FParamList.count > 0);
end;

procedure TFhirCompartmentDefinitionResource.SetDocumentation(value : TFhirString);
begin
  FDocumentation.free;
  FDocumentation := value;
end;

function TFhirCompartmentDefinitionResource.GetDocumentationST : String;
begin
  if FDocumentation = nil then
    result := ''
  else
    result := FDocumentation.value;
end;

procedure TFhirCompartmentDefinitionResource.SetDocumentationST(value : String);
begin
  if value <> '' then
  begin
    if FDocumentation = nil then
      FDocumentation := TFhirString.create;
    FDocumentation.value := value
  end
  else if FDocumentation <> nil then
    FDocumentation.value := '';
end;

{ TFhirCompartmentDefinitionResourceListEnumerator }

constructor TFhirCompartmentDefinitionResourceListEnumerator.Create(list : TFhirCompartmentDefinitionResourceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCompartmentDefinitionResourceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCompartmentDefinitionResourceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCompartmentDefinitionResourceListEnumerator.GetCurrent : TFhirCompartmentDefinitionResource;
begin
  Result := FList[FIndex];
end;

function TFhirCompartmentDefinitionResourceListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCompartmentDefinitionResourceList }

function TFhirCompartmentDefinitionResourceList.AddItem(value: TFhirCompartmentDefinitionResource): TFhirCompartmentDefinitionResource;
begin
  assert(value.ClassName = 'TFhirCompartmentDefinitionResource', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCompartmentDefinitionResource');
  add(value);
  result := value;
end;

function TFhirCompartmentDefinitionResourceList.Append: TFhirCompartmentDefinitionResource;
begin
  result := TFhirCompartmentDefinitionResource.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCompartmentDefinitionResourceList.ClearItems;
begin
  Clear;
end;

function TFhirCompartmentDefinitionResourceList.GetEnumerator : TFhirCompartmentDefinitionResourceListEnumerator;
begin
  result := TFhirCompartmentDefinitionResourceListEnumerator.Create(self.link);
end;

function TFhirCompartmentDefinitionResourceList.Clone: TFhirCompartmentDefinitionResourceList;
begin
  result := TFhirCompartmentDefinitionResourceList(inherited Clone);
end;

function TFhirCompartmentDefinitionResourceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCompartmentDefinitionResourceList.GetItemN(index: Integer): TFhirCompartmentDefinitionResource;
begin
  result := TFhirCompartmentDefinitionResource(ObjectByIndex[index]);
end;

function TFhirCompartmentDefinitionResourceList.ItemClass: TFslObjectClass;
begin
  result := TFhirCompartmentDefinitionResource;
end;
function TFhirCompartmentDefinitionResourceList.IndexOf(value: TFhirCompartmentDefinitionResource): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCompartmentDefinitionResourceList.Insert(index: Integer): TFhirCompartmentDefinitionResource;
begin
  result := TFhirCompartmentDefinitionResource.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCompartmentDefinitionResourceList.InsertItem(index: Integer; value: TFhirCompartmentDefinitionResource);
begin
  assert(value is TFhirCompartmentDefinitionResource);
  Inherited Insert(index, value);
end;

function TFhirCompartmentDefinitionResourceList.Item(index: Integer): TFhirCompartmentDefinitionResource;
begin
  result := TFhirCompartmentDefinitionResource(ObjectByIndex[index]);
end;

function TFhirCompartmentDefinitionResourceList.Link: TFhirCompartmentDefinitionResourceList;
begin
  result := TFhirCompartmentDefinitionResourceList(inherited Link);
end;

procedure TFhirCompartmentDefinitionResourceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCompartmentDefinitionResourceList.SetItemByIndex(index: Integer; value: TFhirCompartmentDefinitionResource);
begin
  assert(value is TFhirCompartmentDefinitionResource);
  FhirCompartmentDefinitionResources[index] := value;
end;

procedure TFhirCompartmentDefinitionResourceList.SetItemN(index: Integer; value: TFhirCompartmentDefinitionResource);
begin
  assert(value is TFhirCompartmentDefinitionResource);
  ObjectByIndex[index] := value;
end;

{ TFhirCompartmentDefinition }

constructor TFhirCompartmentDefinition.Create;
begin
  inherited;
end;

destructor TFhirCompartmentDefinition.Destroy;
begin
  FUrl.free;
  FVersion.free;
  FName.free;
  FStatus.free;
  FExperimental.free;
  FDate.free;
  FPublisher.free;
  FContactList.Free;
  FDescription.free;
  FUseContextList.Free;
  FPurpose.free;
  FCode.free;
  FSearch.free;
  FResourceList.Free;
  inherited;
end;

procedure TFhirCompartmentDefinition.Assign(oSource : TFslObject);
begin
  inherited;
  urlElement := TFhirCompartmentDefinition(oSource).urlElement.Clone;
  versionElement := TFhirCompartmentDefinition(oSource).versionElement.Clone;
  nameElement := TFhirCompartmentDefinition(oSource).nameElement.Clone;
  statusElement := TFhirCompartmentDefinition(oSource).statusElement.Clone;
  experimentalElement := TFhirCompartmentDefinition(oSource).experimentalElement.Clone;
  dateElement := TFhirCompartmentDefinition(oSource).dateElement.Clone;
  publisherElement := TFhirCompartmentDefinition(oSource).publisherElement.Clone;
  if (TFhirCompartmentDefinition(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirContactDetailList.Create;
    FContactList.Assign(TFhirCompartmentDefinition(oSource).FContactList);
  end;
  descriptionElement := TFhirCompartmentDefinition(oSource).descriptionElement.Clone;
  if (TFhirCompartmentDefinition(oSource).FUseContextList = nil) then
  begin
    FUseContextList.free;
    FUseContextList := nil;
  end
  else
  begin
    if FUseContextList = nil then
      FUseContextList := TFhirUsageContextList.Create;
    FUseContextList.Assign(TFhirCompartmentDefinition(oSource).FUseContextList);
  end;
  purposeElement := TFhirCompartmentDefinition(oSource).purposeElement.Clone;
  codeElement := TFhirCompartmentDefinition(oSource).codeElement.Clone;
  searchElement := TFhirCompartmentDefinition(oSource).searchElement.Clone;
  if (TFhirCompartmentDefinition(oSource).FResourceList = nil) then
  begin
    FResourceList.free;
    FResourceList := nil;
  end
  else
  begin
    if FResourceList = nil then
      FResourceList := TFhirCompartmentDefinitionResourceList.Create;
    FResourceList.Assign(TFhirCompartmentDefinition(oSource).FResourceList);
  end;
end;

function TFhirCompartmentDefinition.GetResourceType : TFhirResourceType;
begin
  result := frtCompartmentDefinition;
end;

procedure TFhirCompartmentDefinition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
  if (child_name = 'version') Then
     list.add(self.link, 'version', FVersion.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'experimental') Then
     list.add(self.link, 'experimental', FExperimental.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'publisher') Then
     list.add(self.link, 'publisher', FPublisher.Link);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'useContext') Then
    list.addAll(self, 'useContext', FUseContextList);
  if (child_name = 'purpose') Then
     list.add(self.link, 'purpose', FPurpose.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'search') Then
     list.add(self.link, 'search', FSearch.Link);
  if (child_name = 'resource') Then
    list.addAll(self, 'resource', FResourceList);
end;

procedure TFhirCompartmentDefinition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'url', 'uri', false, TFhirUri, FUrl.Link));
  oList.add(TFHIRProperty.create(self, 'version', 'string', false, TFhirString, FVersion.Link));
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'experimental', 'boolean', false, TFhirBoolean, FExperimental.Link));
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));
  oList.add(TFHIRProperty.create(self, 'publisher', 'string', false, TFhirString, FPublisher.Link));
  oList.add(TFHIRProperty.create(self, 'contact', 'ContactDetail', true, TFhirContactDetail, FContactList.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'markdown', false, TFhirMarkdown, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'useContext', 'UsageContext', true, TFhirUsageContext, FUseContextList.Link));
  oList.add(TFHIRProperty.create(self, 'purpose', 'markdown', false, TFhirMarkdown, FPurpose.Link));
  oList.add(TFHIRProperty.create(self, 'code', 'code', false, TFhirEnum, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'search', 'boolean', false, TFhirBoolean, FSearch.Link));
  oList.add(TFHIRProperty.create(self, 'resource', 'BackboneElement', true, TFhirCompartmentDefinitionResource, FResourceList.Link));
end;

function TFhirCompartmentDefinition.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'url') then
  begin
    UrlElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'experimental') then
  begin
    ExperimentalElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'publisher') then
  begin
    PublisherElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirContactDetail);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'useContext') then
  begin
    UseContextList.add(propValue as TFhirUsageContext);
    result := propValue;
  end
  else if (propName = 'purpose') then
  begin
    PurposeElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    CodeElement := asEnum(SYSTEMS_TFhirCompartmentTypeEnum, CODES_TFhirCompartmentTypeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'search') then
  begin
    SearchElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'resource') then
  begin
    ResourceList.add(propValue as TFhirCompartmentDefinitionResource);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCompartmentDefinition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirContactDetail)
  else if (propName = 'useContext') then UseContextList.insertItem(index, propValue as TFhirUsageContext)
  else if (propName = 'resource') then ResourceList.insertItem(index, propValue as TFhirCompartmentDefinitionResource)
  else inherited;
end;

function TFhirCompartmentDefinition.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'url') then result := TFhirUri.create()
  else if (propName = 'version') then result := TFhirString.create()
  else if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[PublicationStatusNull], CODES_TFhirPublicationStatusEnum[PublicationStatusNull]) 
  else if (propName = 'experimental') then result := TFhirBoolean.create()
  else if (propName = 'date') then result := TFhirDateTime.create()
  else if (propName = 'publisher') then result := TFhirString.create()
  else if (propName = 'contact') then result := ContactList.new()
  else if (propName = 'description') then result := TFhirMarkdown.create()
  else if (propName = 'useContext') then result := UseContextList.new()
  else if (propName = 'purpose') then result := TFhirMarkdown.create()
  else if (propName = 'code') then result := TFhirEnum.create(SYSTEMS_TFhirCompartmentTypeEnum[CompartmentTypeNull], CODES_TFhirCompartmentTypeEnum[CompartmentTypeNull]) 
  else if (propName = 'search') then result := TFhirBoolean.create()
  else if (propName = 'resource') then result := ResourceList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirCompartmentDefinition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'url') then result := 'uri'
  else if (propName = 'version') then result := 'string'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'experimental') then result := 'boolean'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'publisher') then result := 'string'
  else if (propName = 'contact') then result := 'ContactDetail'
  else if (propName = 'description') then result := 'markdown'
  else if (propName = 'useContext') then result := 'UsageContext'
  else if (propName = 'purpose') then result := 'markdown'
  else if (propName = 'code') then result := 'code'
  else if (propName = 'search') then result := 'boolean'
  else if (propName = 'resource') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCompartmentDefinition.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := nil
  else if (propName = 'version') then VersionElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'experimental') then ExperimentalElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'publisher') then PublisherElement := nil
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value)
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'useContext') then deletePropertyValue('useContext', UseContextList, value)
  else if (propName = 'purpose') then PurposeElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'search') then SearchElement := nil
  else if (propName = 'resource') then deletePropertyValue('resource', ResourceList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCompartmentDefinition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := asUri(new)
  else if (propName = 'version') then VersionElement := asString(new)
  else if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, new)
  else if (propName = 'experimental') then ExperimentalElement := asBoolean(new)
  else if (propName = 'date') then DateElement := asDateTime(new)
  else if (propName = 'publisher') then PublisherElement := asString(new)
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new)
  else if (propName = 'description') then DescriptionElement := asMarkdown(new)
  else if (propName = 'useContext') then replacePropertyValue('useContext', UseContextList, existing, new)
  else if (propName = 'purpose') then PurposeElement := asMarkdown(new)
  else if (propName = 'code') then CodeElement := asEnum(SYSTEMS_TFhirCompartmentTypeEnum, CODES_TFhirCompartmentTypeEnum, new)
  else if (propName = 'search') then SearchElement := asBoolean(new)
  else if (propName = 'resource') then replacePropertyValue('resource', ResourceList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCompartmentDefinition.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'contact') then ContactList.move(source, destination)
  else if (propName = 'useContext') then UseContextList.move(source, destination)
  else if (propName = 'resource') then ResourceList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCompartmentDefinition.fhirType : string;
begin
  result := 'CompartmentDefinition';
end;

function TFhirCompartmentDefinition.Link : TFhirCompartmentDefinition;
begin
  result := TFhirCompartmentDefinition(inherited Link);
end;

function TFhirCompartmentDefinition.Clone : TFhirCompartmentDefinition;
begin
  result := TFhirCompartmentDefinition(inherited Clone);
end;

function TFhirCompartmentDefinition.equals(other : TObject) : boolean; 
var
  o : TFhirCompartmentDefinition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCompartmentDefinition)) then
    result := false
  else
  begin
    o := TFhirCompartmentDefinition(other);
    result := compareDeep(urlElement, o.urlElement, true) and compareDeep(versionElement, o.versionElement, true) and 
      compareDeep(nameElement, o.nameElement, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(experimentalElement, o.experimentalElement, true) and compareDeep(dateElement, o.dateElement, true) and 
      compareDeep(publisherElement, o.publisherElement, true) and compareDeep(contactList, o.contactList, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(useContextList, o.useContextList, true) and 
      compareDeep(purposeElement, o.purposeElement, true) and compareDeep(codeElement, o.codeElement, true) and 
      compareDeep(searchElement, o.searchElement, true) and compareDeep(resourceList, o.resourceList, true);
  end;
end;

function TFhirCompartmentDefinition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FUrl) and isEmptyProp(FVersion) and isEmptyProp(FName) and isEmptyProp(FStatus) and isEmptyProp(FExperimental) and isEmptyProp(FDate) and isEmptyProp(FPublisher) and isEmptyProp(FcontactList) and isEmptyProp(FDescription) and isEmptyProp(FuseContextList) and isEmptyProp(FPurpose) and isEmptyProp(FCode) and isEmptyProp(FSearch) and isEmptyProp(FresourceList);
end;

procedure TFhirCompartmentDefinition.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('url');
  fields.add('version');
  fields.add('name');
  fields.add('status');
  fields.add('experimental');
  fields.add('date');
  fields.add('publisher');
  fields.add('contact');
  fields.add('description');
  fields.add('useContext');
  fields.add('purpose');
  fields.add('code');
  fields.add('search');
  fields.add('resource');
end;

function TFhirCompartmentDefinition.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FContactList.sizeInBytes(magic));
  inc(result, FUseContextList.sizeInBytes(magic));
  inc(result, FResourceList.sizeInBytes(magic));
end;

procedure TFhirCompartmentDefinition.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

function TFhirCompartmentDefinition.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

procedure TFhirCompartmentDefinition.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

procedure TFhirCompartmentDefinition.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

function TFhirCompartmentDefinition.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

procedure TFhirCompartmentDefinition.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

procedure TFhirCompartmentDefinition.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirCompartmentDefinition.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirCompartmentDefinition.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirCompartmentDefinition.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirCompartmentDefinition.GetStatusST : TFhirPublicationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirPublicationStatusEnum(0)
  else
    result := TFhirPublicationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirPublicationStatusEnum, FStatus.value));
end;

procedure TFhirCompartmentDefinition.SetStatusST(value : TFhirPublicationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[value], CODES_TFhirPublicationStatusEnum[value]);
end;

procedure TFhirCompartmentDefinition.SetExperimental(value : TFhirBoolean);
begin
  FExperimental.free;
  FExperimental := value;
end;

function TFhirCompartmentDefinition.GetExperimentalST : Boolean;
begin
  if FExperimental = nil then
    result := false
  else
    result := FExperimental.value;
end;

procedure TFhirCompartmentDefinition.SetExperimentalST(value : Boolean);
begin
  if FExperimental = nil then
    FExperimental := TFhirBoolean.create;
  FExperimental.value := value
end;

procedure TFhirCompartmentDefinition.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

function TFhirCompartmentDefinition.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirCompartmentDefinition.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

procedure TFhirCompartmentDefinition.SetPublisher(value : TFhirString);
begin
  FPublisher.free;
  FPublisher := value;
end;

function TFhirCompartmentDefinition.GetPublisherST : String;
begin
  if FPublisher = nil then
    result := ''
  else
    result := FPublisher.value;
end;

procedure TFhirCompartmentDefinition.SetPublisherST(value : String);
begin
  if value <> '' then
  begin
    if FPublisher = nil then
      FPublisher := TFhirString.create;
    FPublisher.value := value
  end
  else if FPublisher <> nil then
    FPublisher.value := '';
end;

function TFhirCompartmentDefinition.GetContactList : TFhirContactDetailList;
begin
  if FContactList = nil then
    FContactList := TFhirContactDetailList.Create;
  result := FContactList;
end;

function TFhirCompartmentDefinition.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

procedure TFhirCompartmentDefinition.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirCompartmentDefinition.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirCompartmentDefinition.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirCompartmentDefinition.GetUseContextList : TFhirUsageContextList;
begin
  if FUseContextList = nil then
    FUseContextList := TFhirUsageContextList.Create;
  result := FUseContextList;
end;

function TFhirCompartmentDefinition.GetHasUseContextList : boolean;
begin
  result := (FUseContextList <> nil) and (FUseContextList.count > 0);
end;

procedure TFhirCompartmentDefinition.SetPurpose(value : TFhirMarkdown);
begin
  FPurpose.free;
  FPurpose := value;
end;

function TFhirCompartmentDefinition.GetPurposeST : String;
begin
  if FPurpose = nil then
    result := ''
  else
    result := FPurpose.value;
end;

procedure TFhirCompartmentDefinition.SetPurposeST(value : String);
begin
  if value <> '' then
  begin
    if FPurpose = nil then
      FPurpose := TFhirMarkdown.create;
    FPurpose.value := value
  end
  else if FPurpose <> nil then
    FPurpose.value := '';
end;

procedure TFhirCompartmentDefinition.SetCode(value : TFhirEnum);
begin
  FCode.free;
  FCode := value;
end;

function TFhirCompartmentDefinition.GetCodeST : TFhirCompartmentTypeEnum;
begin
  if FCode = nil then
    result := TFhirCompartmentTypeEnum(0)
  else
    result := TFhirCompartmentTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirCompartmentTypeEnum, FCode.value));
end;

procedure TFhirCompartmentDefinition.SetCodeST(value : TFhirCompartmentTypeEnum);
begin
  if ord(value) = 0 then
    CodeElement := nil
  else
    CodeElement := TFhirEnum.create(SYSTEMS_TFhirCompartmentTypeEnum[value], CODES_TFhirCompartmentTypeEnum[value]);
end;

procedure TFhirCompartmentDefinition.SetSearch(value : TFhirBoolean);
begin
  FSearch.free;
  FSearch := value;
end;

function TFhirCompartmentDefinition.GetSearchST : Boolean;
begin
  if FSearch = nil then
    result := false
  else
    result := FSearch.value;
end;

procedure TFhirCompartmentDefinition.SetSearchST(value : Boolean);
begin
  if FSearch = nil then
    FSearch := TFhirBoolean.create;
  FSearch.value := value
end;

function TFhirCompartmentDefinition.GetResourceList : TFhirCompartmentDefinitionResourceList;
begin
  if FResourceList = nil then
    FResourceList := TFhirCompartmentDefinitionResourceList.Create;
  result := FResourceList;
end;

function TFhirCompartmentDefinition.GetHasResourceList : boolean;
begin
  result := (FResourceList <> nil) and (FResourceList.count > 0);
end;

{ TFhirCompartmentDefinitionListEnumerator }

constructor TFhirCompartmentDefinitionListEnumerator.Create(list : TFhirCompartmentDefinitionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCompartmentDefinitionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCompartmentDefinitionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCompartmentDefinitionListEnumerator.GetCurrent : TFhirCompartmentDefinition;
begin
  Result := FList[FIndex];
end;

function TFhirCompartmentDefinitionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCompartmentDefinitionList }

function TFhirCompartmentDefinitionList.AddItem(value: TFhirCompartmentDefinition): TFhirCompartmentDefinition;
begin
  assert(value.ClassName = 'TFhirCompartmentDefinition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCompartmentDefinition');
  add(value);
  result := value;
end;

function TFhirCompartmentDefinitionList.Append: TFhirCompartmentDefinition;
begin
  result := TFhirCompartmentDefinition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCompartmentDefinitionList.ClearItems;
begin
  Clear;
end;

function TFhirCompartmentDefinitionList.GetEnumerator : TFhirCompartmentDefinitionListEnumerator;
begin
  result := TFhirCompartmentDefinitionListEnumerator.Create(self.link);
end;

function TFhirCompartmentDefinitionList.Clone: TFhirCompartmentDefinitionList;
begin
  result := TFhirCompartmentDefinitionList(inherited Clone);
end;

function TFhirCompartmentDefinitionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCompartmentDefinitionList.GetItemN(index: Integer): TFhirCompartmentDefinition;
begin
  result := TFhirCompartmentDefinition(ObjectByIndex[index]);
end;

function TFhirCompartmentDefinitionList.ItemClass: TFslObjectClass;
begin
  result := TFhirCompartmentDefinition;
end;
function TFhirCompartmentDefinitionList.IndexOf(value: TFhirCompartmentDefinition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCompartmentDefinitionList.Insert(index: Integer): TFhirCompartmentDefinition;
begin
  result := TFhirCompartmentDefinition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCompartmentDefinitionList.InsertItem(index: Integer; value: TFhirCompartmentDefinition);
begin
  assert(value is TFhirCompartmentDefinition);
  Inherited Insert(index, value);
end;

function TFhirCompartmentDefinitionList.Item(index: Integer): TFhirCompartmentDefinition;
begin
  result := TFhirCompartmentDefinition(ObjectByIndex[index]);
end;

function TFhirCompartmentDefinitionList.Link: TFhirCompartmentDefinitionList;
begin
  result := TFhirCompartmentDefinitionList(inherited Link);
end;

procedure TFhirCompartmentDefinitionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCompartmentDefinitionList.SetItemByIndex(index: Integer; value: TFhirCompartmentDefinition);
begin
  assert(value is TFhirCompartmentDefinition);
  FhirCompartmentDefinitions[index] := value;
end;

procedure TFhirCompartmentDefinitionList.SetItemN(index: Integer; value: TFhirCompartmentDefinition);
begin
  assert(value is TFhirCompartmentDefinition);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_COMPARTMENTDEFINITION}
{$IFDEF FHIR_CONCEPTMAP}
{ TFhirConceptMapGroup }

constructor TFhirConceptMapGroup.Create;
begin
  inherited;
end;

destructor TFhirConceptMapGroup.Destroy;
begin
  FSource.free;
  FSourceVersion.free;
  FTarget.free;
  FTargetVersion.free;
  FElementList.Free;
  FUnmapped.free;
  inherited;
end;

procedure TFhirConceptMapGroup.Assign(oSource : TFslObject);
begin
  inherited;
  sourceElement := TFhirConceptMapGroup(oSource).sourceElement.Clone;
  sourceVersionElement := TFhirConceptMapGroup(oSource).sourceVersionElement.Clone;
  targetElement := TFhirConceptMapGroup(oSource).targetElement.Clone;
  targetVersionElement := TFhirConceptMapGroup(oSource).targetVersionElement.Clone;
  if (TFhirConceptMapGroup(oSource).FElementList = nil) then
  begin
    FElementList.free;
    FElementList := nil;
  end
  else
  begin
    if FElementList = nil then
      FElementList := TFhirConceptMapGroupElementList.Create;
    FElementList.Assign(TFhirConceptMapGroup(oSource).FElementList);
  end;
  unmapped := TFhirConceptMapGroup(oSource).unmapped.Clone;
end;

procedure TFhirConceptMapGroup.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'source') Then
     list.add(self.link, 'source', FSource.Link);
  if (child_name = 'sourceVersion') Then
     list.add(self.link, 'sourceVersion', FSourceVersion.Link);
  if (child_name = 'target') Then
     list.add(self.link, 'target', FTarget.Link);
  if (child_name = 'targetVersion') Then
     list.add(self.link, 'targetVersion', FTargetVersion.Link);
  if (child_name = 'element') Then
    list.addAll(self, 'element', FElementList);
  if (child_name = 'unmapped') Then
     list.add(self.link, 'unmapped', FUnmapped.Link);
end;

procedure TFhirConceptMapGroup.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'source', 'uri', false, TFhirUri, FSource.Link));
  oList.add(TFHIRProperty.create(self, 'sourceVersion', 'string', false, TFhirString, FSourceVersion.Link));
  oList.add(TFHIRProperty.create(self, 'target', 'uri', false, TFhirUri, FTarget.Link));
  oList.add(TFHIRProperty.create(self, 'targetVersion', 'string', false, TFhirString, FTargetVersion.Link));
  oList.add(TFHIRProperty.create(self, 'element', 'BackboneElement', true, TFhirConceptMapGroupElement, FElementList.Link));
  oList.add(TFHIRProperty.create(self, 'unmapped', 'BackboneElement', false, TFhirConceptMapGroupUnmapped, FUnmapped.Link));
end;

function TFhirConceptMapGroup.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'source') then
  begin
    SourceElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'sourceVersion') then
  begin
    SourceVersionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'target') then
  begin
    TargetElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'targetVersion') then
  begin
    TargetVersionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'element') then
  begin
    ElementList.add(propValue as TFhirConceptMapGroupElement);
    result := propValue;
  end
  else if (propName = 'unmapped') then
  begin
    Unmapped := propValue as TFhirConceptMapGroupUnmapped;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirConceptMapGroup.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'element') then ElementList.insertItem(index, propValue as TFhirConceptMapGroupElement)
  else inherited;
end;

function TFhirConceptMapGroup.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'source') then result := TFhirUri.create()
  else if (propName = 'sourceVersion') then result := TFhirString.create()
  else if (propName = 'target') then result := TFhirUri.create()
  else if (propName = 'targetVersion') then result := TFhirString.create()
  else if (propName = 'element') then result := ElementList.new()
  else if (propName = 'unmapped') then result := TFhirConceptMapGroupUnmapped.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirConceptMapGroup.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'source') then result := 'uri'
  else if (propName = 'sourceVersion') then result := 'string'
  else if (propName = 'target') then result := 'uri'
  else if (propName = 'targetVersion') then result := 'string'
  else if (propName = 'element') then result := 'BackboneElement'
  else if (propName = 'unmapped') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirConceptMapGroup.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'source') then SourceElement := nil
  else if (propName = 'sourceVersion') then SourceVersionElement := nil
  else if (propName = 'target') then TargetElement := nil
  else if (propName = 'targetVersion') then TargetVersionElement := nil
  else if (propName = 'element') then deletePropertyValue('element', ElementList, value)
  else if (propName = 'unmapped') then UnmappedElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirConceptMapGroup.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'source') then SourceElement := asUri(new)
  else if (propName = 'sourceVersion') then SourceVersionElement := asString(new)
  else if (propName = 'target') then TargetElement := asUri(new)
  else if (propName = 'targetVersion') then TargetVersionElement := asString(new)
  else if (propName = 'element') then replacePropertyValue('element', ElementList, existing, new)
  else if (propName = 'unmapped') then UnmappedElement := new as TFhirConceptMapGroupUnmapped
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirConceptMapGroup.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'element') then ElementList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirConceptMapGroup.fhirType : string;
begin
  result := 'ConceptMap.group';
end;

function TFhirConceptMapGroup.Link : TFhirConceptMapGroup;
begin
  result := TFhirConceptMapGroup(inherited Link);
end;

function TFhirConceptMapGroup.Clone : TFhirConceptMapGroup;
begin
  result := TFhirConceptMapGroup(inherited Clone);
end;

function TFhirConceptMapGroup.equals(other : TObject) : boolean; 
var
  o : TFhirConceptMapGroup;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirConceptMapGroup)) then
    result := false
  else
  begin
    o := TFhirConceptMapGroup(other);
    result := compareDeep(sourceElement, o.sourceElement, true) and compareDeep(sourceVersionElement, o.sourceVersionElement, true) and 
      compareDeep(targetElement, o.targetElement, true) and compareDeep(targetVersionElement, o.targetVersionElement, true) and 
      compareDeep(elementList, o.elementList, true) and compareDeep(unmappedElement, o.unmappedElement, true);
  end;
end;

function TFhirConceptMapGroup.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSource) and isEmptyProp(FSourceVersion) and isEmptyProp(FTarget) and isEmptyProp(FTargetVersion) and isEmptyProp(FelementList) and isEmptyProp(FUnmapped);
end;

procedure TFhirConceptMapGroup.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('source');
  fields.add('sourceVersion');
  fields.add('target');
  fields.add('targetVersion');
  fields.add('element');
  fields.add('unmapped');
end;

function TFhirConceptMapGroup.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FElementList.sizeInBytes(magic));
end;

procedure TFhirConceptMapGroup.SetSource(value : TFhirUri);
begin
  FSource.free;
  FSource := value;
end;

function TFhirConceptMapGroup.GetSourceST : String;
begin
  if FSource = nil then
    result := ''
  else
    result := FSource.value;
end;

procedure TFhirConceptMapGroup.SetSourceST(value : String);
begin
  if value <> '' then
  begin
    if FSource = nil then
      FSource := TFhirUri.create;
    FSource.value := value
  end
  else if FSource <> nil then
    FSource.value := '';
end;

procedure TFhirConceptMapGroup.SetSourceVersion(value : TFhirString);
begin
  FSourceVersion.free;
  FSourceVersion := value;
end;

function TFhirConceptMapGroup.GetSourceVersionST : String;
begin
  if FSourceVersion = nil then
    result := ''
  else
    result := FSourceVersion.value;
end;

procedure TFhirConceptMapGroup.SetSourceVersionST(value : String);
begin
  if value <> '' then
  begin
    if FSourceVersion = nil then
      FSourceVersion := TFhirString.create;
    FSourceVersion.value := value
  end
  else if FSourceVersion <> nil then
    FSourceVersion.value := '';
end;

procedure TFhirConceptMapGroup.SetTarget(value : TFhirUri);
begin
  FTarget.free;
  FTarget := value;
end;

function TFhirConceptMapGroup.GetTargetST : String;
begin
  if FTarget = nil then
    result := ''
  else
    result := FTarget.value;
end;

procedure TFhirConceptMapGroup.SetTargetST(value : String);
begin
  if value <> '' then
  begin
    if FTarget = nil then
      FTarget := TFhirUri.create;
    FTarget.value := value
  end
  else if FTarget <> nil then
    FTarget.value := '';
end;

procedure TFhirConceptMapGroup.SetTargetVersion(value : TFhirString);
begin
  FTargetVersion.free;
  FTargetVersion := value;
end;

function TFhirConceptMapGroup.GetTargetVersionST : String;
begin
  if FTargetVersion = nil then
    result := ''
  else
    result := FTargetVersion.value;
end;

procedure TFhirConceptMapGroup.SetTargetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FTargetVersion = nil then
      FTargetVersion := TFhirString.create;
    FTargetVersion.value := value
  end
  else if FTargetVersion <> nil then
    FTargetVersion.value := '';
end;

function TFhirConceptMapGroup.GetElementList : TFhirConceptMapGroupElementList;
begin
  if FElementList = nil then
    FElementList := TFhirConceptMapGroupElementList.Create;
  result := FElementList;
end;

function TFhirConceptMapGroup.GetHasElementList : boolean;
begin
  result := (FElementList <> nil) and (FElementList.count > 0);
end;

procedure TFhirConceptMapGroup.SetUnmapped(value : TFhirConceptMapGroupUnmapped);
begin
  FUnmapped.free;
  FUnmapped := value;
end;

{ TFhirConceptMapGroupListEnumerator }

constructor TFhirConceptMapGroupListEnumerator.Create(list : TFhirConceptMapGroupList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirConceptMapGroupListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConceptMapGroupListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirConceptMapGroupListEnumerator.GetCurrent : TFhirConceptMapGroup;
begin
  Result := FList[FIndex];
end;

function TFhirConceptMapGroupListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirConceptMapGroupList }

function TFhirConceptMapGroupList.AddItem(value: TFhirConceptMapGroup): TFhirConceptMapGroup;
begin
  assert(value.ClassName = 'TFhirConceptMapGroup', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConceptMapGroup');
  add(value);
  result := value;
end;

function TFhirConceptMapGroupList.Append: TFhirConceptMapGroup;
begin
  result := TFhirConceptMapGroup.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConceptMapGroupList.ClearItems;
begin
  Clear;
end;

function TFhirConceptMapGroupList.GetEnumerator : TFhirConceptMapGroupListEnumerator;
begin
  result := TFhirConceptMapGroupListEnumerator.Create(self.link);
end;

function TFhirConceptMapGroupList.Clone: TFhirConceptMapGroupList;
begin
  result := TFhirConceptMapGroupList(inherited Clone);
end;

function TFhirConceptMapGroupList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConceptMapGroupList.GetItemN(index: Integer): TFhirConceptMapGroup;
begin
  result := TFhirConceptMapGroup(ObjectByIndex[index]);
end;

function TFhirConceptMapGroupList.ItemClass: TFslObjectClass;
begin
  result := TFhirConceptMapGroup;
end;
function TFhirConceptMapGroupList.IndexOf(value: TFhirConceptMapGroup): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirConceptMapGroupList.Insert(index: Integer): TFhirConceptMapGroup;
begin
  result := TFhirConceptMapGroup.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConceptMapGroupList.InsertItem(index: Integer; value: TFhirConceptMapGroup);
begin
  assert(value is TFhirConceptMapGroup);
  Inherited Insert(index, value);
end;

function TFhirConceptMapGroupList.Item(index: Integer): TFhirConceptMapGroup;
begin
  result := TFhirConceptMapGroup(ObjectByIndex[index]);
end;

function TFhirConceptMapGroupList.Link: TFhirConceptMapGroupList;
begin
  result := TFhirConceptMapGroupList(inherited Link);
end;

procedure TFhirConceptMapGroupList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConceptMapGroupList.SetItemByIndex(index: Integer; value: TFhirConceptMapGroup);
begin
  assert(value is TFhirConceptMapGroup);
  FhirConceptMapGroups[index] := value;
end;

procedure TFhirConceptMapGroupList.SetItemN(index: Integer; value: TFhirConceptMapGroup);
begin
  assert(value is TFhirConceptMapGroup);
  ObjectByIndex[index] := value;
end;

{ TFhirConceptMapGroupElement }

constructor TFhirConceptMapGroupElement.Create;
begin
  inherited;
end;

destructor TFhirConceptMapGroupElement.Destroy;
begin
  FCode.free;
  FDisplay.free;
  FTargetList.Free;
  inherited;
end;

procedure TFhirConceptMapGroupElement.Assign(oSource : TFslObject);
begin
  inherited;
  codeElement := TFhirConceptMapGroupElement(oSource).codeElement.Clone;
  displayElement := TFhirConceptMapGroupElement(oSource).displayElement.Clone;
  if (TFhirConceptMapGroupElement(oSource).FTargetList = nil) then
  begin
    FTargetList.free;
    FTargetList := nil;
  end
  else
  begin
    if FTargetList = nil then
      FTargetList := TFhirConceptMapGroupElementTargetList.Create;
    FTargetList.Assign(TFhirConceptMapGroupElement(oSource).FTargetList);
  end;
end;

procedure TFhirConceptMapGroupElement.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'display') Then
     list.add(self.link, 'display', FDisplay.Link);
  if (child_name = 'target') Then
    list.addAll(self, 'target', FTargetList);
end;

procedure TFhirConceptMapGroupElement.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'code', false, TFhirCode, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'display', 'string', false, TFhirString, FDisplay.Link));
  oList.add(TFHIRProperty.create(self, 'target', 'BackboneElement', true, TFhirConceptMapGroupElementTarget, FTargetList.Link));
end;

function TFhirConceptMapGroupElement.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    CodeElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'display') then
  begin
    DisplayElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'target') then
  begin
    TargetList.add(propValue as TFhirConceptMapGroupElementTarget);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirConceptMapGroupElement.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'target') then TargetList.insertItem(index, propValue as TFhirConceptMapGroupElementTarget)
  else inherited;
end;

function TFhirConceptMapGroupElement.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCode.create()
  else if (propName = 'display') then result := TFhirString.create()
  else if (propName = 'target') then result := TargetList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirConceptMapGroupElement.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'code'
  else if (propName = 'display') then result := 'string'
  else if (propName = 'target') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirConceptMapGroupElement.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'display') then DisplayElement := nil
  else if (propName = 'target') then deletePropertyValue('target', TargetList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirConceptMapGroupElement.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := asCode(new)
  else if (propName = 'display') then DisplayElement := asString(new)
  else if (propName = 'target') then replacePropertyValue('target', TargetList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirConceptMapGroupElement.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'target') then TargetList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirConceptMapGroupElement.fhirType : string;
begin
  result := 'ConceptMap.group.element';
end;

function TFhirConceptMapGroupElement.Link : TFhirConceptMapGroupElement;
begin
  result := TFhirConceptMapGroupElement(inherited Link);
end;

function TFhirConceptMapGroupElement.Clone : TFhirConceptMapGroupElement;
begin
  result := TFhirConceptMapGroupElement(inherited Clone);
end;

function TFhirConceptMapGroupElement.equals(other : TObject) : boolean; 
var
  o : TFhirConceptMapGroupElement;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirConceptMapGroupElement)) then
    result := false
  else
  begin
    o := TFhirConceptMapGroupElement(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(displayElement, o.displayElement, true) and 
      compareDeep(targetList, o.targetList, true);
  end;
end;

function TFhirConceptMapGroupElement.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FDisplay) and isEmptyProp(FtargetList);
end;

procedure TFhirConceptMapGroupElement.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('code');
  fields.add('display');
  fields.add('target');
end;

function TFhirConceptMapGroupElement.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FTargetList.sizeInBytes(magic));
end;

procedure TFhirConceptMapGroupElement.SetCode(value : TFhirCode);
begin
  FCode.free;
  FCode := value;
end;

function TFhirConceptMapGroupElement.GetCodeST : String;
begin
  if FCode = nil then
    result := ''
  else
    result := FCode.value;
end;

procedure TFhirConceptMapGroupElement.SetCodeST(value : String);
begin
  if value <> '' then
  begin
    if FCode = nil then
      FCode := TFhirCode.create;
    FCode.value := value
  end
  else if FCode <> nil then
    FCode.value := '';
end;

procedure TFhirConceptMapGroupElement.SetDisplay(value : TFhirString);
begin
  FDisplay.free;
  FDisplay := value;
end;

function TFhirConceptMapGroupElement.GetDisplayST : String;
begin
  if FDisplay = nil then
    result := ''
  else
    result := FDisplay.value;
end;

procedure TFhirConceptMapGroupElement.SetDisplayST(value : String);
begin
  if value <> '' then
  begin
    if FDisplay = nil then
      FDisplay := TFhirString.create;
    FDisplay.value := value
  end
  else if FDisplay <> nil then
    FDisplay.value := '';
end;

function TFhirConceptMapGroupElement.GetTargetList : TFhirConceptMapGroupElementTargetList;
begin
  if FTargetList = nil then
    FTargetList := TFhirConceptMapGroupElementTargetList.Create;
  result := FTargetList;
end;

function TFhirConceptMapGroupElement.GetHasTargetList : boolean;
begin
  result := (FTargetList <> nil) and (FTargetList.count > 0);
end;

{ TFhirConceptMapGroupElementListEnumerator }

constructor TFhirConceptMapGroupElementListEnumerator.Create(list : TFhirConceptMapGroupElementList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirConceptMapGroupElementListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConceptMapGroupElementListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirConceptMapGroupElementListEnumerator.GetCurrent : TFhirConceptMapGroupElement;
begin
  Result := FList[FIndex];
end;

function TFhirConceptMapGroupElementListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirConceptMapGroupElementList }

function TFhirConceptMapGroupElementList.AddItem(value: TFhirConceptMapGroupElement): TFhirConceptMapGroupElement;
begin
  assert(value.ClassName = 'TFhirConceptMapGroupElement', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConceptMapGroupElement');
  add(value);
  result := value;
end;

function TFhirConceptMapGroupElementList.Append: TFhirConceptMapGroupElement;
begin
  result := TFhirConceptMapGroupElement.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConceptMapGroupElementList.ClearItems;
begin
  Clear;
end;

function TFhirConceptMapGroupElementList.GetEnumerator : TFhirConceptMapGroupElementListEnumerator;
begin
  result := TFhirConceptMapGroupElementListEnumerator.Create(self.link);
end;

function TFhirConceptMapGroupElementList.Clone: TFhirConceptMapGroupElementList;
begin
  result := TFhirConceptMapGroupElementList(inherited Clone);
end;

function TFhirConceptMapGroupElementList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConceptMapGroupElementList.GetItemN(index: Integer): TFhirConceptMapGroupElement;
begin
  result := TFhirConceptMapGroupElement(ObjectByIndex[index]);
end;

function TFhirConceptMapGroupElementList.ItemClass: TFslObjectClass;
begin
  result := TFhirConceptMapGroupElement;
end;
function TFhirConceptMapGroupElementList.IndexOf(value: TFhirConceptMapGroupElement): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirConceptMapGroupElementList.Insert(index: Integer): TFhirConceptMapGroupElement;
begin
  result := TFhirConceptMapGroupElement.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConceptMapGroupElementList.InsertItem(index: Integer; value: TFhirConceptMapGroupElement);
begin
  assert(value is TFhirConceptMapGroupElement);
  Inherited Insert(index, value);
end;

function TFhirConceptMapGroupElementList.Item(index: Integer): TFhirConceptMapGroupElement;
begin
  result := TFhirConceptMapGroupElement(ObjectByIndex[index]);
end;

function TFhirConceptMapGroupElementList.Link: TFhirConceptMapGroupElementList;
begin
  result := TFhirConceptMapGroupElementList(inherited Link);
end;

procedure TFhirConceptMapGroupElementList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConceptMapGroupElementList.SetItemByIndex(index: Integer; value: TFhirConceptMapGroupElement);
begin
  assert(value is TFhirConceptMapGroupElement);
  FhirConceptMapGroupElements[index] := value;
end;

procedure TFhirConceptMapGroupElementList.SetItemN(index: Integer; value: TFhirConceptMapGroupElement);
begin
  assert(value is TFhirConceptMapGroupElement);
  ObjectByIndex[index] := value;
end;

{ TFhirConceptMapGroupElementTarget }

constructor TFhirConceptMapGroupElementTarget.Create;
begin
  inherited;
end;

destructor TFhirConceptMapGroupElementTarget.Destroy;
begin
  FCode.free;
  FDisplay.free;
  FEquivalence.free;
  FComment.free;
  FDependsOnList.Free;
  FProductList.Free;
  inherited;
end;

procedure TFhirConceptMapGroupElementTarget.Assign(oSource : TFslObject);
begin
  inherited;
  codeElement := TFhirConceptMapGroupElementTarget(oSource).codeElement.Clone;
  displayElement := TFhirConceptMapGroupElementTarget(oSource).displayElement.Clone;
  equivalenceElement := TFhirConceptMapGroupElementTarget(oSource).equivalenceElement.Clone;
  commentElement := TFhirConceptMapGroupElementTarget(oSource).commentElement.Clone;
  if (TFhirConceptMapGroupElementTarget(oSource).FDependsOnList = nil) then
  begin
    FDependsOnList.free;
    FDependsOnList := nil;
  end
  else
  begin
    if FDependsOnList = nil then
      FDependsOnList := TFhirConceptMapGroupElementTargetDependsOnList.Create;
    FDependsOnList.Assign(TFhirConceptMapGroupElementTarget(oSource).FDependsOnList);
  end;
  if (TFhirConceptMapGroupElementTarget(oSource).FProductList = nil) then
  begin
    FProductList.free;
    FProductList := nil;
  end
  else
  begin
    if FProductList = nil then
      FProductList := TFhirConceptMapGroupElementTargetDependsOnList.Create;
    FProductList.Assign(TFhirConceptMapGroupElementTarget(oSource).FProductList);
  end;
end;

procedure TFhirConceptMapGroupElementTarget.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'display') Then
     list.add(self.link, 'display', FDisplay.Link);
  if (child_name = 'equivalence') Then
     list.add(self.link, 'equivalence', FEquivalence.Link);
  if (child_name = 'comment') Then
     list.add(self.link, 'comment', FComment.Link);
  if (child_name = 'dependsOn') Then
    list.addAll(self, 'dependsOn', FDependsOnList);
  if (child_name = 'product') Then
    list.addAll(self, 'product', FProductList);
end;

procedure TFhirConceptMapGroupElementTarget.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'code', false, TFhirCode, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'display', 'string', false, TFhirString, FDisplay.Link));
  oList.add(TFHIRProperty.create(self, 'equivalence', 'code', false, TFhirEnum, FEquivalence.Link));
  oList.add(TFHIRProperty.create(self, 'comment', 'string', false, TFhirString, FComment.Link));
  oList.add(TFHIRProperty.create(self, 'dependsOn', 'BackboneElement', true, TFhirConceptMapGroupElementTargetDependsOn, FDependsOnList.Link));
  oList.add(TFHIRProperty.create(self, 'product', '', true, TFhirConceptMapGroupElementTargetDependsOn, FProductList.Link));
end;

function TFhirConceptMapGroupElementTarget.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    CodeElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'display') then
  begin
    DisplayElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'equivalence') then
  begin
    EquivalenceElement := asEnum(SYSTEMS_TFhirConceptMapEquivalenceEnum, CODES_TFhirConceptMapEquivalenceEnum, propValue);
    result := propValue;
  end
  else if (propName = 'comment') then
  begin
    CommentElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'dependsOn') then
  begin
    DependsOnList.add(propValue as TFhirConceptMapGroupElementTargetDependsOn);
    result := propValue;
  end
  else if (propName = 'product') then
  begin
    ProductList.add(propValue as TFhirConceptMapGroupElementTargetDependsOn);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirConceptMapGroupElementTarget.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'dependsOn') then DependsOnList.insertItem(index, propValue as TFhirConceptMapGroupElementTargetDependsOn)
  else if (propName = 'product') then ProductList.insertItem(index, propValue as TFhirConceptMapGroupElementTargetDependsOn)
  else inherited;
end;

function TFhirConceptMapGroupElementTarget.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCode.create()
  else if (propName = 'display') then result := TFhirString.create()
  else if (propName = 'equivalence') then result := TFhirEnum.create(SYSTEMS_TFhirConceptMapEquivalenceEnum[ConceptMapEquivalenceNull], CODES_TFhirConceptMapEquivalenceEnum[ConceptMapEquivalenceNull]) 
  else if (propName = 'comment') then result := TFhirString.create()
  else if (propName = 'dependsOn') then result := DependsOnList.new()
  else if (propName = 'product') then result := ProductList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirConceptMapGroupElementTarget.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'code'
  else if (propName = 'display') then result := 'string'
  else if (propName = 'equivalence') then result := 'code'
  else if (propName = 'comment') then result := 'string'
  else if (propName = 'dependsOn') then result := 'BackboneElement'
  else if (propName = 'product') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirConceptMapGroupElementTarget.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'display') then DisplayElement := nil
  else if (propName = 'equivalence') then EquivalenceElement := nil
  else if (propName = 'comment') then CommentElement := nil
  else if (propName = 'dependsOn') then deletePropertyValue('dependsOn', DependsOnList, value)
  else if (propName = 'product') then deletePropertyValue('product', ProductList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirConceptMapGroupElementTarget.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := asCode(new)
  else if (propName = 'display') then DisplayElement := asString(new)
  else if (propName = 'equivalence') then EquivalenceElement := asEnum(SYSTEMS_TFhirConceptMapEquivalenceEnum, CODES_TFhirConceptMapEquivalenceEnum, new)
  else if (propName = 'comment') then CommentElement := asString(new)
  else if (propName = 'dependsOn') then replacePropertyValue('dependsOn', DependsOnList, existing, new)
  else if (propName = 'product') then replacePropertyValue('product', ProductList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirConceptMapGroupElementTarget.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'dependsOn') then DependsOnList.move(source, destination)
  else if (propName = 'product') then ProductList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirConceptMapGroupElementTarget.fhirType : string;
begin
  result := 'ConceptMap.group.element.target';
end;

function TFhirConceptMapGroupElementTarget.Link : TFhirConceptMapGroupElementTarget;
begin
  result := TFhirConceptMapGroupElementTarget(inherited Link);
end;

function TFhirConceptMapGroupElementTarget.Clone : TFhirConceptMapGroupElementTarget;
begin
  result := TFhirConceptMapGroupElementTarget(inherited Clone);
end;

function TFhirConceptMapGroupElementTarget.equals(other : TObject) : boolean; 
var
  o : TFhirConceptMapGroupElementTarget;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirConceptMapGroupElementTarget)) then
    result := false
  else
  begin
    o := TFhirConceptMapGroupElementTarget(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(displayElement, o.displayElement, true) and 
      compareDeep(equivalenceElement, o.equivalenceElement, true) and compareDeep(commentElement, o.commentElement, true) and 
      compareDeep(dependsOnList, o.dependsOnList, true) and compareDeep(productList, o.productList, true);
  end;
end;

function TFhirConceptMapGroupElementTarget.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FDisplay) and isEmptyProp(FEquivalence) and isEmptyProp(FComment) and isEmptyProp(FdependsOnList) and isEmptyProp(FproductList);
end;

procedure TFhirConceptMapGroupElementTarget.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('code');
  fields.add('display');
  fields.add('equivalence');
  fields.add('comment');
  fields.add('dependsOn');
  fields.add('product');
end;

function TFhirConceptMapGroupElementTarget.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FDependsOnList.sizeInBytes(magic));
  inc(result, FProductList.sizeInBytes(magic));
end;

procedure TFhirConceptMapGroupElementTarget.SetCode(value : TFhirCode);
begin
  FCode.free;
  FCode := value;
end;

function TFhirConceptMapGroupElementTarget.GetCodeST : String;
begin
  if FCode = nil then
    result := ''
  else
    result := FCode.value;
end;

procedure TFhirConceptMapGroupElementTarget.SetCodeST(value : String);
begin
  if value <> '' then
  begin
    if FCode = nil then
      FCode := TFhirCode.create;
    FCode.value := value
  end
  else if FCode <> nil then
    FCode.value := '';
end;

procedure TFhirConceptMapGroupElementTarget.SetDisplay(value : TFhirString);
begin
  FDisplay.free;
  FDisplay := value;
end;

function TFhirConceptMapGroupElementTarget.GetDisplayST : String;
begin
  if FDisplay = nil then
    result := ''
  else
    result := FDisplay.value;
end;

procedure TFhirConceptMapGroupElementTarget.SetDisplayST(value : String);
begin
  if value <> '' then
  begin
    if FDisplay = nil then
      FDisplay := TFhirString.create;
    FDisplay.value := value
  end
  else if FDisplay <> nil then
    FDisplay.value := '';
end;

procedure TFhirConceptMapGroupElementTarget.SetEquivalence(value : TFhirEnum);
begin
  FEquivalence.free;
  FEquivalence := value;
end;

function TFhirConceptMapGroupElementTarget.GetEquivalenceST : TFhirConceptMapEquivalenceEnum;
begin
  if FEquivalence = nil then
    result := TFhirConceptMapEquivalenceEnum(0)
  else
    result := TFhirConceptMapEquivalenceEnum(StringArrayIndexOfSensitive(CODES_TFhirConceptMapEquivalenceEnum, FEquivalence.value));
end;

procedure TFhirConceptMapGroupElementTarget.SetEquivalenceST(value : TFhirConceptMapEquivalenceEnum);
begin
  if ord(value) = 0 then
    EquivalenceElement := nil
  else
    EquivalenceElement := TFhirEnum.create(SYSTEMS_TFhirConceptMapEquivalenceEnum[value], CODES_TFhirConceptMapEquivalenceEnum[value]);
end;

procedure TFhirConceptMapGroupElementTarget.SetComment(value : TFhirString);
begin
  FComment.free;
  FComment := value;
end;

function TFhirConceptMapGroupElementTarget.GetCommentST : String;
begin
  if FComment = nil then
    result := ''
  else
    result := FComment.value;
end;

procedure TFhirConceptMapGroupElementTarget.SetCommentST(value : String);
begin
  if value <> '' then
  begin
    if FComment = nil then
      FComment := TFhirString.create;
    FComment.value := value
  end
  else if FComment <> nil then
    FComment.value := '';
end;

function TFhirConceptMapGroupElementTarget.GetDependsOnList : TFhirConceptMapGroupElementTargetDependsOnList;
begin
  if FDependsOnList = nil then
    FDependsOnList := TFhirConceptMapGroupElementTargetDependsOnList.Create;
  result := FDependsOnList;
end;

function TFhirConceptMapGroupElementTarget.GetHasDependsOnList : boolean;
begin
  result := (FDependsOnList <> nil) and (FDependsOnList.count > 0);
end;

function TFhirConceptMapGroupElementTarget.GetProductList : TFhirConceptMapGroupElementTargetDependsOnList;
begin
  if FProductList = nil then
    FProductList := TFhirConceptMapGroupElementTargetDependsOnList.Create;
  result := FProductList;
end;

function TFhirConceptMapGroupElementTarget.GetHasProductList : boolean;
begin
  result := (FProductList <> nil) and (FProductList.count > 0);
end;

{ TFhirConceptMapGroupElementTargetListEnumerator }

constructor TFhirConceptMapGroupElementTargetListEnumerator.Create(list : TFhirConceptMapGroupElementTargetList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirConceptMapGroupElementTargetListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConceptMapGroupElementTargetListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirConceptMapGroupElementTargetListEnumerator.GetCurrent : TFhirConceptMapGroupElementTarget;
begin
  Result := FList[FIndex];
end;

function TFhirConceptMapGroupElementTargetListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirConceptMapGroupElementTargetList }

function TFhirConceptMapGroupElementTargetList.AddItem(value: TFhirConceptMapGroupElementTarget): TFhirConceptMapGroupElementTarget;
begin
  assert(value.ClassName = 'TFhirConceptMapGroupElementTarget', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConceptMapGroupElementTarget');
  add(value);
  result := value;
end;

function TFhirConceptMapGroupElementTargetList.Append: TFhirConceptMapGroupElementTarget;
begin
  result := TFhirConceptMapGroupElementTarget.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConceptMapGroupElementTargetList.ClearItems;
begin
  Clear;
end;

function TFhirConceptMapGroupElementTargetList.GetEnumerator : TFhirConceptMapGroupElementTargetListEnumerator;
begin
  result := TFhirConceptMapGroupElementTargetListEnumerator.Create(self.link);
end;

function TFhirConceptMapGroupElementTargetList.Clone: TFhirConceptMapGroupElementTargetList;
begin
  result := TFhirConceptMapGroupElementTargetList(inherited Clone);
end;

function TFhirConceptMapGroupElementTargetList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConceptMapGroupElementTargetList.GetItemN(index: Integer): TFhirConceptMapGroupElementTarget;
begin
  result := TFhirConceptMapGroupElementTarget(ObjectByIndex[index]);
end;

function TFhirConceptMapGroupElementTargetList.ItemClass: TFslObjectClass;
begin
  result := TFhirConceptMapGroupElementTarget;
end;
function TFhirConceptMapGroupElementTargetList.IndexOf(value: TFhirConceptMapGroupElementTarget): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirConceptMapGroupElementTargetList.Insert(index: Integer): TFhirConceptMapGroupElementTarget;
begin
  result := TFhirConceptMapGroupElementTarget.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConceptMapGroupElementTargetList.InsertItem(index: Integer; value: TFhirConceptMapGroupElementTarget);
begin
  assert(value is TFhirConceptMapGroupElementTarget);
  Inherited Insert(index, value);
end;

function TFhirConceptMapGroupElementTargetList.Item(index: Integer): TFhirConceptMapGroupElementTarget;
begin
  result := TFhirConceptMapGroupElementTarget(ObjectByIndex[index]);
end;

function TFhirConceptMapGroupElementTargetList.Link: TFhirConceptMapGroupElementTargetList;
begin
  result := TFhirConceptMapGroupElementTargetList(inherited Link);
end;

procedure TFhirConceptMapGroupElementTargetList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConceptMapGroupElementTargetList.SetItemByIndex(index: Integer; value: TFhirConceptMapGroupElementTarget);
begin
  assert(value is TFhirConceptMapGroupElementTarget);
  FhirConceptMapGroupElementTargets[index] := value;
end;

procedure TFhirConceptMapGroupElementTargetList.SetItemN(index: Integer; value: TFhirConceptMapGroupElementTarget);
begin
  assert(value is TFhirConceptMapGroupElementTarget);
  ObjectByIndex[index] := value;
end;

{ TFhirConceptMapGroupElementTargetDependsOn }

constructor TFhirConceptMapGroupElementTargetDependsOn.Create;
begin
  inherited;
end;

destructor TFhirConceptMapGroupElementTargetDependsOn.Destroy;
begin
  FProperty_.free;
  FSystem.free;
  FValue.free;
  FDisplay.free;
  inherited;
end;

procedure TFhirConceptMapGroupElementTargetDependsOn.Assign(oSource : TFslObject);
begin
  inherited;
  property_Element := TFhirConceptMapGroupElementTargetDependsOn(oSource).property_Element.Clone;
  systemElement := TFhirConceptMapGroupElementTargetDependsOn(oSource).systemElement.Clone;
  valueElement := TFhirConceptMapGroupElementTargetDependsOn(oSource).valueElement.Clone;
  displayElement := TFhirConceptMapGroupElementTargetDependsOn(oSource).displayElement.Clone;
end;

procedure TFhirConceptMapGroupElementTargetDependsOn.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'property') Then
     list.add(self.link, 'property', FProperty_.Link);
  if (child_name = 'system') Then
     list.add(self.link, 'system', FSystem.Link);
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
  if (child_name = 'display') Then
     list.add(self.link, 'display', FDisplay.Link);
end;

procedure TFhirConceptMapGroupElementTargetDependsOn.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'property', 'uri', false, TFhirUri, FProperty_.Link));
  oList.add(TFHIRProperty.create(self, 'system', 'canonical', false, TFhirCanonical, FSystem.Link));
  oList.add(TFHIRProperty.create(self, 'value', 'string', false, TFhirString, FValue.Link));
  oList.add(TFHIRProperty.create(self, 'display', 'string', false, TFhirString, FDisplay.Link));
end;

function TFhirConceptMapGroupElementTargetDependsOn.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'property') then
  begin
    Property_Element := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'system') then
  begin
    SystemElement := asCanonical(propValue);
    result := propValue;
  end
  else if (propName = 'value') then
  begin
    ValueElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'display') then
  begin
    DisplayElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirConceptMapGroupElementTargetDependsOn.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirConceptMapGroupElementTargetDependsOn.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'property') then result := TFhirUri.create()
  else if (propName = 'system') then result := TFhirCanonical.create()
  else if (propName = 'value') then result := TFhirString.create()
  else if (propName = 'display') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirConceptMapGroupElementTargetDependsOn.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'property') then result := 'uri'
  else if (propName = 'system') then result := 'canonical'
  else if (propName = 'value') then result := 'string'
  else if (propName = 'display') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirConceptMapGroupElementTargetDependsOn.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'property') then Property_Element := nil
  else if (propName = 'system') then SystemElement := nil
  else if (propName = 'value') then ValueElement := nil
  else if (propName = 'display') then DisplayElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirConceptMapGroupElementTargetDependsOn.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'property') then Property_Element := asUri(new)
  else if (propName = 'system') then SystemElement := asCanonical(new)
  else if (propName = 'value') then ValueElement := asString(new)
  else if (propName = 'display') then DisplayElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirConceptMapGroupElementTargetDependsOn.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirConceptMapGroupElementTargetDependsOn.fhirType : string;
begin
  result := 'ConceptMap.group.element.target.dependsOn';
end;

function TFhirConceptMapGroupElementTargetDependsOn.Link : TFhirConceptMapGroupElementTargetDependsOn;
begin
  result := TFhirConceptMapGroupElementTargetDependsOn(inherited Link);
end;

function TFhirConceptMapGroupElementTargetDependsOn.Clone : TFhirConceptMapGroupElementTargetDependsOn;
begin
  result := TFhirConceptMapGroupElementTargetDependsOn(inherited Clone);
end;

function TFhirConceptMapGroupElementTargetDependsOn.equals(other : TObject) : boolean; 
var
  o : TFhirConceptMapGroupElementTargetDependsOn;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirConceptMapGroupElementTargetDependsOn)) then
    result := false
  else
  begin
    o := TFhirConceptMapGroupElementTargetDependsOn(other);
    result := compareDeep(property_Element, o.property_Element, true) and compareDeep(systemElement, o.systemElement, true) and 
      compareDeep(valueElement, o.valueElement, true) and compareDeep(displayElement, o.displayElement, true);
  end;
end;

function TFhirConceptMapGroupElementTargetDependsOn.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FProperty_) and isEmptyProp(FSystem) and isEmptyProp(FValue) and isEmptyProp(FDisplay);
end;

procedure TFhirConceptMapGroupElementTargetDependsOn.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('property');
  fields.add('system');
  fields.add('value');
  fields.add('display');
end;

function TFhirConceptMapGroupElementTargetDependsOn.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirConceptMapGroupElementTargetDependsOn.SetProperty_(value : TFhirUri);
begin
  FProperty_.free;
  FProperty_ := value;
end;

function TFhirConceptMapGroupElementTargetDependsOn.GetProperty_ST : String;
begin
  if FProperty_ = nil then
    result := ''
  else
    result := FProperty_.value;
end;

procedure TFhirConceptMapGroupElementTargetDependsOn.SetProperty_ST(value : String);
begin
  if value <> '' then
  begin
    if FProperty_ = nil then
      FProperty_ := TFhirUri.create;
    FProperty_.value := value
  end
  else if FProperty_ <> nil then
    FProperty_.value := '';
end;

procedure TFhirConceptMapGroupElementTargetDependsOn.SetSystem(value : TFhirCanonical);
begin
  FSystem.free;
  FSystem := value;
end;

function TFhirConceptMapGroupElementTargetDependsOn.GetSystemST : String;
begin
  if FSystem = nil then
    result := ''
  else
    result := FSystem.value;
end;

procedure TFhirConceptMapGroupElementTargetDependsOn.SetSystemST(value : String);
begin
  if value <> '' then
  begin
    if FSystem = nil then
      FSystem := TFhirCanonical.create;
    FSystem.value := value
  end
  else if FSystem <> nil then
    FSystem.value := '';
end;

procedure TFhirConceptMapGroupElementTargetDependsOn.SetValue(value : TFhirString);
begin
  FValue.free;
  FValue := value;
end;

function TFhirConceptMapGroupElementTargetDependsOn.GetValueST : String;
begin
  if FValue = nil then
    result := ''
  else
    result := FValue.value;
end;

procedure TFhirConceptMapGroupElementTargetDependsOn.SetValueST(value : String);
begin
  if value <> '' then
  begin
    if FValue = nil then
      FValue := TFhirString.create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := '';
end;

procedure TFhirConceptMapGroupElementTargetDependsOn.SetDisplay(value : TFhirString);
begin
  FDisplay.free;
  FDisplay := value;
end;

function TFhirConceptMapGroupElementTargetDependsOn.GetDisplayST : String;
begin
  if FDisplay = nil then
    result := ''
  else
    result := FDisplay.value;
end;

procedure TFhirConceptMapGroupElementTargetDependsOn.SetDisplayST(value : String);
begin
  if value <> '' then
  begin
    if FDisplay = nil then
      FDisplay := TFhirString.create;
    FDisplay.value := value
  end
  else if FDisplay <> nil then
    FDisplay.value := '';
end;

{ TFhirConceptMapGroupElementTargetDependsOnListEnumerator }

constructor TFhirConceptMapGroupElementTargetDependsOnListEnumerator.Create(list : TFhirConceptMapGroupElementTargetDependsOnList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirConceptMapGroupElementTargetDependsOnListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConceptMapGroupElementTargetDependsOnListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirConceptMapGroupElementTargetDependsOnListEnumerator.GetCurrent : TFhirConceptMapGroupElementTargetDependsOn;
begin
  Result := FList[FIndex];
end;

function TFhirConceptMapGroupElementTargetDependsOnListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirConceptMapGroupElementTargetDependsOnList }

function TFhirConceptMapGroupElementTargetDependsOnList.AddItem(value: TFhirConceptMapGroupElementTargetDependsOn): TFhirConceptMapGroupElementTargetDependsOn;
begin
  assert(value.ClassName = 'TFhirConceptMapGroupElementTargetDependsOn', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConceptMapGroupElementTargetDependsOn');
  add(value);
  result := value;
end;

function TFhirConceptMapGroupElementTargetDependsOnList.Append: TFhirConceptMapGroupElementTargetDependsOn;
begin
  result := TFhirConceptMapGroupElementTargetDependsOn.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConceptMapGroupElementTargetDependsOnList.ClearItems;
begin
  Clear;
end;

function TFhirConceptMapGroupElementTargetDependsOnList.GetEnumerator : TFhirConceptMapGroupElementTargetDependsOnListEnumerator;
begin
  result := TFhirConceptMapGroupElementTargetDependsOnListEnumerator.Create(self.link);
end;

function TFhirConceptMapGroupElementTargetDependsOnList.Clone: TFhirConceptMapGroupElementTargetDependsOnList;
begin
  result := TFhirConceptMapGroupElementTargetDependsOnList(inherited Clone);
end;

function TFhirConceptMapGroupElementTargetDependsOnList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConceptMapGroupElementTargetDependsOnList.GetItemN(index: Integer): TFhirConceptMapGroupElementTargetDependsOn;
begin
  result := TFhirConceptMapGroupElementTargetDependsOn(ObjectByIndex[index]);
end;

function TFhirConceptMapGroupElementTargetDependsOnList.ItemClass: TFslObjectClass;
begin
  result := TFhirConceptMapGroupElementTargetDependsOn;
end;
function TFhirConceptMapGroupElementTargetDependsOnList.IndexOf(value: TFhirConceptMapGroupElementTargetDependsOn): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirConceptMapGroupElementTargetDependsOnList.Insert(index: Integer): TFhirConceptMapGroupElementTargetDependsOn;
begin
  result := TFhirConceptMapGroupElementTargetDependsOn.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConceptMapGroupElementTargetDependsOnList.InsertItem(index: Integer; value: TFhirConceptMapGroupElementTargetDependsOn);
begin
  assert(value is TFhirConceptMapGroupElementTargetDependsOn);
  Inherited Insert(index, value);
end;

function TFhirConceptMapGroupElementTargetDependsOnList.Item(index: Integer): TFhirConceptMapGroupElementTargetDependsOn;
begin
  result := TFhirConceptMapGroupElementTargetDependsOn(ObjectByIndex[index]);
end;

function TFhirConceptMapGroupElementTargetDependsOnList.Link: TFhirConceptMapGroupElementTargetDependsOnList;
begin
  result := TFhirConceptMapGroupElementTargetDependsOnList(inherited Link);
end;

procedure TFhirConceptMapGroupElementTargetDependsOnList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConceptMapGroupElementTargetDependsOnList.SetItemByIndex(index: Integer; value: TFhirConceptMapGroupElementTargetDependsOn);
begin
  assert(value is TFhirConceptMapGroupElementTargetDependsOn);
  FhirConceptMapGroupElementTargetDependsOns[index] := value;
end;

procedure TFhirConceptMapGroupElementTargetDependsOnList.SetItemN(index: Integer; value: TFhirConceptMapGroupElementTargetDependsOn);
begin
  assert(value is TFhirConceptMapGroupElementTargetDependsOn);
  ObjectByIndex[index] := value;
end;

{ TFhirConceptMapGroupUnmapped }

constructor TFhirConceptMapGroupUnmapped.Create;
begin
  inherited;
end;

destructor TFhirConceptMapGroupUnmapped.Destroy;
begin
  FMode.free;
  FCode.free;
  FDisplay.free;
  FUrl.free;
  inherited;
end;

procedure TFhirConceptMapGroupUnmapped.Assign(oSource : TFslObject);
begin
  inherited;
  modeElement := TFhirConceptMapGroupUnmapped(oSource).modeElement.Clone;
  codeElement := TFhirConceptMapGroupUnmapped(oSource).codeElement.Clone;
  displayElement := TFhirConceptMapGroupUnmapped(oSource).displayElement.Clone;
  urlElement := TFhirConceptMapGroupUnmapped(oSource).urlElement.Clone;
end;

procedure TFhirConceptMapGroupUnmapped.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'mode') Then
     list.add(self.link, 'mode', FMode.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'display') Then
     list.add(self.link, 'display', FDisplay.Link);
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
end;

procedure TFhirConceptMapGroupUnmapped.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'mode', 'code', false, TFhirEnum, FMode.Link));
  oList.add(TFHIRProperty.create(self, 'code', 'code', false, TFhirCode, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'display', 'string', false, TFhirString, FDisplay.Link));
  oList.add(TFHIRProperty.create(self, 'url', 'canonical', false, TFhirCanonical, FUrl.Link));
end;

function TFhirConceptMapGroupUnmapped.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'mode') then
  begin
    ModeElement := asEnum(SYSTEMS_TFhirConceptMapGroupUnmappedModeEnum, CODES_TFhirConceptMapGroupUnmappedModeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    CodeElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'display') then
  begin
    DisplayElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'url') then
  begin
    UrlElement := asCanonical(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirConceptMapGroupUnmapped.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirConceptMapGroupUnmapped.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'mode') then result := TFhirEnum.create(SYSTEMS_TFhirConceptMapGroupUnmappedModeEnum[ConceptMapGroupUnmappedModeNull], CODES_TFhirConceptMapGroupUnmappedModeEnum[ConceptMapGroupUnmappedModeNull]) 
  else if (propName = 'code') then result := TFhirCode.create()
  else if (propName = 'display') then result := TFhirString.create()
  else if (propName = 'url') then result := TFhirCanonical.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirConceptMapGroupUnmapped.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'mode') then result := 'code'
  else if (propName = 'code') then result := 'code'
  else if (propName = 'display') then result := 'string'
  else if (propName = 'url') then result := 'canonical'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirConceptMapGroupUnmapped.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'mode') then ModeElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'display') then DisplayElement := nil
  else if (propName = 'url') then UrlElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirConceptMapGroupUnmapped.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'mode') then ModeElement := asEnum(SYSTEMS_TFhirConceptMapGroupUnmappedModeEnum, CODES_TFhirConceptMapGroupUnmappedModeEnum, new)
  else if (propName = 'code') then CodeElement := asCode(new)
  else if (propName = 'display') then DisplayElement := asString(new)
  else if (propName = 'url') then UrlElement := asCanonical(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirConceptMapGroupUnmapped.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirConceptMapGroupUnmapped.fhirType : string;
begin
  result := 'ConceptMap.group.unmapped';
end;

function TFhirConceptMapGroupUnmapped.Link : TFhirConceptMapGroupUnmapped;
begin
  result := TFhirConceptMapGroupUnmapped(inherited Link);
end;

function TFhirConceptMapGroupUnmapped.Clone : TFhirConceptMapGroupUnmapped;
begin
  result := TFhirConceptMapGroupUnmapped(inherited Clone);
end;

function TFhirConceptMapGroupUnmapped.equals(other : TObject) : boolean; 
var
  o : TFhirConceptMapGroupUnmapped;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirConceptMapGroupUnmapped)) then
    result := false
  else
  begin
    o := TFhirConceptMapGroupUnmapped(other);
    result := compareDeep(modeElement, o.modeElement, true) and compareDeep(codeElement, o.codeElement, true) and 
      compareDeep(displayElement, o.displayElement, true) and compareDeep(urlElement, o.urlElement, true);
  end;
end;

function TFhirConceptMapGroupUnmapped.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FMode) and isEmptyProp(FCode) and isEmptyProp(FDisplay) and isEmptyProp(FUrl);
end;

procedure TFhirConceptMapGroupUnmapped.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('mode');
  fields.add('code');
  fields.add('display');
  fields.add('url');
end;

function TFhirConceptMapGroupUnmapped.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirConceptMapGroupUnmapped.SetMode(value : TFhirEnum);
begin
  FMode.free;
  FMode := value;
end;

function TFhirConceptMapGroupUnmapped.GetModeST : TFhirConceptMapGroupUnmappedModeEnum;
begin
  if FMode = nil then
    result := TFhirConceptMapGroupUnmappedModeEnum(0)
  else
    result := TFhirConceptMapGroupUnmappedModeEnum(StringArrayIndexOfSensitive(CODES_TFhirConceptMapGroupUnmappedModeEnum, FMode.value));
end;

procedure TFhirConceptMapGroupUnmapped.SetModeST(value : TFhirConceptMapGroupUnmappedModeEnum);
begin
  if ord(value) = 0 then
    ModeElement := nil
  else
    ModeElement := TFhirEnum.create(SYSTEMS_TFhirConceptMapGroupUnmappedModeEnum[value], CODES_TFhirConceptMapGroupUnmappedModeEnum[value]);
end;

procedure TFhirConceptMapGroupUnmapped.SetCode(value : TFhirCode);
begin
  FCode.free;
  FCode := value;
end;

function TFhirConceptMapGroupUnmapped.GetCodeST : String;
begin
  if FCode = nil then
    result := ''
  else
    result := FCode.value;
end;

procedure TFhirConceptMapGroupUnmapped.SetCodeST(value : String);
begin
  if value <> '' then
  begin
    if FCode = nil then
      FCode := TFhirCode.create;
    FCode.value := value
  end
  else if FCode <> nil then
    FCode.value := '';
end;

procedure TFhirConceptMapGroupUnmapped.SetDisplay(value : TFhirString);
begin
  FDisplay.free;
  FDisplay := value;
end;

function TFhirConceptMapGroupUnmapped.GetDisplayST : String;
begin
  if FDisplay = nil then
    result := ''
  else
    result := FDisplay.value;
end;

procedure TFhirConceptMapGroupUnmapped.SetDisplayST(value : String);
begin
  if value <> '' then
  begin
    if FDisplay = nil then
      FDisplay := TFhirString.create;
    FDisplay.value := value
  end
  else if FDisplay <> nil then
    FDisplay.value := '';
end;

procedure TFhirConceptMapGroupUnmapped.SetUrl(value : TFhirCanonical);
begin
  FUrl.free;
  FUrl := value;
end;

function TFhirConceptMapGroupUnmapped.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

procedure TFhirConceptMapGroupUnmapped.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirCanonical.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

{ TFhirConceptMapGroupUnmappedListEnumerator }

constructor TFhirConceptMapGroupUnmappedListEnumerator.Create(list : TFhirConceptMapGroupUnmappedList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirConceptMapGroupUnmappedListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConceptMapGroupUnmappedListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirConceptMapGroupUnmappedListEnumerator.GetCurrent : TFhirConceptMapGroupUnmapped;
begin
  Result := FList[FIndex];
end;

function TFhirConceptMapGroupUnmappedListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirConceptMapGroupUnmappedList }

function TFhirConceptMapGroupUnmappedList.AddItem(value: TFhirConceptMapGroupUnmapped): TFhirConceptMapGroupUnmapped;
begin
  assert(value.ClassName = 'TFhirConceptMapGroupUnmapped', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConceptMapGroupUnmapped');
  add(value);
  result := value;
end;

function TFhirConceptMapGroupUnmappedList.Append: TFhirConceptMapGroupUnmapped;
begin
  result := TFhirConceptMapGroupUnmapped.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConceptMapGroupUnmappedList.ClearItems;
begin
  Clear;
end;

function TFhirConceptMapGroupUnmappedList.GetEnumerator : TFhirConceptMapGroupUnmappedListEnumerator;
begin
  result := TFhirConceptMapGroupUnmappedListEnumerator.Create(self.link);
end;

function TFhirConceptMapGroupUnmappedList.Clone: TFhirConceptMapGroupUnmappedList;
begin
  result := TFhirConceptMapGroupUnmappedList(inherited Clone);
end;

function TFhirConceptMapGroupUnmappedList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConceptMapGroupUnmappedList.GetItemN(index: Integer): TFhirConceptMapGroupUnmapped;
begin
  result := TFhirConceptMapGroupUnmapped(ObjectByIndex[index]);
end;

function TFhirConceptMapGroupUnmappedList.ItemClass: TFslObjectClass;
begin
  result := TFhirConceptMapGroupUnmapped;
end;
function TFhirConceptMapGroupUnmappedList.IndexOf(value: TFhirConceptMapGroupUnmapped): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirConceptMapGroupUnmappedList.Insert(index: Integer): TFhirConceptMapGroupUnmapped;
begin
  result := TFhirConceptMapGroupUnmapped.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConceptMapGroupUnmappedList.InsertItem(index: Integer; value: TFhirConceptMapGroupUnmapped);
begin
  assert(value is TFhirConceptMapGroupUnmapped);
  Inherited Insert(index, value);
end;

function TFhirConceptMapGroupUnmappedList.Item(index: Integer): TFhirConceptMapGroupUnmapped;
begin
  result := TFhirConceptMapGroupUnmapped(ObjectByIndex[index]);
end;

function TFhirConceptMapGroupUnmappedList.Link: TFhirConceptMapGroupUnmappedList;
begin
  result := TFhirConceptMapGroupUnmappedList(inherited Link);
end;

procedure TFhirConceptMapGroupUnmappedList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConceptMapGroupUnmappedList.SetItemByIndex(index: Integer; value: TFhirConceptMapGroupUnmapped);
begin
  assert(value is TFhirConceptMapGroupUnmapped);
  FhirConceptMapGroupUnmappeds[index] := value;
end;

procedure TFhirConceptMapGroupUnmappedList.SetItemN(index: Integer; value: TFhirConceptMapGroupUnmapped);
begin
  assert(value is TFhirConceptMapGroupUnmapped);
  ObjectByIndex[index] := value;
end;

{ TFhirConceptMap }

constructor TFhirConceptMap.Create;
begin
  inherited;
end;

destructor TFhirConceptMap.Destroy;
begin
  FUrl.free;
  FIdentifier.free;
  FVersion.free;
  FName.free;
  FTitle.free;
  FStatus.free;
  FExperimental.free;
  FDate.free;
  FPublisher.free;
  FContactList.Free;
  FDescription.free;
  FUseContextList.Free;
  FJurisdictionList.Free;
  FPurpose.free;
  FCopyright.free;
  FSource.free;
  FTarget.free;
  FGroupList.Free;
  inherited;
end;

procedure TFhirConceptMap.Assign(oSource : TFslObject);
begin
  inherited;
  urlElement := TFhirConceptMap(oSource).urlElement.Clone;
  identifier := TFhirConceptMap(oSource).identifier.Clone;
  versionElement := TFhirConceptMap(oSource).versionElement.Clone;
  nameElement := TFhirConceptMap(oSource).nameElement.Clone;
  titleElement := TFhirConceptMap(oSource).titleElement.Clone;
  statusElement := TFhirConceptMap(oSource).statusElement.Clone;
  experimentalElement := TFhirConceptMap(oSource).experimentalElement.Clone;
  dateElement := TFhirConceptMap(oSource).dateElement.Clone;
  publisherElement := TFhirConceptMap(oSource).publisherElement.Clone;
  if (TFhirConceptMap(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirContactDetailList.Create;
    FContactList.Assign(TFhirConceptMap(oSource).FContactList);
  end;
  descriptionElement := TFhirConceptMap(oSource).descriptionElement.Clone;
  if (TFhirConceptMap(oSource).FUseContextList = nil) then
  begin
    FUseContextList.free;
    FUseContextList := nil;
  end
  else
  begin
    if FUseContextList = nil then
      FUseContextList := TFhirUsageContextList.Create;
    FUseContextList.Assign(TFhirConceptMap(oSource).FUseContextList);
  end;
  if (TFhirConceptMap(oSource).FJurisdictionList = nil) then
  begin
    FJurisdictionList.free;
    FJurisdictionList := nil;
  end
  else
  begin
    if FJurisdictionList = nil then
      FJurisdictionList := TFhirCodeableConceptList.Create;
    FJurisdictionList.Assign(TFhirConceptMap(oSource).FJurisdictionList);
  end;
  purposeElement := TFhirConceptMap(oSource).purposeElement.Clone;
  copyrightElement := TFhirConceptMap(oSource).copyrightElement.Clone;
  source := TFhirConceptMap(oSource).source.Clone;
  target := TFhirConceptMap(oSource).target.Clone;
  if (TFhirConceptMap(oSource).FGroupList = nil) then
  begin
    FGroupList.free;
    FGroupList := nil;
  end
  else
  begin
    if FGroupList = nil then
      FGroupList := TFhirConceptMapGroupList.Create;
    FGroupList.Assign(TFhirConceptMap(oSource).FGroupList);
  end;
end;

function TFhirConceptMap.GetResourceType : TFhirResourceType;
begin
  result := frtConceptMap;
end;

procedure TFhirConceptMap.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'version') Then
     list.add(self.link, 'version', FVersion.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'experimental') Then
     list.add(self.link, 'experimental', FExperimental.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'publisher') Then
     list.add(self.link, 'publisher', FPublisher.Link);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'useContext') Then
    list.addAll(self, 'useContext', FUseContextList);
  if (child_name = 'jurisdiction') Then
    list.addAll(self, 'jurisdiction', FJurisdictionList);
  if (child_name = 'purpose') Then
     list.add(self.link, 'purpose', FPurpose.Link);
  if (child_name = 'copyright') Then
     list.add(self.link, 'copyright', FCopyright.Link);
  if (child_name = 'source[x]') or (child_name = 'source') Then
     list.add(self.link, 'source[x]', FSource.Link);
  if (child_name = 'target[x]') or (child_name = 'target') Then
     list.add(self.link, 'target[x]', FTarget.Link);
  if (child_name = 'group') Then
    list.addAll(self, 'group', FGroupList);
end;

procedure TFhirConceptMap.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'url', 'uri', false, TFhirUri, FUrl.Link));
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));
  oList.add(TFHIRProperty.create(self, 'version', 'string', false, TFhirString, FVersion.Link));
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'experimental', 'boolean', false, TFhirBoolean, FExperimental.Link));
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));
  oList.add(TFHIRProperty.create(self, 'publisher', 'string', false, TFhirString, FPublisher.Link));
  oList.add(TFHIRProperty.create(self, 'contact', 'ContactDetail', true, TFhirContactDetail, FContactList.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'markdown', false, TFhirMarkdown, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'useContext', 'UsageContext', true, TFhirUsageContext, FUseContextList.Link));
  oList.add(TFHIRProperty.create(self, 'jurisdiction', 'CodeableConcept', true, TFhirCodeableConcept, FJurisdictionList.Link));
  oList.add(TFHIRProperty.create(self, 'purpose', 'markdown', false, TFhirMarkdown, FPurpose.Link));
  oList.add(TFHIRProperty.create(self, 'copyright', 'markdown', false, TFhirMarkdown, FCopyright.Link));
  oList.add(TFHIRProperty.create(self, 'source[x]', 'uri|canonical', false, TFhirDataType, FSource.Link));
  oList.add(TFHIRProperty.create(self, 'target[x]', 'uri|canonical', false, TFhirDataType, FTarget.Link));
  oList.add(TFHIRProperty.create(self, 'group', 'BackboneElement', true, TFhirConceptMapGroup, FGroupList.Link));
end;

function TFhirConceptMap.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'url') then
  begin
    UrlElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier;
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'title') then
  begin
    TitleElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'experimental') then
  begin
    ExperimentalElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'publisher') then
  begin
    PublisherElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirContactDetail);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'useContext') then
  begin
    UseContextList.add(propValue as TFhirUsageContext);
    result := propValue;
  end
  else if (propName = 'jurisdiction') then
  begin
    JurisdictionList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'purpose') then
  begin
    PurposeElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'copyright') then
  begin
    CopyrightElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (isMatchingName(propName, 'source', ['Uri', 'Canonical'])) then
  begin
    Source := propValue as TFhirDataType;
    result := propValue;
  end
  else if (isMatchingName(propName, 'target', ['Uri', 'Canonical'])) then
  begin
    Target := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'group') then
  begin
    GroupList.add(propValue as TFhirConceptMapGroup);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirConceptMap.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirContactDetail)
  else if (propName = 'useContext') then UseContextList.insertItem(index, propValue as TFhirUsageContext)
  else if (propName = 'jurisdiction') then JurisdictionList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'group') then GroupList.insertItem(index, propValue as TFhirConceptMapGroup)
  else inherited;
end;

function TFhirConceptMap.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'url') then result := TFhirUri.create()
  else if (propName = 'identifier') then result := TFhirIdentifier.create()
  else if (propName = 'version') then result := TFhirString.create()
  else if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'title') then result := TFhirString.create()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[PublicationStatusNull], CODES_TFhirPublicationStatusEnum[PublicationStatusNull]) 
  else if (propName = 'experimental') then result := TFhirBoolean.create()
  else if (propName = 'date') then result := TFhirDateTime.create()
  else if (propName = 'publisher') then result := TFhirString.create()
  else if (propName = 'contact') then result := ContactList.new()
  else if (propName = 'description') then result := TFhirMarkdown.create()
  else if (propName = 'useContext') then result := UseContextList.new()
  else if (propName = 'jurisdiction') then result := JurisdictionList.new()
  else if (propName = 'purpose') then result := TFhirMarkdown.create()
  else if (propName = 'copyright') then result := TFhirMarkdown.create()
  else if (isMatchingName(propName, 'source', ['Uri', 'Canonical'])) then raise EFHIRException.create('Cannot make property Source')
  else if (isMatchingName(propName, 'target', ['Uri', 'Canonical'])) then raise EFHIRException.create('Cannot make property Target')
  else if (propName = 'group') then result := GroupList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirConceptMap.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'url') then result := 'uri'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'version') then result := 'string'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'title') then result := 'string'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'experimental') then result := 'boolean'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'publisher') then result := 'string'
  else if (propName = 'contact') then result := 'ContactDetail'
  else if (propName = 'description') then result := 'markdown'
  else if (propName = 'useContext') then result := 'UsageContext'
  else if (propName = 'jurisdiction') then result := 'CodeableConcept'
  else if (propName = 'purpose') then result := 'markdown'
  else if (propName = 'copyright') then result := 'markdown'
  else if (propName = 'source[x]') then result := 'uri|canonical'
  else if (propName = 'target[x]') then result := 'uri|canonical'
  else if (propName = 'group') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirConceptMap.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := nil
  else if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'version') then VersionElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'title') then TitleElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'experimental') then ExperimentalElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'publisher') then PublisherElement := nil
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value)
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'useContext') then deletePropertyValue('useContext', UseContextList, value)
  else if (propName = 'jurisdiction') then deletePropertyValue('jurisdiction', JurisdictionList, value)
  else if (propName = 'purpose') then PurposeElement := nil
  else if (propName = 'copyright') then CopyrightElement := nil
  else if (isMatchingName(propName, 'source', ['Uri', 'Canonical'])) then SourceElement := nil
  else if (isMatchingName(propName, 'target', ['Uri', 'Canonical'])) then TargetElement := nil
  else if (propName = 'group') then deletePropertyValue('group', GroupList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirConceptMap.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := asUri(new)
  else if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier
  else if (propName = 'version') then VersionElement := asString(new)
  else if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'title') then TitleElement := asString(new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, new)
  else if (propName = 'experimental') then ExperimentalElement := asBoolean(new)
  else if (propName = 'date') then DateElement := asDateTime(new)
  else if (propName = 'publisher') then PublisherElement := asString(new)
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new)
  else if (propName = 'description') then DescriptionElement := asMarkdown(new)
  else if (propName = 'useContext') then replacePropertyValue('useContext', UseContextList, existing, new)
  else if (propName = 'jurisdiction') then replacePropertyValue('jurisdiction', JurisdictionList, existing, new)
  else if (propName = 'purpose') then PurposeElement := asMarkdown(new)
  else if (propName = 'copyright') then CopyrightElement := asMarkdown(new)
  else if (isMatchingName(propName, 'source', ['Uri', 'Canonical'])) then SourceElement := new as TFhirDataType
  else if (isMatchingName(propName, 'target', ['Uri', 'Canonical'])) then TargetElement := new as TFhirDataType
  else if (propName = 'group') then replacePropertyValue('group', GroupList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirConceptMap.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'contact') then ContactList.move(source, destination)
  else if (propName = 'useContext') then UseContextList.move(source, destination)
  else if (propName = 'jurisdiction') then JurisdictionList.move(source, destination)
  else if (propName = 'group') then GroupList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirConceptMap.fhirType : string;
begin
  result := 'ConceptMap';
end;

function TFhirConceptMap.Link : TFhirConceptMap;
begin
  result := TFhirConceptMap(inherited Link);
end;

function TFhirConceptMap.Clone : TFhirConceptMap;
begin
  result := TFhirConceptMap(inherited Clone);
end;

function TFhirConceptMap.equals(other : TObject) : boolean; 
var
  o : TFhirConceptMap;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirConceptMap)) then
    result := false
  else
  begin
    o := TFhirConceptMap(other);
    result := compareDeep(urlElement, o.urlElement, true) and compareDeep(identifierElement, o.identifierElement, true) and 
      compareDeep(versionElement, o.versionElement, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(titleElement, o.titleElement, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(experimentalElement, o.experimentalElement, true) and compareDeep(dateElement, o.dateElement, true) and 
      compareDeep(publisherElement, o.publisherElement, true) and compareDeep(contactList, o.contactList, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(useContextList, o.useContextList, true) and 
      compareDeep(jurisdictionList, o.jurisdictionList, true) and compareDeep(purposeElement, o.purposeElement, true) and 
      compareDeep(copyrightElement, o.copyrightElement, true) and compareDeep(sourceElement, o.sourceElement, true) and 
      compareDeep(targetElement, o.targetElement, true) and compareDeep(groupList, o.groupList, true);
  end;
end;

function TFhirConceptMap.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FUrl) and isEmptyProp(FIdentifier) and isEmptyProp(FVersion) and isEmptyProp(FName) and isEmptyProp(FTitle) and isEmptyProp(FStatus) and isEmptyProp(FExperimental) and isEmptyProp(FDate) and isEmptyProp(FPublisher) and isEmptyProp(FcontactList) and isEmptyProp(FDescription) and isEmptyProp(FuseContextList) and isEmptyProp(FjurisdictionList) and isEmptyProp(FPurpose) and isEmptyProp(FCopyright) and isEmptyProp(FSource) and isEmptyProp(FTarget) and isEmptyProp(FgroupList);
end;

procedure TFhirConceptMap.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('url');
  fields.add('identifier');
  fields.add('version');
  fields.add('name');
  fields.add('title');
  fields.add('status');
  fields.add('experimental');
  fields.add('date');
  fields.add('publisher');
  fields.add('contact');
  fields.add('description');
  fields.add('useContext');
  fields.add('jurisdiction');
  fields.add('purpose');
  fields.add('copyright');
  fields.add('source[x]');
  fields.add('target[x]');
  fields.add('group');
end;

function TFhirConceptMap.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FContactList.sizeInBytes(magic));
  inc(result, FUseContextList.sizeInBytes(magic));
  inc(result, FJurisdictionList.sizeInBytes(magic));
  inc(result, FGroupList.sizeInBytes(magic));
end;

procedure TFhirConceptMap.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

function TFhirConceptMap.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

procedure TFhirConceptMap.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

procedure TFhirConceptMap.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

procedure TFhirConceptMap.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

function TFhirConceptMap.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

procedure TFhirConceptMap.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

procedure TFhirConceptMap.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirConceptMap.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirConceptMap.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirConceptMap.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

function TFhirConceptMap.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

procedure TFhirConceptMap.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

procedure TFhirConceptMap.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirConceptMap.GetStatusST : TFhirPublicationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirPublicationStatusEnum(0)
  else
    result := TFhirPublicationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirPublicationStatusEnum, FStatus.value));
end;

procedure TFhirConceptMap.SetStatusST(value : TFhirPublicationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[value], CODES_TFhirPublicationStatusEnum[value]);
end;

procedure TFhirConceptMap.SetExperimental(value : TFhirBoolean);
begin
  FExperimental.free;
  FExperimental := value;
end;

function TFhirConceptMap.GetExperimentalST : Boolean;
begin
  if FExperimental = nil then
    result := false
  else
    result := FExperimental.value;
end;

procedure TFhirConceptMap.SetExperimentalST(value : Boolean);
begin
  if FExperimental = nil then
    FExperimental := TFhirBoolean.create;
  FExperimental.value := value
end;

procedure TFhirConceptMap.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

function TFhirConceptMap.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirConceptMap.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

procedure TFhirConceptMap.SetPublisher(value : TFhirString);
begin
  FPublisher.free;
  FPublisher := value;
end;

function TFhirConceptMap.GetPublisherST : String;
begin
  if FPublisher = nil then
    result := ''
  else
    result := FPublisher.value;
end;

procedure TFhirConceptMap.SetPublisherST(value : String);
begin
  if value <> '' then
  begin
    if FPublisher = nil then
      FPublisher := TFhirString.create;
    FPublisher.value := value
  end
  else if FPublisher <> nil then
    FPublisher.value := '';
end;

function TFhirConceptMap.GetContactList : TFhirContactDetailList;
begin
  if FContactList = nil then
    FContactList := TFhirContactDetailList.Create;
  result := FContactList;
end;

function TFhirConceptMap.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

procedure TFhirConceptMap.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirConceptMap.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirConceptMap.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirConceptMap.GetUseContextList : TFhirUsageContextList;
begin
  if FUseContextList = nil then
    FUseContextList := TFhirUsageContextList.Create;
  result := FUseContextList;
end;

function TFhirConceptMap.GetHasUseContextList : boolean;
begin
  result := (FUseContextList <> nil) and (FUseContextList.count > 0);
end;

function TFhirConceptMap.GetJurisdictionList : TFhirCodeableConceptList;
begin
  if FJurisdictionList = nil then
    FJurisdictionList := TFhirCodeableConceptList.Create;
  result := FJurisdictionList;
end;

function TFhirConceptMap.GetHasJurisdictionList : boolean;
begin
  result := (FJurisdictionList <> nil) and (FJurisdictionList.count > 0);
end;

procedure TFhirConceptMap.SetPurpose(value : TFhirMarkdown);
begin
  FPurpose.free;
  FPurpose := value;
end;

function TFhirConceptMap.GetPurposeST : String;
begin
  if FPurpose = nil then
    result := ''
  else
    result := FPurpose.value;
end;

procedure TFhirConceptMap.SetPurposeST(value : String);
begin
  if value <> '' then
  begin
    if FPurpose = nil then
      FPurpose := TFhirMarkdown.create;
    FPurpose.value := value
  end
  else if FPurpose <> nil then
    FPurpose.value := '';
end;

procedure TFhirConceptMap.SetCopyright(value : TFhirMarkdown);
begin
  FCopyright.free;
  FCopyright := value;
end;

function TFhirConceptMap.GetCopyrightST : String;
begin
  if FCopyright = nil then
    result := ''
  else
    result := FCopyright.value;
end;

procedure TFhirConceptMap.SetCopyrightST(value : String);
begin
  if value <> '' then
  begin
    if FCopyright = nil then
      FCopyright := TFhirMarkdown.create;
    FCopyright.value := value
  end
  else if FCopyright <> nil then
    FCopyright.value := '';
end;

procedure TFhirConceptMap.SetSource(value : TFhirDataType);
begin
  FSource.free;
  FSource := value;
end;

procedure TFhirConceptMap.SetTarget(value : TFhirDataType);
begin
  FTarget.free;
  FTarget := value;
end;

function TFhirConceptMap.GetGroupList : TFhirConceptMapGroupList;
begin
  if FGroupList = nil then
    FGroupList := TFhirConceptMapGroupList.Create;
  result := FGroupList;
end;

function TFhirConceptMap.GetHasGroupList : boolean;
begin
  result := (FGroupList <> nil) and (FGroupList.count > 0);
end;

{ TFhirConceptMapListEnumerator }

constructor TFhirConceptMapListEnumerator.Create(list : TFhirConceptMapList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirConceptMapListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConceptMapListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirConceptMapListEnumerator.GetCurrent : TFhirConceptMap;
begin
  Result := FList[FIndex];
end;

function TFhirConceptMapListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirConceptMapList }

function TFhirConceptMapList.AddItem(value: TFhirConceptMap): TFhirConceptMap;
begin
  assert(value.ClassName = 'TFhirConceptMap', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConceptMap');
  add(value);
  result := value;
end;

function TFhirConceptMapList.Append: TFhirConceptMap;
begin
  result := TFhirConceptMap.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConceptMapList.ClearItems;
begin
  Clear;
end;

function TFhirConceptMapList.GetEnumerator : TFhirConceptMapListEnumerator;
begin
  result := TFhirConceptMapListEnumerator.Create(self.link);
end;

function TFhirConceptMapList.Clone: TFhirConceptMapList;
begin
  result := TFhirConceptMapList(inherited Clone);
end;

function TFhirConceptMapList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConceptMapList.GetItemN(index: Integer): TFhirConceptMap;
begin
  result := TFhirConceptMap(ObjectByIndex[index]);
end;

function TFhirConceptMapList.ItemClass: TFslObjectClass;
begin
  result := TFhirConceptMap;
end;
function TFhirConceptMapList.IndexOf(value: TFhirConceptMap): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirConceptMapList.Insert(index: Integer): TFhirConceptMap;
begin
  result := TFhirConceptMap.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConceptMapList.InsertItem(index: Integer; value: TFhirConceptMap);
begin
  assert(value is TFhirConceptMap);
  Inherited Insert(index, value);
end;

function TFhirConceptMapList.Item(index: Integer): TFhirConceptMap;
begin
  result := TFhirConceptMap(ObjectByIndex[index]);
end;

function TFhirConceptMapList.Link: TFhirConceptMapList;
begin
  result := TFhirConceptMapList(inherited Link);
end;

procedure TFhirConceptMapList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConceptMapList.SetItemByIndex(index: Integer; value: TFhirConceptMap);
begin
  assert(value is TFhirConceptMap);
  FhirConceptMaps[index] := value;
end;

procedure TFhirConceptMapList.SetItemN(index: Integer; value: TFhirConceptMap);
begin
  assert(value is TFhirConceptMap);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_CONCEPTMAP}
{$IFDEF FHIR_EVENTDEFINITION}
{ TFhirEventDefinition }

constructor TFhirEventDefinition.Create;
begin
  inherited;
end;

destructor TFhirEventDefinition.Destroy;
begin
  FUrl.free;
  FIdentifierList.Free;
  FVersion.free;
  FName.free;
  FTitle.free;
  FSubtitle.free;
  FStatus.free;
  FExperimental.free;
  FSubject.free;
  FDate.free;
  FPublisher.free;
  FContactList.Free;
  FDescription.free;
  FUseContextList.Free;
  FJurisdictionList.Free;
  FPurpose.free;
  FUsage.free;
  FCopyright.free;
  FApprovalDate.free;
  FLastReviewDate.free;
  FEffectivePeriod.free;
  FTopicList.Free;
  FAuthorList.Free;
  FEditorList.Free;
  FReviewerList.Free;
  FEndorserList.Free;
  FRelatedArtifactList.Free;
  FTriggerList.Free;
  inherited;
end;

procedure TFhirEventDefinition.Assign(oSource : TFslObject);
begin
  inherited;
  urlElement := TFhirEventDefinition(oSource).urlElement.Clone;
  if (TFhirEventDefinition(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirEventDefinition(oSource).FIdentifierList);
  end;
  versionElement := TFhirEventDefinition(oSource).versionElement.Clone;
  nameElement := TFhirEventDefinition(oSource).nameElement.Clone;
  titleElement := TFhirEventDefinition(oSource).titleElement.Clone;
  subtitleElement := TFhirEventDefinition(oSource).subtitleElement.Clone;
  statusElement := TFhirEventDefinition(oSource).statusElement.Clone;
  experimentalElement := TFhirEventDefinition(oSource).experimentalElement.Clone;
  subject := TFhirEventDefinition(oSource).subject.Clone;
  dateElement := TFhirEventDefinition(oSource).dateElement.Clone;
  publisherElement := TFhirEventDefinition(oSource).publisherElement.Clone;
  if (TFhirEventDefinition(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirContactDetailList.Create;
    FContactList.Assign(TFhirEventDefinition(oSource).FContactList);
  end;
  descriptionElement := TFhirEventDefinition(oSource).descriptionElement.Clone;
  if (TFhirEventDefinition(oSource).FUseContextList = nil) then
  begin
    FUseContextList.free;
    FUseContextList := nil;
  end
  else
  begin
    if FUseContextList = nil then
      FUseContextList := TFhirUsageContextList.Create;
    FUseContextList.Assign(TFhirEventDefinition(oSource).FUseContextList);
  end;
  if (TFhirEventDefinition(oSource).FJurisdictionList = nil) then
  begin
    FJurisdictionList.free;
    FJurisdictionList := nil;
  end
  else
  begin
    if FJurisdictionList = nil then
      FJurisdictionList := TFhirCodeableConceptList.Create;
    FJurisdictionList.Assign(TFhirEventDefinition(oSource).FJurisdictionList);
  end;
  purposeElement := TFhirEventDefinition(oSource).purposeElement.Clone;
  usageElement := TFhirEventDefinition(oSource).usageElement.Clone;
  copyrightElement := TFhirEventDefinition(oSource).copyrightElement.Clone;
  approvalDateElement := TFhirEventDefinition(oSource).approvalDateElement.Clone;
  lastReviewDateElement := TFhirEventDefinition(oSource).lastReviewDateElement.Clone;
  effectivePeriod := TFhirEventDefinition(oSource).effectivePeriod.Clone;
  if (TFhirEventDefinition(oSource).FTopicList = nil) then
  begin
    FTopicList.free;
    FTopicList := nil;
  end
  else
  begin
    if FTopicList = nil then
      FTopicList := TFhirCodeableConceptList.Create;
    FTopicList.Assign(TFhirEventDefinition(oSource).FTopicList);
  end;
  if (TFhirEventDefinition(oSource).FAuthorList = nil) then
  begin
    FAuthorList.free;
    FAuthorList := nil;
  end
  else
  begin
    if FAuthorList = nil then
      FAuthorList := TFhirContactDetailList.Create;
    FAuthorList.Assign(TFhirEventDefinition(oSource).FAuthorList);
  end;
  if (TFhirEventDefinition(oSource).FEditorList = nil) then
  begin
    FEditorList.free;
    FEditorList := nil;
  end
  else
  begin
    if FEditorList = nil then
      FEditorList := TFhirContactDetailList.Create;
    FEditorList.Assign(TFhirEventDefinition(oSource).FEditorList);
  end;
  if (TFhirEventDefinition(oSource).FReviewerList = nil) then
  begin
    FReviewerList.free;
    FReviewerList := nil;
  end
  else
  begin
    if FReviewerList = nil then
      FReviewerList := TFhirContactDetailList.Create;
    FReviewerList.Assign(TFhirEventDefinition(oSource).FReviewerList);
  end;
  if (TFhirEventDefinition(oSource).FEndorserList = nil) then
  begin
    FEndorserList.free;
    FEndorserList := nil;
  end
  else
  begin
    if FEndorserList = nil then
      FEndorserList := TFhirContactDetailList.Create;
    FEndorserList.Assign(TFhirEventDefinition(oSource).FEndorserList);
  end;
  if (TFhirEventDefinition(oSource).FRelatedArtifactList = nil) then
  begin
    FRelatedArtifactList.free;
    FRelatedArtifactList := nil;
  end
  else
  begin
    if FRelatedArtifactList = nil then
      FRelatedArtifactList := TFhirRelatedArtifactList.Create;
    FRelatedArtifactList.Assign(TFhirEventDefinition(oSource).FRelatedArtifactList);
  end;
  if (TFhirEventDefinition(oSource).FTriggerList = nil) then
  begin
    FTriggerList.free;
    FTriggerList := nil;
  end
  else
  begin
    if FTriggerList = nil then
      FTriggerList := TFhirTriggerDefinitionList.Create;
    FTriggerList.Assign(TFhirEventDefinition(oSource).FTriggerList);
  end;
end;

function TFhirEventDefinition.GetResourceType : TFhirResourceType;
begin
  result := frtEventDefinition;
end;

procedure TFhirEventDefinition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'version') Then
     list.add(self.link, 'version', FVersion.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
  if (child_name = 'subtitle') Then
     list.add(self.link, 'subtitle', FSubtitle.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'experimental') Then
     list.add(self.link, 'experimental', FExperimental.Link);
  if (child_name = 'subject[x]') or (child_name = 'subject') Then
     list.add(self.link, 'subject[x]', FSubject.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'publisher') Then
     list.add(self.link, 'publisher', FPublisher.Link);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'useContext') Then
    list.addAll(self, 'useContext', FUseContextList);
  if (child_name = 'jurisdiction') Then
    list.addAll(self, 'jurisdiction', FJurisdictionList);
  if (child_name = 'purpose') Then
     list.add(self.link, 'purpose', FPurpose.Link);
  if (child_name = 'usage') Then
     list.add(self.link, 'usage', FUsage.Link);
  if (child_name = 'copyright') Then
     list.add(self.link, 'copyright', FCopyright.Link);
  if (child_name = 'approvalDate') Then
     list.add(self.link, 'approvalDate', FApprovalDate.Link);
  if (child_name = 'lastReviewDate') Then
     list.add(self.link, 'lastReviewDate', FLastReviewDate.Link);
  if (child_name = 'effectivePeriod') Then
     list.add(self.link, 'effectivePeriod', FEffectivePeriod.Link);
  if (child_name = 'topic') Then
    list.addAll(self, 'topic', FTopicList);
  if (child_name = 'author') Then
    list.addAll(self, 'author', FAuthorList);
  if (child_name = 'editor') Then
    list.addAll(self, 'editor', FEditorList);
  if (child_name = 'reviewer') Then
    list.addAll(self, 'reviewer', FReviewerList);
  if (child_name = 'endorser') Then
    list.addAll(self, 'endorser', FEndorserList);
  if (child_name = 'relatedArtifact') Then
    list.addAll(self, 'relatedArtifact', FRelatedArtifactList);
  if (child_name = 'trigger') Then
    list.addAll(self, 'trigger', FTriggerList);
end;

procedure TFhirEventDefinition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'url', 'uri', false, TFhirUri, FUrl.Link));
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'version', 'string', false, TFhirString, FVersion.Link));
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link));
  oList.add(TFHIRProperty.create(self, 'subtitle', 'string', false, TFhirString, FSubtitle.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'experimental', 'boolean', false, TFhirBoolean, FExperimental.Link));
  oList.add(TFHIRProperty.create(self, 'subject[x]', 'CodeableConcept|Reference', false, TFhirDataType, FSubject.Link));
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));
  oList.add(TFHIRProperty.create(self, 'publisher', 'string', false, TFhirString, FPublisher.Link));
  oList.add(TFHIRProperty.create(self, 'contact', 'ContactDetail', true, TFhirContactDetail, FContactList.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'markdown', false, TFhirMarkdown, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'useContext', 'UsageContext', true, TFhirUsageContext, FUseContextList.Link));
  oList.add(TFHIRProperty.create(self, 'jurisdiction', 'CodeableConcept', true, TFhirCodeableConcept, FJurisdictionList.Link));
  oList.add(TFHIRProperty.create(self, 'purpose', 'markdown', false, TFhirMarkdown, FPurpose.Link));
  oList.add(TFHIRProperty.create(self, 'usage', 'string', false, TFhirString, FUsage.Link));
  oList.add(TFHIRProperty.create(self, 'copyright', 'markdown', false, TFhirMarkdown, FCopyright.Link));
  oList.add(TFHIRProperty.create(self, 'approvalDate', 'date', false, TFhirDate, FApprovalDate.Link));
  oList.add(TFHIRProperty.create(self, 'lastReviewDate', 'date', false, TFhirDate, FLastReviewDate.Link));
  oList.add(TFHIRProperty.create(self, 'effectivePeriod', 'Period', false, TFhirPeriod, FEffectivePeriod.Link));
  oList.add(TFHIRProperty.create(self, 'topic', 'CodeableConcept', true, TFhirCodeableConcept, FTopicList.Link));
  oList.add(TFHIRProperty.create(self, 'author', 'ContactDetail', true, TFhirContactDetail, FAuthorList.Link));
  oList.add(TFHIRProperty.create(self, 'editor', 'ContactDetail', true, TFhirContactDetail, FEditorList.Link));
  oList.add(TFHIRProperty.create(self, 'reviewer', 'ContactDetail', true, TFhirContactDetail, FReviewerList.Link));
  oList.add(TFHIRProperty.create(self, 'endorser', 'ContactDetail', true, TFhirContactDetail, FEndorserList.Link));
  oList.add(TFHIRProperty.create(self, 'relatedArtifact', 'RelatedArtifact', true, TFhirRelatedArtifact, FRelatedArtifactList.Link));
  oList.add(TFHIRProperty.create(self, 'trigger', 'TriggerDefinition', true, TFhirTriggerDefinition, FTriggerList.Link));
end;

function TFhirEventDefinition.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'url') then
  begin
    UrlElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'title') then
  begin
    TitleElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'subtitle') then
  begin
    SubtitleElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'experimental') then
  begin
    ExperimentalElement := asBoolean(propValue);
    result := propValue;
  end
  else if (isMatchingName(propName, 'subject', ['CodeableConcept', 'Reference'])) then
  begin
    Subject := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'publisher') then
  begin
    PublisherElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirContactDetail);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'useContext') then
  begin
    UseContextList.add(propValue as TFhirUsageContext);
    result := propValue;
  end
  else if (propName = 'jurisdiction') then
  begin
    JurisdictionList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'purpose') then
  begin
    PurposeElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'usage') then
  begin
    UsageElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'copyright') then
  begin
    CopyrightElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'approvalDate') then
  begin
    ApprovalDateElement := asDate(propValue);
    result := propValue;
  end
  else if (propName = 'lastReviewDate') then
  begin
    LastReviewDateElement := asDate(propValue);
    result := propValue;
  end
  else if (propName = 'effectivePeriod') then
  begin
    EffectivePeriod := propValue as TFhirPeriod;
    result := propValue;
  end
  else if (propName = 'topic') then
  begin
    TopicList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    AuthorList.add(propValue as TFhirContactDetail);
    result := propValue;
  end
  else if (propName = 'editor') then
  begin
    EditorList.add(propValue as TFhirContactDetail);
    result := propValue;
  end
  else if (propName = 'reviewer') then
  begin
    ReviewerList.add(propValue as TFhirContactDetail);
    result := propValue;
  end
  else if (propName = 'endorser') then
  begin
    EndorserList.add(propValue as TFhirContactDetail);
    result := propValue;
  end
  else if (propName = 'relatedArtifact') then
  begin
    RelatedArtifactList.add(propValue as TFhirRelatedArtifact);
    result := propValue;
  end
  else if (propName = 'trigger') then
  begin
    TriggerList.add(propValue as TFhirTriggerDefinition);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEventDefinition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirContactDetail)
  else if (propName = 'useContext') then UseContextList.insertItem(index, propValue as TFhirUsageContext)
  else if (propName = 'jurisdiction') then JurisdictionList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'topic') then TopicList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'author') then AuthorList.insertItem(index, propValue as TFhirContactDetail)
  else if (propName = 'editor') then EditorList.insertItem(index, propValue as TFhirContactDetail)
  else if (propName = 'reviewer') then ReviewerList.insertItem(index, propValue as TFhirContactDetail)
  else if (propName = 'endorser') then EndorserList.insertItem(index, propValue as TFhirContactDetail)
  else if (propName = 'relatedArtifact') then RelatedArtifactList.insertItem(index, propValue as TFhirRelatedArtifact)
  else if (propName = 'trigger') then TriggerList.insertItem(index, propValue as TFhirTriggerDefinition)
  else inherited;
end;

function TFhirEventDefinition.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'url') then result := TFhirUri.create()
  else if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'version') then result := TFhirString.create()
  else if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'title') then result := TFhirString.create()
  else if (propName = 'subtitle') then result := TFhirString.create()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[PublicationStatusNull], CODES_TFhirPublicationStatusEnum[PublicationStatusNull]) 
  else if (propName = 'experimental') then result := TFhirBoolean.create()
  else if (isMatchingName(propName, 'subject', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Subject')
  else if (propName = 'date') then result := TFhirDateTime.create()
  else if (propName = 'publisher') then result := TFhirString.create()
  else if (propName = 'contact') then result := ContactList.new()
  else if (propName = 'description') then result := TFhirMarkdown.create()
  else if (propName = 'useContext') then result := UseContextList.new()
  else if (propName = 'jurisdiction') then result := JurisdictionList.new()
  else if (propName = 'purpose') then result := TFhirMarkdown.create()
  else if (propName = 'usage') then result := TFhirString.create()
  else if (propName = 'copyright') then result := TFhirMarkdown.create()
  else if (propName = 'approvalDate') then result := TFhirDate.create()
  else if (propName = 'lastReviewDate') then result := TFhirDate.create()
  else if (propName = 'effectivePeriod') then result := TFhirPeriod.create()
  else if (propName = 'topic') then result := TopicList.new()
  else if (propName = 'author') then result := AuthorList.new()
  else if (propName = 'editor') then result := EditorList.new()
  else if (propName = 'reviewer') then result := ReviewerList.new()
  else if (propName = 'endorser') then result := EndorserList.new()
  else if (propName = 'relatedArtifact') then result := RelatedArtifactList.new()
  else if (propName = 'trigger') then result := TriggerList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirEventDefinition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'url') then result := 'uri'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'version') then result := 'string'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'title') then result := 'string'
  else if (propName = 'subtitle') then result := 'string'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'experimental') then result := 'boolean'
  else if (propName = 'subject[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'publisher') then result := 'string'
  else if (propName = 'contact') then result := 'ContactDetail'
  else if (propName = 'description') then result := 'markdown'
  else if (propName = 'useContext') then result := 'UsageContext'
  else if (propName = 'jurisdiction') then result := 'CodeableConcept'
  else if (propName = 'purpose') then result := 'markdown'
  else if (propName = 'usage') then result := 'string'
  else if (propName = 'copyright') then result := 'markdown'
  else if (propName = 'approvalDate') then result := 'date'
  else if (propName = 'lastReviewDate') then result := 'date'
  else if (propName = 'effectivePeriod') then result := 'Period'
  else if (propName = 'topic') then result := 'CodeableConcept'
  else if (propName = 'author') then result := 'ContactDetail'
  else if (propName = 'editor') then result := 'ContactDetail'
  else if (propName = 'reviewer') then result := 'ContactDetail'
  else if (propName = 'endorser') then result := 'ContactDetail'
  else if (propName = 'relatedArtifact') then result := 'RelatedArtifact'
  else if (propName = 'trigger') then result := 'TriggerDefinition'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEventDefinition.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := nil
  else if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'version') then VersionElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'title') then TitleElement := nil
  else if (propName = 'subtitle') then SubtitleElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'experimental') then ExperimentalElement := nil
  else if (isMatchingName(propName, 'subject', ['CodeableConcept', 'Reference'])) then SubjectElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'publisher') then PublisherElement := nil
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value)
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'useContext') then deletePropertyValue('useContext', UseContextList, value)
  else if (propName = 'jurisdiction') then deletePropertyValue('jurisdiction', JurisdictionList, value)
  else if (propName = 'purpose') then PurposeElement := nil
  else if (propName = 'usage') then UsageElement := nil
  else if (propName = 'copyright') then CopyrightElement := nil
  else if (propName = 'approvalDate') then ApprovalDateElement := nil
  else if (propName = 'lastReviewDate') then LastReviewDateElement := nil
  else if (propName = 'effectivePeriod') then EffectivePeriodElement := nil
  else if (propName = 'topic') then deletePropertyValue('topic', TopicList, value)
  else if (propName = 'author') then deletePropertyValue('author', AuthorList, value)
  else if (propName = 'editor') then deletePropertyValue('editor', EditorList, value)
  else if (propName = 'reviewer') then deletePropertyValue('reviewer', ReviewerList, value)
  else if (propName = 'endorser') then deletePropertyValue('endorser', EndorserList, value)
  else if (propName = 'relatedArtifact') then deletePropertyValue('relatedArtifact', RelatedArtifactList, value)
  else if (propName = 'trigger') then deletePropertyValue('trigger', TriggerList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEventDefinition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := asUri(new)
  else if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'version') then VersionElement := asString(new)
  else if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'title') then TitleElement := asString(new)
  else if (propName = 'subtitle') then SubtitleElement := asString(new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, new)
  else if (propName = 'experimental') then ExperimentalElement := asBoolean(new)
  else if (isMatchingName(propName, 'subject', ['CodeableConcept', 'Reference'])) then SubjectElement := new as TFhirDataType
  else if (propName = 'date') then DateElement := asDateTime(new)
  else if (propName = 'publisher') then PublisherElement := asString(new)
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new)
  else if (propName = 'description') then DescriptionElement := asMarkdown(new)
  else if (propName = 'useContext') then replacePropertyValue('useContext', UseContextList, existing, new)
  else if (propName = 'jurisdiction') then replacePropertyValue('jurisdiction', JurisdictionList, existing, new)
  else if (propName = 'purpose') then PurposeElement := asMarkdown(new)
  else if (propName = 'usage') then UsageElement := asString(new)
  else if (propName = 'copyright') then CopyrightElement := asMarkdown(new)
  else if (propName = 'approvalDate') then ApprovalDateElement := asDate(new)
  else if (propName = 'lastReviewDate') then LastReviewDateElement := asDate(new)
  else if (propName = 'effectivePeriod') then EffectivePeriodElement := new as TFhirPeriod
  else if (propName = 'topic') then replacePropertyValue('topic', TopicList, existing, new)
  else if (propName = 'author') then replacePropertyValue('author', AuthorList, existing, new)
  else if (propName = 'editor') then replacePropertyValue('editor', EditorList, existing, new)
  else if (propName = 'reviewer') then replacePropertyValue('reviewer', ReviewerList, existing, new)
  else if (propName = 'endorser') then replacePropertyValue('endorser', EndorserList, existing, new)
  else if (propName = 'relatedArtifact') then replacePropertyValue('relatedArtifact', RelatedArtifactList, existing, new)
  else if (propName = 'trigger') then replacePropertyValue('trigger', TriggerList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEventDefinition.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'contact') then ContactList.move(source, destination)
  else if (propName = 'useContext') then UseContextList.move(source, destination)
  else if (propName = 'jurisdiction') then JurisdictionList.move(source, destination)
  else if (propName = 'topic') then TopicList.move(source, destination)
  else if (propName = 'author') then AuthorList.move(source, destination)
  else if (propName = 'editor') then EditorList.move(source, destination)
  else if (propName = 'reviewer') then ReviewerList.move(source, destination)
  else if (propName = 'endorser') then EndorserList.move(source, destination)
  else if (propName = 'relatedArtifact') then RelatedArtifactList.move(source, destination)
  else if (propName = 'trigger') then TriggerList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirEventDefinition.fhirType : string;
begin
  result := 'EventDefinition';
end;

function TFhirEventDefinition.Link : TFhirEventDefinition;
begin
  result := TFhirEventDefinition(inherited Link);
end;

function TFhirEventDefinition.Clone : TFhirEventDefinition;
begin
  result := TFhirEventDefinition(inherited Clone);
end;

function TFhirEventDefinition.equals(other : TObject) : boolean; 
var
  o : TFhirEventDefinition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEventDefinition)) then
    result := false
  else
  begin
    o := TFhirEventDefinition(other);
    result := compareDeep(urlElement, o.urlElement, true) and compareDeep(identifierList, o.identifierList, true) and 
      compareDeep(versionElement, o.versionElement, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(titleElement, o.titleElement, true) and compareDeep(subtitleElement, o.subtitleElement, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(experimentalElement, o.experimentalElement, true) and 
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(dateElement, o.dateElement, true) and 
      compareDeep(publisherElement, o.publisherElement, true) and compareDeep(contactList, o.contactList, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(useContextList, o.useContextList, true) and 
      compareDeep(jurisdictionList, o.jurisdictionList, true) and compareDeep(purposeElement, o.purposeElement, true) and 
      compareDeep(usageElement, o.usageElement, true) and compareDeep(copyrightElement, o.copyrightElement, true) and 
      compareDeep(approvalDateElement, o.approvalDateElement, true) and compareDeep(lastReviewDateElement, o.lastReviewDateElement, true) and 
      compareDeep(effectivePeriodElement, o.effectivePeriodElement, true) and compareDeep(topicList, o.topicList, true) and 
      compareDeep(authorList, o.authorList, true) and compareDeep(editorList, o.editorList, true) and 
      compareDeep(reviewerList, o.reviewerList, true) and compareDeep(endorserList, o.endorserList, true) and 
      compareDeep(relatedArtifactList, o.relatedArtifactList, true) and compareDeep(triggerList, o.triggerList, true);
  end;
end;

function TFhirEventDefinition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FUrl) and isEmptyProp(FidentifierList) and isEmptyProp(FVersion) and isEmptyProp(FName) and isEmptyProp(FTitle) and isEmptyProp(FSubtitle) and isEmptyProp(FStatus) and isEmptyProp(FExperimental) and isEmptyProp(FSubject) and isEmptyProp(FDate) and isEmptyProp(FPublisher) and isEmptyProp(FcontactList) and isEmptyProp(FDescription) and isEmptyProp(FuseContextList) and isEmptyProp(FjurisdictionList) and isEmptyProp(FPurpose) and isEmptyProp(FUsage) and isEmptyProp(FCopyright) and isEmptyProp(FApprovalDate) and isEmptyProp(FLastReviewDate) and isEmptyProp(FEffectivePeriod) and isEmptyProp(FtopicList) and isEmptyProp(FauthorList) and isEmptyProp(FeditorList) and isEmptyProp(FreviewerList) and isEmptyProp(FendorserList) and isEmptyProp(FrelatedArtifactList) and isEmptyProp(FtriggerList);
end;

procedure TFhirEventDefinition.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('url');
  fields.add('identifier');
  fields.add('version');
  fields.add('name');
  fields.add('title');
  fields.add('subtitle');
  fields.add('status');
  fields.add('experimental');
  fields.add('subject[x]');
  fields.add('date');
  fields.add('publisher');
  fields.add('contact');
  fields.add('description');
  fields.add('useContext');
  fields.add('jurisdiction');
  fields.add('purpose');
  fields.add('usage');
  fields.add('copyright');
  fields.add('approvalDate');
  fields.add('lastReviewDate');
  fields.add('effectivePeriod');
  fields.add('topic');
  fields.add('author');
  fields.add('editor');
  fields.add('reviewer');
  fields.add('endorser');
  fields.add('relatedArtifact');
  fields.add('trigger');
end;

function TFhirEventDefinition.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FContactList.sizeInBytes(magic));
  inc(result, FUseContextList.sizeInBytes(magic));
  inc(result, FJurisdictionList.sizeInBytes(magic));
  inc(result, FTopicList.sizeInBytes(magic));
  inc(result, FAuthorList.sizeInBytes(magic));
  inc(result, FEditorList.sizeInBytes(magic));
  inc(result, FReviewerList.sizeInBytes(magic));
  inc(result, FEndorserList.sizeInBytes(magic));
  inc(result, FRelatedArtifactList.sizeInBytes(magic));
  inc(result, FTriggerList.sizeInBytes(magic));
end;

procedure TFhirEventDefinition.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

function TFhirEventDefinition.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

procedure TFhirEventDefinition.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

function TFhirEventDefinition.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirEventDefinition.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirEventDefinition.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

function TFhirEventDefinition.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

procedure TFhirEventDefinition.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

procedure TFhirEventDefinition.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirEventDefinition.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirEventDefinition.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirEventDefinition.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

function TFhirEventDefinition.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

procedure TFhirEventDefinition.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

procedure TFhirEventDefinition.SetSubtitle(value : TFhirString);
begin
  FSubtitle.free;
  FSubtitle := value;
end;

function TFhirEventDefinition.GetSubtitleST : String;
begin
  if FSubtitle = nil then
    result := ''
  else
    result := FSubtitle.value;
end;

procedure TFhirEventDefinition.SetSubtitleST(value : String);
begin
  if value <> '' then
  begin
    if FSubtitle = nil then
      FSubtitle := TFhirString.create;
    FSubtitle.value := value
  end
  else if FSubtitle <> nil then
    FSubtitle.value := '';
end;

procedure TFhirEventDefinition.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirEventDefinition.GetStatusST : TFhirPublicationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirPublicationStatusEnum(0)
  else
    result := TFhirPublicationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirPublicationStatusEnum, FStatus.value));
end;

procedure TFhirEventDefinition.SetStatusST(value : TFhirPublicationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[value], CODES_TFhirPublicationStatusEnum[value]);
end;

procedure TFhirEventDefinition.SetExperimental(value : TFhirBoolean);
begin
  FExperimental.free;
  FExperimental := value;
end;

function TFhirEventDefinition.GetExperimentalST : Boolean;
begin
  if FExperimental = nil then
    result := false
  else
    result := FExperimental.value;
end;

procedure TFhirEventDefinition.SetExperimentalST(value : Boolean);
begin
  if FExperimental = nil then
    FExperimental := TFhirBoolean.create;
  FExperimental.value := value
end;

procedure TFhirEventDefinition.SetSubject(value : TFhirDataType);
begin
  FSubject.free;
  FSubject := value;
end;

procedure TFhirEventDefinition.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

function TFhirEventDefinition.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirEventDefinition.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

procedure TFhirEventDefinition.SetPublisher(value : TFhirString);
begin
  FPublisher.free;
  FPublisher := value;
end;

function TFhirEventDefinition.GetPublisherST : String;
begin
  if FPublisher = nil then
    result := ''
  else
    result := FPublisher.value;
end;

procedure TFhirEventDefinition.SetPublisherST(value : String);
begin
  if value <> '' then
  begin
    if FPublisher = nil then
      FPublisher := TFhirString.create;
    FPublisher.value := value
  end
  else if FPublisher <> nil then
    FPublisher.value := '';
end;

function TFhirEventDefinition.GetContactList : TFhirContactDetailList;
begin
  if FContactList = nil then
    FContactList := TFhirContactDetailList.Create;
  result := FContactList;
end;

function TFhirEventDefinition.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

procedure TFhirEventDefinition.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirEventDefinition.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirEventDefinition.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirEventDefinition.GetUseContextList : TFhirUsageContextList;
begin
  if FUseContextList = nil then
    FUseContextList := TFhirUsageContextList.Create;
  result := FUseContextList;
end;

function TFhirEventDefinition.GetHasUseContextList : boolean;
begin
  result := (FUseContextList <> nil) and (FUseContextList.count > 0);
end;

function TFhirEventDefinition.GetJurisdictionList : TFhirCodeableConceptList;
begin
  if FJurisdictionList = nil then
    FJurisdictionList := TFhirCodeableConceptList.Create;
  result := FJurisdictionList;
end;

function TFhirEventDefinition.GetHasJurisdictionList : boolean;
begin
  result := (FJurisdictionList <> nil) and (FJurisdictionList.count > 0);
end;

procedure TFhirEventDefinition.SetPurpose(value : TFhirMarkdown);
begin
  FPurpose.free;
  FPurpose := value;
end;

function TFhirEventDefinition.GetPurposeST : String;
begin
  if FPurpose = nil then
    result := ''
  else
    result := FPurpose.value;
end;

procedure TFhirEventDefinition.SetPurposeST(value : String);
begin
  if value <> '' then
  begin
    if FPurpose = nil then
      FPurpose := TFhirMarkdown.create;
    FPurpose.value := value
  end
  else if FPurpose <> nil then
    FPurpose.value := '';
end;

procedure TFhirEventDefinition.SetUsage(value : TFhirString);
begin
  FUsage.free;
  FUsage := value;
end;

function TFhirEventDefinition.GetUsageST : String;
begin
  if FUsage = nil then
    result := ''
  else
    result := FUsage.value;
end;

procedure TFhirEventDefinition.SetUsageST(value : String);
begin
  if value <> '' then
  begin
    if FUsage = nil then
      FUsage := TFhirString.create;
    FUsage.value := value
  end
  else if FUsage <> nil then
    FUsage.value := '';
end;

procedure TFhirEventDefinition.SetCopyright(value : TFhirMarkdown);
begin
  FCopyright.free;
  FCopyright := value;
end;

function TFhirEventDefinition.GetCopyrightST : String;
begin
  if FCopyright = nil then
    result := ''
  else
    result := FCopyright.value;
end;

procedure TFhirEventDefinition.SetCopyrightST(value : String);
begin
  if value <> '' then
  begin
    if FCopyright = nil then
      FCopyright := TFhirMarkdown.create;
    FCopyright.value := value
  end
  else if FCopyright <> nil then
    FCopyright.value := '';
end;

procedure TFhirEventDefinition.SetApprovalDate(value : TFhirDate);
begin
  FApprovalDate.free;
  FApprovalDate := value;
end;

function TFhirEventDefinition.GetApprovalDateST : TFslDateTime;
begin
  if FApprovalDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FApprovalDate.value;
end;

procedure TFhirEventDefinition.SetApprovalDateST(value : TFslDateTime);
begin
  if FApprovalDate = nil then
    FApprovalDate := TFhirDate.create;
  FApprovalDate.value := value
end;

procedure TFhirEventDefinition.SetLastReviewDate(value : TFhirDate);
begin
  FLastReviewDate.free;
  FLastReviewDate := value;
end;

function TFhirEventDefinition.GetLastReviewDateST : TFslDateTime;
begin
  if FLastReviewDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FLastReviewDate.value;
end;

procedure TFhirEventDefinition.SetLastReviewDateST(value : TFslDateTime);
begin
  if FLastReviewDate = nil then
    FLastReviewDate := TFhirDate.create;
  FLastReviewDate.value := value
end;

procedure TFhirEventDefinition.SetEffectivePeriod(value : TFhirPeriod);
begin
  FEffectivePeriod.free;
  FEffectivePeriod := value;
end;

function TFhirEventDefinition.GetTopicList : TFhirCodeableConceptList;
begin
  if FTopicList = nil then
    FTopicList := TFhirCodeableConceptList.Create;
  result := FTopicList;
end;

function TFhirEventDefinition.GetHasTopicList : boolean;
begin
  result := (FTopicList <> nil) and (FTopicList.count > 0);
end;

function TFhirEventDefinition.GetAuthorList : TFhirContactDetailList;
begin
  if FAuthorList = nil then
    FAuthorList := TFhirContactDetailList.Create;
  result := FAuthorList;
end;

function TFhirEventDefinition.GetHasAuthorList : boolean;
begin
  result := (FAuthorList <> nil) and (FAuthorList.count > 0);
end;

function TFhirEventDefinition.GetEditorList : TFhirContactDetailList;
begin
  if FEditorList = nil then
    FEditorList := TFhirContactDetailList.Create;
  result := FEditorList;
end;

function TFhirEventDefinition.GetHasEditorList : boolean;
begin
  result := (FEditorList <> nil) and (FEditorList.count > 0);
end;

function TFhirEventDefinition.GetReviewerList : TFhirContactDetailList;
begin
  if FReviewerList = nil then
    FReviewerList := TFhirContactDetailList.Create;
  result := FReviewerList;
end;

function TFhirEventDefinition.GetHasReviewerList : boolean;
begin
  result := (FReviewerList <> nil) and (FReviewerList.count > 0);
end;

function TFhirEventDefinition.GetEndorserList : TFhirContactDetailList;
begin
  if FEndorserList = nil then
    FEndorserList := TFhirContactDetailList.Create;
  result := FEndorserList;
end;

function TFhirEventDefinition.GetHasEndorserList : boolean;
begin
  result := (FEndorserList <> nil) and (FEndorserList.count > 0);
end;

function TFhirEventDefinition.GetRelatedArtifactList : TFhirRelatedArtifactList;
begin
  if FRelatedArtifactList = nil then
    FRelatedArtifactList := TFhirRelatedArtifactList.Create;
  result := FRelatedArtifactList;
end;

function TFhirEventDefinition.GetHasRelatedArtifactList : boolean;
begin
  result := (FRelatedArtifactList <> nil) and (FRelatedArtifactList.count > 0);
end;

function TFhirEventDefinition.GetTriggerList : TFhirTriggerDefinitionList;
begin
  if FTriggerList = nil then
    FTriggerList := TFhirTriggerDefinitionList.Create;
  result := FTriggerList;
end;

function TFhirEventDefinition.GetHasTriggerList : boolean;
begin
  result := (FTriggerList <> nil) and (FTriggerList.count > 0);
end;

{ TFhirEventDefinitionListEnumerator }

constructor TFhirEventDefinitionListEnumerator.Create(list : TFhirEventDefinitionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEventDefinitionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEventDefinitionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEventDefinitionListEnumerator.GetCurrent : TFhirEventDefinition;
begin
  Result := FList[FIndex];
end;

function TFhirEventDefinitionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirEventDefinitionList }

function TFhirEventDefinitionList.AddItem(value: TFhirEventDefinition): TFhirEventDefinition;
begin
  assert(value.ClassName = 'TFhirEventDefinition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEventDefinition');
  add(value);
  result := value;
end;

function TFhirEventDefinitionList.Append: TFhirEventDefinition;
begin
  result := TFhirEventDefinition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEventDefinitionList.ClearItems;
begin
  Clear;
end;

function TFhirEventDefinitionList.GetEnumerator : TFhirEventDefinitionListEnumerator;
begin
  result := TFhirEventDefinitionListEnumerator.Create(self.link);
end;

function TFhirEventDefinitionList.Clone: TFhirEventDefinitionList;
begin
  result := TFhirEventDefinitionList(inherited Clone);
end;

function TFhirEventDefinitionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEventDefinitionList.GetItemN(index: Integer): TFhirEventDefinition;
begin
  result := TFhirEventDefinition(ObjectByIndex[index]);
end;

function TFhirEventDefinitionList.ItemClass: TFslObjectClass;
begin
  result := TFhirEventDefinition;
end;
function TFhirEventDefinitionList.IndexOf(value: TFhirEventDefinition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEventDefinitionList.Insert(index: Integer): TFhirEventDefinition;
begin
  result := TFhirEventDefinition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEventDefinitionList.InsertItem(index: Integer; value: TFhirEventDefinition);
begin
  assert(value is TFhirEventDefinition);
  Inherited Insert(index, value);
end;

function TFhirEventDefinitionList.Item(index: Integer): TFhirEventDefinition;
begin
  result := TFhirEventDefinition(ObjectByIndex[index]);
end;

function TFhirEventDefinitionList.Link: TFhirEventDefinitionList;
begin
  result := TFhirEventDefinitionList(inherited Link);
end;

procedure TFhirEventDefinitionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEventDefinitionList.SetItemByIndex(index: Integer; value: TFhirEventDefinition);
begin
  assert(value is TFhirEventDefinition);
  FhirEventDefinitions[index] := value;
end;

procedure TFhirEventDefinitionList.SetItemN(index: Integer; value: TFhirEventDefinition);
begin
  assert(value is TFhirEventDefinition);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_EVENTDEFINITION}
{$IFDEF FHIR_EXAMPLESCENARIO}
{ TFhirExampleScenarioActor }

constructor TFhirExampleScenarioActor.Create;
begin
  inherited;
end;

destructor TFhirExampleScenarioActor.Destroy;
begin
  FActorId.free;
  FType_.free;
  FName.free;
  FDescription.free;
  inherited;
end;

procedure TFhirExampleScenarioActor.Assign(oSource : TFslObject);
begin
  inherited;
  actorIdElement := TFhirExampleScenarioActor(oSource).actorIdElement.Clone;
  type_Element := TFhirExampleScenarioActor(oSource).type_Element.Clone;
  nameElement := TFhirExampleScenarioActor(oSource).nameElement.Clone;
  descriptionElement := TFhirExampleScenarioActor(oSource).descriptionElement.Clone;
end;

procedure TFhirExampleScenarioActor.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'actorId') Then
     list.add(self.link, 'actorId', FActorId.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
end;

procedure TFhirExampleScenarioActor.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'actorId', 'string', false, TFhirString, FActorId.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFhirEnum, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'markdown', false, TFhirMarkdown, FDescription.Link));
end;

function TFhirExampleScenarioActor.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'actorId') then
  begin
    ActorIdElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirExampleScenarioActorTypeEnum, CODES_TFhirExampleScenarioActorTypeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asMarkdown(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExampleScenarioActor.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirExampleScenarioActor.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'actorId') then result := TFhirString.create()
  else if (propName = 'type') then result := TFhirEnum.create(SYSTEMS_TFhirExampleScenarioActorTypeEnum[ExampleScenarioActorTypeNull], CODES_TFhirExampleScenarioActorTypeEnum[ExampleScenarioActorTypeNull]) 
  else if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'description') then result := TFhirMarkdown.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirExampleScenarioActor.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'actorId') then result := 'string'
  else if (propName = 'type') then result := 'code'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'description') then result := 'markdown'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExampleScenarioActor.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'actorId') then ActorIdElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExampleScenarioActor.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'actorId') then ActorIdElement := asString(new)
  else if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirExampleScenarioActorTypeEnum, CODES_TFhirExampleScenarioActorTypeEnum, new)
  else if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'description') then DescriptionElement := asMarkdown(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExampleScenarioActor.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirExampleScenarioActor.fhirType : string;
begin
  result := 'ExampleScenario.actor';
end;

function TFhirExampleScenarioActor.Link : TFhirExampleScenarioActor;
begin
  result := TFhirExampleScenarioActor(inherited Link);
end;

function TFhirExampleScenarioActor.Clone : TFhirExampleScenarioActor;
begin
  result := TFhirExampleScenarioActor(inherited Clone);
end;

function TFhirExampleScenarioActor.equals(other : TObject) : boolean; 
var
  o : TFhirExampleScenarioActor;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExampleScenarioActor)) then
    result := false
  else
  begin
    o := TFhirExampleScenarioActor(other);
    result := compareDeep(actorIdElement, o.actorIdElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(nameElement, o.nameElement, true) and compareDeep(descriptionElement, o.descriptionElement, true);
  end;
end;

function TFhirExampleScenarioActor.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FActorId) and isEmptyProp(FType_) and isEmptyProp(FName) and isEmptyProp(FDescription);
end;

procedure TFhirExampleScenarioActor.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('actorId');
  fields.add('type');
  fields.add('name');
  fields.add('description');
end;

function TFhirExampleScenarioActor.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirExampleScenarioActor.SetActorId(value : TFhirString);
begin
  FActorId.free;
  FActorId := value;
end;

function TFhirExampleScenarioActor.GetActorIdST : String;
begin
  if FActorId = nil then
    result := ''
  else
    result := FActorId.value;
end;

procedure TFhirExampleScenarioActor.SetActorIdST(value : String);
begin
  if value <> '' then
  begin
    if FActorId = nil then
      FActorId := TFhirString.create;
    FActorId.value := value
  end
  else if FActorId <> nil then
    FActorId.value := '';
end;

procedure TFhirExampleScenarioActor.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirExampleScenarioActor.GetType_ST : TFhirExampleScenarioActorTypeEnum;
begin
  if FType_ = nil then
    result := TFhirExampleScenarioActorTypeEnum(0)
  else
    result := TFhirExampleScenarioActorTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirExampleScenarioActorTypeEnum, FType_.value));
end;

procedure TFhirExampleScenarioActor.SetType_ST(value : TFhirExampleScenarioActorTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirExampleScenarioActorTypeEnum[value], CODES_TFhirExampleScenarioActorTypeEnum[value]);
end;

procedure TFhirExampleScenarioActor.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirExampleScenarioActor.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirExampleScenarioActor.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirExampleScenarioActor.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirExampleScenarioActor.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirExampleScenarioActor.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

{ TFhirExampleScenarioActorListEnumerator }

constructor TFhirExampleScenarioActorListEnumerator.Create(list : TFhirExampleScenarioActorList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExampleScenarioActorListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExampleScenarioActorListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExampleScenarioActorListEnumerator.GetCurrent : TFhirExampleScenarioActor;
begin
  Result := FList[FIndex];
end;

function TFhirExampleScenarioActorListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirExampleScenarioActorList }

function TFhirExampleScenarioActorList.AddItem(value: TFhirExampleScenarioActor): TFhirExampleScenarioActor;
begin
  assert(value.ClassName = 'TFhirExampleScenarioActor', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExampleScenarioActor');
  add(value);
  result := value;
end;

function TFhirExampleScenarioActorList.Append: TFhirExampleScenarioActor;
begin
  result := TFhirExampleScenarioActor.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExampleScenarioActorList.ClearItems;
begin
  Clear;
end;

function TFhirExampleScenarioActorList.GetEnumerator : TFhirExampleScenarioActorListEnumerator;
begin
  result := TFhirExampleScenarioActorListEnumerator.Create(self.link);
end;

function TFhirExampleScenarioActorList.Clone: TFhirExampleScenarioActorList;
begin
  result := TFhirExampleScenarioActorList(inherited Clone);
end;

function TFhirExampleScenarioActorList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExampleScenarioActorList.GetItemN(index: Integer): TFhirExampleScenarioActor;
begin
  result := TFhirExampleScenarioActor(ObjectByIndex[index]);
end;

function TFhirExampleScenarioActorList.ItemClass: TFslObjectClass;
begin
  result := TFhirExampleScenarioActor;
end;
function TFhirExampleScenarioActorList.IndexOf(value: TFhirExampleScenarioActor): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExampleScenarioActorList.Insert(index: Integer): TFhirExampleScenarioActor;
begin
  result := TFhirExampleScenarioActor.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExampleScenarioActorList.InsertItem(index: Integer; value: TFhirExampleScenarioActor);
begin
  assert(value is TFhirExampleScenarioActor);
  Inherited Insert(index, value);
end;

function TFhirExampleScenarioActorList.Item(index: Integer): TFhirExampleScenarioActor;
begin
  result := TFhirExampleScenarioActor(ObjectByIndex[index]);
end;

function TFhirExampleScenarioActorList.Link: TFhirExampleScenarioActorList;
begin
  result := TFhirExampleScenarioActorList(inherited Link);
end;

procedure TFhirExampleScenarioActorList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExampleScenarioActorList.SetItemByIndex(index: Integer; value: TFhirExampleScenarioActor);
begin
  assert(value is TFhirExampleScenarioActor);
  FhirExampleScenarioActors[index] := value;
end;

procedure TFhirExampleScenarioActorList.SetItemN(index: Integer; value: TFhirExampleScenarioActor);
begin
  assert(value is TFhirExampleScenarioActor);
  ObjectByIndex[index] := value;
end;

{ TFhirExampleScenarioInstance }

constructor TFhirExampleScenarioInstance.Create;
begin
  inherited;
end;

destructor TFhirExampleScenarioInstance.Destroy;
begin
  FResourceId.free;
  FResourceType.free;
  FName.free;
  FDescription.free;
  FVersionList.Free;
  FContainedInstanceList.Free;
  inherited;
end;

procedure TFhirExampleScenarioInstance.Assign(oSource : TFslObject);
begin
  inherited;
  resourceIdElement := TFhirExampleScenarioInstance(oSource).resourceIdElement.Clone;
  resourceTypeElement := TFhirExampleScenarioInstance(oSource).resourceTypeElement.Clone;
  nameElement := TFhirExampleScenarioInstance(oSource).nameElement.Clone;
  descriptionElement := TFhirExampleScenarioInstance(oSource).descriptionElement.Clone;
  if (TFhirExampleScenarioInstance(oSource).FVersionList = nil) then
  begin
    FVersionList.free;
    FVersionList := nil;
  end
  else
  begin
    if FVersionList = nil then
      FVersionList := TFhirExampleScenarioInstanceVersionList.Create;
    FVersionList.Assign(TFhirExampleScenarioInstance(oSource).FVersionList);
  end;
  if (TFhirExampleScenarioInstance(oSource).FContainedInstanceList = nil) then
  begin
    FContainedInstanceList.free;
    FContainedInstanceList := nil;
  end
  else
  begin
    if FContainedInstanceList = nil then
      FContainedInstanceList := TFhirExampleScenarioInstanceContainedInstanceList.Create;
    FContainedInstanceList.Assign(TFhirExampleScenarioInstance(oSource).FContainedInstanceList);
  end;
end;

procedure TFhirExampleScenarioInstance.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'resourceId') Then
     list.add(self.link, 'resourceId', FResourceId.Link);
  if (child_name = 'resourceType') Then
     list.add(self.link, 'resourceType', FResourceType.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'version') Then
    list.addAll(self, 'version', FVersionList);
  if (child_name = 'containedInstance') Then
    list.addAll(self, 'containedInstance', FContainedInstanceList);
end;

procedure TFhirExampleScenarioInstance.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'resourceId', 'string', false, TFhirString, FResourceId.Link));
  oList.add(TFHIRProperty.create(self, 'resourceType', 'code', false, TFhirEnum, FResourceType.Link));
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'markdown', false, TFhirMarkdown, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'version', 'BackboneElement', true, TFhirExampleScenarioInstanceVersion, FVersionList.Link));
  oList.add(TFHIRProperty.create(self, 'containedInstance', 'BackboneElement', true, TFhirExampleScenarioInstanceContainedInstance, FContainedInstanceList.Link));
end;

function TFhirExampleScenarioInstance.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'resourceId') then
  begin
    ResourceIdElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'resourceType') then
  begin
    ResourceTypeElement := asEnum(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum, propValue);
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionList.add(propValue as TFhirExampleScenarioInstanceVersion);
    result := propValue;
  end
  else if (propName = 'containedInstance') then
  begin
    ContainedInstanceList.add(propValue as TFhirExampleScenarioInstanceContainedInstance);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExampleScenarioInstance.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'version') then VersionList.insertItem(index, propValue as TFhirExampleScenarioInstanceVersion)
  else if (propName = 'containedInstance') then ContainedInstanceList.insertItem(index, propValue as TFhirExampleScenarioInstanceContainedInstance)
  else inherited;
end;

function TFhirExampleScenarioInstance.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'resourceId') then result := TFhirString.create()
  else if (propName = 'resourceType') then result := TFhirEnum.create(SYSTEMS_TFhirResourceTypesEnum[ResourceTypesNull], CODES_TFhirResourceTypesEnum[ResourceTypesNull]) 
  else if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'description') then result := TFhirMarkdown.create()
  else if (propName = 'version') then result := VersionList.new()
  else if (propName = 'containedInstance') then result := ContainedInstanceList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirExampleScenarioInstance.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'resourceId') then result := 'string'
  else if (propName = 'resourceType') then result := 'code'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'description') then result := 'markdown'
  else if (propName = 'version') then result := 'BackboneElement'
  else if (propName = 'containedInstance') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExampleScenarioInstance.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'resourceId') then ResourceIdElement := nil
  else if (propName = 'resourceType') then ResourceTypeElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'version') then deletePropertyValue('version', VersionList, value)
  else if (propName = 'containedInstance') then deletePropertyValue('containedInstance', ContainedInstanceList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExampleScenarioInstance.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'resourceId') then ResourceIdElement := asString(new)
  else if (propName = 'resourceType') then ResourceTypeElement := asEnum(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum, new)
  else if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'description') then DescriptionElement := asMarkdown(new)
  else if (propName = 'version') then replacePropertyValue('version', VersionList, existing, new)
  else if (propName = 'containedInstance') then replacePropertyValue('containedInstance', ContainedInstanceList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExampleScenarioInstance.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'version') then VersionList.move(source, destination)
  else if (propName = 'containedInstance') then ContainedInstanceList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirExampleScenarioInstance.fhirType : string;
begin
  result := 'ExampleScenario.instance';
end;

function TFhirExampleScenarioInstance.Link : TFhirExampleScenarioInstance;
begin
  result := TFhirExampleScenarioInstance(inherited Link);
end;

function TFhirExampleScenarioInstance.Clone : TFhirExampleScenarioInstance;
begin
  result := TFhirExampleScenarioInstance(inherited Clone);
end;

function TFhirExampleScenarioInstance.equals(other : TObject) : boolean; 
var
  o : TFhirExampleScenarioInstance;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExampleScenarioInstance)) then
    result := false
  else
  begin
    o := TFhirExampleScenarioInstance(other);
    result := compareDeep(resourceIdElement, o.resourceIdElement, true) and compareDeep(resourceTypeElement, o.resourceTypeElement, true) and 
      compareDeep(nameElement, o.nameElement, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(versionList, o.versionList, true) and compareDeep(containedInstanceList, o.containedInstanceList, true);
  end;
end;

function TFhirExampleScenarioInstance.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FResourceId) and isEmptyProp(FResourceType) and isEmptyProp(FName) and isEmptyProp(FDescription) and isEmptyProp(FversionList) and isEmptyProp(FcontainedInstanceList);
end;

procedure TFhirExampleScenarioInstance.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('resourceId');
  fields.add('resourceType');
  fields.add('name');
  fields.add('description');
  fields.add('version');
  fields.add('containedInstance');
end;

function TFhirExampleScenarioInstance.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FVersionList.sizeInBytes(magic));
  inc(result, FContainedInstanceList.sizeInBytes(magic));
end;

procedure TFhirExampleScenarioInstance.SetResourceId(value : TFhirString);
begin
  FResourceId.free;
  FResourceId := value;
end;

function TFhirExampleScenarioInstance.GetResourceIdST : String;
begin
  if FResourceId = nil then
    result := ''
  else
    result := FResourceId.value;
end;

procedure TFhirExampleScenarioInstance.SetResourceIdST(value : String);
begin
  if value <> '' then
  begin
    if FResourceId = nil then
      FResourceId := TFhirString.create;
    FResourceId.value := value
  end
  else if FResourceId <> nil then
    FResourceId.value := '';
end;

procedure TFhirExampleScenarioInstance.SetResourceType(value : TFhirEnum);
begin
  FResourceType.free;
  FResourceType := value;
end;

function TFhirExampleScenarioInstance.GetResourceTypeST : TFhirResourceTypesEnum;
begin
  if FResourceType = nil then
    result := TFhirResourceTypesEnum(0)
  else
    result := TFhirResourceTypesEnum(StringArrayIndexOfSensitive(CODES_TFhirResourceTypesEnum, FResourceType.value));
end;

procedure TFhirExampleScenarioInstance.SetResourceTypeST(value : TFhirResourceTypesEnum);
begin
  if ord(value) = 0 then
    ResourceTypeElement := nil
  else
    ResourceTypeElement := TFhirEnum.create(SYSTEMS_TFhirResourceTypesEnum[value], CODES_TFhirResourceTypesEnum[value]);
end;

procedure TFhirExampleScenarioInstance.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirExampleScenarioInstance.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirExampleScenarioInstance.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirExampleScenarioInstance.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirExampleScenarioInstance.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirExampleScenarioInstance.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirExampleScenarioInstance.GetVersionList : TFhirExampleScenarioInstanceVersionList;
begin
  if FVersionList = nil then
    FVersionList := TFhirExampleScenarioInstanceVersionList.Create;
  result := FVersionList;
end;

function TFhirExampleScenarioInstance.GetHasVersionList : boolean;
begin
  result := (FVersionList <> nil) and (FVersionList.count > 0);
end;

function TFhirExampleScenarioInstance.GetContainedInstanceList : TFhirExampleScenarioInstanceContainedInstanceList;
begin
  if FContainedInstanceList = nil then
    FContainedInstanceList := TFhirExampleScenarioInstanceContainedInstanceList.Create;
  result := FContainedInstanceList;
end;

function TFhirExampleScenarioInstance.GetHasContainedInstanceList : boolean;
begin
  result := (FContainedInstanceList <> nil) and (FContainedInstanceList.count > 0);
end;

{ TFhirExampleScenarioInstanceListEnumerator }

constructor TFhirExampleScenarioInstanceListEnumerator.Create(list : TFhirExampleScenarioInstanceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExampleScenarioInstanceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExampleScenarioInstanceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExampleScenarioInstanceListEnumerator.GetCurrent : TFhirExampleScenarioInstance;
begin
  Result := FList[FIndex];
end;

function TFhirExampleScenarioInstanceListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirExampleScenarioInstanceList }

function TFhirExampleScenarioInstanceList.AddItem(value: TFhirExampleScenarioInstance): TFhirExampleScenarioInstance;
begin
  assert(value.ClassName = 'TFhirExampleScenarioInstance', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExampleScenarioInstance');
  add(value);
  result := value;
end;

function TFhirExampleScenarioInstanceList.Append: TFhirExampleScenarioInstance;
begin
  result := TFhirExampleScenarioInstance.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExampleScenarioInstanceList.ClearItems;
begin
  Clear;
end;

function TFhirExampleScenarioInstanceList.GetEnumerator : TFhirExampleScenarioInstanceListEnumerator;
begin
  result := TFhirExampleScenarioInstanceListEnumerator.Create(self.link);
end;

function TFhirExampleScenarioInstanceList.Clone: TFhirExampleScenarioInstanceList;
begin
  result := TFhirExampleScenarioInstanceList(inherited Clone);
end;

function TFhirExampleScenarioInstanceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExampleScenarioInstanceList.GetItemN(index: Integer): TFhirExampleScenarioInstance;
begin
  result := TFhirExampleScenarioInstance(ObjectByIndex[index]);
end;

function TFhirExampleScenarioInstanceList.ItemClass: TFslObjectClass;
begin
  result := TFhirExampleScenarioInstance;
end;
function TFhirExampleScenarioInstanceList.IndexOf(value: TFhirExampleScenarioInstance): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExampleScenarioInstanceList.Insert(index: Integer): TFhirExampleScenarioInstance;
begin
  result := TFhirExampleScenarioInstance.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExampleScenarioInstanceList.InsertItem(index: Integer; value: TFhirExampleScenarioInstance);
begin
  assert(value is TFhirExampleScenarioInstance);
  Inherited Insert(index, value);
end;

function TFhirExampleScenarioInstanceList.Item(index: Integer): TFhirExampleScenarioInstance;
begin
  result := TFhirExampleScenarioInstance(ObjectByIndex[index]);
end;

function TFhirExampleScenarioInstanceList.Link: TFhirExampleScenarioInstanceList;
begin
  result := TFhirExampleScenarioInstanceList(inherited Link);
end;

procedure TFhirExampleScenarioInstanceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExampleScenarioInstanceList.SetItemByIndex(index: Integer; value: TFhirExampleScenarioInstance);
begin
  assert(value is TFhirExampleScenarioInstance);
  FhirExampleScenarioInstances[index] := value;
end;

procedure TFhirExampleScenarioInstanceList.SetItemN(index: Integer; value: TFhirExampleScenarioInstance);
begin
  assert(value is TFhirExampleScenarioInstance);
  ObjectByIndex[index] := value;
end;

{ TFhirExampleScenarioInstanceVersion }

constructor TFhirExampleScenarioInstanceVersion.Create;
begin
  inherited;
end;

destructor TFhirExampleScenarioInstanceVersion.Destroy;
begin
  FVersionId.free;
  FDescription.free;
  inherited;
end;

procedure TFhirExampleScenarioInstanceVersion.Assign(oSource : TFslObject);
begin
  inherited;
  versionIdElement := TFhirExampleScenarioInstanceVersion(oSource).versionIdElement.Clone;
  descriptionElement := TFhirExampleScenarioInstanceVersion(oSource).descriptionElement.Clone;
end;

procedure TFhirExampleScenarioInstanceVersion.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'versionId') Then
     list.add(self.link, 'versionId', FVersionId.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
end;

procedure TFhirExampleScenarioInstanceVersion.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'versionId', 'string', false, TFhirString, FVersionId.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'markdown', false, TFhirMarkdown, FDescription.Link));
end;

function TFhirExampleScenarioInstanceVersion.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'versionId') then
  begin
    VersionIdElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asMarkdown(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExampleScenarioInstanceVersion.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirExampleScenarioInstanceVersion.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'versionId') then result := TFhirString.create()
  else if (propName = 'description') then result := TFhirMarkdown.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirExampleScenarioInstanceVersion.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'versionId') then result := 'string'
  else if (propName = 'description') then result := 'markdown'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExampleScenarioInstanceVersion.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'versionId') then VersionIdElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExampleScenarioInstanceVersion.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'versionId') then VersionIdElement := asString(new)
  else if (propName = 'description') then DescriptionElement := asMarkdown(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExampleScenarioInstanceVersion.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirExampleScenarioInstanceVersion.fhirType : string;
begin
  result := 'ExampleScenario.instance.version';
end;

function TFhirExampleScenarioInstanceVersion.Link : TFhirExampleScenarioInstanceVersion;
begin
  result := TFhirExampleScenarioInstanceVersion(inherited Link);
end;

function TFhirExampleScenarioInstanceVersion.Clone : TFhirExampleScenarioInstanceVersion;
begin
  result := TFhirExampleScenarioInstanceVersion(inherited Clone);
end;

function TFhirExampleScenarioInstanceVersion.equals(other : TObject) : boolean; 
var
  o : TFhirExampleScenarioInstanceVersion;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExampleScenarioInstanceVersion)) then
    result := false
  else
  begin
    o := TFhirExampleScenarioInstanceVersion(other);
    result := compareDeep(versionIdElement, o.versionIdElement, true) and compareDeep(descriptionElement, o.descriptionElement, true);
  end;
end;

function TFhirExampleScenarioInstanceVersion.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FVersionId) and isEmptyProp(FDescription);
end;

procedure TFhirExampleScenarioInstanceVersion.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('versionId');
  fields.add('description');
end;

function TFhirExampleScenarioInstanceVersion.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirExampleScenarioInstanceVersion.SetVersionId(value : TFhirString);
begin
  FVersionId.free;
  FVersionId := value;
end;

function TFhirExampleScenarioInstanceVersion.GetVersionIdST : String;
begin
  if FVersionId = nil then
    result := ''
  else
    result := FVersionId.value;
end;

procedure TFhirExampleScenarioInstanceVersion.SetVersionIdST(value : String);
begin
  if value <> '' then
  begin
    if FVersionId = nil then
      FVersionId := TFhirString.create;
    FVersionId.value := value
  end
  else if FVersionId <> nil then
    FVersionId.value := '';
end;

procedure TFhirExampleScenarioInstanceVersion.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirExampleScenarioInstanceVersion.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirExampleScenarioInstanceVersion.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

{ TFhirExampleScenarioInstanceVersionListEnumerator }

constructor TFhirExampleScenarioInstanceVersionListEnumerator.Create(list : TFhirExampleScenarioInstanceVersionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExampleScenarioInstanceVersionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExampleScenarioInstanceVersionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExampleScenarioInstanceVersionListEnumerator.GetCurrent : TFhirExampleScenarioInstanceVersion;
begin
  Result := FList[FIndex];
end;

function TFhirExampleScenarioInstanceVersionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirExampleScenarioInstanceVersionList }

function TFhirExampleScenarioInstanceVersionList.AddItem(value: TFhirExampleScenarioInstanceVersion): TFhirExampleScenarioInstanceVersion;
begin
  assert(value.ClassName = 'TFhirExampleScenarioInstanceVersion', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExampleScenarioInstanceVersion');
  add(value);
  result := value;
end;

function TFhirExampleScenarioInstanceVersionList.Append: TFhirExampleScenarioInstanceVersion;
begin
  result := TFhirExampleScenarioInstanceVersion.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExampleScenarioInstanceVersionList.ClearItems;
begin
  Clear;
end;

function TFhirExampleScenarioInstanceVersionList.GetEnumerator : TFhirExampleScenarioInstanceVersionListEnumerator;
begin
  result := TFhirExampleScenarioInstanceVersionListEnumerator.Create(self.link);
end;

function TFhirExampleScenarioInstanceVersionList.Clone: TFhirExampleScenarioInstanceVersionList;
begin
  result := TFhirExampleScenarioInstanceVersionList(inherited Clone);
end;

function TFhirExampleScenarioInstanceVersionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExampleScenarioInstanceVersionList.GetItemN(index: Integer): TFhirExampleScenarioInstanceVersion;
begin
  result := TFhirExampleScenarioInstanceVersion(ObjectByIndex[index]);
end;

function TFhirExampleScenarioInstanceVersionList.ItemClass: TFslObjectClass;
begin
  result := TFhirExampleScenarioInstanceVersion;
end;
function TFhirExampleScenarioInstanceVersionList.IndexOf(value: TFhirExampleScenarioInstanceVersion): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExampleScenarioInstanceVersionList.Insert(index: Integer): TFhirExampleScenarioInstanceVersion;
begin
  result := TFhirExampleScenarioInstanceVersion.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExampleScenarioInstanceVersionList.InsertItem(index: Integer; value: TFhirExampleScenarioInstanceVersion);
begin
  assert(value is TFhirExampleScenarioInstanceVersion);
  Inherited Insert(index, value);
end;

function TFhirExampleScenarioInstanceVersionList.Item(index: Integer): TFhirExampleScenarioInstanceVersion;
begin
  result := TFhirExampleScenarioInstanceVersion(ObjectByIndex[index]);
end;

function TFhirExampleScenarioInstanceVersionList.Link: TFhirExampleScenarioInstanceVersionList;
begin
  result := TFhirExampleScenarioInstanceVersionList(inherited Link);
end;

procedure TFhirExampleScenarioInstanceVersionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExampleScenarioInstanceVersionList.SetItemByIndex(index: Integer; value: TFhirExampleScenarioInstanceVersion);
begin
  assert(value is TFhirExampleScenarioInstanceVersion);
  FhirExampleScenarioInstanceVersions[index] := value;
end;

procedure TFhirExampleScenarioInstanceVersionList.SetItemN(index: Integer; value: TFhirExampleScenarioInstanceVersion);
begin
  assert(value is TFhirExampleScenarioInstanceVersion);
  ObjectByIndex[index] := value;
end;

{ TFhirExampleScenarioInstanceContainedInstance }

constructor TFhirExampleScenarioInstanceContainedInstance.Create;
begin
  inherited;
end;

destructor TFhirExampleScenarioInstanceContainedInstance.Destroy;
begin
  FResourceId.free;
  FVersionId.free;
  inherited;
end;

procedure TFhirExampleScenarioInstanceContainedInstance.Assign(oSource : TFslObject);
begin
  inherited;
  resourceIdElement := TFhirExampleScenarioInstanceContainedInstance(oSource).resourceIdElement.Clone;
  versionIdElement := TFhirExampleScenarioInstanceContainedInstance(oSource).versionIdElement.Clone;
end;

procedure TFhirExampleScenarioInstanceContainedInstance.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'resourceId') Then
     list.add(self.link, 'resourceId', FResourceId.Link);
  if (child_name = 'versionId') Then
     list.add(self.link, 'versionId', FVersionId.Link);
end;

procedure TFhirExampleScenarioInstanceContainedInstance.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'resourceId', 'string', false, TFhirString, FResourceId.Link));
  oList.add(TFHIRProperty.create(self, 'versionId', 'string', false, TFhirString, FVersionId.Link));
end;

function TFhirExampleScenarioInstanceContainedInstance.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'resourceId') then
  begin
    ResourceIdElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'versionId') then
  begin
    VersionIdElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExampleScenarioInstanceContainedInstance.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirExampleScenarioInstanceContainedInstance.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'resourceId') then result := TFhirString.create()
  else if (propName = 'versionId') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirExampleScenarioInstanceContainedInstance.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'resourceId') then result := 'string'
  else if (propName = 'versionId') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExampleScenarioInstanceContainedInstance.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'resourceId') then ResourceIdElement := nil
  else if (propName = 'versionId') then VersionIdElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExampleScenarioInstanceContainedInstance.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'resourceId') then ResourceIdElement := asString(new)
  else if (propName = 'versionId') then VersionIdElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExampleScenarioInstanceContainedInstance.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirExampleScenarioInstanceContainedInstance.fhirType : string;
begin
  result := 'ExampleScenario.instance.containedInstance';
end;

function TFhirExampleScenarioInstanceContainedInstance.Link : TFhirExampleScenarioInstanceContainedInstance;
begin
  result := TFhirExampleScenarioInstanceContainedInstance(inherited Link);
end;

function TFhirExampleScenarioInstanceContainedInstance.Clone : TFhirExampleScenarioInstanceContainedInstance;
begin
  result := TFhirExampleScenarioInstanceContainedInstance(inherited Clone);
end;

function TFhirExampleScenarioInstanceContainedInstance.equals(other : TObject) : boolean; 
var
  o : TFhirExampleScenarioInstanceContainedInstance;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExampleScenarioInstanceContainedInstance)) then
    result := false
  else
  begin
    o := TFhirExampleScenarioInstanceContainedInstance(other);
    result := compareDeep(resourceIdElement, o.resourceIdElement, true) and compareDeep(versionIdElement, o.versionIdElement, true);
  end;
end;

function TFhirExampleScenarioInstanceContainedInstance.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FResourceId) and isEmptyProp(FVersionId);
end;

procedure TFhirExampleScenarioInstanceContainedInstance.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('resourceId');
  fields.add('versionId');
end;

function TFhirExampleScenarioInstanceContainedInstance.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirExampleScenarioInstanceContainedInstance.SetResourceId(value : TFhirString);
begin
  FResourceId.free;
  FResourceId := value;
end;

function TFhirExampleScenarioInstanceContainedInstance.GetResourceIdST : String;
begin
  if FResourceId = nil then
    result := ''
  else
    result := FResourceId.value;
end;

procedure TFhirExampleScenarioInstanceContainedInstance.SetResourceIdST(value : String);
begin
  if value <> '' then
  begin
    if FResourceId = nil then
      FResourceId := TFhirString.create;
    FResourceId.value := value
  end
  else if FResourceId <> nil then
    FResourceId.value := '';
end;

procedure TFhirExampleScenarioInstanceContainedInstance.SetVersionId(value : TFhirString);
begin
  FVersionId.free;
  FVersionId := value;
end;

function TFhirExampleScenarioInstanceContainedInstance.GetVersionIdST : String;
begin
  if FVersionId = nil then
    result := ''
  else
    result := FVersionId.value;
end;

procedure TFhirExampleScenarioInstanceContainedInstance.SetVersionIdST(value : String);
begin
  if value <> '' then
  begin
    if FVersionId = nil then
      FVersionId := TFhirString.create;
    FVersionId.value := value
  end
  else if FVersionId <> nil then
    FVersionId.value := '';
end;

{ TFhirExampleScenarioInstanceContainedInstanceListEnumerator }

constructor TFhirExampleScenarioInstanceContainedInstanceListEnumerator.Create(list : TFhirExampleScenarioInstanceContainedInstanceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExampleScenarioInstanceContainedInstanceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExampleScenarioInstanceContainedInstanceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExampleScenarioInstanceContainedInstanceListEnumerator.GetCurrent : TFhirExampleScenarioInstanceContainedInstance;
begin
  Result := FList[FIndex];
end;

function TFhirExampleScenarioInstanceContainedInstanceListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirExampleScenarioInstanceContainedInstanceList }

function TFhirExampleScenarioInstanceContainedInstanceList.AddItem(value: TFhirExampleScenarioInstanceContainedInstance): TFhirExampleScenarioInstanceContainedInstance;
begin
  assert(value.ClassName = 'TFhirExampleScenarioInstanceContainedInstance', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExampleScenarioInstanceContainedInstance');
  add(value);
  result := value;
end;

function TFhirExampleScenarioInstanceContainedInstanceList.Append: TFhirExampleScenarioInstanceContainedInstance;
begin
  result := TFhirExampleScenarioInstanceContainedInstance.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExampleScenarioInstanceContainedInstanceList.ClearItems;
begin
  Clear;
end;

function TFhirExampleScenarioInstanceContainedInstanceList.GetEnumerator : TFhirExampleScenarioInstanceContainedInstanceListEnumerator;
begin
  result := TFhirExampleScenarioInstanceContainedInstanceListEnumerator.Create(self.link);
end;

function TFhirExampleScenarioInstanceContainedInstanceList.Clone: TFhirExampleScenarioInstanceContainedInstanceList;
begin
  result := TFhirExampleScenarioInstanceContainedInstanceList(inherited Clone);
end;

function TFhirExampleScenarioInstanceContainedInstanceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExampleScenarioInstanceContainedInstanceList.GetItemN(index: Integer): TFhirExampleScenarioInstanceContainedInstance;
begin
  result := TFhirExampleScenarioInstanceContainedInstance(ObjectByIndex[index]);
end;

function TFhirExampleScenarioInstanceContainedInstanceList.ItemClass: TFslObjectClass;
begin
  result := TFhirExampleScenarioInstanceContainedInstance;
end;
function TFhirExampleScenarioInstanceContainedInstanceList.IndexOf(value: TFhirExampleScenarioInstanceContainedInstance): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExampleScenarioInstanceContainedInstanceList.Insert(index: Integer): TFhirExampleScenarioInstanceContainedInstance;
begin
  result := TFhirExampleScenarioInstanceContainedInstance.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExampleScenarioInstanceContainedInstanceList.InsertItem(index: Integer; value: TFhirExampleScenarioInstanceContainedInstance);
begin
  assert(value is TFhirExampleScenarioInstanceContainedInstance);
  Inherited Insert(index, value);
end;

function TFhirExampleScenarioInstanceContainedInstanceList.Item(index: Integer): TFhirExampleScenarioInstanceContainedInstance;
begin
  result := TFhirExampleScenarioInstanceContainedInstance(ObjectByIndex[index]);
end;

function TFhirExampleScenarioInstanceContainedInstanceList.Link: TFhirExampleScenarioInstanceContainedInstanceList;
begin
  result := TFhirExampleScenarioInstanceContainedInstanceList(inherited Link);
end;

procedure TFhirExampleScenarioInstanceContainedInstanceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExampleScenarioInstanceContainedInstanceList.SetItemByIndex(index: Integer; value: TFhirExampleScenarioInstanceContainedInstance);
begin
  assert(value is TFhirExampleScenarioInstanceContainedInstance);
  FhirExampleScenarioInstanceContainedInstances[index] := value;
end;

procedure TFhirExampleScenarioInstanceContainedInstanceList.SetItemN(index: Integer; value: TFhirExampleScenarioInstanceContainedInstance);
begin
  assert(value is TFhirExampleScenarioInstanceContainedInstance);
  ObjectByIndex[index] := value;
end;

{ TFhirExampleScenarioProcess }

constructor TFhirExampleScenarioProcess.Create;
begin
  inherited;
end;

destructor TFhirExampleScenarioProcess.Destroy;
begin
  FTitle.free;
  FDescription.free;
  FPreConditions.free;
  FPostConditions.free;
  FStepList.Free;
  inherited;
end;

procedure TFhirExampleScenarioProcess.Assign(oSource : TFslObject);
begin
  inherited;
  titleElement := TFhirExampleScenarioProcess(oSource).titleElement.Clone;
  descriptionElement := TFhirExampleScenarioProcess(oSource).descriptionElement.Clone;
  preConditionsElement := TFhirExampleScenarioProcess(oSource).preConditionsElement.Clone;
  postConditionsElement := TFhirExampleScenarioProcess(oSource).postConditionsElement.Clone;
  if (TFhirExampleScenarioProcess(oSource).FStepList = nil) then
  begin
    FStepList.free;
    FStepList := nil;
  end
  else
  begin
    if FStepList = nil then
      FStepList := TFhirExampleScenarioProcessStepList.Create;
    FStepList.Assign(TFhirExampleScenarioProcess(oSource).FStepList);
  end;
end;

procedure TFhirExampleScenarioProcess.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'preConditions') Then
     list.add(self.link, 'preConditions', FPreConditions.Link);
  if (child_name = 'postConditions') Then
     list.add(self.link, 'postConditions', FPostConditions.Link);
  if (child_name = 'step') Then
    list.addAll(self, 'step', FStepList);
end;

procedure TFhirExampleScenarioProcess.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'markdown', false, TFhirMarkdown, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'preConditions', 'markdown', false, TFhirMarkdown, FPreConditions.Link));
  oList.add(TFHIRProperty.create(self, 'postConditions', 'markdown', false, TFhirMarkdown, FPostConditions.Link));
  oList.add(TFHIRProperty.create(self, 'step', 'BackboneElement', true, TFhirExampleScenarioProcessStep, FStepList.Link));
end;

function TFhirExampleScenarioProcess.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'title') then
  begin
    TitleElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'preConditions') then
  begin
    PreConditionsElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'postConditions') then
  begin
    PostConditionsElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'step') then
  begin
    StepList.add(propValue as TFhirExampleScenarioProcessStep);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExampleScenarioProcess.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'step') then StepList.insertItem(index, propValue as TFhirExampleScenarioProcessStep)
  else inherited;
end;

function TFhirExampleScenarioProcess.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'title') then result := TFhirString.create()
  else if (propName = 'description') then result := TFhirMarkdown.create()
  else if (propName = 'preConditions') then result := TFhirMarkdown.create()
  else if (propName = 'postConditions') then result := TFhirMarkdown.create()
  else if (propName = 'step') then result := StepList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirExampleScenarioProcess.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'title') then result := 'string'
  else if (propName = 'description') then result := 'markdown'
  else if (propName = 'preConditions') then result := 'markdown'
  else if (propName = 'postConditions') then result := 'markdown'
  else if (propName = 'step') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExampleScenarioProcess.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'title') then TitleElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'preConditions') then PreConditionsElement := nil
  else if (propName = 'postConditions') then PostConditionsElement := nil
  else if (propName = 'step') then deletePropertyValue('step', StepList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExampleScenarioProcess.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'title') then TitleElement := asString(new)
  else if (propName = 'description') then DescriptionElement := asMarkdown(new)
  else if (propName = 'preConditions') then PreConditionsElement := asMarkdown(new)
  else if (propName = 'postConditions') then PostConditionsElement := asMarkdown(new)
  else if (propName = 'step') then replacePropertyValue('step', StepList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExampleScenarioProcess.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'step') then StepList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirExampleScenarioProcess.fhirType : string;
begin
  result := 'ExampleScenario.process';
end;

function TFhirExampleScenarioProcess.Link : TFhirExampleScenarioProcess;
begin
  result := TFhirExampleScenarioProcess(inherited Link);
end;

function TFhirExampleScenarioProcess.Clone : TFhirExampleScenarioProcess;
begin
  result := TFhirExampleScenarioProcess(inherited Clone);
end;

function TFhirExampleScenarioProcess.equals(other : TObject) : boolean; 
var
  o : TFhirExampleScenarioProcess;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExampleScenarioProcess)) then
    result := false
  else
  begin
    o := TFhirExampleScenarioProcess(other);
    result := compareDeep(titleElement, o.titleElement, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(preConditionsElement, o.preConditionsElement, true) and compareDeep(postConditionsElement, o.postConditionsElement, true) and 
      compareDeep(stepList, o.stepList, true);
  end;
end;

function TFhirExampleScenarioProcess.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FTitle) and isEmptyProp(FDescription) and isEmptyProp(FPreConditions) and isEmptyProp(FPostConditions) and isEmptyProp(FstepList);
end;

procedure TFhirExampleScenarioProcess.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('title');
  fields.add('description');
  fields.add('preConditions');
  fields.add('postConditions');
  fields.add('step');
end;

function TFhirExampleScenarioProcess.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FStepList.sizeInBytes(magic));
end;

procedure TFhirExampleScenarioProcess.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

function TFhirExampleScenarioProcess.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

procedure TFhirExampleScenarioProcess.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

procedure TFhirExampleScenarioProcess.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirExampleScenarioProcess.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirExampleScenarioProcess.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirExampleScenarioProcess.SetPreConditions(value : TFhirMarkdown);
begin
  FPreConditions.free;
  FPreConditions := value;
end;

function TFhirExampleScenarioProcess.GetPreConditionsST : String;
begin
  if FPreConditions = nil then
    result := ''
  else
    result := FPreConditions.value;
end;

procedure TFhirExampleScenarioProcess.SetPreConditionsST(value : String);
begin
  if value <> '' then
  begin
    if FPreConditions = nil then
      FPreConditions := TFhirMarkdown.create;
    FPreConditions.value := value
  end
  else if FPreConditions <> nil then
    FPreConditions.value := '';
end;

procedure TFhirExampleScenarioProcess.SetPostConditions(value : TFhirMarkdown);
begin
  FPostConditions.free;
  FPostConditions := value;
end;

function TFhirExampleScenarioProcess.GetPostConditionsST : String;
begin
  if FPostConditions = nil then
    result := ''
  else
    result := FPostConditions.value;
end;

procedure TFhirExampleScenarioProcess.SetPostConditionsST(value : String);
begin
  if value <> '' then
  begin
    if FPostConditions = nil then
      FPostConditions := TFhirMarkdown.create;
    FPostConditions.value := value
  end
  else if FPostConditions <> nil then
    FPostConditions.value := '';
end;

function TFhirExampleScenarioProcess.GetStepList : TFhirExampleScenarioProcessStepList;
begin
  if FStepList = nil then
    FStepList := TFhirExampleScenarioProcessStepList.Create;
  result := FStepList;
end;

function TFhirExampleScenarioProcess.GetHasStepList : boolean;
begin
  result := (FStepList <> nil) and (FStepList.count > 0);
end;

{ TFhirExampleScenarioProcessListEnumerator }

constructor TFhirExampleScenarioProcessListEnumerator.Create(list : TFhirExampleScenarioProcessList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExampleScenarioProcessListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExampleScenarioProcessListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExampleScenarioProcessListEnumerator.GetCurrent : TFhirExampleScenarioProcess;
begin
  Result := FList[FIndex];
end;

function TFhirExampleScenarioProcessListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirExampleScenarioProcessList }

function TFhirExampleScenarioProcessList.AddItem(value: TFhirExampleScenarioProcess): TFhirExampleScenarioProcess;
begin
  assert(value.ClassName = 'TFhirExampleScenarioProcess', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExampleScenarioProcess');
  add(value);
  result := value;
end;

function TFhirExampleScenarioProcessList.Append: TFhirExampleScenarioProcess;
begin
  result := TFhirExampleScenarioProcess.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExampleScenarioProcessList.ClearItems;
begin
  Clear;
end;

function TFhirExampleScenarioProcessList.GetEnumerator : TFhirExampleScenarioProcessListEnumerator;
begin
  result := TFhirExampleScenarioProcessListEnumerator.Create(self.link);
end;

function TFhirExampleScenarioProcessList.Clone: TFhirExampleScenarioProcessList;
begin
  result := TFhirExampleScenarioProcessList(inherited Clone);
end;

function TFhirExampleScenarioProcessList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExampleScenarioProcessList.GetItemN(index: Integer): TFhirExampleScenarioProcess;
begin
  result := TFhirExampleScenarioProcess(ObjectByIndex[index]);
end;

function TFhirExampleScenarioProcessList.ItemClass: TFslObjectClass;
begin
  result := TFhirExampleScenarioProcess;
end;
function TFhirExampleScenarioProcessList.IndexOf(value: TFhirExampleScenarioProcess): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExampleScenarioProcessList.Insert(index: Integer): TFhirExampleScenarioProcess;
begin
  result := TFhirExampleScenarioProcess.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExampleScenarioProcessList.InsertItem(index: Integer; value: TFhirExampleScenarioProcess);
begin
  assert(value is TFhirExampleScenarioProcess);
  Inherited Insert(index, value);
end;

function TFhirExampleScenarioProcessList.Item(index: Integer): TFhirExampleScenarioProcess;
begin
  result := TFhirExampleScenarioProcess(ObjectByIndex[index]);
end;

function TFhirExampleScenarioProcessList.Link: TFhirExampleScenarioProcessList;
begin
  result := TFhirExampleScenarioProcessList(inherited Link);
end;

procedure TFhirExampleScenarioProcessList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExampleScenarioProcessList.SetItemByIndex(index: Integer; value: TFhirExampleScenarioProcess);
begin
  assert(value is TFhirExampleScenarioProcess);
  FhirExampleScenarioProcesses[index] := value;
end;

procedure TFhirExampleScenarioProcessList.SetItemN(index: Integer; value: TFhirExampleScenarioProcess);
begin
  assert(value is TFhirExampleScenarioProcess);
  ObjectByIndex[index] := value;
end;

{ TFhirExampleScenarioProcessStep }

constructor TFhirExampleScenarioProcessStep.Create;
begin
  inherited;
end;

destructor TFhirExampleScenarioProcessStep.Destroy;
begin
  FProcessList.Free;
  FPause.free;
  FOperation.free;
  FAlternativeList.Free;
  inherited;
end;

procedure TFhirExampleScenarioProcessStep.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirExampleScenarioProcessStep(oSource).FProcessList = nil) then
  begin
    FProcessList.free;
    FProcessList := nil;
  end
  else
  begin
    if FProcessList = nil then
      FProcessList := TFhirExampleScenarioProcessList.Create;
    FProcessList.Assign(TFhirExampleScenarioProcessStep(oSource).FProcessList);
  end;
  pauseElement := TFhirExampleScenarioProcessStep(oSource).pauseElement.Clone;
  operation := TFhirExampleScenarioProcessStep(oSource).operation.Clone;
  if (TFhirExampleScenarioProcessStep(oSource).FAlternativeList = nil) then
  begin
    FAlternativeList.free;
    FAlternativeList := nil;
  end
  else
  begin
    if FAlternativeList = nil then
      FAlternativeList := TFhirExampleScenarioProcessStepAlternativeList.Create;
    FAlternativeList.Assign(TFhirExampleScenarioProcessStep(oSource).FAlternativeList);
  end;
end;

procedure TFhirExampleScenarioProcessStep.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'process') Then
    list.addAll(self, 'process', FProcessList);
  if (child_name = 'pause') Then
     list.add(self.link, 'pause', FPause.Link);
  if (child_name = 'operation') Then
     list.add(self.link, 'operation', FOperation.Link);
  if (child_name = 'alternative') Then
    list.addAll(self, 'alternative', FAlternativeList);
end;

procedure TFhirExampleScenarioProcessStep.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'process', '', true, TFhirExampleScenarioProcess, FProcessList.Link));
  oList.add(TFHIRProperty.create(self, 'pause', 'boolean', false, TFhirBoolean, FPause.Link));
  oList.add(TFHIRProperty.create(self, 'operation', 'BackboneElement', false, TFhirExampleScenarioProcessStepOperation, FOperation.Link));
  oList.add(TFHIRProperty.create(self, 'alternative', 'BackboneElement', true, TFhirExampleScenarioProcessStepAlternative, FAlternativeList.Link));
end;

function TFhirExampleScenarioProcessStep.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'process') then
  begin
    ProcessList.add(propValue as TFhirExampleScenarioProcess);
    result := propValue;
  end
  else if (propName = 'pause') then
  begin
    PauseElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'operation') then
  begin
    Operation := propValue as TFhirExampleScenarioProcessStepOperation;
    result := propValue;
  end
  else if (propName = 'alternative') then
  begin
    AlternativeList.add(propValue as TFhirExampleScenarioProcessStepAlternative);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExampleScenarioProcessStep.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'process') then ProcessList.insertItem(index, propValue as TFhirExampleScenarioProcess)
  else if (propName = 'alternative') then AlternativeList.insertItem(index, propValue as TFhirExampleScenarioProcessStepAlternative)
  else inherited;
end;

function TFhirExampleScenarioProcessStep.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'process') then result := ProcessList.new()
  else if (propName = 'pause') then result := TFhirBoolean.create()
  else if (propName = 'operation') then result := TFhirExampleScenarioProcessStepOperation.create()
  else if (propName = 'alternative') then result := AlternativeList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirExampleScenarioProcessStep.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'process') then result := ''
  else if (propName = 'pause') then result := 'boolean'
  else if (propName = 'operation') then result := 'BackboneElement'
  else if (propName = 'alternative') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExampleScenarioProcessStep.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'process') then deletePropertyValue('process', ProcessList, value)
  else if (propName = 'pause') then PauseElement := nil
  else if (propName = 'operation') then OperationElement := nil
  else if (propName = 'alternative') then deletePropertyValue('alternative', AlternativeList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExampleScenarioProcessStep.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'process') then replacePropertyValue('process', ProcessList, existing, new)
  else if (propName = 'pause') then PauseElement := asBoolean(new)
  else if (propName = 'operation') then OperationElement := new as TFhirExampleScenarioProcessStepOperation
  else if (propName = 'alternative') then replacePropertyValue('alternative', AlternativeList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExampleScenarioProcessStep.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'process') then ProcessList.move(source, destination)
  else if (propName = 'alternative') then AlternativeList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirExampleScenarioProcessStep.fhirType : string;
begin
  result := 'ExampleScenario.process.step';
end;

function TFhirExampleScenarioProcessStep.Link : TFhirExampleScenarioProcessStep;
begin
  result := TFhirExampleScenarioProcessStep(inherited Link);
end;

function TFhirExampleScenarioProcessStep.Clone : TFhirExampleScenarioProcessStep;
begin
  result := TFhirExampleScenarioProcessStep(inherited Clone);
end;

function TFhirExampleScenarioProcessStep.equals(other : TObject) : boolean; 
var
  o : TFhirExampleScenarioProcessStep;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExampleScenarioProcessStep)) then
    result := false
  else
  begin
    o := TFhirExampleScenarioProcessStep(other);
    result := compareDeep(processList, o.processList, true) and compareDeep(pauseElement, o.pauseElement, true) and 
      compareDeep(operationElement, o.operationElement, true) and compareDeep(alternativeList, o.alternativeList, true);
  end;
end;

function TFhirExampleScenarioProcessStep.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FprocessList) and isEmptyProp(FPause) and isEmptyProp(FOperation) and isEmptyProp(FalternativeList);
end;

procedure TFhirExampleScenarioProcessStep.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('process');
  fields.add('pause');
  fields.add('operation');
  fields.add('alternative');
end;

function TFhirExampleScenarioProcessStep.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FProcessList.sizeInBytes(magic));
  inc(result, FAlternativeList.sizeInBytes(magic));
end;

function TFhirExampleScenarioProcessStep.GetProcessList : TFhirExampleScenarioProcessList;
begin
  if FProcessList = nil then
    FProcessList := TFhirExampleScenarioProcessList.Create;
  result := FProcessList;
end;

function TFhirExampleScenarioProcessStep.GetHasProcessList : boolean;
begin
  result := (FProcessList <> nil) and (FProcessList.count > 0);
end;

procedure TFhirExampleScenarioProcessStep.SetPause(value : TFhirBoolean);
begin
  FPause.free;
  FPause := value;
end;

function TFhirExampleScenarioProcessStep.GetPauseST : Boolean;
begin
  if FPause = nil then
    result := false
  else
    result := FPause.value;
end;

procedure TFhirExampleScenarioProcessStep.SetPauseST(value : Boolean);
begin
  if FPause = nil then
    FPause := TFhirBoolean.create;
  FPause.value := value
end;

procedure TFhirExampleScenarioProcessStep.SetOperation(value : TFhirExampleScenarioProcessStepOperation);
begin
  FOperation.free;
  FOperation := value;
end;

function TFhirExampleScenarioProcessStep.GetAlternativeList : TFhirExampleScenarioProcessStepAlternativeList;
begin
  if FAlternativeList = nil then
    FAlternativeList := TFhirExampleScenarioProcessStepAlternativeList.Create;
  result := FAlternativeList;
end;

function TFhirExampleScenarioProcessStep.GetHasAlternativeList : boolean;
begin
  result := (FAlternativeList <> nil) and (FAlternativeList.count > 0);
end;

{ TFhirExampleScenarioProcessStepListEnumerator }

constructor TFhirExampleScenarioProcessStepListEnumerator.Create(list : TFhirExampleScenarioProcessStepList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExampleScenarioProcessStepListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExampleScenarioProcessStepListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExampleScenarioProcessStepListEnumerator.GetCurrent : TFhirExampleScenarioProcessStep;
begin
  Result := FList[FIndex];
end;

function TFhirExampleScenarioProcessStepListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirExampleScenarioProcessStepList }

function TFhirExampleScenarioProcessStepList.AddItem(value: TFhirExampleScenarioProcessStep): TFhirExampleScenarioProcessStep;
begin
  assert(value.ClassName = 'TFhirExampleScenarioProcessStep', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExampleScenarioProcessStep');
  add(value);
  result := value;
end;

function TFhirExampleScenarioProcessStepList.Append: TFhirExampleScenarioProcessStep;
begin
  result := TFhirExampleScenarioProcessStep.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExampleScenarioProcessStepList.ClearItems;
begin
  Clear;
end;

function TFhirExampleScenarioProcessStepList.GetEnumerator : TFhirExampleScenarioProcessStepListEnumerator;
begin
  result := TFhirExampleScenarioProcessStepListEnumerator.Create(self.link);
end;

function TFhirExampleScenarioProcessStepList.Clone: TFhirExampleScenarioProcessStepList;
begin
  result := TFhirExampleScenarioProcessStepList(inherited Clone);
end;

function TFhirExampleScenarioProcessStepList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExampleScenarioProcessStepList.GetItemN(index: Integer): TFhirExampleScenarioProcessStep;
begin
  result := TFhirExampleScenarioProcessStep(ObjectByIndex[index]);
end;

function TFhirExampleScenarioProcessStepList.ItemClass: TFslObjectClass;
begin
  result := TFhirExampleScenarioProcessStep;
end;
function TFhirExampleScenarioProcessStepList.IndexOf(value: TFhirExampleScenarioProcessStep): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExampleScenarioProcessStepList.Insert(index: Integer): TFhirExampleScenarioProcessStep;
begin
  result := TFhirExampleScenarioProcessStep.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExampleScenarioProcessStepList.InsertItem(index: Integer; value: TFhirExampleScenarioProcessStep);
begin
  assert(value is TFhirExampleScenarioProcessStep);
  Inherited Insert(index, value);
end;

function TFhirExampleScenarioProcessStepList.Item(index: Integer): TFhirExampleScenarioProcessStep;
begin
  result := TFhirExampleScenarioProcessStep(ObjectByIndex[index]);
end;

function TFhirExampleScenarioProcessStepList.Link: TFhirExampleScenarioProcessStepList;
begin
  result := TFhirExampleScenarioProcessStepList(inherited Link);
end;

procedure TFhirExampleScenarioProcessStepList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExampleScenarioProcessStepList.SetItemByIndex(index: Integer; value: TFhirExampleScenarioProcessStep);
begin
  assert(value is TFhirExampleScenarioProcessStep);
  FhirExampleScenarioProcessSteps[index] := value;
end;

procedure TFhirExampleScenarioProcessStepList.SetItemN(index: Integer; value: TFhirExampleScenarioProcessStep);
begin
  assert(value is TFhirExampleScenarioProcessStep);
  ObjectByIndex[index] := value;
end;

{ TFhirExampleScenarioProcessStepOperation }

constructor TFhirExampleScenarioProcessStepOperation.Create;
begin
  inherited;
end;

destructor TFhirExampleScenarioProcessStepOperation.Destroy;
begin
  FNumber.free;
  FType_.free;
  FName.free;
  FInitiator.free;
  FReceiver.free;
  FDescription.free;
  FInitiatorActive.free;
  FReceiverActive.free;
  FRequest.free;
  FResponse.free;
  inherited;
end;

procedure TFhirExampleScenarioProcessStepOperation.Assign(oSource : TFslObject);
begin
  inherited;
  numberElement := TFhirExampleScenarioProcessStepOperation(oSource).numberElement.Clone;
  type_Element := TFhirExampleScenarioProcessStepOperation(oSource).type_Element.Clone;
  nameElement := TFhirExampleScenarioProcessStepOperation(oSource).nameElement.Clone;
  initiatorElement := TFhirExampleScenarioProcessStepOperation(oSource).initiatorElement.Clone;
  receiverElement := TFhirExampleScenarioProcessStepOperation(oSource).receiverElement.Clone;
  descriptionElement := TFhirExampleScenarioProcessStepOperation(oSource).descriptionElement.Clone;
  initiatorActiveElement := TFhirExampleScenarioProcessStepOperation(oSource).initiatorActiveElement.Clone;
  receiverActiveElement := TFhirExampleScenarioProcessStepOperation(oSource).receiverActiveElement.Clone;
  request := TFhirExampleScenarioProcessStepOperation(oSource).request.Clone;
  response := TFhirExampleScenarioProcessStepOperation(oSource).response.Clone;
end;

procedure TFhirExampleScenarioProcessStepOperation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'number') Then
     list.add(self.link, 'number', FNumber.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'initiator') Then
     list.add(self.link, 'initiator', FInitiator.Link);
  if (child_name = 'receiver') Then
     list.add(self.link, 'receiver', FReceiver.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'initiatorActive') Then
     list.add(self.link, 'initiatorActive', FInitiatorActive.Link);
  if (child_name = 'receiverActive') Then
     list.add(self.link, 'receiverActive', FReceiverActive.Link);
  if (child_name = 'request') Then
     list.add(self.link, 'request', FRequest.Link);
  if (child_name = 'response') Then
     list.add(self.link, 'response', FResponse.Link);
end;

procedure TFhirExampleScenarioProcessStepOperation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'number', 'string', false, TFhirString, FNumber.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'string', false, TFhirString, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'initiator', 'string', false, TFhirString, FInitiator.Link));
  oList.add(TFHIRProperty.create(self, 'receiver', 'string', false, TFhirString, FReceiver.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'markdown', false, TFhirMarkdown, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'initiatorActive', 'boolean', false, TFhirBoolean, FInitiatorActive.Link));
  oList.add(TFHIRProperty.create(self, 'receiverActive', 'boolean', false, TFhirBoolean, FReceiverActive.Link));
  oList.add(TFHIRProperty.create(self, 'request', '', false, TFhirExampleScenarioInstanceContainedInstance, FRequest.Link));
  oList.add(TFHIRProperty.create(self, 'response', '', false, TFhirExampleScenarioInstanceContainedInstance, FResponse.Link));
end;

function TFhirExampleScenarioProcessStepOperation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'number') then
  begin
    NumberElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_Element := asString(propValue);
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'initiator') then
  begin
    InitiatorElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'receiver') then
  begin
    ReceiverElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'initiatorActive') then
  begin
    InitiatorActiveElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'receiverActive') then
  begin
    ReceiverActiveElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'request') then
  begin
    Request := propValue as TFhirExampleScenarioInstanceContainedInstance;
    result := propValue;
  end
  else if (propName = 'response') then
  begin
    Response := propValue as TFhirExampleScenarioInstanceContainedInstance;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExampleScenarioProcessStepOperation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirExampleScenarioProcessStepOperation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'number') then result := TFhirString.create()
  else if (propName = 'type') then result := TFhirString.create()
  else if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'initiator') then result := TFhirString.create()
  else if (propName = 'receiver') then result := TFhirString.create()
  else if (propName = 'description') then result := TFhirMarkdown.create()
  else if (propName = 'initiatorActive') then result := TFhirBoolean.create()
  else if (propName = 'receiverActive') then result := TFhirBoolean.create()
  else if (propName = 'request') then result := TFhirExampleScenarioInstanceContainedInstance.create()
  else if (propName = 'response') then result := TFhirExampleScenarioInstanceContainedInstance.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirExampleScenarioProcessStepOperation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'number') then result := 'string'
  else if (propName = 'type') then result := 'string'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'initiator') then result := 'string'
  else if (propName = 'receiver') then result := 'string'
  else if (propName = 'description') then result := 'markdown'
  else if (propName = 'initiatorActive') then result := 'boolean'
  else if (propName = 'receiverActive') then result := 'boolean'
  else if (propName = 'request') then result := ''
  else if (propName = 'response') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExampleScenarioProcessStepOperation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'number') then NumberElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'initiator') then InitiatorElement := nil
  else if (propName = 'receiver') then ReceiverElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'initiatorActive') then InitiatorActiveElement := nil
  else if (propName = 'receiverActive') then ReceiverActiveElement := nil
  else if (propName = 'request') then RequestElement := nil
  else if (propName = 'response') then ResponseElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExampleScenarioProcessStepOperation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'number') then NumberElement := asString(new)
  else if (propName = 'type') then Type_Element := asString(new)
  else if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'initiator') then InitiatorElement := asString(new)
  else if (propName = 'receiver') then ReceiverElement := asString(new)
  else if (propName = 'description') then DescriptionElement := asMarkdown(new)
  else if (propName = 'initiatorActive') then InitiatorActiveElement := asBoolean(new)
  else if (propName = 'receiverActive') then ReceiverActiveElement := asBoolean(new)
  else if (propName = 'request') then RequestElement := new as TFhirExampleScenarioInstanceContainedInstance
  else if (propName = 'response') then ResponseElement := new as TFhirExampleScenarioInstanceContainedInstance
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExampleScenarioProcessStepOperation.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirExampleScenarioProcessStepOperation.fhirType : string;
begin
  result := 'ExampleScenario.process.step.operation';
end;

function TFhirExampleScenarioProcessStepOperation.Link : TFhirExampleScenarioProcessStepOperation;
begin
  result := TFhirExampleScenarioProcessStepOperation(inherited Link);
end;

function TFhirExampleScenarioProcessStepOperation.Clone : TFhirExampleScenarioProcessStepOperation;
begin
  result := TFhirExampleScenarioProcessStepOperation(inherited Clone);
end;

function TFhirExampleScenarioProcessStepOperation.equals(other : TObject) : boolean; 
var
  o : TFhirExampleScenarioProcessStepOperation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExampleScenarioProcessStepOperation)) then
    result := false
  else
  begin
    o := TFhirExampleScenarioProcessStepOperation(other);
    result := compareDeep(numberElement, o.numberElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(nameElement, o.nameElement, true) and compareDeep(initiatorElement, o.initiatorElement, true) and 
      compareDeep(receiverElement, o.receiverElement, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(initiatorActiveElement, o.initiatorActiveElement, true) and compareDeep(receiverActiveElement, o.receiverActiveElement, true) and 
      compareDeep(requestElement, o.requestElement, true) and compareDeep(responseElement, o.responseElement, true);
  end;
end;

function TFhirExampleScenarioProcessStepOperation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FNumber) and isEmptyProp(FType_) and isEmptyProp(FName) and isEmptyProp(FInitiator) and isEmptyProp(FReceiver) and isEmptyProp(FDescription) and isEmptyProp(FInitiatorActive) and isEmptyProp(FReceiverActive) and isEmptyProp(FRequest) and isEmptyProp(FResponse);
end;

procedure TFhirExampleScenarioProcessStepOperation.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('number');
  fields.add('type');
  fields.add('name');
  fields.add('initiator');
  fields.add('receiver');
  fields.add('description');
  fields.add('initiatorActive');
  fields.add('receiverActive');
  fields.add('request');
  fields.add('response');
end;

function TFhirExampleScenarioProcessStepOperation.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirExampleScenarioProcessStepOperation.SetNumber(value : TFhirString);
begin
  FNumber.free;
  FNumber := value;
end;

function TFhirExampleScenarioProcessStepOperation.GetNumberST : String;
begin
  if FNumber = nil then
    result := ''
  else
    result := FNumber.value;
end;

procedure TFhirExampleScenarioProcessStepOperation.SetNumberST(value : String);
begin
  if value <> '' then
  begin
    if FNumber = nil then
      FNumber := TFhirString.create;
    FNumber.value := value
  end
  else if FNumber <> nil then
    FNumber.value := '';
end;

procedure TFhirExampleScenarioProcessStepOperation.SetType_(value : TFhirString);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirExampleScenarioProcessStepOperation.GetType_ST : String;
begin
  if FType_ = nil then
    result := ''
  else
    result := FType_.value;
end;

procedure TFhirExampleScenarioProcessStepOperation.SetType_ST(value : String);
begin
  if value <> '' then
  begin
    if FType_ = nil then
      FType_ := TFhirString.create;
    FType_.value := value
  end
  else if FType_ <> nil then
    FType_.value := '';
end;

procedure TFhirExampleScenarioProcessStepOperation.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirExampleScenarioProcessStepOperation.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirExampleScenarioProcessStepOperation.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirExampleScenarioProcessStepOperation.SetInitiator(value : TFhirString);
begin
  FInitiator.free;
  FInitiator := value;
end;

function TFhirExampleScenarioProcessStepOperation.GetInitiatorST : String;
begin
  if FInitiator = nil then
    result := ''
  else
    result := FInitiator.value;
end;

procedure TFhirExampleScenarioProcessStepOperation.SetInitiatorST(value : String);
begin
  if value <> '' then
  begin
    if FInitiator = nil then
      FInitiator := TFhirString.create;
    FInitiator.value := value
  end
  else if FInitiator <> nil then
    FInitiator.value := '';
end;

procedure TFhirExampleScenarioProcessStepOperation.SetReceiver(value : TFhirString);
begin
  FReceiver.free;
  FReceiver := value;
end;

function TFhirExampleScenarioProcessStepOperation.GetReceiverST : String;
begin
  if FReceiver = nil then
    result := ''
  else
    result := FReceiver.value;
end;

procedure TFhirExampleScenarioProcessStepOperation.SetReceiverST(value : String);
begin
  if value <> '' then
  begin
    if FReceiver = nil then
      FReceiver := TFhirString.create;
    FReceiver.value := value
  end
  else if FReceiver <> nil then
    FReceiver.value := '';
end;

procedure TFhirExampleScenarioProcessStepOperation.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirExampleScenarioProcessStepOperation.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirExampleScenarioProcessStepOperation.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirExampleScenarioProcessStepOperation.SetInitiatorActive(value : TFhirBoolean);
begin
  FInitiatorActive.free;
  FInitiatorActive := value;
end;

function TFhirExampleScenarioProcessStepOperation.GetInitiatorActiveST : Boolean;
begin
  if FInitiatorActive = nil then
    result := false
  else
    result := FInitiatorActive.value;
end;

procedure TFhirExampleScenarioProcessStepOperation.SetInitiatorActiveST(value : Boolean);
begin
  if FInitiatorActive = nil then
    FInitiatorActive := TFhirBoolean.create;
  FInitiatorActive.value := value
end;

procedure TFhirExampleScenarioProcessStepOperation.SetReceiverActive(value : TFhirBoolean);
begin
  FReceiverActive.free;
  FReceiverActive := value;
end;

function TFhirExampleScenarioProcessStepOperation.GetReceiverActiveST : Boolean;
begin
  if FReceiverActive = nil then
    result := false
  else
    result := FReceiverActive.value;
end;

procedure TFhirExampleScenarioProcessStepOperation.SetReceiverActiveST(value : Boolean);
begin
  if FReceiverActive = nil then
    FReceiverActive := TFhirBoolean.create;
  FReceiverActive.value := value
end;

procedure TFhirExampleScenarioProcessStepOperation.SetRequest(value : TFhirExampleScenarioInstanceContainedInstance);
begin
  FRequest.free;
  FRequest := value;
end;

procedure TFhirExampleScenarioProcessStepOperation.SetResponse(value : TFhirExampleScenarioInstanceContainedInstance);
begin
  FResponse.free;
  FResponse := value;
end;

{ TFhirExampleScenarioProcessStepOperationListEnumerator }

constructor TFhirExampleScenarioProcessStepOperationListEnumerator.Create(list : TFhirExampleScenarioProcessStepOperationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExampleScenarioProcessStepOperationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExampleScenarioProcessStepOperationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExampleScenarioProcessStepOperationListEnumerator.GetCurrent : TFhirExampleScenarioProcessStepOperation;
begin
  Result := FList[FIndex];
end;

function TFhirExampleScenarioProcessStepOperationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirExampleScenarioProcessStepOperationList }

function TFhirExampleScenarioProcessStepOperationList.AddItem(value: TFhirExampleScenarioProcessStepOperation): TFhirExampleScenarioProcessStepOperation;
begin
  assert(value.ClassName = 'TFhirExampleScenarioProcessStepOperation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExampleScenarioProcessStepOperation');
  add(value);
  result := value;
end;

function TFhirExampleScenarioProcessStepOperationList.Append: TFhirExampleScenarioProcessStepOperation;
begin
  result := TFhirExampleScenarioProcessStepOperation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExampleScenarioProcessStepOperationList.ClearItems;
begin
  Clear;
end;

function TFhirExampleScenarioProcessStepOperationList.GetEnumerator : TFhirExampleScenarioProcessStepOperationListEnumerator;
begin
  result := TFhirExampleScenarioProcessStepOperationListEnumerator.Create(self.link);
end;

function TFhirExampleScenarioProcessStepOperationList.Clone: TFhirExampleScenarioProcessStepOperationList;
begin
  result := TFhirExampleScenarioProcessStepOperationList(inherited Clone);
end;

function TFhirExampleScenarioProcessStepOperationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExampleScenarioProcessStepOperationList.GetItemN(index: Integer): TFhirExampleScenarioProcessStepOperation;
begin
  result := TFhirExampleScenarioProcessStepOperation(ObjectByIndex[index]);
end;

function TFhirExampleScenarioProcessStepOperationList.ItemClass: TFslObjectClass;
begin
  result := TFhirExampleScenarioProcessStepOperation;
end;
function TFhirExampleScenarioProcessStepOperationList.IndexOf(value: TFhirExampleScenarioProcessStepOperation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExampleScenarioProcessStepOperationList.Insert(index: Integer): TFhirExampleScenarioProcessStepOperation;
begin
  result := TFhirExampleScenarioProcessStepOperation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExampleScenarioProcessStepOperationList.InsertItem(index: Integer; value: TFhirExampleScenarioProcessStepOperation);
begin
  assert(value is TFhirExampleScenarioProcessStepOperation);
  Inherited Insert(index, value);
end;

function TFhirExampleScenarioProcessStepOperationList.Item(index: Integer): TFhirExampleScenarioProcessStepOperation;
begin
  result := TFhirExampleScenarioProcessStepOperation(ObjectByIndex[index]);
end;

function TFhirExampleScenarioProcessStepOperationList.Link: TFhirExampleScenarioProcessStepOperationList;
begin
  result := TFhirExampleScenarioProcessStepOperationList(inherited Link);
end;

procedure TFhirExampleScenarioProcessStepOperationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExampleScenarioProcessStepOperationList.SetItemByIndex(index: Integer; value: TFhirExampleScenarioProcessStepOperation);
begin
  assert(value is TFhirExampleScenarioProcessStepOperation);
  FhirExampleScenarioProcessStepOperations[index] := value;
end;

procedure TFhirExampleScenarioProcessStepOperationList.SetItemN(index: Integer; value: TFhirExampleScenarioProcessStepOperation);
begin
  assert(value is TFhirExampleScenarioProcessStepOperation);
  ObjectByIndex[index] := value;
end;

{ TFhirExampleScenarioProcessStepAlternative }

constructor TFhirExampleScenarioProcessStepAlternative.Create;
begin
  inherited;
end;

destructor TFhirExampleScenarioProcessStepAlternative.Destroy;
begin
  FTitle.free;
  FDescription.free;
  FStepList.Free;
  inherited;
end;

procedure TFhirExampleScenarioProcessStepAlternative.Assign(oSource : TFslObject);
begin
  inherited;
  titleElement := TFhirExampleScenarioProcessStepAlternative(oSource).titleElement.Clone;
  descriptionElement := TFhirExampleScenarioProcessStepAlternative(oSource).descriptionElement.Clone;
  if (TFhirExampleScenarioProcessStepAlternative(oSource).FStepList = nil) then
  begin
    FStepList.free;
    FStepList := nil;
  end
  else
  begin
    if FStepList = nil then
      FStepList := TFhirExampleScenarioProcessStepList.Create;
    FStepList.Assign(TFhirExampleScenarioProcessStepAlternative(oSource).FStepList);
  end;
end;

procedure TFhirExampleScenarioProcessStepAlternative.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'step') Then
    list.addAll(self, 'step', FStepList);
end;

procedure TFhirExampleScenarioProcessStepAlternative.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'markdown', false, TFhirMarkdown, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'step', '', true, TFhirExampleScenarioProcessStep, FStepList.Link));
end;

function TFhirExampleScenarioProcessStepAlternative.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'title') then
  begin
    TitleElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'step') then
  begin
    StepList.add(propValue as TFhirExampleScenarioProcessStep);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExampleScenarioProcessStepAlternative.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'step') then StepList.insertItem(index, propValue as TFhirExampleScenarioProcessStep)
  else inherited;
end;

function TFhirExampleScenarioProcessStepAlternative.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'title') then result := TFhirString.create()
  else if (propName = 'description') then result := TFhirMarkdown.create()
  else if (propName = 'step') then result := StepList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirExampleScenarioProcessStepAlternative.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'title') then result := 'string'
  else if (propName = 'description') then result := 'markdown'
  else if (propName = 'step') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExampleScenarioProcessStepAlternative.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'title') then TitleElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'step') then deletePropertyValue('step', StepList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExampleScenarioProcessStepAlternative.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'title') then TitleElement := asString(new)
  else if (propName = 'description') then DescriptionElement := asMarkdown(new)
  else if (propName = 'step') then replacePropertyValue('step', StepList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExampleScenarioProcessStepAlternative.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'step') then StepList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirExampleScenarioProcessStepAlternative.fhirType : string;
begin
  result := 'ExampleScenario.process.step.alternative';
end;

function TFhirExampleScenarioProcessStepAlternative.Link : TFhirExampleScenarioProcessStepAlternative;
begin
  result := TFhirExampleScenarioProcessStepAlternative(inherited Link);
end;

function TFhirExampleScenarioProcessStepAlternative.Clone : TFhirExampleScenarioProcessStepAlternative;
begin
  result := TFhirExampleScenarioProcessStepAlternative(inherited Clone);
end;

function TFhirExampleScenarioProcessStepAlternative.equals(other : TObject) : boolean; 
var
  o : TFhirExampleScenarioProcessStepAlternative;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExampleScenarioProcessStepAlternative)) then
    result := false
  else
  begin
    o := TFhirExampleScenarioProcessStepAlternative(other);
    result := compareDeep(titleElement, o.titleElement, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(stepList, o.stepList, true);
  end;
end;

function TFhirExampleScenarioProcessStepAlternative.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FTitle) and isEmptyProp(FDescription) and isEmptyProp(FstepList);
end;

procedure TFhirExampleScenarioProcessStepAlternative.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('title');
  fields.add('description');
  fields.add('step');
end;

function TFhirExampleScenarioProcessStepAlternative.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FStepList.sizeInBytes(magic));
end;

procedure TFhirExampleScenarioProcessStepAlternative.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

function TFhirExampleScenarioProcessStepAlternative.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

procedure TFhirExampleScenarioProcessStepAlternative.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

procedure TFhirExampleScenarioProcessStepAlternative.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirExampleScenarioProcessStepAlternative.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirExampleScenarioProcessStepAlternative.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirExampleScenarioProcessStepAlternative.GetStepList : TFhirExampleScenarioProcessStepList;
begin
  if FStepList = nil then
    FStepList := TFhirExampleScenarioProcessStepList.Create;
  result := FStepList;
end;

function TFhirExampleScenarioProcessStepAlternative.GetHasStepList : boolean;
begin
  result := (FStepList <> nil) and (FStepList.count > 0);
end;

{ TFhirExampleScenarioProcessStepAlternativeListEnumerator }

constructor TFhirExampleScenarioProcessStepAlternativeListEnumerator.Create(list : TFhirExampleScenarioProcessStepAlternativeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExampleScenarioProcessStepAlternativeListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExampleScenarioProcessStepAlternativeListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExampleScenarioProcessStepAlternativeListEnumerator.GetCurrent : TFhirExampleScenarioProcessStepAlternative;
begin
  Result := FList[FIndex];
end;

function TFhirExampleScenarioProcessStepAlternativeListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirExampleScenarioProcessStepAlternativeList }

function TFhirExampleScenarioProcessStepAlternativeList.AddItem(value: TFhirExampleScenarioProcessStepAlternative): TFhirExampleScenarioProcessStepAlternative;
begin
  assert(value.ClassName = 'TFhirExampleScenarioProcessStepAlternative', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExampleScenarioProcessStepAlternative');
  add(value);
  result := value;
end;

function TFhirExampleScenarioProcessStepAlternativeList.Append: TFhirExampleScenarioProcessStepAlternative;
begin
  result := TFhirExampleScenarioProcessStepAlternative.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExampleScenarioProcessStepAlternativeList.ClearItems;
begin
  Clear;
end;

function TFhirExampleScenarioProcessStepAlternativeList.GetEnumerator : TFhirExampleScenarioProcessStepAlternativeListEnumerator;
begin
  result := TFhirExampleScenarioProcessStepAlternativeListEnumerator.Create(self.link);
end;

function TFhirExampleScenarioProcessStepAlternativeList.Clone: TFhirExampleScenarioProcessStepAlternativeList;
begin
  result := TFhirExampleScenarioProcessStepAlternativeList(inherited Clone);
end;

function TFhirExampleScenarioProcessStepAlternativeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExampleScenarioProcessStepAlternativeList.GetItemN(index: Integer): TFhirExampleScenarioProcessStepAlternative;
begin
  result := TFhirExampleScenarioProcessStepAlternative(ObjectByIndex[index]);
end;

function TFhirExampleScenarioProcessStepAlternativeList.ItemClass: TFslObjectClass;
begin
  result := TFhirExampleScenarioProcessStepAlternative;
end;
function TFhirExampleScenarioProcessStepAlternativeList.IndexOf(value: TFhirExampleScenarioProcessStepAlternative): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExampleScenarioProcessStepAlternativeList.Insert(index: Integer): TFhirExampleScenarioProcessStepAlternative;
begin
  result := TFhirExampleScenarioProcessStepAlternative.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExampleScenarioProcessStepAlternativeList.InsertItem(index: Integer; value: TFhirExampleScenarioProcessStepAlternative);
begin
  assert(value is TFhirExampleScenarioProcessStepAlternative);
  Inherited Insert(index, value);
end;

function TFhirExampleScenarioProcessStepAlternativeList.Item(index: Integer): TFhirExampleScenarioProcessStepAlternative;
begin
  result := TFhirExampleScenarioProcessStepAlternative(ObjectByIndex[index]);
end;

function TFhirExampleScenarioProcessStepAlternativeList.Link: TFhirExampleScenarioProcessStepAlternativeList;
begin
  result := TFhirExampleScenarioProcessStepAlternativeList(inherited Link);
end;

procedure TFhirExampleScenarioProcessStepAlternativeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExampleScenarioProcessStepAlternativeList.SetItemByIndex(index: Integer; value: TFhirExampleScenarioProcessStepAlternative);
begin
  assert(value is TFhirExampleScenarioProcessStepAlternative);
  FhirExampleScenarioProcessStepAlternatives[index] := value;
end;

procedure TFhirExampleScenarioProcessStepAlternativeList.SetItemN(index: Integer; value: TFhirExampleScenarioProcessStepAlternative);
begin
  assert(value is TFhirExampleScenarioProcessStepAlternative);
  ObjectByIndex[index] := value;
end;

{ TFhirExampleScenario }

constructor TFhirExampleScenario.Create;
begin
  inherited;
end;

destructor TFhirExampleScenario.Destroy;
begin
  FUrl.free;
  FIdentifierList.Free;
  FVersion.free;
  FName.free;
  FStatus.free;
  FExperimental.free;
  FDate.free;
  FPublisher.free;
  FContactList.Free;
  FUseContextList.Free;
  FJurisdictionList.Free;
  FCopyright.free;
  FPurpose.free;
  FActorList.Free;
  FInstanceList.Free;
  FProcessList.Free;
  FWorkflowList.Free;
  inherited;
end;

procedure TFhirExampleScenario.Assign(oSource : TFslObject);
begin
  inherited;
  urlElement := TFhirExampleScenario(oSource).urlElement.Clone;
  if (TFhirExampleScenario(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirExampleScenario(oSource).FIdentifierList);
  end;
  versionElement := TFhirExampleScenario(oSource).versionElement.Clone;
  nameElement := TFhirExampleScenario(oSource).nameElement.Clone;
  statusElement := TFhirExampleScenario(oSource).statusElement.Clone;
  experimentalElement := TFhirExampleScenario(oSource).experimentalElement.Clone;
  dateElement := TFhirExampleScenario(oSource).dateElement.Clone;
  publisherElement := TFhirExampleScenario(oSource).publisherElement.Clone;
  if (TFhirExampleScenario(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirContactDetailList.Create;
    FContactList.Assign(TFhirExampleScenario(oSource).FContactList);
  end;
  if (TFhirExampleScenario(oSource).FUseContextList = nil) then
  begin
    FUseContextList.free;
    FUseContextList := nil;
  end
  else
  begin
    if FUseContextList = nil then
      FUseContextList := TFhirUsageContextList.Create;
    FUseContextList.Assign(TFhirExampleScenario(oSource).FUseContextList);
  end;
  if (TFhirExampleScenario(oSource).FJurisdictionList = nil) then
  begin
    FJurisdictionList.free;
    FJurisdictionList := nil;
  end
  else
  begin
    if FJurisdictionList = nil then
      FJurisdictionList := TFhirCodeableConceptList.Create;
    FJurisdictionList.Assign(TFhirExampleScenario(oSource).FJurisdictionList);
  end;
  copyrightElement := TFhirExampleScenario(oSource).copyrightElement.Clone;
  purposeElement := TFhirExampleScenario(oSource).purposeElement.Clone;
  if (TFhirExampleScenario(oSource).FActorList = nil) then
  begin
    FActorList.free;
    FActorList := nil;
  end
  else
  begin
    if FActorList = nil then
      FActorList := TFhirExampleScenarioActorList.Create;
    FActorList.Assign(TFhirExampleScenario(oSource).FActorList);
  end;
  if (TFhirExampleScenario(oSource).FInstanceList = nil) then
  begin
    FInstanceList.free;
    FInstanceList := nil;
  end
  else
  begin
    if FInstanceList = nil then
      FInstanceList := TFhirExampleScenarioInstanceList.Create;
    FInstanceList.Assign(TFhirExampleScenario(oSource).FInstanceList);
  end;
  if (TFhirExampleScenario(oSource).FProcessList = nil) then
  begin
    FProcessList.free;
    FProcessList := nil;
  end
  else
  begin
    if FProcessList = nil then
      FProcessList := TFhirExampleScenarioProcessList.Create;
    FProcessList.Assign(TFhirExampleScenario(oSource).FProcessList);
  end;
  if (TFhirExampleScenario(oSource).FWorkflowList = nil) then
  begin
    FWorkflowList.free;
    FWorkflowList := nil;
  end
  else
  begin
    if FWorkflowList = nil then
      FWorkflowList := TFhirCanonicalList.Create;
    FWorkflowList.Assign(TFhirExampleScenario(oSource).FWorkflowList);
  end;
end;

function TFhirExampleScenario.GetResourceType : TFhirResourceType;
begin
  result := frtExampleScenario;
end;

procedure TFhirExampleScenario.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'version') Then
     list.add(self.link, 'version', FVersion.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'experimental') Then
     list.add(self.link, 'experimental', FExperimental.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'publisher') Then
     list.add(self.link, 'publisher', FPublisher.Link);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'useContext') Then
    list.addAll(self, 'useContext', FUseContextList);
  if (child_name = 'jurisdiction') Then
    list.addAll(self, 'jurisdiction', FJurisdictionList);
  if (child_name = 'copyright') Then
     list.add(self.link, 'copyright', FCopyright.Link);
  if (child_name = 'purpose') Then
     list.add(self.link, 'purpose', FPurpose.Link);
  if (child_name = 'actor') Then
    list.addAll(self, 'actor', FActorList);
  if (child_name = 'instance') Then
    list.addAll(self, 'instance', FInstanceList);
  if (child_name = 'process') Then
    list.addAll(self, 'process', FProcessList);
  if (child_name = 'workflow') Then
    list.addAll(self, 'workflow', FWorkflowList);
end;

procedure TFhirExampleScenario.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'url', 'uri', false, TFhirUri, FUrl.Link));
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'version', 'string', false, TFhirString, FVersion.Link));
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'experimental', 'boolean', false, TFhirBoolean, FExperimental.Link));
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));
  oList.add(TFHIRProperty.create(self, 'publisher', 'string', false, TFhirString, FPublisher.Link));
  oList.add(TFHIRProperty.create(self, 'contact', 'ContactDetail', true, TFhirContactDetail, FContactList.Link));
  oList.add(TFHIRProperty.create(self, 'useContext', 'UsageContext', true, TFhirUsageContext, FUseContextList.Link));
  oList.add(TFHIRProperty.create(self, 'jurisdiction', 'CodeableConcept', true, TFhirCodeableConcept, FJurisdictionList.Link));
  oList.add(TFHIRProperty.create(self, 'copyright', 'markdown', false, TFhirMarkdown, FCopyright.Link));
  oList.add(TFHIRProperty.create(self, 'purpose', 'markdown', false, TFhirMarkdown, FPurpose.Link));
  oList.add(TFHIRProperty.create(self, 'actor', 'BackboneElement', true, TFhirExampleScenarioActor, FActorList.Link));
  oList.add(TFHIRProperty.create(self, 'instance', 'BackboneElement', true, TFhirExampleScenarioInstance, FInstanceList.Link));
  oList.add(TFHIRProperty.create(self, 'process', 'BackboneElement', true, TFhirExampleScenarioProcess, FProcessList.Link));
  oList.add(TFHIRProperty.create(self, 'workflow', 'canonical', true, TFhirCanonical, FWorkflowList.Link));
end;

function TFhirExampleScenario.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'url') then
  begin
    UrlElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'experimental') then
  begin
    ExperimentalElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'publisher') then
  begin
    PublisherElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirContactDetail);
    result := propValue;
  end
  else if (propName = 'useContext') then
  begin
    UseContextList.add(propValue as TFhirUsageContext);
    result := propValue;
  end
  else if (propName = 'jurisdiction') then
  begin
    JurisdictionList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'copyright') then
  begin
    CopyrightElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'purpose') then
  begin
    PurposeElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'actor') then
  begin
    ActorList.add(propValue as TFhirExampleScenarioActor);
    result := propValue;
  end
  else if (propName = 'instance') then
  begin
    InstanceList.add(propValue as TFhirExampleScenarioInstance);
    result := propValue;
  end
  else if (propName = 'process') then
  begin
    ProcessList.add(propValue as TFhirExampleScenarioProcess);
    result := propValue;
  end
  else if (propName = 'workflow') then
  begin
    WorkflowList.add(asCanonical(propValue)){2};     result := propValue;

  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExampleScenario.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirContactDetail)
  else if (propName = 'useContext') then UseContextList.insertItem(index, propValue as TFhirUsageContext)
  else if (propName = 'jurisdiction') then JurisdictionList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'actor') then ActorList.insertItem(index, propValue as TFhirExampleScenarioActor)
  else if (propName = 'instance') then InstanceList.insertItem(index, propValue as TFhirExampleScenarioInstance)
  else if (propName = 'process') then ProcessList.insertItem(index, propValue as TFhirExampleScenarioProcess)
  else if (propName = 'workflow') then WorkflowList.insertItem(index, asCanonical(propValue))
  else inherited;
end;

function TFhirExampleScenario.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'url') then result := TFhirUri.create()
  else if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'version') then result := TFhirString.create()
  else if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[PublicationStatusNull], CODES_TFhirPublicationStatusEnum[PublicationStatusNull]) 
  else if (propName = 'experimental') then result := TFhirBoolean.create()
  else if (propName = 'date') then result := TFhirDateTime.create()
  else if (propName = 'publisher') then result := TFhirString.create()
  else if (propName = 'contact') then result := ContactList.new()
  else if (propName = 'useContext') then result := UseContextList.new()
  else if (propName = 'jurisdiction') then result := JurisdictionList.new()
  else if (propName = 'copyright') then result := TFhirMarkdown.create()
  else if (propName = 'purpose') then result := TFhirMarkdown.create()
  else if (propName = 'actor') then result := ActorList.new()
  else if (propName = 'instance') then result := InstanceList.new()
  else if (propName = 'process') then result := ProcessList.new()
  else if (propName = 'workflow') then result := WorkflowList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirExampleScenario.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'url') then result := 'uri'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'version') then result := 'string'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'experimental') then result := 'boolean'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'publisher') then result := 'string'
  else if (propName = 'contact') then result := 'ContactDetail'
  else if (propName = 'useContext') then result := 'UsageContext'
  else if (propName = 'jurisdiction') then result := 'CodeableConcept'
  else if (propName = 'copyright') then result := 'markdown'
  else if (propName = 'purpose') then result := 'markdown'
  else if (propName = 'actor') then result := 'BackboneElement'
  else if (propName = 'instance') then result := 'BackboneElement'
  else if (propName = 'process') then result := 'BackboneElement'
  else if (propName = 'workflow') then result := 'canonical'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExampleScenario.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := nil
  else if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'version') then VersionElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'experimental') then ExperimentalElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'publisher') then PublisherElement := nil
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value)
  else if (propName = 'useContext') then deletePropertyValue('useContext', UseContextList, value)
  else if (propName = 'jurisdiction') then deletePropertyValue('jurisdiction', JurisdictionList, value)
  else if (propName = 'copyright') then CopyrightElement := nil
  else if (propName = 'purpose') then PurposeElement := nil
  else if (propName = 'actor') then deletePropertyValue('actor', ActorList, value)
  else if (propName = 'instance') then deletePropertyValue('instance', InstanceList, value)
  else if (propName = 'process') then deletePropertyValue('process', ProcessList, value)
  else if (propName = 'workflow') then deletePropertyValue('workflow', WorkflowList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExampleScenario.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := asUri(new)
  else if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'version') then VersionElement := asString(new)
  else if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, new)
  else if (propName = 'experimental') then ExperimentalElement := asBoolean(new)
  else if (propName = 'date') then DateElement := asDateTime(new)
  else if (propName = 'publisher') then PublisherElement := asString(new)
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new)
  else if (propName = 'useContext') then replacePropertyValue('useContext', UseContextList, existing, new)
  else if (propName = 'jurisdiction') then replacePropertyValue('jurisdiction', JurisdictionList, existing, new)
  else if (propName = 'copyright') then CopyrightElement := asMarkdown(new)
  else if (propName = 'purpose') then PurposeElement := asMarkdown(new)
  else if (propName = 'actor') then replacePropertyValue('actor', ActorList, existing, new)
  else if (propName = 'instance') then replacePropertyValue('instance', InstanceList, existing, new)
  else if (propName = 'process') then replacePropertyValue('process', ProcessList, existing, new)
  else if (propName = 'workflow') then replacePropertyValue('workflow', WorkflowList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExampleScenario.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'contact') then ContactList.move(source, destination)
  else if (propName = 'useContext') then UseContextList.move(source, destination)
  else if (propName = 'jurisdiction') then JurisdictionList.move(source, destination)
  else if (propName = 'actor') then ActorList.move(source, destination)
  else if (propName = 'instance') then InstanceList.move(source, destination)
  else if (propName = 'process') then ProcessList.move(source, destination)
  else if (propName = 'workflow') then WorkflowList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirExampleScenario.fhirType : string;
begin
  result := 'ExampleScenario';
end;

function TFhirExampleScenario.Link : TFhirExampleScenario;
begin
  result := TFhirExampleScenario(inherited Link);
end;

function TFhirExampleScenario.Clone : TFhirExampleScenario;
begin
  result := TFhirExampleScenario(inherited Clone);
end;

function TFhirExampleScenario.equals(other : TObject) : boolean; 
var
  o : TFhirExampleScenario;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExampleScenario)) then
    result := false
  else
  begin
    o := TFhirExampleScenario(other);
    result := compareDeep(urlElement, o.urlElement, true) and compareDeep(identifierList, o.identifierList, true) and 
      compareDeep(versionElement, o.versionElement, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(experimentalElement, o.experimentalElement, true) and 
      compareDeep(dateElement, o.dateElement, true) and compareDeep(publisherElement, o.publisherElement, true) and 
      compareDeep(contactList, o.contactList, true) and compareDeep(useContextList, o.useContextList, true) and 
      compareDeep(jurisdictionList, o.jurisdictionList, true) and compareDeep(copyrightElement, o.copyrightElement, true) and 
      compareDeep(purposeElement, o.purposeElement, true) and compareDeep(actorList, o.actorList, true) and 
      compareDeep(instanceList, o.instanceList, true) and compareDeep(processList, o.processList, true) and 
      compareDeep(workflowList, o.workflowList, true);
  end;
end;

function TFhirExampleScenario.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FUrl) and isEmptyProp(FidentifierList) and isEmptyProp(FVersion) and isEmptyProp(FName) and isEmptyProp(FStatus) and isEmptyProp(FExperimental) and isEmptyProp(FDate) and isEmptyProp(FPublisher) and isEmptyProp(FcontactList) and isEmptyProp(FuseContextList) and isEmptyProp(FjurisdictionList) and isEmptyProp(FCopyright) and isEmptyProp(FPurpose) and isEmptyProp(FactorList) and isEmptyProp(FinstanceList) and isEmptyProp(FprocessList) and isEmptyProp(FworkflowList);
end;

procedure TFhirExampleScenario.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('url');
  fields.add('identifier');
  fields.add('version');
  fields.add('name');
  fields.add('status');
  fields.add('experimental');
  fields.add('date');
  fields.add('publisher');
  fields.add('contact');
  fields.add('useContext');
  fields.add('jurisdiction');
  fields.add('copyright');
  fields.add('purpose');
  fields.add('actor');
  fields.add('instance');
  fields.add('process');
  fields.add('workflow');
end;

function TFhirExampleScenario.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FContactList.sizeInBytes(magic));
  inc(result, FUseContextList.sizeInBytes(magic));
  inc(result, FJurisdictionList.sizeInBytes(magic));
  inc(result, FActorList.sizeInBytes(magic));
  inc(result, FInstanceList.sizeInBytes(magic));
  inc(result, FProcessList.sizeInBytes(magic));
  inc(result, FWorkflowList.sizeInBytes(magic));
end;

procedure TFhirExampleScenario.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

function TFhirExampleScenario.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

procedure TFhirExampleScenario.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

function TFhirExampleScenario.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirExampleScenario.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirExampleScenario.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

function TFhirExampleScenario.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

procedure TFhirExampleScenario.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

procedure TFhirExampleScenario.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirExampleScenario.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirExampleScenario.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirExampleScenario.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirExampleScenario.GetStatusST : TFhirPublicationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirPublicationStatusEnum(0)
  else
    result := TFhirPublicationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirPublicationStatusEnum, FStatus.value));
end;

procedure TFhirExampleScenario.SetStatusST(value : TFhirPublicationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[value], CODES_TFhirPublicationStatusEnum[value]);
end;

procedure TFhirExampleScenario.SetExperimental(value : TFhirBoolean);
begin
  FExperimental.free;
  FExperimental := value;
end;

function TFhirExampleScenario.GetExperimentalST : Boolean;
begin
  if FExperimental = nil then
    result := false
  else
    result := FExperimental.value;
end;

procedure TFhirExampleScenario.SetExperimentalST(value : Boolean);
begin
  if FExperimental = nil then
    FExperimental := TFhirBoolean.create;
  FExperimental.value := value
end;

procedure TFhirExampleScenario.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

function TFhirExampleScenario.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirExampleScenario.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

procedure TFhirExampleScenario.SetPublisher(value : TFhirString);
begin
  FPublisher.free;
  FPublisher := value;
end;

function TFhirExampleScenario.GetPublisherST : String;
begin
  if FPublisher = nil then
    result := ''
  else
    result := FPublisher.value;
end;

procedure TFhirExampleScenario.SetPublisherST(value : String);
begin
  if value <> '' then
  begin
    if FPublisher = nil then
      FPublisher := TFhirString.create;
    FPublisher.value := value
  end
  else if FPublisher <> nil then
    FPublisher.value := '';
end;

function TFhirExampleScenario.GetContactList : TFhirContactDetailList;
begin
  if FContactList = nil then
    FContactList := TFhirContactDetailList.Create;
  result := FContactList;
end;

function TFhirExampleScenario.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

function TFhirExampleScenario.GetUseContextList : TFhirUsageContextList;
begin
  if FUseContextList = nil then
    FUseContextList := TFhirUsageContextList.Create;
  result := FUseContextList;
end;

function TFhirExampleScenario.GetHasUseContextList : boolean;
begin
  result := (FUseContextList <> nil) and (FUseContextList.count > 0);
end;

function TFhirExampleScenario.GetJurisdictionList : TFhirCodeableConceptList;
begin
  if FJurisdictionList = nil then
    FJurisdictionList := TFhirCodeableConceptList.Create;
  result := FJurisdictionList;
end;

function TFhirExampleScenario.GetHasJurisdictionList : boolean;
begin
  result := (FJurisdictionList <> nil) and (FJurisdictionList.count > 0);
end;

procedure TFhirExampleScenario.SetCopyright(value : TFhirMarkdown);
begin
  FCopyright.free;
  FCopyright := value;
end;

function TFhirExampleScenario.GetCopyrightST : String;
begin
  if FCopyright = nil then
    result := ''
  else
    result := FCopyright.value;
end;

procedure TFhirExampleScenario.SetCopyrightST(value : String);
begin
  if value <> '' then
  begin
    if FCopyright = nil then
      FCopyright := TFhirMarkdown.create;
    FCopyright.value := value
  end
  else if FCopyright <> nil then
    FCopyright.value := '';
end;

procedure TFhirExampleScenario.SetPurpose(value : TFhirMarkdown);
begin
  FPurpose.free;
  FPurpose := value;
end;

function TFhirExampleScenario.GetPurposeST : String;
begin
  if FPurpose = nil then
    result := ''
  else
    result := FPurpose.value;
end;

procedure TFhirExampleScenario.SetPurposeST(value : String);
begin
  if value <> '' then
  begin
    if FPurpose = nil then
      FPurpose := TFhirMarkdown.create;
    FPurpose.value := value
  end
  else if FPurpose <> nil then
    FPurpose.value := '';
end;

function TFhirExampleScenario.GetActorList : TFhirExampleScenarioActorList;
begin
  if FActorList = nil then
    FActorList := TFhirExampleScenarioActorList.Create;
  result := FActorList;
end;

function TFhirExampleScenario.GetHasActorList : boolean;
begin
  result := (FActorList <> nil) and (FActorList.count > 0);
end;

function TFhirExampleScenario.GetInstanceList : TFhirExampleScenarioInstanceList;
begin
  if FInstanceList = nil then
    FInstanceList := TFhirExampleScenarioInstanceList.Create;
  result := FInstanceList;
end;

function TFhirExampleScenario.GetHasInstanceList : boolean;
begin
  result := (FInstanceList <> nil) and (FInstanceList.count > 0);
end;

function TFhirExampleScenario.GetProcessList : TFhirExampleScenarioProcessList;
begin
  if FProcessList = nil then
    FProcessList := TFhirExampleScenarioProcessList.Create;
  result := FProcessList;
end;

function TFhirExampleScenario.GetHasProcessList : boolean;
begin
  result := (FProcessList <> nil) and (FProcessList.count > 0);
end;

function TFhirExampleScenario.GetWorkflowList : TFhirCanonicalList;
begin
  if FWorkflowList = nil then
    FWorkflowList := TFhirCanonicalList.Create;
  result := FWorkflowList;
end;

function TFhirExampleScenario.GetHasWorkflowList : boolean;
begin
  result := (FWorkflowList <> nil) and (FWorkflowList.count > 0);
end;

{ TFhirExampleScenarioListEnumerator }

constructor TFhirExampleScenarioListEnumerator.Create(list : TFhirExampleScenarioList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExampleScenarioListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExampleScenarioListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExampleScenarioListEnumerator.GetCurrent : TFhirExampleScenario;
begin
  Result := FList[FIndex];
end;

function TFhirExampleScenarioListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirExampleScenarioList }

function TFhirExampleScenarioList.AddItem(value: TFhirExampleScenario): TFhirExampleScenario;
begin
  assert(value.ClassName = 'TFhirExampleScenario', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExampleScenario');
  add(value);
  result := value;
end;

function TFhirExampleScenarioList.Append: TFhirExampleScenario;
begin
  result := TFhirExampleScenario.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExampleScenarioList.ClearItems;
begin
  Clear;
end;

function TFhirExampleScenarioList.GetEnumerator : TFhirExampleScenarioListEnumerator;
begin
  result := TFhirExampleScenarioListEnumerator.Create(self.link);
end;

function TFhirExampleScenarioList.Clone: TFhirExampleScenarioList;
begin
  result := TFhirExampleScenarioList(inherited Clone);
end;

function TFhirExampleScenarioList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExampleScenarioList.GetItemN(index: Integer): TFhirExampleScenario;
begin
  result := TFhirExampleScenario(ObjectByIndex[index]);
end;

function TFhirExampleScenarioList.ItemClass: TFslObjectClass;
begin
  result := TFhirExampleScenario;
end;
function TFhirExampleScenarioList.IndexOf(value: TFhirExampleScenario): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExampleScenarioList.Insert(index: Integer): TFhirExampleScenario;
begin
  result := TFhirExampleScenario.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExampleScenarioList.InsertItem(index: Integer; value: TFhirExampleScenario);
begin
  assert(value is TFhirExampleScenario);
  Inherited Insert(index, value);
end;

function TFhirExampleScenarioList.Item(index: Integer): TFhirExampleScenario;
begin
  result := TFhirExampleScenario(ObjectByIndex[index]);
end;

function TFhirExampleScenarioList.Link: TFhirExampleScenarioList;
begin
  result := TFhirExampleScenarioList(inherited Link);
end;

procedure TFhirExampleScenarioList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExampleScenarioList.SetItemByIndex(index: Integer; value: TFhirExampleScenario);
begin
  assert(value is TFhirExampleScenario);
  FhirExampleScenarios[index] := value;
end;

procedure TFhirExampleScenarioList.SetItemN(index: Integer; value: TFhirExampleScenario);
begin
  assert(value is TFhirExampleScenario);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_EXAMPLESCENARIO}
{$IFDEF FHIR_GRAPHDEFINITION}
{ TFhirGraphDefinitionLink }

constructor TFhirGraphDefinitionLink.Create;
begin
  inherited;
end;

destructor TFhirGraphDefinitionLink.Destroy;
begin
  FPath.free;
  FSliceName.free;
  FMin.free;
  FMax.free;
  FDescription.free;
  FTargetList.Free;
  inherited;
end;

procedure TFhirGraphDefinitionLink.Assign(oSource : TFslObject);
begin
  inherited;
  pathElement := TFhirGraphDefinitionLink(oSource).pathElement.Clone;
  sliceNameElement := TFhirGraphDefinitionLink(oSource).sliceNameElement.Clone;
  minElement := TFhirGraphDefinitionLink(oSource).minElement.Clone;
  maxElement := TFhirGraphDefinitionLink(oSource).maxElement.Clone;
  descriptionElement := TFhirGraphDefinitionLink(oSource).descriptionElement.Clone;
  if (TFhirGraphDefinitionLink(oSource).FTargetList = nil) then
  begin
    FTargetList.free;
    FTargetList := nil;
  end
  else
  begin
    if FTargetList = nil then
      FTargetList := TFhirGraphDefinitionLinkTargetList.Create;
    FTargetList.Assign(TFhirGraphDefinitionLink(oSource).FTargetList);
  end;
end;

procedure TFhirGraphDefinitionLink.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'path') Then
     list.add(self.link, 'path', FPath.Link);
  if (child_name = 'sliceName') Then
     list.add(self.link, 'sliceName', FSliceName.Link);
  if (child_name = 'min') Then
     list.add(self.link, 'min', FMin.Link);
  if (child_name = 'max') Then
     list.add(self.link, 'max', FMax.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'target') Then
    list.addAll(self, 'target', FTargetList);
end;

procedure TFhirGraphDefinitionLink.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'path', 'string', false, TFhirString, FPath.Link));
  oList.add(TFHIRProperty.create(self, 'sliceName', 'string', false, TFhirString, FSliceName.Link));
  oList.add(TFHIRProperty.create(self, 'min', 'integer', false, TFhirInteger, FMin.Link));
  oList.add(TFHIRProperty.create(self, 'max', 'string', false, TFhirString, FMax.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'target', 'BackboneElement', true, TFhirGraphDefinitionLinkTarget, FTargetList.Link));
end;

function TFhirGraphDefinitionLink.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'path') then
  begin
    PathElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'sliceName') then
  begin
    SliceNameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'min') then
  begin
    MinElement := asInteger(propValue);
    result := propValue;
  end
  else if (propName = 'max') then
  begin
    MaxElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'target') then
  begin
    TargetList.add(propValue as TFhirGraphDefinitionLinkTarget);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirGraphDefinitionLink.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'target') then TargetList.insertItem(index, propValue as TFhirGraphDefinitionLinkTarget)
  else inherited;
end;

function TFhirGraphDefinitionLink.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'path') then result := TFhirString.create()
  else if (propName = 'sliceName') then result := TFhirString.create()
  else if (propName = 'min') then result := TFhirInteger.create()
  else if (propName = 'max') then result := TFhirString.create()
  else if (propName = 'description') then result := TFhirString.create()
  else if (propName = 'target') then result := TargetList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirGraphDefinitionLink.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'path') then result := 'string'
  else if (propName = 'sliceName') then result := 'string'
  else if (propName = 'min') then result := 'integer'
  else if (propName = 'max') then result := 'string'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'target') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirGraphDefinitionLink.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'path') then PathElement := nil
  else if (propName = 'sliceName') then SliceNameElement := nil
  else if (propName = 'min') then MinElement := nil
  else if (propName = 'max') then MaxElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'target') then deletePropertyValue('target', TargetList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirGraphDefinitionLink.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'path') then PathElement := asString(new)
  else if (propName = 'sliceName') then SliceNameElement := asString(new)
  else if (propName = 'min') then MinElement := asInteger(new)
  else if (propName = 'max') then MaxElement := asString(new)
  else if (propName = 'description') then DescriptionElement := asString(new)
  else if (propName = 'target') then replacePropertyValue('target', TargetList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirGraphDefinitionLink.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'target') then TargetList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirGraphDefinitionLink.fhirType : string;
begin
  result := 'GraphDefinition.link';
end;

function TFhirGraphDefinitionLink.Link : TFhirGraphDefinitionLink;
begin
  result := TFhirGraphDefinitionLink(inherited Link);
end;

function TFhirGraphDefinitionLink.Clone : TFhirGraphDefinitionLink;
begin
  result := TFhirGraphDefinitionLink(inherited Clone);
end;

function TFhirGraphDefinitionLink.equals(other : TObject) : boolean; 
var
  o : TFhirGraphDefinitionLink;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirGraphDefinitionLink)) then
    result := false
  else
  begin
    o := TFhirGraphDefinitionLink(other);
    result := compareDeep(pathElement, o.pathElement, true) and compareDeep(sliceNameElement, o.sliceNameElement, true) and 
      compareDeep(minElement, o.minElement, true) and compareDeep(maxElement, o.maxElement, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(targetList, o.targetList, true);
  end;
end;

function TFhirGraphDefinitionLink.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FPath) and isEmptyProp(FSliceName) and isEmptyProp(FMin) and isEmptyProp(FMax) and isEmptyProp(FDescription) and isEmptyProp(FtargetList);
end;

procedure TFhirGraphDefinitionLink.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('path');
  fields.add('sliceName');
  fields.add('min');
  fields.add('max');
  fields.add('description');
  fields.add('target');
end;

function TFhirGraphDefinitionLink.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FTargetList.sizeInBytes(magic));
end;

procedure TFhirGraphDefinitionLink.SetPath(value : TFhirString);
begin
  FPath.free;
  FPath := value;
end;

function TFhirGraphDefinitionLink.GetPathST : String;
begin
  if FPath = nil then
    result := ''
  else
    result := FPath.value;
end;

procedure TFhirGraphDefinitionLink.SetPathST(value : String);
begin
  if value <> '' then
  begin
    if FPath = nil then
      FPath := TFhirString.create;
    FPath.value := value
  end
  else if FPath <> nil then
    FPath.value := '';
end;

procedure TFhirGraphDefinitionLink.SetSliceName(value : TFhirString);
begin
  FSliceName.free;
  FSliceName := value;
end;

function TFhirGraphDefinitionLink.GetSliceNameST : String;
begin
  if FSliceName = nil then
    result := ''
  else
    result := FSliceName.value;
end;

procedure TFhirGraphDefinitionLink.SetSliceNameST(value : String);
begin
  if value <> '' then
  begin
    if FSliceName = nil then
      FSliceName := TFhirString.create;
    FSliceName.value := value
  end
  else if FSliceName <> nil then
    FSliceName.value := '';
end;

procedure TFhirGraphDefinitionLink.SetMin(value : TFhirInteger);
begin
  FMin.free;
  FMin := value;
end;

function TFhirGraphDefinitionLink.GetMinST : String;
begin
  if FMin = nil then
    result := ''
  else
    result := FMin.value;
end;

procedure TFhirGraphDefinitionLink.SetMinST(value : String);
begin
  if value <> '' then
  begin
    if FMin = nil then
      FMin := TFhirInteger.create;
    FMin.value := value
  end
  else if FMin <> nil then
    FMin.value := '';
end;

procedure TFhirGraphDefinitionLink.SetMax(value : TFhirString);
begin
  FMax.free;
  FMax := value;
end;

function TFhirGraphDefinitionLink.GetMaxST : String;
begin
  if FMax = nil then
    result := ''
  else
    result := FMax.value;
end;

procedure TFhirGraphDefinitionLink.SetMaxST(value : String);
begin
  if value <> '' then
  begin
    if FMax = nil then
      FMax := TFhirString.create;
    FMax.value := value
  end
  else if FMax <> nil then
    FMax.value := '';
end;

procedure TFhirGraphDefinitionLink.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirGraphDefinitionLink.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirGraphDefinitionLink.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirGraphDefinitionLink.GetTargetList : TFhirGraphDefinitionLinkTargetList;
begin
  if FTargetList = nil then
    FTargetList := TFhirGraphDefinitionLinkTargetList.Create;
  result := FTargetList;
end;

function TFhirGraphDefinitionLink.GetHasTargetList : boolean;
begin
  result := (FTargetList <> nil) and (FTargetList.count > 0);
end;

{ TFhirGraphDefinitionLinkListEnumerator }

constructor TFhirGraphDefinitionLinkListEnumerator.Create(list : TFhirGraphDefinitionLinkList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirGraphDefinitionLinkListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirGraphDefinitionLinkListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirGraphDefinitionLinkListEnumerator.GetCurrent : TFhirGraphDefinitionLink;
begin
  Result := FList[FIndex];
end;

function TFhirGraphDefinitionLinkListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirGraphDefinitionLinkList }

function TFhirGraphDefinitionLinkList.AddItem(value: TFhirGraphDefinitionLink): TFhirGraphDefinitionLink;
begin
  assert(value.ClassName = 'TFhirGraphDefinitionLink', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirGraphDefinitionLink');
  add(value);
  result := value;
end;

function TFhirGraphDefinitionLinkList.Append: TFhirGraphDefinitionLink;
begin
  result := TFhirGraphDefinitionLink.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirGraphDefinitionLinkList.ClearItems;
begin
  Clear;
end;

function TFhirGraphDefinitionLinkList.GetEnumerator : TFhirGraphDefinitionLinkListEnumerator;
begin
  result := TFhirGraphDefinitionLinkListEnumerator.Create(self.link);
end;

function TFhirGraphDefinitionLinkList.Clone: TFhirGraphDefinitionLinkList;
begin
  result := TFhirGraphDefinitionLinkList(inherited Clone);
end;

function TFhirGraphDefinitionLinkList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirGraphDefinitionLinkList.GetItemN(index: Integer): TFhirGraphDefinitionLink;
begin
  result := TFhirGraphDefinitionLink(ObjectByIndex[index]);
end;

function TFhirGraphDefinitionLinkList.ItemClass: TFslObjectClass;
begin
  result := TFhirGraphDefinitionLink;
end;
function TFhirGraphDefinitionLinkList.IndexOf(value: TFhirGraphDefinitionLink): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirGraphDefinitionLinkList.Insert(index: Integer): TFhirGraphDefinitionLink;
begin
  result := TFhirGraphDefinitionLink.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirGraphDefinitionLinkList.InsertItem(index: Integer; value: TFhirGraphDefinitionLink);
begin
  assert(value is TFhirGraphDefinitionLink);
  Inherited Insert(index, value);
end;

function TFhirGraphDefinitionLinkList.Item(index: Integer): TFhirGraphDefinitionLink;
begin
  result := TFhirGraphDefinitionLink(ObjectByIndex[index]);
end;

function TFhirGraphDefinitionLinkList.Link: TFhirGraphDefinitionLinkList;
begin
  result := TFhirGraphDefinitionLinkList(inherited Link);
end;

procedure TFhirGraphDefinitionLinkList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirGraphDefinitionLinkList.SetItemByIndex(index: Integer; value: TFhirGraphDefinitionLink);
begin
  assert(value is TFhirGraphDefinitionLink);
  FhirGraphDefinitionLinks[index] := value;
end;

procedure TFhirGraphDefinitionLinkList.SetItemN(index: Integer; value: TFhirGraphDefinitionLink);
begin
  assert(value is TFhirGraphDefinitionLink);
  ObjectByIndex[index] := value;
end;

{ TFhirGraphDefinitionLinkTarget }

constructor TFhirGraphDefinitionLinkTarget.Create;
begin
  inherited;
end;

destructor TFhirGraphDefinitionLinkTarget.Destroy;
begin
  FType_.free;
  FParams.free;
  FProfile.free;
  FCompartmentList.Free;
  FLink_List.Free;
  inherited;
end;

procedure TFhirGraphDefinitionLinkTarget.Assign(oSource : TFslObject);
begin
  inherited;
  type_Element := TFhirGraphDefinitionLinkTarget(oSource).type_Element.Clone;
  paramsElement := TFhirGraphDefinitionLinkTarget(oSource).paramsElement.Clone;
  profileElement := TFhirGraphDefinitionLinkTarget(oSource).profileElement.Clone;
  if (TFhirGraphDefinitionLinkTarget(oSource).FCompartmentList = nil) then
  begin
    FCompartmentList.free;
    FCompartmentList := nil;
  end
  else
  begin
    if FCompartmentList = nil then
      FCompartmentList := TFhirGraphDefinitionLinkTargetCompartmentList.Create;
    FCompartmentList.Assign(TFhirGraphDefinitionLinkTarget(oSource).FCompartmentList);
  end;
  if (TFhirGraphDefinitionLinkTarget(oSource).FLink_List = nil) then
  begin
    FLink_List.free;
    FLink_List := nil;
  end
  else
  begin
    if FLink_List = nil then
      FLink_List := TFhirGraphDefinitionLinkList.Create;
    FLink_List.Assign(TFhirGraphDefinitionLinkTarget(oSource).FLink_List);
  end;
end;

procedure TFhirGraphDefinitionLinkTarget.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'params') Then
     list.add(self.link, 'params', FParams.Link);
  if (child_name = 'profile') Then
     list.add(self.link, 'profile', FProfile.Link);
  if (child_name = 'compartment') Then
    list.addAll(self, 'compartment', FCompartmentList);
  if (child_name = 'link') Then
    list.addAll(self, 'link', FLink_List);
end;

procedure TFhirGraphDefinitionLinkTarget.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFhirEnum, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'params', 'string', false, TFhirString, FParams.Link));
  oList.add(TFHIRProperty.create(self, 'profile', 'canonical', false, TFhirCanonical, FProfile.Link));
  oList.add(TFHIRProperty.create(self, 'compartment', 'BackboneElement', true, TFhirGraphDefinitionLinkTargetCompartment, FCompartmentList.Link));
  oList.add(TFHIRProperty.create(self, 'link', '', true, TFhirGraphDefinitionLink, FLink_List.Link));
end;

function TFhirGraphDefinitionLinkTarget.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum, propValue);
    result := propValue;
  end
  else if (propName = 'params') then
  begin
    ParamsElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'profile') then
  begin
    ProfileElement := asCanonical(propValue);
    result := propValue;
  end
  else if (propName = 'compartment') then
  begin
    CompartmentList.add(propValue as TFhirGraphDefinitionLinkTargetCompartment);
    result := propValue;
  end
  else if (propName = 'link') then
  begin
    Link_List.add(propValue as TFhirGraphDefinitionLink);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirGraphDefinitionLinkTarget.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'compartment') then CompartmentList.insertItem(index, propValue as TFhirGraphDefinitionLinkTargetCompartment)
  else if (propName = 'link') then Link_List.insertItem(index, propValue as TFhirGraphDefinitionLink)
  else inherited;
end;

function TFhirGraphDefinitionLinkTarget.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirEnum.create(SYSTEMS_TFhirResourceTypesEnum[ResourceTypesNull], CODES_TFhirResourceTypesEnum[ResourceTypesNull]) 
  else if (propName = 'params') then result := TFhirString.create()
  else if (propName = 'profile') then result := TFhirCanonical.create()
  else if (propName = 'compartment') then result := CompartmentList.new()
  else if (propName = 'link') then result := Link_List.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirGraphDefinitionLinkTarget.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'code'
  else if (propName = 'params') then result := 'string'
  else if (propName = 'profile') then result := 'canonical'
  else if (propName = 'compartment') then result := 'BackboneElement'
  else if (propName = 'link') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirGraphDefinitionLinkTarget.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'params') then ParamsElement := nil
  else if (propName = 'profile') then ProfileElement := nil
  else if (propName = 'compartment') then deletePropertyValue('compartment', CompartmentList, value)
  else if (propName = 'link') then deletePropertyValue('link', Link_List, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirGraphDefinitionLinkTarget.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum, new)
  else if (propName = 'params') then ParamsElement := asString(new)
  else if (propName = 'profile') then ProfileElement := asCanonical(new)
  else if (propName = 'compartment') then replacePropertyValue('compartment', CompartmentList, existing, new)
  else if (propName = 'link') then replacePropertyValue('link', Link_List, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirGraphDefinitionLinkTarget.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'compartment') then CompartmentList.move(source, destination)
  else if (propName = 'link') then Link_List.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirGraphDefinitionLinkTarget.fhirType : string;
begin
  result := 'GraphDefinition.link.target';
end;

function TFhirGraphDefinitionLinkTarget.Link : TFhirGraphDefinitionLinkTarget;
begin
  result := TFhirGraphDefinitionLinkTarget(inherited Link);
end;

function TFhirGraphDefinitionLinkTarget.Clone : TFhirGraphDefinitionLinkTarget;
begin
  result := TFhirGraphDefinitionLinkTarget(inherited Clone);
end;

function TFhirGraphDefinitionLinkTarget.equals(other : TObject) : boolean; 
var
  o : TFhirGraphDefinitionLinkTarget;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirGraphDefinitionLinkTarget)) then
    result := false
  else
  begin
    o := TFhirGraphDefinitionLinkTarget(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(paramsElement, o.paramsElement, true) and 
      compareDeep(profileElement, o.profileElement, true) and compareDeep(compartmentList, o.compartmentList, true) and 
      compareDeep(link_List, o.link_List, true);
  end;
end;

function TFhirGraphDefinitionLinkTarget.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FParams) and isEmptyProp(FProfile) and isEmptyProp(FcompartmentList) and isEmptyProp(Flink_List);
end;

procedure TFhirGraphDefinitionLinkTarget.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('params');
  fields.add('profile');
  fields.add('compartment');
  fields.add('link');
end;

function TFhirGraphDefinitionLinkTarget.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FCompartmentList.sizeInBytes(magic));
  inc(result, FLink_List.sizeInBytes(magic));
end;

procedure TFhirGraphDefinitionLinkTarget.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirGraphDefinitionLinkTarget.GetType_ST : TFhirResourceTypesEnum;
begin
  if FType_ = nil then
    result := TFhirResourceTypesEnum(0)
  else
    result := TFhirResourceTypesEnum(StringArrayIndexOfSensitive(CODES_TFhirResourceTypesEnum, FType_.value));
end;

procedure TFhirGraphDefinitionLinkTarget.SetType_ST(value : TFhirResourceTypesEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirResourceTypesEnum[value], CODES_TFhirResourceTypesEnum[value]);
end;

procedure TFhirGraphDefinitionLinkTarget.SetParams(value : TFhirString);
begin
  FParams.free;
  FParams := value;
end;

function TFhirGraphDefinitionLinkTarget.GetParamsST : String;
begin
  if FParams = nil then
    result := ''
  else
    result := FParams.value;
end;

procedure TFhirGraphDefinitionLinkTarget.SetParamsST(value : String);
begin
  if value <> '' then
  begin
    if FParams = nil then
      FParams := TFhirString.create;
    FParams.value := value
  end
  else if FParams <> nil then
    FParams.value := '';
end;

procedure TFhirGraphDefinitionLinkTarget.SetProfile(value : TFhirCanonical);
begin
  FProfile.free;
  FProfile := value;
end;

function TFhirGraphDefinitionLinkTarget.GetProfileST : String;
begin
  if FProfile = nil then
    result := ''
  else
    result := FProfile.value;
end;

procedure TFhirGraphDefinitionLinkTarget.SetProfileST(value : String);
begin
  if value <> '' then
  begin
    if FProfile = nil then
      FProfile := TFhirCanonical.create;
    FProfile.value := value
  end
  else if FProfile <> nil then
    FProfile.value := '';
end;

function TFhirGraphDefinitionLinkTarget.GetCompartmentList : TFhirGraphDefinitionLinkTargetCompartmentList;
begin
  if FCompartmentList = nil then
    FCompartmentList := TFhirGraphDefinitionLinkTargetCompartmentList.Create;
  result := FCompartmentList;
end;

function TFhirGraphDefinitionLinkTarget.GetHasCompartmentList : boolean;
begin
  result := (FCompartmentList <> nil) and (FCompartmentList.count > 0);
end;

function TFhirGraphDefinitionLinkTarget.GetLink_List : TFhirGraphDefinitionLinkList;
begin
  if FLink_List = nil then
    FLink_List := TFhirGraphDefinitionLinkList.Create;
  result := FLink_List;
end;

function TFhirGraphDefinitionLinkTarget.GetHasLink_List : boolean;
begin
  result := (FLink_List <> nil) and (FLink_List.count > 0);
end;

{ TFhirGraphDefinitionLinkTargetListEnumerator }

constructor TFhirGraphDefinitionLinkTargetListEnumerator.Create(list : TFhirGraphDefinitionLinkTargetList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirGraphDefinitionLinkTargetListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirGraphDefinitionLinkTargetListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirGraphDefinitionLinkTargetListEnumerator.GetCurrent : TFhirGraphDefinitionLinkTarget;
begin
  Result := FList[FIndex];
end;

function TFhirGraphDefinitionLinkTargetListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirGraphDefinitionLinkTargetList }

function TFhirGraphDefinitionLinkTargetList.AddItem(value: TFhirGraphDefinitionLinkTarget): TFhirGraphDefinitionLinkTarget;
begin
  assert(value.ClassName = 'TFhirGraphDefinitionLinkTarget', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirGraphDefinitionLinkTarget');
  add(value);
  result := value;
end;

function TFhirGraphDefinitionLinkTargetList.Append: TFhirGraphDefinitionLinkTarget;
begin
  result := TFhirGraphDefinitionLinkTarget.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirGraphDefinitionLinkTargetList.ClearItems;
begin
  Clear;
end;

function TFhirGraphDefinitionLinkTargetList.GetEnumerator : TFhirGraphDefinitionLinkTargetListEnumerator;
begin
  result := TFhirGraphDefinitionLinkTargetListEnumerator.Create(self.link);
end;

function TFhirGraphDefinitionLinkTargetList.Clone: TFhirGraphDefinitionLinkTargetList;
begin
  result := TFhirGraphDefinitionLinkTargetList(inherited Clone);
end;

function TFhirGraphDefinitionLinkTargetList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirGraphDefinitionLinkTargetList.GetItemN(index: Integer): TFhirGraphDefinitionLinkTarget;
begin
  result := TFhirGraphDefinitionLinkTarget(ObjectByIndex[index]);
end;

function TFhirGraphDefinitionLinkTargetList.ItemClass: TFslObjectClass;
begin
  result := TFhirGraphDefinitionLinkTarget;
end;
function TFhirGraphDefinitionLinkTargetList.IndexOf(value: TFhirGraphDefinitionLinkTarget): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirGraphDefinitionLinkTargetList.Insert(index: Integer): TFhirGraphDefinitionLinkTarget;
begin
  result := TFhirGraphDefinitionLinkTarget.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirGraphDefinitionLinkTargetList.InsertItem(index: Integer; value: TFhirGraphDefinitionLinkTarget);
begin
  assert(value is TFhirGraphDefinitionLinkTarget);
  Inherited Insert(index, value);
end;

function TFhirGraphDefinitionLinkTargetList.Item(index: Integer): TFhirGraphDefinitionLinkTarget;
begin
  result := TFhirGraphDefinitionLinkTarget(ObjectByIndex[index]);
end;

function TFhirGraphDefinitionLinkTargetList.Link: TFhirGraphDefinitionLinkTargetList;
begin
  result := TFhirGraphDefinitionLinkTargetList(inherited Link);
end;

procedure TFhirGraphDefinitionLinkTargetList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirGraphDefinitionLinkTargetList.SetItemByIndex(index: Integer; value: TFhirGraphDefinitionLinkTarget);
begin
  assert(value is TFhirGraphDefinitionLinkTarget);
  FhirGraphDefinitionLinkTargets[index] := value;
end;

procedure TFhirGraphDefinitionLinkTargetList.SetItemN(index: Integer; value: TFhirGraphDefinitionLinkTarget);
begin
  assert(value is TFhirGraphDefinitionLinkTarget);
  ObjectByIndex[index] := value;
end;

{ TFhirGraphDefinitionLinkTargetCompartment }

constructor TFhirGraphDefinitionLinkTargetCompartment.Create;
begin
  inherited;
end;

destructor TFhirGraphDefinitionLinkTargetCompartment.Destroy;
begin
  FUse.free;
  FCode.free;
  FRule.free;
  FExpression.free;
  FDescription.free;
  inherited;
end;

procedure TFhirGraphDefinitionLinkTargetCompartment.Assign(oSource : TFslObject);
begin
  inherited;
  useElement := TFhirGraphDefinitionLinkTargetCompartment(oSource).useElement.Clone;
  codeElement := TFhirGraphDefinitionLinkTargetCompartment(oSource).codeElement.Clone;
  ruleElement := TFhirGraphDefinitionLinkTargetCompartment(oSource).ruleElement.Clone;
  expressionElement := TFhirGraphDefinitionLinkTargetCompartment(oSource).expressionElement.Clone;
  descriptionElement := TFhirGraphDefinitionLinkTargetCompartment(oSource).descriptionElement.Clone;
end;

procedure TFhirGraphDefinitionLinkTargetCompartment.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'use') Then
     list.add(self.link, 'use', FUse.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'rule') Then
     list.add(self.link, 'rule', FRule.Link);
  if (child_name = 'expression') Then
     list.add(self.link, 'expression', FExpression.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
end;

procedure TFhirGraphDefinitionLinkTargetCompartment.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'use', 'code', false, TFhirEnum, FUse.Link));
  oList.add(TFHIRProperty.create(self, 'code', 'code', false, TFhirEnum, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'rule', 'code', false, TFhirEnum, FRule.Link));
  oList.add(TFHIRProperty.create(self, 'expression', 'string', false, TFhirString, FExpression.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));
end;

function TFhirGraphDefinitionLinkTargetCompartment.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'use') then
  begin
    UseElement := asEnum(SYSTEMS_TFhirGraphCompartmentUseEnum, CODES_TFhirGraphCompartmentUseEnum, propValue);
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    CodeElement := asEnum(SYSTEMS_TFhirCompartmentTypeEnum, CODES_TFhirCompartmentTypeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'rule') then
  begin
    RuleElement := asEnum(SYSTEMS_TFhirGraphCompartmentRuleEnum, CODES_TFhirGraphCompartmentRuleEnum, propValue);
    result := propValue;
  end
  else if (propName = 'expression') then
  begin
    ExpressionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirGraphDefinitionLinkTargetCompartment.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirGraphDefinitionLinkTargetCompartment.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'use') then result := TFhirEnum.create(SYSTEMS_TFhirGraphCompartmentUseEnum[GraphCompartmentUseNull], CODES_TFhirGraphCompartmentUseEnum[GraphCompartmentUseNull]) 
  else if (propName = 'code') then result := TFhirEnum.create(SYSTEMS_TFhirCompartmentTypeEnum[CompartmentTypeNull], CODES_TFhirCompartmentTypeEnum[CompartmentTypeNull]) 
  else if (propName = 'rule') then result := TFhirEnum.create(SYSTEMS_TFhirGraphCompartmentRuleEnum[GraphCompartmentRuleNull], CODES_TFhirGraphCompartmentRuleEnum[GraphCompartmentRuleNull]) 
  else if (propName = 'expression') then result := TFhirString.create()
  else if (propName = 'description') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirGraphDefinitionLinkTargetCompartment.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'use') then result := 'code'
  else if (propName = 'code') then result := 'code'
  else if (propName = 'rule') then result := 'code'
  else if (propName = 'expression') then result := 'string'
  else if (propName = 'description') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirGraphDefinitionLinkTargetCompartment.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'use') then UseElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'rule') then RuleElement := nil
  else if (propName = 'expression') then ExpressionElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirGraphDefinitionLinkTargetCompartment.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'use') then UseElement := asEnum(SYSTEMS_TFhirGraphCompartmentUseEnum, CODES_TFhirGraphCompartmentUseEnum, new)
  else if (propName = 'code') then CodeElement := asEnum(SYSTEMS_TFhirCompartmentTypeEnum, CODES_TFhirCompartmentTypeEnum, new)
  else if (propName = 'rule') then RuleElement := asEnum(SYSTEMS_TFhirGraphCompartmentRuleEnum, CODES_TFhirGraphCompartmentRuleEnum, new)
  else if (propName = 'expression') then ExpressionElement := asString(new)
  else if (propName = 'description') then DescriptionElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirGraphDefinitionLinkTargetCompartment.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirGraphDefinitionLinkTargetCompartment.fhirType : string;
begin
  result := 'GraphDefinition.link.target.compartment';
end;

function TFhirGraphDefinitionLinkTargetCompartment.Link : TFhirGraphDefinitionLinkTargetCompartment;
begin
  result := TFhirGraphDefinitionLinkTargetCompartment(inherited Link);
end;

function TFhirGraphDefinitionLinkTargetCompartment.Clone : TFhirGraphDefinitionLinkTargetCompartment;
begin
  result := TFhirGraphDefinitionLinkTargetCompartment(inherited Clone);
end;

function TFhirGraphDefinitionLinkTargetCompartment.equals(other : TObject) : boolean; 
var
  o : TFhirGraphDefinitionLinkTargetCompartment;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirGraphDefinitionLinkTargetCompartment)) then
    result := false
  else
  begin
    o := TFhirGraphDefinitionLinkTargetCompartment(other);
    result := compareDeep(useElement, o.useElement, true) and compareDeep(codeElement, o.codeElement, true) and 
      compareDeep(ruleElement, o.ruleElement, true) and compareDeep(expressionElement, o.expressionElement, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true);
  end;
end;

function TFhirGraphDefinitionLinkTargetCompartment.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FUse) and isEmptyProp(FCode) and isEmptyProp(FRule) and isEmptyProp(FExpression) and isEmptyProp(FDescription);
end;

procedure TFhirGraphDefinitionLinkTargetCompartment.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('use');
  fields.add('code');
  fields.add('rule');
  fields.add('expression');
  fields.add('description');
end;

function TFhirGraphDefinitionLinkTargetCompartment.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirGraphDefinitionLinkTargetCompartment.SetUse(value : TFhirEnum);
begin
  FUse.free;
  FUse := value;
end;

function TFhirGraphDefinitionLinkTargetCompartment.GetUseST : TFhirGraphCompartmentUseEnum;
begin
  if FUse = nil then
    result := TFhirGraphCompartmentUseEnum(0)
  else
    result := TFhirGraphCompartmentUseEnum(StringArrayIndexOfSensitive(CODES_TFhirGraphCompartmentUseEnum, FUse.value));
end;

procedure TFhirGraphDefinitionLinkTargetCompartment.SetUseST(value : TFhirGraphCompartmentUseEnum);
begin
  if ord(value) = 0 then
    UseElement := nil
  else
    UseElement := TFhirEnum.create(SYSTEMS_TFhirGraphCompartmentUseEnum[value], CODES_TFhirGraphCompartmentUseEnum[value]);
end;

procedure TFhirGraphDefinitionLinkTargetCompartment.SetCode(value : TFhirEnum);
begin
  FCode.free;
  FCode := value;
end;

function TFhirGraphDefinitionLinkTargetCompartment.GetCodeST : TFhirCompartmentTypeEnum;
begin
  if FCode = nil then
    result := TFhirCompartmentTypeEnum(0)
  else
    result := TFhirCompartmentTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirCompartmentTypeEnum, FCode.value));
end;

procedure TFhirGraphDefinitionLinkTargetCompartment.SetCodeST(value : TFhirCompartmentTypeEnum);
begin
  if ord(value) = 0 then
    CodeElement := nil
  else
    CodeElement := TFhirEnum.create(SYSTEMS_TFhirCompartmentTypeEnum[value], CODES_TFhirCompartmentTypeEnum[value]);
end;

procedure TFhirGraphDefinitionLinkTargetCompartment.SetRule(value : TFhirEnum);
begin
  FRule.free;
  FRule := value;
end;

function TFhirGraphDefinitionLinkTargetCompartment.GetRuleST : TFhirGraphCompartmentRuleEnum;
begin
  if FRule = nil then
    result := TFhirGraphCompartmentRuleEnum(0)
  else
    result := TFhirGraphCompartmentRuleEnum(StringArrayIndexOfSensitive(CODES_TFhirGraphCompartmentRuleEnum, FRule.value));
end;

procedure TFhirGraphDefinitionLinkTargetCompartment.SetRuleST(value : TFhirGraphCompartmentRuleEnum);
begin
  if ord(value) = 0 then
    RuleElement := nil
  else
    RuleElement := TFhirEnum.create(SYSTEMS_TFhirGraphCompartmentRuleEnum[value], CODES_TFhirGraphCompartmentRuleEnum[value]);
end;

procedure TFhirGraphDefinitionLinkTargetCompartment.SetExpression(value : TFhirString);
begin
  FExpression.free;
  FExpression := value;
end;

function TFhirGraphDefinitionLinkTargetCompartment.GetExpressionST : String;
begin
  if FExpression = nil then
    result := ''
  else
    result := FExpression.value;
end;

procedure TFhirGraphDefinitionLinkTargetCompartment.SetExpressionST(value : String);
begin
  if value <> '' then
  begin
    if FExpression = nil then
      FExpression := TFhirString.create;
    FExpression.value := value
  end
  else if FExpression <> nil then
    FExpression.value := '';
end;

procedure TFhirGraphDefinitionLinkTargetCompartment.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirGraphDefinitionLinkTargetCompartment.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirGraphDefinitionLinkTargetCompartment.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

{ TFhirGraphDefinitionLinkTargetCompartmentListEnumerator }

constructor TFhirGraphDefinitionLinkTargetCompartmentListEnumerator.Create(list : TFhirGraphDefinitionLinkTargetCompartmentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirGraphDefinitionLinkTargetCompartmentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirGraphDefinitionLinkTargetCompartmentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirGraphDefinitionLinkTargetCompartmentListEnumerator.GetCurrent : TFhirGraphDefinitionLinkTargetCompartment;
begin
  Result := FList[FIndex];
end;

function TFhirGraphDefinitionLinkTargetCompartmentListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirGraphDefinitionLinkTargetCompartmentList }

function TFhirGraphDefinitionLinkTargetCompartmentList.AddItem(value: TFhirGraphDefinitionLinkTargetCompartment): TFhirGraphDefinitionLinkTargetCompartment;
begin
  assert(value.ClassName = 'TFhirGraphDefinitionLinkTargetCompartment', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirGraphDefinitionLinkTargetCompartment');
  add(value);
  result := value;
end;

function TFhirGraphDefinitionLinkTargetCompartmentList.Append: TFhirGraphDefinitionLinkTargetCompartment;
begin
  result := TFhirGraphDefinitionLinkTargetCompartment.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirGraphDefinitionLinkTargetCompartmentList.ClearItems;
begin
  Clear;
end;

function TFhirGraphDefinitionLinkTargetCompartmentList.GetEnumerator : TFhirGraphDefinitionLinkTargetCompartmentListEnumerator;
begin
  result := TFhirGraphDefinitionLinkTargetCompartmentListEnumerator.Create(self.link);
end;

function TFhirGraphDefinitionLinkTargetCompartmentList.Clone: TFhirGraphDefinitionLinkTargetCompartmentList;
begin
  result := TFhirGraphDefinitionLinkTargetCompartmentList(inherited Clone);
end;

function TFhirGraphDefinitionLinkTargetCompartmentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirGraphDefinitionLinkTargetCompartmentList.GetItemN(index: Integer): TFhirGraphDefinitionLinkTargetCompartment;
begin
  result := TFhirGraphDefinitionLinkTargetCompartment(ObjectByIndex[index]);
end;

function TFhirGraphDefinitionLinkTargetCompartmentList.ItemClass: TFslObjectClass;
begin
  result := TFhirGraphDefinitionLinkTargetCompartment;
end;
function TFhirGraphDefinitionLinkTargetCompartmentList.IndexOf(value: TFhirGraphDefinitionLinkTargetCompartment): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirGraphDefinitionLinkTargetCompartmentList.Insert(index: Integer): TFhirGraphDefinitionLinkTargetCompartment;
begin
  result := TFhirGraphDefinitionLinkTargetCompartment.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirGraphDefinitionLinkTargetCompartmentList.InsertItem(index: Integer; value: TFhirGraphDefinitionLinkTargetCompartment);
begin
  assert(value is TFhirGraphDefinitionLinkTargetCompartment);
  Inherited Insert(index, value);
end;

function TFhirGraphDefinitionLinkTargetCompartmentList.Item(index: Integer): TFhirGraphDefinitionLinkTargetCompartment;
begin
  result := TFhirGraphDefinitionLinkTargetCompartment(ObjectByIndex[index]);
end;

function TFhirGraphDefinitionLinkTargetCompartmentList.Link: TFhirGraphDefinitionLinkTargetCompartmentList;
begin
  result := TFhirGraphDefinitionLinkTargetCompartmentList(inherited Link);
end;

procedure TFhirGraphDefinitionLinkTargetCompartmentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirGraphDefinitionLinkTargetCompartmentList.SetItemByIndex(index: Integer; value: TFhirGraphDefinitionLinkTargetCompartment);
begin
  assert(value is TFhirGraphDefinitionLinkTargetCompartment);
  FhirGraphDefinitionLinkTargetCompartments[index] := value;
end;

procedure TFhirGraphDefinitionLinkTargetCompartmentList.SetItemN(index: Integer; value: TFhirGraphDefinitionLinkTargetCompartment);
begin
  assert(value is TFhirGraphDefinitionLinkTargetCompartment);
  ObjectByIndex[index] := value;
end;

{ TFhirGraphDefinition }

constructor TFhirGraphDefinition.Create;
begin
  inherited;
end;

destructor TFhirGraphDefinition.Destroy;
begin
  FUrl.free;
  FVersion.free;
  FName.free;
  FStatus.free;
  FExperimental.free;
  FDate.free;
  FPublisher.free;
  FContactList.Free;
  FDescription.free;
  FUseContextList.Free;
  FJurisdictionList.Free;
  FPurpose.free;
  FStart.free;
  FProfile.free;
  FLink_List.Free;
  inherited;
end;

procedure TFhirGraphDefinition.Assign(oSource : TFslObject);
begin
  inherited;
  urlElement := TFhirGraphDefinition(oSource).urlElement.Clone;
  versionElement := TFhirGraphDefinition(oSource).versionElement.Clone;
  nameElement := TFhirGraphDefinition(oSource).nameElement.Clone;
  statusElement := TFhirGraphDefinition(oSource).statusElement.Clone;
  experimentalElement := TFhirGraphDefinition(oSource).experimentalElement.Clone;
  dateElement := TFhirGraphDefinition(oSource).dateElement.Clone;
  publisherElement := TFhirGraphDefinition(oSource).publisherElement.Clone;
  if (TFhirGraphDefinition(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirContactDetailList.Create;
    FContactList.Assign(TFhirGraphDefinition(oSource).FContactList);
  end;
  descriptionElement := TFhirGraphDefinition(oSource).descriptionElement.Clone;
  if (TFhirGraphDefinition(oSource).FUseContextList = nil) then
  begin
    FUseContextList.free;
    FUseContextList := nil;
  end
  else
  begin
    if FUseContextList = nil then
      FUseContextList := TFhirUsageContextList.Create;
    FUseContextList.Assign(TFhirGraphDefinition(oSource).FUseContextList);
  end;
  if (TFhirGraphDefinition(oSource).FJurisdictionList = nil) then
  begin
    FJurisdictionList.free;
    FJurisdictionList := nil;
  end
  else
  begin
    if FJurisdictionList = nil then
      FJurisdictionList := TFhirCodeableConceptList.Create;
    FJurisdictionList.Assign(TFhirGraphDefinition(oSource).FJurisdictionList);
  end;
  purposeElement := TFhirGraphDefinition(oSource).purposeElement.Clone;
  startElement := TFhirGraphDefinition(oSource).startElement.Clone;
  profileElement := TFhirGraphDefinition(oSource).profileElement.Clone;
  if (TFhirGraphDefinition(oSource).FLink_List = nil) then
  begin
    FLink_List.free;
    FLink_List := nil;
  end
  else
  begin
    if FLink_List = nil then
      FLink_List := TFhirGraphDefinitionLinkList.Create;
    FLink_List.Assign(TFhirGraphDefinition(oSource).FLink_List);
  end;
end;

function TFhirGraphDefinition.GetResourceType : TFhirResourceType;
begin
  result := frtGraphDefinition;
end;

procedure TFhirGraphDefinition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
  if (child_name = 'version') Then
     list.add(self.link, 'version', FVersion.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'experimental') Then
     list.add(self.link, 'experimental', FExperimental.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'publisher') Then
     list.add(self.link, 'publisher', FPublisher.Link);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'useContext') Then
    list.addAll(self, 'useContext', FUseContextList);
  if (child_name = 'jurisdiction') Then
    list.addAll(self, 'jurisdiction', FJurisdictionList);
  if (child_name = 'purpose') Then
     list.add(self.link, 'purpose', FPurpose.Link);
  if (child_name = 'start') Then
     list.add(self.link, 'start', FStart.Link);
  if (child_name = 'profile') Then
     list.add(self.link, 'profile', FProfile.Link);
  if (child_name = 'link') Then
    list.addAll(self, 'link', FLink_List);
end;

procedure TFhirGraphDefinition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'url', 'uri', false, TFhirUri, FUrl.Link));
  oList.add(TFHIRProperty.create(self, 'version', 'string', false, TFhirString, FVersion.Link));
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'experimental', 'boolean', false, TFhirBoolean, FExperimental.Link));
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));
  oList.add(TFHIRProperty.create(self, 'publisher', 'string', false, TFhirString, FPublisher.Link));
  oList.add(TFHIRProperty.create(self, 'contact', 'ContactDetail', true, TFhirContactDetail, FContactList.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'markdown', false, TFhirMarkdown, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'useContext', 'UsageContext', true, TFhirUsageContext, FUseContextList.Link));
  oList.add(TFHIRProperty.create(self, 'jurisdiction', 'CodeableConcept', true, TFhirCodeableConcept, FJurisdictionList.Link));
  oList.add(TFHIRProperty.create(self, 'purpose', 'markdown', false, TFhirMarkdown, FPurpose.Link));
  oList.add(TFHIRProperty.create(self, 'start', 'code', false, TFhirEnum, FStart.Link));
  oList.add(TFHIRProperty.create(self, 'profile', 'canonical', false, TFhirCanonical, FProfile.Link));
  oList.add(TFHIRProperty.create(self, 'link', 'BackboneElement', true, TFhirGraphDefinitionLink, FLink_List.Link));
end;

function TFhirGraphDefinition.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'url') then
  begin
    UrlElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'experimental') then
  begin
    ExperimentalElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'publisher') then
  begin
    PublisherElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirContactDetail);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'useContext') then
  begin
    UseContextList.add(propValue as TFhirUsageContext);
    result := propValue;
  end
  else if (propName = 'jurisdiction') then
  begin
    JurisdictionList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'purpose') then
  begin
    PurposeElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'start') then
  begin
    StartElement := asEnum(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum, propValue);
    result := propValue;
  end
  else if (propName = 'profile') then
  begin
    ProfileElement := asCanonical(propValue);
    result := propValue;
  end
  else if (propName = 'link') then
  begin
    Link_List.add(propValue as TFhirGraphDefinitionLink);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirGraphDefinition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirContactDetail)
  else if (propName = 'useContext') then UseContextList.insertItem(index, propValue as TFhirUsageContext)
  else if (propName = 'jurisdiction') then JurisdictionList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'link') then Link_List.insertItem(index, propValue as TFhirGraphDefinitionLink)
  else inherited;
end;

function TFhirGraphDefinition.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'url') then result := TFhirUri.create()
  else if (propName = 'version') then result := TFhirString.create()
  else if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[PublicationStatusNull], CODES_TFhirPublicationStatusEnum[PublicationStatusNull]) 
  else if (propName = 'experimental') then result := TFhirBoolean.create()
  else if (propName = 'date') then result := TFhirDateTime.create()
  else if (propName = 'publisher') then result := TFhirString.create()
  else if (propName = 'contact') then result := ContactList.new()
  else if (propName = 'description') then result := TFhirMarkdown.create()
  else if (propName = 'useContext') then result := UseContextList.new()
  else if (propName = 'jurisdiction') then result := JurisdictionList.new()
  else if (propName = 'purpose') then result := TFhirMarkdown.create()
  else if (propName = 'start') then result := TFhirEnum.create(SYSTEMS_TFhirResourceTypesEnum[ResourceTypesNull], CODES_TFhirResourceTypesEnum[ResourceTypesNull]) 
  else if (propName = 'profile') then result := TFhirCanonical.create()
  else if (propName = 'link') then result := Link_List.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirGraphDefinition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'url') then result := 'uri'
  else if (propName = 'version') then result := 'string'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'experimental') then result := 'boolean'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'publisher') then result := 'string'
  else if (propName = 'contact') then result := 'ContactDetail'
  else if (propName = 'description') then result := 'markdown'
  else if (propName = 'useContext') then result := 'UsageContext'
  else if (propName = 'jurisdiction') then result := 'CodeableConcept'
  else if (propName = 'purpose') then result := 'markdown'
  else if (propName = 'start') then result := 'code'
  else if (propName = 'profile') then result := 'canonical'
  else if (propName = 'link') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirGraphDefinition.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := nil
  else if (propName = 'version') then VersionElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'experimental') then ExperimentalElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'publisher') then PublisherElement := nil
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value)
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'useContext') then deletePropertyValue('useContext', UseContextList, value)
  else if (propName = 'jurisdiction') then deletePropertyValue('jurisdiction', JurisdictionList, value)
  else if (propName = 'purpose') then PurposeElement := nil
  else if (propName = 'start') then StartElement := nil
  else if (propName = 'profile') then ProfileElement := nil
  else if (propName = 'link') then deletePropertyValue('link', Link_List, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirGraphDefinition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := asUri(new)
  else if (propName = 'version') then VersionElement := asString(new)
  else if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, new)
  else if (propName = 'experimental') then ExperimentalElement := asBoolean(new)
  else if (propName = 'date') then DateElement := asDateTime(new)
  else if (propName = 'publisher') then PublisherElement := asString(new)
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new)
  else if (propName = 'description') then DescriptionElement := asMarkdown(new)
  else if (propName = 'useContext') then replacePropertyValue('useContext', UseContextList, existing, new)
  else if (propName = 'jurisdiction') then replacePropertyValue('jurisdiction', JurisdictionList, existing, new)
  else if (propName = 'purpose') then PurposeElement := asMarkdown(new)
  else if (propName = 'start') then StartElement := asEnum(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum, new)
  else if (propName = 'profile') then ProfileElement := asCanonical(new)
  else if (propName = 'link') then replacePropertyValue('link', Link_List, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirGraphDefinition.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'contact') then ContactList.move(source, destination)
  else if (propName = 'useContext') then UseContextList.move(source, destination)
  else if (propName = 'jurisdiction') then JurisdictionList.move(source, destination)
  else if (propName = 'link') then Link_List.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirGraphDefinition.fhirType : string;
begin
  result := 'GraphDefinition';
end;

function TFhirGraphDefinition.Link : TFhirGraphDefinition;
begin
  result := TFhirGraphDefinition(inherited Link);
end;

function TFhirGraphDefinition.Clone : TFhirGraphDefinition;
begin
  result := TFhirGraphDefinition(inherited Clone);
end;

function TFhirGraphDefinition.equals(other : TObject) : boolean; 
var
  o : TFhirGraphDefinition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirGraphDefinition)) then
    result := false
  else
  begin
    o := TFhirGraphDefinition(other);
    result := compareDeep(urlElement, o.urlElement, true) and compareDeep(versionElement, o.versionElement, true) and 
      compareDeep(nameElement, o.nameElement, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(experimentalElement, o.experimentalElement, true) and compareDeep(dateElement, o.dateElement, true) and 
      compareDeep(publisherElement, o.publisherElement, true) and compareDeep(contactList, o.contactList, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(useContextList, o.useContextList, true) and 
      compareDeep(jurisdictionList, o.jurisdictionList, true) and compareDeep(purposeElement, o.purposeElement, true) and 
      compareDeep(startElement, o.startElement, true) and compareDeep(profileElement, o.profileElement, true) and 
      compareDeep(link_List, o.link_List, true);
  end;
end;

function TFhirGraphDefinition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FUrl) and isEmptyProp(FVersion) and isEmptyProp(FName) and isEmptyProp(FStatus) and isEmptyProp(FExperimental) and isEmptyProp(FDate) and isEmptyProp(FPublisher) and isEmptyProp(FcontactList) and isEmptyProp(FDescription) and isEmptyProp(FuseContextList) and isEmptyProp(FjurisdictionList) and isEmptyProp(FPurpose) and isEmptyProp(FStart) and isEmptyProp(FProfile) and isEmptyProp(Flink_List);
end;

procedure TFhirGraphDefinition.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('url');
  fields.add('version');
  fields.add('name');
  fields.add('status');
  fields.add('experimental');
  fields.add('date');
  fields.add('publisher');
  fields.add('contact');
  fields.add('description');
  fields.add('useContext');
  fields.add('jurisdiction');
  fields.add('purpose');
  fields.add('start');
  fields.add('profile');
  fields.add('link');
end;

function TFhirGraphDefinition.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FContactList.sizeInBytes(magic));
  inc(result, FUseContextList.sizeInBytes(magic));
  inc(result, FJurisdictionList.sizeInBytes(magic));
  inc(result, FLink_List.sizeInBytes(magic));
end;

procedure TFhirGraphDefinition.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

function TFhirGraphDefinition.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

procedure TFhirGraphDefinition.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

procedure TFhirGraphDefinition.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

function TFhirGraphDefinition.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

procedure TFhirGraphDefinition.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

procedure TFhirGraphDefinition.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirGraphDefinition.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirGraphDefinition.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirGraphDefinition.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirGraphDefinition.GetStatusST : TFhirPublicationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirPublicationStatusEnum(0)
  else
    result := TFhirPublicationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirPublicationStatusEnum, FStatus.value));
end;

procedure TFhirGraphDefinition.SetStatusST(value : TFhirPublicationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[value], CODES_TFhirPublicationStatusEnum[value]);
end;

procedure TFhirGraphDefinition.SetExperimental(value : TFhirBoolean);
begin
  FExperimental.free;
  FExperimental := value;
end;

function TFhirGraphDefinition.GetExperimentalST : Boolean;
begin
  if FExperimental = nil then
    result := false
  else
    result := FExperimental.value;
end;

procedure TFhirGraphDefinition.SetExperimentalST(value : Boolean);
begin
  if FExperimental = nil then
    FExperimental := TFhirBoolean.create;
  FExperimental.value := value
end;

procedure TFhirGraphDefinition.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

function TFhirGraphDefinition.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirGraphDefinition.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

procedure TFhirGraphDefinition.SetPublisher(value : TFhirString);
begin
  FPublisher.free;
  FPublisher := value;
end;

function TFhirGraphDefinition.GetPublisherST : String;
begin
  if FPublisher = nil then
    result := ''
  else
    result := FPublisher.value;
end;

procedure TFhirGraphDefinition.SetPublisherST(value : String);
begin
  if value <> '' then
  begin
    if FPublisher = nil then
      FPublisher := TFhirString.create;
    FPublisher.value := value
  end
  else if FPublisher <> nil then
    FPublisher.value := '';
end;

function TFhirGraphDefinition.GetContactList : TFhirContactDetailList;
begin
  if FContactList = nil then
    FContactList := TFhirContactDetailList.Create;
  result := FContactList;
end;

function TFhirGraphDefinition.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

procedure TFhirGraphDefinition.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirGraphDefinition.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirGraphDefinition.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirGraphDefinition.GetUseContextList : TFhirUsageContextList;
begin
  if FUseContextList = nil then
    FUseContextList := TFhirUsageContextList.Create;
  result := FUseContextList;
end;

function TFhirGraphDefinition.GetHasUseContextList : boolean;
begin
  result := (FUseContextList <> nil) and (FUseContextList.count > 0);
end;

function TFhirGraphDefinition.GetJurisdictionList : TFhirCodeableConceptList;
begin
  if FJurisdictionList = nil then
    FJurisdictionList := TFhirCodeableConceptList.Create;
  result := FJurisdictionList;
end;

function TFhirGraphDefinition.GetHasJurisdictionList : boolean;
begin
  result := (FJurisdictionList <> nil) and (FJurisdictionList.count > 0);
end;

procedure TFhirGraphDefinition.SetPurpose(value : TFhirMarkdown);
begin
  FPurpose.free;
  FPurpose := value;
end;

function TFhirGraphDefinition.GetPurposeST : String;
begin
  if FPurpose = nil then
    result := ''
  else
    result := FPurpose.value;
end;

procedure TFhirGraphDefinition.SetPurposeST(value : String);
begin
  if value <> '' then
  begin
    if FPurpose = nil then
      FPurpose := TFhirMarkdown.create;
    FPurpose.value := value
  end
  else if FPurpose <> nil then
    FPurpose.value := '';
end;

procedure TFhirGraphDefinition.SetStart(value : TFhirEnum);
begin
  FStart.free;
  FStart := value;
end;

function TFhirGraphDefinition.GetStartST : TFhirResourceTypesEnum;
begin
  if FStart = nil then
    result := TFhirResourceTypesEnum(0)
  else
    result := TFhirResourceTypesEnum(StringArrayIndexOfSensitive(CODES_TFhirResourceTypesEnum, FStart.value));
end;

procedure TFhirGraphDefinition.SetStartST(value : TFhirResourceTypesEnum);
begin
  if ord(value) = 0 then
    StartElement := nil
  else
    StartElement := TFhirEnum.create(SYSTEMS_TFhirResourceTypesEnum[value], CODES_TFhirResourceTypesEnum[value]);
end;

procedure TFhirGraphDefinition.SetProfile(value : TFhirCanonical);
begin
  FProfile.free;
  FProfile := value;
end;

function TFhirGraphDefinition.GetProfileST : String;
begin
  if FProfile = nil then
    result := ''
  else
    result := FProfile.value;
end;

procedure TFhirGraphDefinition.SetProfileST(value : String);
begin
  if value <> '' then
  begin
    if FProfile = nil then
      FProfile := TFhirCanonical.create;
    FProfile.value := value
  end
  else if FProfile <> nil then
    FProfile.value := '';
end;

function TFhirGraphDefinition.GetLink_List : TFhirGraphDefinitionLinkList;
begin
  if FLink_List = nil then
    FLink_List := TFhirGraphDefinitionLinkList.Create;
  result := FLink_List;
end;

function TFhirGraphDefinition.GetHasLink_List : boolean;
begin
  result := (FLink_List <> nil) and (FLink_List.count > 0);
end;

{ TFhirGraphDefinitionListEnumerator }

constructor TFhirGraphDefinitionListEnumerator.Create(list : TFhirGraphDefinitionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirGraphDefinitionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirGraphDefinitionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirGraphDefinitionListEnumerator.GetCurrent : TFhirGraphDefinition;
begin
  Result := FList[FIndex];
end;

function TFhirGraphDefinitionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirGraphDefinitionList }

function TFhirGraphDefinitionList.AddItem(value: TFhirGraphDefinition): TFhirGraphDefinition;
begin
  assert(value.ClassName = 'TFhirGraphDefinition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirGraphDefinition');
  add(value);
  result := value;
end;

function TFhirGraphDefinitionList.Append: TFhirGraphDefinition;
begin
  result := TFhirGraphDefinition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirGraphDefinitionList.ClearItems;
begin
  Clear;
end;

function TFhirGraphDefinitionList.GetEnumerator : TFhirGraphDefinitionListEnumerator;
begin
  result := TFhirGraphDefinitionListEnumerator.Create(self.link);
end;

function TFhirGraphDefinitionList.Clone: TFhirGraphDefinitionList;
begin
  result := TFhirGraphDefinitionList(inherited Clone);
end;

function TFhirGraphDefinitionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirGraphDefinitionList.GetItemN(index: Integer): TFhirGraphDefinition;
begin
  result := TFhirGraphDefinition(ObjectByIndex[index]);
end;

function TFhirGraphDefinitionList.ItemClass: TFslObjectClass;
begin
  result := TFhirGraphDefinition;
end;
function TFhirGraphDefinitionList.IndexOf(value: TFhirGraphDefinition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirGraphDefinitionList.Insert(index: Integer): TFhirGraphDefinition;
begin
  result := TFhirGraphDefinition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirGraphDefinitionList.InsertItem(index: Integer; value: TFhirGraphDefinition);
begin
  assert(value is TFhirGraphDefinition);
  Inherited Insert(index, value);
end;

function TFhirGraphDefinitionList.Item(index: Integer): TFhirGraphDefinition;
begin
  result := TFhirGraphDefinition(ObjectByIndex[index]);
end;

function TFhirGraphDefinitionList.Link: TFhirGraphDefinitionList;
begin
  result := TFhirGraphDefinitionList(inherited Link);
end;

procedure TFhirGraphDefinitionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirGraphDefinitionList.SetItemByIndex(index: Integer; value: TFhirGraphDefinition);
begin
  assert(value is TFhirGraphDefinition);
  FhirGraphDefinitions[index] := value;
end;

procedure TFhirGraphDefinitionList.SetItemN(index: Integer; value: TFhirGraphDefinition);
begin
  assert(value is TFhirGraphDefinition);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_GRAPHDEFINITION}
{$IFDEF FHIR_IMPLEMENTATIONGUIDE}
{ TFhirImplementationGuideDependsOn }

constructor TFhirImplementationGuideDependsOn.Create;
begin
  inherited;
end;

destructor TFhirImplementationGuideDependsOn.Destroy;
begin
  FUri.free;
  FPackageId.free;
  FVersion.free;
  inherited;
end;

procedure TFhirImplementationGuideDependsOn.Assign(oSource : TFslObject);
begin
  inherited;
  uriElement := TFhirImplementationGuideDependsOn(oSource).uriElement.Clone;
  packageIdElement := TFhirImplementationGuideDependsOn(oSource).packageIdElement.Clone;
  versionElement := TFhirImplementationGuideDependsOn(oSource).versionElement.Clone;
end;

procedure TFhirImplementationGuideDependsOn.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'uri') Then
     list.add(self.link, 'uri', FUri.Link);
  if (child_name = 'packageId') Then
     list.add(self.link, 'packageId', FPackageId.Link);
  if (child_name = 'version') Then
     list.add(self.link, 'version', FVersion.Link);
end;

procedure TFhirImplementationGuideDependsOn.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'uri', 'canonical', false, TFhirCanonical, FUri.Link));
  oList.add(TFHIRProperty.create(self, 'packageId', 'id', false, TFhirId, FPackageId.Link));
  oList.add(TFHIRProperty.create(self, 'version', 'string', false, TFhirString, FVersion.Link));
end;

function TFhirImplementationGuideDependsOn.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'uri') then
  begin
    UriElement := asCanonical(propValue);
    result := propValue;
  end
  else if (propName = 'packageId') then
  begin
    PackageIdElement := asId(propValue);
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirImplementationGuideDependsOn.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirImplementationGuideDependsOn.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'uri') then result := TFhirCanonical.create()
  else if (propName = 'packageId') then result := TFhirId.create()
  else if (propName = 'version') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirImplementationGuideDependsOn.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'uri') then result := 'canonical'
  else if (propName = 'packageId') then result := 'id'
  else if (propName = 'version') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImplementationGuideDependsOn.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'uri') then UriElement := nil
  else if (propName = 'packageId') then PackageIdElement := nil
  else if (propName = 'version') then VersionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImplementationGuideDependsOn.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'uri') then UriElement := asCanonical(new)
  else if (propName = 'packageId') then PackageIdElement := asId(new)
  else if (propName = 'version') then VersionElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImplementationGuideDependsOn.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirImplementationGuideDependsOn.fhirType : string;
begin
  result := 'ImplementationGuide.dependsOn';
end;

function TFhirImplementationGuideDependsOn.Link : TFhirImplementationGuideDependsOn;
begin
  result := TFhirImplementationGuideDependsOn(inherited Link);
end;

function TFhirImplementationGuideDependsOn.Clone : TFhirImplementationGuideDependsOn;
begin
  result := TFhirImplementationGuideDependsOn(inherited Clone);
end;

function TFhirImplementationGuideDependsOn.equals(other : TObject) : boolean; 
var
  o : TFhirImplementationGuideDependsOn;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImplementationGuideDependsOn)) then
    result := false
  else
  begin
    o := TFhirImplementationGuideDependsOn(other);
    result := compareDeep(uriElement, o.uriElement, true) and compareDeep(packageIdElement, o.packageIdElement, true) and 
      compareDeep(versionElement, o.versionElement, true);
  end;
end;

function TFhirImplementationGuideDependsOn.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FUri) and isEmptyProp(FPackageId) and isEmptyProp(FVersion);
end;

procedure TFhirImplementationGuideDependsOn.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('uri');
  fields.add('packageId');
  fields.add('version');
end;

function TFhirImplementationGuideDependsOn.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirImplementationGuideDependsOn.SetUri(value : TFhirCanonical);
begin
  FUri.free;
  FUri := value;
end;

function TFhirImplementationGuideDependsOn.GetUriST : String;
begin
  if FUri = nil then
    result := ''
  else
    result := FUri.value;
end;

procedure TFhirImplementationGuideDependsOn.SetUriST(value : String);
begin
  if value <> '' then
  begin
    if FUri = nil then
      FUri := TFhirCanonical.create;
    FUri.value := value
  end
  else if FUri <> nil then
    FUri.value := '';
end;

procedure TFhirImplementationGuideDependsOn.SetPackageId(value : TFhirId);
begin
  FPackageId.free;
  FPackageId := value;
end;

function TFhirImplementationGuideDependsOn.GetPackageIdST : String;
begin
  if FPackageId = nil then
    result := ''
  else
    result := FPackageId.value;
end;

procedure TFhirImplementationGuideDependsOn.SetPackageIdST(value : String);
begin
  if value <> '' then
  begin
    if FPackageId = nil then
      FPackageId := TFhirId.create;
    FPackageId.value := value
  end
  else if FPackageId <> nil then
    FPackageId.value := '';
end;

procedure TFhirImplementationGuideDependsOn.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

function TFhirImplementationGuideDependsOn.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

procedure TFhirImplementationGuideDependsOn.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

{ TFhirImplementationGuideDependsOnListEnumerator }

constructor TFhirImplementationGuideDependsOnListEnumerator.Create(list : TFhirImplementationGuideDependsOnList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImplementationGuideDependsOnListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImplementationGuideDependsOnListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImplementationGuideDependsOnListEnumerator.GetCurrent : TFhirImplementationGuideDependsOn;
begin
  Result := FList[FIndex];
end;

function TFhirImplementationGuideDependsOnListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirImplementationGuideDependsOnList }

function TFhirImplementationGuideDependsOnList.AddItem(value: TFhirImplementationGuideDependsOn): TFhirImplementationGuideDependsOn;
begin
  assert(value.ClassName = 'TFhirImplementationGuideDependsOn', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImplementationGuideDependsOn');
  add(value);
  result := value;
end;

function TFhirImplementationGuideDependsOnList.Append: TFhirImplementationGuideDependsOn;
begin
  result := TFhirImplementationGuideDependsOn.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImplementationGuideDependsOnList.ClearItems;
begin
  Clear;
end;

function TFhirImplementationGuideDependsOnList.GetEnumerator : TFhirImplementationGuideDependsOnListEnumerator;
begin
  result := TFhirImplementationGuideDependsOnListEnumerator.Create(self.link);
end;

function TFhirImplementationGuideDependsOnList.Clone: TFhirImplementationGuideDependsOnList;
begin
  result := TFhirImplementationGuideDependsOnList(inherited Clone);
end;

function TFhirImplementationGuideDependsOnList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImplementationGuideDependsOnList.GetItemN(index: Integer): TFhirImplementationGuideDependsOn;
begin
  result := TFhirImplementationGuideDependsOn(ObjectByIndex[index]);
end;

function TFhirImplementationGuideDependsOnList.ItemClass: TFslObjectClass;
begin
  result := TFhirImplementationGuideDependsOn;
end;
function TFhirImplementationGuideDependsOnList.IndexOf(value: TFhirImplementationGuideDependsOn): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImplementationGuideDependsOnList.Insert(index: Integer): TFhirImplementationGuideDependsOn;
begin
  result := TFhirImplementationGuideDependsOn.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImplementationGuideDependsOnList.InsertItem(index: Integer; value: TFhirImplementationGuideDependsOn);
begin
  assert(value is TFhirImplementationGuideDependsOn);
  Inherited Insert(index, value);
end;

function TFhirImplementationGuideDependsOnList.Item(index: Integer): TFhirImplementationGuideDependsOn;
begin
  result := TFhirImplementationGuideDependsOn(ObjectByIndex[index]);
end;

function TFhirImplementationGuideDependsOnList.Link: TFhirImplementationGuideDependsOnList;
begin
  result := TFhirImplementationGuideDependsOnList(inherited Link);
end;

procedure TFhirImplementationGuideDependsOnList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImplementationGuideDependsOnList.SetItemByIndex(index: Integer; value: TFhirImplementationGuideDependsOn);
begin
  assert(value is TFhirImplementationGuideDependsOn);
  FhirImplementationGuideDependsOns[index] := value;
end;

procedure TFhirImplementationGuideDependsOnList.SetItemN(index: Integer; value: TFhirImplementationGuideDependsOn);
begin
  assert(value is TFhirImplementationGuideDependsOn);
  ObjectByIndex[index] := value;
end;

{ TFhirImplementationGuideGlobal }

constructor TFhirImplementationGuideGlobal.Create;
begin
  inherited;
end;

destructor TFhirImplementationGuideGlobal.Destroy;
begin
  FType_.free;
  FProfile.free;
  inherited;
end;

procedure TFhirImplementationGuideGlobal.Assign(oSource : TFslObject);
begin
  inherited;
  type_Element := TFhirImplementationGuideGlobal(oSource).type_Element.Clone;
  profileElement := TFhirImplementationGuideGlobal(oSource).profileElement.Clone;
end;

procedure TFhirImplementationGuideGlobal.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'profile') Then
     list.add(self.link, 'profile', FProfile.Link);
end;

procedure TFhirImplementationGuideGlobal.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFhirEnum, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'profile', 'canonical', false, TFhirCanonical, FProfile.Link));
end;

function TFhirImplementationGuideGlobal.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum, propValue);
    result := propValue;
  end
  else if (propName = 'profile') then
  begin
    ProfileElement := asCanonical(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirImplementationGuideGlobal.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirImplementationGuideGlobal.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirEnum.create(SYSTEMS_TFhirResourceTypesEnum[ResourceTypesNull], CODES_TFhirResourceTypesEnum[ResourceTypesNull]) 
  else if (propName = 'profile') then result := TFhirCanonical.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirImplementationGuideGlobal.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'code'
  else if (propName = 'profile') then result := 'canonical'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImplementationGuideGlobal.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'profile') then ProfileElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImplementationGuideGlobal.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum, new)
  else if (propName = 'profile') then ProfileElement := asCanonical(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImplementationGuideGlobal.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirImplementationGuideGlobal.fhirType : string;
begin
  result := 'ImplementationGuide.global';
end;

function TFhirImplementationGuideGlobal.Link : TFhirImplementationGuideGlobal;
begin
  result := TFhirImplementationGuideGlobal(inherited Link);
end;

function TFhirImplementationGuideGlobal.Clone : TFhirImplementationGuideGlobal;
begin
  result := TFhirImplementationGuideGlobal(inherited Clone);
end;

function TFhirImplementationGuideGlobal.equals(other : TObject) : boolean; 
var
  o : TFhirImplementationGuideGlobal;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImplementationGuideGlobal)) then
    result := false
  else
  begin
    o := TFhirImplementationGuideGlobal(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(profileElement, o.profileElement, true);
  end;
end;

function TFhirImplementationGuideGlobal.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FProfile);
end;

procedure TFhirImplementationGuideGlobal.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('profile');
end;

function TFhirImplementationGuideGlobal.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirImplementationGuideGlobal.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirImplementationGuideGlobal.GetType_ST : TFhirResourceTypesEnum;
begin
  if FType_ = nil then
    result := TFhirResourceTypesEnum(0)
  else
    result := TFhirResourceTypesEnum(StringArrayIndexOfSensitive(CODES_TFhirResourceTypesEnum, FType_.value));
end;

procedure TFhirImplementationGuideGlobal.SetType_ST(value : TFhirResourceTypesEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirResourceTypesEnum[value], CODES_TFhirResourceTypesEnum[value]);
end;

procedure TFhirImplementationGuideGlobal.SetProfile(value : TFhirCanonical);
begin
  FProfile.free;
  FProfile := value;
end;

function TFhirImplementationGuideGlobal.GetProfileST : String;
begin
  if FProfile = nil then
    result := ''
  else
    result := FProfile.value;
end;

procedure TFhirImplementationGuideGlobal.SetProfileST(value : String);
begin
  if value <> '' then
  begin
    if FProfile = nil then
      FProfile := TFhirCanonical.create;
    FProfile.value := value
  end
  else if FProfile <> nil then
    FProfile.value := '';
end;

{ TFhirImplementationGuideGlobalListEnumerator }

constructor TFhirImplementationGuideGlobalListEnumerator.Create(list : TFhirImplementationGuideGlobalList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImplementationGuideGlobalListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImplementationGuideGlobalListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImplementationGuideGlobalListEnumerator.GetCurrent : TFhirImplementationGuideGlobal;
begin
  Result := FList[FIndex];
end;

function TFhirImplementationGuideGlobalListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirImplementationGuideGlobalList }

function TFhirImplementationGuideGlobalList.AddItem(value: TFhirImplementationGuideGlobal): TFhirImplementationGuideGlobal;
begin
  assert(value.ClassName = 'TFhirImplementationGuideGlobal', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImplementationGuideGlobal');
  add(value);
  result := value;
end;

function TFhirImplementationGuideGlobalList.Append: TFhirImplementationGuideGlobal;
begin
  result := TFhirImplementationGuideGlobal.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImplementationGuideGlobalList.ClearItems;
begin
  Clear;
end;

function TFhirImplementationGuideGlobalList.GetEnumerator : TFhirImplementationGuideGlobalListEnumerator;
begin
  result := TFhirImplementationGuideGlobalListEnumerator.Create(self.link);
end;

function TFhirImplementationGuideGlobalList.Clone: TFhirImplementationGuideGlobalList;
begin
  result := TFhirImplementationGuideGlobalList(inherited Clone);
end;

function TFhirImplementationGuideGlobalList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImplementationGuideGlobalList.GetItemN(index: Integer): TFhirImplementationGuideGlobal;
begin
  result := TFhirImplementationGuideGlobal(ObjectByIndex[index]);
end;

function TFhirImplementationGuideGlobalList.ItemClass: TFslObjectClass;
begin
  result := TFhirImplementationGuideGlobal;
end;
function TFhirImplementationGuideGlobalList.IndexOf(value: TFhirImplementationGuideGlobal): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImplementationGuideGlobalList.Insert(index: Integer): TFhirImplementationGuideGlobal;
begin
  result := TFhirImplementationGuideGlobal.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImplementationGuideGlobalList.InsertItem(index: Integer; value: TFhirImplementationGuideGlobal);
begin
  assert(value is TFhirImplementationGuideGlobal);
  Inherited Insert(index, value);
end;

function TFhirImplementationGuideGlobalList.Item(index: Integer): TFhirImplementationGuideGlobal;
begin
  result := TFhirImplementationGuideGlobal(ObjectByIndex[index]);
end;

function TFhirImplementationGuideGlobalList.Link: TFhirImplementationGuideGlobalList;
begin
  result := TFhirImplementationGuideGlobalList(inherited Link);
end;

procedure TFhirImplementationGuideGlobalList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImplementationGuideGlobalList.SetItemByIndex(index: Integer; value: TFhirImplementationGuideGlobal);
begin
  assert(value is TFhirImplementationGuideGlobal);
  FhirImplementationGuideGlobals[index] := value;
end;

procedure TFhirImplementationGuideGlobalList.SetItemN(index: Integer; value: TFhirImplementationGuideGlobal);
begin
  assert(value is TFhirImplementationGuideGlobal);
  ObjectByIndex[index] := value;
end;

{ TFhirImplementationGuideDefinition }

constructor TFhirImplementationGuideDefinition.Create;
begin
  inherited;
end;

destructor TFhirImplementationGuideDefinition.Destroy;
begin
  FGroupingList.Free;
  FResourceList.Free;
  FPage.free;
  FParameterList.Free;
  FTemplateList.Free;
  inherited;
end;

procedure TFhirImplementationGuideDefinition.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirImplementationGuideDefinition(oSource).FGroupingList = nil) then
  begin
    FGroupingList.free;
    FGroupingList := nil;
  end
  else
  begin
    if FGroupingList = nil then
      FGroupingList := TFhirImplementationGuideDefinitionGroupingList.Create;
    FGroupingList.Assign(TFhirImplementationGuideDefinition(oSource).FGroupingList);
  end;
  if (TFhirImplementationGuideDefinition(oSource).FResourceList = nil) then
  begin
    FResourceList.free;
    FResourceList := nil;
  end
  else
  begin
    if FResourceList = nil then
      FResourceList := TFhirImplementationGuideDefinitionResourceList.Create;
    FResourceList.Assign(TFhirImplementationGuideDefinition(oSource).FResourceList);
  end;
  page := TFhirImplementationGuideDefinition(oSource).page.Clone;
  if (TFhirImplementationGuideDefinition(oSource).FParameterList = nil) then
  begin
    FParameterList.free;
    FParameterList := nil;
  end
  else
  begin
    if FParameterList = nil then
      FParameterList := TFhirImplementationGuideDefinitionParameterList.Create;
    FParameterList.Assign(TFhirImplementationGuideDefinition(oSource).FParameterList);
  end;
  if (TFhirImplementationGuideDefinition(oSource).FTemplateList = nil) then
  begin
    FTemplateList.free;
    FTemplateList := nil;
  end
  else
  begin
    if FTemplateList = nil then
      FTemplateList := TFhirImplementationGuideDefinitionTemplateList.Create;
    FTemplateList.Assign(TFhirImplementationGuideDefinition(oSource).FTemplateList);
  end;
end;

procedure TFhirImplementationGuideDefinition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'grouping') Then
    list.addAll(self, 'grouping', FGroupingList);
  if (child_name = 'resource') Then
    list.addAll(self, 'resource', FResourceList);
  if (child_name = 'page') Then
     list.add(self.link, 'page', FPage.Link);
  if (child_name = 'parameter') Then
    list.addAll(self, 'parameter', FParameterList);
  if (child_name = 'template') Then
    list.addAll(self, 'template', FTemplateList);
end;

procedure TFhirImplementationGuideDefinition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'grouping', 'BackboneElement', true, TFhirImplementationGuideDefinitionGrouping, FGroupingList.Link));
  oList.add(TFHIRProperty.create(self, 'resource', 'BackboneElement', true, TFhirImplementationGuideDefinitionResource, FResourceList.Link));
  oList.add(TFHIRProperty.create(self, 'page', 'BackboneElement', false, TFhirImplementationGuideDefinitionPage, FPage.Link));
  oList.add(TFHIRProperty.create(self, 'parameter', 'BackboneElement', true, TFhirImplementationGuideDefinitionParameter, FParameterList.Link));
  oList.add(TFHIRProperty.create(self, 'template', 'BackboneElement', true, TFhirImplementationGuideDefinitionTemplate, FTemplateList.Link));
end;

function TFhirImplementationGuideDefinition.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'grouping') then
  begin
    GroupingList.add(propValue as TFhirImplementationGuideDefinitionGrouping);
    result := propValue;
  end
  else if (propName = 'resource') then
  begin
    ResourceList.add(propValue as TFhirImplementationGuideDefinitionResource);
    result := propValue;
  end
  else if (propName = 'page') then
  begin
    Page := propValue as TFhirImplementationGuideDefinitionPage;
    result := propValue;
  end
  else if (propName = 'parameter') then
  begin
    ParameterList.add(propValue as TFhirImplementationGuideDefinitionParameter);
    result := propValue;
  end
  else if (propName = 'template') then
  begin
    TemplateList.add(propValue as TFhirImplementationGuideDefinitionTemplate);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirImplementationGuideDefinition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'grouping') then GroupingList.insertItem(index, propValue as TFhirImplementationGuideDefinitionGrouping)
  else if (propName = 'resource') then ResourceList.insertItem(index, propValue as TFhirImplementationGuideDefinitionResource)
  else if (propName = 'parameter') then ParameterList.insertItem(index, propValue as TFhirImplementationGuideDefinitionParameter)
  else if (propName = 'template') then TemplateList.insertItem(index, propValue as TFhirImplementationGuideDefinitionTemplate)
  else inherited;
end;

function TFhirImplementationGuideDefinition.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'grouping') then result := GroupingList.new()
  else if (propName = 'resource') then result := ResourceList.new()
  else if (propName = 'page') then result := TFhirImplementationGuideDefinitionPage.create()
  else if (propName = 'parameter') then result := ParameterList.new()
  else if (propName = 'template') then result := TemplateList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirImplementationGuideDefinition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'grouping') then result := 'BackboneElement'
  else if (propName = 'resource') then result := 'BackboneElement'
  else if (propName = 'page') then result := 'BackboneElement'
  else if (propName = 'parameter') then result := 'BackboneElement'
  else if (propName = 'template') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImplementationGuideDefinition.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'grouping') then deletePropertyValue('grouping', GroupingList, value)
  else if (propName = 'resource') then deletePropertyValue('resource', ResourceList, value)
  else if (propName = 'page') then PageElement := nil
  else if (propName = 'parameter') then deletePropertyValue('parameter', ParameterList, value)
  else if (propName = 'template') then deletePropertyValue('template', TemplateList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImplementationGuideDefinition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'grouping') then replacePropertyValue('grouping', GroupingList, existing, new)
  else if (propName = 'resource') then replacePropertyValue('resource', ResourceList, existing, new)
  else if (propName = 'page') then PageElement := new as TFhirImplementationGuideDefinitionPage
  else if (propName = 'parameter') then replacePropertyValue('parameter', ParameterList, existing, new)
  else if (propName = 'template') then replacePropertyValue('template', TemplateList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImplementationGuideDefinition.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'grouping') then GroupingList.move(source, destination)
  else if (propName = 'resource') then ResourceList.move(source, destination)
  else if (propName = 'parameter') then ParameterList.move(source, destination)
  else if (propName = 'template') then TemplateList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirImplementationGuideDefinition.fhirType : string;
begin
  result := 'ImplementationGuide.definition';
end;

function TFhirImplementationGuideDefinition.Link : TFhirImplementationGuideDefinition;
begin
  result := TFhirImplementationGuideDefinition(inherited Link);
end;

function TFhirImplementationGuideDefinition.Clone : TFhirImplementationGuideDefinition;
begin
  result := TFhirImplementationGuideDefinition(inherited Clone);
end;

function TFhirImplementationGuideDefinition.equals(other : TObject) : boolean; 
var
  o : TFhirImplementationGuideDefinition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImplementationGuideDefinition)) then
    result := false
  else
  begin
    o := TFhirImplementationGuideDefinition(other);
    result := compareDeep(groupingList, o.groupingList, true) and compareDeep(resourceList, o.resourceList, true) and 
      compareDeep(pageElement, o.pageElement, true) and compareDeep(parameterList, o.parameterList, true) and 
      compareDeep(templateList, o.templateList, true);
  end;
end;

function TFhirImplementationGuideDefinition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FgroupingList) and isEmptyProp(FresourceList) and isEmptyProp(FPage) and isEmptyProp(FparameterList) and isEmptyProp(FtemplateList);
end;

procedure TFhirImplementationGuideDefinition.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('grouping');
  fields.add('resource');
  fields.add('page');
  fields.add('parameter');
  fields.add('template');
end;

function TFhirImplementationGuideDefinition.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FGroupingList.sizeInBytes(magic));
  inc(result, FResourceList.sizeInBytes(magic));
  inc(result, FParameterList.sizeInBytes(magic));
  inc(result, FTemplateList.sizeInBytes(magic));
end;

function TFhirImplementationGuideDefinition.GetGroupingList : TFhirImplementationGuideDefinitionGroupingList;
begin
  if FGroupingList = nil then
    FGroupingList := TFhirImplementationGuideDefinitionGroupingList.Create;
  result := FGroupingList;
end;

function TFhirImplementationGuideDefinition.GetHasGroupingList : boolean;
begin
  result := (FGroupingList <> nil) and (FGroupingList.count > 0);
end;

function TFhirImplementationGuideDefinition.GetResourceList : TFhirImplementationGuideDefinitionResourceList;
begin
  if FResourceList = nil then
    FResourceList := TFhirImplementationGuideDefinitionResourceList.Create;
  result := FResourceList;
end;

function TFhirImplementationGuideDefinition.GetHasResourceList : boolean;
begin
  result := (FResourceList <> nil) and (FResourceList.count > 0);
end;

procedure TFhirImplementationGuideDefinition.SetPage(value : TFhirImplementationGuideDefinitionPage);
begin
  FPage.free;
  FPage := value;
end;

function TFhirImplementationGuideDefinition.GetParameterList : TFhirImplementationGuideDefinitionParameterList;
begin
  if FParameterList = nil then
    FParameterList := TFhirImplementationGuideDefinitionParameterList.Create;
  result := FParameterList;
end;

function TFhirImplementationGuideDefinition.GetHasParameterList : boolean;
begin
  result := (FParameterList <> nil) and (FParameterList.count > 0);
end;

function TFhirImplementationGuideDefinition.GetTemplateList : TFhirImplementationGuideDefinitionTemplateList;
begin
  if FTemplateList = nil then
    FTemplateList := TFhirImplementationGuideDefinitionTemplateList.Create;
  result := FTemplateList;
end;

function TFhirImplementationGuideDefinition.GetHasTemplateList : boolean;
begin
  result := (FTemplateList <> nil) and (FTemplateList.count > 0);
end;

{ TFhirImplementationGuideDefinitionListEnumerator }

constructor TFhirImplementationGuideDefinitionListEnumerator.Create(list : TFhirImplementationGuideDefinitionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImplementationGuideDefinitionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImplementationGuideDefinitionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImplementationGuideDefinitionListEnumerator.GetCurrent : TFhirImplementationGuideDefinition;
begin
  Result := FList[FIndex];
end;

function TFhirImplementationGuideDefinitionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirImplementationGuideDefinitionList }

function TFhirImplementationGuideDefinitionList.AddItem(value: TFhirImplementationGuideDefinition): TFhirImplementationGuideDefinition;
begin
  assert(value.ClassName = 'TFhirImplementationGuideDefinition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImplementationGuideDefinition');
  add(value);
  result := value;
end;

function TFhirImplementationGuideDefinitionList.Append: TFhirImplementationGuideDefinition;
begin
  result := TFhirImplementationGuideDefinition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImplementationGuideDefinitionList.ClearItems;
begin
  Clear;
end;

function TFhirImplementationGuideDefinitionList.GetEnumerator : TFhirImplementationGuideDefinitionListEnumerator;
begin
  result := TFhirImplementationGuideDefinitionListEnumerator.Create(self.link);
end;

function TFhirImplementationGuideDefinitionList.Clone: TFhirImplementationGuideDefinitionList;
begin
  result := TFhirImplementationGuideDefinitionList(inherited Clone);
end;

function TFhirImplementationGuideDefinitionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImplementationGuideDefinitionList.GetItemN(index: Integer): TFhirImplementationGuideDefinition;
begin
  result := TFhirImplementationGuideDefinition(ObjectByIndex[index]);
end;

function TFhirImplementationGuideDefinitionList.ItemClass: TFslObjectClass;
begin
  result := TFhirImplementationGuideDefinition;
end;
function TFhirImplementationGuideDefinitionList.IndexOf(value: TFhirImplementationGuideDefinition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImplementationGuideDefinitionList.Insert(index: Integer): TFhirImplementationGuideDefinition;
begin
  result := TFhirImplementationGuideDefinition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImplementationGuideDefinitionList.InsertItem(index: Integer; value: TFhirImplementationGuideDefinition);
begin
  assert(value is TFhirImplementationGuideDefinition);
  Inherited Insert(index, value);
end;

function TFhirImplementationGuideDefinitionList.Item(index: Integer): TFhirImplementationGuideDefinition;
begin
  result := TFhirImplementationGuideDefinition(ObjectByIndex[index]);
end;

function TFhirImplementationGuideDefinitionList.Link: TFhirImplementationGuideDefinitionList;
begin
  result := TFhirImplementationGuideDefinitionList(inherited Link);
end;

procedure TFhirImplementationGuideDefinitionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImplementationGuideDefinitionList.SetItemByIndex(index: Integer; value: TFhirImplementationGuideDefinition);
begin
  assert(value is TFhirImplementationGuideDefinition);
  FhirImplementationGuideDefinitions[index] := value;
end;

procedure TFhirImplementationGuideDefinitionList.SetItemN(index: Integer; value: TFhirImplementationGuideDefinition);
begin
  assert(value is TFhirImplementationGuideDefinition);
  ObjectByIndex[index] := value;
end;

{ TFhirImplementationGuideDefinitionGrouping }

constructor TFhirImplementationGuideDefinitionGrouping.Create;
begin
  inherited;
end;

destructor TFhirImplementationGuideDefinitionGrouping.Destroy;
begin
  FName.free;
  FDescription.free;
  inherited;
end;

procedure TFhirImplementationGuideDefinitionGrouping.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirImplementationGuideDefinitionGrouping(oSource).nameElement.Clone;
  descriptionElement := TFhirImplementationGuideDefinitionGrouping(oSource).descriptionElement.Clone;
end;

procedure TFhirImplementationGuideDefinitionGrouping.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
end;

procedure TFhirImplementationGuideDefinitionGrouping.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));
end;

function TFhirImplementationGuideDefinitionGrouping.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirImplementationGuideDefinitionGrouping.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirImplementationGuideDefinitionGrouping.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'description') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirImplementationGuideDefinitionGrouping.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'description') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImplementationGuideDefinitionGrouping.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImplementationGuideDefinitionGrouping.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'description') then DescriptionElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImplementationGuideDefinitionGrouping.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirImplementationGuideDefinitionGrouping.fhirType : string;
begin
  result := 'ImplementationGuide.definition.grouping';
end;

function TFhirImplementationGuideDefinitionGrouping.Link : TFhirImplementationGuideDefinitionGrouping;
begin
  result := TFhirImplementationGuideDefinitionGrouping(inherited Link);
end;

function TFhirImplementationGuideDefinitionGrouping.Clone : TFhirImplementationGuideDefinitionGrouping;
begin
  result := TFhirImplementationGuideDefinitionGrouping(inherited Clone);
end;

function TFhirImplementationGuideDefinitionGrouping.equals(other : TObject) : boolean; 
var
  o : TFhirImplementationGuideDefinitionGrouping;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImplementationGuideDefinitionGrouping)) then
    result := false
  else
  begin
    o := TFhirImplementationGuideDefinitionGrouping(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(descriptionElement, o.descriptionElement, true);
  end;
end;

function TFhirImplementationGuideDefinitionGrouping.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FDescription);
end;

procedure TFhirImplementationGuideDefinitionGrouping.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('name');
  fields.add('description');
end;

function TFhirImplementationGuideDefinitionGrouping.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirImplementationGuideDefinitionGrouping.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirImplementationGuideDefinitionGrouping.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirImplementationGuideDefinitionGrouping.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirImplementationGuideDefinitionGrouping.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirImplementationGuideDefinitionGrouping.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirImplementationGuideDefinitionGrouping.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

{ TFhirImplementationGuideDefinitionGroupingListEnumerator }

constructor TFhirImplementationGuideDefinitionGroupingListEnumerator.Create(list : TFhirImplementationGuideDefinitionGroupingList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImplementationGuideDefinitionGroupingListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImplementationGuideDefinitionGroupingListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImplementationGuideDefinitionGroupingListEnumerator.GetCurrent : TFhirImplementationGuideDefinitionGrouping;
begin
  Result := FList[FIndex];
end;

function TFhirImplementationGuideDefinitionGroupingListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirImplementationGuideDefinitionGroupingList }

function TFhirImplementationGuideDefinitionGroupingList.AddItem(value: TFhirImplementationGuideDefinitionGrouping): TFhirImplementationGuideDefinitionGrouping;
begin
  assert(value.ClassName = 'TFhirImplementationGuideDefinitionGrouping', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImplementationGuideDefinitionGrouping');
  add(value);
  result := value;
end;

function TFhirImplementationGuideDefinitionGroupingList.Append: TFhirImplementationGuideDefinitionGrouping;
begin
  result := TFhirImplementationGuideDefinitionGrouping.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImplementationGuideDefinitionGroupingList.ClearItems;
begin
  Clear;
end;

function TFhirImplementationGuideDefinitionGroupingList.GetEnumerator : TFhirImplementationGuideDefinitionGroupingListEnumerator;
begin
  result := TFhirImplementationGuideDefinitionGroupingListEnumerator.Create(self.link);
end;

function TFhirImplementationGuideDefinitionGroupingList.Clone: TFhirImplementationGuideDefinitionGroupingList;
begin
  result := TFhirImplementationGuideDefinitionGroupingList(inherited Clone);
end;

function TFhirImplementationGuideDefinitionGroupingList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImplementationGuideDefinitionGroupingList.GetItemN(index: Integer): TFhirImplementationGuideDefinitionGrouping;
begin
  result := TFhirImplementationGuideDefinitionGrouping(ObjectByIndex[index]);
end;

function TFhirImplementationGuideDefinitionGroupingList.ItemClass: TFslObjectClass;
begin
  result := TFhirImplementationGuideDefinitionGrouping;
end;
function TFhirImplementationGuideDefinitionGroupingList.IndexOf(value: TFhirImplementationGuideDefinitionGrouping): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImplementationGuideDefinitionGroupingList.Insert(index: Integer): TFhirImplementationGuideDefinitionGrouping;
begin
  result := TFhirImplementationGuideDefinitionGrouping.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImplementationGuideDefinitionGroupingList.InsertItem(index: Integer; value: TFhirImplementationGuideDefinitionGrouping);
begin
  assert(value is TFhirImplementationGuideDefinitionGrouping);
  Inherited Insert(index, value);
end;

function TFhirImplementationGuideDefinitionGroupingList.Item(index: Integer): TFhirImplementationGuideDefinitionGrouping;
begin
  result := TFhirImplementationGuideDefinitionGrouping(ObjectByIndex[index]);
end;

function TFhirImplementationGuideDefinitionGroupingList.Link: TFhirImplementationGuideDefinitionGroupingList;
begin
  result := TFhirImplementationGuideDefinitionGroupingList(inherited Link);
end;

procedure TFhirImplementationGuideDefinitionGroupingList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImplementationGuideDefinitionGroupingList.SetItemByIndex(index: Integer; value: TFhirImplementationGuideDefinitionGrouping);
begin
  assert(value is TFhirImplementationGuideDefinitionGrouping);
  FhirImplementationGuideDefinitionGroupings[index] := value;
end;

procedure TFhirImplementationGuideDefinitionGroupingList.SetItemN(index: Integer; value: TFhirImplementationGuideDefinitionGrouping);
begin
  assert(value is TFhirImplementationGuideDefinitionGrouping);
  ObjectByIndex[index] := value;
end;

{ TFhirImplementationGuideDefinitionResource }

constructor TFhirImplementationGuideDefinitionResource.Create;
begin
  inherited;
end;

destructor TFhirImplementationGuideDefinitionResource.Destroy;
begin
  FReference.free;
  FFhirVersion.Free;
  FName.free;
  FDescription.free;
  FExample.free;
  FGroupingId.free;
  inherited;
end;

procedure TFhirImplementationGuideDefinitionResource.Assign(oSource : TFslObject);
begin
  inherited;
  reference := TFhirImplementationGuideDefinitionResource(oSource).reference.Clone;
  if (TFhirImplementationGuideDefinitionResource(oSource).FFhirVersion = nil) then
  begin
    FFhirVersion.free;
    FFhirVersion := nil;
  end
  else
  begin
    FFhirVersion := TFhirEnumList.Create(SYSTEMS_TFhirFHIRVersionEnum, CODES_TFhirFHIRVersionEnum);
    FFhirVersion.Assign(TFhirImplementationGuideDefinitionResource(oSource).FFhirVersion);
  end;
  nameElement := TFhirImplementationGuideDefinitionResource(oSource).nameElement.Clone;
  descriptionElement := TFhirImplementationGuideDefinitionResource(oSource).descriptionElement.Clone;
  example := TFhirImplementationGuideDefinitionResource(oSource).example.Clone;
  groupingIdElement := TFhirImplementationGuideDefinitionResource(oSource).groupingIdElement.Clone;
end;

procedure TFhirImplementationGuideDefinitionResource.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'reference') Then
     list.add(self.link, 'reference', FReference.Link);
  if (child_name = 'fhirVersion') Then
     list.addAll(self, 'fhirVersion', FFhirVersion);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'example[x]') or (child_name = 'example') Then
     list.add(self.link, 'example[x]', FExample.Link);
  if (child_name = 'groupingId') Then
     list.add(self.link, 'groupingId', FGroupingId.Link);
end;

procedure TFhirImplementationGuideDefinitionResource.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'reference', 'Reference', false, TFhirReference, FReference.Link));
  oList.add(TFHIRProperty.create(self, 'fhirVersion', 'code', true, TFhirEnum, FFhirVersion.Link));
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'example[x]', 'boolean|canonical', false, TFhirDataType, FExample.Link));
  oList.add(TFHIRProperty.create(self, 'groupingId', 'id', false, TFhirId, FGroupingId.Link));
end;

function TFhirImplementationGuideDefinitionResource.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'reference') then
  begin
    Reference := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'fhirVersion') then
  begin
    FhirVersionList.add(asEnum(SYSTEMS_TFhirFHIRVersionEnum, CODES_TFhirFHIRVersionEnum, propValue));
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue);
    result := propValue;
  end
  else if (isMatchingName(propName, 'example', ['Boolean', 'Canonical'])) then
  begin
    Example := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'groupingId') then
  begin
    GroupingIdElement := asId(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirImplementationGuideDefinitionResource.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'fhirVersion') then FFhirVersion.insertItem(index, asEnum(SYSTEMS_TFhirFHIRVersionEnum, CODES_TFhirFHIRVersionEnum, propValue))
  else inherited;
end;

function TFhirImplementationGuideDefinitionResource.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'reference') then result := TFhirReference.create()
  else if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'description') then result := TFhirString.create()
  else if (isMatchingName(propName, 'example', ['Boolean', 'Canonical'])) then raise EFHIRException.create('Cannot make property Example')
  else if (propName = 'groupingId') then result := TFhirId.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirImplementationGuideDefinitionResource.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'reference') then result := 'Reference'
  else if (propName = 'fhirVersion') then result := 'code'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'example[x]') then result := 'boolean|canonical'
  else if (propName = 'groupingId') then result := 'id'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImplementationGuideDefinitionResource.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'reference') then ReferenceElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (isMatchingName(propName, 'example', ['Boolean', 'Canonical'])) then ExampleElement := nil
  else if (propName = 'groupingId') then GroupingIdElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImplementationGuideDefinitionResource.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'reference') then ReferenceElement := new as TFhirReference
  else if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'description') then DescriptionElement := asString(new)
  else if (isMatchingName(propName, 'example', ['Boolean', 'Canonical'])) then ExampleElement := new as TFhirDataType
  else if (propName = 'groupingId') then GroupingIdElement := asId(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImplementationGuideDefinitionResource.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'fhirVersion') then FFhirVersion.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirImplementationGuideDefinitionResource.fhirType : string;
begin
  result := 'ImplementationGuide.definition.resource';
end;

function TFhirImplementationGuideDefinitionResource.Link : TFhirImplementationGuideDefinitionResource;
begin
  result := TFhirImplementationGuideDefinitionResource(inherited Link);
end;

function TFhirImplementationGuideDefinitionResource.Clone : TFhirImplementationGuideDefinitionResource;
begin
  result := TFhirImplementationGuideDefinitionResource(inherited Clone);
end;

function TFhirImplementationGuideDefinitionResource.equals(other : TObject) : boolean; 
var
  o : TFhirImplementationGuideDefinitionResource;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImplementationGuideDefinitionResource)) then
    result := false
  else
  begin
    o := TFhirImplementationGuideDefinitionResource(other);
    result := compareDeep(referenceElement, o.referenceElement, true) and compareDeep(fhirVersionList, o.fhirVersionList, true) and 
      compareDeep(nameElement, o.nameElement, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(exampleElement, o.exampleElement, true) and compareDeep(groupingIdElement, o.groupingIdElement, true);
  end;
end;

function TFhirImplementationGuideDefinitionResource.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FReference) and isEmptyProp(FFhirVersion) and isEmptyProp(FName) and isEmptyProp(FDescription) and isEmptyProp(FExample) and isEmptyProp(FGroupingId);
end;

procedure TFhirImplementationGuideDefinitionResource.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('reference');
  fields.add('fhirVersion');
  fields.add('name');
  fields.add('description');
  fields.add('example[x]');
  fields.add('groupingId');
end;

function TFhirImplementationGuideDefinitionResource.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FFhirVersion.sizeInBytes(magic));
end;

procedure TFhirImplementationGuideDefinitionResource.SetReference(value : TFhirReference);
begin
  FReference.free;
  FReference := value;
end;

function TFhirImplementationGuideDefinitionResource.GetFhirVersion : TFhirEnumList;
begin
  if FFhirVersion = nil then
    FFhirVersion := TFhirEnumList.Create(SYSTEMS_TFhirFHIRVersionEnum, CODES_TFhirFHIRVersionEnum);
  result := FFhirVersion;
end;

function TFhirImplementationGuideDefinitionResource.GetHasFhirVersion : boolean;
begin
  result := (FFhirVersion <> nil) and (FFhirVersion.count > 0);
end;

function TFhirImplementationGuideDefinitionResource.GetFhirVersionST : TFhirFHIRVersionEnumList;
  var i : integer;
begin
  result := [];
  if FfhirVersion <> nil then
    for i := 0 to FfhirVersion.count - 1 do
      result := result + [TFhirFHIRVersionEnum(StringArrayIndexOfSensitive(CODES_TFhirFHIRVersionEnum, FfhirVersion[i].value))];
end;

procedure TFhirImplementationGuideDefinitionResource.SetFhirVersionST(value : TFhirFHIRVersionEnumList);
var a : TFhirFHIRVersionEnum;
begin
  if FfhirVersion = nil then
    FfhirVersion := TFhirEnumList.create(SYSTEMS_TFhirFHIRVersionEnum, CODES_TFhirFHIRVersionEnum);
  FfhirVersion.clear;
  for a := low(TFhirFHIRVersionEnum) to high(TFhirFHIRVersionEnum) do
    if a in value then
      begin
         if FfhirVersion = nil then
           FfhirVersion := TFhirEnumList.create(SYSTEMS_TFhirFHIRVersionEnum, CODES_TFhirFHIRVersionEnum);
         FfhirVersion.add(TFhirEnum.create(SYSTEMS_TFhirFHIRVersionEnum[a], CODES_TFhirFHIRVersionEnum[a]));
      end;
end;

procedure TFhirImplementationGuideDefinitionResource.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirImplementationGuideDefinitionResource.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirImplementationGuideDefinitionResource.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirImplementationGuideDefinitionResource.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirImplementationGuideDefinitionResource.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirImplementationGuideDefinitionResource.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirImplementationGuideDefinitionResource.SetExample(value : TFhirDataType);
begin
  FExample.free;
  FExample := value;
end;

procedure TFhirImplementationGuideDefinitionResource.SetGroupingId(value : TFhirId);
begin
  FGroupingId.free;
  FGroupingId := value;
end;

function TFhirImplementationGuideDefinitionResource.GetGroupingIdST : String;
begin
  if FGroupingId = nil then
    result := ''
  else
    result := FGroupingId.value;
end;

procedure TFhirImplementationGuideDefinitionResource.SetGroupingIdST(value : String);
begin
  if value <> '' then
  begin
    if FGroupingId = nil then
      FGroupingId := TFhirId.create;
    FGroupingId.value := value
  end
  else if FGroupingId <> nil then
    FGroupingId.value := '';
end;

{ TFhirImplementationGuideDefinitionResourceListEnumerator }

constructor TFhirImplementationGuideDefinitionResourceListEnumerator.Create(list : TFhirImplementationGuideDefinitionResourceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImplementationGuideDefinitionResourceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImplementationGuideDefinitionResourceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImplementationGuideDefinitionResourceListEnumerator.GetCurrent : TFhirImplementationGuideDefinitionResource;
begin
  Result := FList[FIndex];
end;

function TFhirImplementationGuideDefinitionResourceListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirImplementationGuideDefinitionResourceList }

function TFhirImplementationGuideDefinitionResourceList.AddItem(value: TFhirImplementationGuideDefinitionResource): TFhirImplementationGuideDefinitionResource;
begin
  assert(value.ClassName = 'TFhirImplementationGuideDefinitionResource', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImplementationGuideDefinitionResource');
  add(value);
  result := value;
end;

function TFhirImplementationGuideDefinitionResourceList.Append: TFhirImplementationGuideDefinitionResource;
begin
  result := TFhirImplementationGuideDefinitionResource.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImplementationGuideDefinitionResourceList.ClearItems;
begin
  Clear;
end;

function TFhirImplementationGuideDefinitionResourceList.GetEnumerator : TFhirImplementationGuideDefinitionResourceListEnumerator;
begin
  result := TFhirImplementationGuideDefinitionResourceListEnumerator.Create(self.link);
end;

function TFhirImplementationGuideDefinitionResourceList.Clone: TFhirImplementationGuideDefinitionResourceList;
begin
  result := TFhirImplementationGuideDefinitionResourceList(inherited Clone);
end;

function TFhirImplementationGuideDefinitionResourceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImplementationGuideDefinitionResourceList.GetItemN(index: Integer): TFhirImplementationGuideDefinitionResource;
begin
  result := TFhirImplementationGuideDefinitionResource(ObjectByIndex[index]);
end;

function TFhirImplementationGuideDefinitionResourceList.ItemClass: TFslObjectClass;
begin
  result := TFhirImplementationGuideDefinitionResource;
end;
function TFhirImplementationGuideDefinitionResourceList.IndexOf(value: TFhirImplementationGuideDefinitionResource): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImplementationGuideDefinitionResourceList.Insert(index: Integer): TFhirImplementationGuideDefinitionResource;
begin
  result := TFhirImplementationGuideDefinitionResource.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImplementationGuideDefinitionResourceList.InsertItem(index: Integer; value: TFhirImplementationGuideDefinitionResource);
begin
  assert(value is TFhirImplementationGuideDefinitionResource);
  Inherited Insert(index, value);
end;

function TFhirImplementationGuideDefinitionResourceList.Item(index: Integer): TFhirImplementationGuideDefinitionResource;
begin
  result := TFhirImplementationGuideDefinitionResource(ObjectByIndex[index]);
end;

function TFhirImplementationGuideDefinitionResourceList.Link: TFhirImplementationGuideDefinitionResourceList;
begin
  result := TFhirImplementationGuideDefinitionResourceList(inherited Link);
end;

procedure TFhirImplementationGuideDefinitionResourceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImplementationGuideDefinitionResourceList.SetItemByIndex(index: Integer; value: TFhirImplementationGuideDefinitionResource);
begin
  assert(value is TFhirImplementationGuideDefinitionResource);
  FhirImplementationGuideDefinitionResources[index] := value;
end;

procedure TFhirImplementationGuideDefinitionResourceList.SetItemN(index: Integer; value: TFhirImplementationGuideDefinitionResource);
begin
  assert(value is TFhirImplementationGuideDefinitionResource);
  ObjectByIndex[index] := value;
end;

{ TFhirImplementationGuideDefinitionPage }

constructor TFhirImplementationGuideDefinitionPage.Create;
begin
  inherited;
end;

destructor TFhirImplementationGuideDefinitionPage.Destroy;
begin
  FName.free;
  FTitle.free;
  FGeneration.free;
  FPageList.Free;
  inherited;
end;

procedure TFhirImplementationGuideDefinitionPage.Assign(oSource : TFslObject);
begin
  inherited;
  name := TFhirImplementationGuideDefinitionPage(oSource).name.Clone;
  titleElement := TFhirImplementationGuideDefinitionPage(oSource).titleElement.Clone;
  generationElement := TFhirImplementationGuideDefinitionPage(oSource).generationElement.Clone;
  if (TFhirImplementationGuideDefinitionPage(oSource).FPageList = nil) then
  begin
    FPageList.free;
    FPageList := nil;
  end
  else
  begin
    if FPageList = nil then
      FPageList := TFhirImplementationGuideDefinitionPageList.Create;
    FPageList.Assign(TFhirImplementationGuideDefinitionPage(oSource).FPageList);
  end;
end;

procedure TFhirImplementationGuideDefinitionPage.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name[x]') or (child_name = 'name') Then
     list.add(self.link, 'name[x]', FName.Link);
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
  if (child_name = 'generation') Then
     list.add(self.link, 'generation', FGeneration.Link);
  if (child_name = 'page') Then
    list.addAll(self, 'page', FPageList);
end;

procedure TFhirImplementationGuideDefinitionPage.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name[x]', 'url|Reference', false, TFhirDataType, FName.Link));
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link));
  oList.add(TFHIRProperty.create(self, 'generation', 'code', false, TFhirEnum, FGeneration.Link));
  oList.add(TFHIRProperty.create(self, 'page', '', true, TFhirImplementationGuideDefinitionPage, FPageList.Link));
end;

function TFhirImplementationGuideDefinitionPage.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'name', ['Url', 'Reference'])) then
  begin
    Name := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'title') then
  begin
    TitleElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'generation') then
  begin
    GenerationElement := asEnum(SYSTEMS_TFhirGuidePageGenerationEnum, CODES_TFhirGuidePageGenerationEnum, propValue);
    result := propValue;
  end
  else if (propName = 'page') then
  begin
    PageList.add(propValue as TFhirImplementationGuideDefinitionPage);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirImplementationGuideDefinitionPage.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'page') then PageList.insertItem(index, propValue as TFhirImplementationGuideDefinitionPage)
  else inherited;
end;

function TFhirImplementationGuideDefinitionPage.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'name', ['Url', 'Reference'])) then raise EFHIRException.create('Cannot make property Name')
  else if (propName = 'title') then result := TFhirString.create()
  else if (propName = 'generation') then result := TFhirEnum.create(SYSTEMS_TFhirGuidePageGenerationEnum[GuidePageGenerationNull], CODES_TFhirGuidePageGenerationEnum[GuidePageGenerationNull]) 
  else if (propName = 'page') then result := PageList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirImplementationGuideDefinitionPage.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name[x]') then result := 'url|Reference'
  else if (propName = 'title') then result := 'string'
  else if (propName = 'generation') then result := 'code'
  else if (propName = 'page') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImplementationGuideDefinitionPage.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'name', ['Url', 'Reference'])) then NameElement := nil
  else if (propName = 'title') then TitleElement := nil
  else if (propName = 'generation') then GenerationElement := nil
  else if (propName = 'page') then deletePropertyValue('page', PageList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImplementationGuideDefinitionPage.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'name', ['Url', 'Reference'])) then NameElement := new as TFhirDataType
  else if (propName = 'title') then TitleElement := asString(new)
  else if (propName = 'generation') then GenerationElement := asEnum(SYSTEMS_TFhirGuidePageGenerationEnum, CODES_TFhirGuidePageGenerationEnum, new)
  else if (propName = 'page') then replacePropertyValue('page', PageList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImplementationGuideDefinitionPage.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'page') then PageList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirImplementationGuideDefinitionPage.fhirType : string;
begin
  result := 'ImplementationGuide.definition.page';
end;

function TFhirImplementationGuideDefinitionPage.Link : TFhirImplementationGuideDefinitionPage;
begin
  result := TFhirImplementationGuideDefinitionPage(inherited Link);
end;

function TFhirImplementationGuideDefinitionPage.Clone : TFhirImplementationGuideDefinitionPage;
begin
  result := TFhirImplementationGuideDefinitionPage(inherited Clone);
end;

function TFhirImplementationGuideDefinitionPage.equals(other : TObject) : boolean; 
var
  o : TFhirImplementationGuideDefinitionPage;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImplementationGuideDefinitionPage)) then
    result := false
  else
  begin
    o := TFhirImplementationGuideDefinitionPage(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(titleElement, o.titleElement, true) and 
      compareDeep(generationElement, o.generationElement, true) and compareDeep(pageList, o.pageList, true);
  end;
end;

function TFhirImplementationGuideDefinitionPage.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FTitle) and isEmptyProp(FGeneration) and isEmptyProp(FpageList);
end;

procedure TFhirImplementationGuideDefinitionPage.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('name[x]');
  fields.add('title');
  fields.add('generation');
  fields.add('page');
end;

function TFhirImplementationGuideDefinitionPage.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FPageList.sizeInBytes(magic));
end;

procedure TFhirImplementationGuideDefinitionPage.SetName(value : TFhirDataType);
begin
  FName.free;
  FName := value;
end;

procedure TFhirImplementationGuideDefinitionPage.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

function TFhirImplementationGuideDefinitionPage.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

procedure TFhirImplementationGuideDefinitionPage.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

procedure TFhirImplementationGuideDefinitionPage.SetGeneration(value : TFhirEnum);
begin
  FGeneration.free;
  FGeneration := value;
end;

function TFhirImplementationGuideDefinitionPage.GetGenerationST : TFhirGuidePageGenerationEnum;
begin
  if FGeneration = nil then
    result := TFhirGuidePageGenerationEnum(0)
  else
    result := TFhirGuidePageGenerationEnum(StringArrayIndexOfSensitive(CODES_TFhirGuidePageGenerationEnum, FGeneration.value));
end;

procedure TFhirImplementationGuideDefinitionPage.SetGenerationST(value : TFhirGuidePageGenerationEnum);
begin
  if ord(value) = 0 then
    GenerationElement := nil
  else
    GenerationElement := TFhirEnum.create(SYSTEMS_TFhirGuidePageGenerationEnum[value], CODES_TFhirGuidePageGenerationEnum[value]);
end;

function TFhirImplementationGuideDefinitionPage.GetPageList : TFhirImplementationGuideDefinitionPageList;
begin
  if FPageList = nil then
    FPageList := TFhirImplementationGuideDefinitionPageList.Create;
  result := FPageList;
end;

function TFhirImplementationGuideDefinitionPage.GetHasPageList : boolean;
begin
  result := (FPageList <> nil) and (FPageList.count > 0);
end;

{ TFhirImplementationGuideDefinitionPageListEnumerator }

constructor TFhirImplementationGuideDefinitionPageListEnumerator.Create(list : TFhirImplementationGuideDefinitionPageList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImplementationGuideDefinitionPageListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImplementationGuideDefinitionPageListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImplementationGuideDefinitionPageListEnumerator.GetCurrent : TFhirImplementationGuideDefinitionPage;
begin
  Result := FList[FIndex];
end;

function TFhirImplementationGuideDefinitionPageListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirImplementationGuideDefinitionPageList }

function TFhirImplementationGuideDefinitionPageList.AddItem(value: TFhirImplementationGuideDefinitionPage): TFhirImplementationGuideDefinitionPage;
begin
  assert(value.ClassName = 'TFhirImplementationGuideDefinitionPage', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImplementationGuideDefinitionPage');
  add(value);
  result := value;
end;

function TFhirImplementationGuideDefinitionPageList.Append: TFhirImplementationGuideDefinitionPage;
begin
  result := TFhirImplementationGuideDefinitionPage.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImplementationGuideDefinitionPageList.ClearItems;
begin
  Clear;
end;

function TFhirImplementationGuideDefinitionPageList.GetEnumerator : TFhirImplementationGuideDefinitionPageListEnumerator;
begin
  result := TFhirImplementationGuideDefinitionPageListEnumerator.Create(self.link);
end;

function TFhirImplementationGuideDefinitionPageList.Clone: TFhirImplementationGuideDefinitionPageList;
begin
  result := TFhirImplementationGuideDefinitionPageList(inherited Clone);
end;

function TFhirImplementationGuideDefinitionPageList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImplementationGuideDefinitionPageList.GetItemN(index: Integer): TFhirImplementationGuideDefinitionPage;
begin
  result := TFhirImplementationGuideDefinitionPage(ObjectByIndex[index]);
end;

function TFhirImplementationGuideDefinitionPageList.ItemClass: TFslObjectClass;
begin
  result := TFhirImplementationGuideDefinitionPage;
end;
function TFhirImplementationGuideDefinitionPageList.IndexOf(value: TFhirImplementationGuideDefinitionPage): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImplementationGuideDefinitionPageList.Insert(index: Integer): TFhirImplementationGuideDefinitionPage;
begin
  result := TFhirImplementationGuideDefinitionPage.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImplementationGuideDefinitionPageList.InsertItem(index: Integer; value: TFhirImplementationGuideDefinitionPage);
begin
  assert(value is TFhirImplementationGuideDefinitionPage);
  Inherited Insert(index, value);
end;

function TFhirImplementationGuideDefinitionPageList.Item(index: Integer): TFhirImplementationGuideDefinitionPage;
begin
  result := TFhirImplementationGuideDefinitionPage(ObjectByIndex[index]);
end;

function TFhirImplementationGuideDefinitionPageList.Link: TFhirImplementationGuideDefinitionPageList;
begin
  result := TFhirImplementationGuideDefinitionPageList(inherited Link);
end;

procedure TFhirImplementationGuideDefinitionPageList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImplementationGuideDefinitionPageList.SetItemByIndex(index: Integer; value: TFhirImplementationGuideDefinitionPage);
begin
  assert(value is TFhirImplementationGuideDefinitionPage);
  FhirImplementationGuideDefinitionPages[index] := value;
end;

procedure TFhirImplementationGuideDefinitionPageList.SetItemN(index: Integer; value: TFhirImplementationGuideDefinitionPage);
begin
  assert(value is TFhirImplementationGuideDefinitionPage);
  ObjectByIndex[index] := value;
end;

{ TFhirImplementationGuideDefinitionParameter }

constructor TFhirImplementationGuideDefinitionParameter.Create;
begin
  inherited;
end;

destructor TFhirImplementationGuideDefinitionParameter.Destroy;
begin
  FCode.free;
  FValue.free;
  inherited;
end;

procedure TFhirImplementationGuideDefinitionParameter.Assign(oSource : TFslObject);
begin
  inherited;
  codeElement := TFhirImplementationGuideDefinitionParameter(oSource).codeElement.Clone;
  valueElement := TFhirImplementationGuideDefinitionParameter(oSource).valueElement.Clone;
end;

procedure TFhirImplementationGuideDefinitionParameter.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
end;

procedure TFhirImplementationGuideDefinitionParameter.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'code', false, TFhirEnum, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'value', 'string', false, TFhirString, FValue.Link));
end;

function TFhirImplementationGuideDefinitionParameter.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    CodeElement := asEnum(SYSTEMS_TFhirGuideParameterCodeEnum, CODES_TFhirGuideParameterCodeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'value') then
  begin
    ValueElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirImplementationGuideDefinitionParameter.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirImplementationGuideDefinitionParameter.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirEnum.create(SYSTEMS_TFhirGuideParameterCodeEnum[GuideParameterCodeNull], CODES_TFhirGuideParameterCodeEnum[GuideParameterCodeNull]) 
  else if (propName = 'value') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirImplementationGuideDefinitionParameter.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'code'
  else if (propName = 'value') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImplementationGuideDefinitionParameter.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'value') then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImplementationGuideDefinitionParameter.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := asEnum(SYSTEMS_TFhirGuideParameterCodeEnum, CODES_TFhirGuideParameterCodeEnum, new)
  else if (propName = 'value') then ValueElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImplementationGuideDefinitionParameter.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirImplementationGuideDefinitionParameter.fhirType : string;
begin
  result := 'ImplementationGuide.definition.parameter';
end;

function TFhirImplementationGuideDefinitionParameter.Link : TFhirImplementationGuideDefinitionParameter;
begin
  result := TFhirImplementationGuideDefinitionParameter(inherited Link);
end;

function TFhirImplementationGuideDefinitionParameter.Clone : TFhirImplementationGuideDefinitionParameter;
begin
  result := TFhirImplementationGuideDefinitionParameter(inherited Clone);
end;

function TFhirImplementationGuideDefinitionParameter.equals(other : TObject) : boolean; 
var
  o : TFhirImplementationGuideDefinitionParameter;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImplementationGuideDefinitionParameter)) then
    result := false
  else
  begin
    o := TFhirImplementationGuideDefinitionParameter(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirImplementationGuideDefinitionParameter.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FValue);
end;

procedure TFhirImplementationGuideDefinitionParameter.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('code');
  fields.add('value');
end;

function TFhirImplementationGuideDefinitionParameter.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirImplementationGuideDefinitionParameter.SetCode(value : TFhirEnum);
begin
  FCode.free;
  FCode := value;
end;

function TFhirImplementationGuideDefinitionParameter.GetCodeST : TFhirGuideParameterCodeEnum;
begin
  if FCode = nil then
    result := TFhirGuideParameterCodeEnum(0)
  else
    result := TFhirGuideParameterCodeEnum(StringArrayIndexOfSensitive(CODES_TFhirGuideParameterCodeEnum, FCode.value));
end;

procedure TFhirImplementationGuideDefinitionParameter.SetCodeST(value : TFhirGuideParameterCodeEnum);
begin
  if ord(value) = 0 then
    CodeElement := nil
  else
    CodeElement := TFhirEnum.create(SYSTEMS_TFhirGuideParameterCodeEnum[value], CODES_TFhirGuideParameterCodeEnum[value]);
end;

procedure TFhirImplementationGuideDefinitionParameter.SetValue(value : TFhirString);
begin
  FValue.free;
  FValue := value;
end;

function TFhirImplementationGuideDefinitionParameter.GetValueST : String;
begin
  if FValue = nil then
    result := ''
  else
    result := FValue.value;
end;

procedure TFhirImplementationGuideDefinitionParameter.SetValueST(value : String);
begin
  if value <> '' then
  begin
    if FValue = nil then
      FValue := TFhirString.create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := '';
end;

{ TFhirImplementationGuideDefinitionParameterListEnumerator }

constructor TFhirImplementationGuideDefinitionParameterListEnumerator.Create(list : TFhirImplementationGuideDefinitionParameterList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImplementationGuideDefinitionParameterListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImplementationGuideDefinitionParameterListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImplementationGuideDefinitionParameterListEnumerator.GetCurrent : TFhirImplementationGuideDefinitionParameter;
begin
  Result := FList[FIndex];
end;

function TFhirImplementationGuideDefinitionParameterListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirImplementationGuideDefinitionParameterList }

function TFhirImplementationGuideDefinitionParameterList.AddItem(value: TFhirImplementationGuideDefinitionParameter): TFhirImplementationGuideDefinitionParameter;
begin
  assert(value.ClassName = 'TFhirImplementationGuideDefinitionParameter', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImplementationGuideDefinitionParameter');
  add(value);
  result := value;
end;

function TFhirImplementationGuideDefinitionParameterList.Append: TFhirImplementationGuideDefinitionParameter;
begin
  result := TFhirImplementationGuideDefinitionParameter.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImplementationGuideDefinitionParameterList.ClearItems;
begin
  Clear;
end;

function TFhirImplementationGuideDefinitionParameterList.GetEnumerator : TFhirImplementationGuideDefinitionParameterListEnumerator;
begin
  result := TFhirImplementationGuideDefinitionParameterListEnumerator.Create(self.link);
end;

function TFhirImplementationGuideDefinitionParameterList.Clone: TFhirImplementationGuideDefinitionParameterList;
begin
  result := TFhirImplementationGuideDefinitionParameterList(inherited Clone);
end;

function TFhirImplementationGuideDefinitionParameterList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImplementationGuideDefinitionParameterList.GetItemN(index: Integer): TFhirImplementationGuideDefinitionParameter;
begin
  result := TFhirImplementationGuideDefinitionParameter(ObjectByIndex[index]);
end;

function TFhirImplementationGuideDefinitionParameterList.ItemClass: TFslObjectClass;
begin
  result := TFhirImplementationGuideDefinitionParameter;
end;
function TFhirImplementationGuideDefinitionParameterList.IndexOf(value: TFhirImplementationGuideDefinitionParameter): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImplementationGuideDefinitionParameterList.Insert(index: Integer): TFhirImplementationGuideDefinitionParameter;
begin
  result := TFhirImplementationGuideDefinitionParameter.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImplementationGuideDefinitionParameterList.InsertItem(index: Integer; value: TFhirImplementationGuideDefinitionParameter);
begin
  assert(value is TFhirImplementationGuideDefinitionParameter);
  Inherited Insert(index, value);
end;

function TFhirImplementationGuideDefinitionParameterList.Item(index: Integer): TFhirImplementationGuideDefinitionParameter;
begin
  result := TFhirImplementationGuideDefinitionParameter(ObjectByIndex[index]);
end;

function TFhirImplementationGuideDefinitionParameterList.Link: TFhirImplementationGuideDefinitionParameterList;
begin
  result := TFhirImplementationGuideDefinitionParameterList(inherited Link);
end;

procedure TFhirImplementationGuideDefinitionParameterList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImplementationGuideDefinitionParameterList.SetItemByIndex(index: Integer; value: TFhirImplementationGuideDefinitionParameter);
begin
  assert(value is TFhirImplementationGuideDefinitionParameter);
  FhirImplementationGuideDefinitionParameters[index] := value;
end;

procedure TFhirImplementationGuideDefinitionParameterList.SetItemN(index: Integer; value: TFhirImplementationGuideDefinitionParameter);
begin
  assert(value is TFhirImplementationGuideDefinitionParameter);
  ObjectByIndex[index] := value;
end;

{ TFhirImplementationGuideDefinitionTemplate }

constructor TFhirImplementationGuideDefinitionTemplate.Create;
begin
  inherited;
end;

destructor TFhirImplementationGuideDefinitionTemplate.Destroy;
begin
  FCode.free;
  FSource.free;
  FScope.free;
  inherited;
end;

procedure TFhirImplementationGuideDefinitionTemplate.Assign(oSource : TFslObject);
begin
  inherited;
  codeElement := TFhirImplementationGuideDefinitionTemplate(oSource).codeElement.Clone;
  sourceElement := TFhirImplementationGuideDefinitionTemplate(oSource).sourceElement.Clone;
  scopeElement := TFhirImplementationGuideDefinitionTemplate(oSource).scopeElement.Clone;
end;

procedure TFhirImplementationGuideDefinitionTemplate.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'source') Then
     list.add(self.link, 'source', FSource.Link);
  if (child_name = 'scope') Then
     list.add(self.link, 'scope', FScope.Link);
end;

procedure TFhirImplementationGuideDefinitionTemplate.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'code', false, TFhirCode, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'source', 'string', false, TFhirString, FSource.Link));
  oList.add(TFHIRProperty.create(self, 'scope', 'string', false, TFhirString, FScope.Link));
end;

function TFhirImplementationGuideDefinitionTemplate.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    CodeElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    SourceElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'scope') then
  begin
    ScopeElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirImplementationGuideDefinitionTemplate.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirImplementationGuideDefinitionTemplate.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCode.create()
  else if (propName = 'source') then result := TFhirString.create()
  else if (propName = 'scope') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirImplementationGuideDefinitionTemplate.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'code'
  else if (propName = 'source') then result := 'string'
  else if (propName = 'scope') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImplementationGuideDefinitionTemplate.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'source') then SourceElement := nil
  else if (propName = 'scope') then ScopeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImplementationGuideDefinitionTemplate.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := asCode(new)
  else if (propName = 'source') then SourceElement := asString(new)
  else if (propName = 'scope') then ScopeElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImplementationGuideDefinitionTemplate.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirImplementationGuideDefinitionTemplate.fhirType : string;
begin
  result := 'ImplementationGuide.definition.template';
end;

function TFhirImplementationGuideDefinitionTemplate.Link : TFhirImplementationGuideDefinitionTemplate;
begin
  result := TFhirImplementationGuideDefinitionTemplate(inherited Link);
end;

function TFhirImplementationGuideDefinitionTemplate.Clone : TFhirImplementationGuideDefinitionTemplate;
begin
  result := TFhirImplementationGuideDefinitionTemplate(inherited Clone);
end;

function TFhirImplementationGuideDefinitionTemplate.equals(other : TObject) : boolean; 
var
  o : TFhirImplementationGuideDefinitionTemplate;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImplementationGuideDefinitionTemplate)) then
    result := false
  else
  begin
    o := TFhirImplementationGuideDefinitionTemplate(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(sourceElement, o.sourceElement, true) and 
      compareDeep(scopeElement, o.scopeElement, true);
  end;
end;

function TFhirImplementationGuideDefinitionTemplate.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FSource) and isEmptyProp(FScope);
end;

procedure TFhirImplementationGuideDefinitionTemplate.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('code');
  fields.add('source');
  fields.add('scope');
end;

function TFhirImplementationGuideDefinitionTemplate.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirImplementationGuideDefinitionTemplate.SetCode(value : TFhirCode);
begin
  FCode.free;
  FCode := value;
end;

function TFhirImplementationGuideDefinitionTemplate.GetCodeST : String;
begin
  if FCode = nil then
    result := ''
  else
    result := FCode.value;
end;

procedure TFhirImplementationGuideDefinitionTemplate.SetCodeST(value : String);
begin
  if value <> '' then
  begin
    if FCode = nil then
      FCode := TFhirCode.create;
    FCode.value := value
  end
  else if FCode <> nil then
    FCode.value := '';
end;

procedure TFhirImplementationGuideDefinitionTemplate.SetSource(value : TFhirString);
begin
  FSource.free;
  FSource := value;
end;

function TFhirImplementationGuideDefinitionTemplate.GetSourceST : String;
begin
  if FSource = nil then
    result := ''
  else
    result := FSource.value;
end;

procedure TFhirImplementationGuideDefinitionTemplate.SetSourceST(value : String);
begin
  if value <> '' then
  begin
    if FSource = nil then
      FSource := TFhirString.create;
    FSource.value := value
  end
  else if FSource <> nil then
    FSource.value := '';
end;

procedure TFhirImplementationGuideDefinitionTemplate.SetScope(value : TFhirString);
begin
  FScope.free;
  FScope := value;
end;

function TFhirImplementationGuideDefinitionTemplate.GetScopeST : String;
begin
  if FScope = nil then
    result := ''
  else
    result := FScope.value;
end;

procedure TFhirImplementationGuideDefinitionTemplate.SetScopeST(value : String);
begin
  if value <> '' then
  begin
    if FScope = nil then
      FScope := TFhirString.create;
    FScope.value := value
  end
  else if FScope <> nil then
    FScope.value := '';
end;

{ TFhirImplementationGuideDefinitionTemplateListEnumerator }

constructor TFhirImplementationGuideDefinitionTemplateListEnumerator.Create(list : TFhirImplementationGuideDefinitionTemplateList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImplementationGuideDefinitionTemplateListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImplementationGuideDefinitionTemplateListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImplementationGuideDefinitionTemplateListEnumerator.GetCurrent : TFhirImplementationGuideDefinitionTemplate;
begin
  Result := FList[FIndex];
end;

function TFhirImplementationGuideDefinitionTemplateListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirImplementationGuideDefinitionTemplateList }

function TFhirImplementationGuideDefinitionTemplateList.AddItem(value: TFhirImplementationGuideDefinitionTemplate): TFhirImplementationGuideDefinitionTemplate;
begin
  assert(value.ClassName = 'TFhirImplementationGuideDefinitionTemplate', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImplementationGuideDefinitionTemplate');
  add(value);
  result := value;
end;

function TFhirImplementationGuideDefinitionTemplateList.Append: TFhirImplementationGuideDefinitionTemplate;
begin
  result := TFhirImplementationGuideDefinitionTemplate.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImplementationGuideDefinitionTemplateList.ClearItems;
begin
  Clear;
end;

function TFhirImplementationGuideDefinitionTemplateList.GetEnumerator : TFhirImplementationGuideDefinitionTemplateListEnumerator;
begin
  result := TFhirImplementationGuideDefinitionTemplateListEnumerator.Create(self.link);
end;

function TFhirImplementationGuideDefinitionTemplateList.Clone: TFhirImplementationGuideDefinitionTemplateList;
begin
  result := TFhirImplementationGuideDefinitionTemplateList(inherited Clone);
end;

function TFhirImplementationGuideDefinitionTemplateList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImplementationGuideDefinitionTemplateList.GetItemN(index: Integer): TFhirImplementationGuideDefinitionTemplate;
begin
  result := TFhirImplementationGuideDefinitionTemplate(ObjectByIndex[index]);
end;

function TFhirImplementationGuideDefinitionTemplateList.ItemClass: TFslObjectClass;
begin
  result := TFhirImplementationGuideDefinitionTemplate;
end;
function TFhirImplementationGuideDefinitionTemplateList.IndexOf(value: TFhirImplementationGuideDefinitionTemplate): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImplementationGuideDefinitionTemplateList.Insert(index: Integer): TFhirImplementationGuideDefinitionTemplate;
begin
  result := TFhirImplementationGuideDefinitionTemplate.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImplementationGuideDefinitionTemplateList.InsertItem(index: Integer; value: TFhirImplementationGuideDefinitionTemplate);
begin
  assert(value is TFhirImplementationGuideDefinitionTemplate);
  Inherited Insert(index, value);
end;

function TFhirImplementationGuideDefinitionTemplateList.Item(index: Integer): TFhirImplementationGuideDefinitionTemplate;
begin
  result := TFhirImplementationGuideDefinitionTemplate(ObjectByIndex[index]);
end;

function TFhirImplementationGuideDefinitionTemplateList.Link: TFhirImplementationGuideDefinitionTemplateList;
begin
  result := TFhirImplementationGuideDefinitionTemplateList(inherited Link);
end;

procedure TFhirImplementationGuideDefinitionTemplateList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImplementationGuideDefinitionTemplateList.SetItemByIndex(index: Integer; value: TFhirImplementationGuideDefinitionTemplate);
begin
  assert(value is TFhirImplementationGuideDefinitionTemplate);
  FhirImplementationGuideDefinitionTemplates[index] := value;
end;

procedure TFhirImplementationGuideDefinitionTemplateList.SetItemN(index: Integer; value: TFhirImplementationGuideDefinitionTemplate);
begin
  assert(value is TFhirImplementationGuideDefinitionTemplate);
  ObjectByIndex[index] := value;
end;

{ TFhirImplementationGuideManifest }

constructor TFhirImplementationGuideManifest.Create;
begin
  inherited;
end;

destructor TFhirImplementationGuideManifest.Destroy;
begin
  FRendering.free;
  FResourceList.Free;
  FPageList.Free;
  FImageList.Free;
  FOtherList.Free;
  inherited;
end;

procedure TFhirImplementationGuideManifest.Assign(oSource : TFslObject);
begin
  inherited;
  renderingElement := TFhirImplementationGuideManifest(oSource).renderingElement.Clone;
  if (TFhirImplementationGuideManifest(oSource).FResourceList = nil) then
  begin
    FResourceList.free;
    FResourceList := nil;
  end
  else
  begin
    if FResourceList = nil then
      FResourceList := TFhirImplementationGuideManifestResourceList.Create;
    FResourceList.Assign(TFhirImplementationGuideManifest(oSource).FResourceList);
  end;
  if (TFhirImplementationGuideManifest(oSource).FPageList = nil) then
  begin
    FPageList.free;
    FPageList := nil;
  end
  else
  begin
    if FPageList = nil then
      FPageList := TFhirImplementationGuideManifestPageList.Create;
    FPageList.Assign(TFhirImplementationGuideManifest(oSource).FPageList);
  end;
  if (TFhirImplementationGuideManifest(oSource).FImageList = nil) then
  begin
    FImageList.free;
    FImageList := nil;
  end
  else
  begin
    if FImageList = nil then
      FImageList := TFhirStringList.Create;
    FImageList.Assign(TFhirImplementationGuideManifest(oSource).FImageList);
  end;
  if (TFhirImplementationGuideManifest(oSource).FOtherList = nil) then
  begin
    FOtherList.free;
    FOtherList := nil;
  end
  else
  begin
    if FOtherList = nil then
      FOtherList := TFhirStringList.Create;
    FOtherList.Assign(TFhirImplementationGuideManifest(oSource).FOtherList);
  end;
end;

procedure TFhirImplementationGuideManifest.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'rendering') Then
     list.add(self.link, 'rendering', FRendering.Link);
  if (child_name = 'resource') Then
    list.addAll(self, 'resource', FResourceList);
  if (child_name = 'page') Then
    list.addAll(self, 'page', FPageList);
  if (child_name = 'image') Then
    list.addAll(self, 'image', FImageList);
  if (child_name = 'other') Then
    list.addAll(self, 'other', FOtherList);
end;

procedure TFhirImplementationGuideManifest.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'rendering', 'url', false, TFhirUrl, FRendering.Link));
  oList.add(TFHIRProperty.create(self, 'resource', 'BackboneElement', true, TFhirImplementationGuideManifestResource, FResourceList.Link));
  oList.add(TFHIRProperty.create(self, 'page', 'BackboneElement', true, TFhirImplementationGuideManifestPage, FPageList.Link));
  oList.add(TFHIRProperty.create(self, 'image', 'string', true, TFhirString, FImageList.Link));
  oList.add(TFHIRProperty.create(self, 'other', 'string', true, TFhirString, FOtherList.Link));
end;

function TFhirImplementationGuideManifest.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'rendering') then
  begin
    RenderingElement := asUrl(propValue);
    result := propValue;
  end
  else if (propName = 'resource') then
  begin
    ResourceList.add(propValue as TFhirImplementationGuideManifestResource);
    result := propValue;
  end
  else if (propName = 'page') then
  begin
    PageList.add(propValue as TFhirImplementationGuideManifestPage);
    result := propValue;
  end
  else if (propName = 'image') then
  begin
    ImageList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'other') then
  begin
    OtherList.add(asString(propValue)){2};     result := propValue;

  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirImplementationGuideManifest.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'resource') then ResourceList.insertItem(index, propValue as TFhirImplementationGuideManifestResource)
  else if (propName = 'page') then PageList.insertItem(index, propValue as TFhirImplementationGuideManifestPage)
  else if (propName = 'image') then ImageList.insertItem(index, asString(propValue))
  else if (propName = 'other') then OtherList.insertItem(index, asString(propValue))
  else inherited;
end;

function TFhirImplementationGuideManifest.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'rendering') then result := TFhirUrl.create()
  else if (propName = 'resource') then result := ResourceList.new()
  else if (propName = 'page') then result := PageList.new()
  else if (propName = 'image') then result := ImageList.new()
  else if (propName = 'other') then result := OtherList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirImplementationGuideManifest.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'rendering') then result := 'url'
  else if (propName = 'resource') then result := 'BackboneElement'
  else if (propName = 'page') then result := 'BackboneElement'
  else if (propName = 'image') then result := 'string'
  else if (propName = 'other') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImplementationGuideManifest.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'rendering') then RenderingElement := nil
  else if (propName = 'resource') then deletePropertyValue('resource', ResourceList, value)
  else if (propName = 'page') then deletePropertyValue('page', PageList, value)
  else if (propName = 'image') then deletePropertyValue('image', ImageList, value)
  else if (propName = 'other') then deletePropertyValue('other', OtherList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImplementationGuideManifest.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'rendering') then RenderingElement := asUrl(new)
  else if (propName = 'resource') then replacePropertyValue('resource', ResourceList, existing, new)
  else if (propName = 'page') then replacePropertyValue('page', PageList, existing, new)
  else if (propName = 'image') then replacePropertyValue('image', ImageList, existing, new)
  else if (propName = 'other') then replacePropertyValue('other', OtherList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImplementationGuideManifest.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'resource') then ResourceList.move(source, destination)
  else if (propName = 'page') then PageList.move(source, destination)
  else if (propName = 'image') then ImageList.move(source, destination)
  else if (propName = 'other') then OtherList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirImplementationGuideManifest.fhirType : string;
begin
  result := 'ImplementationGuide.manifest';
end;

function TFhirImplementationGuideManifest.Link : TFhirImplementationGuideManifest;
begin
  result := TFhirImplementationGuideManifest(inherited Link);
end;

function TFhirImplementationGuideManifest.Clone : TFhirImplementationGuideManifest;
begin
  result := TFhirImplementationGuideManifest(inherited Clone);
end;

function TFhirImplementationGuideManifest.equals(other : TObject) : boolean; 
var
  o : TFhirImplementationGuideManifest;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImplementationGuideManifest)) then
    result := false
  else
  begin
    o := TFhirImplementationGuideManifest(other);
    result := compareDeep(renderingElement, o.renderingElement, true) and compareDeep(resourceList, o.resourceList, true) and 
      compareDeep(pageList, o.pageList, true) and compareDeep(imageList, o.imageList, true) and 
      compareDeep(otherList, o.otherList, true);
  end;
end;

function TFhirImplementationGuideManifest.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FRendering) and isEmptyProp(FresourceList) and isEmptyProp(FpageList) and isEmptyProp(FimageList) and isEmptyProp(FotherList);
end;

procedure TFhirImplementationGuideManifest.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('rendering');
  fields.add('resource');
  fields.add('page');
  fields.add('image');
  fields.add('other');
end;

function TFhirImplementationGuideManifest.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FResourceList.sizeInBytes(magic));
  inc(result, FPageList.sizeInBytes(magic));
  inc(result, FImageList.sizeInBytes(magic));
  inc(result, FOtherList.sizeInBytes(magic));
end;

procedure TFhirImplementationGuideManifest.SetRendering(value : TFhirUrl);
begin
  FRendering.free;
  FRendering := value;
end;

function TFhirImplementationGuideManifest.GetRenderingST : String;
begin
  if FRendering = nil then
    result := ''
  else
    result := FRendering.value;
end;

procedure TFhirImplementationGuideManifest.SetRenderingST(value : String);
begin
  if value <> '' then
  begin
    if FRendering = nil then
      FRendering := TFhirUrl.create;
    FRendering.value := value
  end
  else if FRendering <> nil then
    FRendering.value := '';
end;

function TFhirImplementationGuideManifest.GetResourceList : TFhirImplementationGuideManifestResourceList;
begin
  if FResourceList = nil then
    FResourceList := TFhirImplementationGuideManifestResourceList.Create;
  result := FResourceList;
end;

function TFhirImplementationGuideManifest.GetHasResourceList : boolean;
begin
  result := (FResourceList <> nil) and (FResourceList.count > 0);
end;

function TFhirImplementationGuideManifest.GetPageList : TFhirImplementationGuideManifestPageList;
begin
  if FPageList = nil then
    FPageList := TFhirImplementationGuideManifestPageList.Create;
  result := FPageList;
end;

function TFhirImplementationGuideManifest.GetHasPageList : boolean;
begin
  result := (FPageList <> nil) and (FPageList.count > 0);
end;

function TFhirImplementationGuideManifest.GetImageList : TFhirStringList;
begin
  if FImageList = nil then
    FImageList := TFhirStringList.Create;
  result := FImageList;
end;

function TFhirImplementationGuideManifest.GetHasImageList : boolean;
begin
  result := (FImageList <> nil) and (FImageList.count > 0);
end;

function TFhirImplementationGuideManifest.GetOtherList : TFhirStringList;
begin
  if FOtherList = nil then
    FOtherList := TFhirStringList.Create;
  result := FOtherList;
end;

function TFhirImplementationGuideManifest.GetHasOtherList : boolean;
begin
  result := (FOtherList <> nil) and (FOtherList.count > 0);
end;

{ TFhirImplementationGuideManifestListEnumerator }

constructor TFhirImplementationGuideManifestListEnumerator.Create(list : TFhirImplementationGuideManifestList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImplementationGuideManifestListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImplementationGuideManifestListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImplementationGuideManifestListEnumerator.GetCurrent : TFhirImplementationGuideManifest;
begin
  Result := FList[FIndex];
end;

function TFhirImplementationGuideManifestListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirImplementationGuideManifestList }

function TFhirImplementationGuideManifestList.AddItem(value: TFhirImplementationGuideManifest): TFhirImplementationGuideManifest;
begin
  assert(value.ClassName = 'TFhirImplementationGuideManifest', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImplementationGuideManifest');
  add(value);
  result := value;
end;

function TFhirImplementationGuideManifestList.Append: TFhirImplementationGuideManifest;
begin
  result := TFhirImplementationGuideManifest.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImplementationGuideManifestList.ClearItems;
begin
  Clear;
end;

function TFhirImplementationGuideManifestList.GetEnumerator : TFhirImplementationGuideManifestListEnumerator;
begin
  result := TFhirImplementationGuideManifestListEnumerator.Create(self.link);
end;

function TFhirImplementationGuideManifestList.Clone: TFhirImplementationGuideManifestList;
begin
  result := TFhirImplementationGuideManifestList(inherited Clone);
end;

function TFhirImplementationGuideManifestList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImplementationGuideManifestList.GetItemN(index: Integer): TFhirImplementationGuideManifest;
begin
  result := TFhirImplementationGuideManifest(ObjectByIndex[index]);
end;

function TFhirImplementationGuideManifestList.ItemClass: TFslObjectClass;
begin
  result := TFhirImplementationGuideManifest;
end;
function TFhirImplementationGuideManifestList.IndexOf(value: TFhirImplementationGuideManifest): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImplementationGuideManifestList.Insert(index: Integer): TFhirImplementationGuideManifest;
begin
  result := TFhirImplementationGuideManifest.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImplementationGuideManifestList.InsertItem(index: Integer; value: TFhirImplementationGuideManifest);
begin
  assert(value is TFhirImplementationGuideManifest);
  Inherited Insert(index, value);
end;

function TFhirImplementationGuideManifestList.Item(index: Integer): TFhirImplementationGuideManifest;
begin
  result := TFhirImplementationGuideManifest(ObjectByIndex[index]);
end;

function TFhirImplementationGuideManifestList.Link: TFhirImplementationGuideManifestList;
begin
  result := TFhirImplementationGuideManifestList(inherited Link);
end;

procedure TFhirImplementationGuideManifestList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImplementationGuideManifestList.SetItemByIndex(index: Integer; value: TFhirImplementationGuideManifest);
begin
  assert(value is TFhirImplementationGuideManifest);
  FhirImplementationGuideManifests[index] := value;
end;

procedure TFhirImplementationGuideManifestList.SetItemN(index: Integer; value: TFhirImplementationGuideManifest);
begin
  assert(value is TFhirImplementationGuideManifest);
  ObjectByIndex[index] := value;
end;

{ TFhirImplementationGuideManifestResource }

constructor TFhirImplementationGuideManifestResource.Create;
begin
  inherited;
end;

destructor TFhirImplementationGuideManifestResource.Destroy;
begin
  FReference.free;
  FExample.free;
  FRelativePath.free;
  inherited;
end;

procedure TFhirImplementationGuideManifestResource.Assign(oSource : TFslObject);
begin
  inherited;
  reference := TFhirImplementationGuideManifestResource(oSource).reference.Clone;
  example := TFhirImplementationGuideManifestResource(oSource).example.Clone;
  relativePathElement := TFhirImplementationGuideManifestResource(oSource).relativePathElement.Clone;
end;

procedure TFhirImplementationGuideManifestResource.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'reference') Then
     list.add(self.link, 'reference', FReference.Link);
  if (child_name = 'example[x]') or (child_name = 'example') Then
     list.add(self.link, 'example[x]', FExample.Link);
  if (child_name = 'relativePath') Then
     list.add(self.link, 'relativePath', FRelativePath.Link);
end;

procedure TFhirImplementationGuideManifestResource.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'reference', 'Reference', false, TFhirReference, FReference.Link));
  oList.add(TFHIRProperty.create(self, 'example[x]', 'boolean|canonical', false, TFhirDataType, FExample.Link));
  oList.add(TFHIRProperty.create(self, 'relativePath', 'url', false, TFhirUrl, FRelativePath.Link));
end;

function TFhirImplementationGuideManifestResource.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'reference') then
  begin
    Reference := propValue as TFhirReference;
    result := propValue;
  end
  else if (isMatchingName(propName, 'example', ['Boolean', 'Canonical'])) then
  begin
    Example := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'relativePath') then
  begin
    RelativePathElement := asUrl(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirImplementationGuideManifestResource.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirImplementationGuideManifestResource.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'reference') then result := TFhirReference.create()
  else if (isMatchingName(propName, 'example', ['Boolean', 'Canonical'])) then raise EFHIRException.create('Cannot make property Example')
  else if (propName = 'relativePath') then result := TFhirUrl.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirImplementationGuideManifestResource.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'reference') then result := 'Reference'
  else if (propName = 'example[x]') then result := 'boolean|canonical'
  else if (propName = 'relativePath') then result := 'url'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImplementationGuideManifestResource.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'reference') then ReferenceElement := nil
  else if (isMatchingName(propName, 'example', ['Boolean', 'Canonical'])) then ExampleElement := nil
  else if (propName = 'relativePath') then RelativePathElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImplementationGuideManifestResource.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'reference') then ReferenceElement := new as TFhirReference
  else if (isMatchingName(propName, 'example', ['Boolean', 'Canonical'])) then ExampleElement := new as TFhirDataType
  else if (propName = 'relativePath') then RelativePathElement := asUrl(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImplementationGuideManifestResource.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirImplementationGuideManifestResource.fhirType : string;
begin
  result := 'ImplementationGuide.manifest.resource';
end;

function TFhirImplementationGuideManifestResource.Link : TFhirImplementationGuideManifestResource;
begin
  result := TFhirImplementationGuideManifestResource(inherited Link);
end;

function TFhirImplementationGuideManifestResource.Clone : TFhirImplementationGuideManifestResource;
begin
  result := TFhirImplementationGuideManifestResource(inherited Clone);
end;

function TFhirImplementationGuideManifestResource.equals(other : TObject) : boolean; 
var
  o : TFhirImplementationGuideManifestResource;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImplementationGuideManifestResource)) then
    result := false
  else
  begin
    o := TFhirImplementationGuideManifestResource(other);
    result := compareDeep(referenceElement, o.referenceElement, true) and compareDeep(exampleElement, o.exampleElement, true) and 
      compareDeep(relativePathElement, o.relativePathElement, true);
  end;
end;

function TFhirImplementationGuideManifestResource.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FReference) and isEmptyProp(FExample) and isEmptyProp(FRelativePath);
end;

procedure TFhirImplementationGuideManifestResource.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('reference');
  fields.add('example[x]');
  fields.add('relativePath');
end;

function TFhirImplementationGuideManifestResource.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirImplementationGuideManifestResource.SetReference(value : TFhirReference);
begin
  FReference.free;
  FReference := value;
end;

procedure TFhirImplementationGuideManifestResource.SetExample(value : TFhirDataType);
begin
  FExample.free;
  FExample := value;
end;

procedure TFhirImplementationGuideManifestResource.SetRelativePath(value : TFhirUrl);
begin
  FRelativePath.free;
  FRelativePath := value;
end;

function TFhirImplementationGuideManifestResource.GetRelativePathST : String;
begin
  if FRelativePath = nil then
    result := ''
  else
    result := FRelativePath.value;
end;

procedure TFhirImplementationGuideManifestResource.SetRelativePathST(value : String);
begin
  if value <> '' then
  begin
    if FRelativePath = nil then
      FRelativePath := TFhirUrl.create;
    FRelativePath.value := value
  end
  else if FRelativePath <> nil then
    FRelativePath.value := '';
end;

{ TFhirImplementationGuideManifestResourceListEnumerator }

constructor TFhirImplementationGuideManifestResourceListEnumerator.Create(list : TFhirImplementationGuideManifestResourceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImplementationGuideManifestResourceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImplementationGuideManifestResourceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImplementationGuideManifestResourceListEnumerator.GetCurrent : TFhirImplementationGuideManifestResource;
begin
  Result := FList[FIndex];
end;

function TFhirImplementationGuideManifestResourceListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirImplementationGuideManifestResourceList }

function TFhirImplementationGuideManifestResourceList.AddItem(value: TFhirImplementationGuideManifestResource): TFhirImplementationGuideManifestResource;
begin
  assert(value.ClassName = 'TFhirImplementationGuideManifestResource', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImplementationGuideManifestResource');
  add(value);
  result := value;
end;

function TFhirImplementationGuideManifestResourceList.Append: TFhirImplementationGuideManifestResource;
begin
  result := TFhirImplementationGuideManifestResource.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImplementationGuideManifestResourceList.ClearItems;
begin
  Clear;
end;

function TFhirImplementationGuideManifestResourceList.GetEnumerator : TFhirImplementationGuideManifestResourceListEnumerator;
begin
  result := TFhirImplementationGuideManifestResourceListEnumerator.Create(self.link);
end;

function TFhirImplementationGuideManifestResourceList.Clone: TFhirImplementationGuideManifestResourceList;
begin
  result := TFhirImplementationGuideManifestResourceList(inherited Clone);
end;

function TFhirImplementationGuideManifestResourceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImplementationGuideManifestResourceList.GetItemN(index: Integer): TFhirImplementationGuideManifestResource;
begin
  result := TFhirImplementationGuideManifestResource(ObjectByIndex[index]);
end;

function TFhirImplementationGuideManifestResourceList.ItemClass: TFslObjectClass;
begin
  result := TFhirImplementationGuideManifestResource;
end;
function TFhirImplementationGuideManifestResourceList.IndexOf(value: TFhirImplementationGuideManifestResource): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImplementationGuideManifestResourceList.Insert(index: Integer): TFhirImplementationGuideManifestResource;
begin
  result := TFhirImplementationGuideManifestResource.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImplementationGuideManifestResourceList.InsertItem(index: Integer; value: TFhirImplementationGuideManifestResource);
begin
  assert(value is TFhirImplementationGuideManifestResource);
  Inherited Insert(index, value);
end;

function TFhirImplementationGuideManifestResourceList.Item(index: Integer): TFhirImplementationGuideManifestResource;
begin
  result := TFhirImplementationGuideManifestResource(ObjectByIndex[index]);
end;

function TFhirImplementationGuideManifestResourceList.Link: TFhirImplementationGuideManifestResourceList;
begin
  result := TFhirImplementationGuideManifestResourceList(inherited Link);
end;

procedure TFhirImplementationGuideManifestResourceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImplementationGuideManifestResourceList.SetItemByIndex(index: Integer; value: TFhirImplementationGuideManifestResource);
begin
  assert(value is TFhirImplementationGuideManifestResource);
  FhirImplementationGuideManifestResources[index] := value;
end;

procedure TFhirImplementationGuideManifestResourceList.SetItemN(index: Integer; value: TFhirImplementationGuideManifestResource);
begin
  assert(value is TFhirImplementationGuideManifestResource);
  ObjectByIndex[index] := value;
end;

{ TFhirImplementationGuideManifestPage }

constructor TFhirImplementationGuideManifestPage.Create;
begin
  inherited;
end;

destructor TFhirImplementationGuideManifestPage.Destroy;
begin
  FName.free;
  FTitle.free;
  FAnchorList.Free;
  inherited;
end;

procedure TFhirImplementationGuideManifestPage.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirImplementationGuideManifestPage(oSource).nameElement.Clone;
  titleElement := TFhirImplementationGuideManifestPage(oSource).titleElement.Clone;
  if (TFhirImplementationGuideManifestPage(oSource).FAnchorList = nil) then
  begin
    FAnchorList.free;
    FAnchorList := nil;
  end
  else
  begin
    if FAnchorList = nil then
      FAnchorList := TFhirStringList.Create;
    FAnchorList.Assign(TFhirImplementationGuideManifestPage(oSource).FAnchorList);
  end;
end;

procedure TFhirImplementationGuideManifestPage.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
  if (child_name = 'anchor') Then
    list.addAll(self, 'anchor', FAnchorList);
end;

procedure TFhirImplementationGuideManifestPage.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link));
  oList.add(TFHIRProperty.create(self, 'anchor', 'string', true, TFhirString, FAnchorList.Link));
end;

function TFhirImplementationGuideManifestPage.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'title') then
  begin
    TitleElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'anchor') then
  begin
    AnchorList.add(asString(propValue)){2};     result := propValue;

  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirImplementationGuideManifestPage.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'anchor') then AnchorList.insertItem(index, asString(propValue))
  else inherited;
end;

function TFhirImplementationGuideManifestPage.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'title') then result := TFhirString.create()
  else if (propName = 'anchor') then result := AnchorList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirImplementationGuideManifestPage.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'title') then result := 'string'
  else if (propName = 'anchor') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImplementationGuideManifestPage.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'title') then TitleElement := nil
  else if (propName = 'anchor') then deletePropertyValue('anchor', AnchorList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImplementationGuideManifestPage.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'title') then TitleElement := asString(new)
  else if (propName = 'anchor') then replacePropertyValue('anchor', AnchorList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImplementationGuideManifestPage.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'anchor') then AnchorList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirImplementationGuideManifestPage.fhirType : string;
begin
  result := 'ImplementationGuide.manifest.page';
end;

function TFhirImplementationGuideManifestPage.Link : TFhirImplementationGuideManifestPage;
begin
  result := TFhirImplementationGuideManifestPage(inherited Link);
end;

function TFhirImplementationGuideManifestPage.Clone : TFhirImplementationGuideManifestPage;
begin
  result := TFhirImplementationGuideManifestPage(inherited Clone);
end;

function TFhirImplementationGuideManifestPage.equals(other : TObject) : boolean; 
var
  o : TFhirImplementationGuideManifestPage;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImplementationGuideManifestPage)) then
    result := false
  else
  begin
    o := TFhirImplementationGuideManifestPage(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(titleElement, o.titleElement, true) and 
      compareDeep(anchorList, o.anchorList, true);
  end;
end;

function TFhirImplementationGuideManifestPage.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FTitle) and isEmptyProp(FanchorList);
end;

procedure TFhirImplementationGuideManifestPage.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('name');
  fields.add('title');
  fields.add('anchor');
end;

function TFhirImplementationGuideManifestPage.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FAnchorList.sizeInBytes(magic));
end;

procedure TFhirImplementationGuideManifestPage.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirImplementationGuideManifestPage.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirImplementationGuideManifestPage.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirImplementationGuideManifestPage.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

function TFhirImplementationGuideManifestPage.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

procedure TFhirImplementationGuideManifestPage.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

function TFhirImplementationGuideManifestPage.GetAnchorList : TFhirStringList;
begin
  if FAnchorList = nil then
    FAnchorList := TFhirStringList.Create;
  result := FAnchorList;
end;

function TFhirImplementationGuideManifestPage.GetHasAnchorList : boolean;
begin
  result := (FAnchorList <> nil) and (FAnchorList.count > 0);
end;

{ TFhirImplementationGuideManifestPageListEnumerator }

constructor TFhirImplementationGuideManifestPageListEnumerator.Create(list : TFhirImplementationGuideManifestPageList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImplementationGuideManifestPageListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImplementationGuideManifestPageListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImplementationGuideManifestPageListEnumerator.GetCurrent : TFhirImplementationGuideManifestPage;
begin
  Result := FList[FIndex];
end;

function TFhirImplementationGuideManifestPageListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirImplementationGuideManifestPageList }

function TFhirImplementationGuideManifestPageList.AddItem(value: TFhirImplementationGuideManifestPage): TFhirImplementationGuideManifestPage;
begin
  assert(value.ClassName = 'TFhirImplementationGuideManifestPage', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImplementationGuideManifestPage');
  add(value);
  result := value;
end;

function TFhirImplementationGuideManifestPageList.Append: TFhirImplementationGuideManifestPage;
begin
  result := TFhirImplementationGuideManifestPage.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImplementationGuideManifestPageList.ClearItems;
begin
  Clear;
end;

function TFhirImplementationGuideManifestPageList.GetEnumerator : TFhirImplementationGuideManifestPageListEnumerator;
begin
  result := TFhirImplementationGuideManifestPageListEnumerator.Create(self.link);
end;

function TFhirImplementationGuideManifestPageList.Clone: TFhirImplementationGuideManifestPageList;
begin
  result := TFhirImplementationGuideManifestPageList(inherited Clone);
end;

function TFhirImplementationGuideManifestPageList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImplementationGuideManifestPageList.GetItemN(index: Integer): TFhirImplementationGuideManifestPage;
begin
  result := TFhirImplementationGuideManifestPage(ObjectByIndex[index]);
end;

function TFhirImplementationGuideManifestPageList.ItemClass: TFslObjectClass;
begin
  result := TFhirImplementationGuideManifestPage;
end;
function TFhirImplementationGuideManifestPageList.IndexOf(value: TFhirImplementationGuideManifestPage): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImplementationGuideManifestPageList.Insert(index: Integer): TFhirImplementationGuideManifestPage;
begin
  result := TFhirImplementationGuideManifestPage.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImplementationGuideManifestPageList.InsertItem(index: Integer; value: TFhirImplementationGuideManifestPage);
begin
  assert(value is TFhirImplementationGuideManifestPage);
  Inherited Insert(index, value);
end;

function TFhirImplementationGuideManifestPageList.Item(index: Integer): TFhirImplementationGuideManifestPage;
begin
  result := TFhirImplementationGuideManifestPage(ObjectByIndex[index]);
end;

function TFhirImplementationGuideManifestPageList.Link: TFhirImplementationGuideManifestPageList;
begin
  result := TFhirImplementationGuideManifestPageList(inherited Link);
end;

procedure TFhirImplementationGuideManifestPageList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImplementationGuideManifestPageList.SetItemByIndex(index: Integer; value: TFhirImplementationGuideManifestPage);
begin
  assert(value is TFhirImplementationGuideManifestPage);
  FhirImplementationGuideManifestPages[index] := value;
end;

procedure TFhirImplementationGuideManifestPageList.SetItemN(index: Integer; value: TFhirImplementationGuideManifestPage);
begin
  assert(value is TFhirImplementationGuideManifestPage);
  ObjectByIndex[index] := value;
end;

{ TFhirImplementationGuide }

constructor TFhirImplementationGuide.Create;
begin
  inherited;
end;

destructor TFhirImplementationGuide.Destroy;
begin
  FUrl.free;
  FVersion.free;
  FName.free;
  FTitle.free;
  FStatus.free;
  FExperimental.free;
  FDate.free;
  FPublisher.free;
  FContactList.Free;
  FDescription.free;
  FUseContextList.Free;
  FJurisdictionList.Free;
  FCopyright.free;
  FPackageId.free;
  FLicense.free;
  FFhirVersion.Free;
  FDependsOnList.Free;
  FGlobalList.Free;
  FDefinition.free;
  FManifest.free;
  inherited;
end;

procedure TFhirImplementationGuide.Assign(oSource : TFslObject);
begin
  inherited;
  urlElement := TFhirImplementationGuide(oSource).urlElement.Clone;
  versionElement := TFhirImplementationGuide(oSource).versionElement.Clone;
  nameElement := TFhirImplementationGuide(oSource).nameElement.Clone;
  titleElement := TFhirImplementationGuide(oSource).titleElement.Clone;
  statusElement := TFhirImplementationGuide(oSource).statusElement.Clone;
  experimentalElement := TFhirImplementationGuide(oSource).experimentalElement.Clone;
  dateElement := TFhirImplementationGuide(oSource).dateElement.Clone;
  publisherElement := TFhirImplementationGuide(oSource).publisherElement.Clone;
  if (TFhirImplementationGuide(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirContactDetailList.Create;
    FContactList.Assign(TFhirImplementationGuide(oSource).FContactList);
  end;
  descriptionElement := TFhirImplementationGuide(oSource).descriptionElement.Clone;
  if (TFhirImplementationGuide(oSource).FUseContextList = nil) then
  begin
    FUseContextList.free;
    FUseContextList := nil;
  end
  else
  begin
    if FUseContextList = nil then
      FUseContextList := TFhirUsageContextList.Create;
    FUseContextList.Assign(TFhirImplementationGuide(oSource).FUseContextList);
  end;
  if (TFhirImplementationGuide(oSource).FJurisdictionList = nil) then
  begin
    FJurisdictionList.free;
    FJurisdictionList := nil;
  end
  else
  begin
    if FJurisdictionList = nil then
      FJurisdictionList := TFhirCodeableConceptList.Create;
    FJurisdictionList.Assign(TFhirImplementationGuide(oSource).FJurisdictionList);
  end;
  copyrightElement := TFhirImplementationGuide(oSource).copyrightElement.Clone;
  packageIdElement := TFhirImplementationGuide(oSource).packageIdElement.Clone;
  licenseElement := TFhirImplementationGuide(oSource).licenseElement.Clone;
  if (TFhirImplementationGuide(oSource).FFhirVersion = nil) then
  begin
    FFhirVersion.free;
    FFhirVersion := nil;
  end
  else
  begin
    FFhirVersion := TFhirEnumList.Create(SYSTEMS_TFhirFHIRVersionEnum, CODES_TFhirFHIRVersionEnum);
    FFhirVersion.Assign(TFhirImplementationGuide(oSource).FFhirVersion);
  end;
  if (TFhirImplementationGuide(oSource).FDependsOnList = nil) then
  begin
    FDependsOnList.free;
    FDependsOnList := nil;
  end
  else
  begin
    if FDependsOnList = nil then
      FDependsOnList := TFhirImplementationGuideDependsOnList.Create;
    FDependsOnList.Assign(TFhirImplementationGuide(oSource).FDependsOnList);
  end;
  if (TFhirImplementationGuide(oSource).FGlobalList = nil) then
  begin
    FGlobalList.free;
    FGlobalList := nil;
  end
  else
  begin
    if FGlobalList = nil then
      FGlobalList := TFhirImplementationGuideGlobalList.Create;
    FGlobalList.Assign(TFhirImplementationGuide(oSource).FGlobalList);
  end;
  definition := TFhirImplementationGuide(oSource).definition.Clone;
  manifest := TFhirImplementationGuide(oSource).manifest.Clone;
end;

function TFhirImplementationGuide.GetResourceType : TFhirResourceType;
begin
  result := frtImplementationGuide;
end;

procedure TFhirImplementationGuide.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
  if (child_name = 'version') Then
     list.add(self.link, 'version', FVersion.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'experimental') Then
     list.add(self.link, 'experimental', FExperimental.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'publisher') Then
     list.add(self.link, 'publisher', FPublisher.Link);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'useContext') Then
    list.addAll(self, 'useContext', FUseContextList);
  if (child_name = 'jurisdiction') Then
    list.addAll(self, 'jurisdiction', FJurisdictionList);
  if (child_name = 'copyright') Then
     list.add(self.link, 'copyright', FCopyright.Link);
  if (child_name = 'packageId') Then
     list.add(self.link, 'packageId', FPackageId.Link);
  if (child_name = 'license') Then
     list.add(self.link, 'license', FLicense.Link);
  if (child_name = 'fhirVersion') Then
     list.addAll(self, 'fhirVersion', FFhirVersion);
  if (child_name = 'dependsOn') Then
    list.addAll(self, 'dependsOn', FDependsOnList);
  if (child_name = 'global') Then
    list.addAll(self, 'global', FGlobalList);
  if (child_name = 'definition') Then
     list.add(self.link, 'definition', FDefinition.Link);
  if (child_name = 'manifest') Then
     list.add(self.link, 'manifest', FManifest.Link);
end;

procedure TFhirImplementationGuide.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'url', 'uri', false, TFhirUri, FUrl.Link));
  oList.add(TFHIRProperty.create(self, 'version', 'string', false, TFhirString, FVersion.Link));
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'experimental', 'boolean', false, TFhirBoolean, FExperimental.Link));
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));
  oList.add(TFHIRProperty.create(self, 'publisher', 'string', false, TFhirString, FPublisher.Link));
  oList.add(TFHIRProperty.create(self, 'contact', 'ContactDetail', true, TFhirContactDetail, FContactList.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'markdown', false, TFhirMarkdown, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'useContext', 'UsageContext', true, TFhirUsageContext, FUseContextList.Link));
  oList.add(TFHIRProperty.create(self, 'jurisdiction', 'CodeableConcept', true, TFhirCodeableConcept, FJurisdictionList.Link));
  oList.add(TFHIRProperty.create(self, 'copyright', 'markdown', false, TFhirMarkdown, FCopyright.Link));
  oList.add(TFHIRProperty.create(self, 'packageId', 'id', false, TFhirId, FPackageId.Link));
  oList.add(TFHIRProperty.create(self, 'license', 'code', false, TFhirEnum, FLicense.Link));
  oList.add(TFHIRProperty.create(self, 'fhirVersion', 'code', true, TFhirEnum, FFhirVersion.Link));
  oList.add(TFHIRProperty.create(self, 'dependsOn', 'BackboneElement', true, TFhirImplementationGuideDependsOn, FDependsOnList.Link));
  oList.add(TFHIRProperty.create(self, 'global', 'BackboneElement', true, TFhirImplementationGuideGlobal, FGlobalList.Link));
  oList.add(TFHIRProperty.create(self, 'definition', 'BackboneElement', false, TFhirImplementationGuideDefinition, FDefinition.Link));
  oList.add(TFHIRProperty.create(self, 'manifest', 'BackboneElement', false, TFhirImplementationGuideManifest, FManifest.Link));
end;

function TFhirImplementationGuide.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'url') then
  begin
    UrlElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'title') then
  begin
    TitleElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'experimental') then
  begin
    ExperimentalElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'publisher') then
  begin
    PublisherElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirContactDetail);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'useContext') then
  begin
    UseContextList.add(propValue as TFhirUsageContext);
    result := propValue;
  end
  else if (propName = 'jurisdiction') then
  begin
    JurisdictionList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'copyright') then
  begin
    CopyrightElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'packageId') then
  begin
    PackageIdElement := asId(propValue);
    result := propValue;
  end
  else if (propName = 'license') then
  begin
    LicenseElement := asEnum(SYSTEMS_TFhirSPDXLicenseEnum, CODES_TFhirSPDXLicenseEnum, propValue);
    result := propValue;
  end
  else if (propName = 'fhirVersion') then
  begin
    FhirVersionList.add(asEnum(SYSTEMS_TFhirFHIRVersionEnum, CODES_TFhirFHIRVersionEnum, propValue));
    result := propValue;
  end
  else if (propName = 'dependsOn') then
  begin
    DependsOnList.add(propValue as TFhirImplementationGuideDependsOn);
    result := propValue;
  end
  else if (propName = 'global') then
  begin
    GlobalList.add(propValue as TFhirImplementationGuideGlobal);
    result := propValue;
  end
  else if (propName = 'definition') then
  begin
    Definition := propValue as TFhirImplementationGuideDefinition;
    result := propValue;
  end
  else if (propName = 'manifest') then
  begin
    Manifest := propValue as TFhirImplementationGuideManifest;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirImplementationGuide.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirContactDetail)
  else if (propName = 'useContext') then UseContextList.insertItem(index, propValue as TFhirUsageContext)
  else if (propName = 'jurisdiction') then JurisdictionList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'fhirVersion') then FFhirVersion.insertItem(index, asEnum(SYSTEMS_TFhirFHIRVersionEnum, CODES_TFhirFHIRVersionEnum, propValue))
  else if (propName = 'dependsOn') then DependsOnList.insertItem(index, propValue as TFhirImplementationGuideDependsOn)
  else if (propName = 'global') then GlobalList.insertItem(index, propValue as TFhirImplementationGuideGlobal)
  else inherited;
end;

function TFhirImplementationGuide.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'url') then result := TFhirUri.create()
  else if (propName = 'version') then result := TFhirString.create()
  else if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'title') then result := TFhirString.create()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[PublicationStatusNull], CODES_TFhirPublicationStatusEnum[PublicationStatusNull]) 
  else if (propName = 'experimental') then result := TFhirBoolean.create()
  else if (propName = 'date') then result := TFhirDateTime.create()
  else if (propName = 'publisher') then result := TFhirString.create()
  else if (propName = 'contact') then result := ContactList.new()
  else if (propName = 'description') then result := TFhirMarkdown.create()
  else if (propName = 'useContext') then result := UseContextList.new()
  else if (propName = 'jurisdiction') then result := JurisdictionList.new()
  else if (propName = 'copyright') then result := TFhirMarkdown.create()
  else if (propName = 'packageId') then result := TFhirId.create()
  else if (propName = 'license') then result := TFhirEnum.create(SYSTEMS_TFhirSPDXLicenseEnum[SPDXLicenseNull], CODES_TFhirSPDXLicenseEnum[SPDXLicenseNull]) 
  else if (propName = 'dependsOn') then result := DependsOnList.new()
  else if (propName = 'global') then result := GlobalList.new()
  else if (propName = 'definition') then result := TFhirImplementationGuideDefinition.create()
  else if (propName = 'manifest') then result := TFhirImplementationGuideManifest.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirImplementationGuide.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'url') then result := 'uri'
  else if (propName = 'version') then result := 'string'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'title') then result := 'string'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'experimental') then result := 'boolean'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'publisher') then result := 'string'
  else if (propName = 'contact') then result := 'ContactDetail'
  else if (propName = 'description') then result := 'markdown'
  else if (propName = 'useContext') then result := 'UsageContext'
  else if (propName = 'jurisdiction') then result := 'CodeableConcept'
  else if (propName = 'copyright') then result := 'markdown'
  else if (propName = 'packageId') then result := 'id'
  else if (propName = 'license') then result := 'code'
  else if (propName = 'fhirVersion') then result := 'code'
  else if (propName = 'dependsOn') then result := 'BackboneElement'
  else if (propName = 'global') then result := 'BackboneElement'
  else if (propName = 'definition') then result := 'BackboneElement'
  else if (propName = 'manifest') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImplementationGuide.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := nil
  else if (propName = 'version') then VersionElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'title') then TitleElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'experimental') then ExperimentalElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'publisher') then PublisherElement := nil
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value)
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'useContext') then deletePropertyValue('useContext', UseContextList, value)
  else if (propName = 'jurisdiction') then deletePropertyValue('jurisdiction', JurisdictionList, value)
  else if (propName = 'copyright') then CopyrightElement := nil
  else if (propName = 'packageId') then PackageIdElement := nil
  else if (propName = 'license') then LicenseElement := nil
  else if (propName = 'dependsOn') then deletePropertyValue('dependsOn', DependsOnList, value)
  else if (propName = 'global') then deletePropertyValue('global', GlobalList, value)
  else if (propName = 'definition') then DefinitionElement := nil
  else if (propName = 'manifest') then ManifestElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImplementationGuide.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := asUri(new)
  else if (propName = 'version') then VersionElement := asString(new)
  else if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'title') then TitleElement := asString(new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, new)
  else if (propName = 'experimental') then ExperimentalElement := asBoolean(new)
  else if (propName = 'date') then DateElement := asDateTime(new)
  else if (propName = 'publisher') then PublisherElement := asString(new)
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new)
  else if (propName = 'description') then DescriptionElement := asMarkdown(new)
  else if (propName = 'useContext') then replacePropertyValue('useContext', UseContextList, existing, new)
  else if (propName = 'jurisdiction') then replacePropertyValue('jurisdiction', JurisdictionList, existing, new)
  else if (propName = 'copyright') then CopyrightElement := asMarkdown(new)
  else if (propName = 'packageId') then PackageIdElement := asId(new)
  else if (propName = 'license') then LicenseElement := asEnum(SYSTEMS_TFhirSPDXLicenseEnum, CODES_TFhirSPDXLicenseEnum, new)
  else if (propName = 'dependsOn') then replacePropertyValue('dependsOn', DependsOnList, existing, new)
  else if (propName = 'global') then replacePropertyValue('global', GlobalList, existing, new)
  else if (propName = 'definition') then DefinitionElement := new as TFhirImplementationGuideDefinition
  else if (propName = 'manifest') then ManifestElement := new as TFhirImplementationGuideManifest
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImplementationGuide.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'contact') then ContactList.move(source, destination)
  else if (propName = 'useContext') then UseContextList.move(source, destination)
  else if (propName = 'jurisdiction') then JurisdictionList.move(source, destination)
  else if (propName = 'fhirVersion') then FFhirVersion.move(source, destination)
  else if (propName = 'dependsOn') then DependsOnList.move(source, destination)
  else if (propName = 'global') then GlobalList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirImplementationGuide.fhirType : string;
begin
  result := 'ImplementationGuide';
end;

function TFhirImplementationGuide.Link : TFhirImplementationGuide;
begin
  result := TFhirImplementationGuide(inherited Link);
end;

function TFhirImplementationGuide.Clone : TFhirImplementationGuide;
begin
  result := TFhirImplementationGuide(inherited Clone);
end;

function TFhirImplementationGuide.equals(other : TObject) : boolean; 
var
  o : TFhirImplementationGuide;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImplementationGuide)) then
    result := false
  else
  begin
    o := TFhirImplementationGuide(other);
    result := compareDeep(urlElement, o.urlElement, true) and compareDeep(versionElement, o.versionElement, true) and 
      compareDeep(nameElement, o.nameElement, true) and compareDeep(titleElement, o.titleElement, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(experimentalElement, o.experimentalElement, true) and 
      compareDeep(dateElement, o.dateElement, true) and compareDeep(publisherElement, o.publisherElement, true) and 
      compareDeep(contactList, o.contactList, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(useContextList, o.useContextList, true) and compareDeep(jurisdictionList, o.jurisdictionList, true) and 
      compareDeep(copyrightElement, o.copyrightElement, true) and compareDeep(packageIdElement, o.packageIdElement, true) and 
      compareDeep(licenseElement, o.licenseElement, true) and compareDeep(fhirVersionList, o.fhirVersionList, true) and 
      compareDeep(dependsOnList, o.dependsOnList, true) and compareDeep(globalList, o.globalList, true) and 
      compareDeep(definitionElement, o.definitionElement, true) and compareDeep(manifestElement, o.manifestElement, true);
  end;
end;

function TFhirImplementationGuide.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FUrl) and isEmptyProp(FVersion) and isEmptyProp(FName) and isEmptyProp(FTitle) and isEmptyProp(FStatus) and isEmptyProp(FExperimental) and isEmptyProp(FDate) and isEmptyProp(FPublisher) and isEmptyProp(FcontactList) and isEmptyProp(FDescription) and isEmptyProp(FuseContextList) and isEmptyProp(FjurisdictionList) and isEmptyProp(FCopyright) and isEmptyProp(FPackageId) and isEmptyProp(FLicense) and isEmptyProp(FFhirVersion) and isEmptyProp(FdependsOnList) and isEmptyProp(FglobalList) and isEmptyProp(FDefinition) and isEmptyProp(FManifest);
end;

procedure TFhirImplementationGuide.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('url');
  fields.add('version');
  fields.add('name');
  fields.add('title');
  fields.add('status');
  fields.add('experimental');
  fields.add('date');
  fields.add('publisher');
  fields.add('contact');
  fields.add('description');
  fields.add('useContext');
  fields.add('jurisdiction');
  fields.add('copyright');
  fields.add('packageId');
  fields.add('license');
  fields.add('fhirVersion');
  fields.add('dependsOn');
  fields.add('global');
  fields.add('definition');
  fields.add('manifest');
end;

function TFhirImplementationGuide.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FContactList.sizeInBytes(magic));
  inc(result, FUseContextList.sizeInBytes(magic));
  inc(result, FJurisdictionList.sizeInBytes(magic));
  inc(result, FFhirVersion.sizeInBytes(magic));
  inc(result, FDependsOnList.sizeInBytes(magic));
  inc(result, FGlobalList.sizeInBytes(magic));
end;

procedure TFhirImplementationGuide.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

function TFhirImplementationGuide.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

procedure TFhirImplementationGuide.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

procedure TFhirImplementationGuide.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

function TFhirImplementationGuide.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

procedure TFhirImplementationGuide.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

procedure TFhirImplementationGuide.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirImplementationGuide.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirImplementationGuide.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirImplementationGuide.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

function TFhirImplementationGuide.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

procedure TFhirImplementationGuide.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

procedure TFhirImplementationGuide.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirImplementationGuide.GetStatusST : TFhirPublicationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirPublicationStatusEnum(0)
  else
    result := TFhirPublicationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirPublicationStatusEnum, FStatus.value));
end;

procedure TFhirImplementationGuide.SetStatusST(value : TFhirPublicationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[value], CODES_TFhirPublicationStatusEnum[value]);
end;

procedure TFhirImplementationGuide.SetExperimental(value : TFhirBoolean);
begin
  FExperimental.free;
  FExperimental := value;
end;

function TFhirImplementationGuide.GetExperimentalST : Boolean;
begin
  if FExperimental = nil then
    result := false
  else
    result := FExperimental.value;
end;

procedure TFhirImplementationGuide.SetExperimentalST(value : Boolean);
begin
  if FExperimental = nil then
    FExperimental := TFhirBoolean.create;
  FExperimental.value := value
end;

procedure TFhirImplementationGuide.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

function TFhirImplementationGuide.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirImplementationGuide.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

procedure TFhirImplementationGuide.SetPublisher(value : TFhirString);
begin
  FPublisher.free;
  FPublisher := value;
end;

function TFhirImplementationGuide.GetPublisherST : String;
begin
  if FPublisher = nil then
    result := ''
  else
    result := FPublisher.value;
end;

procedure TFhirImplementationGuide.SetPublisherST(value : String);
begin
  if value <> '' then
  begin
    if FPublisher = nil then
      FPublisher := TFhirString.create;
    FPublisher.value := value
  end
  else if FPublisher <> nil then
    FPublisher.value := '';
end;

function TFhirImplementationGuide.GetContactList : TFhirContactDetailList;
begin
  if FContactList = nil then
    FContactList := TFhirContactDetailList.Create;
  result := FContactList;
end;

function TFhirImplementationGuide.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

procedure TFhirImplementationGuide.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirImplementationGuide.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirImplementationGuide.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirImplementationGuide.GetUseContextList : TFhirUsageContextList;
begin
  if FUseContextList = nil then
    FUseContextList := TFhirUsageContextList.Create;
  result := FUseContextList;
end;

function TFhirImplementationGuide.GetHasUseContextList : boolean;
begin
  result := (FUseContextList <> nil) and (FUseContextList.count > 0);
end;

function TFhirImplementationGuide.GetJurisdictionList : TFhirCodeableConceptList;
begin
  if FJurisdictionList = nil then
    FJurisdictionList := TFhirCodeableConceptList.Create;
  result := FJurisdictionList;
end;

function TFhirImplementationGuide.GetHasJurisdictionList : boolean;
begin
  result := (FJurisdictionList <> nil) and (FJurisdictionList.count > 0);
end;

procedure TFhirImplementationGuide.SetCopyright(value : TFhirMarkdown);
begin
  FCopyright.free;
  FCopyright := value;
end;

function TFhirImplementationGuide.GetCopyrightST : String;
begin
  if FCopyright = nil then
    result := ''
  else
    result := FCopyright.value;
end;

procedure TFhirImplementationGuide.SetCopyrightST(value : String);
begin
  if value <> '' then
  begin
    if FCopyright = nil then
      FCopyright := TFhirMarkdown.create;
    FCopyright.value := value
  end
  else if FCopyright <> nil then
    FCopyright.value := '';
end;

procedure TFhirImplementationGuide.SetPackageId(value : TFhirId);
begin
  FPackageId.free;
  FPackageId := value;
end;

function TFhirImplementationGuide.GetPackageIdST : String;
begin
  if FPackageId = nil then
    result := ''
  else
    result := FPackageId.value;
end;

procedure TFhirImplementationGuide.SetPackageIdST(value : String);
begin
  if value <> '' then
  begin
    if FPackageId = nil then
      FPackageId := TFhirId.create;
    FPackageId.value := value
  end
  else if FPackageId <> nil then
    FPackageId.value := '';
end;

procedure TFhirImplementationGuide.SetLicense(value : TFhirEnum);
begin
  FLicense.free;
  FLicense := value;
end;

function TFhirImplementationGuide.GetLicenseST : TFhirSPDXLicenseEnum;
begin
  if FLicense = nil then
    result := TFhirSPDXLicenseEnum(0)
  else
    result := TFhirSPDXLicenseEnum(StringArrayIndexOfSensitive(CODES_TFhirSPDXLicenseEnum, FLicense.value));
end;

procedure TFhirImplementationGuide.SetLicenseST(value : TFhirSPDXLicenseEnum);
begin
  if ord(value) = 0 then
    LicenseElement := nil
  else
    LicenseElement := TFhirEnum.create(SYSTEMS_TFhirSPDXLicenseEnum[value], CODES_TFhirSPDXLicenseEnum[value]);
end;

function TFhirImplementationGuide.GetFhirVersion : TFhirEnumList;
begin
  if FFhirVersion = nil then
    FFhirVersion := TFhirEnumList.Create(SYSTEMS_TFhirFHIRVersionEnum, CODES_TFhirFHIRVersionEnum);
  result := FFhirVersion;
end;

function TFhirImplementationGuide.GetHasFhirVersion : boolean;
begin
  result := (FFhirVersion <> nil) and (FFhirVersion.count > 0);
end;

function TFhirImplementationGuide.GetFhirVersionST : TFhirFHIRVersionEnumList;
  var i : integer;
begin
  result := [];
  if FfhirVersion <> nil then
    for i := 0 to FfhirVersion.count - 1 do
      result := result + [TFhirFHIRVersionEnum(StringArrayIndexOfSensitive(CODES_TFhirFHIRVersionEnum, FfhirVersion[i].value))];
end;

procedure TFhirImplementationGuide.SetFhirVersionST(value : TFhirFHIRVersionEnumList);
var a : TFhirFHIRVersionEnum;
begin
  if FfhirVersion = nil then
    FfhirVersion := TFhirEnumList.create(SYSTEMS_TFhirFHIRVersionEnum, CODES_TFhirFHIRVersionEnum);
  FfhirVersion.clear;
  for a := low(TFhirFHIRVersionEnum) to high(TFhirFHIRVersionEnum) do
    if a in value then
      begin
         if FfhirVersion = nil then
           FfhirVersion := TFhirEnumList.create(SYSTEMS_TFhirFHIRVersionEnum, CODES_TFhirFHIRVersionEnum);
         FfhirVersion.add(TFhirEnum.create(SYSTEMS_TFhirFHIRVersionEnum[a], CODES_TFhirFHIRVersionEnum[a]));
      end;
end;

function TFhirImplementationGuide.GetDependsOnList : TFhirImplementationGuideDependsOnList;
begin
  if FDependsOnList = nil then
    FDependsOnList := TFhirImplementationGuideDependsOnList.Create;
  result := FDependsOnList;
end;

function TFhirImplementationGuide.GetHasDependsOnList : boolean;
begin
  result := (FDependsOnList <> nil) and (FDependsOnList.count > 0);
end;

function TFhirImplementationGuide.GetGlobalList : TFhirImplementationGuideGlobalList;
begin
  if FGlobalList = nil then
    FGlobalList := TFhirImplementationGuideGlobalList.Create;
  result := FGlobalList;
end;

function TFhirImplementationGuide.GetHasGlobalList : boolean;
begin
  result := (FGlobalList <> nil) and (FGlobalList.count > 0);
end;

procedure TFhirImplementationGuide.SetDefinition(value : TFhirImplementationGuideDefinition);
begin
  FDefinition.free;
  FDefinition := value;
end;

procedure TFhirImplementationGuide.SetManifest(value : TFhirImplementationGuideManifest);
begin
  FManifest.free;
  FManifest := value;
end;

{ TFhirImplementationGuideListEnumerator }

constructor TFhirImplementationGuideListEnumerator.Create(list : TFhirImplementationGuideList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImplementationGuideListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImplementationGuideListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImplementationGuideListEnumerator.GetCurrent : TFhirImplementationGuide;
begin
  Result := FList[FIndex];
end;

function TFhirImplementationGuideListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirImplementationGuideList }

function TFhirImplementationGuideList.AddItem(value: TFhirImplementationGuide): TFhirImplementationGuide;
begin
  assert(value.ClassName = 'TFhirImplementationGuide', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImplementationGuide');
  add(value);
  result := value;
end;

function TFhirImplementationGuideList.Append: TFhirImplementationGuide;
begin
  result := TFhirImplementationGuide.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImplementationGuideList.ClearItems;
begin
  Clear;
end;

function TFhirImplementationGuideList.GetEnumerator : TFhirImplementationGuideListEnumerator;
begin
  result := TFhirImplementationGuideListEnumerator.Create(self.link);
end;

function TFhirImplementationGuideList.Clone: TFhirImplementationGuideList;
begin
  result := TFhirImplementationGuideList(inherited Clone);
end;

function TFhirImplementationGuideList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImplementationGuideList.GetItemN(index: Integer): TFhirImplementationGuide;
begin
  result := TFhirImplementationGuide(ObjectByIndex[index]);
end;

function TFhirImplementationGuideList.ItemClass: TFslObjectClass;
begin
  result := TFhirImplementationGuide;
end;
function TFhirImplementationGuideList.IndexOf(value: TFhirImplementationGuide): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImplementationGuideList.Insert(index: Integer): TFhirImplementationGuide;
begin
  result := TFhirImplementationGuide.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImplementationGuideList.InsertItem(index: Integer; value: TFhirImplementationGuide);
begin
  assert(value is TFhirImplementationGuide);
  Inherited Insert(index, value);
end;

function TFhirImplementationGuideList.Item(index: Integer): TFhirImplementationGuide;
begin
  result := TFhirImplementationGuide(ObjectByIndex[index]);
end;

function TFhirImplementationGuideList.Link: TFhirImplementationGuideList;
begin
  result := TFhirImplementationGuideList(inherited Link);
end;

procedure TFhirImplementationGuideList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImplementationGuideList.SetItemByIndex(index: Integer; value: TFhirImplementationGuide);
begin
  assert(value is TFhirImplementationGuide);
  FhirImplementationGuides[index] := value;
end;

procedure TFhirImplementationGuideList.SetItemN(index: Integer; value: TFhirImplementationGuide);
begin
  assert(value is TFhirImplementationGuide);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_IMPLEMENTATIONGUIDE}
{$IFDEF FHIR_LIBRARY}
{ TFhirLibrary }

constructor TFhirLibrary.Create;
begin
  inherited;
end;

destructor TFhirLibrary.Destroy;
begin
  FUrl.free;
  FIdentifierList.Free;
  FVersion.free;
  FName.free;
  FTitle.free;
  FSubtitle.free;
  FStatus.free;
  FExperimental.free;
  FType_.free;
  FSubject.free;
  FDate.free;
  FPublisher.free;
  FContactList.Free;
  FDescription.free;
  FUseContextList.Free;
  FJurisdictionList.Free;
  FPurpose.free;
  FUsage.free;
  FCopyright.free;
  FApprovalDate.free;
  FLastReviewDate.free;
  FEffectivePeriod.free;
  FTopicList.Free;
  FAuthorList.Free;
  FEditorList.Free;
  FReviewerList.Free;
  FEndorserList.Free;
  FRelatedArtifactList.Free;
  FParameterList.Free;
  FDataRequirementList.Free;
  FContentList.Free;
  inherited;
end;

procedure TFhirLibrary.Assign(oSource : TFslObject);
begin
  inherited;
  urlElement := TFhirLibrary(oSource).urlElement.Clone;
  if (TFhirLibrary(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirLibrary(oSource).FIdentifierList);
  end;
  versionElement := TFhirLibrary(oSource).versionElement.Clone;
  nameElement := TFhirLibrary(oSource).nameElement.Clone;
  titleElement := TFhirLibrary(oSource).titleElement.Clone;
  subtitleElement := TFhirLibrary(oSource).subtitleElement.Clone;
  statusElement := TFhirLibrary(oSource).statusElement.Clone;
  experimentalElement := TFhirLibrary(oSource).experimentalElement.Clone;
  type_ := TFhirLibrary(oSource).type_.Clone;
  subject := TFhirLibrary(oSource).subject.Clone;
  dateElement := TFhirLibrary(oSource).dateElement.Clone;
  publisherElement := TFhirLibrary(oSource).publisherElement.Clone;
  if (TFhirLibrary(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirContactDetailList.Create;
    FContactList.Assign(TFhirLibrary(oSource).FContactList);
  end;
  descriptionElement := TFhirLibrary(oSource).descriptionElement.Clone;
  if (TFhirLibrary(oSource).FUseContextList = nil) then
  begin
    FUseContextList.free;
    FUseContextList := nil;
  end
  else
  begin
    if FUseContextList = nil then
      FUseContextList := TFhirUsageContextList.Create;
    FUseContextList.Assign(TFhirLibrary(oSource).FUseContextList);
  end;
  if (TFhirLibrary(oSource).FJurisdictionList = nil) then
  begin
    FJurisdictionList.free;
    FJurisdictionList := nil;
  end
  else
  begin
    if FJurisdictionList = nil then
      FJurisdictionList := TFhirCodeableConceptList.Create;
    FJurisdictionList.Assign(TFhirLibrary(oSource).FJurisdictionList);
  end;
  purposeElement := TFhirLibrary(oSource).purposeElement.Clone;
  usageElement := TFhirLibrary(oSource).usageElement.Clone;
  copyrightElement := TFhirLibrary(oSource).copyrightElement.Clone;
  approvalDateElement := TFhirLibrary(oSource).approvalDateElement.Clone;
  lastReviewDateElement := TFhirLibrary(oSource).lastReviewDateElement.Clone;
  effectivePeriod := TFhirLibrary(oSource).effectivePeriod.Clone;
  if (TFhirLibrary(oSource).FTopicList = nil) then
  begin
    FTopicList.free;
    FTopicList := nil;
  end
  else
  begin
    if FTopicList = nil then
      FTopicList := TFhirCodeableConceptList.Create;
    FTopicList.Assign(TFhirLibrary(oSource).FTopicList);
  end;
  if (TFhirLibrary(oSource).FAuthorList = nil) then
  begin
    FAuthorList.free;
    FAuthorList := nil;
  end
  else
  begin
    if FAuthorList = nil then
      FAuthorList := TFhirContactDetailList.Create;
    FAuthorList.Assign(TFhirLibrary(oSource).FAuthorList);
  end;
  if (TFhirLibrary(oSource).FEditorList = nil) then
  begin
    FEditorList.free;
    FEditorList := nil;
  end
  else
  begin
    if FEditorList = nil then
      FEditorList := TFhirContactDetailList.Create;
    FEditorList.Assign(TFhirLibrary(oSource).FEditorList);
  end;
  if (TFhirLibrary(oSource).FReviewerList = nil) then
  begin
    FReviewerList.free;
    FReviewerList := nil;
  end
  else
  begin
    if FReviewerList = nil then
      FReviewerList := TFhirContactDetailList.Create;
    FReviewerList.Assign(TFhirLibrary(oSource).FReviewerList);
  end;
  if (TFhirLibrary(oSource).FEndorserList = nil) then
  begin
    FEndorserList.free;
    FEndorserList := nil;
  end
  else
  begin
    if FEndorserList = nil then
      FEndorserList := TFhirContactDetailList.Create;
    FEndorserList.Assign(TFhirLibrary(oSource).FEndorserList);
  end;
  if (TFhirLibrary(oSource).FRelatedArtifactList = nil) then
  begin
    FRelatedArtifactList.free;
    FRelatedArtifactList := nil;
  end
  else
  begin
    if FRelatedArtifactList = nil then
      FRelatedArtifactList := TFhirRelatedArtifactList.Create;
    FRelatedArtifactList.Assign(TFhirLibrary(oSource).FRelatedArtifactList);
  end;
  if (TFhirLibrary(oSource).FParameterList = nil) then
  begin
    FParameterList.free;
    FParameterList := nil;
  end
  else
  begin
    if FParameterList = nil then
      FParameterList := TFhirParameterDefinitionList.Create;
    FParameterList.Assign(TFhirLibrary(oSource).FParameterList);
  end;
  if (TFhirLibrary(oSource).FDataRequirementList = nil) then
  begin
    FDataRequirementList.free;
    FDataRequirementList := nil;
  end
  else
  begin
    if FDataRequirementList = nil then
      FDataRequirementList := TFhirDataRequirementList.Create;
    FDataRequirementList.Assign(TFhirLibrary(oSource).FDataRequirementList);
  end;
  if (TFhirLibrary(oSource).FContentList = nil) then
  begin
    FContentList.free;
    FContentList := nil;
  end
  else
  begin
    if FContentList = nil then
      FContentList := TFhirAttachmentList.Create;
    FContentList.Assign(TFhirLibrary(oSource).FContentList);
  end;
end;

function TFhirLibrary.GetResourceType : TFhirResourceType;
begin
  result := frtLibrary;
end;

procedure TFhirLibrary.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'version') Then
     list.add(self.link, 'version', FVersion.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
  if (child_name = 'subtitle') Then
     list.add(self.link, 'subtitle', FSubtitle.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'experimental') Then
     list.add(self.link, 'experimental', FExperimental.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'subject[x]') or (child_name = 'subject') Then
     list.add(self.link, 'subject[x]', FSubject.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'publisher') Then
     list.add(self.link, 'publisher', FPublisher.Link);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'useContext') Then
    list.addAll(self, 'useContext', FUseContextList);
  if (child_name = 'jurisdiction') Then
    list.addAll(self, 'jurisdiction', FJurisdictionList);
  if (child_name = 'purpose') Then
     list.add(self.link, 'purpose', FPurpose.Link);
  if (child_name = 'usage') Then
     list.add(self.link, 'usage', FUsage.Link);
  if (child_name = 'copyright') Then
     list.add(self.link, 'copyright', FCopyright.Link);
  if (child_name = 'approvalDate') Then
     list.add(self.link, 'approvalDate', FApprovalDate.Link);
  if (child_name = 'lastReviewDate') Then
     list.add(self.link, 'lastReviewDate', FLastReviewDate.Link);
  if (child_name = 'effectivePeriod') Then
     list.add(self.link, 'effectivePeriod', FEffectivePeriod.Link);
  if (child_name = 'topic') Then
    list.addAll(self, 'topic', FTopicList);
  if (child_name = 'author') Then
    list.addAll(self, 'author', FAuthorList);
  if (child_name = 'editor') Then
    list.addAll(self, 'editor', FEditorList);
  if (child_name = 'reviewer') Then
    list.addAll(self, 'reviewer', FReviewerList);
  if (child_name = 'endorser') Then
    list.addAll(self, 'endorser', FEndorserList);
  if (child_name = 'relatedArtifact') Then
    list.addAll(self, 'relatedArtifact', FRelatedArtifactList);
  if (child_name = 'parameter') Then
    list.addAll(self, 'parameter', FParameterList);
  if (child_name = 'dataRequirement') Then
    list.addAll(self, 'dataRequirement', FDataRequirementList);
  if (child_name = 'content') Then
    list.addAll(self, 'content', FContentList);
end;

procedure TFhirLibrary.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'url', 'uri', false, TFhirUri, FUrl.Link));
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'version', 'string', false, TFhirString, FVersion.Link));
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link));
  oList.add(TFHIRProperty.create(self, 'subtitle', 'string', false, TFhirString, FSubtitle.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'experimental', 'boolean', false, TFhirBoolean, FExperimental.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'subject[x]', 'CodeableConcept|Reference', false, TFhirDataType, FSubject.Link));
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));
  oList.add(TFHIRProperty.create(self, 'publisher', 'string', false, TFhirString, FPublisher.Link));
  oList.add(TFHIRProperty.create(self, 'contact', 'ContactDetail', true, TFhirContactDetail, FContactList.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'markdown', false, TFhirMarkdown, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'useContext', 'UsageContext', true, TFhirUsageContext, FUseContextList.Link));
  oList.add(TFHIRProperty.create(self, 'jurisdiction', 'CodeableConcept', true, TFhirCodeableConcept, FJurisdictionList.Link));
  oList.add(TFHIRProperty.create(self, 'purpose', 'markdown', false, TFhirMarkdown, FPurpose.Link));
  oList.add(TFHIRProperty.create(self, 'usage', 'string', false, TFhirString, FUsage.Link));
  oList.add(TFHIRProperty.create(self, 'copyright', 'markdown', false, TFhirMarkdown, FCopyright.Link));
  oList.add(TFHIRProperty.create(self, 'approvalDate', 'date', false, TFhirDate, FApprovalDate.Link));
  oList.add(TFHIRProperty.create(self, 'lastReviewDate', 'date', false, TFhirDate, FLastReviewDate.Link));
  oList.add(TFHIRProperty.create(self, 'effectivePeriod', 'Period', false, TFhirPeriod, FEffectivePeriod.Link));
  oList.add(TFHIRProperty.create(self, 'topic', 'CodeableConcept', true, TFhirCodeableConcept, FTopicList.Link));
  oList.add(TFHIRProperty.create(self, 'author', 'ContactDetail', true, TFhirContactDetail, FAuthorList.Link));
  oList.add(TFHIRProperty.create(self, 'editor', 'ContactDetail', true, TFhirContactDetail, FEditorList.Link));
  oList.add(TFHIRProperty.create(self, 'reviewer', 'ContactDetail', true, TFhirContactDetail, FReviewerList.Link));
  oList.add(TFHIRProperty.create(self, 'endorser', 'ContactDetail', true, TFhirContactDetail, FEndorserList.Link));
  oList.add(TFHIRProperty.create(self, 'relatedArtifact', 'RelatedArtifact', true, TFhirRelatedArtifact, FRelatedArtifactList.Link));
  oList.add(TFHIRProperty.create(self, 'parameter', 'ParameterDefinition', true, TFhirParameterDefinition, FParameterList.Link));
  oList.add(TFHIRProperty.create(self, 'dataRequirement', 'DataRequirement', true, TFhirDataRequirement, FDataRequirementList.Link));
  oList.add(TFHIRProperty.create(self, 'content', 'Attachment', true, TFhirAttachment, FContentList.Link));
end;

function TFhirLibrary.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'url') then
  begin
    UrlElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'title') then
  begin
    TitleElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'subtitle') then
  begin
    SubtitleElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'experimental') then
  begin
    ExperimentalElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (isMatchingName(propName, 'subject', ['CodeableConcept', 'Reference'])) then
  begin
    Subject := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'publisher') then
  begin
    PublisherElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirContactDetail);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'useContext') then
  begin
    UseContextList.add(propValue as TFhirUsageContext);
    result := propValue;
  end
  else if (propName = 'jurisdiction') then
  begin
    JurisdictionList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'purpose') then
  begin
    PurposeElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'usage') then
  begin
    UsageElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'copyright') then
  begin
    CopyrightElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'approvalDate') then
  begin
    ApprovalDateElement := asDate(propValue);
    result := propValue;
  end
  else if (propName = 'lastReviewDate') then
  begin
    LastReviewDateElement := asDate(propValue);
    result := propValue;
  end
  else if (propName = 'effectivePeriod') then
  begin
    EffectivePeriod := propValue as TFhirPeriod;
    result := propValue;
  end
  else if (propName = 'topic') then
  begin
    TopicList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    AuthorList.add(propValue as TFhirContactDetail);
    result := propValue;
  end
  else if (propName = 'editor') then
  begin
    EditorList.add(propValue as TFhirContactDetail);
    result := propValue;
  end
  else if (propName = 'reviewer') then
  begin
    ReviewerList.add(propValue as TFhirContactDetail);
    result := propValue;
  end
  else if (propName = 'endorser') then
  begin
    EndorserList.add(propValue as TFhirContactDetail);
    result := propValue;
  end
  else if (propName = 'relatedArtifact') then
  begin
    RelatedArtifactList.add(propValue as TFhirRelatedArtifact);
    result := propValue;
  end
  else if (propName = 'parameter') then
  begin
    ParameterList.add(propValue as TFhirParameterDefinition);
    result := propValue;
  end
  else if (propName = 'dataRequirement') then
  begin
    DataRequirementList.add(propValue as TFhirDataRequirement);
    result := propValue;
  end
  else if (propName = 'content') then
  begin
    ContentList.add(propValue as TFhirAttachment);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirLibrary.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirContactDetail)
  else if (propName = 'useContext') then UseContextList.insertItem(index, propValue as TFhirUsageContext)
  else if (propName = 'jurisdiction') then JurisdictionList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'topic') then TopicList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'author') then AuthorList.insertItem(index, propValue as TFhirContactDetail)
  else if (propName = 'editor') then EditorList.insertItem(index, propValue as TFhirContactDetail)
  else if (propName = 'reviewer') then ReviewerList.insertItem(index, propValue as TFhirContactDetail)
  else if (propName = 'endorser') then EndorserList.insertItem(index, propValue as TFhirContactDetail)
  else if (propName = 'relatedArtifact') then RelatedArtifactList.insertItem(index, propValue as TFhirRelatedArtifact)
  else if (propName = 'parameter') then ParameterList.insertItem(index, propValue as TFhirParameterDefinition)
  else if (propName = 'dataRequirement') then DataRequirementList.insertItem(index, propValue as TFhirDataRequirement)
  else if (propName = 'content') then ContentList.insertItem(index, propValue as TFhirAttachment)
  else inherited;
end;

function TFhirLibrary.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'url') then result := TFhirUri.create()
  else if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'version') then result := TFhirString.create()
  else if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'title') then result := TFhirString.create()
  else if (propName = 'subtitle') then result := TFhirString.create()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[PublicationStatusNull], CODES_TFhirPublicationStatusEnum[PublicationStatusNull]) 
  else if (propName = 'experimental') then result := TFhirBoolean.create()
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (isMatchingName(propName, 'subject', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Subject')
  else if (propName = 'date') then result := TFhirDateTime.create()
  else if (propName = 'publisher') then result := TFhirString.create()
  else if (propName = 'contact') then result := ContactList.new()
  else if (propName = 'description') then result := TFhirMarkdown.create()
  else if (propName = 'useContext') then result := UseContextList.new()
  else if (propName = 'jurisdiction') then result := JurisdictionList.new()
  else if (propName = 'purpose') then result := TFhirMarkdown.create()
  else if (propName = 'usage') then result := TFhirString.create()
  else if (propName = 'copyright') then result := TFhirMarkdown.create()
  else if (propName = 'approvalDate') then result := TFhirDate.create()
  else if (propName = 'lastReviewDate') then result := TFhirDate.create()
  else if (propName = 'effectivePeriod') then result := TFhirPeriod.create()
  else if (propName = 'topic') then result := TopicList.new()
  else if (propName = 'author') then result := AuthorList.new()
  else if (propName = 'editor') then result := EditorList.new()
  else if (propName = 'reviewer') then result := ReviewerList.new()
  else if (propName = 'endorser') then result := EndorserList.new()
  else if (propName = 'relatedArtifact') then result := RelatedArtifactList.new()
  else if (propName = 'parameter') then result := ParameterList.new()
  else if (propName = 'dataRequirement') then result := DataRequirementList.new()
  else if (propName = 'content') then result := ContentList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirLibrary.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'url') then result := 'uri'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'version') then result := 'string'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'title') then result := 'string'
  else if (propName = 'subtitle') then result := 'string'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'experimental') then result := 'boolean'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'subject[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'publisher') then result := 'string'
  else if (propName = 'contact') then result := 'ContactDetail'
  else if (propName = 'description') then result := 'markdown'
  else if (propName = 'useContext') then result := 'UsageContext'
  else if (propName = 'jurisdiction') then result := 'CodeableConcept'
  else if (propName = 'purpose') then result := 'markdown'
  else if (propName = 'usage') then result := 'string'
  else if (propName = 'copyright') then result := 'markdown'
  else if (propName = 'approvalDate') then result := 'date'
  else if (propName = 'lastReviewDate') then result := 'date'
  else if (propName = 'effectivePeriod') then result := 'Period'
  else if (propName = 'topic') then result := 'CodeableConcept'
  else if (propName = 'author') then result := 'ContactDetail'
  else if (propName = 'editor') then result := 'ContactDetail'
  else if (propName = 'reviewer') then result := 'ContactDetail'
  else if (propName = 'endorser') then result := 'ContactDetail'
  else if (propName = 'relatedArtifact') then result := 'RelatedArtifact'
  else if (propName = 'parameter') then result := 'ParameterDefinition'
  else if (propName = 'dataRequirement') then result := 'DataRequirement'
  else if (propName = 'content') then result := 'Attachment'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirLibrary.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := nil
  else if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'version') then VersionElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'title') then TitleElement := nil
  else if (propName = 'subtitle') then SubtitleElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'experimental') then ExperimentalElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (isMatchingName(propName, 'subject', ['CodeableConcept', 'Reference'])) then SubjectElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'publisher') then PublisherElement := nil
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value)
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'useContext') then deletePropertyValue('useContext', UseContextList, value)
  else if (propName = 'jurisdiction') then deletePropertyValue('jurisdiction', JurisdictionList, value)
  else if (propName = 'purpose') then PurposeElement := nil
  else if (propName = 'usage') then UsageElement := nil
  else if (propName = 'copyright') then CopyrightElement := nil
  else if (propName = 'approvalDate') then ApprovalDateElement := nil
  else if (propName = 'lastReviewDate') then LastReviewDateElement := nil
  else if (propName = 'effectivePeriod') then EffectivePeriodElement := nil
  else if (propName = 'topic') then deletePropertyValue('topic', TopicList, value)
  else if (propName = 'author') then deletePropertyValue('author', AuthorList, value)
  else if (propName = 'editor') then deletePropertyValue('editor', EditorList, value)
  else if (propName = 'reviewer') then deletePropertyValue('reviewer', ReviewerList, value)
  else if (propName = 'endorser') then deletePropertyValue('endorser', EndorserList, value)
  else if (propName = 'relatedArtifact') then deletePropertyValue('relatedArtifact', RelatedArtifactList, value)
  else if (propName = 'parameter') then deletePropertyValue('parameter', ParameterList, value)
  else if (propName = 'dataRequirement') then deletePropertyValue('dataRequirement', DataRequirementList, value)
  else if (propName = 'content') then deletePropertyValue('content', ContentList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirLibrary.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := asUri(new)
  else if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'version') then VersionElement := asString(new)
  else if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'title') then TitleElement := asString(new)
  else if (propName = 'subtitle') then SubtitleElement := asString(new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, new)
  else if (propName = 'experimental') then ExperimentalElement := asBoolean(new)
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (isMatchingName(propName, 'subject', ['CodeableConcept', 'Reference'])) then SubjectElement := new as TFhirDataType
  else if (propName = 'date') then DateElement := asDateTime(new)
  else if (propName = 'publisher') then PublisherElement := asString(new)
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new)
  else if (propName = 'description') then DescriptionElement := asMarkdown(new)
  else if (propName = 'useContext') then replacePropertyValue('useContext', UseContextList, existing, new)
  else if (propName = 'jurisdiction') then replacePropertyValue('jurisdiction', JurisdictionList, existing, new)
  else if (propName = 'purpose') then PurposeElement := asMarkdown(new)
  else if (propName = 'usage') then UsageElement := asString(new)
  else if (propName = 'copyright') then CopyrightElement := asMarkdown(new)
  else if (propName = 'approvalDate') then ApprovalDateElement := asDate(new)
  else if (propName = 'lastReviewDate') then LastReviewDateElement := asDate(new)
  else if (propName = 'effectivePeriod') then EffectivePeriodElement := new as TFhirPeriod
  else if (propName = 'topic') then replacePropertyValue('topic', TopicList, existing, new)
  else if (propName = 'author') then replacePropertyValue('author', AuthorList, existing, new)
  else if (propName = 'editor') then replacePropertyValue('editor', EditorList, existing, new)
  else if (propName = 'reviewer') then replacePropertyValue('reviewer', ReviewerList, existing, new)
  else if (propName = 'endorser') then replacePropertyValue('endorser', EndorserList, existing, new)
  else if (propName = 'relatedArtifact') then replacePropertyValue('relatedArtifact', RelatedArtifactList, existing, new)
  else if (propName = 'parameter') then replacePropertyValue('parameter', ParameterList, existing, new)
  else if (propName = 'dataRequirement') then replacePropertyValue('dataRequirement', DataRequirementList, existing, new)
  else if (propName = 'content') then replacePropertyValue('content', ContentList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirLibrary.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'contact') then ContactList.move(source, destination)
  else if (propName = 'useContext') then UseContextList.move(source, destination)
  else if (propName = 'jurisdiction') then JurisdictionList.move(source, destination)
  else if (propName = 'topic') then TopicList.move(source, destination)
  else if (propName = 'author') then AuthorList.move(source, destination)
  else if (propName = 'editor') then EditorList.move(source, destination)
  else if (propName = 'reviewer') then ReviewerList.move(source, destination)
  else if (propName = 'endorser') then EndorserList.move(source, destination)
  else if (propName = 'relatedArtifact') then RelatedArtifactList.move(source, destination)
  else if (propName = 'parameter') then ParameterList.move(source, destination)
  else if (propName = 'dataRequirement') then DataRequirementList.move(source, destination)
  else if (propName = 'content') then ContentList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirLibrary.fhirType : string;
begin
  result := 'Library';
end;

function TFhirLibrary.Link : TFhirLibrary;
begin
  result := TFhirLibrary(inherited Link);
end;

function TFhirLibrary.Clone : TFhirLibrary;
begin
  result := TFhirLibrary(inherited Clone);
end;

function TFhirLibrary.equals(other : TObject) : boolean; 
var
  o : TFhirLibrary;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirLibrary)) then
    result := false
  else
  begin
    o := TFhirLibrary(other);
    result := compareDeep(urlElement, o.urlElement, true) and compareDeep(identifierList, o.identifierList, true) and 
      compareDeep(versionElement, o.versionElement, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(titleElement, o.titleElement, true) and compareDeep(subtitleElement, o.subtitleElement, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(experimentalElement, o.experimentalElement, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(subjectElement, o.subjectElement, true) and 
      compareDeep(dateElement, o.dateElement, true) and compareDeep(publisherElement, o.publisherElement, true) and 
      compareDeep(contactList, o.contactList, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(useContextList, o.useContextList, true) and compareDeep(jurisdictionList, o.jurisdictionList, true) and 
      compareDeep(purposeElement, o.purposeElement, true) and compareDeep(usageElement, o.usageElement, true) and 
      compareDeep(copyrightElement, o.copyrightElement, true) and compareDeep(approvalDateElement, o.approvalDateElement, true) and 
      compareDeep(lastReviewDateElement, o.lastReviewDateElement, true) and compareDeep(effectivePeriodElement, o.effectivePeriodElement, true) and 
      compareDeep(topicList, o.topicList, true) and compareDeep(authorList, o.authorList, true) and 
      compareDeep(editorList, o.editorList, true) and compareDeep(reviewerList, o.reviewerList, true) and 
      compareDeep(endorserList, o.endorserList, true) and compareDeep(relatedArtifactList, o.relatedArtifactList, true) and 
      compareDeep(parameterList, o.parameterList, true) and compareDeep(dataRequirementList, o.dataRequirementList, true) and 
      compareDeep(contentList, o.contentList, true);
  end;
end;

function TFhirLibrary.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FUrl) and isEmptyProp(FidentifierList) and isEmptyProp(FVersion) and isEmptyProp(FName) and isEmptyProp(FTitle) and isEmptyProp(FSubtitle) and isEmptyProp(FStatus) and isEmptyProp(FExperimental) and isEmptyProp(FType_) and isEmptyProp(FSubject) and isEmptyProp(FDate) and isEmptyProp(FPublisher) and isEmptyProp(FcontactList) and isEmptyProp(FDescription) and isEmptyProp(FuseContextList) and isEmptyProp(FjurisdictionList) and isEmptyProp(FPurpose) and isEmptyProp(FUsage) and isEmptyProp(FCopyright) and isEmptyProp(FApprovalDate) and isEmptyProp(FLastReviewDate) and isEmptyProp(FEffectivePeriod) and isEmptyProp(FtopicList) and isEmptyProp(FauthorList) and isEmptyProp(FeditorList) and isEmptyProp(FreviewerList) and isEmptyProp(FendorserList) and isEmptyProp(FrelatedArtifactList) and isEmptyProp(FparameterList) and isEmptyProp(FdataRequirementList) and isEmptyProp(FcontentList);
end;

procedure TFhirLibrary.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('url');
  fields.add('identifier');
  fields.add('version');
  fields.add('name');
  fields.add('title');
  fields.add('subtitle');
  fields.add('status');
  fields.add('experimental');
  fields.add('type');
  fields.add('subject[x]');
  fields.add('date');
  fields.add('publisher');
  fields.add('contact');
  fields.add('description');
  fields.add('useContext');
  fields.add('jurisdiction');
  fields.add('purpose');
  fields.add('usage');
  fields.add('copyright');
  fields.add('approvalDate');
  fields.add('lastReviewDate');
  fields.add('effectivePeriod');
  fields.add('topic');
  fields.add('author');
  fields.add('editor');
  fields.add('reviewer');
  fields.add('endorser');
  fields.add('relatedArtifact');
  fields.add('parameter');
  fields.add('dataRequirement');
  fields.add('content');
end;

function TFhirLibrary.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FContactList.sizeInBytes(magic));
  inc(result, FUseContextList.sizeInBytes(magic));
  inc(result, FJurisdictionList.sizeInBytes(magic));
  inc(result, FTopicList.sizeInBytes(magic));
  inc(result, FAuthorList.sizeInBytes(magic));
  inc(result, FEditorList.sizeInBytes(magic));
  inc(result, FReviewerList.sizeInBytes(magic));
  inc(result, FEndorserList.sizeInBytes(magic));
  inc(result, FRelatedArtifactList.sizeInBytes(magic));
  inc(result, FParameterList.sizeInBytes(magic));
  inc(result, FDataRequirementList.sizeInBytes(magic));
  inc(result, FContentList.sizeInBytes(magic));
end;

procedure TFhirLibrary.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

function TFhirLibrary.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

procedure TFhirLibrary.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

function TFhirLibrary.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirLibrary.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirLibrary.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

function TFhirLibrary.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

procedure TFhirLibrary.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

procedure TFhirLibrary.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirLibrary.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirLibrary.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirLibrary.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

function TFhirLibrary.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

procedure TFhirLibrary.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

procedure TFhirLibrary.SetSubtitle(value : TFhirString);
begin
  FSubtitle.free;
  FSubtitle := value;
end;

function TFhirLibrary.GetSubtitleST : String;
begin
  if FSubtitle = nil then
    result := ''
  else
    result := FSubtitle.value;
end;

procedure TFhirLibrary.SetSubtitleST(value : String);
begin
  if value <> '' then
  begin
    if FSubtitle = nil then
      FSubtitle := TFhirString.create;
    FSubtitle.value := value
  end
  else if FSubtitle <> nil then
    FSubtitle.value := '';
end;

procedure TFhirLibrary.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirLibrary.GetStatusST : TFhirPublicationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirPublicationStatusEnum(0)
  else
    result := TFhirPublicationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirPublicationStatusEnum, FStatus.value));
end;

procedure TFhirLibrary.SetStatusST(value : TFhirPublicationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[value], CODES_TFhirPublicationStatusEnum[value]);
end;

procedure TFhirLibrary.SetExperimental(value : TFhirBoolean);
begin
  FExperimental.free;
  FExperimental := value;
end;

function TFhirLibrary.GetExperimentalST : Boolean;
begin
  if FExperimental = nil then
    result := false
  else
    result := FExperimental.value;
end;

procedure TFhirLibrary.SetExperimentalST(value : Boolean);
begin
  if FExperimental = nil then
    FExperimental := TFhirBoolean.create;
  FExperimental.value := value
end;

procedure TFhirLibrary.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirLibrary.SetSubject(value : TFhirDataType);
begin
  FSubject.free;
  FSubject := value;
end;

procedure TFhirLibrary.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

function TFhirLibrary.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirLibrary.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

procedure TFhirLibrary.SetPublisher(value : TFhirString);
begin
  FPublisher.free;
  FPublisher := value;
end;

function TFhirLibrary.GetPublisherST : String;
begin
  if FPublisher = nil then
    result := ''
  else
    result := FPublisher.value;
end;

procedure TFhirLibrary.SetPublisherST(value : String);
begin
  if value <> '' then
  begin
    if FPublisher = nil then
      FPublisher := TFhirString.create;
    FPublisher.value := value
  end
  else if FPublisher <> nil then
    FPublisher.value := '';
end;

function TFhirLibrary.GetContactList : TFhirContactDetailList;
begin
  if FContactList = nil then
    FContactList := TFhirContactDetailList.Create;
  result := FContactList;
end;

function TFhirLibrary.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

procedure TFhirLibrary.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirLibrary.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirLibrary.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirLibrary.GetUseContextList : TFhirUsageContextList;
begin
  if FUseContextList = nil then
    FUseContextList := TFhirUsageContextList.Create;
  result := FUseContextList;
end;

function TFhirLibrary.GetHasUseContextList : boolean;
begin
  result := (FUseContextList <> nil) and (FUseContextList.count > 0);
end;

function TFhirLibrary.GetJurisdictionList : TFhirCodeableConceptList;
begin
  if FJurisdictionList = nil then
    FJurisdictionList := TFhirCodeableConceptList.Create;
  result := FJurisdictionList;
end;

function TFhirLibrary.GetHasJurisdictionList : boolean;
begin
  result := (FJurisdictionList <> nil) and (FJurisdictionList.count > 0);
end;

procedure TFhirLibrary.SetPurpose(value : TFhirMarkdown);
begin
  FPurpose.free;
  FPurpose := value;
end;

function TFhirLibrary.GetPurposeST : String;
begin
  if FPurpose = nil then
    result := ''
  else
    result := FPurpose.value;
end;

procedure TFhirLibrary.SetPurposeST(value : String);
begin
  if value <> '' then
  begin
    if FPurpose = nil then
      FPurpose := TFhirMarkdown.create;
    FPurpose.value := value
  end
  else if FPurpose <> nil then
    FPurpose.value := '';
end;

procedure TFhirLibrary.SetUsage(value : TFhirString);
begin
  FUsage.free;
  FUsage := value;
end;

function TFhirLibrary.GetUsageST : String;
begin
  if FUsage = nil then
    result := ''
  else
    result := FUsage.value;
end;

procedure TFhirLibrary.SetUsageST(value : String);
begin
  if value <> '' then
  begin
    if FUsage = nil then
      FUsage := TFhirString.create;
    FUsage.value := value
  end
  else if FUsage <> nil then
    FUsage.value := '';
end;

procedure TFhirLibrary.SetCopyright(value : TFhirMarkdown);
begin
  FCopyright.free;
  FCopyright := value;
end;

function TFhirLibrary.GetCopyrightST : String;
begin
  if FCopyright = nil then
    result := ''
  else
    result := FCopyright.value;
end;

procedure TFhirLibrary.SetCopyrightST(value : String);
begin
  if value <> '' then
  begin
    if FCopyright = nil then
      FCopyright := TFhirMarkdown.create;
    FCopyright.value := value
  end
  else if FCopyright <> nil then
    FCopyright.value := '';
end;

procedure TFhirLibrary.SetApprovalDate(value : TFhirDate);
begin
  FApprovalDate.free;
  FApprovalDate := value;
end;

function TFhirLibrary.GetApprovalDateST : TFslDateTime;
begin
  if FApprovalDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FApprovalDate.value;
end;

procedure TFhirLibrary.SetApprovalDateST(value : TFslDateTime);
begin
  if FApprovalDate = nil then
    FApprovalDate := TFhirDate.create;
  FApprovalDate.value := value
end;

procedure TFhirLibrary.SetLastReviewDate(value : TFhirDate);
begin
  FLastReviewDate.free;
  FLastReviewDate := value;
end;

function TFhirLibrary.GetLastReviewDateST : TFslDateTime;
begin
  if FLastReviewDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FLastReviewDate.value;
end;

procedure TFhirLibrary.SetLastReviewDateST(value : TFslDateTime);
begin
  if FLastReviewDate = nil then
    FLastReviewDate := TFhirDate.create;
  FLastReviewDate.value := value
end;

procedure TFhirLibrary.SetEffectivePeriod(value : TFhirPeriod);
begin
  FEffectivePeriod.free;
  FEffectivePeriod := value;
end;

function TFhirLibrary.GetTopicList : TFhirCodeableConceptList;
begin
  if FTopicList = nil then
    FTopicList := TFhirCodeableConceptList.Create;
  result := FTopicList;
end;

function TFhirLibrary.GetHasTopicList : boolean;
begin
  result := (FTopicList <> nil) and (FTopicList.count > 0);
end;

function TFhirLibrary.GetAuthorList : TFhirContactDetailList;
begin
  if FAuthorList = nil then
    FAuthorList := TFhirContactDetailList.Create;
  result := FAuthorList;
end;

function TFhirLibrary.GetHasAuthorList : boolean;
begin
  result := (FAuthorList <> nil) and (FAuthorList.count > 0);
end;

function TFhirLibrary.GetEditorList : TFhirContactDetailList;
begin
  if FEditorList = nil then
    FEditorList := TFhirContactDetailList.Create;
  result := FEditorList;
end;

function TFhirLibrary.GetHasEditorList : boolean;
begin
  result := (FEditorList <> nil) and (FEditorList.count > 0);
end;

function TFhirLibrary.GetReviewerList : TFhirContactDetailList;
begin
  if FReviewerList = nil then
    FReviewerList := TFhirContactDetailList.Create;
  result := FReviewerList;
end;

function TFhirLibrary.GetHasReviewerList : boolean;
begin
  result := (FReviewerList <> nil) and (FReviewerList.count > 0);
end;

function TFhirLibrary.GetEndorserList : TFhirContactDetailList;
begin
  if FEndorserList = nil then
    FEndorserList := TFhirContactDetailList.Create;
  result := FEndorserList;
end;

function TFhirLibrary.GetHasEndorserList : boolean;
begin
  result := (FEndorserList <> nil) and (FEndorserList.count > 0);
end;

function TFhirLibrary.GetRelatedArtifactList : TFhirRelatedArtifactList;
begin
  if FRelatedArtifactList = nil then
    FRelatedArtifactList := TFhirRelatedArtifactList.Create;
  result := FRelatedArtifactList;
end;

function TFhirLibrary.GetHasRelatedArtifactList : boolean;
begin
  result := (FRelatedArtifactList <> nil) and (FRelatedArtifactList.count > 0);
end;

function TFhirLibrary.GetParameterList : TFhirParameterDefinitionList;
begin
  if FParameterList = nil then
    FParameterList := TFhirParameterDefinitionList.Create;
  result := FParameterList;
end;

function TFhirLibrary.GetHasParameterList : boolean;
begin
  result := (FParameterList <> nil) and (FParameterList.count > 0);
end;

function TFhirLibrary.GetDataRequirementList : TFhirDataRequirementList;
begin
  if FDataRequirementList = nil then
    FDataRequirementList := TFhirDataRequirementList.Create;
  result := FDataRequirementList;
end;

function TFhirLibrary.GetHasDataRequirementList : boolean;
begin
  result := (FDataRequirementList <> nil) and (FDataRequirementList.count > 0);
end;

function TFhirLibrary.GetContentList : TFhirAttachmentList;
begin
  if FContentList = nil then
    FContentList := TFhirAttachmentList.Create;
  result := FContentList;
end;

function TFhirLibrary.GetHasContentList : boolean;
begin
  result := (FContentList <> nil) and (FContentList.count > 0);
end;

{ TFhirLibraryListEnumerator }

constructor TFhirLibraryListEnumerator.Create(list : TFhirLibraryList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirLibraryListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirLibraryListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirLibraryListEnumerator.GetCurrent : TFhirLibrary;
begin
  Result := FList[FIndex];
end;

function TFhirLibraryListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirLibraryList }

function TFhirLibraryList.AddItem(value: TFhirLibrary): TFhirLibrary;
begin
  assert(value.ClassName = 'TFhirLibrary', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirLibrary');
  add(value);
  result := value;
end;

function TFhirLibraryList.Append: TFhirLibrary;
begin
  result := TFhirLibrary.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirLibraryList.ClearItems;
begin
  Clear;
end;

function TFhirLibraryList.GetEnumerator : TFhirLibraryListEnumerator;
begin
  result := TFhirLibraryListEnumerator.Create(self.link);
end;

function TFhirLibraryList.Clone: TFhirLibraryList;
begin
  result := TFhirLibraryList(inherited Clone);
end;

function TFhirLibraryList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirLibraryList.GetItemN(index: Integer): TFhirLibrary;
begin
  result := TFhirLibrary(ObjectByIndex[index]);
end;

function TFhirLibraryList.ItemClass: TFslObjectClass;
begin
  result := TFhirLibrary;
end;
function TFhirLibraryList.IndexOf(value: TFhirLibrary): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirLibraryList.Insert(index: Integer): TFhirLibrary;
begin
  result := TFhirLibrary.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirLibraryList.InsertItem(index: Integer; value: TFhirLibrary);
begin
  assert(value is TFhirLibrary);
  Inherited Insert(index, value);
end;

function TFhirLibraryList.Item(index: Integer): TFhirLibrary;
begin
  result := TFhirLibrary(ObjectByIndex[index]);
end;

function TFhirLibraryList.Link: TFhirLibraryList;
begin
  result := TFhirLibraryList(inherited Link);
end;

procedure TFhirLibraryList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirLibraryList.SetItemByIndex(index: Integer; value: TFhirLibrary);
begin
  assert(value is TFhirLibrary);
  FhirLibraries[index] := value;
end;

procedure TFhirLibraryList.SetItemN(index: Integer; value: TFhirLibrary);
begin
  assert(value is TFhirLibrary);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_LIBRARY}
{$IFDEF FHIR_MEASURE}
{ TFhirMeasureGroup }

constructor TFhirMeasureGroup.Create;
begin
  inherited;
end;

destructor TFhirMeasureGroup.Destroy;
begin
  FCode.free;
  FDescription.free;
  FPopulationList.Free;
  FStratifierList.Free;
  inherited;
end;

procedure TFhirMeasureGroup.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirMeasureGroup(oSource).code.Clone;
  descriptionElement := TFhirMeasureGroup(oSource).descriptionElement.Clone;
  if (TFhirMeasureGroup(oSource).FPopulationList = nil) then
  begin
    FPopulationList.free;
    FPopulationList := nil;
  end
  else
  begin
    if FPopulationList = nil then
      FPopulationList := TFhirMeasureGroupPopulationList.Create;
    FPopulationList.Assign(TFhirMeasureGroup(oSource).FPopulationList);
  end;
  if (TFhirMeasureGroup(oSource).FStratifierList = nil) then
  begin
    FStratifierList.free;
    FStratifierList := nil;
  end
  else
  begin
    if FStratifierList = nil then
      FStratifierList := TFhirMeasureGroupStratifierList.Create;
    FStratifierList.Assign(TFhirMeasureGroup(oSource).FStratifierList);
  end;
end;

procedure TFhirMeasureGroup.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'population') Then
    list.addAll(self, 'population', FPopulationList);
  if (child_name = 'stratifier') Then
    list.addAll(self, 'stratifier', FStratifierList);
end;

procedure TFhirMeasureGroup.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'population', 'BackboneElement', true, TFhirMeasureGroupPopulation, FPopulationList.Link));
  oList.add(TFHIRProperty.create(self, 'stratifier', 'BackboneElement', true, TFhirMeasureGroupStratifier, FStratifierList.Link));
end;

function TFhirMeasureGroup.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'population') then
  begin
    PopulationList.add(propValue as TFhirMeasureGroupPopulation);
    result := propValue;
  end
  else if (propName = 'stratifier') then
  begin
    StratifierList.add(propValue as TFhirMeasureGroupStratifier);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMeasureGroup.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'population') then PopulationList.insertItem(index, propValue as TFhirMeasureGroupPopulation)
  else if (propName = 'stratifier') then StratifierList.insertItem(index, propValue as TFhirMeasureGroupStratifier)
  else inherited;
end;

function TFhirMeasureGroup.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (propName = 'description') then result := TFhirString.create()
  else if (propName = 'population') then result := PopulationList.new()
  else if (propName = 'stratifier') then result := StratifierList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMeasureGroup.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'population') then result := 'BackboneElement'
  else if (propName = 'stratifier') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMeasureGroup.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'population') then deletePropertyValue('population', PopulationList, value)
  else if (propName = 'stratifier') then deletePropertyValue('stratifier', StratifierList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMeasureGroup.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (propName = 'description') then DescriptionElement := asString(new)
  else if (propName = 'population') then replacePropertyValue('population', PopulationList, existing, new)
  else if (propName = 'stratifier') then replacePropertyValue('stratifier', StratifierList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMeasureGroup.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'population') then PopulationList.move(source, destination)
  else if (propName = 'stratifier') then StratifierList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMeasureGroup.fhirType : string;
begin
  result := 'Measure.group';
end;

function TFhirMeasureGroup.Link : TFhirMeasureGroup;
begin
  result := TFhirMeasureGroup(inherited Link);
end;

function TFhirMeasureGroup.Clone : TFhirMeasureGroup;
begin
  result := TFhirMeasureGroup(inherited Clone);
end;

function TFhirMeasureGroup.equals(other : TObject) : boolean; 
var
  o : TFhirMeasureGroup;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMeasureGroup)) then
    result := false
  else
  begin
    o := TFhirMeasureGroup(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(populationList, o.populationList, true) and compareDeep(stratifierList, o.stratifierList, true);
  end;
end;

function TFhirMeasureGroup.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FDescription) and isEmptyProp(FpopulationList) and isEmptyProp(FstratifierList);
end;

procedure TFhirMeasureGroup.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('code');
  fields.add('description');
  fields.add('population');
  fields.add('stratifier');
end;

function TFhirMeasureGroup.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FPopulationList.sizeInBytes(magic));
  inc(result, FStratifierList.sizeInBytes(magic));
end;

procedure TFhirMeasureGroup.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

procedure TFhirMeasureGroup.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirMeasureGroup.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirMeasureGroup.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirMeasureGroup.GetPopulationList : TFhirMeasureGroupPopulationList;
begin
  if FPopulationList = nil then
    FPopulationList := TFhirMeasureGroupPopulationList.Create;
  result := FPopulationList;
end;

function TFhirMeasureGroup.GetHasPopulationList : boolean;
begin
  result := (FPopulationList <> nil) and (FPopulationList.count > 0);
end;

function TFhirMeasureGroup.GetStratifierList : TFhirMeasureGroupStratifierList;
begin
  if FStratifierList = nil then
    FStratifierList := TFhirMeasureGroupStratifierList.Create;
  result := FStratifierList;
end;

function TFhirMeasureGroup.GetHasStratifierList : boolean;
begin
  result := (FStratifierList <> nil) and (FStratifierList.count > 0);
end;

{ TFhirMeasureGroupListEnumerator }

constructor TFhirMeasureGroupListEnumerator.Create(list : TFhirMeasureGroupList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMeasureGroupListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMeasureGroupListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMeasureGroupListEnumerator.GetCurrent : TFhirMeasureGroup;
begin
  Result := FList[FIndex];
end;

function TFhirMeasureGroupListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMeasureGroupList }

function TFhirMeasureGroupList.AddItem(value: TFhirMeasureGroup): TFhirMeasureGroup;
begin
  assert(value.ClassName = 'TFhirMeasureGroup', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMeasureGroup');
  add(value);
  result := value;
end;

function TFhirMeasureGroupList.Append: TFhirMeasureGroup;
begin
  result := TFhirMeasureGroup.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureGroupList.ClearItems;
begin
  Clear;
end;

function TFhirMeasureGroupList.GetEnumerator : TFhirMeasureGroupListEnumerator;
begin
  result := TFhirMeasureGroupListEnumerator.Create(self.link);
end;

function TFhirMeasureGroupList.Clone: TFhirMeasureGroupList;
begin
  result := TFhirMeasureGroupList(inherited Clone);
end;

function TFhirMeasureGroupList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMeasureGroupList.GetItemN(index: Integer): TFhirMeasureGroup;
begin
  result := TFhirMeasureGroup(ObjectByIndex[index]);
end;

function TFhirMeasureGroupList.ItemClass: TFslObjectClass;
begin
  result := TFhirMeasureGroup;
end;
function TFhirMeasureGroupList.IndexOf(value: TFhirMeasureGroup): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMeasureGroupList.Insert(index: Integer): TFhirMeasureGroup;
begin
  result := TFhirMeasureGroup.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureGroupList.InsertItem(index: Integer; value: TFhirMeasureGroup);
begin
  assert(value is TFhirMeasureGroup);
  Inherited Insert(index, value);
end;

function TFhirMeasureGroupList.Item(index: Integer): TFhirMeasureGroup;
begin
  result := TFhirMeasureGroup(ObjectByIndex[index]);
end;

function TFhirMeasureGroupList.Link: TFhirMeasureGroupList;
begin
  result := TFhirMeasureGroupList(inherited Link);
end;

procedure TFhirMeasureGroupList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMeasureGroupList.SetItemByIndex(index: Integer; value: TFhirMeasureGroup);
begin
  assert(value is TFhirMeasureGroup);
  FhirMeasureGroups[index] := value;
end;

procedure TFhirMeasureGroupList.SetItemN(index: Integer; value: TFhirMeasureGroup);
begin
  assert(value is TFhirMeasureGroup);
  ObjectByIndex[index] := value;
end;

{ TFhirMeasureGroupPopulation }

constructor TFhirMeasureGroupPopulation.Create;
begin
  inherited;
end;

destructor TFhirMeasureGroupPopulation.Destroy;
begin
  FCode.free;
  FDescription.free;
  FCriteria.free;
  inherited;
end;

procedure TFhirMeasureGroupPopulation.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirMeasureGroupPopulation(oSource).code.Clone;
  descriptionElement := TFhirMeasureGroupPopulation(oSource).descriptionElement.Clone;
  criteria := TFhirMeasureGroupPopulation(oSource).criteria.Clone;
end;

procedure TFhirMeasureGroupPopulation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'criteria') Then
     list.add(self.link, 'criteria', FCriteria.Link);
end;

procedure TFhirMeasureGroupPopulation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'criteria', 'Expression', false, TFhirExpression, FCriteria.Link));
end;

function TFhirMeasureGroupPopulation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'criteria') then
  begin
    Criteria := propValue as TFhirExpression;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMeasureGroupPopulation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMeasureGroupPopulation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (propName = 'description') then result := TFhirString.create()
  else if (propName = 'criteria') then result := TFhirExpression.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMeasureGroupPopulation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'criteria') then result := 'Expression'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMeasureGroupPopulation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'criteria') then CriteriaElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMeasureGroupPopulation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (propName = 'description') then DescriptionElement := asString(new)
  else if (propName = 'criteria') then CriteriaElement := new as TFhirExpression
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMeasureGroupPopulation.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMeasureGroupPopulation.fhirType : string;
begin
  result := 'Measure.group.population';
end;

function TFhirMeasureGroupPopulation.Link : TFhirMeasureGroupPopulation;
begin
  result := TFhirMeasureGroupPopulation(inherited Link);
end;

function TFhirMeasureGroupPopulation.Clone : TFhirMeasureGroupPopulation;
begin
  result := TFhirMeasureGroupPopulation(inherited Clone);
end;

function TFhirMeasureGroupPopulation.equals(other : TObject) : boolean; 
var
  o : TFhirMeasureGroupPopulation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMeasureGroupPopulation)) then
    result := false
  else
  begin
    o := TFhirMeasureGroupPopulation(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(criteriaElement, o.criteriaElement, true);
  end;
end;

function TFhirMeasureGroupPopulation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FDescription) and isEmptyProp(FCriteria);
end;

procedure TFhirMeasureGroupPopulation.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('code');
  fields.add('description');
  fields.add('criteria');
end;

function TFhirMeasureGroupPopulation.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirMeasureGroupPopulation.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

procedure TFhirMeasureGroupPopulation.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirMeasureGroupPopulation.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirMeasureGroupPopulation.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirMeasureGroupPopulation.SetCriteria(value : TFhirExpression);
begin
  FCriteria.free;
  FCriteria := value;
end;

{ TFhirMeasureGroupPopulationListEnumerator }

constructor TFhirMeasureGroupPopulationListEnumerator.Create(list : TFhirMeasureGroupPopulationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMeasureGroupPopulationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMeasureGroupPopulationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMeasureGroupPopulationListEnumerator.GetCurrent : TFhirMeasureGroupPopulation;
begin
  Result := FList[FIndex];
end;

function TFhirMeasureGroupPopulationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMeasureGroupPopulationList }

function TFhirMeasureGroupPopulationList.AddItem(value: TFhirMeasureGroupPopulation): TFhirMeasureGroupPopulation;
begin
  assert(value.ClassName = 'TFhirMeasureGroupPopulation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMeasureGroupPopulation');
  add(value);
  result := value;
end;

function TFhirMeasureGroupPopulationList.Append: TFhirMeasureGroupPopulation;
begin
  result := TFhirMeasureGroupPopulation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureGroupPopulationList.ClearItems;
begin
  Clear;
end;

function TFhirMeasureGroupPopulationList.GetEnumerator : TFhirMeasureGroupPopulationListEnumerator;
begin
  result := TFhirMeasureGroupPopulationListEnumerator.Create(self.link);
end;

function TFhirMeasureGroupPopulationList.Clone: TFhirMeasureGroupPopulationList;
begin
  result := TFhirMeasureGroupPopulationList(inherited Clone);
end;

function TFhirMeasureGroupPopulationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMeasureGroupPopulationList.GetItemN(index: Integer): TFhirMeasureGroupPopulation;
begin
  result := TFhirMeasureGroupPopulation(ObjectByIndex[index]);
end;

function TFhirMeasureGroupPopulationList.ItemClass: TFslObjectClass;
begin
  result := TFhirMeasureGroupPopulation;
end;
function TFhirMeasureGroupPopulationList.IndexOf(value: TFhirMeasureGroupPopulation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMeasureGroupPopulationList.Insert(index: Integer): TFhirMeasureGroupPopulation;
begin
  result := TFhirMeasureGroupPopulation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureGroupPopulationList.InsertItem(index: Integer; value: TFhirMeasureGroupPopulation);
begin
  assert(value is TFhirMeasureGroupPopulation);
  Inherited Insert(index, value);
end;

function TFhirMeasureGroupPopulationList.Item(index: Integer): TFhirMeasureGroupPopulation;
begin
  result := TFhirMeasureGroupPopulation(ObjectByIndex[index]);
end;

function TFhirMeasureGroupPopulationList.Link: TFhirMeasureGroupPopulationList;
begin
  result := TFhirMeasureGroupPopulationList(inherited Link);
end;

procedure TFhirMeasureGroupPopulationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMeasureGroupPopulationList.SetItemByIndex(index: Integer; value: TFhirMeasureGroupPopulation);
begin
  assert(value is TFhirMeasureGroupPopulation);
  FhirMeasureGroupPopulations[index] := value;
end;

procedure TFhirMeasureGroupPopulationList.SetItemN(index: Integer; value: TFhirMeasureGroupPopulation);
begin
  assert(value is TFhirMeasureGroupPopulation);
  ObjectByIndex[index] := value;
end;

{ TFhirMeasureGroupStratifier }

constructor TFhirMeasureGroupStratifier.Create;
begin
  inherited;
end;

destructor TFhirMeasureGroupStratifier.Destroy;
begin
  FCode.free;
  FDescription.free;
  FCriteria.free;
  FComponentList.Free;
  inherited;
end;

procedure TFhirMeasureGroupStratifier.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirMeasureGroupStratifier(oSource).code.Clone;
  descriptionElement := TFhirMeasureGroupStratifier(oSource).descriptionElement.Clone;
  criteria := TFhirMeasureGroupStratifier(oSource).criteria.Clone;
  if (TFhirMeasureGroupStratifier(oSource).FComponentList = nil) then
  begin
    FComponentList.free;
    FComponentList := nil;
  end
  else
  begin
    if FComponentList = nil then
      FComponentList := TFhirMeasureGroupStratifierComponentList.Create;
    FComponentList.Assign(TFhirMeasureGroupStratifier(oSource).FComponentList);
  end;
end;

procedure TFhirMeasureGroupStratifier.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'criteria') Then
     list.add(self.link, 'criteria', FCriteria.Link);
  if (child_name = 'component') Then
    list.addAll(self, 'component', FComponentList);
end;

procedure TFhirMeasureGroupStratifier.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'criteria', 'Expression', false, TFhirExpression, FCriteria.Link));
  oList.add(TFHIRProperty.create(self, 'component', 'BackboneElement', true, TFhirMeasureGroupStratifierComponent, FComponentList.Link));
end;

function TFhirMeasureGroupStratifier.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'criteria') then
  begin
    Criteria := propValue as TFhirExpression;
    result := propValue;
  end
  else if (propName = 'component') then
  begin
    ComponentList.add(propValue as TFhirMeasureGroupStratifierComponent);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMeasureGroupStratifier.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'component') then ComponentList.insertItem(index, propValue as TFhirMeasureGroupStratifierComponent)
  else inherited;
end;

function TFhirMeasureGroupStratifier.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (propName = 'description') then result := TFhirString.create()
  else if (propName = 'criteria') then result := TFhirExpression.create()
  else if (propName = 'component') then result := ComponentList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMeasureGroupStratifier.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'criteria') then result := 'Expression'
  else if (propName = 'component') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMeasureGroupStratifier.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'criteria') then CriteriaElement := nil
  else if (propName = 'component') then deletePropertyValue('component', ComponentList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMeasureGroupStratifier.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (propName = 'description') then DescriptionElement := asString(new)
  else if (propName = 'criteria') then CriteriaElement := new as TFhirExpression
  else if (propName = 'component') then replacePropertyValue('component', ComponentList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMeasureGroupStratifier.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'component') then ComponentList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMeasureGroupStratifier.fhirType : string;
begin
  result := 'Measure.group.stratifier';
end;

function TFhirMeasureGroupStratifier.Link : TFhirMeasureGroupStratifier;
begin
  result := TFhirMeasureGroupStratifier(inherited Link);
end;

function TFhirMeasureGroupStratifier.Clone : TFhirMeasureGroupStratifier;
begin
  result := TFhirMeasureGroupStratifier(inherited Clone);
end;

function TFhirMeasureGroupStratifier.equals(other : TObject) : boolean; 
var
  o : TFhirMeasureGroupStratifier;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMeasureGroupStratifier)) then
    result := false
  else
  begin
    o := TFhirMeasureGroupStratifier(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(criteriaElement, o.criteriaElement, true) and compareDeep(componentList, o.componentList, true);
  end;
end;

function TFhirMeasureGroupStratifier.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FDescription) and isEmptyProp(FCriteria) and isEmptyProp(FcomponentList);
end;

procedure TFhirMeasureGroupStratifier.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('code');
  fields.add('description');
  fields.add('criteria');
  fields.add('component');
end;

function TFhirMeasureGroupStratifier.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FComponentList.sizeInBytes(magic));
end;

procedure TFhirMeasureGroupStratifier.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

procedure TFhirMeasureGroupStratifier.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirMeasureGroupStratifier.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirMeasureGroupStratifier.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirMeasureGroupStratifier.SetCriteria(value : TFhirExpression);
begin
  FCriteria.free;
  FCriteria := value;
end;

function TFhirMeasureGroupStratifier.GetComponentList : TFhirMeasureGroupStratifierComponentList;
begin
  if FComponentList = nil then
    FComponentList := TFhirMeasureGroupStratifierComponentList.Create;
  result := FComponentList;
end;

function TFhirMeasureGroupStratifier.GetHasComponentList : boolean;
begin
  result := (FComponentList <> nil) and (FComponentList.count > 0);
end;

{ TFhirMeasureGroupStratifierListEnumerator }

constructor TFhirMeasureGroupStratifierListEnumerator.Create(list : TFhirMeasureGroupStratifierList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMeasureGroupStratifierListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMeasureGroupStratifierListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMeasureGroupStratifierListEnumerator.GetCurrent : TFhirMeasureGroupStratifier;
begin
  Result := FList[FIndex];
end;

function TFhirMeasureGroupStratifierListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMeasureGroupStratifierList }

function TFhirMeasureGroupStratifierList.AddItem(value: TFhirMeasureGroupStratifier): TFhirMeasureGroupStratifier;
begin
  assert(value.ClassName = 'TFhirMeasureGroupStratifier', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMeasureGroupStratifier');
  add(value);
  result := value;
end;

function TFhirMeasureGroupStratifierList.Append: TFhirMeasureGroupStratifier;
begin
  result := TFhirMeasureGroupStratifier.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureGroupStratifierList.ClearItems;
begin
  Clear;
end;

function TFhirMeasureGroupStratifierList.GetEnumerator : TFhirMeasureGroupStratifierListEnumerator;
begin
  result := TFhirMeasureGroupStratifierListEnumerator.Create(self.link);
end;

function TFhirMeasureGroupStratifierList.Clone: TFhirMeasureGroupStratifierList;
begin
  result := TFhirMeasureGroupStratifierList(inherited Clone);
end;

function TFhirMeasureGroupStratifierList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMeasureGroupStratifierList.GetItemN(index: Integer): TFhirMeasureGroupStratifier;
begin
  result := TFhirMeasureGroupStratifier(ObjectByIndex[index]);
end;

function TFhirMeasureGroupStratifierList.ItemClass: TFslObjectClass;
begin
  result := TFhirMeasureGroupStratifier;
end;
function TFhirMeasureGroupStratifierList.IndexOf(value: TFhirMeasureGroupStratifier): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMeasureGroupStratifierList.Insert(index: Integer): TFhirMeasureGroupStratifier;
begin
  result := TFhirMeasureGroupStratifier.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureGroupStratifierList.InsertItem(index: Integer; value: TFhirMeasureGroupStratifier);
begin
  assert(value is TFhirMeasureGroupStratifier);
  Inherited Insert(index, value);
end;

function TFhirMeasureGroupStratifierList.Item(index: Integer): TFhirMeasureGroupStratifier;
begin
  result := TFhirMeasureGroupStratifier(ObjectByIndex[index]);
end;

function TFhirMeasureGroupStratifierList.Link: TFhirMeasureGroupStratifierList;
begin
  result := TFhirMeasureGroupStratifierList(inherited Link);
end;

procedure TFhirMeasureGroupStratifierList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMeasureGroupStratifierList.SetItemByIndex(index: Integer; value: TFhirMeasureGroupStratifier);
begin
  assert(value is TFhirMeasureGroupStratifier);
  FhirMeasureGroupStratifiers[index] := value;
end;

procedure TFhirMeasureGroupStratifierList.SetItemN(index: Integer; value: TFhirMeasureGroupStratifier);
begin
  assert(value is TFhirMeasureGroupStratifier);
  ObjectByIndex[index] := value;
end;

{ TFhirMeasureGroupStratifierComponent }

constructor TFhirMeasureGroupStratifierComponent.Create;
begin
  inherited;
end;

destructor TFhirMeasureGroupStratifierComponent.Destroy;
begin
  FCode.free;
  FDescription.free;
  FCriteria.free;
  inherited;
end;

procedure TFhirMeasureGroupStratifierComponent.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirMeasureGroupStratifierComponent(oSource).code.Clone;
  descriptionElement := TFhirMeasureGroupStratifierComponent(oSource).descriptionElement.Clone;
  criteria := TFhirMeasureGroupStratifierComponent(oSource).criteria.Clone;
end;

procedure TFhirMeasureGroupStratifierComponent.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'criteria') Then
     list.add(self.link, 'criteria', FCriteria.Link);
end;

procedure TFhirMeasureGroupStratifierComponent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'criteria', 'Expression', false, TFhirExpression, FCriteria.Link));
end;

function TFhirMeasureGroupStratifierComponent.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'criteria') then
  begin
    Criteria := propValue as TFhirExpression;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMeasureGroupStratifierComponent.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMeasureGroupStratifierComponent.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (propName = 'description') then result := TFhirString.create()
  else if (propName = 'criteria') then result := TFhirExpression.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMeasureGroupStratifierComponent.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'criteria') then result := 'Expression'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMeasureGroupStratifierComponent.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'criteria') then CriteriaElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMeasureGroupStratifierComponent.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (propName = 'description') then DescriptionElement := asString(new)
  else if (propName = 'criteria') then CriteriaElement := new as TFhirExpression
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMeasureGroupStratifierComponent.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMeasureGroupStratifierComponent.fhirType : string;
begin
  result := 'Measure.group.stratifier.component';
end;

function TFhirMeasureGroupStratifierComponent.Link : TFhirMeasureGroupStratifierComponent;
begin
  result := TFhirMeasureGroupStratifierComponent(inherited Link);
end;

function TFhirMeasureGroupStratifierComponent.Clone : TFhirMeasureGroupStratifierComponent;
begin
  result := TFhirMeasureGroupStratifierComponent(inherited Clone);
end;

function TFhirMeasureGroupStratifierComponent.equals(other : TObject) : boolean; 
var
  o : TFhirMeasureGroupStratifierComponent;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMeasureGroupStratifierComponent)) then
    result := false
  else
  begin
    o := TFhirMeasureGroupStratifierComponent(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(criteriaElement, o.criteriaElement, true);
  end;
end;

function TFhirMeasureGroupStratifierComponent.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FDescription) and isEmptyProp(FCriteria);
end;

procedure TFhirMeasureGroupStratifierComponent.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('code');
  fields.add('description');
  fields.add('criteria');
end;

function TFhirMeasureGroupStratifierComponent.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirMeasureGroupStratifierComponent.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

procedure TFhirMeasureGroupStratifierComponent.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirMeasureGroupStratifierComponent.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirMeasureGroupStratifierComponent.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirMeasureGroupStratifierComponent.SetCriteria(value : TFhirExpression);
begin
  FCriteria.free;
  FCriteria := value;
end;

{ TFhirMeasureGroupStratifierComponentListEnumerator }

constructor TFhirMeasureGroupStratifierComponentListEnumerator.Create(list : TFhirMeasureGroupStratifierComponentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMeasureGroupStratifierComponentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMeasureGroupStratifierComponentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMeasureGroupStratifierComponentListEnumerator.GetCurrent : TFhirMeasureGroupStratifierComponent;
begin
  Result := FList[FIndex];
end;

function TFhirMeasureGroupStratifierComponentListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMeasureGroupStratifierComponentList }

function TFhirMeasureGroupStratifierComponentList.AddItem(value: TFhirMeasureGroupStratifierComponent): TFhirMeasureGroupStratifierComponent;
begin
  assert(value.ClassName = 'TFhirMeasureGroupStratifierComponent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMeasureGroupStratifierComponent');
  add(value);
  result := value;
end;

function TFhirMeasureGroupStratifierComponentList.Append: TFhirMeasureGroupStratifierComponent;
begin
  result := TFhirMeasureGroupStratifierComponent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureGroupStratifierComponentList.ClearItems;
begin
  Clear;
end;

function TFhirMeasureGroupStratifierComponentList.GetEnumerator : TFhirMeasureGroupStratifierComponentListEnumerator;
begin
  result := TFhirMeasureGroupStratifierComponentListEnumerator.Create(self.link);
end;

function TFhirMeasureGroupStratifierComponentList.Clone: TFhirMeasureGroupStratifierComponentList;
begin
  result := TFhirMeasureGroupStratifierComponentList(inherited Clone);
end;

function TFhirMeasureGroupStratifierComponentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMeasureGroupStratifierComponentList.GetItemN(index: Integer): TFhirMeasureGroupStratifierComponent;
begin
  result := TFhirMeasureGroupStratifierComponent(ObjectByIndex[index]);
end;

function TFhirMeasureGroupStratifierComponentList.ItemClass: TFslObjectClass;
begin
  result := TFhirMeasureGroupStratifierComponent;
end;
function TFhirMeasureGroupStratifierComponentList.IndexOf(value: TFhirMeasureGroupStratifierComponent): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMeasureGroupStratifierComponentList.Insert(index: Integer): TFhirMeasureGroupStratifierComponent;
begin
  result := TFhirMeasureGroupStratifierComponent.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureGroupStratifierComponentList.InsertItem(index: Integer; value: TFhirMeasureGroupStratifierComponent);
begin
  assert(value is TFhirMeasureGroupStratifierComponent);
  Inherited Insert(index, value);
end;

function TFhirMeasureGroupStratifierComponentList.Item(index: Integer): TFhirMeasureGroupStratifierComponent;
begin
  result := TFhirMeasureGroupStratifierComponent(ObjectByIndex[index]);
end;

function TFhirMeasureGroupStratifierComponentList.Link: TFhirMeasureGroupStratifierComponentList;
begin
  result := TFhirMeasureGroupStratifierComponentList(inherited Link);
end;

procedure TFhirMeasureGroupStratifierComponentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMeasureGroupStratifierComponentList.SetItemByIndex(index: Integer; value: TFhirMeasureGroupStratifierComponent);
begin
  assert(value is TFhirMeasureGroupStratifierComponent);
  FhirMeasureGroupStratifierComponents[index] := value;
end;

procedure TFhirMeasureGroupStratifierComponentList.SetItemN(index: Integer; value: TFhirMeasureGroupStratifierComponent);
begin
  assert(value is TFhirMeasureGroupStratifierComponent);
  ObjectByIndex[index] := value;
end;

{ TFhirMeasureSupplementalData }

constructor TFhirMeasureSupplementalData.Create;
begin
  inherited;
end;

destructor TFhirMeasureSupplementalData.Destroy;
begin
  FCode.free;
  FUsageList.Free;
  FDescription.free;
  FCriteria.free;
  inherited;
end;

procedure TFhirMeasureSupplementalData.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirMeasureSupplementalData(oSource).code.Clone;
  if (TFhirMeasureSupplementalData(oSource).FUsageList = nil) then
  begin
    FUsageList.free;
    FUsageList := nil;
  end
  else
  begin
    if FUsageList = nil then
      FUsageList := TFhirCodeableConceptList.Create;
    FUsageList.Assign(TFhirMeasureSupplementalData(oSource).FUsageList);
  end;
  descriptionElement := TFhirMeasureSupplementalData(oSource).descriptionElement.Clone;
  criteria := TFhirMeasureSupplementalData(oSource).criteria.Clone;
end;

procedure TFhirMeasureSupplementalData.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'usage') Then
    list.addAll(self, 'usage', FUsageList);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'criteria') Then
     list.add(self.link, 'criteria', FCriteria.Link);
end;

procedure TFhirMeasureSupplementalData.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'usage', 'CodeableConcept', true, TFhirCodeableConcept, FUsageList.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'criteria', 'Expression', false, TFhirExpression, FCriteria.Link));
end;

function TFhirMeasureSupplementalData.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'usage') then
  begin
    UsageList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'criteria') then
  begin
    Criteria := propValue as TFhirExpression;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMeasureSupplementalData.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'usage') then UsageList.insertItem(index, propValue as TFhirCodeableConcept)
  else inherited;
end;

function TFhirMeasureSupplementalData.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (propName = 'usage') then result := UsageList.new()
  else if (propName = 'description') then result := TFhirString.create()
  else if (propName = 'criteria') then result := TFhirExpression.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMeasureSupplementalData.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'usage') then result := 'CodeableConcept'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'criteria') then result := 'Expression'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMeasureSupplementalData.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'usage') then deletePropertyValue('usage', UsageList, value)
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'criteria') then CriteriaElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMeasureSupplementalData.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (propName = 'usage') then replacePropertyValue('usage', UsageList, existing, new)
  else if (propName = 'description') then DescriptionElement := asString(new)
  else if (propName = 'criteria') then CriteriaElement := new as TFhirExpression
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMeasureSupplementalData.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'usage') then UsageList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMeasureSupplementalData.fhirType : string;
begin
  result := 'Measure.supplementalData';
end;

function TFhirMeasureSupplementalData.Link : TFhirMeasureSupplementalData;
begin
  result := TFhirMeasureSupplementalData(inherited Link);
end;

function TFhirMeasureSupplementalData.Clone : TFhirMeasureSupplementalData;
begin
  result := TFhirMeasureSupplementalData(inherited Clone);
end;

function TFhirMeasureSupplementalData.equals(other : TObject) : boolean; 
var
  o : TFhirMeasureSupplementalData;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMeasureSupplementalData)) then
    result := false
  else
  begin
    o := TFhirMeasureSupplementalData(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(usageList, o.usageList, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(criteriaElement, o.criteriaElement, true);
  end;
end;

function TFhirMeasureSupplementalData.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FusageList) and isEmptyProp(FDescription) and isEmptyProp(FCriteria);
end;

procedure TFhirMeasureSupplementalData.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('code');
  fields.add('usage');
  fields.add('description');
  fields.add('criteria');
end;

function TFhirMeasureSupplementalData.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FUsageList.sizeInBytes(magic));
end;

procedure TFhirMeasureSupplementalData.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

function TFhirMeasureSupplementalData.GetUsageList : TFhirCodeableConceptList;
begin
  if FUsageList = nil then
    FUsageList := TFhirCodeableConceptList.Create;
  result := FUsageList;
end;

function TFhirMeasureSupplementalData.GetHasUsageList : boolean;
begin
  result := (FUsageList <> nil) and (FUsageList.count > 0);
end;

procedure TFhirMeasureSupplementalData.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirMeasureSupplementalData.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirMeasureSupplementalData.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirMeasureSupplementalData.SetCriteria(value : TFhirExpression);
begin
  FCriteria.free;
  FCriteria := value;
end;

{ TFhirMeasureSupplementalDataListEnumerator }

constructor TFhirMeasureSupplementalDataListEnumerator.Create(list : TFhirMeasureSupplementalDataList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMeasureSupplementalDataListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMeasureSupplementalDataListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMeasureSupplementalDataListEnumerator.GetCurrent : TFhirMeasureSupplementalData;
begin
  Result := FList[FIndex];
end;

function TFhirMeasureSupplementalDataListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMeasureSupplementalDataList }

function TFhirMeasureSupplementalDataList.AddItem(value: TFhirMeasureSupplementalData): TFhirMeasureSupplementalData;
begin
  assert(value.ClassName = 'TFhirMeasureSupplementalData', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMeasureSupplementalData');
  add(value);
  result := value;
end;

function TFhirMeasureSupplementalDataList.Append: TFhirMeasureSupplementalData;
begin
  result := TFhirMeasureSupplementalData.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureSupplementalDataList.ClearItems;
begin
  Clear;
end;

function TFhirMeasureSupplementalDataList.GetEnumerator : TFhirMeasureSupplementalDataListEnumerator;
begin
  result := TFhirMeasureSupplementalDataListEnumerator.Create(self.link);
end;

function TFhirMeasureSupplementalDataList.Clone: TFhirMeasureSupplementalDataList;
begin
  result := TFhirMeasureSupplementalDataList(inherited Clone);
end;

function TFhirMeasureSupplementalDataList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMeasureSupplementalDataList.GetItemN(index: Integer): TFhirMeasureSupplementalData;
begin
  result := TFhirMeasureSupplementalData(ObjectByIndex[index]);
end;

function TFhirMeasureSupplementalDataList.ItemClass: TFslObjectClass;
begin
  result := TFhirMeasureSupplementalData;
end;
function TFhirMeasureSupplementalDataList.IndexOf(value: TFhirMeasureSupplementalData): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMeasureSupplementalDataList.Insert(index: Integer): TFhirMeasureSupplementalData;
begin
  result := TFhirMeasureSupplementalData.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureSupplementalDataList.InsertItem(index: Integer; value: TFhirMeasureSupplementalData);
begin
  assert(value is TFhirMeasureSupplementalData);
  Inherited Insert(index, value);
end;

function TFhirMeasureSupplementalDataList.Item(index: Integer): TFhirMeasureSupplementalData;
begin
  result := TFhirMeasureSupplementalData(ObjectByIndex[index]);
end;

function TFhirMeasureSupplementalDataList.Link: TFhirMeasureSupplementalDataList;
begin
  result := TFhirMeasureSupplementalDataList(inherited Link);
end;

procedure TFhirMeasureSupplementalDataList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMeasureSupplementalDataList.SetItemByIndex(index: Integer; value: TFhirMeasureSupplementalData);
begin
  assert(value is TFhirMeasureSupplementalData);
  FhirMeasureSupplementalData[index] := value;
end;

procedure TFhirMeasureSupplementalDataList.SetItemN(index: Integer; value: TFhirMeasureSupplementalData);
begin
  assert(value is TFhirMeasureSupplementalData);
  ObjectByIndex[index] := value;
end;

{ TFhirMeasure }

constructor TFhirMeasure.Create;
begin
  inherited;
end;

destructor TFhirMeasure.Destroy;
begin
  FUrl.free;
  FIdentifierList.Free;
  FVersion.free;
  FName.free;
  FTitle.free;
  FSubtitle.free;
  FStatus.free;
  FExperimental.free;
  FSubject.free;
  FDate.free;
  FPublisher.free;
  FContactList.Free;
  FDescription.free;
  FUseContextList.Free;
  FJurisdictionList.Free;
  FPurpose.free;
  FUsage.free;
  FCopyright.free;
  FApprovalDate.free;
  FLastReviewDate.free;
  FEffectivePeriod.free;
  FTopicList.Free;
  FAuthorList.Free;
  FEditorList.Free;
  FReviewerList.Free;
  FEndorserList.Free;
  FRelatedArtifactList.Free;
  FLibrary_List.Free;
  FDisclaimer.free;
  FScoring.free;
  FCompositeScoring.free;
  FType_List.Free;
  FRiskAdjustment.free;
  FRateAggregation.free;
  FRationale.free;
  FClinicalRecommendationStatement.free;
  FImprovementNotation.free;
  FDefinitionList.Free;
  FGuidance.free;
  FGroupList.Free;
  FSupplementalDataList.Free;
  inherited;
end;

procedure TFhirMeasure.Assign(oSource : TFslObject);
begin
  inherited;
  urlElement := TFhirMeasure(oSource).urlElement.Clone;
  if (TFhirMeasure(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirMeasure(oSource).FIdentifierList);
  end;
  versionElement := TFhirMeasure(oSource).versionElement.Clone;
  nameElement := TFhirMeasure(oSource).nameElement.Clone;
  titleElement := TFhirMeasure(oSource).titleElement.Clone;
  subtitleElement := TFhirMeasure(oSource).subtitleElement.Clone;
  statusElement := TFhirMeasure(oSource).statusElement.Clone;
  experimentalElement := TFhirMeasure(oSource).experimentalElement.Clone;
  subject := TFhirMeasure(oSource).subject.Clone;
  dateElement := TFhirMeasure(oSource).dateElement.Clone;
  publisherElement := TFhirMeasure(oSource).publisherElement.Clone;
  if (TFhirMeasure(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirContactDetailList.Create;
    FContactList.Assign(TFhirMeasure(oSource).FContactList);
  end;
  descriptionElement := TFhirMeasure(oSource).descriptionElement.Clone;
  if (TFhirMeasure(oSource).FUseContextList = nil) then
  begin
    FUseContextList.free;
    FUseContextList := nil;
  end
  else
  begin
    if FUseContextList = nil then
      FUseContextList := TFhirUsageContextList.Create;
    FUseContextList.Assign(TFhirMeasure(oSource).FUseContextList);
  end;
  if (TFhirMeasure(oSource).FJurisdictionList = nil) then
  begin
    FJurisdictionList.free;
    FJurisdictionList := nil;
  end
  else
  begin
    if FJurisdictionList = nil then
      FJurisdictionList := TFhirCodeableConceptList.Create;
    FJurisdictionList.Assign(TFhirMeasure(oSource).FJurisdictionList);
  end;
  purposeElement := TFhirMeasure(oSource).purposeElement.Clone;
  usageElement := TFhirMeasure(oSource).usageElement.Clone;
  copyrightElement := TFhirMeasure(oSource).copyrightElement.Clone;
  approvalDateElement := TFhirMeasure(oSource).approvalDateElement.Clone;
  lastReviewDateElement := TFhirMeasure(oSource).lastReviewDateElement.Clone;
  effectivePeriod := TFhirMeasure(oSource).effectivePeriod.Clone;
  if (TFhirMeasure(oSource).FTopicList = nil) then
  begin
    FTopicList.free;
    FTopicList := nil;
  end
  else
  begin
    if FTopicList = nil then
      FTopicList := TFhirCodeableConceptList.Create;
    FTopicList.Assign(TFhirMeasure(oSource).FTopicList);
  end;
  if (TFhirMeasure(oSource).FAuthorList = nil) then
  begin
    FAuthorList.free;
    FAuthorList := nil;
  end
  else
  begin
    if FAuthorList = nil then
      FAuthorList := TFhirContactDetailList.Create;
    FAuthorList.Assign(TFhirMeasure(oSource).FAuthorList);
  end;
  if (TFhirMeasure(oSource).FEditorList = nil) then
  begin
    FEditorList.free;
    FEditorList := nil;
  end
  else
  begin
    if FEditorList = nil then
      FEditorList := TFhirContactDetailList.Create;
    FEditorList.Assign(TFhirMeasure(oSource).FEditorList);
  end;
  if (TFhirMeasure(oSource).FReviewerList = nil) then
  begin
    FReviewerList.free;
    FReviewerList := nil;
  end
  else
  begin
    if FReviewerList = nil then
      FReviewerList := TFhirContactDetailList.Create;
    FReviewerList.Assign(TFhirMeasure(oSource).FReviewerList);
  end;
  if (TFhirMeasure(oSource).FEndorserList = nil) then
  begin
    FEndorserList.free;
    FEndorserList := nil;
  end
  else
  begin
    if FEndorserList = nil then
      FEndorserList := TFhirContactDetailList.Create;
    FEndorserList.Assign(TFhirMeasure(oSource).FEndorserList);
  end;
  if (TFhirMeasure(oSource).FRelatedArtifactList = nil) then
  begin
    FRelatedArtifactList.free;
    FRelatedArtifactList := nil;
  end
  else
  begin
    if FRelatedArtifactList = nil then
      FRelatedArtifactList := TFhirRelatedArtifactList.Create;
    FRelatedArtifactList.Assign(TFhirMeasure(oSource).FRelatedArtifactList);
  end;
  if (TFhirMeasure(oSource).FLibrary_List = nil) then
  begin
    FLibrary_List.free;
    FLibrary_List := nil;
  end
  else
  begin
    if FLibrary_List = nil then
      FLibrary_List := TFhirCanonicalList.Create;
    FLibrary_List.Assign(TFhirMeasure(oSource).FLibrary_List);
  end;
  disclaimerElement := TFhirMeasure(oSource).disclaimerElement.Clone;
  scoring := TFhirMeasure(oSource).scoring.Clone;
  compositeScoring := TFhirMeasure(oSource).compositeScoring.Clone;
  if (TFhirMeasure(oSource).FType_List = nil) then
  begin
    FType_List.free;
    FType_List := nil;
  end
  else
  begin
    if FType_List = nil then
      FType_List := TFhirCodeableConceptList.Create;
    FType_List.Assign(TFhirMeasure(oSource).FType_List);
  end;
  riskAdjustmentElement := TFhirMeasure(oSource).riskAdjustmentElement.Clone;
  rateAggregationElement := TFhirMeasure(oSource).rateAggregationElement.Clone;
  rationaleElement := TFhirMeasure(oSource).rationaleElement.Clone;
  clinicalRecommendationStatementElement := TFhirMeasure(oSource).clinicalRecommendationStatementElement.Clone;
  improvementNotation := TFhirMeasure(oSource).improvementNotation.Clone;
  if (TFhirMeasure(oSource).FDefinitionList = nil) then
  begin
    FDefinitionList.free;
    FDefinitionList := nil;
  end
  else
  begin
    if FDefinitionList = nil then
      FDefinitionList := TFhirMarkdownList.Create;
    FDefinitionList.Assign(TFhirMeasure(oSource).FDefinitionList);
  end;
  guidanceElement := TFhirMeasure(oSource).guidanceElement.Clone;
  if (TFhirMeasure(oSource).FGroupList = nil) then
  begin
    FGroupList.free;
    FGroupList := nil;
  end
  else
  begin
    if FGroupList = nil then
      FGroupList := TFhirMeasureGroupList.Create;
    FGroupList.Assign(TFhirMeasure(oSource).FGroupList);
  end;
  if (TFhirMeasure(oSource).FSupplementalDataList = nil) then
  begin
    FSupplementalDataList.free;
    FSupplementalDataList := nil;
  end
  else
  begin
    if FSupplementalDataList = nil then
      FSupplementalDataList := TFhirMeasureSupplementalDataList.Create;
    FSupplementalDataList.Assign(TFhirMeasure(oSource).FSupplementalDataList);
  end;
end;

function TFhirMeasure.GetResourceType : TFhirResourceType;
begin
  result := frtMeasure;
end;

procedure TFhirMeasure.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'version') Then
     list.add(self.link, 'version', FVersion.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
  if (child_name = 'subtitle') Then
     list.add(self.link, 'subtitle', FSubtitle.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'experimental') Then
     list.add(self.link, 'experimental', FExperimental.Link);
  if (child_name = 'subject[x]') or (child_name = 'subject') Then
     list.add(self.link, 'subject[x]', FSubject.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'publisher') Then
     list.add(self.link, 'publisher', FPublisher.Link);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'useContext') Then
    list.addAll(self, 'useContext', FUseContextList);
  if (child_name = 'jurisdiction') Then
    list.addAll(self, 'jurisdiction', FJurisdictionList);
  if (child_name = 'purpose') Then
     list.add(self.link, 'purpose', FPurpose.Link);
  if (child_name = 'usage') Then
     list.add(self.link, 'usage', FUsage.Link);
  if (child_name = 'copyright') Then
     list.add(self.link, 'copyright', FCopyright.Link);
  if (child_name = 'approvalDate') Then
     list.add(self.link, 'approvalDate', FApprovalDate.Link);
  if (child_name = 'lastReviewDate') Then
     list.add(self.link, 'lastReviewDate', FLastReviewDate.Link);
  if (child_name = 'effectivePeriod') Then
     list.add(self.link, 'effectivePeriod', FEffectivePeriod.Link);
  if (child_name = 'topic') Then
    list.addAll(self, 'topic', FTopicList);
  if (child_name = 'author') Then
    list.addAll(self, 'author', FAuthorList);
  if (child_name = 'editor') Then
    list.addAll(self, 'editor', FEditorList);
  if (child_name = 'reviewer') Then
    list.addAll(self, 'reviewer', FReviewerList);
  if (child_name = 'endorser') Then
    list.addAll(self, 'endorser', FEndorserList);
  if (child_name = 'relatedArtifact') Then
    list.addAll(self, 'relatedArtifact', FRelatedArtifactList);
  if (child_name = 'library') Then
    list.addAll(self, 'library', FLibrary_List);
  if (child_name = 'disclaimer') Then
     list.add(self.link, 'disclaimer', FDisclaimer.Link);
  if (child_name = 'scoring') Then
     list.add(self.link, 'scoring', FScoring.Link);
  if (child_name = 'compositeScoring') Then
     list.add(self.link, 'compositeScoring', FCompositeScoring.Link);
  if (child_name = 'type') Then
    list.addAll(self, 'type', FType_List);
  if (child_name = 'riskAdjustment') Then
     list.add(self.link, 'riskAdjustment', FRiskAdjustment.Link);
  if (child_name = 'rateAggregation') Then
     list.add(self.link, 'rateAggregation', FRateAggregation.Link);
  if (child_name = 'rationale') Then
     list.add(self.link, 'rationale', FRationale.Link);
  if (child_name = 'clinicalRecommendationStatement') Then
     list.add(self.link, 'clinicalRecommendationStatement', FClinicalRecommendationStatement.Link);
  if (child_name = 'improvementNotation') Then
     list.add(self.link, 'improvementNotation', FImprovementNotation.Link);
  if (child_name = 'definition') Then
    list.addAll(self, 'definition', FDefinitionList);
  if (child_name = 'guidance') Then
     list.add(self.link, 'guidance', FGuidance.Link);
  if (child_name = 'group') Then
    list.addAll(self, 'group', FGroupList);
  if (child_name = 'supplementalData') Then
    list.addAll(self, 'supplementalData', FSupplementalDataList);
end;

procedure TFhirMeasure.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'url', 'uri', false, TFhirUri, FUrl.Link));
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'version', 'string', false, TFhirString, FVersion.Link));
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link));
  oList.add(TFHIRProperty.create(self, 'subtitle', 'string', false, TFhirString, FSubtitle.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'experimental', 'boolean', false, TFhirBoolean, FExperimental.Link));
  oList.add(TFHIRProperty.create(self, 'subject[x]', 'CodeableConcept|Reference', false, TFhirDataType, FSubject.Link));
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));
  oList.add(TFHIRProperty.create(self, 'publisher', 'string', false, TFhirString, FPublisher.Link));
  oList.add(TFHIRProperty.create(self, 'contact', 'ContactDetail', true, TFhirContactDetail, FContactList.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'markdown', false, TFhirMarkdown, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'useContext', 'UsageContext', true, TFhirUsageContext, FUseContextList.Link));
  oList.add(TFHIRProperty.create(self, 'jurisdiction', 'CodeableConcept', true, TFhirCodeableConcept, FJurisdictionList.Link));
  oList.add(TFHIRProperty.create(self, 'purpose', 'markdown', false, TFhirMarkdown, FPurpose.Link));
  oList.add(TFHIRProperty.create(self, 'usage', 'string', false, TFhirString, FUsage.Link));
  oList.add(TFHIRProperty.create(self, 'copyright', 'markdown', false, TFhirMarkdown, FCopyright.Link));
  oList.add(TFHIRProperty.create(self, 'approvalDate', 'date', false, TFhirDate, FApprovalDate.Link));
  oList.add(TFHIRProperty.create(self, 'lastReviewDate', 'date', false, TFhirDate, FLastReviewDate.Link));
  oList.add(TFHIRProperty.create(self, 'effectivePeriod', 'Period', false, TFhirPeriod, FEffectivePeriod.Link));
  oList.add(TFHIRProperty.create(self, 'topic', 'CodeableConcept', true, TFhirCodeableConcept, FTopicList.Link));
  oList.add(TFHIRProperty.create(self, 'author', 'ContactDetail', true, TFhirContactDetail, FAuthorList.Link));
  oList.add(TFHIRProperty.create(self, 'editor', 'ContactDetail', true, TFhirContactDetail, FEditorList.Link));
  oList.add(TFHIRProperty.create(self, 'reviewer', 'ContactDetail', true, TFhirContactDetail, FReviewerList.Link));
  oList.add(TFHIRProperty.create(self, 'endorser', 'ContactDetail', true, TFhirContactDetail, FEndorserList.Link));
  oList.add(TFHIRProperty.create(self, 'relatedArtifact', 'RelatedArtifact', true, TFhirRelatedArtifact, FRelatedArtifactList.Link));
  oList.add(TFHIRProperty.create(self, 'library', 'canonical', true, TFhirCanonical, FLibrary_List.Link));
  oList.add(TFHIRProperty.create(self, 'disclaimer', 'markdown', false, TFhirMarkdown, FDisclaimer.Link));
  oList.add(TFHIRProperty.create(self, 'scoring', 'CodeableConcept', false, TFhirCodeableConcept, FScoring.Link));
  oList.add(TFHIRProperty.create(self, 'compositeScoring', 'CodeableConcept', false, TFhirCodeableConcept, FCompositeScoring.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', true, TFhirCodeableConcept, FType_List.Link));
  oList.add(TFHIRProperty.create(self, 'riskAdjustment', 'string', false, TFhirString, FRiskAdjustment.Link));
  oList.add(TFHIRProperty.create(self, 'rateAggregation', 'string', false, TFhirString, FRateAggregation.Link));
  oList.add(TFHIRProperty.create(self, 'rationale', 'markdown', false, TFhirMarkdown, FRationale.Link));
  oList.add(TFHIRProperty.create(self, 'clinicalRecommendationStatement', 'markdown', false, TFhirMarkdown, FClinicalRecommendationStatement.Link));
  oList.add(TFHIRProperty.create(self, 'improvementNotation', 'CodeableConcept', false, TFhirCodeableConcept, FImprovementNotation.Link));
  oList.add(TFHIRProperty.create(self, 'definition', 'markdown', true, TFhirMarkdown, FDefinitionList.Link));
  oList.add(TFHIRProperty.create(self, 'guidance', 'markdown', false, TFhirMarkdown, FGuidance.Link));
  oList.add(TFHIRProperty.create(self, 'group', 'BackboneElement', true, TFhirMeasureGroup, FGroupList.Link));
  oList.add(TFHIRProperty.create(self, 'supplementalData', 'BackboneElement', true, TFhirMeasureSupplementalData, FSupplementalDataList.Link));
end;

function TFhirMeasure.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'url') then
  begin
    UrlElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'title') then
  begin
    TitleElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'subtitle') then
  begin
    SubtitleElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'experimental') then
  begin
    ExperimentalElement := asBoolean(propValue);
    result := propValue;
  end
  else if (isMatchingName(propName, 'subject', ['CodeableConcept', 'Reference'])) then
  begin
    Subject := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'publisher') then
  begin
    PublisherElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirContactDetail);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'useContext') then
  begin
    UseContextList.add(propValue as TFhirUsageContext);
    result := propValue;
  end
  else if (propName = 'jurisdiction') then
  begin
    JurisdictionList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'purpose') then
  begin
    PurposeElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'usage') then
  begin
    UsageElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'copyright') then
  begin
    CopyrightElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'approvalDate') then
  begin
    ApprovalDateElement := asDate(propValue);
    result := propValue;
  end
  else if (propName = 'lastReviewDate') then
  begin
    LastReviewDateElement := asDate(propValue);
    result := propValue;
  end
  else if (propName = 'effectivePeriod') then
  begin
    EffectivePeriod := propValue as TFhirPeriod;
    result := propValue;
  end
  else if (propName = 'topic') then
  begin
    TopicList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    AuthorList.add(propValue as TFhirContactDetail);
    result := propValue;
  end
  else if (propName = 'editor') then
  begin
    EditorList.add(propValue as TFhirContactDetail);
    result := propValue;
  end
  else if (propName = 'reviewer') then
  begin
    ReviewerList.add(propValue as TFhirContactDetail);
    result := propValue;
  end
  else if (propName = 'endorser') then
  begin
    EndorserList.add(propValue as TFhirContactDetail);
    result := propValue;
  end
  else if (propName = 'relatedArtifact') then
  begin
    RelatedArtifactList.add(propValue as TFhirRelatedArtifact);
    result := propValue;
  end
  else if (propName = 'library') then
  begin
    Library_List.add(asCanonical(propValue)){2};     result := propValue;

  end
  else if (propName = 'disclaimer') then
  begin
    DisclaimerElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'scoring') then
  begin
    Scoring := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'compositeScoring') then
  begin
    CompositeScoring := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_List.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'riskAdjustment') then
  begin
    RiskAdjustmentElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'rateAggregation') then
  begin
    RateAggregationElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'rationale') then
  begin
    RationaleElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'clinicalRecommendationStatement') then
  begin
    ClinicalRecommendationStatementElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'improvementNotation') then
  begin
    ImprovementNotation := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'definition') then
  begin
    DefinitionList.add(asMarkdown(propValue)){2};     result := propValue;

  end
  else if (propName = 'guidance') then
  begin
    GuidanceElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'group') then
  begin
    GroupList.add(propValue as TFhirMeasureGroup);
    result := propValue;
  end
  else if (propName = 'supplementalData') then
  begin
    SupplementalDataList.add(propValue as TFhirMeasureSupplementalData);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMeasure.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirContactDetail)
  else if (propName = 'useContext') then UseContextList.insertItem(index, propValue as TFhirUsageContext)
  else if (propName = 'jurisdiction') then JurisdictionList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'topic') then TopicList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'author') then AuthorList.insertItem(index, propValue as TFhirContactDetail)
  else if (propName = 'editor') then EditorList.insertItem(index, propValue as TFhirContactDetail)
  else if (propName = 'reviewer') then ReviewerList.insertItem(index, propValue as TFhirContactDetail)
  else if (propName = 'endorser') then EndorserList.insertItem(index, propValue as TFhirContactDetail)
  else if (propName = 'relatedArtifact') then RelatedArtifactList.insertItem(index, propValue as TFhirRelatedArtifact)
  else if (propName = 'library') then Library_List.insertItem(index, asCanonical(propValue))
  else if (propName = 'type') then Type_List.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'definition') then DefinitionList.insertItem(index, asMarkdown(propValue))
  else if (propName = 'group') then GroupList.insertItem(index, propValue as TFhirMeasureGroup)
  else if (propName = 'supplementalData') then SupplementalDataList.insertItem(index, propValue as TFhirMeasureSupplementalData)
  else inherited;
end;

function TFhirMeasure.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'url') then result := TFhirUri.create()
  else if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'version') then result := TFhirString.create()
  else if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'title') then result := TFhirString.create()
  else if (propName = 'subtitle') then result := TFhirString.create()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[PublicationStatusNull], CODES_TFhirPublicationStatusEnum[PublicationStatusNull]) 
  else if (propName = 'experimental') then result := TFhirBoolean.create()
  else if (isMatchingName(propName, 'subject', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Subject')
  else if (propName = 'date') then result := TFhirDateTime.create()
  else if (propName = 'publisher') then result := TFhirString.create()
  else if (propName = 'contact') then result := ContactList.new()
  else if (propName = 'description') then result := TFhirMarkdown.create()
  else if (propName = 'useContext') then result := UseContextList.new()
  else if (propName = 'jurisdiction') then result := JurisdictionList.new()
  else if (propName = 'purpose') then result := TFhirMarkdown.create()
  else if (propName = 'usage') then result := TFhirString.create()
  else if (propName = 'copyright') then result := TFhirMarkdown.create()
  else if (propName = 'approvalDate') then result := TFhirDate.create()
  else if (propName = 'lastReviewDate') then result := TFhirDate.create()
  else if (propName = 'effectivePeriod') then result := TFhirPeriod.create()
  else if (propName = 'topic') then result := TopicList.new()
  else if (propName = 'author') then result := AuthorList.new()
  else if (propName = 'editor') then result := EditorList.new()
  else if (propName = 'reviewer') then result := ReviewerList.new()
  else if (propName = 'endorser') then result := EndorserList.new()
  else if (propName = 'relatedArtifact') then result := RelatedArtifactList.new()
  else if (propName = 'library') then result := Library_List.new()
  else if (propName = 'disclaimer') then result := TFhirMarkdown.create()
  else if (propName = 'scoring') then result := TFhirCodeableConcept.create()
  else if (propName = 'compositeScoring') then result := TFhirCodeableConcept.create()
  else if (propName = 'type') then result := Type_List.new()
  else if (propName = 'riskAdjustment') then result := TFhirString.create()
  else if (propName = 'rateAggregation') then result := TFhirString.create()
  else if (propName = 'rationale') then result := TFhirMarkdown.create()
  else if (propName = 'clinicalRecommendationStatement') then result := TFhirMarkdown.create()
  else if (propName = 'improvementNotation') then result := TFhirCodeableConcept.create()
  else if (propName = 'definition') then result := DefinitionList.new()
  else if (propName = 'guidance') then result := TFhirMarkdown.create()
  else if (propName = 'group') then result := GroupList.new()
  else if (propName = 'supplementalData') then result := SupplementalDataList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMeasure.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'url') then result := 'uri'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'version') then result := 'string'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'title') then result := 'string'
  else if (propName = 'subtitle') then result := 'string'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'experimental') then result := 'boolean'
  else if (propName = 'subject[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'publisher') then result := 'string'
  else if (propName = 'contact') then result := 'ContactDetail'
  else if (propName = 'description') then result := 'markdown'
  else if (propName = 'useContext') then result := 'UsageContext'
  else if (propName = 'jurisdiction') then result := 'CodeableConcept'
  else if (propName = 'purpose') then result := 'markdown'
  else if (propName = 'usage') then result := 'string'
  else if (propName = 'copyright') then result := 'markdown'
  else if (propName = 'approvalDate') then result := 'date'
  else if (propName = 'lastReviewDate') then result := 'date'
  else if (propName = 'effectivePeriod') then result := 'Period'
  else if (propName = 'topic') then result := 'CodeableConcept'
  else if (propName = 'author') then result := 'ContactDetail'
  else if (propName = 'editor') then result := 'ContactDetail'
  else if (propName = 'reviewer') then result := 'ContactDetail'
  else if (propName = 'endorser') then result := 'ContactDetail'
  else if (propName = 'relatedArtifact') then result := 'RelatedArtifact'
  else if (propName = 'library') then result := 'canonical'
  else if (propName = 'disclaimer') then result := 'markdown'
  else if (propName = 'scoring') then result := 'CodeableConcept'
  else if (propName = 'compositeScoring') then result := 'CodeableConcept'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'riskAdjustment') then result := 'string'
  else if (propName = 'rateAggregation') then result := 'string'
  else if (propName = 'rationale') then result := 'markdown'
  else if (propName = 'clinicalRecommendationStatement') then result := 'markdown'
  else if (propName = 'improvementNotation') then result := 'CodeableConcept'
  else if (propName = 'definition') then result := 'markdown'
  else if (propName = 'guidance') then result := 'markdown'
  else if (propName = 'group') then result := 'BackboneElement'
  else if (propName = 'supplementalData') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMeasure.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := nil
  else if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'version') then VersionElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'title') then TitleElement := nil
  else if (propName = 'subtitle') then SubtitleElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'experimental') then ExperimentalElement := nil
  else if (isMatchingName(propName, 'subject', ['CodeableConcept', 'Reference'])) then SubjectElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'publisher') then PublisherElement := nil
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value)
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'useContext') then deletePropertyValue('useContext', UseContextList, value)
  else if (propName = 'jurisdiction') then deletePropertyValue('jurisdiction', JurisdictionList, value)
  else if (propName = 'purpose') then PurposeElement := nil
  else if (propName = 'usage') then UsageElement := nil
  else if (propName = 'copyright') then CopyrightElement := nil
  else if (propName = 'approvalDate') then ApprovalDateElement := nil
  else if (propName = 'lastReviewDate') then LastReviewDateElement := nil
  else if (propName = 'effectivePeriod') then EffectivePeriodElement := nil
  else if (propName = 'topic') then deletePropertyValue('topic', TopicList, value)
  else if (propName = 'author') then deletePropertyValue('author', AuthorList, value)
  else if (propName = 'editor') then deletePropertyValue('editor', EditorList, value)
  else if (propName = 'reviewer') then deletePropertyValue('reviewer', ReviewerList, value)
  else if (propName = 'endorser') then deletePropertyValue('endorser', EndorserList, value)
  else if (propName = 'relatedArtifact') then deletePropertyValue('relatedArtifact', RelatedArtifactList, value)
  else if (propName = 'library') then deletePropertyValue('library', Library_List, value)
  else if (propName = 'disclaimer') then DisclaimerElement := nil
  else if (propName = 'scoring') then ScoringElement := nil
  else if (propName = 'compositeScoring') then CompositeScoringElement := nil
  else if (propName = 'type') then deletePropertyValue('type', Type_List, value)
  else if (propName = 'riskAdjustment') then RiskAdjustmentElement := nil
  else if (propName = 'rateAggregation') then RateAggregationElement := nil
  else if (propName = 'rationale') then RationaleElement := nil
  else if (propName = 'clinicalRecommendationStatement') then ClinicalRecommendationStatementElement := nil
  else if (propName = 'improvementNotation') then ImprovementNotationElement := nil
  else if (propName = 'definition') then deletePropertyValue('definition', DefinitionList, value)
  else if (propName = 'guidance') then GuidanceElement := nil
  else if (propName = 'group') then deletePropertyValue('group', GroupList, value)
  else if (propName = 'supplementalData') then deletePropertyValue('supplementalData', SupplementalDataList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMeasure.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := asUri(new)
  else if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'version') then VersionElement := asString(new)
  else if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'title') then TitleElement := asString(new)
  else if (propName = 'subtitle') then SubtitleElement := asString(new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, new)
  else if (propName = 'experimental') then ExperimentalElement := asBoolean(new)
  else if (isMatchingName(propName, 'subject', ['CodeableConcept', 'Reference'])) then SubjectElement := new as TFhirDataType
  else if (propName = 'date') then DateElement := asDateTime(new)
  else if (propName = 'publisher') then PublisherElement := asString(new)
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new)
  else if (propName = 'description') then DescriptionElement := asMarkdown(new)
  else if (propName = 'useContext') then replacePropertyValue('useContext', UseContextList, existing, new)
  else if (propName = 'jurisdiction') then replacePropertyValue('jurisdiction', JurisdictionList, existing, new)
  else if (propName = 'purpose') then PurposeElement := asMarkdown(new)
  else if (propName = 'usage') then UsageElement := asString(new)
  else if (propName = 'copyright') then CopyrightElement := asMarkdown(new)
  else if (propName = 'approvalDate') then ApprovalDateElement := asDate(new)
  else if (propName = 'lastReviewDate') then LastReviewDateElement := asDate(new)
  else if (propName = 'effectivePeriod') then EffectivePeriodElement := new as TFhirPeriod
  else if (propName = 'topic') then replacePropertyValue('topic', TopicList, existing, new)
  else if (propName = 'author') then replacePropertyValue('author', AuthorList, existing, new)
  else if (propName = 'editor') then replacePropertyValue('editor', EditorList, existing, new)
  else if (propName = 'reviewer') then replacePropertyValue('reviewer', ReviewerList, existing, new)
  else if (propName = 'endorser') then replacePropertyValue('endorser', EndorserList, existing, new)
  else if (propName = 'relatedArtifact') then replacePropertyValue('relatedArtifact', RelatedArtifactList, existing, new)
  else if (propName = 'library') then replacePropertyValue('library', Library_List, existing, new)
  else if (propName = 'disclaimer') then DisclaimerElement := asMarkdown(new)
  else if (propName = 'scoring') then ScoringElement := new as TFhirCodeableConcept
  else if (propName = 'compositeScoring') then CompositeScoringElement := new as TFhirCodeableConcept
  else if (propName = 'type') then replacePropertyValue('type', Type_List, existing, new)
  else if (propName = 'riskAdjustment') then RiskAdjustmentElement := asString(new)
  else if (propName = 'rateAggregation') then RateAggregationElement := asString(new)
  else if (propName = 'rationale') then RationaleElement := asMarkdown(new)
  else if (propName = 'clinicalRecommendationStatement') then ClinicalRecommendationStatementElement := asMarkdown(new)
  else if (propName = 'improvementNotation') then ImprovementNotationElement := new as TFhirCodeableConcept
  else if (propName = 'definition') then replacePropertyValue('definition', DefinitionList, existing, new)
  else if (propName = 'guidance') then GuidanceElement := asMarkdown(new)
  else if (propName = 'group') then replacePropertyValue('group', GroupList, existing, new)
  else if (propName = 'supplementalData') then replacePropertyValue('supplementalData', SupplementalDataList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMeasure.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'contact') then ContactList.move(source, destination)
  else if (propName = 'useContext') then UseContextList.move(source, destination)
  else if (propName = 'jurisdiction') then JurisdictionList.move(source, destination)
  else if (propName = 'topic') then TopicList.move(source, destination)
  else if (propName = 'author') then AuthorList.move(source, destination)
  else if (propName = 'editor') then EditorList.move(source, destination)
  else if (propName = 'reviewer') then ReviewerList.move(source, destination)
  else if (propName = 'endorser') then EndorserList.move(source, destination)
  else if (propName = 'relatedArtifact') then RelatedArtifactList.move(source, destination)
  else if (propName = 'library') then Library_List.move(source, destination)
  else if (propName = 'type') then Type_List.move(source, destination)
  else if (propName = 'definition') then DefinitionList.move(source, destination)
  else if (propName = 'group') then GroupList.move(source, destination)
  else if (propName = 'supplementalData') then SupplementalDataList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMeasure.fhirType : string;
begin
  result := 'Measure';
end;

function TFhirMeasure.Link : TFhirMeasure;
begin
  result := TFhirMeasure(inherited Link);
end;

function TFhirMeasure.Clone : TFhirMeasure;
begin
  result := TFhirMeasure(inherited Clone);
end;

function TFhirMeasure.equals(other : TObject) : boolean; 
var
  o : TFhirMeasure;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMeasure)) then
    result := false
  else
  begin
    o := TFhirMeasure(other);
    result := compareDeep(urlElement, o.urlElement, true) and compareDeep(identifierList, o.identifierList, true) and 
      compareDeep(versionElement, o.versionElement, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(titleElement, o.titleElement, true) and compareDeep(subtitleElement, o.subtitleElement, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(experimentalElement, o.experimentalElement, true) and 
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(dateElement, o.dateElement, true) and 
      compareDeep(publisherElement, o.publisherElement, true) and compareDeep(contactList, o.contactList, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(useContextList, o.useContextList, true) and 
      compareDeep(jurisdictionList, o.jurisdictionList, true) and compareDeep(purposeElement, o.purposeElement, true) and 
      compareDeep(usageElement, o.usageElement, true) and compareDeep(copyrightElement, o.copyrightElement, true) and 
      compareDeep(approvalDateElement, o.approvalDateElement, true) and compareDeep(lastReviewDateElement, o.lastReviewDateElement, true) and 
      compareDeep(effectivePeriodElement, o.effectivePeriodElement, true) and compareDeep(topicList, o.topicList, true) and 
      compareDeep(authorList, o.authorList, true) and compareDeep(editorList, o.editorList, true) and 
      compareDeep(reviewerList, o.reviewerList, true) and compareDeep(endorserList, o.endorserList, true) and 
      compareDeep(relatedArtifactList, o.relatedArtifactList, true) and compareDeep(library_List, o.library_List, true) and 
      compareDeep(disclaimerElement, o.disclaimerElement, true) and compareDeep(scoringElement, o.scoringElement, true) and 
      compareDeep(compositeScoringElement, o.compositeScoringElement, true) and compareDeep(type_List, o.type_List, true) and 
      compareDeep(riskAdjustmentElement, o.riskAdjustmentElement, true) and compareDeep(rateAggregationElement, o.rateAggregationElement, true) and 
      compareDeep(rationaleElement, o.rationaleElement, true) and compareDeep(clinicalRecommendationStatementElement, o.clinicalRecommendationStatementElement, true) and 
      compareDeep(improvementNotationElement, o.improvementNotationElement, true) and 
      compareDeep(definitionList, o.definitionList, true) and compareDeep(guidanceElement, o.guidanceElement, true) and 
      compareDeep(groupList, o.groupList, true) and compareDeep(supplementalDataList, o.supplementalDataList, true);
  end;
end;

function TFhirMeasure.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FUrl) and isEmptyProp(FidentifierList) and isEmptyProp(FVersion) and isEmptyProp(FName) and isEmptyProp(FTitle) and isEmptyProp(FSubtitle) and isEmptyProp(FStatus) and isEmptyProp(FExperimental) and isEmptyProp(FSubject) and isEmptyProp(FDate) and isEmptyProp(FPublisher) and isEmptyProp(FcontactList) and isEmptyProp(FDescription) and isEmptyProp(FuseContextList) and isEmptyProp(FjurisdictionList) and isEmptyProp(FPurpose) and isEmptyProp(FUsage) and isEmptyProp(FCopyright) and isEmptyProp(FApprovalDate) and isEmptyProp(FLastReviewDate) and isEmptyProp(FEffectivePeriod) and isEmptyProp(FtopicList) and isEmptyProp(FauthorList) and isEmptyProp(FeditorList) and isEmptyProp(FreviewerList) and isEmptyProp(FendorserList) and isEmptyProp(FrelatedArtifactList) and isEmptyProp(Flibrary_List) and isEmptyProp(FDisclaimer) and isEmptyProp(FScoring) and isEmptyProp(FCompositeScoring) and isEmptyProp(Ftype_List) and isEmptyProp(FRiskAdjustment)
       and isEmptyProp(FRateAggregation) and isEmptyProp(FRationale) and isEmptyProp(FClinicalRecommendationStatement) and isEmptyProp(FImprovementNotation) and isEmptyProp(FdefinitionList) and isEmptyProp(FGuidance) and isEmptyProp(FgroupList) and isEmptyProp(FsupplementalDataList);
end;

procedure TFhirMeasure.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('url');
  fields.add('identifier');
  fields.add('version');
  fields.add('name');
  fields.add('title');
  fields.add('subtitle');
  fields.add('status');
  fields.add('experimental');
  fields.add('subject[x]');
  fields.add('date');
  fields.add('publisher');
  fields.add('contact');
  fields.add('description');
  fields.add('useContext');
  fields.add('jurisdiction');
  fields.add('purpose');
  fields.add('usage');
  fields.add('copyright');
  fields.add('approvalDate');
  fields.add('lastReviewDate');
  fields.add('effectivePeriod');
  fields.add('topic');
  fields.add('author');
  fields.add('editor');
  fields.add('reviewer');
  fields.add('endorser');
  fields.add('relatedArtifact');
  fields.add('library');
  fields.add('disclaimer');
  fields.add('scoring');
  fields.add('compositeScoring');
  fields.add('type');
  fields.add('riskAdjustment');
  fields.add('rateAggregation');
  fields.add('rationale');
  fields.add('clinicalRecommendationStatement');
  fields.add('improvementNotation');
  fields.add('definition');
  fields.add('guidance');
  fields.add('group');
  fields.add('supplementalData');
end;

function TFhirMeasure.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FContactList.sizeInBytes(magic));
  inc(result, FUseContextList.sizeInBytes(magic));
  inc(result, FJurisdictionList.sizeInBytes(magic));
  inc(result, FTopicList.sizeInBytes(magic));
  inc(result, FAuthorList.sizeInBytes(magic));
  inc(result, FEditorList.sizeInBytes(magic));
  inc(result, FReviewerList.sizeInBytes(magic));
  inc(result, FEndorserList.sizeInBytes(magic));
  inc(result, FRelatedArtifactList.sizeInBytes(magic));
  inc(result, FLibrary_List.sizeInBytes(magic));
  inc(result, FType_List.sizeInBytes(magic));
  inc(result, FDefinitionList.sizeInBytes(magic));
  inc(result, FGroupList.sizeInBytes(magic));
  inc(result, FSupplementalDataList.sizeInBytes(magic));
end;

procedure TFhirMeasure.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

function TFhirMeasure.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

procedure TFhirMeasure.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

function TFhirMeasure.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirMeasure.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirMeasure.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

function TFhirMeasure.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

procedure TFhirMeasure.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

procedure TFhirMeasure.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirMeasure.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirMeasure.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirMeasure.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

function TFhirMeasure.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

procedure TFhirMeasure.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

procedure TFhirMeasure.SetSubtitle(value : TFhirString);
begin
  FSubtitle.free;
  FSubtitle := value;
end;

function TFhirMeasure.GetSubtitleST : String;
begin
  if FSubtitle = nil then
    result := ''
  else
    result := FSubtitle.value;
end;

procedure TFhirMeasure.SetSubtitleST(value : String);
begin
  if value <> '' then
  begin
    if FSubtitle = nil then
      FSubtitle := TFhirString.create;
    FSubtitle.value := value
  end
  else if FSubtitle <> nil then
    FSubtitle.value := '';
end;

procedure TFhirMeasure.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirMeasure.GetStatusST : TFhirPublicationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirPublicationStatusEnum(0)
  else
    result := TFhirPublicationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirPublicationStatusEnum, FStatus.value));
end;

procedure TFhirMeasure.SetStatusST(value : TFhirPublicationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[value], CODES_TFhirPublicationStatusEnum[value]);
end;

procedure TFhirMeasure.SetExperimental(value : TFhirBoolean);
begin
  FExperimental.free;
  FExperimental := value;
end;

function TFhirMeasure.GetExperimentalST : Boolean;
begin
  if FExperimental = nil then
    result := false
  else
    result := FExperimental.value;
end;

procedure TFhirMeasure.SetExperimentalST(value : Boolean);
begin
  if FExperimental = nil then
    FExperimental := TFhirBoolean.create;
  FExperimental.value := value
end;

procedure TFhirMeasure.SetSubject(value : TFhirDataType);
begin
  FSubject.free;
  FSubject := value;
end;

procedure TFhirMeasure.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

function TFhirMeasure.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirMeasure.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

procedure TFhirMeasure.SetPublisher(value : TFhirString);
begin
  FPublisher.free;
  FPublisher := value;
end;

function TFhirMeasure.GetPublisherST : String;
begin
  if FPublisher = nil then
    result := ''
  else
    result := FPublisher.value;
end;

procedure TFhirMeasure.SetPublisherST(value : String);
begin
  if value <> '' then
  begin
    if FPublisher = nil then
      FPublisher := TFhirString.create;
    FPublisher.value := value
  end
  else if FPublisher <> nil then
    FPublisher.value := '';
end;

function TFhirMeasure.GetContactList : TFhirContactDetailList;
begin
  if FContactList = nil then
    FContactList := TFhirContactDetailList.Create;
  result := FContactList;
end;

function TFhirMeasure.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

procedure TFhirMeasure.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirMeasure.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirMeasure.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirMeasure.GetUseContextList : TFhirUsageContextList;
begin
  if FUseContextList = nil then
    FUseContextList := TFhirUsageContextList.Create;
  result := FUseContextList;
end;

function TFhirMeasure.GetHasUseContextList : boolean;
begin
  result := (FUseContextList <> nil) and (FUseContextList.count > 0);
end;

function TFhirMeasure.GetJurisdictionList : TFhirCodeableConceptList;
begin
  if FJurisdictionList = nil then
    FJurisdictionList := TFhirCodeableConceptList.Create;
  result := FJurisdictionList;
end;

function TFhirMeasure.GetHasJurisdictionList : boolean;
begin
  result := (FJurisdictionList <> nil) and (FJurisdictionList.count > 0);
end;

procedure TFhirMeasure.SetPurpose(value : TFhirMarkdown);
begin
  FPurpose.free;
  FPurpose := value;
end;

function TFhirMeasure.GetPurposeST : String;
begin
  if FPurpose = nil then
    result := ''
  else
    result := FPurpose.value;
end;

procedure TFhirMeasure.SetPurposeST(value : String);
begin
  if value <> '' then
  begin
    if FPurpose = nil then
      FPurpose := TFhirMarkdown.create;
    FPurpose.value := value
  end
  else if FPurpose <> nil then
    FPurpose.value := '';
end;

procedure TFhirMeasure.SetUsage(value : TFhirString);
begin
  FUsage.free;
  FUsage := value;
end;

function TFhirMeasure.GetUsageST : String;
begin
  if FUsage = nil then
    result := ''
  else
    result := FUsage.value;
end;

procedure TFhirMeasure.SetUsageST(value : String);
begin
  if value <> '' then
  begin
    if FUsage = nil then
      FUsage := TFhirString.create;
    FUsage.value := value
  end
  else if FUsage <> nil then
    FUsage.value := '';
end;

procedure TFhirMeasure.SetCopyright(value : TFhirMarkdown);
begin
  FCopyright.free;
  FCopyright := value;
end;

function TFhirMeasure.GetCopyrightST : String;
begin
  if FCopyright = nil then
    result := ''
  else
    result := FCopyright.value;
end;

procedure TFhirMeasure.SetCopyrightST(value : String);
begin
  if value <> '' then
  begin
    if FCopyright = nil then
      FCopyright := TFhirMarkdown.create;
    FCopyright.value := value
  end
  else if FCopyright <> nil then
    FCopyright.value := '';
end;

procedure TFhirMeasure.SetApprovalDate(value : TFhirDate);
begin
  FApprovalDate.free;
  FApprovalDate := value;
end;

function TFhirMeasure.GetApprovalDateST : TFslDateTime;
begin
  if FApprovalDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FApprovalDate.value;
end;

procedure TFhirMeasure.SetApprovalDateST(value : TFslDateTime);
begin
  if FApprovalDate = nil then
    FApprovalDate := TFhirDate.create;
  FApprovalDate.value := value
end;

procedure TFhirMeasure.SetLastReviewDate(value : TFhirDate);
begin
  FLastReviewDate.free;
  FLastReviewDate := value;
end;

function TFhirMeasure.GetLastReviewDateST : TFslDateTime;
begin
  if FLastReviewDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FLastReviewDate.value;
end;

procedure TFhirMeasure.SetLastReviewDateST(value : TFslDateTime);
begin
  if FLastReviewDate = nil then
    FLastReviewDate := TFhirDate.create;
  FLastReviewDate.value := value
end;

procedure TFhirMeasure.SetEffectivePeriod(value : TFhirPeriod);
begin
  FEffectivePeriod.free;
  FEffectivePeriod := value;
end;

function TFhirMeasure.GetTopicList : TFhirCodeableConceptList;
begin
  if FTopicList = nil then
    FTopicList := TFhirCodeableConceptList.Create;
  result := FTopicList;
end;

function TFhirMeasure.GetHasTopicList : boolean;
begin
  result := (FTopicList <> nil) and (FTopicList.count > 0);
end;

function TFhirMeasure.GetAuthorList : TFhirContactDetailList;
begin
  if FAuthorList = nil then
    FAuthorList := TFhirContactDetailList.Create;
  result := FAuthorList;
end;

function TFhirMeasure.GetHasAuthorList : boolean;
begin
  result := (FAuthorList <> nil) and (FAuthorList.count > 0);
end;

function TFhirMeasure.GetEditorList : TFhirContactDetailList;
begin
  if FEditorList = nil then
    FEditorList := TFhirContactDetailList.Create;
  result := FEditorList;
end;

function TFhirMeasure.GetHasEditorList : boolean;
begin
  result := (FEditorList <> nil) and (FEditorList.count > 0);
end;

function TFhirMeasure.GetReviewerList : TFhirContactDetailList;
begin
  if FReviewerList = nil then
    FReviewerList := TFhirContactDetailList.Create;
  result := FReviewerList;
end;

function TFhirMeasure.GetHasReviewerList : boolean;
begin
  result := (FReviewerList <> nil) and (FReviewerList.count > 0);
end;

function TFhirMeasure.GetEndorserList : TFhirContactDetailList;
begin
  if FEndorserList = nil then
    FEndorserList := TFhirContactDetailList.Create;
  result := FEndorserList;
end;

function TFhirMeasure.GetHasEndorserList : boolean;
begin
  result := (FEndorserList <> nil) and (FEndorserList.count > 0);
end;

function TFhirMeasure.GetRelatedArtifactList : TFhirRelatedArtifactList;
begin
  if FRelatedArtifactList = nil then
    FRelatedArtifactList := TFhirRelatedArtifactList.Create;
  result := FRelatedArtifactList;
end;

function TFhirMeasure.GetHasRelatedArtifactList : boolean;
begin
  result := (FRelatedArtifactList <> nil) and (FRelatedArtifactList.count > 0);
end;

function TFhirMeasure.GetLibrary_List : TFhirCanonicalList;
begin
  if FLibrary_List = nil then
    FLibrary_List := TFhirCanonicalList.Create;
  result := FLibrary_List;
end;

function TFhirMeasure.GetHasLibrary_List : boolean;
begin
  result := (FLibrary_List <> nil) and (FLibrary_List.count > 0);
end;

procedure TFhirMeasure.SetDisclaimer(value : TFhirMarkdown);
begin
  FDisclaimer.free;
  FDisclaimer := value;
end;

function TFhirMeasure.GetDisclaimerST : String;
begin
  if FDisclaimer = nil then
    result := ''
  else
    result := FDisclaimer.value;
end;

procedure TFhirMeasure.SetDisclaimerST(value : String);
begin
  if value <> '' then
  begin
    if FDisclaimer = nil then
      FDisclaimer := TFhirMarkdown.create;
    FDisclaimer.value := value
  end
  else if FDisclaimer <> nil then
    FDisclaimer.value := '';
end;

procedure TFhirMeasure.SetScoring(value : TFhirCodeableConcept);
begin
  FScoring.free;
  FScoring := value;
end;

procedure TFhirMeasure.SetCompositeScoring(value : TFhirCodeableConcept);
begin
  FCompositeScoring.free;
  FCompositeScoring := value;
end;

function TFhirMeasure.GetType_List : TFhirCodeableConceptList;
begin
  if FType_List = nil then
    FType_List := TFhirCodeableConceptList.Create;
  result := FType_List;
end;

function TFhirMeasure.GetHasType_List : boolean;
begin
  result := (FType_List <> nil) and (FType_List.count > 0);
end;

procedure TFhirMeasure.SetRiskAdjustment(value : TFhirString);
begin
  FRiskAdjustment.free;
  FRiskAdjustment := value;
end;

function TFhirMeasure.GetRiskAdjustmentST : String;
begin
  if FRiskAdjustment = nil then
    result := ''
  else
    result := FRiskAdjustment.value;
end;

procedure TFhirMeasure.SetRiskAdjustmentST(value : String);
begin
  if value <> '' then
  begin
    if FRiskAdjustment = nil then
      FRiskAdjustment := TFhirString.create;
    FRiskAdjustment.value := value
  end
  else if FRiskAdjustment <> nil then
    FRiskAdjustment.value := '';
end;

procedure TFhirMeasure.SetRateAggregation(value : TFhirString);
begin
  FRateAggregation.free;
  FRateAggregation := value;
end;

function TFhirMeasure.GetRateAggregationST : String;
begin
  if FRateAggregation = nil then
    result := ''
  else
    result := FRateAggregation.value;
end;

procedure TFhirMeasure.SetRateAggregationST(value : String);
begin
  if value <> '' then
  begin
    if FRateAggregation = nil then
      FRateAggregation := TFhirString.create;
    FRateAggregation.value := value
  end
  else if FRateAggregation <> nil then
    FRateAggregation.value := '';
end;

procedure TFhirMeasure.SetRationale(value : TFhirMarkdown);
begin
  FRationale.free;
  FRationale := value;
end;

function TFhirMeasure.GetRationaleST : String;
begin
  if FRationale = nil then
    result := ''
  else
    result := FRationale.value;
end;

procedure TFhirMeasure.SetRationaleST(value : String);
begin
  if value <> '' then
  begin
    if FRationale = nil then
      FRationale := TFhirMarkdown.create;
    FRationale.value := value
  end
  else if FRationale <> nil then
    FRationale.value := '';
end;

procedure TFhirMeasure.SetClinicalRecommendationStatement(value : TFhirMarkdown);
begin
  FClinicalRecommendationStatement.free;
  FClinicalRecommendationStatement := value;
end;

function TFhirMeasure.GetClinicalRecommendationStatementST : String;
begin
  if FClinicalRecommendationStatement = nil then
    result := ''
  else
    result := FClinicalRecommendationStatement.value;
end;

procedure TFhirMeasure.SetClinicalRecommendationStatementST(value : String);
begin
  if value <> '' then
  begin
    if FClinicalRecommendationStatement = nil then
      FClinicalRecommendationStatement := TFhirMarkdown.create;
    FClinicalRecommendationStatement.value := value
  end
  else if FClinicalRecommendationStatement <> nil then
    FClinicalRecommendationStatement.value := '';
end;

procedure TFhirMeasure.SetImprovementNotation(value : TFhirCodeableConcept);
begin
  FImprovementNotation.free;
  FImprovementNotation := value;
end;

function TFhirMeasure.GetDefinitionList : TFhirMarkdownList;
begin
  if FDefinitionList = nil then
    FDefinitionList := TFhirMarkdownList.Create;
  result := FDefinitionList;
end;

function TFhirMeasure.GetHasDefinitionList : boolean;
begin
  result := (FDefinitionList <> nil) and (FDefinitionList.count > 0);
end;

procedure TFhirMeasure.SetGuidance(value : TFhirMarkdown);
begin
  FGuidance.free;
  FGuidance := value;
end;

function TFhirMeasure.GetGuidanceST : String;
begin
  if FGuidance = nil then
    result := ''
  else
    result := FGuidance.value;
end;

procedure TFhirMeasure.SetGuidanceST(value : String);
begin
  if value <> '' then
  begin
    if FGuidance = nil then
      FGuidance := TFhirMarkdown.create;
    FGuidance.value := value
  end
  else if FGuidance <> nil then
    FGuidance.value := '';
end;

function TFhirMeasure.GetGroupList : TFhirMeasureGroupList;
begin
  if FGroupList = nil then
    FGroupList := TFhirMeasureGroupList.Create;
  result := FGroupList;
end;

function TFhirMeasure.GetHasGroupList : boolean;
begin
  result := (FGroupList <> nil) and (FGroupList.count > 0);
end;

function TFhirMeasure.GetSupplementalDataList : TFhirMeasureSupplementalDataList;
begin
  if FSupplementalDataList = nil then
    FSupplementalDataList := TFhirMeasureSupplementalDataList.Create;
  result := FSupplementalDataList;
end;

function TFhirMeasure.GetHasSupplementalDataList : boolean;
begin
  result := (FSupplementalDataList <> nil) and (FSupplementalDataList.count > 0);
end;

{ TFhirMeasureListEnumerator }

constructor TFhirMeasureListEnumerator.Create(list : TFhirMeasureList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMeasureListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMeasureListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMeasureListEnumerator.GetCurrent : TFhirMeasure;
begin
  Result := FList[FIndex];
end;

function TFhirMeasureListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMeasureList }

function TFhirMeasureList.AddItem(value: TFhirMeasure): TFhirMeasure;
begin
  assert(value.ClassName = 'TFhirMeasure', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMeasure');
  add(value);
  result := value;
end;

function TFhirMeasureList.Append: TFhirMeasure;
begin
  result := TFhirMeasure.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureList.ClearItems;
begin
  Clear;
end;

function TFhirMeasureList.GetEnumerator : TFhirMeasureListEnumerator;
begin
  result := TFhirMeasureListEnumerator.Create(self.link);
end;

function TFhirMeasureList.Clone: TFhirMeasureList;
begin
  result := TFhirMeasureList(inherited Clone);
end;

function TFhirMeasureList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMeasureList.GetItemN(index: Integer): TFhirMeasure;
begin
  result := TFhirMeasure(ObjectByIndex[index]);
end;

function TFhirMeasureList.ItemClass: TFslObjectClass;
begin
  result := TFhirMeasure;
end;
function TFhirMeasureList.IndexOf(value: TFhirMeasure): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMeasureList.Insert(index: Integer): TFhirMeasure;
begin
  result := TFhirMeasure.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureList.InsertItem(index: Integer; value: TFhirMeasure);
begin
  assert(value is TFhirMeasure);
  Inherited Insert(index, value);
end;

function TFhirMeasureList.Item(index: Integer): TFhirMeasure;
begin
  result := TFhirMeasure(ObjectByIndex[index]);
end;

function TFhirMeasureList.Link: TFhirMeasureList;
begin
  result := TFhirMeasureList(inherited Link);
end;

procedure TFhirMeasureList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMeasureList.SetItemByIndex(index: Integer; value: TFhirMeasure);
begin
  assert(value is TFhirMeasure);
  FhirMeasures[index] := value;
end;

procedure TFhirMeasureList.SetItemN(index: Integer; value: TFhirMeasure);
begin
  assert(value is TFhirMeasure);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_MEASURE}
{$IFDEF FHIR_MESSAGEDEFINITION}
{ TFhirMessageDefinitionFocus }

constructor TFhirMessageDefinitionFocus.Create;
begin
  inherited;
end;

destructor TFhirMessageDefinitionFocus.Destroy;
begin
  FCode.free;
  FProfile.free;
  FMin.free;
  FMax.free;
  inherited;
end;

procedure TFhirMessageDefinitionFocus.Assign(oSource : TFslObject);
begin
  inherited;
  codeElement := TFhirMessageDefinitionFocus(oSource).codeElement.Clone;
  profileElement := TFhirMessageDefinitionFocus(oSource).profileElement.Clone;
  minElement := TFhirMessageDefinitionFocus(oSource).minElement.Clone;
  maxElement := TFhirMessageDefinitionFocus(oSource).maxElement.Clone;
end;

procedure TFhirMessageDefinitionFocus.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'profile') Then
     list.add(self.link, 'profile', FProfile.Link);
  if (child_name = 'min') Then
     list.add(self.link, 'min', FMin.Link);
  if (child_name = 'max') Then
     list.add(self.link, 'max', FMax.Link);
end;

procedure TFhirMessageDefinitionFocus.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'code', false, TFhirEnum, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'profile', 'canonical', false, TFhirCanonical, FProfile.Link));
  oList.add(TFHIRProperty.create(self, 'min', 'unsignedInt', false, TFhirUnsignedInt, FMin.Link));
  oList.add(TFHIRProperty.create(self, 'max', 'string', false, TFhirString, FMax.Link));
end;

function TFhirMessageDefinitionFocus.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    CodeElement := asEnum(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum, propValue);
    result := propValue;
  end
  else if (propName = 'profile') then
  begin
    ProfileElement := asCanonical(propValue);
    result := propValue;
  end
  else if (propName = 'min') then
  begin
    MinElement := asUnsignedInt(propValue);
    result := propValue;
  end
  else if (propName = 'max') then
  begin
    MaxElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMessageDefinitionFocus.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMessageDefinitionFocus.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirEnum.create(SYSTEMS_TFhirResourceTypesEnum[ResourceTypesNull], CODES_TFhirResourceTypesEnum[ResourceTypesNull]) 
  else if (propName = 'profile') then result := TFhirCanonical.create()
  else if (propName = 'min') then result := TFhirUnsignedInt.create()
  else if (propName = 'max') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMessageDefinitionFocus.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'code'
  else if (propName = 'profile') then result := 'canonical'
  else if (propName = 'min') then result := 'unsignedInt'
  else if (propName = 'max') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMessageDefinitionFocus.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'profile') then ProfileElement := nil
  else if (propName = 'min') then MinElement := nil
  else if (propName = 'max') then MaxElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMessageDefinitionFocus.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := asEnum(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum, new)
  else if (propName = 'profile') then ProfileElement := asCanonical(new)
  else if (propName = 'min') then MinElement := asUnsignedInt(new)
  else if (propName = 'max') then MaxElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMessageDefinitionFocus.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMessageDefinitionFocus.fhirType : string;
begin
  result := 'MessageDefinition.focus';
end;

function TFhirMessageDefinitionFocus.Link : TFhirMessageDefinitionFocus;
begin
  result := TFhirMessageDefinitionFocus(inherited Link);
end;

function TFhirMessageDefinitionFocus.Clone : TFhirMessageDefinitionFocus;
begin
  result := TFhirMessageDefinitionFocus(inherited Clone);
end;

function TFhirMessageDefinitionFocus.equals(other : TObject) : boolean; 
var
  o : TFhirMessageDefinitionFocus;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMessageDefinitionFocus)) then
    result := false
  else
  begin
    o := TFhirMessageDefinitionFocus(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(profileElement, o.profileElement, true) and 
      compareDeep(minElement, o.minElement, true) and compareDeep(maxElement, o.maxElement, true);
  end;
end;

function TFhirMessageDefinitionFocus.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FProfile) and isEmptyProp(FMin) and isEmptyProp(FMax);
end;

procedure TFhirMessageDefinitionFocus.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('code');
  fields.add('profile');
  fields.add('min');
  fields.add('max');
end;

function TFhirMessageDefinitionFocus.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirMessageDefinitionFocus.SetCode(value : TFhirEnum);
begin
  FCode.free;
  FCode := value;
end;

function TFhirMessageDefinitionFocus.GetCodeST : TFhirResourceTypesEnum;
begin
  if FCode = nil then
    result := TFhirResourceTypesEnum(0)
  else
    result := TFhirResourceTypesEnum(StringArrayIndexOfSensitive(CODES_TFhirResourceTypesEnum, FCode.value));
end;

procedure TFhirMessageDefinitionFocus.SetCodeST(value : TFhirResourceTypesEnum);
begin
  if ord(value) = 0 then
    CodeElement := nil
  else
    CodeElement := TFhirEnum.create(SYSTEMS_TFhirResourceTypesEnum[value], CODES_TFhirResourceTypesEnum[value]);
end;

procedure TFhirMessageDefinitionFocus.SetProfile(value : TFhirCanonical);
begin
  FProfile.free;
  FProfile := value;
end;

function TFhirMessageDefinitionFocus.GetProfileST : String;
begin
  if FProfile = nil then
    result := ''
  else
    result := FProfile.value;
end;

procedure TFhirMessageDefinitionFocus.SetProfileST(value : String);
begin
  if value <> '' then
  begin
    if FProfile = nil then
      FProfile := TFhirCanonical.create;
    FProfile.value := value
  end
  else if FProfile <> nil then
    FProfile.value := '';
end;

procedure TFhirMessageDefinitionFocus.SetMin(value : TFhirUnsignedInt);
begin
  FMin.free;
  FMin := value;
end;

function TFhirMessageDefinitionFocus.GetMinST : String;
begin
  if FMin = nil then
    result := ''
  else
    result := FMin.value;
end;

procedure TFhirMessageDefinitionFocus.SetMinST(value : String);
begin
  if value <> '' then
  begin
    if FMin = nil then
      FMin := TFhirUnsignedInt.create;
    FMin.value := value
  end
  else if FMin <> nil then
    FMin.value := '';
end;

procedure TFhirMessageDefinitionFocus.SetMax(value : TFhirString);
begin
  FMax.free;
  FMax := value;
end;

function TFhirMessageDefinitionFocus.GetMaxST : String;
begin
  if FMax = nil then
    result := ''
  else
    result := FMax.value;
end;

procedure TFhirMessageDefinitionFocus.SetMaxST(value : String);
begin
  if value <> '' then
  begin
    if FMax = nil then
      FMax := TFhirString.create;
    FMax.value := value
  end
  else if FMax <> nil then
    FMax.value := '';
end;

{ TFhirMessageDefinitionFocusListEnumerator }

constructor TFhirMessageDefinitionFocusListEnumerator.Create(list : TFhirMessageDefinitionFocusList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMessageDefinitionFocusListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMessageDefinitionFocusListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMessageDefinitionFocusListEnumerator.GetCurrent : TFhirMessageDefinitionFocus;
begin
  Result := FList[FIndex];
end;

function TFhirMessageDefinitionFocusListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMessageDefinitionFocusList }

function TFhirMessageDefinitionFocusList.AddItem(value: TFhirMessageDefinitionFocus): TFhirMessageDefinitionFocus;
begin
  assert(value.ClassName = 'TFhirMessageDefinitionFocus', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMessageDefinitionFocus');
  add(value);
  result := value;
end;

function TFhirMessageDefinitionFocusList.Append: TFhirMessageDefinitionFocus;
begin
  result := TFhirMessageDefinitionFocus.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMessageDefinitionFocusList.ClearItems;
begin
  Clear;
end;

function TFhirMessageDefinitionFocusList.GetEnumerator : TFhirMessageDefinitionFocusListEnumerator;
begin
  result := TFhirMessageDefinitionFocusListEnumerator.Create(self.link);
end;

function TFhirMessageDefinitionFocusList.Clone: TFhirMessageDefinitionFocusList;
begin
  result := TFhirMessageDefinitionFocusList(inherited Clone);
end;

function TFhirMessageDefinitionFocusList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMessageDefinitionFocusList.GetItemN(index: Integer): TFhirMessageDefinitionFocus;
begin
  result := TFhirMessageDefinitionFocus(ObjectByIndex[index]);
end;

function TFhirMessageDefinitionFocusList.ItemClass: TFslObjectClass;
begin
  result := TFhirMessageDefinitionFocus;
end;
function TFhirMessageDefinitionFocusList.IndexOf(value: TFhirMessageDefinitionFocus): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMessageDefinitionFocusList.Insert(index: Integer): TFhirMessageDefinitionFocus;
begin
  result := TFhirMessageDefinitionFocus.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMessageDefinitionFocusList.InsertItem(index: Integer; value: TFhirMessageDefinitionFocus);
begin
  assert(value is TFhirMessageDefinitionFocus);
  Inherited Insert(index, value);
end;

function TFhirMessageDefinitionFocusList.Item(index: Integer): TFhirMessageDefinitionFocus;
begin
  result := TFhirMessageDefinitionFocus(ObjectByIndex[index]);
end;

function TFhirMessageDefinitionFocusList.Link: TFhirMessageDefinitionFocusList;
begin
  result := TFhirMessageDefinitionFocusList(inherited Link);
end;

procedure TFhirMessageDefinitionFocusList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMessageDefinitionFocusList.SetItemByIndex(index: Integer; value: TFhirMessageDefinitionFocus);
begin
  assert(value is TFhirMessageDefinitionFocus);
  FhirMessageDefinitionFocus[index] := value;
end;

procedure TFhirMessageDefinitionFocusList.SetItemN(index: Integer; value: TFhirMessageDefinitionFocus);
begin
  assert(value is TFhirMessageDefinitionFocus);
  ObjectByIndex[index] := value;
end;

{ TFhirMessageDefinitionAllowedResponse }

constructor TFhirMessageDefinitionAllowedResponse.Create;
begin
  inherited;
end;

destructor TFhirMessageDefinitionAllowedResponse.Destroy;
begin
  FMessage.free;
  FSituation.free;
  inherited;
end;

procedure TFhirMessageDefinitionAllowedResponse.Assign(oSource : TFslObject);
begin
  inherited;
  messageElement := TFhirMessageDefinitionAllowedResponse(oSource).messageElement.Clone;
  situationElement := TFhirMessageDefinitionAllowedResponse(oSource).situationElement.Clone;
end;

procedure TFhirMessageDefinitionAllowedResponse.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'message') Then
     list.add(self.link, 'message', FMessage.Link);
  if (child_name = 'situation') Then
     list.add(self.link, 'situation', FSituation.Link);
end;

procedure TFhirMessageDefinitionAllowedResponse.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'message', 'canonical', false, TFhirCanonical, FMessage.Link));
  oList.add(TFHIRProperty.create(self, 'situation', 'markdown', false, TFhirMarkdown, FSituation.Link));
end;

function TFhirMessageDefinitionAllowedResponse.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'message') then
  begin
    MessageElement := asCanonical(propValue);
    result := propValue;
  end
  else if (propName = 'situation') then
  begin
    SituationElement := asMarkdown(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMessageDefinitionAllowedResponse.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMessageDefinitionAllowedResponse.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'message') then result := TFhirCanonical.create()
  else if (propName = 'situation') then result := TFhirMarkdown.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMessageDefinitionAllowedResponse.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'message') then result := 'canonical'
  else if (propName = 'situation') then result := 'markdown'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMessageDefinitionAllowedResponse.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'message') then MessageElement := nil
  else if (propName = 'situation') then SituationElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMessageDefinitionAllowedResponse.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'message') then MessageElement := asCanonical(new)
  else if (propName = 'situation') then SituationElement := asMarkdown(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMessageDefinitionAllowedResponse.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMessageDefinitionAllowedResponse.fhirType : string;
begin
  result := 'MessageDefinition.allowedResponse';
end;

function TFhirMessageDefinitionAllowedResponse.Link : TFhirMessageDefinitionAllowedResponse;
begin
  result := TFhirMessageDefinitionAllowedResponse(inherited Link);
end;

function TFhirMessageDefinitionAllowedResponse.Clone : TFhirMessageDefinitionAllowedResponse;
begin
  result := TFhirMessageDefinitionAllowedResponse(inherited Clone);
end;

function TFhirMessageDefinitionAllowedResponse.equals(other : TObject) : boolean; 
var
  o : TFhirMessageDefinitionAllowedResponse;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMessageDefinitionAllowedResponse)) then
    result := false
  else
  begin
    o := TFhirMessageDefinitionAllowedResponse(other);
    result := compareDeep(messageElement, o.messageElement, true) and compareDeep(situationElement, o.situationElement, true);
  end;
end;

function TFhirMessageDefinitionAllowedResponse.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FMessage) and isEmptyProp(FSituation);
end;

procedure TFhirMessageDefinitionAllowedResponse.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('message');
  fields.add('situation');
end;

function TFhirMessageDefinitionAllowedResponse.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirMessageDefinitionAllowedResponse.SetMessage(value : TFhirCanonical);
begin
  FMessage.free;
  FMessage := value;
end;

function TFhirMessageDefinitionAllowedResponse.GetMessageST : String;
begin
  if FMessage = nil then
    result := ''
  else
    result := FMessage.value;
end;

procedure TFhirMessageDefinitionAllowedResponse.SetMessageST(value : String);
begin
  if value <> '' then
  begin
    if FMessage = nil then
      FMessage := TFhirCanonical.create;
    FMessage.value := value
  end
  else if FMessage <> nil then
    FMessage.value := '';
end;

procedure TFhirMessageDefinitionAllowedResponse.SetSituation(value : TFhirMarkdown);
begin
  FSituation.free;
  FSituation := value;
end;

function TFhirMessageDefinitionAllowedResponse.GetSituationST : String;
begin
  if FSituation = nil then
    result := ''
  else
    result := FSituation.value;
end;

procedure TFhirMessageDefinitionAllowedResponse.SetSituationST(value : String);
begin
  if value <> '' then
  begin
    if FSituation = nil then
      FSituation := TFhirMarkdown.create;
    FSituation.value := value
  end
  else if FSituation <> nil then
    FSituation.value := '';
end;

{ TFhirMessageDefinitionAllowedResponseListEnumerator }

constructor TFhirMessageDefinitionAllowedResponseListEnumerator.Create(list : TFhirMessageDefinitionAllowedResponseList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMessageDefinitionAllowedResponseListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMessageDefinitionAllowedResponseListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMessageDefinitionAllowedResponseListEnumerator.GetCurrent : TFhirMessageDefinitionAllowedResponse;
begin
  Result := FList[FIndex];
end;

function TFhirMessageDefinitionAllowedResponseListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMessageDefinitionAllowedResponseList }

function TFhirMessageDefinitionAllowedResponseList.AddItem(value: TFhirMessageDefinitionAllowedResponse): TFhirMessageDefinitionAllowedResponse;
begin
  assert(value.ClassName = 'TFhirMessageDefinitionAllowedResponse', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMessageDefinitionAllowedResponse');
  add(value);
  result := value;
end;

function TFhirMessageDefinitionAllowedResponseList.Append: TFhirMessageDefinitionAllowedResponse;
begin
  result := TFhirMessageDefinitionAllowedResponse.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMessageDefinitionAllowedResponseList.ClearItems;
begin
  Clear;
end;

function TFhirMessageDefinitionAllowedResponseList.GetEnumerator : TFhirMessageDefinitionAllowedResponseListEnumerator;
begin
  result := TFhirMessageDefinitionAllowedResponseListEnumerator.Create(self.link);
end;

function TFhirMessageDefinitionAllowedResponseList.Clone: TFhirMessageDefinitionAllowedResponseList;
begin
  result := TFhirMessageDefinitionAllowedResponseList(inherited Clone);
end;

function TFhirMessageDefinitionAllowedResponseList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMessageDefinitionAllowedResponseList.GetItemN(index: Integer): TFhirMessageDefinitionAllowedResponse;
begin
  result := TFhirMessageDefinitionAllowedResponse(ObjectByIndex[index]);
end;

function TFhirMessageDefinitionAllowedResponseList.ItemClass: TFslObjectClass;
begin
  result := TFhirMessageDefinitionAllowedResponse;
end;
function TFhirMessageDefinitionAllowedResponseList.IndexOf(value: TFhirMessageDefinitionAllowedResponse): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMessageDefinitionAllowedResponseList.Insert(index: Integer): TFhirMessageDefinitionAllowedResponse;
begin
  result := TFhirMessageDefinitionAllowedResponse.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMessageDefinitionAllowedResponseList.InsertItem(index: Integer; value: TFhirMessageDefinitionAllowedResponse);
begin
  assert(value is TFhirMessageDefinitionAllowedResponse);
  Inherited Insert(index, value);
end;

function TFhirMessageDefinitionAllowedResponseList.Item(index: Integer): TFhirMessageDefinitionAllowedResponse;
begin
  result := TFhirMessageDefinitionAllowedResponse(ObjectByIndex[index]);
end;

function TFhirMessageDefinitionAllowedResponseList.Link: TFhirMessageDefinitionAllowedResponseList;
begin
  result := TFhirMessageDefinitionAllowedResponseList(inherited Link);
end;

procedure TFhirMessageDefinitionAllowedResponseList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMessageDefinitionAllowedResponseList.SetItemByIndex(index: Integer; value: TFhirMessageDefinitionAllowedResponse);
begin
  assert(value is TFhirMessageDefinitionAllowedResponse);
  FhirMessageDefinitionAllowedResponses[index] := value;
end;

procedure TFhirMessageDefinitionAllowedResponseList.SetItemN(index: Integer; value: TFhirMessageDefinitionAllowedResponse);
begin
  assert(value is TFhirMessageDefinitionAllowedResponse);
  ObjectByIndex[index] := value;
end;

{ TFhirMessageDefinition }

constructor TFhirMessageDefinition.Create;
begin
  inherited;
end;

destructor TFhirMessageDefinition.Destroy;
begin
  FUrl.free;
  FIdentifierList.Free;
  FVersion.free;
  FName.free;
  FTitle.free;
  FReplacesList.Free;
  FStatus.free;
  FExperimental.free;
  FDate.free;
  FPublisher.free;
  FContactList.Free;
  FDescription.free;
  FUseContextList.Free;
  FJurisdictionList.Free;
  FPurpose.free;
  FCopyright.free;
  FBase.free;
  FParentList.Free;
  FEvent.free;
  FCategory.free;
  FFocusList.Free;
  FResponseRequired.free;
  FAllowedResponseList.Free;
  FGraphList.Free;
  inherited;
end;

procedure TFhirMessageDefinition.Assign(oSource : TFslObject);
begin
  inherited;
  urlElement := TFhirMessageDefinition(oSource).urlElement.Clone;
  if (TFhirMessageDefinition(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirMessageDefinition(oSource).FIdentifierList);
  end;
  versionElement := TFhirMessageDefinition(oSource).versionElement.Clone;
  nameElement := TFhirMessageDefinition(oSource).nameElement.Clone;
  titleElement := TFhirMessageDefinition(oSource).titleElement.Clone;
  if (TFhirMessageDefinition(oSource).FReplacesList = nil) then
  begin
    FReplacesList.free;
    FReplacesList := nil;
  end
  else
  begin
    if FReplacesList = nil then
      FReplacesList := TFhirCanonicalList.Create;
    FReplacesList.Assign(TFhirMessageDefinition(oSource).FReplacesList);
  end;
  statusElement := TFhirMessageDefinition(oSource).statusElement.Clone;
  experimentalElement := TFhirMessageDefinition(oSource).experimentalElement.Clone;
  dateElement := TFhirMessageDefinition(oSource).dateElement.Clone;
  publisherElement := TFhirMessageDefinition(oSource).publisherElement.Clone;
  if (TFhirMessageDefinition(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirContactDetailList.Create;
    FContactList.Assign(TFhirMessageDefinition(oSource).FContactList);
  end;
  descriptionElement := TFhirMessageDefinition(oSource).descriptionElement.Clone;
  if (TFhirMessageDefinition(oSource).FUseContextList = nil) then
  begin
    FUseContextList.free;
    FUseContextList := nil;
  end
  else
  begin
    if FUseContextList = nil then
      FUseContextList := TFhirUsageContextList.Create;
    FUseContextList.Assign(TFhirMessageDefinition(oSource).FUseContextList);
  end;
  if (TFhirMessageDefinition(oSource).FJurisdictionList = nil) then
  begin
    FJurisdictionList.free;
    FJurisdictionList := nil;
  end
  else
  begin
    if FJurisdictionList = nil then
      FJurisdictionList := TFhirCodeableConceptList.Create;
    FJurisdictionList.Assign(TFhirMessageDefinition(oSource).FJurisdictionList);
  end;
  purposeElement := TFhirMessageDefinition(oSource).purposeElement.Clone;
  copyrightElement := TFhirMessageDefinition(oSource).copyrightElement.Clone;
  baseElement := TFhirMessageDefinition(oSource).baseElement.Clone;
  if (TFhirMessageDefinition(oSource).FParentList = nil) then
  begin
    FParentList.free;
    FParentList := nil;
  end
  else
  begin
    if FParentList = nil then
      FParentList := TFhirCanonicalList.Create;
    FParentList.Assign(TFhirMessageDefinition(oSource).FParentList);
  end;
  event := TFhirMessageDefinition(oSource).event.Clone;
  categoryElement := TFhirMessageDefinition(oSource).categoryElement.Clone;
  if (TFhirMessageDefinition(oSource).FFocusList = nil) then
  begin
    FFocusList.free;
    FFocusList := nil;
  end
  else
  begin
    if FFocusList = nil then
      FFocusList := TFhirMessageDefinitionFocusList.Create;
    FFocusList.Assign(TFhirMessageDefinition(oSource).FFocusList);
  end;
  responseRequiredElement := TFhirMessageDefinition(oSource).responseRequiredElement.Clone;
  if (TFhirMessageDefinition(oSource).FAllowedResponseList = nil) then
  begin
    FAllowedResponseList.free;
    FAllowedResponseList := nil;
  end
  else
  begin
    if FAllowedResponseList = nil then
      FAllowedResponseList := TFhirMessageDefinitionAllowedResponseList.Create;
    FAllowedResponseList.Assign(TFhirMessageDefinition(oSource).FAllowedResponseList);
  end;
  if (TFhirMessageDefinition(oSource).FGraphList = nil) then
  begin
    FGraphList.free;
    FGraphList := nil;
  end
  else
  begin
    if FGraphList = nil then
      FGraphList := TFhirCanonicalList.Create;
    FGraphList.Assign(TFhirMessageDefinition(oSource).FGraphList);
  end;
end;

function TFhirMessageDefinition.GetResourceType : TFhirResourceType;
begin
  result := frtMessageDefinition;
end;

procedure TFhirMessageDefinition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'version') Then
     list.add(self.link, 'version', FVersion.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
  if (child_name = 'replaces') Then
    list.addAll(self, 'replaces', FReplacesList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'experimental') Then
     list.add(self.link, 'experimental', FExperimental.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'publisher') Then
     list.add(self.link, 'publisher', FPublisher.Link);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'useContext') Then
    list.addAll(self, 'useContext', FUseContextList);
  if (child_name = 'jurisdiction') Then
    list.addAll(self, 'jurisdiction', FJurisdictionList);
  if (child_name = 'purpose') Then
     list.add(self.link, 'purpose', FPurpose.Link);
  if (child_name = 'copyright') Then
     list.add(self.link, 'copyright', FCopyright.Link);
  if (child_name = 'base') Then
     list.add(self.link, 'base', FBase.Link);
  if (child_name = 'parent') Then
    list.addAll(self, 'parent', FParentList);
  if (child_name = 'event[x]') or (child_name = 'event') Then
     list.add(self.link, 'event[x]', FEvent.Link);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'focus') Then
    list.addAll(self, 'focus', FFocusList);
  if (child_name = 'responseRequired') Then
     list.add(self.link, 'responseRequired', FResponseRequired.Link);
  if (child_name = 'allowedResponse') Then
    list.addAll(self, 'allowedResponse', FAllowedResponseList);
  if (child_name = 'graph') Then
    list.addAll(self, 'graph', FGraphList);
end;

procedure TFhirMessageDefinition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'url', 'uri', false, TFhirUri, FUrl.Link));
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'version', 'string', false, TFhirString, FVersion.Link));
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link));
  oList.add(TFHIRProperty.create(self, 'replaces', 'canonical', true, TFhirCanonical, FReplacesList.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'experimental', 'boolean', false, TFhirBoolean, FExperimental.Link));
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));
  oList.add(TFHIRProperty.create(self, 'publisher', 'string', false, TFhirString, FPublisher.Link));
  oList.add(TFHIRProperty.create(self, 'contact', 'ContactDetail', true, TFhirContactDetail, FContactList.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'markdown', false, TFhirMarkdown, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'useContext', 'UsageContext', true, TFhirUsageContext, FUseContextList.Link));
  oList.add(TFHIRProperty.create(self, 'jurisdiction', 'CodeableConcept', true, TFhirCodeableConcept, FJurisdictionList.Link));
  oList.add(TFHIRProperty.create(self, 'purpose', 'markdown', false, TFhirMarkdown, FPurpose.Link));
  oList.add(TFHIRProperty.create(self, 'copyright', 'markdown', false, TFhirMarkdown, FCopyright.Link));
  oList.add(TFHIRProperty.create(self, 'base', 'canonical', false, TFhirCanonical, FBase.Link));
  oList.add(TFHIRProperty.create(self, 'parent', 'canonical', true, TFhirCanonical, FParentList.Link));
  oList.add(TFHIRProperty.create(self, 'event[x]', 'Coding|uri', false, TFhirDataType, FEvent.Link));
  oList.add(TFHIRProperty.create(self, 'category', 'code', false, TFhirEnum, FCategory.Link));
  oList.add(TFHIRProperty.create(self, 'focus', 'BackboneElement', true, TFhirMessageDefinitionFocus, FFocusList.Link));
  oList.add(TFHIRProperty.create(self, 'responseRequired', 'code', false, TFhirEnum, FResponseRequired.Link));
  oList.add(TFHIRProperty.create(self, 'allowedResponse', 'BackboneElement', true, TFhirMessageDefinitionAllowedResponse, FAllowedResponseList.Link));
  oList.add(TFHIRProperty.create(self, 'graph', 'canonical', true, TFhirCanonical, FGraphList.Link));
end;

function TFhirMessageDefinition.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'url') then
  begin
    UrlElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'title') then
  begin
    TitleElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'replaces') then
  begin
    ReplacesList.add(asCanonical(propValue)){2};     result := propValue;

  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'experimental') then
  begin
    ExperimentalElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'publisher') then
  begin
    PublisherElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirContactDetail);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'useContext') then
  begin
    UseContextList.add(propValue as TFhirUsageContext);
    result := propValue;
  end
  else if (propName = 'jurisdiction') then
  begin
    JurisdictionList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'purpose') then
  begin
    PurposeElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'copyright') then
  begin
    CopyrightElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'base') then
  begin
    BaseElement := asCanonical(propValue);
    result := propValue;
  end
  else if (propName = 'parent') then
  begin
    ParentList.add(asCanonical(propValue)){2};     result := propValue;

  end
  else if (isMatchingName(propName, 'event', ['Coding', 'Uri'])) then
  begin
    Event := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    CategoryElement := asEnum(SYSTEMS_TFhirMessageSignificanceCategoryEnum, CODES_TFhirMessageSignificanceCategoryEnum, propValue);
    result := propValue;
  end
  else if (propName = 'focus') then
  begin
    FocusList.add(propValue as TFhirMessageDefinitionFocus);
    result := propValue;
  end
  else if (propName = 'responseRequired') then
  begin
    ResponseRequiredElement := asEnum(SYSTEMS_TFhirMessageheaderResponseRequestEnum, CODES_TFhirMessageheaderResponseRequestEnum, propValue);
    result := propValue;
  end
  else if (propName = 'allowedResponse') then
  begin
    AllowedResponseList.add(propValue as TFhirMessageDefinitionAllowedResponse);
    result := propValue;
  end
  else if (propName = 'graph') then
  begin
    GraphList.add(asCanonical(propValue)){2};     result := propValue;

  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMessageDefinition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'replaces') then ReplacesList.insertItem(index, asCanonical(propValue))
  else if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirContactDetail)
  else if (propName = 'useContext') then UseContextList.insertItem(index, propValue as TFhirUsageContext)
  else if (propName = 'jurisdiction') then JurisdictionList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'parent') then ParentList.insertItem(index, asCanonical(propValue))
  else if (propName = 'focus') then FocusList.insertItem(index, propValue as TFhirMessageDefinitionFocus)
  else if (propName = 'allowedResponse') then AllowedResponseList.insertItem(index, propValue as TFhirMessageDefinitionAllowedResponse)
  else if (propName = 'graph') then GraphList.insertItem(index, asCanonical(propValue))
  else inherited;
end;

function TFhirMessageDefinition.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'url') then result := TFhirUri.create()
  else if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'version') then result := TFhirString.create()
  else if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'title') then result := TFhirString.create()
  else if (propName = 'replaces') then result := ReplacesList.new()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[PublicationStatusNull], CODES_TFhirPublicationStatusEnum[PublicationStatusNull]) 
  else if (propName = 'experimental') then result := TFhirBoolean.create()
  else if (propName = 'date') then result := TFhirDateTime.create()
  else if (propName = 'publisher') then result := TFhirString.create()
  else if (propName = 'contact') then result := ContactList.new()
  else if (propName = 'description') then result := TFhirMarkdown.create()
  else if (propName = 'useContext') then result := UseContextList.new()
  else if (propName = 'jurisdiction') then result := JurisdictionList.new()
  else if (propName = 'purpose') then result := TFhirMarkdown.create()
  else if (propName = 'copyright') then result := TFhirMarkdown.create()
  else if (propName = 'base') then result := TFhirCanonical.create()
  else if (propName = 'parent') then result := ParentList.new()
  else if (isMatchingName(propName, 'event', ['Coding', 'Uri'])) then raise EFHIRException.create('Cannot make property Event')
  else if (propName = 'category') then result := TFhirEnum.create(SYSTEMS_TFhirMessageSignificanceCategoryEnum[MessageSignificanceCategoryNull], CODES_TFhirMessageSignificanceCategoryEnum[MessageSignificanceCategoryNull]) 
  else if (propName = 'focus') then result := FocusList.new()
  else if (propName = 'responseRequired') then result := TFhirEnum.create(SYSTEMS_TFhirMessageheaderResponseRequestEnum[MessageheaderResponseRequestNull], CODES_TFhirMessageheaderResponseRequestEnum[MessageheaderResponseRequestNull]) 
  else if (propName = 'allowedResponse') then result := AllowedResponseList.new()
  else if (propName = 'graph') then result := GraphList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMessageDefinition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'url') then result := 'uri'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'version') then result := 'string'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'title') then result := 'string'
  else if (propName = 'replaces') then result := 'canonical'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'experimental') then result := 'boolean'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'publisher') then result := 'string'
  else if (propName = 'contact') then result := 'ContactDetail'
  else if (propName = 'description') then result := 'markdown'
  else if (propName = 'useContext') then result := 'UsageContext'
  else if (propName = 'jurisdiction') then result := 'CodeableConcept'
  else if (propName = 'purpose') then result := 'markdown'
  else if (propName = 'copyright') then result := 'markdown'
  else if (propName = 'base') then result := 'canonical'
  else if (propName = 'parent') then result := 'canonical'
  else if (propName = 'event[x]') then result := 'Coding|uri'
  else if (propName = 'category') then result := 'code'
  else if (propName = 'focus') then result := 'BackboneElement'
  else if (propName = 'responseRequired') then result := 'code'
  else if (propName = 'allowedResponse') then result := 'BackboneElement'
  else if (propName = 'graph') then result := 'canonical'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMessageDefinition.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := nil
  else if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'version') then VersionElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'title') then TitleElement := nil
  else if (propName = 'replaces') then deletePropertyValue('replaces', ReplacesList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'experimental') then ExperimentalElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'publisher') then PublisherElement := nil
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value)
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'useContext') then deletePropertyValue('useContext', UseContextList, value)
  else if (propName = 'jurisdiction') then deletePropertyValue('jurisdiction', JurisdictionList, value)
  else if (propName = 'purpose') then PurposeElement := nil
  else if (propName = 'copyright') then CopyrightElement := nil
  else if (propName = 'base') then BaseElement := nil
  else if (propName = 'parent') then deletePropertyValue('parent', ParentList, value)
  else if (isMatchingName(propName, 'event', ['Coding', 'Uri'])) then EventElement := nil
  else if (propName = 'category') then CategoryElement := nil
  else if (propName = 'focus') then deletePropertyValue('focus', FocusList, value)
  else if (propName = 'responseRequired') then ResponseRequiredElement := nil
  else if (propName = 'allowedResponse') then deletePropertyValue('allowedResponse', AllowedResponseList, value)
  else if (propName = 'graph') then deletePropertyValue('graph', GraphList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMessageDefinition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := asUri(new)
  else if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'version') then VersionElement := asString(new)
  else if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'title') then TitleElement := asString(new)
  else if (propName = 'replaces') then replacePropertyValue('replaces', ReplacesList, existing, new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, new)
  else if (propName = 'experimental') then ExperimentalElement := asBoolean(new)
  else if (propName = 'date') then DateElement := asDateTime(new)
  else if (propName = 'publisher') then PublisherElement := asString(new)
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new)
  else if (propName = 'description') then DescriptionElement := asMarkdown(new)
  else if (propName = 'useContext') then replacePropertyValue('useContext', UseContextList, existing, new)
  else if (propName = 'jurisdiction') then replacePropertyValue('jurisdiction', JurisdictionList, existing, new)
  else if (propName = 'purpose') then PurposeElement := asMarkdown(new)
  else if (propName = 'copyright') then CopyrightElement := asMarkdown(new)
  else if (propName = 'base') then BaseElement := asCanonical(new)
  else if (propName = 'parent') then replacePropertyValue('parent', ParentList, existing, new)
  else if (isMatchingName(propName, 'event', ['Coding', 'Uri'])) then EventElement := new as TFhirDataType
  else if (propName = 'category') then CategoryElement := asEnum(SYSTEMS_TFhirMessageSignificanceCategoryEnum, CODES_TFhirMessageSignificanceCategoryEnum, new)
  else if (propName = 'focus') then replacePropertyValue('focus', FocusList, existing, new)
  else if (propName = 'responseRequired') then ResponseRequiredElement := asEnum(SYSTEMS_TFhirMessageheaderResponseRequestEnum, CODES_TFhirMessageheaderResponseRequestEnum, new)
  else if (propName = 'allowedResponse') then replacePropertyValue('allowedResponse', AllowedResponseList, existing, new)
  else if (propName = 'graph') then replacePropertyValue('graph', GraphList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMessageDefinition.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'replaces') then ReplacesList.move(source, destination)
  else if (propName = 'contact') then ContactList.move(source, destination)
  else if (propName = 'useContext') then UseContextList.move(source, destination)
  else if (propName = 'jurisdiction') then JurisdictionList.move(source, destination)
  else if (propName = 'parent') then ParentList.move(source, destination)
  else if (propName = 'focus') then FocusList.move(source, destination)
  else if (propName = 'allowedResponse') then AllowedResponseList.move(source, destination)
  else if (propName = 'graph') then GraphList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMessageDefinition.fhirType : string;
begin
  result := 'MessageDefinition';
end;

function TFhirMessageDefinition.Link : TFhirMessageDefinition;
begin
  result := TFhirMessageDefinition(inherited Link);
end;

function TFhirMessageDefinition.Clone : TFhirMessageDefinition;
begin
  result := TFhirMessageDefinition(inherited Clone);
end;

function TFhirMessageDefinition.equals(other : TObject) : boolean; 
var
  o : TFhirMessageDefinition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMessageDefinition)) then
    result := false
  else
  begin
    o := TFhirMessageDefinition(other);
    result := compareDeep(urlElement, o.urlElement, true) and compareDeep(identifierList, o.identifierList, true) and 
      compareDeep(versionElement, o.versionElement, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(titleElement, o.titleElement, true) and compareDeep(replacesList, o.replacesList, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(experimentalElement, o.experimentalElement, true) and 
      compareDeep(dateElement, o.dateElement, true) and compareDeep(publisherElement, o.publisherElement, true) and 
      compareDeep(contactList, o.contactList, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(useContextList, o.useContextList, true) and compareDeep(jurisdictionList, o.jurisdictionList, true) and 
      compareDeep(purposeElement, o.purposeElement, true) and compareDeep(copyrightElement, o.copyrightElement, true) and 
      compareDeep(baseElement, o.baseElement, true) and compareDeep(parentList, o.parentList, true) and 
      compareDeep(eventElement, o.eventElement, true) and compareDeep(categoryElement, o.categoryElement, true) and 
      compareDeep(focusList, o.focusList, true) and compareDeep(responseRequiredElement, o.responseRequiredElement, true) and 
      compareDeep(allowedResponseList, o.allowedResponseList, true) and compareDeep(graphList, o.graphList, true);
  end;
end;

function TFhirMessageDefinition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FUrl) and isEmptyProp(FidentifierList) and isEmptyProp(FVersion) and isEmptyProp(FName) and isEmptyProp(FTitle) and isEmptyProp(FreplacesList) and isEmptyProp(FStatus) and isEmptyProp(FExperimental) and isEmptyProp(FDate) and isEmptyProp(FPublisher) and isEmptyProp(FcontactList) and isEmptyProp(FDescription) and isEmptyProp(FuseContextList) and isEmptyProp(FjurisdictionList) and isEmptyProp(FPurpose) and isEmptyProp(FCopyright) and isEmptyProp(FBase) and isEmptyProp(FparentList) and isEmptyProp(FEvent) and isEmptyProp(FCategory) and isEmptyProp(FfocusList) and isEmptyProp(FResponseRequired) and isEmptyProp(FallowedResponseList) and isEmptyProp(FgraphList);
end;

procedure TFhirMessageDefinition.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('url');
  fields.add('identifier');
  fields.add('version');
  fields.add('name');
  fields.add('title');
  fields.add('replaces');
  fields.add('status');
  fields.add('experimental');
  fields.add('date');
  fields.add('publisher');
  fields.add('contact');
  fields.add('description');
  fields.add('useContext');
  fields.add('jurisdiction');
  fields.add('purpose');
  fields.add('copyright');
  fields.add('base');
  fields.add('parent');
  fields.add('event[x]');
  fields.add('category');
  fields.add('focus');
  fields.add('responseRequired');
  fields.add('allowedResponse');
  fields.add('graph');
end;

function TFhirMessageDefinition.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FReplacesList.sizeInBytes(magic));
  inc(result, FContactList.sizeInBytes(magic));
  inc(result, FUseContextList.sizeInBytes(magic));
  inc(result, FJurisdictionList.sizeInBytes(magic));
  inc(result, FParentList.sizeInBytes(magic));
  inc(result, FFocusList.sizeInBytes(magic));
  inc(result, FAllowedResponseList.sizeInBytes(magic));
  inc(result, FGraphList.sizeInBytes(magic));
end;

procedure TFhirMessageDefinition.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

function TFhirMessageDefinition.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

procedure TFhirMessageDefinition.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

function TFhirMessageDefinition.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirMessageDefinition.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirMessageDefinition.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

function TFhirMessageDefinition.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

procedure TFhirMessageDefinition.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

procedure TFhirMessageDefinition.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirMessageDefinition.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirMessageDefinition.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirMessageDefinition.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

function TFhirMessageDefinition.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

procedure TFhirMessageDefinition.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

function TFhirMessageDefinition.GetReplacesList : TFhirCanonicalList;
begin
  if FReplacesList = nil then
    FReplacesList := TFhirCanonicalList.Create;
  result := FReplacesList;
end;

function TFhirMessageDefinition.GetHasReplacesList : boolean;
begin
  result := (FReplacesList <> nil) and (FReplacesList.count > 0);
end;

procedure TFhirMessageDefinition.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirMessageDefinition.GetStatusST : TFhirPublicationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirPublicationStatusEnum(0)
  else
    result := TFhirPublicationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirPublicationStatusEnum, FStatus.value));
end;

procedure TFhirMessageDefinition.SetStatusST(value : TFhirPublicationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[value], CODES_TFhirPublicationStatusEnum[value]);
end;

procedure TFhirMessageDefinition.SetExperimental(value : TFhirBoolean);
begin
  FExperimental.free;
  FExperimental := value;
end;

function TFhirMessageDefinition.GetExperimentalST : Boolean;
begin
  if FExperimental = nil then
    result := false
  else
    result := FExperimental.value;
end;

procedure TFhirMessageDefinition.SetExperimentalST(value : Boolean);
begin
  if FExperimental = nil then
    FExperimental := TFhirBoolean.create;
  FExperimental.value := value
end;

procedure TFhirMessageDefinition.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

function TFhirMessageDefinition.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirMessageDefinition.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

procedure TFhirMessageDefinition.SetPublisher(value : TFhirString);
begin
  FPublisher.free;
  FPublisher := value;
end;

function TFhirMessageDefinition.GetPublisherST : String;
begin
  if FPublisher = nil then
    result := ''
  else
    result := FPublisher.value;
end;

procedure TFhirMessageDefinition.SetPublisherST(value : String);
begin
  if value <> '' then
  begin
    if FPublisher = nil then
      FPublisher := TFhirString.create;
    FPublisher.value := value
  end
  else if FPublisher <> nil then
    FPublisher.value := '';
end;

function TFhirMessageDefinition.GetContactList : TFhirContactDetailList;
begin
  if FContactList = nil then
    FContactList := TFhirContactDetailList.Create;
  result := FContactList;
end;

function TFhirMessageDefinition.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

procedure TFhirMessageDefinition.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirMessageDefinition.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirMessageDefinition.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirMessageDefinition.GetUseContextList : TFhirUsageContextList;
begin
  if FUseContextList = nil then
    FUseContextList := TFhirUsageContextList.Create;
  result := FUseContextList;
end;

function TFhirMessageDefinition.GetHasUseContextList : boolean;
begin
  result := (FUseContextList <> nil) and (FUseContextList.count > 0);
end;

function TFhirMessageDefinition.GetJurisdictionList : TFhirCodeableConceptList;
begin
  if FJurisdictionList = nil then
    FJurisdictionList := TFhirCodeableConceptList.Create;
  result := FJurisdictionList;
end;

function TFhirMessageDefinition.GetHasJurisdictionList : boolean;
begin
  result := (FJurisdictionList <> nil) and (FJurisdictionList.count > 0);
end;

procedure TFhirMessageDefinition.SetPurpose(value : TFhirMarkdown);
begin
  FPurpose.free;
  FPurpose := value;
end;

function TFhirMessageDefinition.GetPurposeST : String;
begin
  if FPurpose = nil then
    result := ''
  else
    result := FPurpose.value;
end;

procedure TFhirMessageDefinition.SetPurposeST(value : String);
begin
  if value <> '' then
  begin
    if FPurpose = nil then
      FPurpose := TFhirMarkdown.create;
    FPurpose.value := value
  end
  else if FPurpose <> nil then
    FPurpose.value := '';
end;

procedure TFhirMessageDefinition.SetCopyright(value : TFhirMarkdown);
begin
  FCopyright.free;
  FCopyright := value;
end;

function TFhirMessageDefinition.GetCopyrightST : String;
begin
  if FCopyright = nil then
    result := ''
  else
    result := FCopyright.value;
end;

procedure TFhirMessageDefinition.SetCopyrightST(value : String);
begin
  if value <> '' then
  begin
    if FCopyright = nil then
      FCopyright := TFhirMarkdown.create;
    FCopyright.value := value
  end
  else if FCopyright <> nil then
    FCopyright.value := '';
end;

procedure TFhirMessageDefinition.SetBase(value : TFhirCanonical);
begin
  FBase.free;
  FBase := value;
end;

function TFhirMessageDefinition.GetBaseST : String;
begin
  if FBase = nil then
    result := ''
  else
    result := FBase.value;
end;

procedure TFhirMessageDefinition.SetBaseST(value : String);
begin
  if value <> '' then
  begin
    if FBase = nil then
      FBase := TFhirCanonical.create;
    FBase.value := value
  end
  else if FBase <> nil then
    FBase.value := '';
end;

function TFhirMessageDefinition.GetParentList : TFhirCanonicalList;
begin
  if FParentList = nil then
    FParentList := TFhirCanonicalList.Create;
  result := FParentList;
end;

function TFhirMessageDefinition.GetHasParentList : boolean;
begin
  result := (FParentList <> nil) and (FParentList.count > 0);
end;

procedure TFhirMessageDefinition.SetEvent(value : TFhirDataType);
begin
  FEvent.free;
  FEvent := value;
end;

procedure TFhirMessageDefinition.SetCategory(value : TFhirEnum);
begin
  FCategory.free;
  FCategory := value;
end;

function TFhirMessageDefinition.GetCategoryST : TFhirMessageSignificanceCategoryEnum;
begin
  if FCategory = nil then
    result := TFhirMessageSignificanceCategoryEnum(0)
  else
    result := TFhirMessageSignificanceCategoryEnum(StringArrayIndexOfSensitive(CODES_TFhirMessageSignificanceCategoryEnum, FCategory.value));
end;

procedure TFhirMessageDefinition.SetCategoryST(value : TFhirMessageSignificanceCategoryEnum);
begin
  if ord(value) = 0 then
    CategoryElement := nil
  else
    CategoryElement := TFhirEnum.create(SYSTEMS_TFhirMessageSignificanceCategoryEnum[value], CODES_TFhirMessageSignificanceCategoryEnum[value]);
end;

function TFhirMessageDefinition.GetFocusList : TFhirMessageDefinitionFocusList;
begin
  if FFocusList = nil then
    FFocusList := TFhirMessageDefinitionFocusList.Create;
  result := FFocusList;
end;

function TFhirMessageDefinition.GetHasFocusList : boolean;
begin
  result := (FFocusList <> nil) and (FFocusList.count > 0);
end;

procedure TFhirMessageDefinition.SetResponseRequired(value : TFhirEnum);
begin
  FResponseRequired.free;
  FResponseRequired := value;
end;

function TFhirMessageDefinition.GetResponseRequiredST : TFhirMessageheaderResponseRequestEnum;
begin
  if FResponseRequired = nil then
    result := TFhirMessageheaderResponseRequestEnum(0)
  else
    result := TFhirMessageheaderResponseRequestEnum(StringArrayIndexOfSensitive(CODES_TFhirMessageheaderResponseRequestEnum, FResponseRequired.value));
end;

procedure TFhirMessageDefinition.SetResponseRequiredST(value : TFhirMessageheaderResponseRequestEnum);
begin
  if ord(value) = 0 then
    ResponseRequiredElement := nil
  else
    ResponseRequiredElement := TFhirEnum.create(SYSTEMS_TFhirMessageheaderResponseRequestEnum[value], CODES_TFhirMessageheaderResponseRequestEnum[value]);
end;

function TFhirMessageDefinition.GetAllowedResponseList : TFhirMessageDefinitionAllowedResponseList;
begin
  if FAllowedResponseList = nil then
    FAllowedResponseList := TFhirMessageDefinitionAllowedResponseList.Create;
  result := FAllowedResponseList;
end;

function TFhirMessageDefinition.GetHasAllowedResponseList : boolean;
begin
  result := (FAllowedResponseList <> nil) and (FAllowedResponseList.count > 0);
end;

function TFhirMessageDefinition.GetGraphList : TFhirCanonicalList;
begin
  if FGraphList = nil then
    FGraphList := TFhirCanonicalList.Create;
  result := FGraphList;
end;

function TFhirMessageDefinition.GetHasGraphList : boolean;
begin
  result := (FGraphList <> nil) and (FGraphList.count > 0);
end;

{ TFhirMessageDefinitionListEnumerator }

constructor TFhirMessageDefinitionListEnumerator.Create(list : TFhirMessageDefinitionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMessageDefinitionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMessageDefinitionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMessageDefinitionListEnumerator.GetCurrent : TFhirMessageDefinition;
begin
  Result := FList[FIndex];
end;

function TFhirMessageDefinitionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMessageDefinitionList }

function TFhirMessageDefinitionList.AddItem(value: TFhirMessageDefinition): TFhirMessageDefinition;
begin
  assert(value.ClassName = 'TFhirMessageDefinition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMessageDefinition');
  add(value);
  result := value;
end;

function TFhirMessageDefinitionList.Append: TFhirMessageDefinition;
begin
  result := TFhirMessageDefinition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMessageDefinitionList.ClearItems;
begin
  Clear;
end;

function TFhirMessageDefinitionList.GetEnumerator : TFhirMessageDefinitionListEnumerator;
begin
  result := TFhirMessageDefinitionListEnumerator.Create(self.link);
end;

function TFhirMessageDefinitionList.Clone: TFhirMessageDefinitionList;
begin
  result := TFhirMessageDefinitionList(inherited Clone);
end;

function TFhirMessageDefinitionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMessageDefinitionList.GetItemN(index: Integer): TFhirMessageDefinition;
begin
  result := TFhirMessageDefinition(ObjectByIndex[index]);
end;

function TFhirMessageDefinitionList.ItemClass: TFslObjectClass;
begin
  result := TFhirMessageDefinition;
end;
function TFhirMessageDefinitionList.IndexOf(value: TFhirMessageDefinition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMessageDefinitionList.Insert(index: Integer): TFhirMessageDefinition;
begin
  result := TFhirMessageDefinition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMessageDefinitionList.InsertItem(index: Integer; value: TFhirMessageDefinition);
begin
  assert(value is TFhirMessageDefinition);
  Inherited Insert(index, value);
end;

function TFhirMessageDefinitionList.Item(index: Integer): TFhirMessageDefinition;
begin
  result := TFhirMessageDefinition(ObjectByIndex[index]);
end;

function TFhirMessageDefinitionList.Link: TFhirMessageDefinitionList;
begin
  result := TFhirMessageDefinitionList(inherited Link);
end;

procedure TFhirMessageDefinitionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMessageDefinitionList.SetItemByIndex(index: Integer; value: TFhirMessageDefinition);
begin
  assert(value is TFhirMessageDefinition);
  FhirMessageDefinitions[index] := value;
end;

procedure TFhirMessageDefinitionList.SetItemN(index: Integer; value: TFhirMessageDefinition);
begin
  assert(value is TFhirMessageDefinition);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_MESSAGEDEFINITION}
{$IFDEF FHIR_NAMINGSYSTEM}
{ TFhirNamingSystemUniqueId }

constructor TFhirNamingSystemUniqueId.Create;
begin
  inherited;
end;

destructor TFhirNamingSystemUniqueId.Destroy;
begin
  FType_.free;
  FValue.free;
  FPreferred.free;
  FComment.free;
  FPeriod.free;
  inherited;
end;

procedure TFhirNamingSystemUniqueId.Assign(oSource : TFslObject);
begin
  inherited;
  type_Element := TFhirNamingSystemUniqueId(oSource).type_Element.Clone;
  valueElement := TFhirNamingSystemUniqueId(oSource).valueElement.Clone;
  preferredElement := TFhirNamingSystemUniqueId(oSource).preferredElement.Clone;
  commentElement := TFhirNamingSystemUniqueId(oSource).commentElement.Clone;
  period := TFhirNamingSystemUniqueId(oSource).period.Clone;
end;

procedure TFhirNamingSystemUniqueId.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
  if (child_name = 'preferred') Then
     list.add(self.link, 'preferred', FPreferred.Link);
  if (child_name = 'comment') Then
     list.add(self.link, 'comment', FComment.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
end;

procedure TFhirNamingSystemUniqueId.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFhirEnum, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'value', 'string', false, TFhirString, FValue.Link));
  oList.add(TFHIRProperty.create(self, 'preferred', 'boolean', false, TFhirBoolean, FPreferred.Link));
  oList.add(TFHIRProperty.create(self, 'comment', 'string', false, TFhirString, FComment.Link));
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));
end;

function TFhirNamingSystemUniqueId.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirNamingSystemIdentifierTypeEnum, CODES_TFhirNamingSystemIdentifierTypeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'value') then
  begin
    ValueElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'preferred') then
  begin
    PreferredElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'comment') then
  begin
    CommentElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirNamingSystemUniqueId.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirNamingSystemUniqueId.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirEnum.create(SYSTEMS_TFhirNamingSystemIdentifierTypeEnum[NamingSystemIdentifierTypeNull], CODES_TFhirNamingSystemIdentifierTypeEnum[NamingSystemIdentifierTypeNull]) 
  else if (propName = 'value') then result := TFhirString.create()
  else if (propName = 'preferred') then result := TFhirBoolean.create()
  else if (propName = 'comment') then result := TFhirString.create()
  else if (propName = 'period') then result := TFhirPeriod.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirNamingSystemUniqueId.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'code'
  else if (propName = 'value') then result := 'string'
  else if (propName = 'preferred') then result := 'boolean'
  else if (propName = 'comment') then result := 'string'
  else if (propName = 'period') then result := 'Period'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirNamingSystemUniqueId.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'value') then ValueElement := nil
  else if (propName = 'preferred') then PreferredElement := nil
  else if (propName = 'comment') then CommentElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirNamingSystemUniqueId.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirNamingSystemIdentifierTypeEnum, CODES_TFhirNamingSystemIdentifierTypeEnum, new)
  else if (propName = 'value') then ValueElement := asString(new)
  else if (propName = 'preferred') then PreferredElement := asBoolean(new)
  else if (propName = 'comment') then CommentElement := asString(new)
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirNamingSystemUniqueId.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirNamingSystemUniqueId.fhirType : string;
begin
  result := 'NamingSystem.uniqueId';
end;

function TFhirNamingSystemUniqueId.Link : TFhirNamingSystemUniqueId;
begin
  result := TFhirNamingSystemUniqueId(inherited Link);
end;

function TFhirNamingSystemUniqueId.Clone : TFhirNamingSystemUniqueId;
begin
  result := TFhirNamingSystemUniqueId(inherited Clone);
end;

function TFhirNamingSystemUniqueId.equals(other : TObject) : boolean; 
var
  o : TFhirNamingSystemUniqueId;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirNamingSystemUniqueId)) then
    result := false
  else
  begin
    o := TFhirNamingSystemUniqueId(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(valueElement, o.valueElement, true) and 
      compareDeep(preferredElement, o.preferredElement, true) and compareDeep(commentElement, o.commentElement, true) and 
      compareDeep(periodElement, o.periodElement, true);
  end;
end;

function TFhirNamingSystemUniqueId.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FValue) and isEmptyProp(FPreferred) and isEmptyProp(FComment) and isEmptyProp(FPeriod);
end;

procedure TFhirNamingSystemUniqueId.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('value');
  fields.add('preferred');
  fields.add('comment');
  fields.add('period');
end;

function TFhirNamingSystemUniqueId.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirNamingSystemUniqueId.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirNamingSystemUniqueId.GetType_ST : TFhirNamingSystemIdentifierTypeEnum;
begin
  if FType_ = nil then
    result := TFhirNamingSystemIdentifierTypeEnum(0)
  else
    result := TFhirNamingSystemIdentifierTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirNamingSystemIdentifierTypeEnum, FType_.value));
end;

procedure TFhirNamingSystemUniqueId.SetType_ST(value : TFhirNamingSystemIdentifierTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirNamingSystemIdentifierTypeEnum[value], CODES_TFhirNamingSystemIdentifierTypeEnum[value]);
end;

procedure TFhirNamingSystemUniqueId.SetValue(value : TFhirString);
begin
  FValue.free;
  FValue := value;
end;

function TFhirNamingSystemUniqueId.GetValueST : String;
begin
  if FValue = nil then
    result := ''
  else
    result := FValue.value;
end;

procedure TFhirNamingSystemUniqueId.SetValueST(value : String);
begin
  if value <> '' then
  begin
    if FValue = nil then
      FValue := TFhirString.create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := '';
end;

procedure TFhirNamingSystemUniqueId.SetPreferred(value : TFhirBoolean);
begin
  FPreferred.free;
  FPreferred := value;
end;

function TFhirNamingSystemUniqueId.GetPreferredST : Boolean;
begin
  if FPreferred = nil then
    result := false
  else
    result := FPreferred.value;
end;

procedure TFhirNamingSystemUniqueId.SetPreferredST(value : Boolean);
begin
  if FPreferred = nil then
    FPreferred := TFhirBoolean.create;
  FPreferred.value := value
end;

procedure TFhirNamingSystemUniqueId.SetComment(value : TFhirString);
begin
  FComment.free;
  FComment := value;
end;

function TFhirNamingSystemUniqueId.GetCommentST : String;
begin
  if FComment = nil then
    result := ''
  else
    result := FComment.value;
end;

procedure TFhirNamingSystemUniqueId.SetCommentST(value : String);
begin
  if value <> '' then
  begin
    if FComment = nil then
      FComment := TFhirString.create;
    FComment.value := value
  end
  else if FComment <> nil then
    FComment.value := '';
end;

procedure TFhirNamingSystemUniqueId.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

{ TFhirNamingSystemUniqueIdListEnumerator }

constructor TFhirNamingSystemUniqueIdListEnumerator.Create(list : TFhirNamingSystemUniqueIdList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirNamingSystemUniqueIdListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirNamingSystemUniqueIdListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirNamingSystemUniqueIdListEnumerator.GetCurrent : TFhirNamingSystemUniqueId;
begin
  Result := FList[FIndex];
end;

function TFhirNamingSystemUniqueIdListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirNamingSystemUniqueIdList }

function TFhirNamingSystemUniqueIdList.AddItem(value: TFhirNamingSystemUniqueId): TFhirNamingSystemUniqueId;
begin
  assert(value.ClassName = 'TFhirNamingSystemUniqueId', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirNamingSystemUniqueId');
  add(value);
  result := value;
end;

function TFhirNamingSystemUniqueIdList.Append: TFhirNamingSystemUniqueId;
begin
  result := TFhirNamingSystemUniqueId.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNamingSystemUniqueIdList.ClearItems;
begin
  Clear;
end;

function TFhirNamingSystemUniqueIdList.GetEnumerator : TFhirNamingSystemUniqueIdListEnumerator;
begin
  result := TFhirNamingSystemUniqueIdListEnumerator.Create(self.link);
end;

function TFhirNamingSystemUniqueIdList.Clone: TFhirNamingSystemUniqueIdList;
begin
  result := TFhirNamingSystemUniqueIdList(inherited Clone);
end;

function TFhirNamingSystemUniqueIdList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirNamingSystemUniqueIdList.GetItemN(index: Integer): TFhirNamingSystemUniqueId;
begin
  result := TFhirNamingSystemUniqueId(ObjectByIndex[index]);
end;

function TFhirNamingSystemUniqueIdList.ItemClass: TFslObjectClass;
begin
  result := TFhirNamingSystemUniqueId;
end;
function TFhirNamingSystemUniqueIdList.IndexOf(value: TFhirNamingSystemUniqueId): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirNamingSystemUniqueIdList.Insert(index: Integer): TFhirNamingSystemUniqueId;
begin
  result := TFhirNamingSystemUniqueId.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNamingSystemUniqueIdList.InsertItem(index: Integer; value: TFhirNamingSystemUniqueId);
begin
  assert(value is TFhirNamingSystemUniqueId);
  Inherited Insert(index, value);
end;

function TFhirNamingSystemUniqueIdList.Item(index: Integer): TFhirNamingSystemUniqueId;
begin
  result := TFhirNamingSystemUniqueId(ObjectByIndex[index]);
end;

function TFhirNamingSystemUniqueIdList.Link: TFhirNamingSystemUniqueIdList;
begin
  result := TFhirNamingSystemUniqueIdList(inherited Link);
end;

procedure TFhirNamingSystemUniqueIdList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirNamingSystemUniqueIdList.SetItemByIndex(index: Integer; value: TFhirNamingSystemUniqueId);
begin
  assert(value is TFhirNamingSystemUniqueId);
  FhirNamingSystemUniqueIds[index] := value;
end;

procedure TFhirNamingSystemUniqueIdList.SetItemN(index: Integer; value: TFhirNamingSystemUniqueId);
begin
  assert(value is TFhirNamingSystemUniqueId);
  ObjectByIndex[index] := value;
end;

{ TFhirNamingSystem }

constructor TFhirNamingSystem.Create;
begin
  inherited;
end;

destructor TFhirNamingSystem.Destroy;
begin
  FName.free;
  FStatus.free;
  FKind.free;
  FDate.free;
  FPublisher.free;
  FContactList.Free;
  FResponsible.free;
  FType_.free;
  FDescription.free;
  FUseContextList.Free;
  FJurisdictionList.Free;
  FUsage.free;
  FUniqueIdList.Free;
  inherited;
end;

procedure TFhirNamingSystem.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirNamingSystem(oSource).nameElement.Clone;
  statusElement := TFhirNamingSystem(oSource).statusElement.Clone;
  kindElement := TFhirNamingSystem(oSource).kindElement.Clone;
  dateElement := TFhirNamingSystem(oSource).dateElement.Clone;
  publisherElement := TFhirNamingSystem(oSource).publisherElement.Clone;
  if (TFhirNamingSystem(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirContactDetailList.Create;
    FContactList.Assign(TFhirNamingSystem(oSource).FContactList);
  end;
  responsibleElement := TFhirNamingSystem(oSource).responsibleElement.Clone;
  type_ := TFhirNamingSystem(oSource).type_.Clone;
  descriptionElement := TFhirNamingSystem(oSource).descriptionElement.Clone;
  if (TFhirNamingSystem(oSource).FUseContextList = nil) then
  begin
    FUseContextList.free;
    FUseContextList := nil;
  end
  else
  begin
    if FUseContextList = nil then
      FUseContextList := TFhirUsageContextList.Create;
    FUseContextList.Assign(TFhirNamingSystem(oSource).FUseContextList);
  end;
  if (TFhirNamingSystem(oSource).FJurisdictionList = nil) then
  begin
    FJurisdictionList.free;
    FJurisdictionList := nil;
  end
  else
  begin
    if FJurisdictionList = nil then
      FJurisdictionList := TFhirCodeableConceptList.Create;
    FJurisdictionList.Assign(TFhirNamingSystem(oSource).FJurisdictionList);
  end;
  usageElement := TFhirNamingSystem(oSource).usageElement.Clone;
  if (TFhirNamingSystem(oSource).FUniqueIdList = nil) then
  begin
    FUniqueIdList.free;
    FUniqueIdList := nil;
  end
  else
  begin
    if FUniqueIdList = nil then
      FUniqueIdList := TFhirNamingSystemUniqueIdList.Create;
    FUniqueIdList.Assign(TFhirNamingSystem(oSource).FUniqueIdList);
  end;
end;

function TFhirNamingSystem.GetResourceType : TFhirResourceType;
begin
  result := frtNamingSystem;
end;

procedure TFhirNamingSystem.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'kind') Then
     list.add(self.link, 'kind', FKind.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'publisher') Then
     list.add(self.link, 'publisher', FPublisher.Link);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'responsible') Then
     list.add(self.link, 'responsible', FResponsible.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'useContext') Then
    list.addAll(self, 'useContext', FUseContextList);
  if (child_name = 'jurisdiction') Then
    list.addAll(self, 'jurisdiction', FJurisdictionList);
  if (child_name = 'usage') Then
     list.add(self.link, 'usage', FUsage.Link);
  if (child_name = 'uniqueId') Then
    list.addAll(self, 'uniqueId', FUniqueIdList);
end;

procedure TFhirNamingSystem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'kind', 'code', false, TFhirEnum, FKind.Link));
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));
  oList.add(TFHIRProperty.create(self, 'publisher', 'string', false, TFhirString, FPublisher.Link));
  oList.add(TFHIRProperty.create(self, 'contact', 'ContactDetail', true, TFhirContactDetail, FContactList.Link));
  oList.add(TFHIRProperty.create(self, 'responsible', 'string', false, TFhirString, FResponsible.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'markdown', false, TFhirMarkdown, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'useContext', 'UsageContext', true, TFhirUsageContext, FUseContextList.Link));
  oList.add(TFHIRProperty.create(self, 'jurisdiction', 'CodeableConcept', true, TFhirCodeableConcept, FJurisdictionList.Link));
  oList.add(TFHIRProperty.create(self, 'usage', 'string', false, TFhirString, FUsage.Link));
  oList.add(TFHIRProperty.create(self, 'uniqueId', 'BackboneElement', true, TFhirNamingSystemUniqueId, FUniqueIdList.Link));
end;

function TFhirNamingSystem.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'kind') then
  begin
    KindElement := asEnum(SYSTEMS_TFhirNamingSystemTypeEnum, CODES_TFhirNamingSystemTypeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'publisher') then
  begin
    PublisherElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirContactDetail);
    result := propValue;
  end
  else if (propName = 'responsible') then
  begin
    ResponsibleElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'useContext') then
  begin
    UseContextList.add(propValue as TFhirUsageContext);
    result := propValue;
  end
  else if (propName = 'jurisdiction') then
  begin
    JurisdictionList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'usage') then
  begin
    UsageElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'uniqueId') then
  begin
    UniqueIdList.add(propValue as TFhirNamingSystemUniqueId);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirNamingSystem.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirContactDetail)
  else if (propName = 'useContext') then UseContextList.insertItem(index, propValue as TFhirUsageContext)
  else if (propName = 'jurisdiction') then JurisdictionList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'uniqueId') then UniqueIdList.insertItem(index, propValue as TFhirNamingSystemUniqueId)
  else inherited;
end;

function TFhirNamingSystem.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[PublicationStatusNull], CODES_TFhirPublicationStatusEnum[PublicationStatusNull]) 
  else if (propName = 'kind') then result := TFhirEnum.create(SYSTEMS_TFhirNamingSystemTypeEnum[NamingSystemTypeNull], CODES_TFhirNamingSystemTypeEnum[NamingSystemTypeNull]) 
  else if (propName = 'date') then result := TFhirDateTime.create()
  else if (propName = 'publisher') then result := TFhirString.create()
  else if (propName = 'contact') then result := ContactList.new()
  else if (propName = 'responsible') then result := TFhirString.create()
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'description') then result := TFhirMarkdown.create()
  else if (propName = 'useContext') then result := UseContextList.new()
  else if (propName = 'jurisdiction') then result := JurisdictionList.new()
  else if (propName = 'usage') then result := TFhirString.create()
  else if (propName = 'uniqueId') then result := UniqueIdList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirNamingSystem.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'kind') then result := 'code'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'publisher') then result := 'string'
  else if (propName = 'contact') then result := 'ContactDetail'
  else if (propName = 'responsible') then result := 'string'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'description') then result := 'markdown'
  else if (propName = 'useContext') then result := 'UsageContext'
  else if (propName = 'jurisdiction') then result := 'CodeableConcept'
  else if (propName = 'usage') then result := 'string'
  else if (propName = 'uniqueId') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirNamingSystem.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'kind') then KindElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'publisher') then PublisherElement := nil
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value)
  else if (propName = 'responsible') then ResponsibleElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'useContext') then deletePropertyValue('useContext', UseContextList, value)
  else if (propName = 'jurisdiction') then deletePropertyValue('jurisdiction', JurisdictionList, value)
  else if (propName = 'usage') then UsageElement := nil
  else if (propName = 'uniqueId') then deletePropertyValue('uniqueId', UniqueIdList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirNamingSystem.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, new)
  else if (propName = 'kind') then KindElement := asEnum(SYSTEMS_TFhirNamingSystemTypeEnum, CODES_TFhirNamingSystemTypeEnum, new)
  else if (propName = 'date') then DateElement := asDateTime(new)
  else if (propName = 'publisher') then PublisherElement := asString(new)
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new)
  else if (propName = 'responsible') then ResponsibleElement := asString(new)
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'description') then DescriptionElement := asMarkdown(new)
  else if (propName = 'useContext') then replacePropertyValue('useContext', UseContextList, existing, new)
  else if (propName = 'jurisdiction') then replacePropertyValue('jurisdiction', JurisdictionList, existing, new)
  else if (propName = 'usage') then UsageElement := asString(new)
  else if (propName = 'uniqueId') then replacePropertyValue('uniqueId', UniqueIdList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirNamingSystem.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'contact') then ContactList.move(source, destination)
  else if (propName = 'useContext') then UseContextList.move(source, destination)
  else if (propName = 'jurisdiction') then JurisdictionList.move(source, destination)
  else if (propName = 'uniqueId') then UniqueIdList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirNamingSystem.fhirType : string;
begin
  result := 'NamingSystem';
end;

function TFhirNamingSystem.Link : TFhirNamingSystem;
begin
  result := TFhirNamingSystem(inherited Link);
end;

function TFhirNamingSystem.Clone : TFhirNamingSystem;
begin
  result := TFhirNamingSystem(inherited Clone);
end;

function TFhirNamingSystem.equals(other : TObject) : boolean; 
var
  o : TFhirNamingSystem;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirNamingSystem)) then
    result := false
  else
  begin
    o := TFhirNamingSystem(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(kindElement, o.kindElement, true) and compareDeep(dateElement, o.dateElement, true) and 
      compareDeep(publisherElement, o.publisherElement, true) and compareDeep(contactList, o.contactList, true) and 
      compareDeep(responsibleElement, o.responsibleElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(useContextList, o.useContextList, true) and 
      compareDeep(jurisdictionList, o.jurisdictionList, true) and compareDeep(usageElement, o.usageElement, true) and 
      compareDeep(uniqueIdList, o.uniqueIdList, true);
  end;
end;

function TFhirNamingSystem.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FStatus) and isEmptyProp(FKind) and isEmptyProp(FDate) and isEmptyProp(FPublisher) and isEmptyProp(FcontactList) and isEmptyProp(FResponsible) and isEmptyProp(FType_) and isEmptyProp(FDescription) and isEmptyProp(FuseContextList) and isEmptyProp(FjurisdictionList) and isEmptyProp(FUsage) and isEmptyProp(FuniqueIdList);
end;

procedure TFhirNamingSystem.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('name');
  fields.add('status');
  fields.add('kind');
  fields.add('date');
  fields.add('publisher');
  fields.add('contact');
  fields.add('responsible');
  fields.add('type');
  fields.add('description');
  fields.add('useContext');
  fields.add('jurisdiction');
  fields.add('usage');
  fields.add('uniqueId');
end;

function TFhirNamingSystem.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FContactList.sizeInBytes(magic));
  inc(result, FUseContextList.sizeInBytes(magic));
  inc(result, FJurisdictionList.sizeInBytes(magic));
  inc(result, FUniqueIdList.sizeInBytes(magic));
end;

procedure TFhirNamingSystem.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirNamingSystem.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirNamingSystem.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirNamingSystem.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirNamingSystem.GetStatusST : TFhirPublicationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirPublicationStatusEnum(0)
  else
    result := TFhirPublicationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirPublicationStatusEnum, FStatus.value));
end;

procedure TFhirNamingSystem.SetStatusST(value : TFhirPublicationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[value], CODES_TFhirPublicationStatusEnum[value]);
end;

procedure TFhirNamingSystem.SetKind(value : TFhirEnum);
begin
  FKind.free;
  FKind := value;
end;

function TFhirNamingSystem.GetKindST : TFhirNamingSystemTypeEnum;
begin
  if FKind = nil then
    result := TFhirNamingSystemTypeEnum(0)
  else
    result := TFhirNamingSystemTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirNamingSystemTypeEnum, FKind.value));
end;

procedure TFhirNamingSystem.SetKindST(value : TFhirNamingSystemTypeEnum);
begin
  if ord(value) = 0 then
    KindElement := nil
  else
    KindElement := TFhirEnum.create(SYSTEMS_TFhirNamingSystemTypeEnum[value], CODES_TFhirNamingSystemTypeEnum[value]);
end;

procedure TFhirNamingSystem.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

function TFhirNamingSystem.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirNamingSystem.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

procedure TFhirNamingSystem.SetPublisher(value : TFhirString);
begin
  FPublisher.free;
  FPublisher := value;
end;

function TFhirNamingSystem.GetPublisherST : String;
begin
  if FPublisher = nil then
    result := ''
  else
    result := FPublisher.value;
end;

procedure TFhirNamingSystem.SetPublisherST(value : String);
begin
  if value <> '' then
  begin
    if FPublisher = nil then
      FPublisher := TFhirString.create;
    FPublisher.value := value
  end
  else if FPublisher <> nil then
    FPublisher.value := '';
end;

function TFhirNamingSystem.GetContactList : TFhirContactDetailList;
begin
  if FContactList = nil then
    FContactList := TFhirContactDetailList.Create;
  result := FContactList;
end;

function TFhirNamingSystem.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

procedure TFhirNamingSystem.SetResponsible(value : TFhirString);
begin
  FResponsible.free;
  FResponsible := value;
end;

function TFhirNamingSystem.GetResponsibleST : String;
begin
  if FResponsible = nil then
    result := ''
  else
    result := FResponsible.value;
end;

procedure TFhirNamingSystem.SetResponsibleST(value : String);
begin
  if value <> '' then
  begin
    if FResponsible = nil then
      FResponsible := TFhirString.create;
    FResponsible.value := value
  end
  else if FResponsible <> nil then
    FResponsible.value := '';
end;

procedure TFhirNamingSystem.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirNamingSystem.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirNamingSystem.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirNamingSystem.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirNamingSystem.GetUseContextList : TFhirUsageContextList;
begin
  if FUseContextList = nil then
    FUseContextList := TFhirUsageContextList.Create;
  result := FUseContextList;
end;

function TFhirNamingSystem.GetHasUseContextList : boolean;
begin
  result := (FUseContextList <> nil) and (FUseContextList.count > 0);
end;

function TFhirNamingSystem.GetJurisdictionList : TFhirCodeableConceptList;
begin
  if FJurisdictionList = nil then
    FJurisdictionList := TFhirCodeableConceptList.Create;
  result := FJurisdictionList;
end;

function TFhirNamingSystem.GetHasJurisdictionList : boolean;
begin
  result := (FJurisdictionList <> nil) and (FJurisdictionList.count > 0);
end;

procedure TFhirNamingSystem.SetUsage(value : TFhirString);
begin
  FUsage.free;
  FUsage := value;
end;

function TFhirNamingSystem.GetUsageST : String;
begin
  if FUsage = nil then
    result := ''
  else
    result := FUsage.value;
end;

procedure TFhirNamingSystem.SetUsageST(value : String);
begin
  if value <> '' then
  begin
    if FUsage = nil then
      FUsage := TFhirString.create;
    FUsage.value := value
  end
  else if FUsage <> nil then
    FUsage.value := '';
end;

function TFhirNamingSystem.GetUniqueIdList : TFhirNamingSystemUniqueIdList;
begin
  if FUniqueIdList = nil then
    FUniqueIdList := TFhirNamingSystemUniqueIdList.Create;
  result := FUniqueIdList;
end;

function TFhirNamingSystem.GetHasUniqueIdList : boolean;
begin
  result := (FUniqueIdList <> nil) and (FUniqueIdList.count > 0);
end;

{ TFhirNamingSystemListEnumerator }

constructor TFhirNamingSystemListEnumerator.Create(list : TFhirNamingSystemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirNamingSystemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirNamingSystemListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirNamingSystemListEnumerator.GetCurrent : TFhirNamingSystem;
begin
  Result := FList[FIndex];
end;

function TFhirNamingSystemListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirNamingSystemList }

function TFhirNamingSystemList.AddItem(value: TFhirNamingSystem): TFhirNamingSystem;
begin
  assert(value.ClassName = 'TFhirNamingSystem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirNamingSystem');
  add(value);
  result := value;
end;

function TFhirNamingSystemList.Append: TFhirNamingSystem;
begin
  result := TFhirNamingSystem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNamingSystemList.ClearItems;
begin
  Clear;
end;

function TFhirNamingSystemList.GetEnumerator : TFhirNamingSystemListEnumerator;
begin
  result := TFhirNamingSystemListEnumerator.Create(self.link);
end;

function TFhirNamingSystemList.Clone: TFhirNamingSystemList;
begin
  result := TFhirNamingSystemList(inherited Clone);
end;

function TFhirNamingSystemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirNamingSystemList.GetItemN(index: Integer): TFhirNamingSystem;
begin
  result := TFhirNamingSystem(ObjectByIndex[index]);
end;

function TFhirNamingSystemList.ItemClass: TFslObjectClass;
begin
  result := TFhirNamingSystem;
end;
function TFhirNamingSystemList.IndexOf(value: TFhirNamingSystem): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirNamingSystemList.Insert(index: Integer): TFhirNamingSystem;
begin
  result := TFhirNamingSystem.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNamingSystemList.InsertItem(index: Integer; value: TFhirNamingSystem);
begin
  assert(value is TFhirNamingSystem);
  Inherited Insert(index, value);
end;

function TFhirNamingSystemList.Item(index: Integer): TFhirNamingSystem;
begin
  result := TFhirNamingSystem(ObjectByIndex[index]);
end;

function TFhirNamingSystemList.Link: TFhirNamingSystemList;
begin
  result := TFhirNamingSystemList(inherited Link);
end;

procedure TFhirNamingSystemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirNamingSystemList.SetItemByIndex(index: Integer; value: TFhirNamingSystem);
begin
  assert(value is TFhirNamingSystem);
  FhirNamingSystems[index] := value;
end;

procedure TFhirNamingSystemList.SetItemN(index: Integer; value: TFhirNamingSystem);
begin
  assert(value is TFhirNamingSystem);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_NAMINGSYSTEM}
{$IFDEF FHIR_OBSERVATIONDEFINITION}
{ TFhirObservationDefinitionQuantitativeDetails }

constructor TFhirObservationDefinitionQuantitativeDetails.Create;
begin
  inherited;
end;

destructor TFhirObservationDefinitionQuantitativeDetails.Destroy;
begin
  FCustomaryUnit.free;
  FUnit_.free;
  FConversionFactor.free;
  FDecimalPrecision.free;
  inherited;
end;

procedure TFhirObservationDefinitionQuantitativeDetails.Assign(oSource : TFslObject);
begin
  inherited;
  customaryUnit := TFhirObservationDefinitionQuantitativeDetails(oSource).customaryUnit.Clone;
  unit_ := TFhirObservationDefinitionQuantitativeDetails(oSource).unit_.Clone;
  conversionFactorElement := TFhirObservationDefinitionQuantitativeDetails(oSource).conversionFactorElement.Clone;
  decimalPrecisionElement := TFhirObservationDefinitionQuantitativeDetails(oSource).decimalPrecisionElement.Clone;
end;

procedure TFhirObservationDefinitionQuantitativeDetails.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'customaryUnit') Then
     list.add(self.link, 'customaryUnit', FCustomaryUnit.Link);
  if (child_name = 'unit') Then
     list.add(self.link, 'unit', FUnit_.Link);
  if (child_name = 'conversionFactor') Then
     list.add(self.link, 'conversionFactor', FConversionFactor.Link);
  if (child_name = 'decimalPrecision') Then
     list.add(self.link, 'decimalPrecision', FDecimalPrecision.Link);
end;

procedure TFhirObservationDefinitionQuantitativeDetails.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'customaryUnit', 'CodeableConcept', false, TFhirCodeableConcept, FCustomaryUnit.Link));
  oList.add(TFHIRProperty.create(self, 'unit', 'CodeableConcept', false, TFhirCodeableConcept, FUnit_.Link));
  oList.add(TFHIRProperty.create(self, 'conversionFactor', 'decimal', false, TFhirDecimal, FConversionFactor.Link));
  oList.add(TFHIRProperty.create(self, 'decimalPrecision', 'integer', false, TFhirInteger, FDecimalPrecision.Link));
end;

function TFhirObservationDefinitionQuantitativeDetails.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'customaryUnit') then
  begin
    CustomaryUnit := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'unit') then
  begin
    Unit_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'conversionFactor') then
  begin
    ConversionFactorElement := asDecimal(propValue);
    result := propValue;
  end
  else if (propName = 'decimalPrecision') then
  begin
    DecimalPrecisionElement := asInteger(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirObservationDefinitionQuantitativeDetails.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirObservationDefinitionQuantitativeDetails.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'customaryUnit') then result := TFhirCodeableConcept.create()
  else if (propName = 'unit') then result := TFhirCodeableConcept.create()
  else if (propName = 'conversionFactor') then result := TFhirDecimal.create()
  else if (propName = 'decimalPrecision') then result := TFhirInteger.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirObservationDefinitionQuantitativeDetails.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'customaryUnit') then result := 'CodeableConcept'
  else if (propName = 'unit') then result := 'CodeableConcept'
  else if (propName = 'conversionFactor') then result := 'decimal'
  else if (propName = 'decimalPrecision') then result := 'integer'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirObservationDefinitionQuantitativeDetails.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'customaryUnit') then CustomaryUnitElement := nil
  else if (propName = 'unit') then Unit_Element := nil
  else if (propName = 'conversionFactor') then ConversionFactorElement := nil
  else if (propName = 'decimalPrecision') then DecimalPrecisionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirObservationDefinitionQuantitativeDetails.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'customaryUnit') then CustomaryUnitElement := new as TFhirCodeableConcept
  else if (propName = 'unit') then Unit_Element := new as TFhirCodeableConcept
  else if (propName = 'conversionFactor') then ConversionFactorElement := asDecimal(new)
  else if (propName = 'decimalPrecision') then DecimalPrecisionElement := asInteger(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirObservationDefinitionQuantitativeDetails.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirObservationDefinitionQuantitativeDetails.fhirType : string;
begin
  result := 'ObservationDefinition.quantitativeDetails';
end;

function TFhirObservationDefinitionQuantitativeDetails.Link : TFhirObservationDefinitionQuantitativeDetails;
begin
  result := TFhirObservationDefinitionQuantitativeDetails(inherited Link);
end;

function TFhirObservationDefinitionQuantitativeDetails.Clone : TFhirObservationDefinitionQuantitativeDetails;
begin
  result := TFhirObservationDefinitionQuantitativeDetails(inherited Clone);
end;

function TFhirObservationDefinitionQuantitativeDetails.equals(other : TObject) : boolean; 
var
  o : TFhirObservationDefinitionQuantitativeDetails;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirObservationDefinitionQuantitativeDetails)) then
    result := false
  else
  begin
    o := TFhirObservationDefinitionQuantitativeDetails(other);
    result := compareDeep(customaryUnitElement, o.customaryUnitElement, true) and 
      compareDeep(unit_Element, o.unit_Element, true) and compareDeep(conversionFactorElement, o.conversionFactorElement, true) and 
      compareDeep(decimalPrecisionElement, o.decimalPrecisionElement, true);
  end;
end;

function TFhirObservationDefinitionQuantitativeDetails.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCustomaryUnit) and isEmptyProp(FUnit_) and isEmptyProp(FConversionFactor) and isEmptyProp(FDecimalPrecision);
end;

procedure TFhirObservationDefinitionQuantitativeDetails.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('customaryUnit');
  fields.add('unit');
  fields.add('conversionFactor');
  fields.add('decimalPrecision');
end;

function TFhirObservationDefinitionQuantitativeDetails.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirObservationDefinitionQuantitativeDetails.SetCustomaryUnit(value : TFhirCodeableConcept);
begin
  FCustomaryUnit.free;
  FCustomaryUnit := value;
end;

procedure TFhirObservationDefinitionQuantitativeDetails.SetUnit_(value : TFhirCodeableConcept);
begin
  FUnit_.free;
  FUnit_ := value;
end;

procedure TFhirObservationDefinitionQuantitativeDetails.SetConversionFactor(value : TFhirDecimal);
begin
  FConversionFactor.free;
  FConversionFactor := value;
end;

function TFhirObservationDefinitionQuantitativeDetails.GetConversionFactorST : String;
begin
  if FConversionFactor = nil then
    result := ''
  else
    result := FConversionFactor.value;
end;

procedure TFhirObservationDefinitionQuantitativeDetails.SetConversionFactorST(value : String);
begin
  if value <> '' then
  begin
    if FConversionFactor = nil then
      FConversionFactor := TFhirDecimal.create;
    FConversionFactor.value := value
  end
  else if FConversionFactor <> nil then
    FConversionFactor.value := '';
end;

procedure TFhirObservationDefinitionQuantitativeDetails.SetDecimalPrecision(value : TFhirInteger);
begin
  FDecimalPrecision.free;
  FDecimalPrecision := value;
end;

function TFhirObservationDefinitionQuantitativeDetails.GetDecimalPrecisionST : String;
begin
  if FDecimalPrecision = nil then
    result := ''
  else
    result := FDecimalPrecision.value;
end;

procedure TFhirObservationDefinitionQuantitativeDetails.SetDecimalPrecisionST(value : String);
begin
  if value <> '' then
  begin
    if FDecimalPrecision = nil then
      FDecimalPrecision := TFhirInteger.create;
    FDecimalPrecision.value := value
  end
  else if FDecimalPrecision <> nil then
    FDecimalPrecision.value := '';
end;

{ TFhirObservationDefinitionQuantitativeDetailsListEnumerator }

constructor TFhirObservationDefinitionQuantitativeDetailsListEnumerator.Create(list : TFhirObservationDefinitionQuantitativeDetailsList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirObservationDefinitionQuantitativeDetailsListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirObservationDefinitionQuantitativeDetailsListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirObservationDefinitionQuantitativeDetailsListEnumerator.GetCurrent : TFhirObservationDefinitionQuantitativeDetails;
begin
  Result := FList[FIndex];
end;

function TFhirObservationDefinitionQuantitativeDetailsListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirObservationDefinitionQuantitativeDetailsList }

function TFhirObservationDefinitionQuantitativeDetailsList.AddItem(value: TFhirObservationDefinitionQuantitativeDetails): TFhirObservationDefinitionQuantitativeDetails;
begin
  assert(value.ClassName = 'TFhirObservationDefinitionQuantitativeDetails', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirObservationDefinitionQuantitativeDetails');
  add(value);
  result := value;
end;

function TFhirObservationDefinitionQuantitativeDetailsList.Append: TFhirObservationDefinitionQuantitativeDetails;
begin
  result := TFhirObservationDefinitionQuantitativeDetails.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirObservationDefinitionQuantitativeDetailsList.ClearItems;
begin
  Clear;
end;

function TFhirObservationDefinitionQuantitativeDetailsList.GetEnumerator : TFhirObservationDefinitionQuantitativeDetailsListEnumerator;
begin
  result := TFhirObservationDefinitionQuantitativeDetailsListEnumerator.Create(self.link);
end;

function TFhirObservationDefinitionQuantitativeDetailsList.Clone: TFhirObservationDefinitionQuantitativeDetailsList;
begin
  result := TFhirObservationDefinitionQuantitativeDetailsList(inherited Clone);
end;

function TFhirObservationDefinitionQuantitativeDetailsList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirObservationDefinitionQuantitativeDetailsList.GetItemN(index: Integer): TFhirObservationDefinitionQuantitativeDetails;
begin
  result := TFhirObservationDefinitionQuantitativeDetails(ObjectByIndex[index]);
end;

function TFhirObservationDefinitionQuantitativeDetailsList.ItemClass: TFslObjectClass;
begin
  result := TFhirObservationDefinitionQuantitativeDetails;
end;
function TFhirObservationDefinitionQuantitativeDetailsList.IndexOf(value: TFhirObservationDefinitionQuantitativeDetails): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirObservationDefinitionQuantitativeDetailsList.Insert(index: Integer): TFhirObservationDefinitionQuantitativeDetails;
begin
  result := TFhirObservationDefinitionQuantitativeDetails.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirObservationDefinitionQuantitativeDetailsList.InsertItem(index: Integer; value: TFhirObservationDefinitionQuantitativeDetails);
begin
  assert(value is TFhirObservationDefinitionQuantitativeDetails);
  Inherited Insert(index, value);
end;

function TFhirObservationDefinitionQuantitativeDetailsList.Item(index: Integer): TFhirObservationDefinitionQuantitativeDetails;
begin
  result := TFhirObservationDefinitionQuantitativeDetails(ObjectByIndex[index]);
end;

function TFhirObservationDefinitionQuantitativeDetailsList.Link: TFhirObservationDefinitionQuantitativeDetailsList;
begin
  result := TFhirObservationDefinitionQuantitativeDetailsList(inherited Link);
end;

procedure TFhirObservationDefinitionQuantitativeDetailsList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirObservationDefinitionQuantitativeDetailsList.SetItemByIndex(index: Integer; value: TFhirObservationDefinitionQuantitativeDetails);
begin
  assert(value is TFhirObservationDefinitionQuantitativeDetails);
  FhirObservationDefinitionQuantitativeDetails[index] := value;
end;

procedure TFhirObservationDefinitionQuantitativeDetailsList.SetItemN(index: Integer; value: TFhirObservationDefinitionQuantitativeDetails);
begin
  assert(value is TFhirObservationDefinitionQuantitativeDetails);
  ObjectByIndex[index] := value;
end;

{ TFhirObservationDefinitionQualifiedInterval }

constructor TFhirObservationDefinitionQualifiedInterval.Create;
begin
  inherited;
end;

destructor TFhirObservationDefinitionQualifiedInterval.Destroy;
begin
  FCategory.free;
  FRange.free;
  FContext.free;
  FAppliesToList.Free;
  FGender.free;
  FAge.free;
  FGestationalAge.free;
  FCondition.free;
  inherited;
end;

procedure TFhirObservationDefinitionQualifiedInterval.Assign(oSource : TFslObject);
begin
  inherited;
  categoryElement := TFhirObservationDefinitionQualifiedInterval(oSource).categoryElement.Clone;
  range := TFhirObservationDefinitionQualifiedInterval(oSource).range.Clone;
  context := TFhirObservationDefinitionQualifiedInterval(oSource).context.Clone;
  if (TFhirObservationDefinitionQualifiedInterval(oSource).FAppliesToList = nil) then
  begin
    FAppliesToList.free;
    FAppliesToList := nil;
  end
  else
  begin
    if FAppliesToList = nil then
      FAppliesToList := TFhirCodeableConceptList.Create;
    FAppliesToList.Assign(TFhirObservationDefinitionQualifiedInterval(oSource).FAppliesToList);
  end;
  genderElement := TFhirObservationDefinitionQualifiedInterval(oSource).genderElement.Clone;
  age := TFhirObservationDefinitionQualifiedInterval(oSource).age.Clone;
  gestationalAge := TFhirObservationDefinitionQualifiedInterval(oSource).gestationalAge.Clone;
  conditionElement := TFhirObservationDefinitionQualifiedInterval(oSource).conditionElement.Clone;
end;

procedure TFhirObservationDefinitionQualifiedInterval.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'range') Then
     list.add(self.link, 'range', FRange.Link);
  if (child_name = 'context') Then
     list.add(self.link, 'context', FContext.Link);
  if (child_name = 'appliesTo') Then
    list.addAll(self, 'appliesTo', FAppliesToList);
  if (child_name = 'gender') Then
     list.add(self.link, 'gender', FGender.Link);
  if (child_name = 'age') Then
     list.add(self.link, 'age', FAge.Link);
  if (child_name = 'gestationalAge') Then
     list.add(self.link, 'gestationalAge', FGestationalAge.Link);
  if (child_name = 'condition') Then
     list.add(self.link, 'condition', FCondition.Link);
end;

procedure TFhirObservationDefinitionQualifiedInterval.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'category', 'code', false, TFhirEnum, FCategory.Link));
  oList.add(TFHIRProperty.create(self, 'range', 'Range', false, TFhirRange, FRange.Link));
  oList.add(TFHIRProperty.create(self, 'context', 'CodeableConcept', false, TFhirCodeableConcept, FContext.Link));
  oList.add(TFHIRProperty.create(self, 'appliesTo', 'CodeableConcept', true, TFhirCodeableConcept, FAppliesToList.Link));
  oList.add(TFHIRProperty.create(self, 'gender', 'code', false, TFhirEnum, FGender.Link));
  oList.add(TFHIRProperty.create(self, 'age', 'Range', false, TFhirRange, FAge.Link));
  oList.add(TFHIRProperty.create(self, 'gestationalAge', 'Range', false, TFhirRange, FGestationalAge.Link));
  oList.add(TFHIRProperty.create(self, 'condition', 'string', false, TFhirString, FCondition.Link));
end;

function TFhirObservationDefinitionQualifiedInterval.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'category') then
  begin
    CategoryElement := asEnum(SYSTEMS_TFhirObservationRangeCategoryEnum, CODES_TFhirObservationRangeCategoryEnum, propValue);
    result := propValue;
  end
  else if (propName = 'range') then
  begin
    Range := propValue as TFhirRange;
    result := propValue;
  end
  else if (propName = 'context') then
  begin
    Context := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'appliesTo') then
  begin
    AppliesToList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'gender') then
  begin
    GenderElement := asEnum(SYSTEMS_TFhirAdministrativeGenderEnum, CODES_TFhirAdministrativeGenderEnum, propValue);
    result := propValue;
  end
  else if (propName = 'age') then
  begin
    Age := propValue as TFhirRange;
    result := propValue;
  end
  else if (propName = 'gestationalAge') then
  begin
    GestationalAge := propValue as TFhirRange;
    result := propValue;
  end
  else if (propName = 'condition') then
  begin
    ConditionElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirObservationDefinitionQualifiedInterval.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'appliesTo') then AppliesToList.insertItem(index, propValue as TFhirCodeableConcept)
  else inherited;
end;

function TFhirObservationDefinitionQualifiedInterval.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'category') then result := TFhirEnum.create(SYSTEMS_TFhirObservationRangeCategoryEnum[ObservationRangeCategoryNull], CODES_TFhirObservationRangeCategoryEnum[ObservationRangeCategoryNull]) 
  else if (propName = 'range') then result := TFhirRange.create()
  else if (propName = 'context') then result := TFhirCodeableConcept.create()
  else if (propName = 'appliesTo') then result := AppliesToList.new()
  else if (propName = 'gender') then result := TFhirEnum.create(SYSTEMS_TFhirAdministrativeGenderEnum[AdministrativeGenderNull], CODES_TFhirAdministrativeGenderEnum[AdministrativeGenderNull]) 
  else if (propName = 'age') then result := TFhirRange.create()
  else if (propName = 'gestationalAge') then result := TFhirRange.create()
  else if (propName = 'condition') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirObservationDefinitionQualifiedInterval.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'category') then result := 'code'
  else if (propName = 'range') then result := 'Range'
  else if (propName = 'context') then result := 'CodeableConcept'
  else if (propName = 'appliesTo') then result := 'CodeableConcept'
  else if (propName = 'gender') then result := 'code'
  else if (propName = 'age') then result := 'Range'
  else if (propName = 'gestationalAge') then result := 'Range'
  else if (propName = 'condition') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirObservationDefinitionQualifiedInterval.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'category') then CategoryElement := nil
  else if (propName = 'range') then RangeElement := nil
  else if (propName = 'context') then ContextElement := nil
  else if (propName = 'appliesTo') then deletePropertyValue('appliesTo', AppliesToList, value)
  else if (propName = 'gender') then GenderElement := nil
  else if (propName = 'age') then AgeElement := nil
  else if (propName = 'gestationalAge') then GestationalAgeElement := nil
  else if (propName = 'condition') then ConditionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirObservationDefinitionQualifiedInterval.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'category') then CategoryElement := asEnum(SYSTEMS_TFhirObservationRangeCategoryEnum, CODES_TFhirObservationRangeCategoryEnum, new)
  else if (propName = 'range') then RangeElement := new as TFhirRange
  else if (propName = 'context') then ContextElement := new as TFhirCodeableConcept
  else if (propName = 'appliesTo') then replacePropertyValue('appliesTo', AppliesToList, existing, new)
  else if (propName = 'gender') then GenderElement := asEnum(SYSTEMS_TFhirAdministrativeGenderEnum, CODES_TFhirAdministrativeGenderEnum, new)
  else if (propName = 'age') then AgeElement := new as TFhirRange
  else if (propName = 'gestationalAge') then GestationalAgeElement := new as TFhirRange
  else if (propName = 'condition') then ConditionElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirObservationDefinitionQualifiedInterval.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'appliesTo') then AppliesToList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirObservationDefinitionQualifiedInterval.fhirType : string;
begin
  result := 'ObservationDefinition.qualifiedInterval';
end;

function TFhirObservationDefinitionQualifiedInterval.Link : TFhirObservationDefinitionQualifiedInterval;
begin
  result := TFhirObservationDefinitionQualifiedInterval(inherited Link);
end;

function TFhirObservationDefinitionQualifiedInterval.Clone : TFhirObservationDefinitionQualifiedInterval;
begin
  result := TFhirObservationDefinitionQualifiedInterval(inherited Clone);
end;

function TFhirObservationDefinitionQualifiedInterval.equals(other : TObject) : boolean; 
var
  o : TFhirObservationDefinitionQualifiedInterval;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirObservationDefinitionQualifiedInterval)) then
    result := false
  else
  begin
    o := TFhirObservationDefinitionQualifiedInterval(other);
    result := compareDeep(categoryElement, o.categoryElement, true) and compareDeep(rangeElement, o.rangeElement, true) and 
      compareDeep(contextElement, o.contextElement, true) and compareDeep(appliesToList, o.appliesToList, true) and 
      compareDeep(genderElement, o.genderElement, true) and compareDeep(ageElement, o.ageElement, true) and 
      compareDeep(gestationalAgeElement, o.gestationalAgeElement, true) and compareDeep(conditionElement, o.conditionElement, true);
  end;
end;

function TFhirObservationDefinitionQualifiedInterval.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCategory) and isEmptyProp(FRange) and isEmptyProp(FContext) and isEmptyProp(FappliesToList) and isEmptyProp(FGender) and isEmptyProp(FAge) and isEmptyProp(FGestationalAge) and isEmptyProp(FCondition);
end;

procedure TFhirObservationDefinitionQualifiedInterval.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('category');
  fields.add('range');
  fields.add('context');
  fields.add('appliesTo');
  fields.add('gender');
  fields.add('age');
  fields.add('gestationalAge');
  fields.add('condition');
end;

function TFhirObservationDefinitionQualifiedInterval.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FAppliesToList.sizeInBytes(magic));
end;

procedure TFhirObservationDefinitionQualifiedInterval.SetCategory(value : TFhirEnum);
begin
  FCategory.free;
  FCategory := value;
end;

function TFhirObservationDefinitionQualifiedInterval.GetCategoryST : TFhirObservationRangeCategoryEnum;
begin
  if FCategory = nil then
    result := TFhirObservationRangeCategoryEnum(0)
  else
    result := TFhirObservationRangeCategoryEnum(StringArrayIndexOfSensitive(CODES_TFhirObservationRangeCategoryEnum, FCategory.value));
end;

procedure TFhirObservationDefinitionQualifiedInterval.SetCategoryST(value : TFhirObservationRangeCategoryEnum);
begin
  if ord(value) = 0 then
    CategoryElement := nil
  else
    CategoryElement := TFhirEnum.create(SYSTEMS_TFhirObservationRangeCategoryEnum[value], CODES_TFhirObservationRangeCategoryEnum[value]);
end;

procedure TFhirObservationDefinitionQualifiedInterval.SetRange(value : TFhirRange);
begin
  FRange.free;
  FRange := value;
end;

procedure TFhirObservationDefinitionQualifiedInterval.SetContext(value : TFhirCodeableConcept);
begin
  FContext.free;
  FContext := value;
end;

function TFhirObservationDefinitionQualifiedInterval.GetAppliesToList : TFhirCodeableConceptList;
begin
  if FAppliesToList = nil then
    FAppliesToList := TFhirCodeableConceptList.Create;
  result := FAppliesToList;
end;

function TFhirObservationDefinitionQualifiedInterval.GetHasAppliesToList : boolean;
begin
  result := (FAppliesToList <> nil) and (FAppliesToList.count > 0);
end;

procedure TFhirObservationDefinitionQualifiedInterval.SetGender(value : TFhirEnum);
begin
  FGender.free;
  FGender := value;
end;

function TFhirObservationDefinitionQualifiedInterval.GetGenderST : TFhirAdministrativeGenderEnum;
begin
  if FGender = nil then
    result := TFhirAdministrativeGenderEnum(0)
  else
    result := TFhirAdministrativeGenderEnum(StringArrayIndexOfSensitive(CODES_TFhirAdministrativeGenderEnum, FGender.value));
end;

procedure TFhirObservationDefinitionQualifiedInterval.SetGenderST(value : TFhirAdministrativeGenderEnum);
begin
  if ord(value) = 0 then
    GenderElement := nil
  else
    GenderElement := TFhirEnum.create(SYSTEMS_TFhirAdministrativeGenderEnum[value], CODES_TFhirAdministrativeGenderEnum[value]);
end;

procedure TFhirObservationDefinitionQualifiedInterval.SetAge(value : TFhirRange);
begin
  FAge.free;
  FAge := value;
end;

procedure TFhirObservationDefinitionQualifiedInterval.SetGestationalAge(value : TFhirRange);
begin
  FGestationalAge.free;
  FGestationalAge := value;
end;

procedure TFhirObservationDefinitionQualifiedInterval.SetCondition(value : TFhirString);
begin
  FCondition.free;
  FCondition := value;
end;

function TFhirObservationDefinitionQualifiedInterval.GetConditionST : String;
begin
  if FCondition = nil then
    result := ''
  else
    result := FCondition.value;
end;

procedure TFhirObservationDefinitionQualifiedInterval.SetConditionST(value : String);
begin
  if value <> '' then
  begin
    if FCondition = nil then
      FCondition := TFhirString.create;
    FCondition.value := value
  end
  else if FCondition <> nil then
    FCondition.value := '';
end;

{ TFhirObservationDefinitionQualifiedIntervalListEnumerator }

constructor TFhirObservationDefinitionQualifiedIntervalListEnumerator.Create(list : TFhirObservationDefinitionQualifiedIntervalList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirObservationDefinitionQualifiedIntervalListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirObservationDefinitionQualifiedIntervalListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirObservationDefinitionQualifiedIntervalListEnumerator.GetCurrent : TFhirObservationDefinitionQualifiedInterval;
begin
  Result := FList[FIndex];
end;

function TFhirObservationDefinitionQualifiedIntervalListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirObservationDefinitionQualifiedIntervalList }

function TFhirObservationDefinitionQualifiedIntervalList.AddItem(value: TFhirObservationDefinitionQualifiedInterval): TFhirObservationDefinitionQualifiedInterval;
begin
  assert(value.ClassName = 'TFhirObservationDefinitionQualifiedInterval', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirObservationDefinitionQualifiedInterval');
  add(value);
  result := value;
end;

function TFhirObservationDefinitionQualifiedIntervalList.Append: TFhirObservationDefinitionQualifiedInterval;
begin
  result := TFhirObservationDefinitionQualifiedInterval.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirObservationDefinitionQualifiedIntervalList.ClearItems;
begin
  Clear;
end;

function TFhirObservationDefinitionQualifiedIntervalList.GetEnumerator : TFhirObservationDefinitionQualifiedIntervalListEnumerator;
begin
  result := TFhirObservationDefinitionQualifiedIntervalListEnumerator.Create(self.link);
end;

function TFhirObservationDefinitionQualifiedIntervalList.Clone: TFhirObservationDefinitionQualifiedIntervalList;
begin
  result := TFhirObservationDefinitionQualifiedIntervalList(inherited Clone);
end;

function TFhirObservationDefinitionQualifiedIntervalList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirObservationDefinitionQualifiedIntervalList.GetItemN(index: Integer): TFhirObservationDefinitionQualifiedInterval;
begin
  result := TFhirObservationDefinitionQualifiedInterval(ObjectByIndex[index]);
end;

function TFhirObservationDefinitionQualifiedIntervalList.ItemClass: TFslObjectClass;
begin
  result := TFhirObservationDefinitionQualifiedInterval;
end;
function TFhirObservationDefinitionQualifiedIntervalList.IndexOf(value: TFhirObservationDefinitionQualifiedInterval): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirObservationDefinitionQualifiedIntervalList.Insert(index: Integer): TFhirObservationDefinitionQualifiedInterval;
begin
  result := TFhirObservationDefinitionQualifiedInterval.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirObservationDefinitionQualifiedIntervalList.InsertItem(index: Integer; value: TFhirObservationDefinitionQualifiedInterval);
begin
  assert(value is TFhirObservationDefinitionQualifiedInterval);
  Inherited Insert(index, value);
end;

function TFhirObservationDefinitionQualifiedIntervalList.Item(index: Integer): TFhirObservationDefinitionQualifiedInterval;
begin
  result := TFhirObservationDefinitionQualifiedInterval(ObjectByIndex[index]);
end;

function TFhirObservationDefinitionQualifiedIntervalList.Link: TFhirObservationDefinitionQualifiedIntervalList;
begin
  result := TFhirObservationDefinitionQualifiedIntervalList(inherited Link);
end;

procedure TFhirObservationDefinitionQualifiedIntervalList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirObservationDefinitionQualifiedIntervalList.SetItemByIndex(index: Integer; value: TFhirObservationDefinitionQualifiedInterval);
begin
  assert(value is TFhirObservationDefinitionQualifiedInterval);
  FhirObservationDefinitionQualifiedIntervals[index] := value;
end;

procedure TFhirObservationDefinitionQualifiedIntervalList.SetItemN(index: Integer; value: TFhirObservationDefinitionQualifiedInterval);
begin
  assert(value is TFhirObservationDefinitionQualifiedInterval);
  ObjectByIndex[index] := value;
end;

{ TFhirObservationDefinition }

constructor TFhirObservationDefinition.Create;
begin
  inherited;
end;

destructor TFhirObservationDefinition.Destroy;
begin
  FCategoryList.Free;
  FCode.free;
  FIdentifierList.Free;
  FPermittedDataType.Free;
  FMultipleResultsAllowed.free;
  FMethod.free;
  FPreferredReportName.free;
  FQuantitativeDetails.free;
  FQualifiedIntervalList.Free;
  FValidCodedValueSet.free;
  FNormalCodedValueSet.free;
  FAbnormalCodedValueSet.free;
  FCriticalCodedValueSet.free;
  inherited;
end;

procedure TFhirObservationDefinition.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirObservationDefinition(oSource).FCategoryList = nil) then
  begin
    FCategoryList.free;
    FCategoryList := nil;
  end
  else
  begin
    if FCategoryList = nil then
      FCategoryList := TFhirCodeableConceptList.Create;
    FCategoryList.Assign(TFhirObservationDefinition(oSource).FCategoryList);
  end;
  code := TFhirObservationDefinition(oSource).code.Clone;
  if (TFhirObservationDefinition(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirObservationDefinition(oSource).FIdentifierList);
  end;
  if (TFhirObservationDefinition(oSource).FPermittedDataType = nil) then
  begin
    FPermittedDataType.free;
    FPermittedDataType := nil;
  end
  else
  begin
    FPermittedDataType := TFhirEnumList.Create(SYSTEMS_TFhirObservationDataTypeEnum, CODES_TFhirObservationDataTypeEnum);
    FPermittedDataType.Assign(TFhirObservationDefinition(oSource).FPermittedDataType);
  end;
  multipleResultsAllowedElement := TFhirObservationDefinition(oSource).multipleResultsAllowedElement.Clone;
  method := TFhirObservationDefinition(oSource).method.Clone;
  preferredReportNameElement := TFhirObservationDefinition(oSource).preferredReportNameElement.Clone;
  quantitativeDetails := TFhirObservationDefinition(oSource).quantitativeDetails.Clone;
  if (TFhirObservationDefinition(oSource).FQualifiedIntervalList = nil) then
  begin
    FQualifiedIntervalList.free;
    FQualifiedIntervalList := nil;
  end
  else
  begin
    if FQualifiedIntervalList = nil then
      FQualifiedIntervalList := TFhirObservationDefinitionQualifiedIntervalList.Create;
    FQualifiedIntervalList.Assign(TFhirObservationDefinition(oSource).FQualifiedIntervalList);
  end;
  validCodedValueSet := TFhirObservationDefinition(oSource).validCodedValueSet.Clone;
  normalCodedValueSet := TFhirObservationDefinition(oSource).normalCodedValueSet.Clone;
  abnormalCodedValueSet := TFhirObservationDefinition(oSource).abnormalCodedValueSet.Clone;
  criticalCodedValueSet := TFhirObservationDefinition(oSource).criticalCodedValueSet.Clone;
end;

function TFhirObservationDefinition.GetResourceType : TFhirResourceType;
begin
  result := frtObservationDefinition;
end;

procedure TFhirObservationDefinition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'category') Then
    list.addAll(self, 'category', FCategoryList);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'permittedDataType') Then
     list.addAll(self, 'permittedDataType', FPermittedDataType);
  if (child_name = 'multipleResultsAllowed') Then
     list.add(self.link, 'multipleResultsAllowed', FMultipleResultsAllowed.Link);
  if (child_name = 'method') Then
     list.add(self.link, 'method', FMethod.Link);
  if (child_name = 'preferredReportName') Then
     list.add(self.link, 'preferredReportName', FPreferredReportName.Link);
  if (child_name = 'quantitativeDetails') Then
     list.add(self.link, 'quantitativeDetails', FQuantitativeDetails.Link);
  if (child_name = 'qualifiedInterval') Then
    list.addAll(self, 'qualifiedInterval', FQualifiedIntervalList);
  if (child_name = 'validCodedValueSet') Then
     list.add(self.link, 'validCodedValueSet', FValidCodedValueSet.Link);
  if (child_name = 'normalCodedValueSet') Then
     list.add(self.link, 'normalCodedValueSet', FNormalCodedValueSet.Link);
  if (child_name = 'abnormalCodedValueSet') Then
     list.add(self.link, 'abnormalCodedValueSet', FAbnormalCodedValueSet.Link);
  if (child_name = 'criticalCodedValueSet') Then
     list.add(self.link, 'criticalCodedValueSet', FCriticalCodedValueSet.Link);
end;

procedure TFhirObservationDefinition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', true, TFhirCodeableConcept, FCategoryList.Link));
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'permittedDataType', 'code', true, TFhirEnum, FPermittedDataType.Link));
  oList.add(TFHIRProperty.create(self, 'multipleResultsAllowed', 'boolean', false, TFhirBoolean, FMultipleResultsAllowed.Link));
  oList.add(TFHIRProperty.create(self, 'method', 'CodeableConcept', false, TFhirCodeableConcept, FMethod.Link));
  oList.add(TFHIRProperty.create(self, 'preferredReportName', 'string', false, TFhirString, FPreferredReportName.Link));
  oList.add(TFHIRProperty.create(self, 'quantitativeDetails', 'BackboneElement', false, TFhirObservationDefinitionQuantitativeDetails, FQuantitativeDetails.Link));
  oList.add(TFHIRProperty.create(self, 'qualifiedInterval', 'BackboneElement', true, TFhirObservationDefinitionQualifiedInterval, FQualifiedIntervalList.Link));
  oList.add(TFHIRProperty.create(self, 'validCodedValueSet', 'Reference', false, TFhirReference, FValidCodedValueSet.Link));
  oList.add(TFHIRProperty.create(self, 'normalCodedValueSet', 'Reference', false, TFhirReference, FNormalCodedValueSet.Link));
  oList.add(TFHIRProperty.create(self, 'abnormalCodedValueSet', 'Reference', false, TFhirReference, FAbnormalCodedValueSet.Link));
  oList.add(TFHIRProperty.create(self, 'criticalCodedValueSet', 'Reference', false, TFhirReference, FCriticalCodedValueSet.Link));
end;

function TFhirObservationDefinition.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'category') then
  begin
    CategoryList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'permittedDataType') then
  begin
    PermittedDataTypeList.add(asEnum(SYSTEMS_TFhirObservationDataTypeEnum, CODES_TFhirObservationDataTypeEnum, propValue));
    result := propValue;
  end
  else if (propName = 'multipleResultsAllowed') then
  begin
    MultipleResultsAllowedElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'method') then
  begin
    Method := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'preferredReportName') then
  begin
    PreferredReportNameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'quantitativeDetails') then
  begin
    QuantitativeDetails := propValue as TFhirObservationDefinitionQuantitativeDetails;
    result := propValue;
  end
  else if (propName = 'qualifiedInterval') then
  begin
    QualifiedIntervalList.add(propValue as TFhirObservationDefinitionQualifiedInterval);
    result := propValue;
  end
  else if (propName = 'validCodedValueSet') then
  begin
    ValidCodedValueSet := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'normalCodedValueSet') then
  begin
    NormalCodedValueSet := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'abnormalCodedValueSet') then
  begin
    AbnormalCodedValueSet := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'criticalCodedValueSet') then
  begin
    CriticalCodedValueSet := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirObservationDefinition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'category') then CategoryList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'permittedDataType') then FPermittedDataType.insertItem(index, asEnum(SYSTEMS_TFhirObservationDataTypeEnum, CODES_TFhirObservationDataTypeEnum, propValue))
  else if (propName = 'qualifiedInterval') then QualifiedIntervalList.insertItem(index, propValue as TFhirObservationDefinitionQualifiedInterval)
  else inherited;
end;

function TFhirObservationDefinition.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'category') then result := CategoryList.new()
  else if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'multipleResultsAllowed') then result := TFhirBoolean.create()
  else if (propName = 'method') then result := TFhirCodeableConcept.create()
  else if (propName = 'preferredReportName') then result := TFhirString.create()
  else if (propName = 'quantitativeDetails') then result := TFhirObservationDefinitionQuantitativeDetails.create()
  else if (propName = 'qualifiedInterval') then result := QualifiedIntervalList.new()
  else if (propName = 'validCodedValueSet') then result := TFhirReference.create()
  else if (propName = 'normalCodedValueSet') then result := TFhirReference.create()
  else if (propName = 'abnormalCodedValueSet') then result := TFhirReference.create()
  else if (propName = 'criticalCodedValueSet') then result := TFhirReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirObservationDefinition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'permittedDataType') then result := 'code'
  else if (propName = 'multipleResultsAllowed') then result := 'boolean'
  else if (propName = 'method') then result := 'CodeableConcept'
  else if (propName = 'preferredReportName') then result := 'string'
  else if (propName = 'quantitativeDetails') then result := 'BackboneElement'
  else if (propName = 'qualifiedInterval') then result := 'BackboneElement'
  else if (propName = 'validCodedValueSet') then result := 'Reference'
  else if (propName = 'normalCodedValueSet') then result := 'Reference'
  else if (propName = 'abnormalCodedValueSet') then result := 'Reference'
  else if (propName = 'criticalCodedValueSet') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirObservationDefinition.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'category') then deletePropertyValue('category', CategoryList, value)
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'multipleResultsAllowed') then MultipleResultsAllowedElement := nil
  else if (propName = 'method') then MethodElement := nil
  else if (propName = 'preferredReportName') then PreferredReportNameElement := nil
  else if (propName = 'quantitativeDetails') then QuantitativeDetailsElement := nil
  else if (propName = 'qualifiedInterval') then deletePropertyValue('qualifiedInterval', QualifiedIntervalList, value)
  else if (propName = 'validCodedValueSet') then ValidCodedValueSetElement := nil
  else if (propName = 'normalCodedValueSet') then NormalCodedValueSetElement := nil
  else if (propName = 'abnormalCodedValueSet') then AbnormalCodedValueSetElement := nil
  else if (propName = 'criticalCodedValueSet') then CriticalCodedValueSetElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirObservationDefinition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'category') then replacePropertyValue('category', CategoryList, existing, new)
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'multipleResultsAllowed') then MultipleResultsAllowedElement := asBoolean(new)
  else if (propName = 'method') then MethodElement := new as TFhirCodeableConcept
  else if (propName = 'preferredReportName') then PreferredReportNameElement := asString(new)
  else if (propName = 'quantitativeDetails') then QuantitativeDetailsElement := new as TFhirObservationDefinitionQuantitativeDetails
  else if (propName = 'qualifiedInterval') then replacePropertyValue('qualifiedInterval', QualifiedIntervalList, existing, new)
  else if (propName = 'validCodedValueSet') then ValidCodedValueSetElement := new as TFhirReference
  else if (propName = 'normalCodedValueSet') then NormalCodedValueSetElement := new as TFhirReference
  else if (propName = 'abnormalCodedValueSet') then AbnormalCodedValueSetElement := new as TFhirReference
  else if (propName = 'criticalCodedValueSet') then CriticalCodedValueSetElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirObservationDefinition.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'category') then CategoryList.move(source, destination)
  else if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'permittedDataType') then FPermittedDataType.move(source, destination)
  else if (propName = 'qualifiedInterval') then QualifiedIntervalList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirObservationDefinition.fhirType : string;
begin
  result := 'ObservationDefinition';
end;

function TFhirObservationDefinition.Link : TFhirObservationDefinition;
begin
  result := TFhirObservationDefinition(inherited Link);
end;

function TFhirObservationDefinition.Clone : TFhirObservationDefinition;
begin
  result := TFhirObservationDefinition(inherited Clone);
end;

function TFhirObservationDefinition.equals(other : TObject) : boolean; 
var
  o : TFhirObservationDefinition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirObservationDefinition)) then
    result := false
  else
  begin
    o := TFhirObservationDefinition(other);
    result := compareDeep(categoryList, o.categoryList, true) and compareDeep(codeElement, o.codeElement, true) and 
      compareDeep(identifierList, o.identifierList, true) and compareDeep(permittedDataTypeList, o.permittedDataTypeList, true) and 
      compareDeep(multipleResultsAllowedElement, o.multipleResultsAllowedElement, true) and 
      compareDeep(methodElement, o.methodElement, true) and compareDeep(preferredReportNameElement, o.preferredReportNameElement, true) and 
      compareDeep(quantitativeDetailsElement, o.quantitativeDetailsElement, true) and 
      compareDeep(qualifiedIntervalList, o.qualifiedIntervalList, true) and compareDeep(validCodedValueSetElement, o.validCodedValueSetElement, true) and 
      compareDeep(normalCodedValueSetElement, o.normalCodedValueSetElement, true) and 
      compareDeep(abnormalCodedValueSetElement, o.abnormalCodedValueSetElement, true) and 
      compareDeep(criticalCodedValueSetElement, o.criticalCodedValueSetElement, true);
  end;
end;

function TFhirObservationDefinition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FcategoryList) and isEmptyProp(FCode) and isEmptyProp(FidentifierList) and isEmptyProp(FPermittedDataType) and isEmptyProp(FMultipleResultsAllowed) and isEmptyProp(FMethod) and isEmptyProp(FPreferredReportName) and isEmptyProp(FQuantitativeDetails) and isEmptyProp(FqualifiedIntervalList) and isEmptyProp(FValidCodedValueSet) and isEmptyProp(FNormalCodedValueSet) and isEmptyProp(FAbnormalCodedValueSet) and isEmptyProp(FCriticalCodedValueSet);
end;

procedure TFhirObservationDefinition.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('category');
  fields.add('code');
  fields.add('identifier');
  fields.add('permittedDataType');
  fields.add('multipleResultsAllowed');
  fields.add('method');
  fields.add('preferredReportName');
  fields.add('quantitativeDetails');
  fields.add('qualifiedInterval');
  fields.add('validCodedValueSet');
  fields.add('normalCodedValueSet');
  fields.add('abnormalCodedValueSet');
  fields.add('criticalCodedValueSet');
end;

function TFhirObservationDefinition.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FCategoryList.sizeInBytes(magic));
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FPermittedDataType.sizeInBytes(magic));
  inc(result, FQualifiedIntervalList.sizeInBytes(magic));
end;

function TFhirObservationDefinition.GetCategoryList : TFhirCodeableConceptList;
begin
  if FCategoryList = nil then
    FCategoryList := TFhirCodeableConceptList.Create;
  result := FCategoryList;
end;

function TFhirObservationDefinition.GetHasCategoryList : boolean;
begin
  result := (FCategoryList <> nil) and (FCategoryList.count > 0);
end;

procedure TFhirObservationDefinition.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

function TFhirObservationDefinition.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirObservationDefinition.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

function TFhirObservationDefinition.GetPermittedDataType : TFhirEnumList;
begin
  if FPermittedDataType = nil then
    FPermittedDataType := TFhirEnumList.Create(SYSTEMS_TFhirObservationDataTypeEnum, CODES_TFhirObservationDataTypeEnum);
  result := FPermittedDataType;
end;

function TFhirObservationDefinition.GetHasPermittedDataType : boolean;
begin
  result := (FPermittedDataType <> nil) and (FPermittedDataType.count > 0);
end;

function TFhirObservationDefinition.GetPermittedDataTypeST : TFhirObservationDataTypeEnumList;
  var i : integer;
begin
  result := [];
  if FpermittedDataType <> nil then
    for i := 0 to FpermittedDataType.count - 1 do
      result := result + [TFhirObservationDataTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirObservationDataTypeEnum, FpermittedDataType[i].value))];
end;

procedure TFhirObservationDefinition.SetPermittedDataTypeST(value : TFhirObservationDataTypeEnumList);
var a : TFhirObservationDataTypeEnum;
begin
  if FpermittedDataType = nil then
    FpermittedDataType := TFhirEnumList.create(SYSTEMS_TFhirObservationDataTypeEnum, CODES_TFhirObservationDataTypeEnum);
  FpermittedDataType.clear;
  for a := low(TFhirObservationDataTypeEnum) to high(TFhirObservationDataTypeEnum) do
    if a in value then
      begin
         if FpermittedDataType = nil then
           FpermittedDataType := TFhirEnumList.create(SYSTEMS_TFhirObservationDataTypeEnum, CODES_TFhirObservationDataTypeEnum);
         FpermittedDataType.add(TFhirEnum.create(SYSTEMS_TFhirObservationDataTypeEnum[a], CODES_TFhirObservationDataTypeEnum[a]));
      end;
end;

procedure TFhirObservationDefinition.SetMultipleResultsAllowed(value : TFhirBoolean);
begin
  FMultipleResultsAllowed.free;
  FMultipleResultsAllowed := value;
end;

function TFhirObservationDefinition.GetMultipleResultsAllowedST : Boolean;
begin
  if FMultipleResultsAllowed = nil then
    result := false
  else
    result := FMultipleResultsAllowed.value;
end;

procedure TFhirObservationDefinition.SetMultipleResultsAllowedST(value : Boolean);
begin
  if FMultipleResultsAllowed = nil then
    FMultipleResultsAllowed := TFhirBoolean.create;
  FMultipleResultsAllowed.value := value
end;

procedure TFhirObservationDefinition.SetMethod(value : TFhirCodeableConcept);
begin
  FMethod.free;
  FMethod := value;
end;

procedure TFhirObservationDefinition.SetPreferredReportName(value : TFhirString);
begin
  FPreferredReportName.free;
  FPreferredReportName := value;
end;

function TFhirObservationDefinition.GetPreferredReportNameST : String;
begin
  if FPreferredReportName = nil then
    result := ''
  else
    result := FPreferredReportName.value;
end;

procedure TFhirObservationDefinition.SetPreferredReportNameST(value : String);
begin
  if value <> '' then
  begin
    if FPreferredReportName = nil then
      FPreferredReportName := TFhirString.create;
    FPreferredReportName.value := value
  end
  else if FPreferredReportName <> nil then
    FPreferredReportName.value := '';
end;

procedure TFhirObservationDefinition.SetQuantitativeDetails(value : TFhirObservationDefinitionQuantitativeDetails);
begin
  FQuantitativeDetails.free;
  FQuantitativeDetails := value;
end;

function TFhirObservationDefinition.GetQualifiedIntervalList : TFhirObservationDefinitionQualifiedIntervalList;
begin
  if FQualifiedIntervalList = nil then
    FQualifiedIntervalList := TFhirObservationDefinitionQualifiedIntervalList.Create;
  result := FQualifiedIntervalList;
end;

function TFhirObservationDefinition.GetHasQualifiedIntervalList : boolean;
begin
  result := (FQualifiedIntervalList <> nil) and (FQualifiedIntervalList.count > 0);
end;

procedure TFhirObservationDefinition.SetValidCodedValueSet(value : TFhirReference);
begin
  FValidCodedValueSet.free;
  FValidCodedValueSet := value;
end;

procedure TFhirObservationDefinition.SetNormalCodedValueSet(value : TFhirReference);
begin
  FNormalCodedValueSet.free;
  FNormalCodedValueSet := value;
end;

procedure TFhirObservationDefinition.SetAbnormalCodedValueSet(value : TFhirReference);
begin
  FAbnormalCodedValueSet.free;
  FAbnormalCodedValueSet := value;
end;

procedure TFhirObservationDefinition.SetCriticalCodedValueSet(value : TFhirReference);
begin
  FCriticalCodedValueSet.free;
  FCriticalCodedValueSet := value;
end;

{ TFhirObservationDefinitionListEnumerator }

constructor TFhirObservationDefinitionListEnumerator.Create(list : TFhirObservationDefinitionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirObservationDefinitionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirObservationDefinitionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirObservationDefinitionListEnumerator.GetCurrent : TFhirObservationDefinition;
begin
  Result := FList[FIndex];
end;

function TFhirObservationDefinitionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirObservationDefinitionList }

function TFhirObservationDefinitionList.AddItem(value: TFhirObservationDefinition): TFhirObservationDefinition;
begin
  assert(value.ClassName = 'TFhirObservationDefinition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirObservationDefinition');
  add(value);
  result := value;
end;

function TFhirObservationDefinitionList.Append: TFhirObservationDefinition;
begin
  result := TFhirObservationDefinition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirObservationDefinitionList.ClearItems;
begin
  Clear;
end;

function TFhirObservationDefinitionList.GetEnumerator : TFhirObservationDefinitionListEnumerator;
begin
  result := TFhirObservationDefinitionListEnumerator.Create(self.link);
end;

function TFhirObservationDefinitionList.Clone: TFhirObservationDefinitionList;
begin
  result := TFhirObservationDefinitionList(inherited Clone);
end;

function TFhirObservationDefinitionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirObservationDefinitionList.GetItemN(index: Integer): TFhirObservationDefinition;
begin
  result := TFhirObservationDefinition(ObjectByIndex[index]);
end;

function TFhirObservationDefinitionList.ItemClass: TFslObjectClass;
begin
  result := TFhirObservationDefinition;
end;
function TFhirObservationDefinitionList.IndexOf(value: TFhirObservationDefinition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirObservationDefinitionList.Insert(index: Integer): TFhirObservationDefinition;
begin
  result := TFhirObservationDefinition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirObservationDefinitionList.InsertItem(index: Integer; value: TFhirObservationDefinition);
begin
  assert(value is TFhirObservationDefinition);
  Inherited Insert(index, value);
end;

function TFhirObservationDefinitionList.Item(index: Integer): TFhirObservationDefinition;
begin
  result := TFhirObservationDefinition(ObjectByIndex[index]);
end;

function TFhirObservationDefinitionList.Link: TFhirObservationDefinitionList;
begin
  result := TFhirObservationDefinitionList(inherited Link);
end;

procedure TFhirObservationDefinitionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirObservationDefinitionList.SetItemByIndex(index: Integer; value: TFhirObservationDefinition);
begin
  assert(value is TFhirObservationDefinition);
  FhirObservationDefinitions[index] := value;
end;

procedure TFhirObservationDefinitionList.SetItemN(index: Integer; value: TFhirObservationDefinition);
begin
  assert(value is TFhirObservationDefinition);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_OBSERVATIONDEFINITION}
{$IFDEF FHIR_OPERATIONDEFINITION}
{ TFhirOperationDefinitionParameter }

constructor TFhirOperationDefinitionParameter.Create;
begin
  inherited;
end;

destructor TFhirOperationDefinitionParameter.Destroy;
begin
  FName.free;
  FUse.free;
  FMin.free;
  FMax.free;
  FDocumentation.free;
  FType_.free;
  FTargetProfileList.Free;
  FSearchType.free;
  FBinding.free;
  FReferencedFromList.Free;
  FPartList.Free;
  inherited;
end;

procedure TFhirOperationDefinitionParameter.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirOperationDefinitionParameter(oSource).nameElement.Clone;
  useElement := TFhirOperationDefinitionParameter(oSource).useElement.Clone;
  minElement := TFhirOperationDefinitionParameter(oSource).minElement.Clone;
  maxElement := TFhirOperationDefinitionParameter(oSource).maxElement.Clone;
  documentationElement := TFhirOperationDefinitionParameter(oSource).documentationElement.Clone;
  type_Element := TFhirOperationDefinitionParameter(oSource).type_Element.Clone;
  if (TFhirOperationDefinitionParameter(oSource).FTargetProfileList = nil) then
  begin
    FTargetProfileList.free;
    FTargetProfileList := nil;
  end
  else
  begin
    if FTargetProfileList = nil then
      FTargetProfileList := TFhirCanonicalList.Create;
    FTargetProfileList.Assign(TFhirOperationDefinitionParameter(oSource).FTargetProfileList);
  end;
  searchTypeElement := TFhirOperationDefinitionParameter(oSource).searchTypeElement.Clone;
  binding := TFhirOperationDefinitionParameter(oSource).binding.Clone;
  if (TFhirOperationDefinitionParameter(oSource).FReferencedFromList = nil) then
  begin
    FReferencedFromList.free;
    FReferencedFromList := nil;
  end
  else
  begin
    if FReferencedFromList = nil then
      FReferencedFromList := TFhirOperationDefinitionParameterReferencedFromList.Create;
    FReferencedFromList.Assign(TFhirOperationDefinitionParameter(oSource).FReferencedFromList);
  end;
  if (TFhirOperationDefinitionParameter(oSource).FPartList = nil) then
  begin
    FPartList.free;
    FPartList := nil;
  end
  else
  begin
    if FPartList = nil then
      FPartList := TFhirOperationDefinitionParameterList.Create;
    FPartList.Assign(TFhirOperationDefinitionParameter(oSource).FPartList);
  end;
end;

procedure TFhirOperationDefinitionParameter.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'use') Then
     list.add(self.link, 'use', FUse.Link);
  if (child_name = 'min') Then
     list.add(self.link, 'min', FMin.Link);
  if (child_name = 'max') Then
     list.add(self.link, 'max', FMax.Link);
  if (child_name = 'documentation') Then
     list.add(self.link, 'documentation', FDocumentation.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'targetProfile') Then
    list.addAll(self, 'targetProfile', FTargetProfileList);
  if (child_name = 'searchType') Then
     list.add(self.link, 'searchType', FSearchType.Link);
  if (child_name = 'binding') Then
     list.add(self.link, 'binding', FBinding.Link);
  if (child_name = 'referencedFrom') Then
    list.addAll(self, 'referencedFrom', FReferencedFromList);
  if (child_name = 'part') Then
    list.addAll(self, 'part', FPartList);
end;

procedure TFhirOperationDefinitionParameter.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'code', false, TFhirCode, FName.Link));
  oList.add(TFHIRProperty.create(self, 'use', 'code', false, TFhirEnum, FUse.Link));
  oList.add(TFHIRProperty.create(self, 'min', 'integer', false, TFhirInteger, FMin.Link));
  oList.add(TFHIRProperty.create(self, 'max', 'string', false, TFhirString, FMax.Link));
  oList.add(TFHIRProperty.create(self, 'documentation', 'string', false, TFhirString, FDocumentation.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFhirEnum, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'targetProfile', 'canonical', true, TFhirCanonical, FTargetProfileList.Link));
  oList.add(TFHIRProperty.create(self, 'searchType', 'code', false, TFhirEnum, FSearchType.Link));
  oList.add(TFHIRProperty.create(self, 'binding', 'BackboneElement', false, TFhirOperationDefinitionParameterBinding, FBinding.Link));
  oList.add(TFHIRProperty.create(self, 'referencedFrom', 'BackboneElement', true, TFhirOperationDefinitionParameterReferencedFrom, FReferencedFromList.Link));
  oList.add(TFHIRProperty.create(self, 'part', '', true, TFhirOperationDefinitionParameter, FPartList.Link));
end;

function TFhirOperationDefinitionParameter.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'use') then
  begin
    UseElement := asEnum(SYSTEMS_TFhirOperationParameterUseEnum, CODES_TFhirOperationParameterUseEnum, propValue);
    result := propValue;
  end
  else if (propName = 'min') then
  begin
    MinElement := asInteger(propValue);
    result := propValue;
  end
  else if (propName = 'max') then
  begin
    MaxElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'documentation') then
  begin
    DocumentationElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirAllTypesEnum, CODES_TFhirAllTypesEnum, propValue);
    result := propValue;
  end
  else if (propName = 'targetProfile') then
  begin
    TargetProfileList.add(asCanonical(propValue)){2};     result := propValue;

  end
  else if (propName = 'searchType') then
  begin
    SearchTypeElement := asEnum(SYSTEMS_TFhirSearchParamTypeEnum, CODES_TFhirSearchParamTypeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'binding') then
  begin
    Binding := propValue as TFhirOperationDefinitionParameterBinding;
    result := propValue;
  end
  else if (propName = 'referencedFrom') then
  begin
    ReferencedFromList.add(propValue as TFhirOperationDefinitionParameterReferencedFrom);
    result := propValue;
  end
  else if (propName = 'part') then
  begin
    PartList.add(propValue as TFhirOperationDefinitionParameter);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirOperationDefinitionParameter.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'targetProfile') then TargetProfileList.insertItem(index, asCanonical(propValue))
  else if (propName = 'referencedFrom') then ReferencedFromList.insertItem(index, propValue as TFhirOperationDefinitionParameterReferencedFrom)
  else if (propName = 'part') then PartList.insertItem(index, propValue as TFhirOperationDefinitionParameter)
  else inherited;
end;

function TFhirOperationDefinitionParameter.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirCode.create()
  else if (propName = 'use') then result := TFhirEnum.create(SYSTEMS_TFhirOperationParameterUseEnum[OperationParameterUseNull], CODES_TFhirOperationParameterUseEnum[OperationParameterUseNull]) 
  else if (propName = 'min') then result := TFhirInteger.create()
  else if (propName = 'max') then result := TFhirString.create()
  else if (propName = 'documentation') then result := TFhirString.create()
  else if (propName = 'type') then result := TFhirEnum.create(SYSTEMS_TFhirAllTypesEnum[AllTypesNull], CODES_TFhirAllTypesEnum[AllTypesNull]) 
  else if (propName = 'targetProfile') then result := TargetProfileList.new()
  else if (propName = 'searchType') then result := TFhirEnum.create(SYSTEMS_TFhirSearchParamTypeEnum[SearchParamTypeNull], CODES_TFhirSearchParamTypeEnum[SearchParamTypeNull]) 
  else if (propName = 'binding') then result := TFhirOperationDefinitionParameterBinding.create()
  else if (propName = 'referencedFrom') then result := ReferencedFromList.new()
  else if (propName = 'part') then result := PartList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirOperationDefinitionParameter.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'code'
  else if (propName = 'use') then result := 'code'
  else if (propName = 'min') then result := 'integer'
  else if (propName = 'max') then result := 'string'
  else if (propName = 'documentation') then result := 'string'
  else if (propName = 'type') then result := 'code'
  else if (propName = 'targetProfile') then result := 'canonical'
  else if (propName = 'searchType') then result := 'code'
  else if (propName = 'binding') then result := 'BackboneElement'
  else if (propName = 'referencedFrom') then result := 'BackboneElement'
  else if (propName = 'part') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirOperationDefinitionParameter.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'use') then UseElement := nil
  else if (propName = 'min') then MinElement := nil
  else if (propName = 'max') then MaxElement := nil
  else if (propName = 'documentation') then DocumentationElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'targetProfile') then deletePropertyValue('targetProfile', TargetProfileList, value)
  else if (propName = 'searchType') then SearchTypeElement := nil
  else if (propName = 'binding') then BindingElement := nil
  else if (propName = 'referencedFrom') then deletePropertyValue('referencedFrom', ReferencedFromList, value)
  else if (propName = 'part') then deletePropertyValue('part', PartList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirOperationDefinitionParameter.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asCode(new)
  else if (propName = 'use') then UseElement := asEnum(SYSTEMS_TFhirOperationParameterUseEnum, CODES_TFhirOperationParameterUseEnum, new)
  else if (propName = 'min') then MinElement := asInteger(new)
  else if (propName = 'max') then MaxElement := asString(new)
  else if (propName = 'documentation') then DocumentationElement := asString(new)
  else if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirAllTypesEnum, CODES_TFhirAllTypesEnum, new)
  else if (propName = 'targetProfile') then replacePropertyValue('targetProfile', TargetProfileList, existing, new)
  else if (propName = 'searchType') then SearchTypeElement := asEnum(SYSTEMS_TFhirSearchParamTypeEnum, CODES_TFhirSearchParamTypeEnum, new)
  else if (propName = 'binding') then BindingElement := new as TFhirOperationDefinitionParameterBinding
  else if (propName = 'referencedFrom') then replacePropertyValue('referencedFrom', ReferencedFromList, existing, new)
  else if (propName = 'part') then replacePropertyValue('part', PartList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirOperationDefinitionParameter.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'targetProfile') then TargetProfileList.move(source, destination)
  else if (propName = 'referencedFrom') then ReferencedFromList.move(source, destination)
  else if (propName = 'part') then PartList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirOperationDefinitionParameter.fhirType : string;
begin
  result := 'OperationDefinition.parameter';
end;

function TFhirOperationDefinitionParameter.Link : TFhirOperationDefinitionParameter;
begin
  result := TFhirOperationDefinitionParameter(inherited Link);
end;

function TFhirOperationDefinitionParameter.Clone : TFhirOperationDefinitionParameter;
begin
  result := TFhirOperationDefinitionParameter(inherited Clone);
end;

function TFhirOperationDefinitionParameter.equals(other : TObject) : boolean; 
var
  o : TFhirOperationDefinitionParameter;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirOperationDefinitionParameter)) then
    result := false
  else
  begin
    o := TFhirOperationDefinitionParameter(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(useElement, o.useElement, true) and 
      compareDeep(minElement, o.minElement, true) and compareDeep(maxElement, o.maxElement, true) and 
      compareDeep(documentationElement, o.documentationElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(targetProfileList, o.targetProfileList, true) and compareDeep(searchTypeElement, o.searchTypeElement, true) and 
      compareDeep(bindingElement, o.bindingElement, true) and compareDeep(referencedFromList, o.referencedFromList, true) and 
      compareDeep(partList, o.partList, true);
  end;
end;

function TFhirOperationDefinitionParameter.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FUse) and isEmptyProp(FMin) and isEmptyProp(FMax) and isEmptyProp(FDocumentation) and isEmptyProp(FType_) and isEmptyProp(FtargetProfileList) and isEmptyProp(FSearchType) and isEmptyProp(FBinding) and isEmptyProp(FreferencedFromList) and isEmptyProp(FpartList);
end;

procedure TFhirOperationDefinitionParameter.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('name');
  fields.add('use');
  fields.add('min');
  fields.add('max');
  fields.add('documentation');
  fields.add('type');
  fields.add('targetProfile');
  fields.add('searchType');
  fields.add('binding');
  fields.add('referencedFrom');
  fields.add('part');
end;

function TFhirOperationDefinitionParameter.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FTargetProfileList.sizeInBytes(magic));
  inc(result, FReferencedFromList.sizeInBytes(magic));
  inc(result, FPartList.sizeInBytes(magic));
end;

procedure TFhirOperationDefinitionParameter.SetName(value : TFhirCode);
begin
  FName.free;
  FName := value;
end;

function TFhirOperationDefinitionParameter.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirOperationDefinitionParameter.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirCode.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirOperationDefinitionParameter.SetUse(value : TFhirEnum);
begin
  FUse.free;
  FUse := value;
end;

function TFhirOperationDefinitionParameter.GetUseST : TFhirOperationParameterUseEnum;
begin
  if FUse = nil then
    result := TFhirOperationParameterUseEnum(0)
  else
    result := TFhirOperationParameterUseEnum(StringArrayIndexOfSensitive(CODES_TFhirOperationParameterUseEnum, FUse.value));
end;

procedure TFhirOperationDefinitionParameter.SetUseST(value : TFhirOperationParameterUseEnum);
begin
  if ord(value) = 0 then
    UseElement := nil
  else
    UseElement := TFhirEnum.create(SYSTEMS_TFhirOperationParameterUseEnum[value], CODES_TFhirOperationParameterUseEnum[value]);
end;

procedure TFhirOperationDefinitionParameter.SetMin(value : TFhirInteger);
begin
  FMin.free;
  FMin := value;
end;

function TFhirOperationDefinitionParameter.GetMinST : String;
begin
  if FMin = nil then
    result := ''
  else
    result := FMin.value;
end;

procedure TFhirOperationDefinitionParameter.SetMinST(value : String);
begin
  if value <> '' then
  begin
    if FMin = nil then
      FMin := TFhirInteger.create;
    FMin.value := value
  end
  else if FMin <> nil then
    FMin.value := '';
end;

procedure TFhirOperationDefinitionParameter.SetMax(value : TFhirString);
begin
  FMax.free;
  FMax := value;
end;

function TFhirOperationDefinitionParameter.GetMaxST : String;
begin
  if FMax = nil then
    result := ''
  else
    result := FMax.value;
end;

procedure TFhirOperationDefinitionParameter.SetMaxST(value : String);
begin
  if value <> '' then
  begin
    if FMax = nil then
      FMax := TFhirString.create;
    FMax.value := value
  end
  else if FMax <> nil then
    FMax.value := '';
end;

procedure TFhirOperationDefinitionParameter.SetDocumentation(value : TFhirString);
begin
  FDocumentation.free;
  FDocumentation := value;
end;

function TFhirOperationDefinitionParameter.GetDocumentationST : String;
begin
  if FDocumentation = nil then
    result := ''
  else
    result := FDocumentation.value;
end;

procedure TFhirOperationDefinitionParameter.SetDocumentationST(value : String);
begin
  if value <> '' then
  begin
    if FDocumentation = nil then
      FDocumentation := TFhirString.create;
    FDocumentation.value := value
  end
  else if FDocumentation <> nil then
    FDocumentation.value := '';
end;

procedure TFhirOperationDefinitionParameter.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirOperationDefinitionParameter.GetType_ST : TFhirAllTypesEnum;
begin
  if FType_ = nil then
    result := TFhirAllTypesEnum(0)
  else
    result := TFhirAllTypesEnum(StringArrayIndexOfSensitive(CODES_TFhirAllTypesEnum, FType_.value));
end;

procedure TFhirOperationDefinitionParameter.SetType_ST(value : TFhirAllTypesEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirAllTypesEnum[value], CODES_TFhirAllTypesEnum[value]);
end;

function TFhirOperationDefinitionParameter.GetTargetProfileList : TFhirCanonicalList;
begin
  if FTargetProfileList = nil then
    FTargetProfileList := TFhirCanonicalList.Create;
  result := FTargetProfileList;
end;

function TFhirOperationDefinitionParameter.GetHasTargetProfileList : boolean;
begin
  result := (FTargetProfileList <> nil) and (FTargetProfileList.count > 0);
end;

procedure TFhirOperationDefinitionParameter.SetSearchType(value : TFhirEnum);
begin
  FSearchType.free;
  FSearchType := value;
end;

function TFhirOperationDefinitionParameter.GetSearchTypeST : TFhirSearchParamTypeEnum;
begin
  if FSearchType = nil then
    result := TFhirSearchParamTypeEnum(0)
  else
    result := TFhirSearchParamTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirSearchParamTypeEnum, FSearchType.value));
end;

procedure TFhirOperationDefinitionParameter.SetSearchTypeST(value : TFhirSearchParamTypeEnum);
begin
  if ord(value) = 0 then
    SearchTypeElement := nil
  else
    SearchTypeElement := TFhirEnum.create(SYSTEMS_TFhirSearchParamTypeEnum[value], CODES_TFhirSearchParamTypeEnum[value]);
end;

procedure TFhirOperationDefinitionParameter.SetBinding(value : TFhirOperationDefinitionParameterBinding);
begin
  FBinding.free;
  FBinding := value;
end;

function TFhirOperationDefinitionParameter.GetReferencedFromList : TFhirOperationDefinitionParameterReferencedFromList;
begin
  if FReferencedFromList = nil then
    FReferencedFromList := TFhirOperationDefinitionParameterReferencedFromList.Create;
  result := FReferencedFromList;
end;

function TFhirOperationDefinitionParameter.GetHasReferencedFromList : boolean;
begin
  result := (FReferencedFromList <> nil) and (FReferencedFromList.count > 0);
end;

function TFhirOperationDefinitionParameter.GetPartList : TFhirOperationDefinitionParameterList;
begin
  if FPartList = nil then
    FPartList := TFhirOperationDefinitionParameterList.Create;
  result := FPartList;
end;

function TFhirOperationDefinitionParameter.GetHasPartList : boolean;
begin
  result := (FPartList <> nil) and (FPartList.count > 0);
end;

{ TFhirOperationDefinitionParameterListEnumerator }

constructor TFhirOperationDefinitionParameterListEnumerator.Create(list : TFhirOperationDefinitionParameterList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirOperationDefinitionParameterListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirOperationDefinitionParameterListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirOperationDefinitionParameterListEnumerator.GetCurrent : TFhirOperationDefinitionParameter;
begin
  Result := FList[FIndex];
end;

function TFhirOperationDefinitionParameterListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirOperationDefinitionParameterList }

function TFhirOperationDefinitionParameterList.AddItem(value: TFhirOperationDefinitionParameter): TFhirOperationDefinitionParameter;
begin
  assert(value.ClassName = 'TFhirOperationDefinitionParameter', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirOperationDefinitionParameter');
  add(value);
  result := value;
end;

function TFhirOperationDefinitionParameterList.Append: TFhirOperationDefinitionParameter;
begin
  result := TFhirOperationDefinitionParameter.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOperationDefinitionParameterList.ClearItems;
begin
  Clear;
end;

function TFhirOperationDefinitionParameterList.GetEnumerator : TFhirOperationDefinitionParameterListEnumerator;
begin
  result := TFhirOperationDefinitionParameterListEnumerator.Create(self.link);
end;

function TFhirOperationDefinitionParameterList.Clone: TFhirOperationDefinitionParameterList;
begin
  result := TFhirOperationDefinitionParameterList(inherited Clone);
end;

function TFhirOperationDefinitionParameterList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirOperationDefinitionParameterList.GetItemN(index: Integer): TFhirOperationDefinitionParameter;
begin
  result := TFhirOperationDefinitionParameter(ObjectByIndex[index]);
end;

function TFhirOperationDefinitionParameterList.ItemClass: TFslObjectClass;
begin
  result := TFhirOperationDefinitionParameter;
end;
function TFhirOperationDefinitionParameterList.IndexOf(value: TFhirOperationDefinitionParameter): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirOperationDefinitionParameterList.Insert(index: Integer): TFhirOperationDefinitionParameter;
begin
  result := TFhirOperationDefinitionParameter.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOperationDefinitionParameterList.InsertItem(index: Integer; value: TFhirOperationDefinitionParameter);
begin
  assert(value is TFhirOperationDefinitionParameter);
  Inherited Insert(index, value);
end;

function TFhirOperationDefinitionParameterList.Item(index: Integer): TFhirOperationDefinitionParameter;
begin
  result := TFhirOperationDefinitionParameter(ObjectByIndex[index]);
end;

function TFhirOperationDefinitionParameterList.Link: TFhirOperationDefinitionParameterList;
begin
  result := TFhirOperationDefinitionParameterList(inherited Link);
end;

procedure TFhirOperationDefinitionParameterList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirOperationDefinitionParameterList.SetItemByIndex(index: Integer; value: TFhirOperationDefinitionParameter);
begin
  assert(value is TFhirOperationDefinitionParameter);
  FhirOperationDefinitionParameters[index] := value;
end;

procedure TFhirOperationDefinitionParameterList.SetItemN(index: Integer; value: TFhirOperationDefinitionParameter);
begin
  assert(value is TFhirOperationDefinitionParameter);
  ObjectByIndex[index] := value;
end;

{ TFhirOperationDefinitionParameterBinding }

constructor TFhirOperationDefinitionParameterBinding.Create;
begin
  inherited;
end;

destructor TFhirOperationDefinitionParameterBinding.Destroy;
begin
  FStrength.free;
  FValueSet.free;
  inherited;
end;

procedure TFhirOperationDefinitionParameterBinding.Assign(oSource : TFslObject);
begin
  inherited;
  strengthElement := TFhirOperationDefinitionParameterBinding(oSource).strengthElement.Clone;
  valueSetElement := TFhirOperationDefinitionParameterBinding(oSource).valueSetElement.Clone;
end;

procedure TFhirOperationDefinitionParameterBinding.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'strength') Then
     list.add(self.link, 'strength', FStrength.Link);
  if (child_name = 'valueSet') Then
     list.add(self.link, 'valueSet', FValueSet.Link);
end;

procedure TFhirOperationDefinitionParameterBinding.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'strength', 'code', false, TFhirEnum, FStrength.Link));
  oList.add(TFHIRProperty.create(self, 'valueSet', 'canonical', false, TFhirCanonical, FValueSet.Link));
end;

function TFhirOperationDefinitionParameterBinding.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'strength') then
  begin
    StrengthElement := asEnum(SYSTEMS_TFhirBindingStrengthEnum, CODES_TFhirBindingStrengthEnum, propValue);
    result := propValue;
  end
  else if (propName = 'valueSet') then
  begin
    ValueSetElement := asCanonical(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirOperationDefinitionParameterBinding.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirOperationDefinitionParameterBinding.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'strength') then result := TFhirEnum.create(SYSTEMS_TFhirBindingStrengthEnum[BindingStrengthNull], CODES_TFhirBindingStrengthEnum[BindingStrengthNull]) 
  else if (propName = 'valueSet') then result := TFhirCanonical.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirOperationDefinitionParameterBinding.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'strength') then result := 'code'
  else if (propName = 'valueSet') then result := 'canonical'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirOperationDefinitionParameterBinding.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'strength') then StrengthElement := nil
  else if (propName = 'valueSet') then ValueSetElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirOperationDefinitionParameterBinding.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'strength') then StrengthElement := asEnum(SYSTEMS_TFhirBindingStrengthEnum, CODES_TFhirBindingStrengthEnum, new)
  else if (propName = 'valueSet') then ValueSetElement := asCanonical(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirOperationDefinitionParameterBinding.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirOperationDefinitionParameterBinding.fhirType : string;
begin
  result := 'OperationDefinition.parameter.binding';
end;

function TFhirOperationDefinitionParameterBinding.Link : TFhirOperationDefinitionParameterBinding;
begin
  result := TFhirOperationDefinitionParameterBinding(inherited Link);
end;

function TFhirOperationDefinitionParameterBinding.Clone : TFhirOperationDefinitionParameterBinding;
begin
  result := TFhirOperationDefinitionParameterBinding(inherited Clone);
end;

function TFhirOperationDefinitionParameterBinding.equals(other : TObject) : boolean; 
var
  o : TFhirOperationDefinitionParameterBinding;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirOperationDefinitionParameterBinding)) then
    result := false
  else
  begin
    o := TFhirOperationDefinitionParameterBinding(other);
    result := compareDeep(strengthElement, o.strengthElement, true) and compareDeep(valueSetElement, o.valueSetElement, true);
  end;
end;

function TFhirOperationDefinitionParameterBinding.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FStrength) and isEmptyProp(FValueSet);
end;

procedure TFhirOperationDefinitionParameterBinding.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('strength');
  fields.add('valueSet');
end;

function TFhirOperationDefinitionParameterBinding.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirOperationDefinitionParameterBinding.SetStrength(value : TFhirEnum);
begin
  FStrength.free;
  FStrength := value;
end;

function TFhirOperationDefinitionParameterBinding.GetStrengthST : TFhirBindingStrengthEnum;
begin
  if FStrength = nil then
    result := TFhirBindingStrengthEnum(0)
  else
    result := TFhirBindingStrengthEnum(StringArrayIndexOfSensitive(CODES_TFhirBindingStrengthEnum, FStrength.value));
end;

procedure TFhirOperationDefinitionParameterBinding.SetStrengthST(value : TFhirBindingStrengthEnum);
begin
  if ord(value) = 0 then
    StrengthElement := nil
  else
    StrengthElement := TFhirEnum.create(SYSTEMS_TFhirBindingStrengthEnum[value], CODES_TFhirBindingStrengthEnum[value]);
end;

procedure TFhirOperationDefinitionParameterBinding.SetValueSet(value : TFhirCanonical);
begin
  FValueSet.free;
  FValueSet := value;
end;

function TFhirOperationDefinitionParameterBinding.GetValueSetST : String;
begin
  if FValueSet = nil then
    result := ''
  else
    result := FValueSet.value;
end;

procedure TFhirOperationDefinitionParameterBinding.SetValueSetST(value : String);
begin
  if value <> '' then
  begin
    if FValueSet = nil then
      FValueSet := TFhirCanonical.create;
    FValueSet.value := value
  end
  else if FValueSet <> nil then
    FValueSet.value := '';
end;

{ TFhirOperationDefinitionParameterBindingListEnumerator }

constructor TFhirOperationDefinitionParameterBindingListEnumerator.Create(list : TFhirOperationDefinitionParameterBindingList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirOperationDefinitionParameterBindingListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirOperationDefinitionParameterBindingListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirOperationDefinitionParameterBindingListEnumerator.GetCurrent : TFhirOperationDefinitionParameterBinding;
begin
  Result := FList[FIndex];
end;

function TFhirOperationDefinitionParameterBindingListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirOperationDefinitionParameterBindingList }

function TFhirOperationDefinitionParameterBindingList.AddItem(value: TFhirOperationDefinitionParameterBinding): TFhirOperationDefinitionParameterBinding;
begin
  assert(value.ClassName = 'TFhirOperationDefinitionParameterBinding', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirOperationDefinitionParameterBinding');
  add(value);
  result := value;
end;

function TFhirOperationDefinitionParameterBindingList.Append: TFhirOperationDefinitionParameterBinding;
begin
  result := TFhirOperationDefinitionParameterBinding.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOperationDefinitionParameterBindingList.ClearItems;
begin
  Clear;
end;

function TFhirOperationDefinitionParameterBindingList.GetEnumerator : TFhirOperationDefinitionParameterBindingListEnumerator;
begin
  result := TFhirOperationDefinitionParameterBindingListEnumerator.Create(self.link);
end;

function TFhirOperationDefinitionParameterBindingList.Clone: TFhirOperationDefinitionParameterBindingList;
begin
  result := TFhirOperationDefinitionParameterBindingList(inherited Clone);
end;

function TFhirOperationDefinitionParameterBindingList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirOperationDefinitionParameterBindingList.GetItemN(index: Integer): TFhirOperationDefinitionParameterBinding;
begin
  result := TFhirOperationDefinitionParameterBinding(ObjectByIndex[index]);
end;

function TFhirOperationDefinitionParameterBindingList.ItemClass: TFslObjectClass;
begin
  result := TFhirOperationDefinitionParameterBinding;
end;
function TFhirOperationDefinitionParameterBindingList.IndexOf(value: TFhirOperationDefinitionParameterBinding): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirOperationDefinitionParameterBindingList.Insert(index: Integer): TFhirOperationDefinitionParameterBinding;
begin
  result := TFhirOperationDefinitionParameterBinding.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOperationDefinitionParameterBindingList.InsertItem(index: Integer; value: TFhirOperationDefinitionParameterBinding);
begin
  assert(value is TFhirOperationDefinitionParameterBinding);
  Inherited Insert(index, value);
end;

function TFhirOperationDefinitionParameterBindingList.Item(index: Integer): TFhirOperationDefinitionParameterBinding;
begin
  result := TFhirOperationDefinitionParameterBinding(ObjectByIndex[index]);
end;

function TFhirOperationDefinitionParameterBindingList.Link: TFhirOperationDefinitionParameterBindingList;
begin
  result := TFhirOperationDefinitionParameterBindingList(inherited Link);
end;

procedure TFhirOperationDefinitionParameterBindingList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirOperationDefinitionParameterBindingList.SetItemByIndex(index: Integer; value: TFhirOperationDefinitionParameterBinding);
begin
  assert(value is TFhirOperationDefinitionParameterBinding);
  FhirOperationDefinitionParameterBindings[index] := value;
end;

procedure TFhirOperationDefinitionParameterBindingList.SetItemN(index: Integer; value: TFhirOperationDefinitionParameterBinding);
begin
  assert(value is TFhirOperationDefinitionParameterBinding);
  ObjectByIndex[index] := value;
end;

{ TFhirOperationDefinitionParameterReferencedFrom }

constructor TFhirOperationDefinitionParameterReferencedFrom.Create;
begin
  inherited;
end;

destructor TFhirOperationDefinitionParameterReferencedFrom.Destroy;
begin
  FSource.free;
  FSourceId.free;
  inherited;
end;

procedure TFhirOperationDefinitionParameterReferencedFrom.Assign(oSource : TFslObject);
begin
  inherited;
  sourceElement := TFhirOperationDefinitionParameterReferencedFrom(oSource).sourceElement.Clone;
  sourceIdElement := TFhirOperationDefinitionParameterReferencedFrom(oSource).sourceIdElement.Clone;
end;

procedure TFhirOperationDefinitionParameterReferencedFrom.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'source') Then
     list.add(self.link, 'source', FSource.Link);
  if (child_name = 'sourceId') Then
     list.add(self.link, 'sourceId', FSourceId.Link);
end;

procedure TFhirOperationDefinitionParameterReferencedFrom.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'source', 'string', false, TFhirString, FSource.Link));
  oList.add(TFHIRProperty.create(self, 'sourceId', 'string', false, TFhirString, FSourceId.Link));
end;

function TFhirOperationDefinitionParameterReferencedFrom.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'source') then
  begin
    SourceElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'sourceId') then
  begin
    SourceIdElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirOperationDefinitionParameterReferencedFrom.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirOperationDefinitionParameterReferencedFrom.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'source') then result := TFhirString.create()
  else if (propName = 'sourceId') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirOperationDefinitionParameterReferencedFrom.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'source') then result := 'string'
  else if (propName = 'sourceId') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirOperationDefinitionParameterReferencedFrom.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'source') then SourceElement := nil
  else if (propName = 'sourceId') then SourceIdElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirOperationDefinitionParameterReferencedFrom.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'source') then SourceElement := asString(new)
  else if (propName = 'sourceId') then SourceIdElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirOperationDefinitionParameterReferencedFrom.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirOperationDefinitionParameterReferencedFrom.fhirType : string;
begin
  result := 'OperationDefinition.parameter.referencedFrom';
end;

function TFhirOperationDefinitionParameterReferencedFrom.Link : TFhirOperationDefinitionParameterReferencedFrom;
begin
  result := TFhirOperationDefinitionParameterReferencedFrom(inherited Link);
end;

function TFhirOperationDefinitionParameterReferencedFrom.Clone : TFhirOperationDefinitionParameterReferencedFrom;
begin
  result := TFhirOperationDefinitionParameterReferencedFrom(inherited Clone);
end;

function TFhirOperationDefinitionParameterReferencedFrom.equals(other : TObject) : boolean; 
var
  o : TFhirOperationDefinitionParameterReferencedFrom;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirOperationDefinitionParameterReferencedFrom)) then
    result := false
  else
  begin
    o := TFhirOperationDefinitionParameterReferencedFrom(other);
    result := compareDeep(sourceElement, o.sourceElement, true) and compareDeep(sourceIdElement, o.sourceIdElement, true);
  end;
end;

function TFhirOperationDefinitionParameterReferencedFrom.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSource) and isEmptyProp(FSourceId);
end;

procedure TFhirOperationDefinitionParameterReferencedFrom.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('source');
  fields.add('sourceId');
end;

function TFhirOperationDefinitionParameterReferencedFrom.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirOperationDefinitionParameterReferencedFrom.SetSource(value : TFhirString);
begin
  FSource.free;
  FSource := value;
end;

function TFhirOperationDefinitionParameterReferencedFrom.GetSourceST : String;
begin
  if FSource = nil then
    result := ''
  else
    result := FSource.value;
end;

procedure TFhirOperationDefinitionParameterReferencedFrom.SetSourceST(value : String);
begin
  if value <> '' then
  begin
    if FSource = nil then
      FSource := TFhirString.create;
    FSource.value := value
  end
  else if FSource <> nil then
    FSource.value := '';
end;

procedure TFhirOperationDefinitionParameterReferencedFrom.SetSourceId(value : TFhirString);
begin
  FSourceId.free;
  FSourceId := value;
end;

function TFhirOperationDefinitionParameterReferencedFrom.GetSourceIdST : String;
begin
  if FSourceId = nil then
    result := ''
  else
    result := FSourceId.value;
end;

procedure TFhirOperationDefinitionParameterReferencedFrom.SetSourceIdST(value : String);
begin
  if value <> '' then
  begin
    if FSourceId = nil then
      FSourceId := TFhirString.create;
    FSourceId.value := value
  end
  else if FSourceId <> nil then
    FSourceId.value := '';
end;

{ TFhirOperationDefinitionParameterReferencedFromListEnumerator }

constructor TFhirOperationDefinitionParameterReferencedFromListEnumerator.Create(list : TFhirOperationDefinitionParameterReferencedFromList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirOperationDefinitionParameterReferencedFromListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirOperationDefinitionParameterReferencedFromListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirOperationDefinitionParameterReferencedFromListEnumerator.GetCurrent : TFhirOperationDefinitionParameterReferencedFrom;
begin
  Result := FList[FIndex];
end;

function TFhirOperationDefinitionParameterReferencedFromListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirOperationDefinitionParameterReferencedFromList }

function TFhirOperationDefinitionParameterReferencedFromList.AddItem(value: TFhirOperationDefinitionParameterReferencedFrom): TFhirOperationDefinitionParameterReferencedFrom;
begin
  assert(value.ClassName = 'TFhirOperationDefinitionParameterReferencedFrom', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirOperationDefinitionParameterReferencedFrom');
  add(value);
  result := value;
end;

function TFhirOperationDefinitionParameterReferencedFromList.Append: TFhirOperationDefinitionParameterReferencedFrom;
begin
  result := TFhirOperationDefinitionParameterReferencedFrom.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOperationDefinitionParameterReferencedFromList.ClearItems;
begin
  Clear;
end;

function TFhirOperationDefinitionParameterReferencedFromList.GetEnumerator : TFhirOperationDefinitionParameterReferencedFromListEnumerator;
begin
  result := TFhirOperationDefinitionParameterReferencedFromListEnumerator.Create(self.link);
end;

function TFhirOperationDefinitionParameterReferencedFromList.Clone: TFhirOperationDefinitionParameterReferencedFromList;
begin
  result := TFhirOperationDefinitionParameterReferencedFromList(inherited Clone);
end;

function TFhirOperationDefinitionParameterReferencedFromList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirOperationDefinitionParameterReferencedFromList.GetItemN(index: Integer): TFhirOperationDefinitionParameterReferencedFrom;
begin
  result := TFhirOperationDefinitionParameterReferencedFrom(ObjectByIndex[index]);
end;

function TFhirOperationDefinitionParameterReferencedFromList.ItemClass: TFslObjectClass;
begin
  result := TFhirOperationDefinitionParameterReferencedFrom;
end;
function TFhirOperationDefinitionParameterReferencedFromList.IndexOf(value: TFhirOperationDefinitionParameterReferencedFrom): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirOperationDefinitionParameterReferencedFromList.Insert(index: Integer): TFhirOperationDefinitionParameterReferencedFrom;
begin
  result := TFhirOperationDefinitionParameterReferencedFrom.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOperationDefinitionParameterReferencedFromList.InsertItem(index: Integer; value: TFhirOperationDefinitionParameterReferencedFrom);
begin
  assert(value is TFhirOperationDefinitionParameterReferencedFrom);
  Inherited Insert(index, value);
end;

function TFhirOperationDefinitionParameterReferencedFromList.Item(index: Integer): TFhirOperationDefinitionParameterReferencedFrom;
begin
  result := TFhirOperationDefinitionParameterReferencedFrom(ObjectByIndex[index]);
end;

function TFhirOperationDefinitionParameterReferencedFromList.Link: TFhirOperationDefinitionParameterReferencedFromList;
begin
  result := TFhirOperationDefinitionParameterReferencedFromList(inherited Link);
end;

procedure TFhirOperationDefinitionParameterReferencedFromList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirOperationDefinitionParameterReferencedFromList.SetItemByIndex(index: Integer; value: TFhirOperationDefinitionParameterReferencedFrom);
begin
  assert(value is TFhirOperationDefinitionParameterReferencedFrom);
  FhirOperationDefinitionParameterReferencedFroms[index] := value;
end;

procedure TFhirOperationDefinitionParameterReferencedFromList.SetItemN(index: Integer; value: TFhirOperationDefinitionParameterReferencedFrom);
begin
  assert(value is TFhirOperationDefinitionParameterReferencedFrom);
  ObjectByIndex[index] := value;
end;

{ TFhirOperationDefinitionOverload }

constructor TFhirOperationDefinitionOverload.Create;
begin
  inherited;
end;

destructor TFhirOperationDefinitionOverload.Destroy;
begin
  FParameterNameList.Free;
  FComment.free;
  inherited;
end;

procedure TFhirOperationDefinitionOverload.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirOperationDefinitionOverload(oSource).FParameterNameList = nil) then
  begin
    FParameterNameList.free;
    FParameterNameList := nil;
  end
  else
  begin
    if FParameterNameList = nil then
      FParameterNameList := TFhirStringList.Create;
    FParameterNameList.Assign(TFhirOperationDefinitionOverload(oSource).FParameterNameList);
  end;
  commentElement := TFhirOperationDefinitionOverload(oSource).commentElement.Clone;
end;

procedure TFhirOperationDefinitionOverload.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'parameterName') Then
    list.addAll(self, 'parameterName', FParameterNameList);
  if (child_name = 'comment') Then
     list.add(self.link, 'comment', FComment.Link);
end;

procedure TFhirOperationDefinitionOverload.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'parameterName', 'string', true, TFhirString, FParameterNameList.Link));
  oList.add(TFHIRProperty.create(self, 'comment', 'string', false, TFhirString, FComment.Link));
end;

function TFhirOperationDefinitionOverload.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'parameterName') then
  begin
    ParameterNameList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'comment') then
  begin
    CommentElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirOperationDefinitionOverload.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'parameterName') then ParameterNameList.insertItem(index, asString(propValue))
  else inherited;
end;

function TFhirOperationDefinitionOverload.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'parameterName') then result := ParameterNameList.new()
  else if (propName = 'comment') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirOperationDefinitionOverload.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'parameterName') then result := 'string'
  else if (propName = 'comment') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirOperationDefinitionOverload.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'parameterName') then deletePropertyValue('parameterName', ParameterNameList, value)
  else if (propName = 'comment') then CommentElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirOperationDefinitionOverload.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'parameterName') then replacePropertyValue('parameterName', ParameterNameList, existing, new)
  else if (propName = 'comment') then CommentElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirOperationDefinitionOverload.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'parameterName') then ParameterNameList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirOperationDefinitionOverload.fhirType : string;
begin
  result := 'OperationDefinition.overload';
end;

function TFhirOperationDefinitionOverload.Link : TFhirOperationDefinitionOverload;
begin
  result := TFhirOperationDefinitionOverload(inherited Link);
end;

function TFhirOperationDefinitionOverload.Clone : TFhirOperationDefinitionOverload;
begin
  result := TFhirOperationDefinitionOverload(inherited Clone);
end;

function TFhirOperationDefinitionOverload.equals(other : TObject) : boolean; 
var
  o : TFhirOperationDefinitionOverload;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirOperationDefinitionOverload)) then
    result := false
  else
  begin
    o := TFhirOperationDefinitionOverload(other);
    result := compareDeep(parameterNameList, o.parameterNameList, true) and compareDeep(commentElement, o.commentElement, true);
  end;
end;

function TFhirOperationDefinitionOverload.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FparameterNameList) and isEmptyProp(FComment);
end;

procedure TFhirOperationDefinitionOverload.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('parameterName');
  fields.add('comment');
end;

function TFhirOperationDefinitionOverload.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FParameterNameList.sizeInBytes(magic));
end;

function TFhirOperationDefinitionOverload.GetParameterNameList : TFhirStringList;
begin
  if FParameterNameList = nil then
    FParameterNameList := TFhirStringList.Create;
  result := FParameterNameList;
end;

function TFhirOperationDefinitionOverload.GetHasParameterNameList : boolean;
begin
  result := (FParameterNameList <> nil) and (FParameterNameList.count > 0);
end;

procedure TFhirOperationDefinitionOverload.SetComment(value : TFhirString);
begin
  FComment.free;
  FComment := value;
end;

function TFhirOperationDefinitionOverload.GetCommentST : String;
begin
  if FComment = nil then
    result := ''
  else
    result := FComment.value;
end;

procedure TFhirOperationDefinitionOverload.SetCommentST(value : String);
begin
  if value <> '' then
  begin
    if FComment = nil then
      FComment := TFhirString.create;
    FComment.value := value
  end
  else if FComment <> nil then
    FComment.value := '';
end;

{ TFhirOperationDefinitionOverloadListEnumerator }

constructor TFhirOperationDefinitionOverloadListEnumerator.Create(list : TFhirOperationDefinitionOverloadList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirOperationDefinitionOverloadListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirOperationDefinitionOverloadListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirOperationDefinitionOverloadListEnumerator.GetCurrent : TFhirOperationDefinitionOverload;
begin
  Result := FList[FIndex];
end;

function TFhirOperationDefinitionOverloadListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirOperationDefinitionOverloadList }

function TFhirOperationDefinitionOverloadList.AddItem(value: TFhirOperationDefinitionOverload): TFhirOperationDefinitionOverload;
begin
  assert(value.ClassName = 'TFhirOperationDefinitionOverload', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirOperationDefinitionOverload');
  add(value);
  result := value;
end;

function TFhirOperationDefinitionOverloadList.Append: TFhirOperationDefinitionOverload;
begin
  result := TFhirOperationDefinitionOverload.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOperationDefinitionOverloadList.ClearItems;
begin
  Clear;
end;

function TFhirOperationDefinitionOverloadList.GetEnumerator : TFhirOperationDefinitionOverloadListEnumerator;
begin
  result := TFhirOperationDefinitionOverloadListEnumerator.Create(self.link);
end;

function TFhirOperationDefinitionOverloadList.Clone: TFhirOperationDefinitionOverloadList;
begin
  result := TFhirOperationDefinitionOverloadList(inherited Clone);
end;

function TFhirOperationDefinitionOverloadList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirOperationDefinitionOverloadList.GetItemN(index: Integer): TFhirOperationDefinitionOverload;
begin
  result := TFhirOperationDefinitionOverload(ObjectByIndex[index]);
end;

function TFhirOperationDefinitionOverloadList.ItemClass: TFslObjectClass;
begin
  result := TFhirOperationDefinitionOverload;
end;
function TFhirOperationDefinitionOverloadList.IndexOf(value: TFhirOperationDefinitionOverload): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirOperationDefinitionOverloadList.Insert(index: Integer): TFhirOperationDefinitionOverload;
begin
  result := TFhirOperationDefinitionOverload.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOperationDefinitionOverloadList.InsertItem(index: Integer; value: TFhirOperationDefinitionOverload);
begin
  assert(value is TFhirOperationDefinitionOverload);
  Inherited Insert(index, value);
end;

function TFhirOperationDefinitionOverloadList.Item(index: Integer): TFhirOperationDefinitionOverload;
begin
  result := TFhirOperationDefinitionOverload(ObjectByIndex[index]);
end;

function TFhirOperationDefinitionOverloadList.Link: TFhirOperationDefinitionOverloadList;
begin
  result := TFhirOperationDefinitionOverloadList(inherited Link);
end;

procedure TFhirOperationDefinitionOverloadList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirOperationDefinitionOverloadList.SetItemByIndex(index: Integer; value: TFhirOperationDefinitionOverload);
begin
  assert(value is TFhirOperationDefinitionOverload);
  FhirOperationDefinitionOverloads[index] := value;
end;

procedure TFhirOperationDefinitionOverloadList.SetItemN(index: Integer; value: TFhirOperationDefinitionOverload);
begin
  assert(value is TFhirOperationDefinitionOverload);
  ObjectByIndex[index] := value;
end;

{ TFhirOperationDefinition }

constructor TFhirOperationDefinition.Create;
begin
  inherited;
end;

destructor TFhirOperationDefinition.Destroy;
begin
  FUrl.free;
  FVersion.free;
  FName.free;
  FTitle.free;
  FStatus.free;
  FKind.free;
  FExperimental.free;
  FDate.free;
  FPublisher.free;
  FContactList.Free;
  FDescription.free;
  FUseContextList.Free;
  FJurisdictionList.Free;
  FPurpose.free;
  FAffectsState.free;
  FCode.free;
  FComment.free;
  FBase.free;
  FResource.Free;
  FSystem.free;
  FType_.free;
  FInstance.free;
  FInputProfile.free;
  FOutputProfile.free;
  FParameterList.Free;
  FOverloadList.Free;
  inherited;
end;

procedure TFhirOperationDefinition.Assign(oSource : TFslObject);
begin
  inherited;
  urlElement := TFhirOperationDefinition(oSource).urlElement.Clone;
  versionElement := TFhirOperationDefinition(oSource).versionElement.Clone;
  nameElement := TFhirOperationDefinition(oSource).nameElement.Clone;
  titleElement := TFhirOperationDefinition(oSource).titleElement.Clone;
  statusElement := TFhirOperationDefinition(oSource).statusElement.Clone;
  kindElement := TFhirOperationDefinition(oSource).kindElement.Clone;
  experimentalElement := TFhirOperationDefinition(oSource).experimentalElement.Clone;
  dateElement := TFhirOperationDefinition(oSource).dateElement.Clone;
  publisherElement := TFhirOperationDefinition(oSource).publisherElement.Clone;
  if (TFhirOperationDefinition(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirContactDetailList.Create;
    FContactList.Assign(TFhirOperationDefinition(oSource).FContactList);
  end;
  descriptionElement := TFhirOperationDefinition(oSource).descriptionElement.Clone;
  if (TFhirOperationDefinition(oSource).FUseContextList = nil) then
  begin
    FUseContextList.free;
    FUseContextList := nil;
  end
  else
  begin
    if FUseContextList = nil then
      FUseContextList := TFhirUsageContextList.Create;
    FUseContextList.Assign(TFhirOperationDefinition(oSource).FUseContextList);
  end;
  if (TFhirOperationDefinition(oSource).FJurisdictionList = nil) then
  begin
    FJurisdictionList.free;
    FJurisdictionList := nil;
  end
  else
  begin
    if FJurisdictionList = nil then
      FJurisdictionList := TFhirCodeableConceptList.Create;
    FJurisdictionList.Assign(TFhirOperationDefinition(oSource).FJurisdictionList);
  end;
  purposeElement := TFhirOperationDefinition(oSource).purposeElement.Clone;
  affectsStateElement := TFhirOperationDefinition(oSource).affectsStateElement.Clone;
  codeElement := TFhirOperationDefinition(oSource).codeElement.Clone;
  commentElement := TFhirOperationDefinition(oSource).commentElement.Clone;
  baseElement := TFhirOperationDefinition(oSource).baseElement.Clone;
  if (TFhirOperationDefinition(oSource).FResource = nil) then
  begin
    FResource.free;
    FResource := nil;
  end
  else
  begin
    FResource := TFhirEnumList.Create(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum);
    FResource.Assign(TFhirOperationDefinition(oSource).FResource);
  end;
  systemElement := TFhirOperationDefinition(oSource).systemElement.Clone;
  type_Element := TFhirOperationDefinition(oSource).type_Element.Clone;
  instanceElement := TFhirOperationDefinition(oSource).instanceElement.Clone;
  inputProfileElement := TFhirOperationDefinition(oSource).inputProfileElement.Clone;
  outputProfileElement := TFhirOperationDefinition(oSource).outputProfileElement.Clone;
  if (TFhirOperationDefinition(oSource).FParameterList = nil) then
  begin
    FParameterList.free;
    FParameterList := nil;
  end
  else
  begin
    if FParameterList = nil then
      FParameterList := TFhirOperationDefinitionParameterList.Create;
    FParameterList.Assign(TFhirOperationDefinition(oSource).FParameterList);
  end;
  if (TFhirOperationDefinition(oSource).FOverloadList = nil) then
  begin
    FOverloadList.free;
    FOverloadList := nil;
  end
  else
  begin
    if FOverloadList = nil then
      FOverloadList := TFhirOperationDefinitionOverloadList.Create;
    FOverloadList.Assign(TFhirOperationDefinition(oSource).FOverloadList);
  end;
end;

function TFhirOperationDefinition.GetResourceType : TFhirResourceType;
begin
  result := frtOperationDefinition;
end;

procedure TFhirOperationDefinition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
  if (child_name = 'version') Then
     list.add(self.link, 'version', FVersion.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'kind') Then
     list.add(self.link, 'kind', FKind.Link);
  if (child_name = 'experimental') Then
     list.add(self.link, 'experimental', FExperimental.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'publisher') Then
     list.add(self.link, 'publisher', FPublisher.Link);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'useContext') Then
    list.addAll(self, 'useContext', FUseContextList);
  if (child_name = 'jurisdiction') Then
    list.addAll(self, 'jurisdiction', FJurisdictionList);
  if (child_name = 'purpose') Then
     list.add(self.link, 'purpose', FPurpose.Link);
  if (child_name = 'affectsState') Then
     list.add(self.link, 'affectsState', FAffectsState.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'comment') Then
     list.add(self.link, 'comment', FComment.Link);
  if (child_name = 'base') Then
     list.add(self.link, 'base', FBase.Link);
  if (child_name = 'resource') Then
     list.addAll(self, 'resource', FResource);
  if (child_name = 'system') Then
     list.add(self.link, 'system', FSystem.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'instance') Then
     list.add(self.link, 'instance', FInstance.Link);
  if (child_name = 'inputProfile') Then
     list.add(self.link, 'inputProfile', FInputProfile.Link);
  if (child_name = 'outputProfile') Then
     list.add(self.link, 'outputProfile', FOutputProfile.Link);
  if (child_name = 'parameter') Then
    list.addAll(self, 'parameter', FParameterList);
  if (child_name = 'overload') Then
    list.addAll(self, 'overload', FOverloadList);
end;

procedure TFhirOperationDefinition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'url', 'uri', false, TFhirUri, FUrl.Link));
  oList.add(TFHIRProperty.create(self, 'version', 'string', false, TFhirString, FVersion.Link));
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'kind', 'code', false, TFhirEnum, FKind.Link));
  oList.add(TFHIRProperty.create(self, 'experimental', 'boolean', false, TFhirBoolean, FExperimental.Link));
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));
  oList.add(TFHIRProperty.create(self, 'publisher', 'string', false, TFhirString, FPublisher.Link));
  oList.add(TFHIRProperty.create(self, 'contact', 'ContactDetail', true, TFhirContactDetail, FContactList.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'markdown', false, TFhirMarkdown, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'useContext', 'UsageContext', true, TFhirUsageContext, FUseContextList.Link));
  oList.add(TFHIRProperty.create(self, 'jurisdiction', 'CodeableConcept', true, TFhirCodeableConcept, FJurisdictionList.Link));
  oList.add(TFHIRProperty.create(self, 'purpose', 'markdown', false, TFhirMarkdown, FPurpose.Link));
  oList.add(TFHIRProperty.create(self, 'affectsState', 'boolean', false, TFhirBoolean, FAffectsState.Link));
  oList.add(TFHIRProperty.create(self, 'code', 'code', false, TFhirCode, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'comment', 'markdown', false, TFhirMarkdown, FComment.Link));
  oList.add(TFHIRProperty.create(self, 'base', 'canonical', false, TFhirCanonical, FBase.Link));
  oList.add(TFHIRProperty.create(self, 'resource', 'code', true, TFhirEnum, FResource.Link));
  oList.add(TFHIRProperty.create(self, 'system', 'boolean', false, TFhirBoolean, FSystem.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'boolean', false, TFhirBoolean, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'instance', 'boolean', false, TFhirBoolean, FInstance.Link));
  oList.add(TFHIRProperty.create(self, 'inputProfile', 'canonical', false, TFhirCanonical, FInputProfile.Link));
  oList.add(TFHIRProperty.create(self, 'outputProfile', 'canonical', false, TFhirCanonical, FOutputProfile.Link));
  oList.add(TFHIRProperty.create(self, 'parameter', 'BackboneElement', true, TFhirOperationDefinitionParameter, FParameterList.Link));
  oList.add(TFHIRProperty.create(self, 'overload', 'BackboneElement', true, TFhirOperationDefinitionOverload, FOverloadList.Link));
end;

function TFhirOperationDefinition.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'url') then
  begin
    UrlElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'title') then
  begin
    TitleElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'kind') then
  begin
    KindElement := asEnum(SYSTEMS_TFhirOperationKindEnum, CODES_TFhirOperationKindEnum, propValue);
    result := propValue;
  end
  else if (propName = 'experimental') then
  begin
    ExperimentalElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'publisher') then
  begin
    PublisherElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirContactDetail);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'useContext') then
  begin
    UseContextList.add(propValue as TFhirUsageContext);
    result := propValue;
  end
  else if (propName = 'jurisdiction') then
  begin
    JurisdictionList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'purpose') then
  begin
    PurposeElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'affectsState') then
  begin
    AffectsStateElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    CodeElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'comment') then
  begin
    CommentElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'base') then
  begin
    BaseElement := asCanonical(propValue);
    result := propValue;
  end
  else if (propName = 'resource') then
  begin
    ResourceList.add(asEnum(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum, propValue));
    result := propValue;
  end
  else if (propName = 'system') then
  begin
    SystemElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_Element := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'instance') then
  begin
    InstanceElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'inputProfile') then
  begin
    InputProfileElement := asCanonical(propValue);
    result := propValue;
  end
  else if (propName = 'outputProfile') then
  begin
    OutputProfileElement := asCanonical(propValue);
    result := propValue;
  end
  else if (propName = 'parameter') then
  begin
    ParameterList.add(propValue as TFhirOperationDefinitionParameter);
    result := propValue;
  end
  else if (propName = 'overload') then
  begin
    OverloadList.add(propValue as TFhirOperationDefinitionOverload);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirOperationDefinition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirContactDetail)
  else if (propName = 'useContext') then UseContextList.insertItem(index, propValue as TFhirUsageContext)
  else if (propName = 'jurisdiction') then JurisdictionList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'resource') then FResource.insertItem(index, asEnum(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum, propValue))
  else if (propName = 'parameter') then ParameterList.insertItem(index, propValue as TFhirOperationDefinitionParameter)
  else if (propName = 'overload') then OverloadList.insertItem(index, propValue as TFhirOperationDefinitionOverload)
  else inherited;
end;

function TFhirOperationDefinition.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'url') then result := TFhirUri.create()
  else if (propName = 'version') then result := TFhirString.create()
  else if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'title') then result := TFhirString.create()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[PublicationStatusNull], CODES_TFhirPublicationStatusEnum[PublicationStatusNull]) 
  else if (propName = 'kind') then result := TFhirEnum.create(SYSTEMS_TFhirOperationKindEnum[OperationKindNull], CODES_TFhirOperationKindEnum[OperationKindNull]) 
  else if (propName = 'experimental') then result := TFhirBoolean.create()
  else if (propName = 'date') then result := TFhirDateTime.create()
  else if (propName = 'publisher') then result := TFhirString.create()
  else if (propName = 'contact') then result := ContactList.new()
  else if (propName = 'description') then result := TFhirMarkdown.create()
  else if (propName = 'useContext') then result := UseContextList.new()
  else if (propName = 'jurisdiction') then result := JurisdictionList.new()
  else if (propName = 'purpose') then result := TFhirMarkdown.create()
  else if (propName = 'affectsState') then result := TFhirBoolean.create()
  else if (propName = 'code') then result := TFhirCode.create()
  else if (propName = 'comment') then result := TFhirMarkdown.create()
  else if (propName = 'base') then result := TFhirCanonical.create()
  else if (propName = 'system') then result := TFhirBoolean.create()
  else if (propName = 'type') then result := TFhirBoolean.create()
  else if (propName = 'instance') then result := TFhirBoolean.create()
  else if (propName = 'inputProfile') then result := TFhirCanonical.create()
  else if (propName = 'outputProfile') then result := TFhirCanonical.create()
  else if (propName = 'parameter') then result := ParameterList.new()
  else if (propName = 'overload') then result := OverloadList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirOperationDefinition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'url') then result := 'uri'
  else if (propName = 'version') then result := 'string'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'title') then result := 'string'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'kind') then result := 'code'
  else if (propName = 'experimental') then result := 'boolean'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'publisher') then result := 'string'
  else if (propName = 'contact') then result := 'ContactDetail'
  else if (propName = 'description') then result := 'markdown'
  else if (propName = 'useContext') then result := 'UsageContext'
  else if (propName = 'jurisdiction') then result := 'CodeableConcept'
  else if (propName = 'purpose') then result := 'markdown'
  else if (propName = 'affectsState') then result := 'boolean'
  else if (propName = 'code') then result := 'code'
  else if (propName = 'comment') then result := 'markdown'
  else if (propName = 'base') then result := 'canonical'
  else if (propName = 'resource') then result := 'code'
  else if (propName = 'system') then result := 'boolean'
  else if (propName = 'type') then result := 'boolean'
  else if (propName = 'instance') then result := 'boolean'
  else if (propName = 'inputProfile') then result := 'canonical'
  else if (propName = 'outputProfile') then result := 'canonical'
  else if (propName = 'parameter') then result := 'BackboneElement'
  else if (propName = 'overload') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirOperationDefinition.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := nil
  else if (propName = 'version') then VersionElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'title') then TitleElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'kind') then KindElement := nil
  else if (propName = 'experimental') then ExperimentalElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'publisher') then PublisherElement := nil
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value)
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'useContext') then deletePropertyValue('useContext', UseContextList, value)
  else if (propName = 'jurisdiction') then deletePropertyValue('jurisdiction', JurisdictionList, value)
  else if (propName = 'purpose') then PurposeElement := nil
  else if (propName = 'affectsState') then AffectsStateElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'comment') then CommentElement := nil
  else if (propName = 'base') then BaseElement := nil
  else if (propName = 'system') then SystemElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'instance') then InstanceElement := nil
  else if (propName = 'inputProfile') then InputProfileElement := nil
  else if (propName = 'outputProfile') then OutputProfileElement := nil
  else if (propName = 'parameter') then deletePropertyValue('parameter', ParameterList, value)
  else if (propName = 'overload') then deletePropertyValue('overload', OverloadList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirOperationDefinition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := asUri(new)
  else if (propName = 'version') then VersionElement := asString(new)
  else if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'title') then TitleElement := asString(new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, new)
  else if (propName = 'kind') then KindElement := asEnum(SYSTEMS_TFhirOperationKindEnum, CODES_TFhirOperationKindEnum, new)
  else if (propName = 'experimental') then ExperimentalElement := asBoolean(new)
  else if (propName = 'date') then DateElement := asDateTime(new)
  else if (propName = 'publisher') then PublisherElement := asString(new)
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new)
  else if (propName = 'description') then DescriptionElement := asMarkdown(new)
  else if (propName = 'useContext') then replacePropertyValue('useContext', UseContextList, existing, new)
  else if (propName = 'jurisdiction') then replacePropertyValue('jurisdiction', JurisdictionList, existing, new)
  else if (propName = 'purpose') then PurposeElement := asMarkdown(new)
  else if (propName = 'affectsState') then AffectsStateElement := asBoolean(new)
  else if (propName = 'code') then CodeElement := asCode(new)
  else if (propName = 'comment') then CommentElement := asMarkdown(new)
  else if (propName = 'base') then BaseElement := asCanonical(new)
  else if (propName = 'system') then SystemElement := asBoolean(new)
  else if (propName = 'type') then Type_Element := asBoolean(new)
  else if (propName = 'instance') then InstanceElement := asBoolean(new)
  else if (propName = 'inputProfile') then InputProfileElement := asCanonical(new)
  else if (propName = 'outputProfile') then OutputProfileElement := asCanonical(new)
  else if (propName = 'parameter') then replacePropertyValue('parameter', ParameterList, existing, new)
  else if (propName = 'overload') then replacePropertyValue('overload', OverloadList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirOperationDefinition.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'contact') then ContactList.move(source, destination)
  else if (propName = 'useContext') then UseContextList.move(source, destination)
  else if (propName = 'jurisdiction') then JurisdictionList.move(source, destination)
  else if (propName = 'resource') then FResource.move(source, destination)
  else if (propName = 'parameter') then ParameterList.move(source, destination)
  else if (propName = 'overload') then OverloadList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirOperationDefinition.fhirType : string;
begin
  result := 'OperationDefinition';
end;

function TFhirOperationDefinition.Link : TFhirOperationDefinition;
begin
  result := TFhirOperationDefinition(inherited Link);
end;

function TFhirOperationDefinition.Clone : TFhirOperationDefinition;
begin
  result := TFhirOperationDefinition(inherited Clone);
end;

function TFhirOperationDefinition.equals(other : TObject) : boolean; 
var
  o : TFhirOperationDefinition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirOperationDefinition)) then
    result := false
  else
  begin
    o := TFhirOperationDefinition(other);
    result := compareDeep(urlElement, o.urlElement, true) and compareDeep(versionElement, o.versionElement, true) and 
      compareDeep(nameElement, o.nameElement, true) and compareDeep(titleElement, o.titleElement, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(kindElement, o.kindElement, true) and 
      compareDeep(experimentalElement, o.experimentalElement, true) and compareDeep(dateElement, o.dateElement, true) and 
      compareDeep(publisherElement, o.publisherElement, true) and compareDeep(contactList, o.contactList, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(useContextList, o.useContextList, true) and 
      compareDeep(jurisdictionList, o.jurisdictionList, true) and compareDeep(purposeElement, o.purposeElement, true) and 
      compareDeep(affectsStateElement, o.affectsStateElement, true) and compareDeep(codeElement, o.codeElement, true) and 
      compareDeep(commentElement, o.commentElement, true) and compareDeep(baseElement, o.baseElement, true) and 
      compareDeep(resourceList, o.resourceList, true) and compareDeep(systemElement, o.systemElement, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(instanceElement, o.instanceElement, true) and 
      compareDeep(inputProfileElement, o.inputProfileElement, true) and compareDeep(outputProfileElement, o.outputProfileElement, true) and 
      compareDeep(parameterList, o.parameterList, true) and compareDeep(overloadList, o.overloadList, true);
  end;
end;

function TFhirOperationDefinition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FUrl) and isEmptyProp(FVersion) and isEmptyProp(FName) and isEmptyProp(FTitle) and isEmptyProp(FStatus) and isEmptyProp(FKind) and isEmptyProp(FExperimental) and isEmptyProp(FDate) and isEmptyProp(FPublisher) and isEmptyProp(FcontactList) and isEmptyProp(FDescription) and isEmptyProp(FuseContextList) and isEmptyProp(FjurisdictionList) and isEmptyProp(FPurpose) and isEmptyProp(FAffectsState) and isEmptyProp(FCode) and isEmptyProp(FComment) and isEmptyProp(FBase) and isEmptyProp(FResource) and isEmptyProp(FSystem) and isEmptyProp(FType_) and isEmptyProp(FInstance) and isEmptyProp(FInputProfile) and isEmptyProp(FOutputProfile) and isEmptyProp(FparameterList) and isEmptyProp(FoverloadList);
end;

procedure TFhirOperationDefinition.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('url');
  fields.add('version');
  fields.add('name');
  fields.add('title');
  fields.add('status');
  fields.add('kind');
  fields.add('experimental');
  fields.add('date');
  fields.add('publisher');
  fields.add('contact');
  fields.add('description');
  fields.add('useContext');
  fields.add('jurisdiction');
  fields.add('purpose');
  fields.add('affectsState');
  fields.add('code');
  fields.add('comment');
  fields.add('base');
  fields.add('resource');
  fields.add('system');
  fields.add('type');
  fields.add('instance');
  fields.add('inputProfile');
  fields.add('outputProfile');
  fields.add('parameter');
  fields.add('overload');
end;

function TFhirOperationDefinition.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FContactList.sizeInBytes(magic));
  inc(result, FUseContextList.sizeInBytes(magic));
  inc(result, FJurisdictionList.sizeInBytes(magic));
  inc(result, FResource.sizeInBytes(magic));
  inc(result, FParameterList.sizeInBytes(magic));
  inc(result, FOverloadList.sizeInBytes(magic));
end;

procedure TFhirOperationDefinition.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

function TFhirOperationDefinition.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

procedure TFhirOperationDefinition.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

procedure TFhirOperationDefinition.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

function TFhirOperationDefinition.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

procedure TFhirOperationDefinition.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

procedure TFhirOperationDefinition.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirOperationDefinition.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirOperationDefinition.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirOperationDefinition.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

function TFhirOperationDefinition.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

procedure TFhirOperationDefinition.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

procedure TFhirOperationDefinition.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirOperationDefinition.GetStatusST : TFhirPublicationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirPublicationStatusEnum(0)
  else
    result := TFhirPublicationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirPublicationStatusEnum, FStatus.value));
end;

procedure TFhirOperationDefinition.SetStatusST(value : TFhirPublicationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[value], CODES_TFhirPublicationStatusEnum[value]);
end;

procedure TFhirOperationDefinition.SetKind(value : TFhirEnum);
begin
  FKind.free;
  FKind := value;
end;

function TFhirOperationDefinition.GetKindST : TFhirOperationKindEnum;
begin
  if FKind = nil then
    result := TFhirOperationKindEnum(0)
  else
    result := TFhirOperationKindEnum(StringArrayIndexOfSensitive(CODES_TFhirOperationKindEnum, FKind.value));
end;

procedure TFhirOperationDefinition.SetKindST(value : TFhirOperationKindEnum);
begin
  if ord(value) = 0 then
    KindElement := nil
  else
    KindElement := TFhirEnum.create(SYSTEMS_TFhirOperationKindEnum[value], CODES_TFhirOperationKindEnum[value]);
end;

procedure TFhirOperationDefinition.SetExperimental(value : TFhirBoolean);
begin
  FExperimental.free;
  FExperimental := value;
end;

function TFhirOperationDefinition.GetExperimentalST : Boolean;
begin
  if FExperimental = nil then
    result := false
  else
    result := FExperimental.value;
end;

procedure TFhirOperationDefinition.SetExperimentalST(value : Boolean);
begin
  if FExperimental = nil then
    FExperimental := TFhirBoolean.create;
  FExperimental.value := value
end;

procedure TFhirOperationDefinition.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

function TFhirOperationDefinition.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirOperationDefinition.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

procedure TFhirOperationDefinition.SetPublisher(value : TFhirString);
begin
  FPublisher.free;
  FPublisher := value;
end;

function TFhirOperationDefinition.GetPublisherST : String;
begin
  if FPublisher = nil then
    result := ''
  else
    result := FPublisher.value;
end;

procedure TFhirOperationDefinition.SetPublisherST(value : String);
begin
  if value <> '' then
  begin
    if FPublisher = nil then
      FPublisher := TFhirString.create;
    FPublisher.value := value
  end
  else if FPublisher <> nil then
    FPublisher.value := '';
end;

function TFhirOperationDefinition.GetContactList : TFhirContactDetailList;
begin
  if FContactList = nil then
    FContactList := TFhirContactDetailList.Create;
  result := FContactList;
end;

function TFhirOperationDefinition.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

procedure TFhirOperationDefinition.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirOperationDefinition.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirOperationDefinition.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirOperationDefinition.GetUseContextList : TFhirUsageContextList;
begin
  if FUseContextList = nil then
    FUseContextList := TFhirUsageContextList.Create;
  result := FUseContextList;
end;

function TFhirOperationDefinition.GetHasUseContextList : boolean;
begin
  result := (FUseContextList <> nil) and (FUseContextList.count > 0);
end;

function TFhirOperationDefinition.GetJurisdictionList : TFhirCodeableConceptList;
begin
  if FJurisdictionList = nil then
    FJurisdictionList := TFhirCodeableConceptList.Create;
  result := FJurisdictionList;
end;

function TFhirOperationDefinition.GetHasJurisdictionList : boolean;
begin
  result := (FJurisdictionList <> nil) and (FJurisdictionList.count > 0);
end;

procedure TFhirOperationDefinition.SetPurpose(value : TFhirMarkdown);
begin
  FPurpose.free;
  FPurpose := value;
end;

function TFhirOperationDefinition.GetPurposeST : String;
begin
  if FPurpose = nil then
    result := ''
  else
    result := FPurpose.value;
end;

procedure TFhirOperationDefinition.SetPurposeST(value : String);
begin
  if value <> '' then
  begin
    if FPurpose = nil then
      FPurpose := TFhirMarkdown.create;
    FPurpose.value := value
  end
  else if FPurpose <> nil then
    FPurpose.value := '';
end;

procedure TFhirOperationDefinition.SetAffectsState(value : TFhirBoolean);
begin
  FAffectsState.free;
  FAffectsState := value;
end;

function TFhirOperationDefinition.GetAffectsStateST : Boolean;
begin
  if FAffectsState = nil then
    result := false
  else
    result := FAffectsState.value;
end;

procedure TFhirOperationDefinition.SetAffectsStateST(value : Boolean);
begin
  if FAffectsState = nil then
    FAffectsState := TFhirBoolean.create;
  FAffectsState.value := value
end;

procedure TFhirOperationDefinition.SetCode(value : TFhirCode);
begin
  FCode.free;
  FCode := value;
end;

function TFhirOperationDefinition.GetCodeST : String;
begin
  if FCode = nil then
    result := ''
  else
    result := FCode.value;
end;

procedure TFhirOperationDefinition.SetCodeST(value : String);
begin
  if value <> '' then
  begin
    if FCode = nil then
      FCode := TFhirCode.create;
    FCode.value := value
  end
  else if FCode <> nil then
    FCode.value := '';
end;

procedure TFhirOperationDefinition.SetComment(value : TFhirMarkdown);
begin
  FComment.free;
  FComment := value;
end;

function TFhirOperationDefinition.GetCommentST : String;
begin
  if FComment = nil then
    result := ''
  else
    result := FComment.value;
end;

procedure TFhirOperationDefinition.SetCommentST(value : String);
begin
  if value <> '' then
  begin
    if FComment = nil then
      FComment := TFhirMarkdown.create;
    FComment.value := value
  end
  else if FComment <> nil then
    FComment.value := '';
end;

procedure TFhirOperationDefinition.SetBase(value : TFhirCanonical);
begin
  FBase.free;
  FBase := value;
end;

function TFhirOperationDefinition.GetBaseST : String;
begin
  if FBase = nil then
    result := ''
  else
    result := FBase.value;
end;

procedure TFhirOperationDefinition.SetBaseST(value : String);
begin
  if value <> '' then
  begin
    if FBase = nil then
      FBase := TFhirCanonical.create;
    FBase.value := value
  end
  else if FBase <> nil then
    FBase.value := '';
end;

function TFhirOperationDefinition.GetResource : TFhirEnumList;
begin
  if FResource = nil then
    FResource := TFhirEnumList.Create(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum);
  result := FResource;
end;

function TFhirOperationDefinition.GetHasResource : boolean;
begin
  result := (FResource <> nil) and (FResource.count > 0);
end;

procedure TFhirOperationDefinition.SetSystem(value : TFhirBoolean);
begin
  FSystem.free;
  FSystem := value;
end;

function TFhirOperationDefinition.GetSystemST : Boolean;
begin
  if FSystem = nil then
    result := false
  else
    result := FSystem.value;
end;

procedure TFhirOperationDefinition.SetSystemST(value : Boolean);
begin
  if FSystem = nil then
    FSystem := TFhirBoolean.create;
  FSystem.value := value
end;

procedure TFhirOperationDefinition.SetType_(value : TFhirBoolean);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirOperationDefinition.GetType_ST : Boolean;
begin
  if FType_ = nil then
    result := false
  else
    result := FType_.value;
end;

procedure TFhirOperationDefinition.SetType_ST(value : Boolean);
begin
  if FType_ = nil then
    FType_ := TFhirBoolean.create;
  FType_.value := value
end;

procedure TFhirOperationDefinition.SetInstance(value : TFhirBoolean);
begin
  FInstance.free;
  FInstance := value;
end;

function TFhirOperationDefinition.GetInstanceST : Boolean;
begin
  if FInstance = nil then
    result := false
  else
    result := FInstance.value;
end;

procedure TFhirOperationDefinition.SetInstanceST(value : Boolean);
begin
  if FInstance = nil then
    FInstance := TFhirBoolean.create;
  FInstance.value := value
end;

procedure TFhirOperationDefinition.SetInputProfile(value : TFhirCanonical);
begin
  FInputProfile.free;
  FInputProfile := value;
end;

function TFhirOperationDefinition.GetInputProfileST : String;
begin
  if FInputProfile = nil then
    result := ''
  else
    result := FInputProfile.value;
end;

procedure TFhirOperationDefinition.SetInputProfileST(value : String);
begin
  if value <> '' then
  begin
    if FInputProfile = nil then
      FInputProfile := TFhirCanonical.create;
    FInputProfile.value := value
  end
  else if FInputProfile <> nil then
    FInputProfile.value := '';
end;

procedure TFhirOperationDefinition.SetOutputProfile(value : TFhirCanonical);
begin
  FOutputProfile.free;
  FOutputProfile := value;
end;

function TFhirOperationDefinition.GetOutputProfileST : String;
begin
  if FOutputProfile = nil then
    result := ''
  else
    result := FOutputProfile.value;
end;

procedure TFhirOperationDefinition.SetOutputProfileST(value : String);
begin
  if value <> '' then
  begin
    if FOutputProfile = nil then
      FOutputProfile := TFhirCanonical.create;
    FOutputProfile.value := value
  end
  else if FOutputProfile <> nil then
    FOutputProfile.value := '';
end;

function TFhirOperationDefinition.GetParameterList : TFhirOperationDefinitionParameterList;
begin
  if FParameterList = nil then
    FParameterList := TFhirOperationDefinitionParameterList.Create;
  result := FParameterList;
end;

function TFhirOperationDefinition.GetHasParameterList : boolean;
begin
  result := (FParameterList <> nil) and (FParameterList.count > 0);
end;

function TFhirOperationDefinition.GetOverloadList : TFhirOperationDefinitionOverloadList;
begin
  if FOverloadList = nil then
    FOverloadList := TFhirOperationDefinitionOverloadList.Create;
  result := FOverloadList;
end;

function TFhirOperationDefinition.GetHasOverloadList : boolean;
begin
  result := (FOverloadList <> nil) and (FOverloadList.count > 0);
end;

{ TFhirOperationDefinitionListEnumerator }

constructor TFhirOperationDefinitionListEnumerator.Create(list : TFhirOperationDefinitionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirOperationDefinitionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirOperationDefinitionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirOperationDefinitionListEnumerator.GetCurrent : TFhirOperationDefinition;
begin
  Result := FList[FIndex];
end;

function TFhirOperationDefinitionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirOperationDefinitionList }

function TFhirOperationDefinitionList.AddItem(value: TFhirOperationDefinition): TFhirOperationDefinition;
begin
  assert(value.ClassName = 'TFhirOperationDefinition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirOperationDefinition');
  add(value);
  result := value;
end;

function TFhirOperationDefinitionList.Append: TFhirOperationDefinition;
begin
  result := TFhirOperationDefinition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOperationDefinitionList.ClearItems;
begin
  Clear;
end;

function TFhirOperationDefinitionList.GetEnumerator : TFhirOperationDefinitionListEnumerator;
begin
  result := TFhirOperationDefinitionListEnumerator.Create(self.link);
end;

function TFhirOperationDefinitionList.Clone: TFhirOperationDefinitionList;
begin
  result := TFhirOperationDefinitionList(inherited Clone);
end;

function TFhirOperationDefinitionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirOperationDefinitionList.GetItemN(index: Integer): TFhirOperationDefinition;
begin
  result := TFhirOperationDefinition(ObjectByIndex[index]);
end;

function TFhirOperationDefinitionList.ItemClass: TFslObjectClass;
begin
  result := TFhirOperationDefinition;
end;
function TFhirOperationDefinitionList.IndexOf(value: TFhirOperationDefinition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirOperationDefinitionList.Insert(index: Integer): TFhirOperationDefinition;
begin
  result := TFhirOperationDefinition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOperationDefinitionList.InsertItem(index: Integer; value: TFhirOperationDefinition);
begin
  assert(value is TFhirOperationDefinition);
  Inherited Insert(index, value);
end;

function TFhirOperationDefinitionList.Item(index: Integer): TFhirOperationDefinition;
begin
  result := TFhirOperationDefinition(ObjectByIndex[index]);
end;

function TFhirOperationDefinitionList.Link: TFhirOperationDefinitionList;
begin
  result := TFhirOperationDefinitionList(inherited Link);
end;

procedure TFhirOperationDefinitionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirOperationDefinitionList.SetItemByIndex(index: Integer; value: TFhirOperationDefinition);
begin
  assert(value is TFhirOperationDefinition);
  FhirOperationDefinitions[index] := value;
end;

procedure TFhirOperationDefinitionList.SetItemN(index: Integer; value: TFhirOperationDefinition);
begin
  assert(value is TFhirOperationDefinition);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_OPERATIONDEFINITION}
{$IFDEF FHIR_QUESTIONNAIRE}
{ TFhirQuestionnaireItem }

constructor TFhirQuestionnaireItem.Create;
begin
  inherited;
end;

destructor TFhirQuestionnaireItem.Destroy;
begin
  FLinkId.free;
  FDefinition.free;
  FCodeList.Free;
  FPrefix.free;
  FText.free;
  FType_.free;
  FEnableWhenList.Free;
  FEnableBehavior.free;
  FRequired.free;
  FRepeats.free;
  FReadOnly.free;
  FMaxLength.free;
  FAnswerValueSet.free;
  FAnswerOptionList.Free;
  FInitialList.Free;
  FItemList.Free;
  inherited;
end;

procedure TFhirQuestionnaireItem.Assign(oSource : TFslObject);
begin
  inherited;
  linkIdElement := TFhirQuestionnaireItem(oSource).linkIdElement.Clone;
  definitionElement := TFhirQuestionnaireItem(oSource).definitionElement.Clone;
  if (TFhirQuestionnaireItem(oSource).FCodeList = nil) then
  begin
    FCodeList.free;
    FCodeList := nil;
  end
  else
  begin
    if FCodeList = nil then
      FCodeList := TFhirCodingList.Create;
    FCodeList.Assign(TFhirQuestionnaireItem(oSource).FCodeList);
  end;
  prefixElement := TFhirQuestionnaireItem(oSource).prefixElement.Clone;
  textElement := TFhirQuestionnaireItem(oSource).textElement.Clone;
  type_Element := TFhirQuestionnaireItem(oSource).type_Element.Clone;
  if (TFhirQuestionnaireItem(oSource).FEnableWhenList = nil) then
  begin
    FEnableWhenList.free;
    FEnableWhenList := nil;
  end
  else
  begin
    if FEnableWhenList = nil then
      FEnableWhenList := TFhirQuestionnaireItemEnableWhenList.Create;
    FEnableWhenList.Assign(TFhirQuestionnaireItem(oSource).FEnableWhenList);
  end;
  enableBehaviorElement := TFhirQuestionnaireItem(oSource).enableBehaviorElement.Clone;
  requiredElement := TFhirQuestionnaireItem(oSource).requiredElement.Clone;
  repeatsElement := TFhirQuestionnaireItem(oSource).repeatsElement.Clone;
  readOnlyElement := TFhirQuestionnaireItem(oSource).readOnlyElement.Clone;
  maxLengthElement := TFhirQuestionnaireItem(oSource).maxLengthElement.Clone;
  answerValueSetElement := TFhirQuestionnaireItem(oSource).answerValueSetElement.Clone;
  if (TFhirQuestionnaireItem(oSource).FAnswerOptionList = nil) then
  begin
    FAnswerOptionList.free;
    FAnswerOptionList := nil;
  end
  else
  begin
    if FAnswerOptionList = nil then
      FAnswerOptionList := TFhirQuestionnaireItemAnswerOptionList.Create;
    FAnswerOptionList.Assign(TFhirQuestionnaireItem(oSource).FAnswerOptionList);
  end;
  if (TFhirQuestionnaireItem(oSource).FInitialList = nil) then
  begin
    FInitialList.free;
    FInitialList := nil;
  end
  else
  begin
    if FInitialList = nil then
      FInitialList := TFhirQuestionnaireItemInitialList.Create;
    FInitialList.Assign(TFhirQuestionnaireItem(oSource).FInitialList);
  end;
  if (TFhirQuestionnaireItem(oSource).FItemList = nil) then
  begin
    FItemList.free;
    FItemList := nil;
  end
  else
  begin
    if FItemList = nil then
      FItemList := TFhirQuestionnaireItemList.Create;
    FItemList.Assign(TFhirQuestionnaireItem(oSource).FItemList);
  end;
end;

procedure TFhirQuestionnaireItem.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'linkId') Then
     list.add(self.link, 'linkId', FLinkId.Link);
  if (child_name = 'definition') Then
     list.add(self.link, 'definition', FDefinition.Link);
  if (child_name = 'code') Then
    list.addAll(self, 'code', FCodeList);
  if (child_name = 'prefix') Then
     list.add(self.link, 'prefix', FPrefix.Link);
  if (child_name = 'text') Then
     list.add(self.link, 'text', FText.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'enableWhen') Then
    list.addAll(self, 'enableWhen', FEnableWhenList);
  if (child_name = 'enableBehavior') Then
     list.add(self.link, 'enableBehavior', FEnableBehavior.Link);
  if (child_name = 'required') Then
     list.add(self.link, 'required', FRequired.Link);
  if (child_name = 'repeats') Then
     list.add(self.link, 'repeats', FRepeats.Link);
  if (child_name = 'readOnly') Then
     list.add(self.link, 'readOnly', FReadOnly.Link);
  if (child_name = 'maxLength') Then
     list.add(self.link, 'maxLength', FMaxLength.Link);
  if (child_name = 'answerValueSet') Then
     list.add(self.link, 'answerValueSet', FAnswerValueSet.Link);
  if (child_name = 'answerOption') Then
    list.addAll(self, 'answerOption', FAnswerOptionList);
  if (child_name = 'initial') Then
    list.addAll(self, 'initial', FInitialList);
  if (child_name = 'item') Then
    list.addAll(self, 'item', FItemList);
end;

procedure TFhirQuestionnaireItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'linkId', 'string', false, TFhirString, FLinkId.Link));
  oList.add(TFHIRProperty.create(self, 'definition', 'uri', false, TFhirUri, FDefinition.Link));
  oList.add(TFHIRProperty.create(self, 'code', 'Coding', true, TFhirCoding, FCodeList.Link));
  oList.add(TFHIRProperty.create(self, 'prefix', 'string', false, TFhirString, FPrefix.Link));
  oList.add(TFHIRProperty.create(self, 'text', 'string', false, TFhirString, FText.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFhirEnum, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'enableWhen', 'BackboneElement', true, TFhirQuestionnaireItemEnableWhen, FEnableWhenList.Link));
  oList.add(TFHIRProperty.create(self, 'enableBehavior', 'code', false, TFhirEnum, FEnableBehavior.Link));
  oList.add(TFHIRProperty.create(self, 'required', 'boolean', false, TFhirBoolean, FRequired.Link));
  oList.add(TFHIRProperty.create(self, 'repeats', 'boolean', false, TFhirBoolean, FRepeats.Link));
  oList.add(TFHIRProperty.create(self, 'readOnly', 'boolean', false, TFhirBoolean, FReadOnly.Link));
  oList.add(TFHIRProperty.create(self, 'maxLength', 'integer', false, TFhirInteger, FMaxLength.Link));
  oList.add(TFHIRProperty.create(self, 'answerValueSet', 'canonical', false, TFhirCanonical, FAnswerValueSet.Link));
  oList.add(TFHIRProperty.create(self, 'answerOption', 'BackboneElement', true, TFhirQuestionnaireItemAnswerOption, FAnswerOptionList.Link));
  oList.add(TFHIRProperty.create(self, 'initial', 'BackboneElement', true, TFhirQuestionnaireItemInitial, FInitialList.Link));
  oList.add(TFHIRProperty.create(self, 'item', '', true, TFhirQuestionnaireItem, FItemList.Link));
end;

function TFhirQuestionnaireItem.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'linkId') then
  begin
    LinkIdElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'definition') then
  begin
    DefinitionElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    CodeList.add(propValue as TFhirCoding);
    result := propValue;
  end
  else if (propName = 'prefix') then
  begin
    PrefixElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'text') then
  begin
    TextElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirQuestionnaireItemTypeEnum, CODES_TFhirQuestionnaireItemTypeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'enableWhen') then
  begin
    EnableWhenList.add(propValue as TFhirQuestionnaireItemEnableWhen);
    result := propValue;
  end
  else if (propName = 'enableBehavior') then
  begin
    EnableBehaviorElement := asEnum(SYSTEMS_TFhirEnableWhenBehaviorEnum, CODES_TFhirEnableWhenBehaviorEnum, propValue);
    result := propValue;
  end
  else if (propName = 'required') then
  begin
    RequiredElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'repeats') then
  begin
    RepeatsElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'readOnly') then
  begin
    ReadOnlyElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'maxLength') then
  begin
    MaxLengthElement := asInteger(propValue);
    result := propValue;
  end
  else if (propName = 'answerValueSet') then
  begin
    AnswerValueSetElement := asCanonical(propValue);
    result := propValue;
  end
  else if (propName = 'answerOption') then
  begin
    AnswerOptionList.add(propValue as TFhirQuestionnaireItemAnswerOption);
    result := propValue;
  end
  else if (propName = 'initial') then
  begin
    InitialList.add(propValue as TFhirQuestionnaireItemInitial);
    result := propValue;
  end
  else if (propName = 'item') then
  begin
    ItemList.add(propValue as TFhirQuestionnaireItem);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirQuestionnaireItem.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'code') then CodeList.insertItem(index, propValue as TFhirCoding)
  else if (propName = 'enableWhen') then EnableWhenList.insertItem(index, propValue as TFhirQuestionnaireItemEnableWhen)
  else if (propName = 'answerOption') then AnswerOptionList.insertItem(index, propValue as TFhirQuestionnaireItemAnswerOption)
  else if (propName = 'initial') then InitialList.insertItem(index, propValue as TFhirQuestionnaireItemInitial)
  else if (propName = 'item') then ItemList.insertItem(index, propValue as TFhirQuestionnaireItem)
  else inherited;
end;

function TFhirQuestionnaireItem.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'linkId') then result := TFhirString.create()
  else if (propName = 'definition') then result := TFhirUri.create()
  else if (propName = 'code') then result := CodeList.new()
  else if (propName = 'prefix') then result := TFhirString.create()
  else if (propName = 'text') then result := TFhirString.create()
  else if (propName = 'type') then result := TFhirEnum.create(SYSTEMS_TFhirQuestionnaireItemTypeEnum[QuestionnaireItemTypeNull], CODES_TFhirQuestionnaireItemTypeEnum[QuestionnaireItemTypeNull]) 
  else if (propName = 'enableWhen') then result := EnableWhenList.new()
  else if (propName = 'enableBehavior') then result := TFhirEnum.create(SYSTEMS_TFhirEnableWhenBehaviorEnum[EnableWhenBehaviorNull], CODES_TFhirEnableWhenBehaviorEnum[EnableWhenBehaviorNull]) 
  else if (propName = 'required') then result := TFhirBoolean.create()
  else if (propName = 'repeats') then result := TFhirBoolean.create()
  else if (propName = 'readOnly') then result := TFhirBoolean.create()
  else if (propName = 'maxLength') then result := TFhirInteger.create()
  else if (propName = 'answerValueSet') then result := TFhirCanonical.create()
  else if (propName = 'answerOption') then result := AnswerOptionList.new()
  else if (propName = 'initial') then result := InitialList.new()
  else if (propName = 'item') then result := ItemList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirQuestionnaireItem.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'linkId') then result := 'string'
  else if (propName = 'definition') then result := 'uri'
  else if (propName = 'code') then result := 'Coding'
  else if (propName = 'prefix') then result := 'string'
  else if (propName = 'text') then result := 'string'
  else if (propName = 'type') then result := 'code'
  else if (propName = 'enableWhen') then result := 'BackboneElement'
  else if (propName = 'enableBehavior') then result := 'code'
  else if (propName = 'required') then result := 'boolean'
  else if (propName = 'repeats') then result := 'boolean'
  else if (propName = 'readOnly') then result := 'boolean'
  else if (propName = 'maxLength') then result := 'integer'
  else if (propName = 'answerValueSet') then result := 'canonical'
  else if (propName = 'answerOption') then result := 'BackboneElement'
  else if (propName = 'initial') then result := 'BackboneElement'
  else if (propName = 'item') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirQuestionnaireItem.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'linkId') then LinkIdElement := nil
  else if (propName = 'definition') then DefinitionElement := nil
  else if (propName = 'code') then deletePropertyValue('code', CodeList, value)
  else if (propName = 'prefix') then PrefixElement := nil
  else if (propName = 'text') then TextElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'enableWhen') then deletePropertyValue('enableWhen', EnableWhenList, value)
  else if (propName = 'enableBehavior') then EnableBehaviorElement := nil
  else if (propName = 'required') then RequiredElement := nil
  else if (propName = 'repeats') then RepeatsElement := nil
  else if (propName = 'readOnly') then ReadOnlyElement := nil
  else if (propName = 'maxLength') then MaxLengthElement := nil
  else if (propName = 'answerValueSet') then AnswerValueSetElement := nil
  else if (propName = 'answerOption') then deletePropertyValue('answerOption', AnswerOptionList, value)
  else if (propName = 'initial') then deletePropertyValue('initial', InitialList, value)
  else if (propName = 'item') then deletePropertyValue('item', ItemList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirQuestionnaireItem.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'linkId') then LinkIdElement := asString(new)
  else if (propName = 'definition') then DefinitionElement := asUri(new)
  else if (propName = 'code') then replacePropertyValue('code', CodeList, existing, new)
  else if (propName = 'prefix') then PrefixElement := asString(new)
  else if (propName = 'text') then TextElement := asString(new)
  else if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirQuestionnaireItemTypeEnum, CODES_TFhirQuestionnaireItemTypeEnum, new)
  else if (propName = 'enableWhen') then replacePropertyValue('enableWhen', EnableWhenList, existing, new)
  else if (propName = 'enableBehavior') then EnableBehaviorElement := asEnum(SYSTEMS_TFhirEnableWhenBehaviorEnum, CODES_TFhirEnableWhenBehaviorEnum, new)
  else if (propName = 'required') then RequiredElement := asBoolean(new)
  else if (propName = 'repeats') then RepeatsElement := asBoolean(new)
  else if (propName = 'readOnly') then ReadOnlyElement := asBoolean(new)
  else if (propName = 'maxLength') then MaxLengthElement := asInteger(new)
  else if (propName = 'answerValueSet') then AnswerValueSetElement := asCanonical(new)
  else if (propName = 'answerOption') then replacePropertyValue('answerOption', AnswerOptionList, existing, new)
  else if (propName = 'initial') then replacePropertyValue('initial', InitialList, existing, new)
  else if (propName = 'item') then replacePropertyValue('item', ItemList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirQuestionnaireItem.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'code') then CodeList.move(source, destination)
  else if (propName = 'enableWhen') then EnableWhenList.move(source, destination)
  else if (propName = 'answerOption') then AnswerOptionList.move(source, destination)
  else if (propName = 'initial') then InitialList.move(source, destination)
  else if (propName = 'item') then ItemList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirQuestionnaireItem.fhirType : string;
begin
  result := 'Questionnaire.item';
end;

function TFhirQuestionnaireItem.Link : TFhirQuestionnaireItem;
begin
  result := TFhirQuestionnaireItem(inherited Link);
end;

function TFhirQuestionnaireItem.Clone : TFhirQuestionnaireItem;
begin
  result := TFhirQuestionnaireItem(inherited Clone);
end;

function TFhirQuestionnaireItem.equals(other : TObject) : boolean; 
var
  o : TFhirQuestionnaireItem;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirQuestionnaireItem)) then
    result := false
  else
  begin
    o := TFhirQuestionnaireItem(other);
    result := compareDeep(linkIdElement, o.linkIdElement, true) and compareDeep(definitionElement, o.definitionElement, true) and 
      compareDeep(codeList, o.codeList, true) and compareDeep(prefixElement, o.prefixElement, true) and 
      compareDeep(textElement, o.textElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(enableWhenList, o.enableWhenList, true) and compareDeep(enableBehaviorElement, o.enableBehaviorElement, true) and 
      compareDeep(requiredElement, o.requiredElement, true) and compareDeep(repeatsElement, o.repeatsElement, true) and 
      compareDeep(readOnlyElement, o.readOnlyElement, true) and compareDeep(maxLengthElement, o.maxLengthElement, true) and 
      compareDeep(answerValueSetElement, o.answerValueSetElement, true) and compareDeep(answerOptionList, o.answerOptionList, true) and 
      compareDeep(initialList, o.initialList, true) and compareDeep(itemList, o.itemList, true);
  end;
end;

function TFhirQuestionnaireItem.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FLinkId) and isEmptyProp(FDefinition) and isEmptyProp(FcodeList) and isEmptyProp(FPrefix) and isEmptyProp(FText) and isEmptyProp(FType_) and isEmptyProp(FenableWhenList) and isEmptyProp(FEnableBehavior) and isEmptyProp(FRequired) and isEmptyProp(FRepeats) and isEmptyProp(FReadOnly) and isEmptyProp(FMaxLength) and isEmptyProp(FAnswerValueSet) and isEmptyProp(FanswerOptionList) and isEmptyProp(FinitialList) and isEmptyProp(FitemList);
end;

procedure TFhirQuestionnaireItem.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('linkId');
  fields.add('definition');
  fields.add('code');
  fields.add('prefix');
  fields.add('text');
  fields.add('type');
  fields.add('enableWhen');
  fields.add('enableBehavior');
  fields.add('required');
  fields.add('repeats');
  fields.add('readOnly');
  fields.add('maxLength');
  fields.add('answerValueSet');
  fields.add('answerOption');
  fields.add('initial');
  fields.add('item');
end;

function TFhirQuestionnaireItem.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FCodeList.sizeInBytes(magic));
  inc(result, FEnableWhenList.sizeInBytes(magic));
  inc(result, FAnswerOptionList.sizeInBytes(magic));
  inc(result, FInitialList.sizeInBytes(magic));
  inc(result, FItemList.sizeInBytes(magic));
end;

procedure TFhirQuestionnaireItem.SetLinkId(value : TFhirString);
begin
  FLinkId.free;
  FLinkId := value;
end;

function TFhirQuestionnaireItem.GetLinkIdST : String;
begin
  if FLinkId = nil then
    result := ''
  else
    result := FLinkId.value;
end;

procedure TFhirQuestionnaireItem.SetLinkIdST(value : String);
begin
  if value <> '' then
  begin
    if FLinkId = nil then
      FLinkId := TFhirString.create;
    FLinkId.value := value
  end
  else if FLinkId <> nil then
    FLinkId.value := '';
end;

procedure TFhirQuestionnaireItem.SetDefinition(value : TFhirUri);
begin
  FDefinition.free;
  FDefinition := value;
end;

function TFhirQuestionnaireItem.GetDefinitionST : String;
begin
  if FDefinition = nil then
    result := ''
  else
    result := FDefinition.value;
end;

procedure TFhirQuestionnaireItem.SetDefinitionST(value : String);
begin
  if value <> '' then
  begin
    if FDefinition = nil then
      FDefinition := TFhirUri.create;
    FDefinition.value := value
  end
  else if FDefinition <> nil then
    FDefinition.value := '';
end;

function TFhirQuestionnaireItem.GetCodeList : TFhirCodingList;
begin
  if FCodeList = nil then
    FCodeList := TFhirCodingList.Create;
  result := FCodeList;
end;

function TFhirQuestionnaireItem.GetHasCodeList : boolean;
begin
  result := (FCodeList <> nil) and (FCodeList.count > 0);
end;

procedure TFhirQuestionnaireItem.SetPrefix(value : TFhirString);
begin
  FPrefix.free;
  FPrefix := value;
end;

function TFhirQuestionnaireItem.GetPrefixST : String;
begin
  if FPrefix = nil then
    result := ''
  else
    result := FPrefix.value;
end;

procedure TFhirQuestionnaireItem.SetPrefixST(value : String);
begin
  if value <> '' then
  begin
    if FPrefix = nil then
      FPrefix := TFhirString.create;
    FPrefix.value := value
  end
  else if FPrefix <> nil then
    FPrefix.value := '';
end;

procedure TFhirQuestionnaireItem.SetText(value : TFhirString);
begin
  FText.free;
  FText := value;
end;

function TFhirQuestionnaireItem.GetTextST : String;
begin
  if FText = nil then
    result := ''
  else
    result := FText.value;
end;

procedure TFhirQuestionnaireItem.SetTextST(value : String);
begin
  if value <> '' then
  begin
    if FText = nil then
      FText := TFhirString.create;
    FText.value := value
  end
  else if FText <> nil then
    FText.value := '';
end;

procedure TFhirQuestionnaireItem.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirQuestionnaireItem.GetType_ST : TFhirQuestionnaireItemTypeEnum;
begin
  if FType_ = nil then
    result := TFhirQuestionnaireItemTypeEnum(0)
  else
    result := TFhirQuestionnaireItemTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirQuestionnaireItemTypeEnum, FType_.value));
end;

procedure TFhirQuestionnaireItem.SetType_ST(value : TFhirQuestionnaireItemTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirQuestionnaireItemTypeEnum[value], CODES_TFhirQuestionnaireItemTypeEnum[value]);
end;

function TFhirQuestionnaireItem.GetEnableWhenList : TFhirQuestionnaireItemEnableWhenList;
begin
  if FEnableWhenList = nil then
    FEnableWhenList := TFhirQuestionnaireItemEnableWhenList.Create;
  result := FEnableWhenList;
end;

function TFhirQuestionnaireItem.GetHasEnableWhenList : boolean;
begin
  result := (FEnableWhenList <> nil) and (FEnableWhenList.count > 0);
end;

procedure TFhirQuestionnaireItem.SetEnableBehavior(value : TFhirEnum);
begin
  FEnableBehavior.free;
  FEnableBehavior := value;
end;

function TFhirQuestionnaireItem.GetEnableBehaviorST : TFhirEnableWhenBehaviorEnum;
begin
  if FEnableBehavior = nil then
    result := TFhirEnableWhenBehaviorEnum(0)
  else
    result := TFhirEnableWhenBehaviorEnum(StringArrayIndexOfSensitive(CODES_TFhirEnableWhenBehaviorEnum, FEnableBehavior.value));
end;

procedure TFhirQuestionnaireItem.SetEnableBehaviorST(value : TFhirEnableWhenBehaviorEnum);
begin
  if ord(value) = 0 then
    EnableBehaviorElement := nil
  else
    EnableBehaviorElement := TFhirEnum.create(SYSTEMS_TFhirEnableWhenBehaviorEnum[value], CODES_TFhirEnableWhenBehaviorEnum[value]);
end;

procedure TFhirQuestionnaireItem.SetRequired(value : TFhirBoolean);
begin
  FRequired.free;
  FRequired := value;
end;

function TFhirQuestionnaireItem.GetRequiredST : Boolean;
begin
  if FRequired = nil then
    result := false
  else
    result := FRequired.value;
end;

procedure TFhirQuestionnaireItem.SetRequiredST(value : Boolean);
begin
  if FRequired = nil then
    FRequired := TFhirBoolean.create;
  FRequired.value := value
end;

procedure TFhirQuestionnaireItem.SetRepeats(value : TFhirBoolean);
begin
  FRepeats.free;
  FRepeats := value;
end;

function TFhirQuestionnaireItem.GetRepeatsST : Boolean;
begin
  if FRepeats = nil then
    result := false
  else
    result := FRepeats.value;
end;

procedure TFhirQuestionnaireItem.SetRepeatsST(value : Boolean);
begin
  if FRepeats = nil then
    FRepeats := TFhirBoolean.create;
  FRepeats.value := value
end;

procedure TFhirQuestionnaireItem.SetReadOnly(value : TFhirBoolean);
begin
  FReadOnly.free;
  FReadOnly := value;
end;

function TFhirQuestionnaireItem.GetReadOnlyST : Boolean;
begin
  if FReadOnly = nil then
    result := false
  else
    result := FReadOnly.value;
end;

procedure TFhirQuestionnaireItem.SetReadOnlyST(value : Boolean);
begin
  if FReadOnly = nil then
    FReadOnly := TFhirBoolean.create;
  FReadOnly.value := value
end;

procedure TFhirQuestionnaireItem.SetMaxLength(value : TFhirInteger);
begin
  FMaxLength.free;
  FMaxLength := value;
end;

function TFhirQuestionnaireItem.GetMaxLengthST : String;
begin
  if FMaxLength = nil then
    result := ''
  else
    result := FMaxLength.value;
end;

procedure TFhirQuestionnaireItem.SetMaxLengthST(value : String);
begin
  if value <> '' then
  begin
    if FMaxLength = nil then
      FMaxLength := TFhirInteger.create;
    FMaxLength.value := value
  end
  else if FMaxLength <> nil then
    FMaxLength.value := '';
end;

procedure TFhirQuestionnaireItem.SetAnswerValueSet(value : TFhirCanonical);
begin
  FAnswerValueSet.free;
  FAnswerValueSet := value;
end;

function TFhirQuestionnaireItem.GetAnswerValueSetST : String;
begin
  if FAnswerValueSet = nil then
    result := ''
  else
    result := FAnswerValueSet.value;
end;

procedure TFhirQuestionnaireItem.SetAnswerValueSetST(value : String);
begin
  if value <> '' then
  begin
    if FAnswerValueSet = nil then
      FAnswerValueSet := TFhirCanonical.create;
    FAnswerValueSet.value := value
  end
  else if FAnswerValueSet <> nil then
    FAnswerValueSet.value := '';
end;

function TFhirQuestionnaireItem.GetAnswerOptionList : TFhirQuestionnaireItemAnswerOptionList;
begin
  if FAnswerOptionList = nil then
    FAnswerOptionList := TFhirQuestionnaireItemAnswerOptionList.Create;
  result := FAnswerOptionList;
end;

function TFhirQuestionnaireItem.GetHasAnswerOptionList : boolean;
begin
  result := (FAnswerOptionList <> nil) and (FAnswerOptionList.count > 0);
end;

function TFhirQuestionnaireItem.GetInitialList : TFhirQuestionnaireItemInitialList;
begin
  if FInitialList = nil then
    FInitialList := TFhirQuestionnaireItemInitialList.Create;
  result := FInitialList;
end;

function TFhirQuestionnaireItem.GetHasInitialList : boolean;
begin
  result := (FInitialList <> nil) and (FInitialList.count > 0);
end;

function TFhirQuestionnaireItem.GetItemList : TFhirQuestionnaireItemList;
begin
  if FItemList = nil then
    FItemList := TFhirQuestionnaireItemList.Create;
  result := FItemList;
end;

function TFhirQuestionnaireItem.GetHasItemList : boolean;
begin
  result := (FItemList <> nil) and (FItemList.count > 0);
end;

{ TFhirQuestionnaireItemListEnumerator }

constructor TFhirQuestionnaireItemListEnumerator.Create(list : TFhirQuestionnaireItemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirQuestionnaireItemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirQuestionnaireItemListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirQuestionnaireItemListEnumerator.GetCurrent : TFhirQuestionnaireItem;
begin
  Result := FList[FIndex];
end;

function TFhirQuestionnaireItemListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirQuestionnaireItemList }

function TFhirQuestionnaireItemList.AddItem(value: TFhirQuestionnaireItem): TFhirQuestionnaireItem;
begin
  assert(value.ClassName = 'TFhirQuestionnaireItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirQuestionnaireItem');
  add(value);
  result := value;
end;

function TFhirQuestionnaireItemList.Append: TFhirQuestionnaireItem;
begin
  result := TFhirQuestionnaireItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirQuestionnaireItemList.ClearItems;
begin
  Clear;
end;

function TFhirQuestionnaireItemList.GetEnumerator : TFhirQuestionnaireItemListEnumerator;
begin
  result := TFhirQuestionnaireItemListEnumerator.Create(self.link);
end;

function TFhirQuestionnaireItemList.Clone: TFhirQuestionnaireItemList;
begin
  result := TFhirQuestionnaireItemList(inherited Clone);
end;

function TFhirQuestionnaireItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirQuestionnaireItemList.GetItemN(index: Integer): TFhirQuestionnaireItem;
begin
  result := TFhirQuestionnaireItem(ObjectByIndex[index]);
end;

function TFhirQuestionnaireItemList.ItemClass: TFslObjectClass;
begin
  result := TFhirQuestionnaireItem;
end;
function TFhirQuestionnaireItemList.IndexOf(value: TFhirQuestionnaireItem): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirQuestionnaireItemList.Insert(index: Integer): TFhirQuestionnaireItem;
begin
  result := TFhirQuestionnaireItem.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirQuestionnaireItemList.InsertItem(index: Integer; value: TFhirQuestionnaireItem);
begin
  assert(value is TFhirQuestionnaireItem);
  Inherited Insert(index, value);
end;

function TFhirQuestionnaireItemList.Item(index: Integer): TFhirQuestionnaireItem;
begin
  result := TFhirQuestionnaireItem(ObjectByIndex[index]);
end;

function TFhirQuestionnaireItemList.Link: TFhirQuestionnaireItemList;
begin
  result := TFhirQuestionnaireItemList(inherited Link);
end;

procedure TFhirQuestionnaireItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirQuestionnaireItemList.SetItemByIndex(index: Integer; value: TFhirQuestionnaireItem);
begin
  assert(value is TFhirQuestionnaireItem);
  FhirQuestionnaireItems[index] := value;
end;

procedure TFhirQuestionnaireItemList.SetItemN(index: Integer; value: TFhirQuestionnaireItem);
begin
  assert(value is TFhirQuestionnaireItem);
  ObjectByIndex[index] := value;
end;

{ TFhirQuestionnaireItemEnableWhen }

constructor TFhirQuestionnaireItemEnableWhen.Create;
begin
  inherited;
end;

destructor TFhirQuestionnaireItemEnableWhen.Destroy;
begin
  FQuestion.free;
  FOperator.free;
  FAnswer.free;
  inherited;
end;

procedure TFhirQuestionnaireItemEnableWhen.Assign(oSource : TFslObject);
begin
  inherited;
  questionElement := TFhirQuestionnaireItemEnableWhen(oSource).questionElement.Clone;
  operatorElement := TFhirQuestionnaireItemEnableWhen(oSource).operatorElement.Clone;
  answer := TFhirQuestionnaireItemEnableWhen(oSource).answer.Clone;
end;

procedure TFhirQuestionnaireItemEnableWhen.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'question') Then
     list.add(self.link, 'question', FQuestion.Link);
  if (child_name = 'operator') Then
     list.add(self.link, 'operator', FOperator.Link);
  if (child_name = 'answer[x]') or (child_name = 'answer') Then
     list.add(self.link, 'answer[x]', FAnswer.Link);
end;

procedure TFhirQuestionnaireItemEnableWhen.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'question', 'string', false, TFhirString, FQuestion.Link));
  oList.add(TFHIRProperty.create(self, 'operator', 'code', false, TFhirEnum, FOperator.Link));
  oList.add(TFHIRProperty.create(self, 'answer[x]', 'boolean|decimal|integer|date|dateTime|time|string|Coding|Quantity|Reference', false, TFhirDataType, FAnswer.Link));
end;

function TFhirQuestionnaireItemEnableWhen.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'question') then
  begin
    QuestionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'operator') then
  begin
    OperatorElement := asEnum(SYSTEMS_TFhirQuestionnaireItemOperatorEnum, CODES_TFhirQuestionnaireItemOperatorEnum, propValue);
    result := propValue;
  end
  else if (isMatchingName(propName, 'answer', ['Boolean', 'Decimal', 'Integer', 'Date', 'DateTime', 'Time', 'String', 'Coding', 'Quantity', 'Reference'])) then
  begin
    Answer := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirQuestionnaireItemEnableWhen.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirQuestionnaireItemEnableWhen.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'question') then result := TFhirString.create()
  else if (propName = 'operator') then result := TFhirEnum.create(SYSTEMS_TFhirQuestionnaireItemOperatorEnum[QuestionnaireItemOperatorNull], CODES_TFhirQuestionnaireItemOperatorEnum[QuestionnaireItemOperatorNull]) 
  else if (isMatchingName(propName, 'answer', ['Boolean', 'Decimal', 'Integer', 'Date', 'DateTime', 'Time', 'String', 'Coding', 'Quantity', 'Reference'])) then raise EFHIRException.create('Cannot make property Answer')
  else result := inherited createPropertyValue(propName);
end;

function TFhirQuestionnaireItemEnableWhen.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'question') then result := 'string'
  else if (propName = 'operator') then result := 'code'
  else if (propName = 'answer[x]') then result := 'boolean|decimal|integer|date|dateTime|time|string|Coding|Quantity|Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirQuestionnaireItemEnableWhen.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'question') then QuestionElement := nil
  else if (propName = 'operator') then OperatorElement := nil
  else if (isMatchingName(propName, 'answer', ['Boolean', 'Decimal', 'Integer', 'Date', 'DateTime', 'Time', 'String', 'Coding', 'Quantity', 'Reference'])) then AnswerElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirQuestionnaireItemEnableWhen.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'question') then QuestionElement := asString(new)
  else if (propName = 'operator') then OperatorElement := asEnum(SYSTEMS_TFhirQuestionnaireItemOperatorEnum, CODES_TFhirQuestionnaireItemOperatorEnum, new)
  else if (isMatchingName(propName, 'answer', ['Boolean', 'Decimal', 'Integer', 'Date', 'DateTime', 'Time', 'String', 'Coding', 'Quantity', 'Reference'])) then AnswerElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirQuestionnaireItemEnableWhen.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirQuestionnaireItemEnableWhen.fhirType : string;
begin
  result := 'Questionnaire.item.enableWhen';
end;

function TFhirQuestionnaireItemEnableWhen.Link : TFhirQuestionnaireItemEnableWhen;
begin
  result := TFhirQuestionnaireItemEnableWhen(inherited Link);
end;

function TFhirQuestionnaireItemEnableWhen.Clone : TFhirQuestionnaireItemEnableWhen;
begin
  result := TFhirQuestionnaireItemEnableWhen(inherited Clone);
end;

function TFhirQuestionnaireItemEnableWhen.equals(other : TObject) : boolean; 
var
  o : TFhirQuestionnaireItemEnableWhen;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirQuestionnaireItemEnableWhen)) then
    result := false
  else
  begin
    o := TFhirQuestionnaireItemEnableWhen(other);
    result := compareDeep(questionElement, o.questionElement, true) and compareDeep(operatorElement, o.operatorElement, true) and 
      compareDeep(answerElement, o.answerElement, true);
  end;
end;

function TFhirQuestionnaireItemEnableWhen.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FQuestion) and isEmptyProp(FOperator) and isEmptyProp(FAnswer);
end;

procedure TFhirQuestionnaireItemEnableWhen.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('question');
  fields.add('operator');
  fields.add('answer[x]');
end;

function TFhirQuestionnaireItemEnableWhen.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirQuestionnaireItemEnableWhen.SetQuestion(value : TFhirString);
begin
  FQuestion.free;
  FQuestion := value;
end;

function TFhirQuestionnaireItemEnableWhen.GetQuestionST : String;
begin
  if FQuestion = nil then
    result := ''
  else
    result := FQuestion.value;
end;

procedure TFhirQuestionnaireItemEnableWhen.SetQuestionST(value : String);
begin
  if value <> '' then
  begin
    if FQuestion = nil then
      FQuestion := TFhirString.create;
    FQuestion.value := value
  end
  else if FQuestion <> nil then
    FQuestion.value := '';
end;

procedure TFhirQuestionnaireItemEnableWhen.SetOperator(value : TFhirEnum);
begin
  FOperator.free;
  FOperator := value;
end;

function TFhirQuestionnaireItemEnableWhen.GetOperatorST : TFhirQuestionnaireItemOperatorEnum;
begin
  if FOperator = nil then
    result := TFhirQuestionnaireItemOperatorEnum(0)
  else
    result := TFhirQuestionnaireItemOperatorEnum(StringArrayIndexOfSensitive(CODES_TFhirQuestionnaireItemOperatorEnum, FOperator.value));
end;

procedure TFhirQuestionnaireItemEnableWhen.SetOperatorST(value : TFhirQuestionnaireItemOperatorEnum);
begin
  if ord(value) = 0 then
    OperatorElement := nil
  else
    OperatorElement := TFhirEnum.create(SYSTEMS_TFhirQuestionnaireItemOperatorEnum[value], CODES_TFhirQuestionnaireItemOperatorEnum[value]);
end;

procedure TFhirQuestionnaireItemEnableWhen.SetAnswer(value : TFhirDataType);
begin
  FAnswer.free;
  FAnswer := value;
end;

{ TFhirQuestionnaireItemEnableWhenListEnumerator }

constructor TFhirQuestionnaireItemEnableWhenListEnumerator.Create(list : TFhirQuestionnaireItemEnableWhenList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirQuestionnaireItemEnableWhenListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirQuestionnaireItemEnableWhenListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirQuestionnaireItemEnableWhenListEnumerator.GetCurrent : TFhirQuestionnaireItemEnableWhen;
begin
  Result := FList[FIndex];
end;

function TFhirQuestionnaireItemEnableWhenListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirQuestionnaireItemEnableWhenList }

function TFhirQuestionnaireItemEnableWhenList.AddItem(value: TFhirQuestionnaireItemEnableWhen): TFhirQuestionnaireItemEnableWhen;
begin
  assert(value.ClassName = 'TFhirQuestionnaireItemEnableWhen', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirQuestionnaireItemEnableWhen');
  add(value);
  result := value;
end;

function TFhirQuestionnaireItemEnableWhenList.Append: TFhirQuestionnaireItemEnableWhen;
begin
  result := TFhirQuestionnaireItemEnableWhen.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirQuestionnaireItemEnableWhenList.ClearItems;
begin
  Clear;
end;

function TFhirQuestionnaireItemEnableWhenList.GetEnumerator : TFhirQuestionnaireItemEnableWhenListEnumerator;
begin
  result := TFhirQuestionnaireItemEnableWhenListEnumerator.Create(self.link);
end;

function TFhirQuestionnaireItemEnableWhenList.Clone: TFhirQuestionnaireItemEnableWhenList;
begin
  result := TFhirQuestionnaireItemEnableWhenList(inherited Clone);
end;

function TFhirQuestionnaireItemEnableWhenList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirQuestionnaireItemEnableWhenList.GetItemN(index: Integer): TFhirQuestionnaireItemEnableWhen;
begin
  result := TFhirQuestionnaireItemEnableWhen(ObjectByIndex[index]);
end;

function TFhirQuestionnaireItemEnableWhenList.ItemClass: TFslObjectClass;
begin
  result := TFhirQuestionnaireItemEnableWhen;
end;
function TFhirQuestionnaireItemEnableWhenList.IndexOf(value: TFhirQuestionnaireItemEnableWhen): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirQuestionnaireItemEnableWhenList.Insert(index: Integer): TFhirQuestionnaireItemEnableWhen;
begin
  result := TFhirQuestionnaireItemEnableWhen.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirQuestionnaireItemEnableWhenList.InsertItem(index: Integer; value: TFhirQuestionnaireItemEnableWhen);
begin
  assert(value is TFhirQuestionnaireItemEnableWhen);
  Inherited Insert(index, value);
end;

function TFhirQuestionnaireItemEnableWhenList.Item(index: Integer): TFhirQuestionnaireItemEnableWhen;
begin
  result := TFhirQuestionnaireItemEnableWhen(ObjectByIndex[index]);
end;

function TFhirQuestionnaireItemEnableWhenList.Link: TFhirQuestionnaireItemEnableWhenList;
begin
  result := TFhirQuestionnaireItemEnableWhenList(inherited Link);
end;

procedure TFhirQuestionnaireItemEnableWhenList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirQuestionnaireItemEnableWhenList.SetItemByIndex(index: Integer; value: TFhirQuestionnaireItemEnableWhen);
begin
  assert(value is TFhirQuestionnaireItemEnableWhen);
  FhirQuestionnaireItemEnableWhens[index] := value;
end;

procedure TFhirQuestionnaireItemEnableWhenList.SetItemN(index: Integer; value: TFhirQuestionnaireItemEnableWhen);
begin
  assert(value is TFhirQuestionnaireItemEnableWhen);
  ObjectByIndex[index] := value;
end;

{ TFhirQuestionnaireItemAnswerOption }

constructor TFhirQuestionnaireItemAnswerOption.Create;
begin
  inherited;
end;

destructor TFhirQuestionnaireItemAnswerOption.Destroy;
begin
  FValue.free;
  FInitialSelected.free;
  inherited;
end;

procedure TFhirQuestionnaireItemAnswerOption.Assign(oSource : TFslObject);
begin
  inherited;
  value := TFhirQuestionnaireItemAnswerOption(oSource).value.Clone;
  initialSelectedElement := TFhirQuestionnaireItemAnswerOption(oSource).initialSelectedElement.Clone;
end;

procedure TFhirQuestionnaireItemAnswerOption.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
  if (child_name = 'initialSelected') Then
     list.add(self.link, 'initialSelected', FInitialSelected.Link);
end;

procedure TFhirQuestionnaireItemAnswerOption.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'value[x]', 'integer|date|time|string|Coding|Reference', false, TFhirDataType, FValue.Link));
  oList.add(TFHIRProperty.create(self, 'initialSelected', 'boolean', false, TFhirBoolean, FInitialSelected.Link));
end;

function TFhirQuestionnaireItemAnswerOption.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'value', ['Integer', 'Date', 'Time', 'String', 'Coding', 'Reference'])) then
  begin
    Value := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'initialSelected') then
  begin
    InitialSelectedElement := asBoolean(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirQuestionnaireItemAnswerOption.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirQuestionnaireItemAnswerOption.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'value', ['Integer', 'Date', 'Time', 'String', 'Coding', 'Reference'])) then raise EFHIRException.create('Cannot make property Value')
  else if (propName = 'initialSelected') then result := TFhirBoolean.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirQuestionnaireItemAnswerOption.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'value[x]') then result := 'integer|date|time|string|Coding|Reference'
  else if (propName = 'initialSelected') then result := 'boolean'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirQuestionnaireItemAnswerOption.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'value', ['Integer', 'Date', 'Time', 'String', 'Coding', 'Reference'])) then ValueElement := nil
  else if (propName = 'initialSelected') then InitialSelectedElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirQuestionnaireItemAnswerOption.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'value', ['Integer', 'Date', 'Time', 'String', 'Coding', 'Reference'])) then ValueElement := new as TFhirDataType
  else if (propName = 'initialSelected') then InitialSelectedElement := asBoolean(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirQuestionnaireItemAnswerOption.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirQuestionnaireItemAnswerOption.fhirType : string;
begin
  result := 'Questionnaire.item.answerOption';
end;

function TFhirQuestionnaireItemAnswerOption.Link : TFhirQuestionnaireItemAnswerOption;
begin
  result := TFhirQuestionnaireItemAnswerOption(inherited Link);
end;

function TFhirQuestionnaireItemAnswerOption.Clone : TFhirQuestionnaireItemAnswerOption;
begin
  result := TFhirQuestionnaireItemAnswerOption(inherited Clone);
end;

function TFhirQuestionnaireItemAnswerOption.equals(other : TObject) : boolean; 
var
  o : TFhirQuestionnaireItemAnswerOption;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirQuestionnaireItemAnswerOption)) then
    result := false
  else
  begin
    o := TFhirQuestionnaireItemAnswerOption(other);
    result := compareDeep(valueElement, o.valueElement, true) and compareDeep(initialSelectedElement, o.initialSelectedElement, true);
  end;
end;

function TFhirQuestionnaireItemAnswerOption.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FValue) and isEmptyProp(FInitialSelected);
end;

procedure TFhirQuestionnaireItemAnswerOption.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('value[x]');
  fields.add('initialSelected');
end;

function TFhirQuestionnaireItemAnswerOption.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirQuestionnaireItemAnswerOption.SetValue(value : TFhirDataType);
begin
  FValue.free;
  FValue := value;
end;

procedure TFhirQuestionnaireItemAnswerOption.SetInitialSelected(value : TFhirBoolean);
begin
  FInitialSelected.free;
  FInitialSelected := value;
end;

function TFhirQuestionnaireItemAnswerOption.GetInitialSelectedST : Boolean;
begin
  if FInitialSelected = nil then
    result := false
  else
    result := FInitialSelected.value;
end;

procedure TFhirQuestionnaireItemAnswerOption.SetInitialSelectedST(value : Boolean);
begin
  if FInitialSelected = nil then
    FInitialSelected := TFhirBoolean.create;
  FInitialSelected.value := value
end;

{ TFhirQuestionnaireItemAnswerOptionListEnumerator }

constructor TFhirQuestionnaireItemAnswerOptionListEnumerator.Create(list : TFhirQuestionnaireItemAnswerOptionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirQuestionnaireItemAnswerOptionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirQuestionnaireItemAnswerOptionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirQuestionnaireItemAnswerOptionListEnumerator.GetCurrent : TFhirQuestionnaireItemAnswerOption;
begin
  Result := FList[FIndex];
end;

function TFhirQuestionnaireItemAnswerOptionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirQuestionnaireItemAnswerOptionList }

function TFhirQuestionnaireItemAnswerOptionList.AddItem(value: TFhirQuestionnaireItemAnswerOption): TFhirQuestionnaireItemAnswerOption;
begin
  assert(value.ClassName = 'TFhirQuestionnaireItemAnswerOption', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirQuestionnaireItemAnswerOption');
  add(value);
  result := value;
end;

function TFhirQuestionnaireItemAnswerOptionList.Append: TFhirQuestionnaireItemAnswerOption;
begin
  result := TFhirQuestionnaireItemAnswerOption.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirQuestionnaireItemAnswerOptionList.ClearItems;
begin
  Clear;
end;

function TFhirQuestionnaireItemAnswerOptionList.GetEnumerator : TFhirQuestionnaireItemAnswerOptionListEnumerator;
begin
  result := TFhirQuestionnaireItemAnswerOptionListEnumerator.Create(self.link);
end;

function TFhirQuestionnaireItemAnswerOptionList.Clone: TFhirQuestionnaireItemAnswerOptionList;
begin
  result := TFhirQuestionnaireItemAnswerOptionList(inherited Clone);
end;

function TFhirQuestionnaireItemAnswerOptionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirQuestionnaireItemAnswerOptionList.GetItemN(index: Integer): TFhirQuestionnaireItemAnswerOption;
begin
  result := TFhirQuestionnaireItemAnswerOption(ObjectByIndex[index]);
end;

function TFhirQuestionnaireItemAnswerOptionList.ItemClass: TFslObjectClass;
begin
  result := TFhirQuestionnaireItemAnswerOption;
end;
function TFhirQuestionnaireItemAnswerOptionList.IndexOf(value: TFhirQuestionnaireItemAnswerOption): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirQuestionnaireItemAnswerOptionList.Insert(index: Integer): TFhirQuestionnaireItemAnswerOption;
begin
  result := TFhirQuestionnaireItemAnswerOption.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirQuestionnaireItemAnswerOptionList.InsertItem(index: Integer; value: TFhirQuestionnaireItemAnswerOption);
begin
  assert(value is TFhirQuestionnaireItemAnswerOption);
  Inherited Insert(index, value);
end;

function TFhirQuestionnaireItemAnswerOptionList.Item(index: Integer): TFhirQuestionnaireItemAnswerOption;
begin
  result := TFhirQuestionnaireItemAnswerOption(ObjectByIndex[index]);
end;

function TFhirQuestionnaireItemAnswerOptionList.Link: TFhirQuestionnaireItemAnswerOptionList;
begin
  result := TFhirQuestionnaireItemAnswerOptionList(inherited Link);
end;

procedure TFhirQuestionnaireItemAnswerOptionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirQuestionnaireItemAnswerOptionList.SetItemByIndex(index: Integer; value: TFhirQuestionnaireItemAnswerOption);
begin
  assert(value is TFhirQuestionnaireItemAnswerOption);
  FhirQuestionnaireItemAnswerOptions[index] := value;
end;

procedure TFhirQuestionnaireItemAnswerOptionList.SetItemN(index: Integer; value: TFhirQuestionnaireItemAnswerOption);
begin
  assert(value is TFhirQuestionnaireItemAnswerOption);
  ObjectByIndex[index] := value;
end;

{ TFhirQuestionnaireItemInitial }

constructor TFhirQuestionnaireItemInitial.Create;
begin
  inherited;
end;

destructor TFhirQuestionnaireItemInitial.Destroy;
begin
  FValue.free;
  inherited;
end;

procedure TFhirQuestionnaireItemInitial.Assign(oSource : TFslObject);
begin
  inherited;
  value := TFhirQuestionnaireItemInitial(oSource).value.Clone;
end;

procedure TFhirQuestionnaireItemInitial.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
end;

procedure TFhirQuestionnaireItemInitial.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'value[x]', 'boolean|decimal|integer|date|dateTime|time|string|uri|Attachment|Coding|Quantity|Reference', false, TFhirDataType, FValue.Link));
end;

function TFhirQuestionnaireItemInitial.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'value', ['Boolean', 'Decimal', 'Integer', 'Date', 'DateTime', 'Time', 'String', 'Uri', 'Attachment', 'Coding', 'Quantity', 'Reference'])) then
  begin
    Value := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirQuestionnaireItemInitial.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirQuestionnaireItemInitial.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'value', ['Boolean', 'Decimal', 'Integer', 'Date', 'DateTime', 'Time', 'String', 'Uri', 'Attachment', 'Coding', 'Quantity', 'Reference'])) then raise EFHIRException.create('Cannot make property Value')
  else result := inherited createPropertyValue(propName);
end;

function TFhirQuestionnaireItemInitial.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'value[x]') then result := 'boolean|decimal|integer|date|dateTime|time|string|uri|Attachment|Coding|Quantity|Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirQuestionnaireItemInitial.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'value', ['Boolean', 'Decimal', 'Integer', 'Date', 'DateTime', 'Time', 'String', 'Uri', 'Attachment', 'Coding', 'Quantity', 'Reference'])) then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirQuestionnaireItemInitial.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'value', ['Boolean', 'Decimal', 'Integer', 'Date', 'DateTime', 'Time', 'String', 'Uri', 'Attachment', 'Coding', 'Quantity', 'Reference'])) then ValueElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirQuestionnaireItemInitial.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirQuestionnaireItemInitial.fhirType : string;
begin
  result := 'Questionnaire.item.initial';
end;

function TFhirQuestionnaireItemInitial.Link : TFhirQuestionnaireItemInitial;
begin
  result := TFhirQuestionnaireItemInitial(inherited Link);
end;

function TFhirQuestionnaireItemInitial.Clone : TFhirQuestionnaireItemInitial;
begin
  result := TFhirQuestionnaireItemInitial(inherited Clone);
end;

function TFhirQuestionnaireItemInitial.equals(other : TObject) : boolean; 
var
  o : TFhirQuestionnaireItemInitial;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirQuestionnaireItemInitial)) then
    result := false
  else
  begin
    o := TFhirQuestionnaireItemInitial(other);
    result := compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirQuestionnaireItemInitial.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FValue);
end;

procedure TFhirQuestionnaireItemInitial.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('value[x]');
end;

function TFhirQuestionnaireItemInitial.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirQuestionnaireItemInitial.SetValue(value : TFhirDataType);
begin
  FValue.free;
  FValue := value;
end;

{ TFhirQuestionnaireItemInitialListEnumerator }

constructor TFhirQuestionnaireItemInitialListEnumerator.Create(list : TFhirQuestionnaireItemInitialList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirQuestionnaireItemInitialListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirQuestionnaireItemInitialListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirQuestionnaireItemInitialListEnumerator.GetCurrent : TFhirQuestionnaireItemInitial;
begin
  Result := FList[FIndex];
end;

function TFhirQuestionnaireItemInitialListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirQuestionnaireItemInitialList }

function TFhirQuestionnaireItemInitialList.AddItem(value: TFhirQuestionnaireItemInitial): TFhirQuestionnaireItemInitial;
begin
  assert(value.ClassName = 'TFhirQuestionnaireItemInitial', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirQuestionnaireItemInitial');
  add(value);
  result := value;
end;

function TFhirQuestionnaireItemInitialList.Append: TFhirQuestionnaireItemInitial;
begin
  result := TFhirQuestionnaireItemInitial.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirQuestionnaireItemInitialList.ClearItems;
begin
  Clear;
end;

function TFhirQuestionnaireItemInitialList.GetEnumerator : TFhirQuestionnaireItemInitialListEnumerator;
begin
  result := TFhirQuestionnaireItemInitialListEnumerator.Create(self.link);
end;

function TFhirQuestionnaireItemInitialList.Clone: TFhirQuestionnaireItemInitialList;
begin
  result := TFhirQuestionnaireItemInitialList(inherited Clone);
end;

function TFhirQuestionnaireItemInitialList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirQuestionnaireItemInitialList.GetItemN(index: Integer): TFhirQuestionnaireItemInitial;
begin
  result := TFhirQuestionnaireItemInitial(ObjectByIndex[index]);
end;

function TFhirQuestionnaireItemInitialList.ItemClass: TFslObjectClass;
begin
  result := TFhirQuestionnaireItemInitial;
end;
function TFhirQuestionnaireItemInitialList.IndexOf(value: TFhirQuestionnaireItemInitial): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirQuestionnaireItemInitialList.Insert(index: Integer): TFhirQuestionnaireItemInitial;
begin
  result := TFhirQuestionnaireItemInitial.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirQuestionnaireItemInitialList.InsertItem(index: Integer; value: TFhirQuestionnaireItemInitial);
begin
  assert(value is TFhirQuestionnaireItemInitial);
  Inherited Insert(index, value);
end;

function TFhirQuestionnaireItemInitialList.Item(index: Integer): TFhirQuestionnaireItemInitial;
begin
  result := TFhirQuestionnaireItemInitial(ObjectByIndex[index]);
end;

function TFhirQuestionnaireItemInitialList.Link: TFhirQuestionnaireItemInitialList;
begin
  result := TFhirQuestionnaireItemInitialList(inherited Link);
end;

procedure TFhirQuestionnaireItemInitialList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirQuestionnaireItemInitialList.SetItemByIndex(index: Integer; value: TFhirQuestionnaireItemInitial);
begin
  assert(value is TFhirQuestionnaireItemInitial);
  FhirQuestionnaireItemInitials[index] := value;
end;

procedure TFhirQuestionnaireItemInitialList.SetItemN(index: Integer; value: TFhirQuestionnaireItemInitial);
begin
  assert(value is TFhirQuestionnaireItemInitial);
  ObjectByIndex[index] := value;
end;

{ TFhirQuestionnaire }

constructor TFhirQuestionnaire.Create;
begin
  inherited;
end;

destructor TFhirQuestionnaire.Destroy;
begin
  FUrl.free;
  FIdentifierList.Free;
  FVersion.free;
  FName.free;
  FTitle.free;
  FDerivedFromList.Free;
  FStatus.free;
  FExperimental.free;
  FSubjectType.Free;
  FDate.free;
  FPublisher.free;
  FContactList.Free;
  FDescription.free;
  FUseContextList.Free;
  FJurisdictionList.Free;
  FPurpose.free;
  FCopyright.free;
  FApprovalDate.free;
  FLastReviewDate.free;
  FEffectivePeriod.free;
  FCodeList.Free;
  FItemList.Free;
  inherited;
end;

procedure TFhirQuestionnaire.Assign(oSource : TFslObject);
begin
  inherited;
  urlElement := TFhirQuestionnaire(oSource).urlElement.Clone;
  if (TFhirQuestionnaire(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirQuestionnaire(oSource).FIdentifierList);
  end;
  versionElement := TFhirQuestionnaire(oSource).versionElement.Clone;
  nameElement := TFhirQuestionnaire(oSource).nameElement.Clone;
  titleElement := TFhirQuestionnaire(oSource).titleElement.Clone;
  if (TFhirQuestionnaire(oSource).FDerivedFromList = nil) then
  begin
    FDerivedFromList.free;
    FDerivedFromList := nil;
  end
  else
  begin
    if FDerivedFromList = nil then
      FDerivedFromList := TFhirCanonicalList.Create;
    FDerivedFromList.Assign(TFhirQuestionnaire(oSource).FDerivedFromList);
  end;
  statusElement := TFhirQuestionnaire(oSource).statusElement.Clone;
  experimentalElement := TFhirQuestionnaire(oSource).experimentalElement.Clone;
  if (TFhirQuestionnaire(oSource).FSubjectType = nil) then
  begin
    FSubjectType.free;
    FSubjectType := nil;
  end
  else
  begin
    FSubjectType := TFhirEnumList.Create(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum);
    FSubjectType.Assign(TFhirQuestionnaire(oSource).FSubjectType);
  end;
  dateElement := TFhirQuestionnaire(oSource).dateElement.Clone;
  publisherElement := TFhirQuestionnaire(oSource).publisherElement.Clone;
  if (TFhirQuestionnaire(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirContactDetailList.Create;
    FContactList.Assign(TFhirQuestionnaire(oSource).FContactList);
  end;
  descriptionElement := TFhirQuestionnaire(oSource).descriptionElement.Clone;
  if (TFhirQuestionnaire(oSource).FUseContextList = nil) then
  begin
    FUseContextList.free;
    FUseContextList := nil;
  end
  else
  begin
    if FUseContextList = nil then
      FUseContextList := TFhirUsageContextList.Create;
    FUseContextList.Assign(TFhirQuestionnaire(oSource).FUseContextList);
  end;
  if (TFhirQuestionnaire(oSource).FJurisdictionList = nil) then
  begin
    FJurisdictionList.free;
    FJurisdictionList := nil;
  end
  else
  begin
    if FJurisdictionList = nil then
      FJurisdictionList := TFhirCodeableConceptList.Create;
    FJurisdictionList.Assign(TFhirQuestionnaire(oSource).FJurisdictionList);
  end;
  purposeElement := TFhirQuestionnaire(oSource).purposeElement.Clone;
  copyrightElement := TFhirQuestionnaire(oSource).copyrightElement.Clone;
  approvalDateElement := TFhirQuestionnaire(oSource).approvalDateElement.Clone;
  lastReviewDateElement := TFhirQuestionnaire(oSource).lastReviewDateElement.Clone;
  effectivePeriod := TFhirQuestionnaire(oSource).effectivePeriod.Clone;
  if (TFhirQuestionnaire(oSource).FCodeList = nil) then
  begin
    FCodeList.free;
    FCodeList := nil;
  end
  else
  begin
    if FCodeList = nil then
      FCodeList := TFhirCodingList.Create;
    FCodeList.Assign(TFhirQuestionnaire(oSource).FCodeList);
  end;
  if (TFhirQuestionnaire(oSource).FItemList = nil) then
  begin
    FItemList.free;
    FItemList := nil;
  end
  else
  begin
    if FItemList = nil then
      FItemList := TFhirQuestionnaireItemList.Create;
    FItemList.Assign(TFhirQuestionnaire(oSource).FItemList);
  end;
end;

function TFhirQuestionnaire.GetResourceType : TFhirResourceType;
begin
  result := frtQuestionnaire;
end;

procedure TFhirQuestionnaire.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'version') Then
     list.add(self.link, 'version', FVersion.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
  if (child_name = 'derivedFrom') Then
    list.addAll(self, 'derivedFrom', FDerivedFromList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'experimental') Then
     list.add(self.link, 'experimental', FExperimental.Link);
  if (child_name = 'subjectType') Then
     list.addAll(self, 'subjectType', FSubjectType);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'publisher') Then
     list.add(self.link, 'publisher', FPublisher.Link);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'useContext') Then
    list.addAll(self, 'useContext', FUseContextList);
  if (child_name = 'jurisdiction') Then
    list.addAll(self, 'jurisdiction', FJurisdictionList);
  if (child_name = 'purpose') Then
     list.add(self.link, 'purpose', FPurpose.Link);
  if (child_name = 'copyright') Then
     list.add(self.link, 'copyright', FCopyright.Link);
  if (child_name = 'approvalDate') Then
     list.add(self.link, 'approvalDate', FApprovalDate.Link);
  if (child_name = 'lastReviewDate') Then
     list.add(self.link, 'lastReviewDate', FLastReviewDate.Link);
  if (child_name = 'effectivePeriod') Then
     list.add(self.link, 'effectivePeriod', FEffectivePeriod.Link);
  if (child_name = 'code') Then
    list.addAll(self, 'code', FCodeList);
  if (child_name = 'item') Then
    list.addAll(self, 'item', FItemList);
end;

procedure TFhirQuestionnaire.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'url', 'uri', false, TFhirUri, FUrl.Link));
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'version', 'string', false, TFhirString, FVersion.Link));
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link));
  oList.add(TFHIRProperty.create(self, 'derivedFrom', 'canonical', true, TFhirCanonical, FDerivedFromList.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'experimental', 'boolean', false, TFhirBoolean, FExperimental.Link));
  oList.add(TFHIRProperty.create(self, 'subjectType', 'code', true, TFhirEnum, FSubjectType.Link));
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));
  oList.add(TFHIRProperty.create(self, 'publisher', 'string', false, TFhirString, FPublisher.Link));
  oList.add(TFHIRProperty.create(self, 'contact', 'ContactDetail', true, TFhirContactDetail, FContactList.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'markdown', false, TFhirMarkdown, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'useContext', 'UsageContext', true, TFhirUsageContext, FUseContextList.Link));
  oList.add(TFHIRProperty.create(self, 'jurisdiction', 'CodeableConcept', true, TFhirCodeableConcept, FJurisdictionList.Link));
  oList.add(TFHIRProperty.create(self, 'purpose', 'markdown', false, TFhirMarkdown, FPurpose.Link));
  oList.add(TFHIRProperty.create(self, 'copyright', 'markdown', false, TFhirMarkdown, FCopyright.Link));
  oList.add(TFHIRProperty.create(self, 'approvalDate', 'date', false, TFhirDate, FApprovalDate.Link));
  oList.add(TFHIRProperty.create(self, 'lastReviewDate', 'date', false, TFhirDate, FLastReviewDate.Link));
  oList.add(TFHIRProperty.create(self, 'effectivePeriod', 'Period', false, TFhirPeriod, FEffectivePeriod.Link));
  oList.add(TFHIRProperty.create(self, 'code', 'Coding', true, TFhirCoding, FCodeList.Link));
  oList.add(TFHIRProperty.create(self, 'item', 'BackboneElement', true, TFhirQuestionnaireItem, FItemList.Link));
end;

function TFhirQuestionnaire.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'url') then
  begin
    UrlElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'title') then
  begin
    TitleElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'derivedFrom') then
  begin
    DerivedFromList.add(asCanonical(propValue)){2};     result := propValue;

  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'experimental') then
  begin
    ExperimentalElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'subjectType') then
  begin
    SubjectTypeList.add(asEnum(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum, propValue));
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'publisher') then
  begin
    PublisherElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirContactDetail);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'useContext') then
  begin
    UseContextList.add(propValue as TFhirUsageContext);
    result := propValue;
  end
  else if (propName = 'jurisdiction') then
  begin
    JurisdictionList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'purpose') then
  begin
    PurposeElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'copyright') then
  begin
    CopyrightElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'approvalDate') then
  begin
    ApprovalDateElement := asDate(propValue);
    result := propValue;
  end
  else if (propName = 'lastReviewDate') then
  begin
    LastReviewDateElement := asDate(propValue);
    result := propValue;
  end
  else if (propName = 'effectivePeriod') then
  begin
    EffectivePeriod := propValue as TFhirPeriod;
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    CodeList.add(propValue as TFhirCoding);
    result := propValue;
  end
  else if (propName = 'item') then
  begin
    ItemList.add(propValue as TFhirQuestionnaireItem);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirQuestionnaire.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'derivedFrom') then DerivedFromList.insertItem(index, asCanonical(propValue))
  else if (propName = 'subjectType') then FSubjectType.insertItem(index, asEnum(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum, propValue))
  else if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirContactDetail)
  else if (propName = 'useContext') then UseContextList.insertItem(index, propValue as TFhirUsageContext)
  else if (propName = 'jurisdiction') then JurisdictionList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'code') then CodeList.insertItem(index, propValue as TFhirCoding)
  else if (propName = 'item') then ItemList.insertItem(index, propValue as TFhirQuestionnaireItem)
  else inherited;
end;

function TFhirQuestionnaire.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'url') then result := TFhirUri.create()
  else if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'version') then result := TFhirString.create()
  else if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'title') then result := TFhirString.create()
  else if (propName = 'derivedFrom') then result := DerivedFromList.new()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[PublicationStatusNull], CODES_TFhirPublicationStatusEnum[PublicationStatusNull]) 
  else if (propName = 'experimental') then result := TFhirBoolean.create()
  else if (propName = 'date') then result := TFhirDateTime.create()
  else if (propName = 'publisher') then result := TFhirString.create()
  else if (propName = 'contact') then result := ContactList.new()
  else if (propName = 'description') then result := TFhirMarkdown.create()
  else if (propName = 'useContext') then result := UseContextList.new()
  else if (propName = 'jurisdiction') then result := JurisdictionList.new()
  else if (propName = 'purpose') then result := TFhirMarkdown.create()
  else if (propName = 'copyright') then result := TFhirMarkdown.create()
  else if (propName = 'approvalDate') then result := TFhirDate.create()
  else if (propName = 'lastReviewDate') then result := TFhirDate.create()
  else if (propName = 'effectivePeriod') then result := TFhirPeriod.create()
  else if (propName = 'code') then result := CodeList.new()
  else if (propName = 'item') then result := ItemList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirQuestionnaire.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'url') then result := 'uri'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'version') then result := 'string'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'title') then result := 'string'
  else if (propName = 'derivedFrom') then result := 'canonical'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'experimental') then result := 'boolean'
  else if (propName = 'subjectType') then result := 'code'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'publisher') then result := 'string'
  else if (propName = 'contact') then result := 'ContactDetail'
  else if (propName = 'description') then result := 'markdown'
  else if (propName = 'useContext') then result := 'UsageContext'
  else if (propName = 'jurisdiction') then result := 'CodeableConcept'
  else if (propName = 'purpose') then result := 'markdown'
  else if (propName = 'copyright') then result := 'markdown'
  else if (propName = 'approvalDate') then result := 'date'
  else if (propName = 'lastReviewDate') then result := 'date'
  else if (propName = 'effectivePeriod') then result := 'Period'
  else if (propName = 'code') then result := 'Coding'
  else if (propName = 'item') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirQuestionnaire.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := nil
  else if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'version') then VersionElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'title') then TitleElement := nil
  else if (propName = 'derivedFrom') then deletePropertyValue('derivedFrom', DerivedFromList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'experimental') then ExperimentalElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'publisher') then PublisherElement := nil
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value)
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'useContext') then deletePropertyValue('useContext', UseContextList, value)
  else if (propName = 'jurisdiction') then deletePropertyValue('jurisdiction', JurisdictionList, value)
  else if (propName = 'purpose') then PurposeElement := nil
  else if (propName = 'copyright') then CopyrightElement := nil
  else if (propName = 'approvalDate') then ApprovalDateElement := nil
  else if (propName = 'lastReviewDate') then LastReviewDateElement := nil
  else if (propName = 'effectivePeriod') then EffectivePeriodElement := nil
  else if (propName = 'code') then deletePropertyValue('code', CodeList, value)
  else if (propName = 'item') then deletePropertyValue('item', ItemList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirQuestionnaire.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := asUri(new)
  else if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'version') then VersionElement := asString(new)
  else if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'title') then TitleElement := asString(new)
  else if (propName = 'derivedFrom') then replacePropertyValue('derivedFrom', DerivedFromList, existing, new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, new)
  else if (propName = 'experimental') then ExperimentalElement := asBoolean(new)
  else if (propName = 'date') then DateElement := asDateTime(new)
  else if (propName = 'publisher') then PublisherElement := asString(new)
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new)
  else if (propName = 'description') then DescriptionElement := asMarkdown(new)
  else if (propName = 'useContext') then replacePropertyValue('useContext', UseContextList, existing, new)
  else if (propName = 'jurisdiction') then replacePropertyValue('jurisdiction', JurisdictionList, existing, new)
  else if (propName = 'purpose') then PurposeElement := asMarkdown(new)
  else if (propName = 'copyright') then CopyrightElement := asMarkdown(new)
  else if (propName = 'approvalDate') then ApprovalDateElement := asDate(new)
  else if (propName = 'lastReviewDate') then LastReviewDateElement := asDate(new)
  else if (propName = 'effectivePeriod') then EffectivePeriodElement := new as TFhirPeriod
  else if (propName = 'code') then replacePropertyValue('code', CodeList, existing, new)
  else if (propName = 'item') then replacePropertyValue('item', ItemList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirQuestionnaire.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'derivedFrom') then DerivedFromList.move(source, destination)
  else if (propName = 'subjectType') then FSubjectType.move(source, destination)
  else if (propName = 'contact') then ContactList.move(source, destination)
  else if (propName = 'useContext') then UseContextList.move(source, destination)
  else if (propName = 'jurisdiction') then JurisdictionList.move(source, destination)
  else if (propName = 'code') then CodeList.move(source, destination)
  else if (propName = 'item') then ItemList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirQuestionnaire.fhirType : string;
begin
  result := 'Questionnaire';
end;

function TFhirQuestionnaire.Link : TFhirQuestionnaire;
begin
  result := TFhirQuestionnaire(inherited Link);
end;

function TFhirQuestionnaire.Clone : TFhirQuestionnaire;
begin
  result := TFhirQuestionnaire(inherited Clone);
end;

function TFhirQuestionnaire.equals(other : TObject) : boolean; 
var
  o : TFhirQuestionnaire;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirQuestionnaire)) then
    result := false
  else
  begin
    o := TFhirQuestionnaire(other);
    result := compareDeep(urlElement, o.urlElement, true) and compareDeep(identifierList, o.identifierList, true) and 
      compareDeep(versionElement, o.versionElement, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(titleElement, o.titleElement, true) and compareDeep(derivedFromList, o.derivedFromList, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(experimentalElement, o.experimentalElement, true) and 
      compareDeep(subjectTypeList, o.subjectTypeList, true) and compareDeep(dateElement, o.dateElement, true) and 
      compareDeep(publisherElement, o.publisherElement, true) and compareDeep(contactList, o.contactList, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(useContextList, o.useContextList, true) and 
      compareDeep(jurisdictionList, o.jurisdictionList, true) and compareDeep(purposeElement, o.purposeElement, true) and 
      compareDeep(copyrightElement, o.copyrightElement, true) and compareDeep(approvalDateElement, o.approvalDateElement, true) and 
      compareDeep(lastReviewDateElement, o.lastReviewDateElement, true) and compareDeep(effectivePeriodElement, o.effectivePeriodElement, true) and 
      compareDeep(codeList, o.codeList, true) and compareDeep(itemList, o.itemList, true);
  end;
end;

function TFhirQuestionnaire.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FUrl) and isEmptyProp(FidentifierList) and isEmptyProp(FVersion) and isEmptyProp(FName) and isEmptyProp(FTitle) and isEmptyProp(FderivedFromList) and isEmptyProp(FStatus) and isEmptyProp(FExperimental) and isEmptyProp(FSubjectType) and isEmptyProp(FDate) and isEmptyProp(FPublisher) and isEmptyProp(FcontactList) and isEmptyProp(FDescription) and isEmptyProp(FuseContextList) and isEmptyProp(FjurisdictionList) and isEmptyProp(FPurpose) and isEmptyProp(FCopyright) and isEmptyProp(FApprovalDate) and isEmptyProp(FLastReviewDate) and isEmptyProp(FEffectivePeriod) and isEmptyProp(FcodeList) and isEmptyProp(FitemList);
end;

procedure TFhirQuestionnaire.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('url');
  fields.add('identifier');
  fields.add('version');
  fields.add('name');
  fields.add('title');
  fields.add('derivedFrom');
  fields.add('status');
  fields.add('experimental');
  fields.add('subjectType');
  fields.add('date');
  fields.add('publisher');
  fields.add('contact');
  fields.add('description');
  fields.add('useContext');
  fields.add('jurisdiction');
  fields.add('purpose');
  fields.add('copyright');
  fields.add('approvalDate');
  fields.add('lastReviewDate');
  fields.add('effectivePeriod');
  fields.add('code');
  fields.add('item');
end;

function TFhirQuestionnaire.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FDerivedFromList.sizeInBytes(magic));
  inc(result, FSubjectType.sizeInBytes(magic));
  inc(result, FContactList.sizeInBytes(magic));
  inc(result, FUseContextList.sizeInBytes(magic));
  inc(result, FJurisdictionList.sizeInBytes(magic));
  inc(result, FCodeList.sizeInBytes(magic));
  inc(result, FItemList.sizeInBytes(magic));
end;

procedure TFhirQuestionnaire.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

function TFhirQuestionnaire.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

procedure TFhirQuestionnaire.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

function TFhirQuestionnaire.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirQuestionnaire.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirQuestionnaire.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

function TFhirQuestionnaire.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

procedure TFhirQuestionnaire.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

procedure TFhirQuestionnaire.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirQuestionnaire.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirQuestionnaire.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirQuestionnaire.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

function TFhirQuestionnaire.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

procedure TFhirQuestionnaire.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

function TFhirQuestionnaire.GetDerivedFromList : TFhirCanonicalList;
begin
  if FDerivedFromList = nil then
    FDerivedFromList := TFhirCanonicalList.Create;
  result := FDerivedFromList;
end;

function TFhirQuestionnaire.GetHasDerivedFromList : boolean;
begin
  result := (FDerivedFromList <> nil) and (FDerivedFromList.count > 0);
end;

procedure TFhirQuestionnaire.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirQuestionnaire.GetStatusST : TFhirPublicationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirPublicationStatusEnum(0)
  else
    result := TFhirPublicationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirPublicationStatusEnum, FStatus.value));
end;

procedure TFhirQuestionnaire.SetStatusST(value : TFhirPublicationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[value], CODES_TFhirPublicationStatusEnum[value]);
end;

procedure TFhirQuestionnaire.SetExperimental(value : TFhirBoolean);
begin
  FExperimental.free;
  FExperimental := value;
end;

function TFhirQuestionnaire.GetExperimentalST : Boolean;
begin
  if FExperimental = nil then
    result := false
  else
    result := FExperimental.value;
end;

procedure TFhirQuestionnaire.SetExperimentalST(value : Boolean);
begin
  if FExperimental = nil then
    FExperimental := TFhirBoolean.create;
  FExperimental.value := value
end;

function TFhirQuestionnaire.GetSubjectType : TFhirEnumList;
begin
  if FSubjectType = nil then
    FSubjectType := TFhirEnumList.Create(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum);
  result := FSubjectType;
end;

function TFhirQuestionnaire.GetHasSubjectType : boolean;
begin
  result := (FSubjectType <> nil) and (FSubjectType.count > 0);
end;

procedure TFhirQuestionnaire.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

function TFhirQuestionnaire.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirQuestionnaire.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

procedure TFhirQuestionnaire.SetPublisher(value : TFhirString);
begin
  FPublisher.free;
  FPublisher := value;
end;

function TFhirQuestionnaire.GetPublisherST : String;
begin
  if FPublisher = nil then
    result := ''
  else
    result := FPublisher.value;
end;

procedure TFhirQuestionnaire.SetPublisherST(value : String);
begin
  if value <> '' then
  begin
    if FPublisher = nil then
      FPublisher := TFhirString.create;
    FPublisher.value := value
  end
  else if FPublisher <> nil then
    FPublisher.value := '';
end;

function TFhirQuestionnaire.GetContactList : TFhirContactDetailList;
begin
  if FContactList = nil then
    FContactList := TFhirContactDetailList.Create;
  result := FContactList;
end;

function TFhirQuestionnaire.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

procedure TFhirQuestionnaire.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirQuestionnaire.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirQuestionnaire.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirQuestionnaire.GetUseContextList : TFhirUsageContextList;
begin
  if FUseContextList = nil then
    FUseContextList := TFhirUsageContextList.Create;
  result := FUseContextList;
end;

function TFhirQuestionnaire.GetHasUseContextList : boolean;
begin
  result := (FUseContextList <> nil) and (FUseContextList.count > 0);
end;

function TFhirQuestionnaire.GetJurisdictionList : TFhirCodeableConceptList;
begin
  if FJurisdictionList = nil then
    FJurisdictionList := TFhirCodeableConceptList.Create;
  result := FJurisdictionList;
end;

function TFhirQuestionnaire.GetHasJurisdictionList : boolean;
begin
  result := (FJurisdictionList <> nil) and (FJurisdictionList.count > 0);
end;

procedure TFhirQuestionnaire.SetPurpose(value : TFhirMarkdown);
begin
  FPurpose.free;
  FPurpose := value;
end;

function TFhirQuestionnaire.GetPurposeST : String;
begin
  if FPurpose = nil then
    result := ''
  else
    result := FPurpose.value;
end;

procedure TFhirQuestionnaire.SetPurposeST(value : String);
begin
  if value <> '' then
  begin
    if FPurpose = nil then
      FPurpose := TFhirMarkdown.create;
    FPurpose.value := value
  end
  else if FPurpose <> nil then
    FPurpose.value := '';
end;

procedure TFhirQuestionnaire.SetCopyright(value : TFhirMarkdown);
begin
  FCopyright.free;
  FCopyright := value;
end;

function TFhirQuestionnaire.GetCopyrightST : String;
begin
  if FCopyright = nil then
    result := ''
  else
    result := FCopyright.value;
end;

procedure TFhirQuestionnaire.SetCopyrightST(value : String);
begin
  if value <> '' then
  begin
    if FCopyright = nil then
      FCopyright := TFhirMarkdown.create;
    FCopyright.value := value
  end
  else if FCopyright <> nil then
    FCopyright.value := '';
end;

procedure TFhirQuestionnaire.SetApprovalDate(value : TFhirDate);
begin
  FApprovalDate.free;
  FApprovalDate := value;
end;

function TFhirQuestionnaire.GetApprovalDateST : TFslDateTime;
begin
  if FApprovalDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FApprovalDate.value;
end;

procedure TFhirQuestionnaire.SetApprovalDateST(value : TFslDateTime);
begin
  if FApprovalDate = nil then
    FApprovalDate := TFhirDate.create;
  FApprovalDate.value := value
end;

procedure TFhirQuestionnaire.SetLastReviewDate(value : TFhirDate);
begin
  FLastReviewDate.free;
  FLastReviewDate := value;
end;

function TFhirQuestionnaire.GetLastReviewDateST : TFslDateTime;
begin
  if FLastReviewDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FLastReviewDate.value;
end;

procedure TFhirQuestionnaire.SetLastReviewDateST(value : TFslDateTime);
begin
  if FLastReviewDate = nil then
    FLastReviewDate := TFhirDate.create;
  FLastReviewDate.value := value
end;

procedure TFhirQuestionnaire.SetEffectivePeriod(value : TFhirPeriod);
begin
  FEffectivePeriod.free;
  FEffectivePeriod := value;
end;

function TFhirQuestionnaire.GetCodeList : TFhirCodingList;
begin
  if FCodeList = nil then
    FCodeList := TFhirCodingList.Create;
  result := FCodeList;
end;

function TFhirQuestionnaire.GetHasCodeList : boolean;
begin
  result := (FCodeList <> nil) and (FCodeList.count > 0);
end;

function TFhirQuestionnaire.GetItemList : TFhirQuestionnaireItemList;
begin
  if FItemList = nil then
    FItemList := TFhirQuestionnaireItemList.Create;
  result := FItemList;
end;

function TFhirQuestionnaire.GetHasItemList : boolean;
begin
  result := (FItemList <> nil) and (FItemList.count > 0);
end;

{ TFhirQuestionnaireListEnumerator }

constructor TFhirQuestionnaireListEnumerator.Create(list : TFhirQuestionnaireList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirQuestionnaireListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirQuestionnaireListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirQuestionnaireListEnumerator.GetCurrent : TFhirQuestionnaire;
begin
  Result := FList[FIndex];
end;

function TFhirQuestionnaireListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirQuestionnaireList }

function TFhirQuestionnaireList.AddItem(value: TFhirQuestionnaire): TFhirQuestionnaire;
begin
  assert(value.ClassName = 'TFhirQuestionnaire', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirQuestionnaire');
  add(value);
  result := value;
end;

function TFhirQuestionnaireList.Append: TFhirQuestionnaire;
begin
  result := TFhirQuestionnaire.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirQuestionnaireList.ClearItems;
begin
  Clear;
end;

function TFhirQuestionnaireList.GetEnumerator : TFhirQuestionnaireListEnumerator;
begin
  result := TFhirQuestionnaireListEnumerator.Create(self.link);
end;

function TFhirQuestionnaireList.Clone: TFhirQuestionnaireList;
begin
  result := TFhirQuestionnaireList(inherited Clone);
end;

function TFhirQuestionnaireList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirQuestionnaireList.GetItemN(index: Integer): TFhirQuestionnaire;
begin
  result := TFhirQuestionnaire(ObjectByIndex[index]);
end;

function TFhirQuestionnaireList.ItemClass: TFslObjectClass;
begin
  result := TFhirQuestionnaire;
end;
function TFhirQuestionnaireList.IndexOf(value: TFhirQuestionnaire): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirQuestionnaireList.Insert(index: Integer): TFhirQuestionnaire;
begin
  result := TFhirQuestionnaire.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirQuestionnaireList.InsertItem(index: Integer; value: TFhirQuestionnaire);
begin
  assert(value is TFhirQuestionnaire);
  Inherited Insert(index, value);
end;

function TFhirQuestionnaireList.Item(index: Integer): TFhirQuestionnaire;
begin
  result := TFhirQuestionnaire(ObjectByIndex[index]);
end;

function TFhirQuestionnaireList.Link: TFhirQuestionnaireList;
begin
  result := TFhirQuestionnaireList(inherited Link);
end;

procedure TFhirQuestionnaireList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirQuestionnaireList.SetItemByIndex(index: Integer; value: TFhirQuestionnaire);
begin
  assert(value is TFhirQuestionnaire);
  FhirQuestionnaires[index] := value;
end;

procedure TFhirQuestionnaireList.SetItemN(index: Integer; value: TFhirQuestionnaire);
begin
  assert(value is TFhirQuestionnaire);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_QUESTIONNAIRE}
{$IFDEF FHIR_SEARCHPARAMETER}
{ TFhirSearchParameterComponent }

constructor TFhirSearchParameterComponent.Create;
begin
  inherited;
end;

destructor TFhirSearchParameterComponent.Destroy;
begin
  FDefinition.free;
  FExpression.free;
  inherited;
end;

procedure TFhirSearchParameterComponent.Assign(oSource : TFslObject);
begin
  inherited;
  definitionElement := TFhirSearchParameterComponent(oSource).definitionElement.Clone;
  expressionElement := TFhirSearchParameterComponent(oSource).expressionElement.Clone;
end;

procedure TFhirSearchParameterComponent.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'definition') Then
     list.add(self.link, 'definition', FDefinition.Link);
  if (child_name = 'expression') Then
     list.add(self.link, 'expression', FExpression.Link);
end;

procedure TFhirSearchParameterComponent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'definition', 'canonical', false, TFhirCanonical, FDefinition.Link));
  oList.add(TFHIRProperty.create(self, 'expression', 'string', false, TFhirString, FExpression.Link));
end;

function TFhirSearchParameterComponent.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'definition') then
  begin
    DefinitionElement := asCanonical(propValue);
    result := propValue;
  end
  else if (propName = 'expression') then
  begin
    ExpressionElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSearchParameterComponent.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSearchParameterComponent.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'definition') then result := TFhirCanonical.create()
  else if (propName = 'expression') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSearchParameterComponent.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'definition') then result := 'canonical'
  else if (propName = 'expression') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSearchParameterComponent.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'definition') then DefinitionElement := nil
  else if (propName = 'expression') then ExpressionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSearchParameterComponent.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'definition') then DefinitionElement := asCanonical(new)
  else if (propName = 'expression') then ExpressionElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSearchParameterComponent.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSearchParameterComponent.fhirType : string;
begin
  result := 'SearchParameter.component';
end;

function TFhirSearchParameterComponent.Link : TFhirSearchParameterComponent;
begin
  result := TFhirSearchParameterComponent(inherited Link);
end;

function TFhirSearchParameterComponent.Clone : TFhirSearchParameterComponent;
begin
  result := TFhirSearchParameterComponent(inherited Clone);
end;

function TFhirSearchParameterComponent.equals(other : TObject) : boolean; 
var
  o : TFhirSearchParameterComponent;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSearchParameterComponent)) then
    result := false
  else
  begin
    o := TFhirSearchParameterComponent(other);
    result := compareDeep(definitionElement, o.definitionElement, true) and compareDeep(expressionElement, o.expressionElement, true);
  end;
end;

function TFhirSearchParameterComponent.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDefinition) and isEmptyProp(FExpression);
end;

procedure TFhirSearchParameterComponent.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('definition');
  fields.add('expression');
end;

function TFhirSearchParameterComponent.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirSearchParameterComponent.SetDefinition(value : TFhirCanonical);
begin
  FDefinition.free;
  FDefinition := value;
end;

function TFhirSearchParameterComponent.GetDefinitionST : String;
begin
  if FDefinition = nil then
    result := ''
  else
    result := FDefinition.value;
end;

procedure TFhirSearchParameterComponent.SetDefinitionST(value : String);
begin
  if value <> '' then
  begin
    if FDefinition = nil then
      FDefinition := TFhirCanonical.create;
    FDefinition.value := value
  end
  else if FDefinition <> nil then
    FDefinition.value := '';
end;

procedure TFhirSearchParameterComponent.SetExpression(value : TFhirString);
begin
  FExpression.free;
  FExpression := value;
end;

function TFhirSearchParameterComponent.GetExpressionST : String;
begin
  if FExpression = nil then
    result := ''
  else
    result := FExpression.value;
end;

procedure TFhirSearchParameterComponent.SetExpressionST(value : String);
begin
  if value <> '' then
  begin
    if FExpression = nil then
      FExpression := TFhirString.create;
    FExpression.value := value
  end
  else if FExpression <> nil then
    FExpression.value := '';
end;

{ TFhirSearchParameterComponentListEnumerator }

constructor TFhirSearchParameterComponentListEnumerator.Create(list : TFhirSearchParameterComponentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSearchParameterComponentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSearchParameterComponentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSearchParameterComponentListEnumerator.GetCurrent : TFhirSearchParameterComponent;
begin
  Result := FList[FIndex];
end;

function TFhirSearchParameterComponentListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSearchParameterComponentList }

function TFhirSearchParameterComponentList.AddItem(value: TFhirSearchParameterComponent): TFhirSearchParameterComponent;
begin
  assert(value.ClassName = 'TFhirSearchParameterComponent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSearchParameterComponent');
  add(value);
  result := value;
end;

function TFhirSearchParameterComponentList.Append: TFhirSearchParameterComponent;
begin
  result := TFhirSearchParameterComponent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSearchParameterComponentList.ClearItems;
begin
  Clear;
end;

function TFhirSearchParameterComponentList.GetEnumerator : TFhirSearchParameterComponentListEnumerator;
begin
  result := TFhirSearchParameterComponentListEnumerator.Create(self.link);
end;

function TFhirSearchParameterComponentList.Clone: TFhirSearchParameterComponentList;
begin
  result := TFhirSearchParameterComponentList(inherited Clone);
end;

function TFhirSearchParameterComponentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSearchParameterComponentList.GetItemN(index: Integer): TFhirSearchParameterComponent;
begin
  result := TFhirSearchParameterComponent(ObjectByIndex[index]);
end;

function TFhirSearchParameterComponentList.ItemClass: TFslObjectClass;
begin
  result := TFhirSearchParameterComponent;
end;
function TFhirSearchParameterComponentList.IndexOf(value: TFhirSearchParameterComponent): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSearchParameterComponentList.Insert(index: Integer): TFhirSearchParameterComponent;
begin
  result := TFhirSearchParameterComponent.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSearchParameterComponentList.InsertItem(index: Integer; value: TFhirSearchParameterComponent);
begin
  assert(value is TFhirSearchParameterComponent);
  Inherited Insert(index, value);
end;

function TFhirSearchParameterComponentList.Item(index: Integer): TFhirSearchParameterComponent;
begin
  result := TFhirSearchParameterComponent(ObjectByIndex[index]);
end;

function TFhirSearchParameterComponentList.Link: TFhirSearchParameterComponentList;
begin
  result := TFhirSearchParameterComponentList(inherited Link);
end;

procedure TFhirSearchParameterComponentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSearchParameterComponentList.SetItemByIndex(index: Integer; value: TFhirSearchParameterComponent);
begin
  assert(value is TFhirSearchParameterComponent);
  FhirSearchParameterComponents[index] := value;
end;

procedure TFhirSearchParameterComponentList.SetItemN(index: Integer; value: TFhirSearchParameterComponent);
begin
  assert(value is TFhirSearchParameterComponent);
  ObjectByIndex[index] := value;
end;

{ TFhirSearchParameter }

constructor TFhirSearchParameter.Create;
begin
  inherited;
end;

destructor TFhirSearchParameter.Destroy;
begin
  FUrl.free;
  FVersion.free;
  FName.free;
  FDerivedFrom.free;
  FStatus.free;
  FExperimental.free;
  FDate.free;
  FPublisher.free;
  FContactList.Free;
  FDescription.free;
  FUseContextList.Free;
  FJurisdictionList.Free;
  FPurpose.free;
  FCode.free;
  FBase.Free;
  FType_.free;
  FExpression.free;
  FXpath.free;
  FXpathUsage.free;
  FTarget.Free;
  FMultipleOr.free;
  FMultipleAnd.free;
  FComparator.Free;
  FModifier.Free;
  FChainList.Free;
  FComponentList.Free;
  inherited;
end;

procedure TFhirSearchParameter.Assign(oSource : TFslObject);
begin
  inherited;
  urlElement := TFhirSearchParameter(oSource).urlElement.Clone;
  versionElement := TFhirSearchParameter(oSource).versionElement.Clone;
  nameElement := TFhirSearchParameter(oSource).nameElement.Clone;
  derivedFromElement := TFhirSearchParameter(oSource).derivedFromElement.Clone;
  statusElement := TFhirSearchParameter(oSource).statusElement.Clone;
  experimentalElement := TFhirSearchParameter(oSource).experimentalElement.Clone;
  dateElement := TFhirSearchParameter(oSource).dateElement.Clone;
  publisherElement := TFhirSearchParameter(oSource).publisherElement.Clone;
  if (TFhirSearchParameter(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirContactDetailList.Create;
    FContactList.Assign(TFhirSearchParameter(oSource).FContactList);
  end;
  descriptionElement := TFhirSearchParameter(oSource).descriptionElement.Clone;
  if (TFhirSearchParameter(oSource).FUseContextList = nil) then
  begin
    FUseContextList.free;
    FUseContextList := nil;
  end
  else
  begin
    if FUseContextList = nil then
      FUseContextList := TFhirUsageContextList.Create;
    FUseContextList.Assign(TFhirSearchParameter(oSource).FUseContextList);
  end;
  if (TFhirSearchParameter(oSource).FJurisdictionList = nil) then
  begin
    FJurisdictionList.free;
    FJurisdictionList := nil;
  end
  else
  begin
    if FJurisdictionList = nil then
      FJurisdictionList := TFhirCodeableConceptList.Create;
    FJurisdictionList.Assign(TFhirSearchParameter(oSource).FJurisdictionList);
  end;
  purposeElement := TFhirSearchParameter(oSource).purposeElement.Clone;
  codeElement := TFhirSearchParameter(oSource).codeElement.Clone;
  if (TFhirSearchParameter(oSource).FBase = nil) then
  begin
    FBase.free;
    FBase := nil;
  end
  else
  begin
    FBase := TFhirEnumList.Create(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum);
    FBase.Assign(TFhirSearchParameter(oSource).FBase);
  end;
  type_Element := TFhirSearchParameter(oSource).type_Element.Clone;
  expressionElement := TFhirSearchParameter(oSource).expressionElement.Clone;
  xpathElement := TFhirSearchParameter(oSource).xpathElement.Clone;
  xpathUsageElement := TFhirSearchParameter(oSource).xpathUsageElement.Clone;
  if (TFhirSearchParameter(oSource).FTarget = nil) then
  begin
    FTarget.free;
    FTarget := nil;
  end
  else
  begin
    FTarget := TFhirEnumList.Create(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum);
    FTarget.Assign(TFhirSearchParameter(oSource).FTarget);
  end;
  multipleOrElement := TFhirSearchParameter(oSource).multipleOrElement.Clone;
  multipleAndElement := TFhirSearchParameter(oSource).multipleAndElement.Clone;
  if (TFhirSearchParameter(oSource).FComparator = nil) then
  begin
    FComparator.free;
    FComparator := nil;
  end
  else
  begin
    FComparator := TFhirEnumList.Create(SYSTEMS_TFhirSearchComparatorEnum, CODES_TFhirSearchComparatorEnum);
    FComparator.Assign(TFhirSearchParameter(oSource).FComparator);
  end;
  if (TFhirSearchParameter(oSource).FModifier = nil) then
  begin
    FModifier.free;
    FModifier := nil;
  end
  else
  begin
    FModifier := TFhirEnumList.Create(SYSTEMS_TFhirSearchModifierCodeEnum, CODES_TFhirSearchModifierCodeEnum);
    FModifier.Assign(TFhirSearchParameter(oSource).FModifier);
  end;
  if (TFhirSearchParameter(oSource).FChainList = nil) then
  begin
    FChainList.free;
    FChainList := nil;
  end
  else
  begin
    if FChainList = nil then
      FChainList := TFhirStringList.Create;
    FChainList.Assign(TFhirSearchParameter(oSource).FChainList);
  end;
  if (TFhirSearchParameter(oSource).FComponentList = nil) then
  begin
    FComponentList.free;
    FComponentList := nil;
  end
  else
  begin
    if FComponentList = nil then
      FComponentList := TFhirSearchParameterComponentList.Create;
    FComponentList.Assign(TFhirSearchParameter(oSource).FComponentList);
  end;
end;

function TFhirSearchParameter.GetResourceType : TFhirResourceType;
begin
  result := frtSearchParameter;
end;

procedure TFhirSearchParameter.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
  if (child_name = 'version') Then
     list.add(self.link, 'version', FVersion.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'derivedFrom') Then
     list.add(self.link, 'derivedFrom', FDerivedFrom.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'experimental') Then
     list.add(self.link, 'experimental', FExperimental.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'publisher') Then
     list.add(self.link, 'publisher', FPublisher.Link);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'useContext') Then
    list.addAll(self, 'useContext', FUseContextList);
  if (child_name = 'jurisdiction') Then
    list.addAll(self, 'jurisdiction', FJurisdictionList);
  if (child_name = 'purpose') Then
     list.add(self.link, 'purpose', FPurpose.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'base') Then
     list.addAll(self, 'base', FBase);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'expression') Then
     list.add(self.link, 'expression', FExpression.Link);
  if (child_name = 'xpath') Then
     list.add(self.link, 'xpath', FXpath.Link);
  if (child_name = 'xpathUsage') Then
     list.add(self.link, 'xpathUsage', FXpathUsage.Link);
  if (child_name = 'target') Then
     list.addAll(self, 'target', FTarget);
  if (child_name = 'multipleOr') Then
     list.add(self.link, 'multipleOr', FMultipleOr.Link);
  if (child_name = 'multipleAnd') Then
     list.add(self.link, 'multipleAnd', FMultipleAnd.Link);
  if (child_name = 'comparator') Then
     list.addAll(self, 'comparator', FComparator);
  if (child_name = 'modifier') Then
     list.addAll(self, 'modifier', FModifier);
  if (child_name = 'chain') Then
    list.addAll(self, 'chain', FChainList);
  if (child_name = 'component') Then
    list.addAll(self, 'component', FComponentList);
end;

procedure TFhirSearchParameter.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'url', 'uri', false, TFhirUri, FUrl.Link));
  oList.add(TFHIRProperty.create(self, 'version', 'string', false, TFhirString, FVersion.Link));
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'derivedFrom', 'canonical', false, TFhirCanonical, FDerivedFrom.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'experimental', 'boolean', false, TFhirBoolean, FExperimental.Link));
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));
  oList.add(TFHIRProperty.create(self, 'publisher', 'string', false, TFhirString, FPublisher.Link));
  oList.add(TFHIRProperty.create(self, 'contact', 'ContactDetail', true, TFhirContactDetail, FContactList.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'markdown', false, TFhirMarkdown, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'useContext', 'UsageContext', true, TFhirUsageContext, FUseContextList.Link));
  oList.add(TFHIRProperty.create(self, 'jurisdiction', 'CodeableConcept', true, TFhirCodeableConcept, FJurisdictionList.Link));
  oList.add(TFHIRProperty.create(self, 'purpose', 'markdown', false, TFhirMarkdown, FPurpose.Link));
  oList.add(TFHIRProperty.create(self, 'code', 'code', false, TFhirCode, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'base', 'code', true, TFhirEnum, FBase.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFhirEnum, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'expression', 'string', false, TFhirString, FExpression.Link));
  oList.add(TFHIRProperty.create(self, 'xpath', 'string', false, TFhirString, FXpath.Link));
  oList.add(TFHIRProperty.create(self, 'xpathUsage', 'code', false, TFhirEnum, FXpathUsage.Link));
  oList.add(TFHIRProperty.create(self, 'target', 'code', true, TFhirEnum, FTarget.Link));
  oList.add(TFHIRProperty.create(self, 'multipleOr', 'boolean', false, TFhirBoolean, FMultipleOr.Link));
  oList.add(TFHIRProperty.create(self, 'multipleAnd', 'boolean', false, TFhirBoolean, FMultipleAnd.Link));
  oList.add(TFHIRProperty.create(self, 'comparator', 'code', true, TFhirEnum, FComparator.Link));
  oList.add(TFHIRProperty.create(self, 'modifier', 'code', true, TFhirEnum, FModifier.Link));
  oList.add(TFHIRProperty.create(self, 'chain', 'string', true, TFhirString, FChainList.Link));
  oList.add(TFHIRProperty.create(self, 'component', 'BackboneElement', true, TFhirSearchParameterComponent, FComponentList.Link));
end;

function TFhirSearchParameter.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'url') then
  begin
    UrlElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'derivedFrom') then
  begin
    DerivedFromElement := asCanonical(propValue);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'experimental') then
  begin
    ExperimentalElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'publisher') then
  begin
    PublisherElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirContactDetail);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'useContext') then
  begin
    UseContextList.add(propValue as TFhirUsageContext);
    result := propValue;
  end
  else if (propName = 'jurisdiction') then
  begin
    JurisdictionList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'purpose') then
  begin
    PurposeElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    CodeElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'base') then
  begin
    BaseList.add(asEnum(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum, propValue));
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirSearchParamTypeEnum, CODES_TFhirSearchParamTypeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'expression') then
  begin
    ExpressionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'xpath') then
  begin
    XpathElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'xpathUsage') then
  begin
    XpathUsageElement := asEnum(SYSTEMS_TFhirXPathUsageTypeEnum, CODES_TFhirXPathUsageTypeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'target') then
  begin
    TargetList.add(asEnum(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum, propValue));
    result := propValue;
  end
  else if (propName = 'multipleOr') then
  begin
    MultipleOrElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'multipleAnd') then
  begin
    MultipleAndElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'comparator') then
  begin
    ComparatorList.add(asEnum(SYSTEMS_TFhirSearchComparatorEnum, CODES_TFhirSearchComparatorEnum, propValue));
    result := propValue;
  end
  else if (propName = 'modifier') then
  begin
    ModifierList.add(asEnum(SYSTEMS_TFhirSearchModifierCodeEnum, CODES_TFhirSearchModifierCodeEnum, propValue));
    result := propValue;
  end
  else if (propName = 'chain') then
  begin
    ChainList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'component') then
  begin
    ComponentList.add(propValue as TFhirSearchParameterComponent);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSearchParameter.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirContactDetail)
  else if (propName = 'useContext') then UseContextList.insertItem(index, propValue as TFhirUsageContext)
  else if (propName = 'jurisdiction') then JurisdictionList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'base') then FBase.insertItem(index, asEnum(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum, propValue))
  else if (propName = 'target') then FTarget.insertItem(index, asEnum(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum, propValue))
  else if (propName = 'comparator') then FComparator.insertItem(index, asEnum(SYSTEMS_TFhirSearchComparatorEnum, CODES_TFhirSearchComparatorEnum, propValue))
  else if (propName = 'modifier') then FModifier.insertItem(index, asEnum(SYSTEMS_TFhirSearchModifierCodeEnum, CODES_TFhirSearchModifierCodeEnum, propValue))
  else if (propName = 'chain') then ChainList.insertItem(index, asString(propValue))
  else if (propName = 'component') then ComponentList.insertItem(index, propValue as TFhirSearchParameterComponent)
  else inherited;
end;

function TFhirSearchParameter.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'url') then result := TFhirUri.create()
  else if (propName = 'version') then result := TFhirString.create()
  else if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'derivedFrom') then result := TFhirCanonical.create()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[PublicationStatusNull], CODES_TFhirPublicationStatusEnum[PublicationStatusNull]) 
  else if (propName = 'experimental') then result := TFhirBoolean.create()
  else if (propName = 'date') then result := TFhirDateTime.create()
  else if (propName = 'publisher') then result := TFhirString.create()
  else if (propName = 'contact') then result := ContactList.new()
  else if (propName = 'description') then result := TFhirMarkdown.create()
  else if (propName = 'useContext') then result := UseContextList.new()
  else if (propName = 'jurisdiction') then result := JurisdictionList.new()
  else if (propName = 'purpose') then result := TFhirMarkdown.create()
  else if (propName = 'code') then result := TFhirCode.create()
  else if (propName = 'type') then result := TFhirEnum.create(SYSTEMS_TFhirSearchParamTypeEnum[SearchParamTypeNull], CODES_TFhirSearchParamTypeEnum[SearchParamTypeNull]) 
  else if (propName = 'expression') then result := TFhirString.create()
  else if (propName = 'xpath') then result := TFhirString.create()
  else if (propName = 'xpathUsage') then result := TFhirEnum.create(SYSTEMS_TFhirXPathUsageTypeEnum[XPathUsageTypeNull], CODES_TFhirXPathUsageTypeEnum[XPathUsageTypeNull]) 
  else if (propName = 'multipleOr') then result := TFhirBoolean.create()
  else if (propName = 'multipleAnd') then result := TFhirBoolean.create()
  else if (propName = 'chain') then result := ChainList.new()
  else if (propName = 'component') then result := ComponentList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSearchParameter.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'url') then result := 'uri'
  else if (propName = 'version') then result := 'string'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'derivedFrom') then result := 'canonical'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'experimental') then result := 'boolean'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'publisher') then result := 'string'
  else if (propName = 'contact') then result := 'ContactDetail'
  else if (propName = 'description') then result := 'markdown'
  else if (propName = 'useContext') then result := 'UsageContext'
  else if (propName = 'jurisdiction') then result := 'CodeableConcept'
  else if (propName = 'purpose') then result := 'markdown'
  else if (propName = 'code') then result := 'code'
  else if (propName = 'base') then result := 'code'
  else if (propName = 'type') then result := 'code'
  else if (propName = 'expression') then result := 'string'
  else if (propName = 'xpath') then result := 'string'
  else if (propName = 'xpathUsage') then result := 'code'
  else if (propName = 'target') then result := 'code'
  else if (propName = 'multipleOr') then result := 'boolean'
  else if (propName = 'multipleAnd') then result := 'boolean'
  else if (propName = 'comparator') then result := 'code'
  else if (propName = 'modifier') then result := 'code'
  else if (propName = 'chain') then result := 'string'
  else if (propName = 'component') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSearchParameter.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := nil
  else if (propName = 'version') then VersionElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'derivedFrom') then DerivedFromElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'experimental') then ExperimentalElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'publisher') then PublisherElement := nil
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value)
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'useContext') then deletePropertyValue('useContext', UseContextList, value)
  else if (propName = 'jurisdiction') then deletePropertyValue('jurisdiction', JurisdictionList, value)
  else if (propName = 'purpose') then PurposeElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'expression') then ExpressionElement := nil
  else if (propName = 'xpath') then XpathElement := nil
  else if (propName = 'xpathUsage') then XpathUsageElement := nil
  else if (propName = 'multipleOr') then MultipleOrElement := nil
  else if (propName = 'multipleAnd') then MultipleAndElement := nil
  else if (propName = 'chain') then deletePropertyValue('chain', ChainList, value)
  else if (propName = 'component') then deletePropertyValue('component', ComponentList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSearchParameter.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := asUri(new)
  else if (propName = 'version') then VersionElement := asString(new)
  else if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'derivedFrom') then DerivedFromElement := asCanonical(new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, new)
  else if (propName = 'experimental') then ExperimentalElement := asBoolean(new)
  else if (propName = 'date') then DateElement := asDateTime(new)
  else if (propName = 'publisher') then PublisherElement := asString(new)
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new)
  else if (propName = 'description') then DescriptionElement := asMarkdown(new)
  else if (propName = 'useContext') then replacePropertyValue('useContext', UseContextList, existing, new)
  else if (propName = 'jurisdiction') then replacePropertyValue('jurisdiction', JurisdictionList, existing, new)
  else if (propName = 'purpose') then PurposeElement := asMarkdown(new)
  else if (propName = 'code') then CodeElement := asCode(new)
  else if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirSearchParamTypeEnum, CODES_TFhirSearchParamTypeEnum, new)
  else if (propName = 'expression') then ExpressionElement := asString(new)
  else if (propName = 'xpath') then XpathElement := asString(new)
  else if (propName = 'xpathUsage') then XpathUsageElement := asEnum(SYSTEMS_TFhirXPathUsageTypeEnum, CODES_TFhirXPathUsageTypeEnum, new)
  else if (propName = 'multipleOr') then MultipleOrElement := asBoolean(new)
  else if (propName = 'multipleAnd') then MultipleAndElement := asBoolean(new)
  else if (propName = 'chain') then replacePropertyValue('chain', ChainList, existing, new)
  else if (propName = 'component') then replacePropertyValue('component', ComponentList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSearchParameter.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'contact') then ContactList.move(source, destination)
  else if (propName = 'useContext') then UseContextList.move(source, destination)
  else if (propName = 'jurisdiction') then JurisdictionList.move(source, destination)
  else if (propName = 'base') then FBase.move(source, destination)
  else if (propName = 'target') then FTarget.move(source, destination)
  else if (propName = 'comparator') then FComparator.move(source, destination)
  else if (propName = 'modifier') then FModifier.move(source, destination)
  else if (propName = 'chain') then ChainList.move(source, destination)
  else if (propName = 'component') then ComponentList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSearchParameter.fhirType : string;
begin
  result := 'SearchParameter';
end;

function TFhirSearchParameter.Link : TFhirSearchParameter;
begin
  result := TFhirSearchParameter(inherited Link);
end;

function TFhirSearchParameter.Clone : TFhirSearchParameter;
begin
  result := TFhirSearchParameter(inherited Clone);
end;

function TFhirSearchParameter.equals(other : TObject) : boolean; 
var
  o : TFhirSearchParameter;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSearchParameter)) then
    result := false
  else
  begin
    o := TFhirSearchParameter(other);
    result := compareDeep(urlElement, o.urlElement, true) and compareDeep(versionElement, o.versionElement, true) and 
      compareDeep(nameElement, o.nameElement, true) and compareDeep(derivedFromElement, o.derivedFromElement, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(experimentalElement, o.experimentalElement, true) and 
      compareDeep(dateElement, o.dateElement, true) and compareDeep(publisherElement, o.publisherElement, true) and 
      compareDeep(contactList, o.contactList, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(useContextList, o.useContextList, true) and compareDeep(jurisdictionList, o.jurisdictionList, true) and 
      compareDeep(purposeElement, o.purposeElement, true) and compareDeep(codeElement, o.codeElement, true) and 
      compareDeep(baseList, o.baseList, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(expressionElement, o.expressionElement, true) and compareDeep(xpathElement, o.xpathElement, true) and 
      compareDeep(xpathUsageElement, o.xpathUsageElement, true) and compareDeep(targetList, o.targetList, true) and 
      compareDeep(multipleOrElement, o.multipleOrElement, true) and compareDeep(multipleAndElement, o.multipleAndElement, true) and 
      compareDeep(comparatorList, o.comparatorList, true) and compareDeep(modifierList, o.modifierList, true) and 
      compareDeep(chainList, o.chainList, true) and compareDeep(componentList, o.componentList, true);
  end;
end;

function TFhirSearchParameter.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FUrl) and isEmptyProp(FVersion) and isEmptyProp(FName) and isEmptyProp(FDerivedFrom) and isEmptyProp(FStatus) and isEmptyProp(FExperimental) and isEmptyProp(FDate) and isEmptyProp(FPublisher) and isEmptyProp(FcontactList) and isEmptyProp(FDescription) and isEmptyProp(FuseContextList) and isEmptyProp(FjurisdictionList) and isEmptyProp(FPurpose) and isEmptyProp(FCode) and isEmptyProp(FBase) and isEmptyProp(FType_) and isEmptyProp(FExpression) and isEmptyProp(FXpath) and isEmptyProp(FXpathUsage) and isEmptyProp(FTarget) and isEmptyProp(FMultipleOr) and isEmptyProp(FMultipleAnd) and isEmptyProp(FComparator) and isEmptyProp(FModifier) and isEmptyProp(FchainList) and isEmptyProp(FcomponentList);
end;

procedure TFhirSearchParameter.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('url');
  fields.add('version');
  fields.add('name');
  fields.add('derivedFrom');
  fields.add('status');
  fields.add('experimental');
  fields.add('date');
  fields.add('publisher');
  fields.add('contact');
  fields.add('description');
  fields.add('useContext');
  fields.add('jurisdiction');
  fields.add('purpose');
  fields.add('code');
  fields.add('base');
  fields.add('type');
  fields.add('expression');
  fields.add('xpath');
  fields.add('xpathUsage');
  fields.add('target');
  fields.add('multipleOr');
  fields.add('multipleAnd');
  fields.add('comparator');
  fields.add('modifier');
  fields.add('chain');
  fields.add('component');
end;

function TFhirSearchParameter.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FContactList.sizeInBytes(magic));
  inc(result, FUseContextList.sizeInBytes(magic));
  inc(result, FJurisdictionList.sizeInBytes(magic));
  inc(result, FBase.sizeInBytes(magic));
  inc(result, FTarget.sizeInBytes(magic));
  inc(result, FComparator.sizeInBytes(magic));
  inc(result, FModifier.sizeInBytes(magic));
  inc(result, FChainList.sizeInBytes(magic));
  inc(result, FComponentList.sizeInBytes(magic));
end;

procedure TFhirSearchParameter.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

function TFhirSearchParameter.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

procedure TFhirSearchParameter.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

procedure TFhirSearchParameter.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

function TFhirSearchParameter.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

procedure TFhirSearchParameter.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

procedure TFhirSearchParameter.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirSearchParameter.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirSearchParameter.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirSearchParameter.SetDerivedFrom(value : TFhirCanonical);
begin
  FDerivedFrom.free;
  FDerivedFrom := value;
end;

function TFhirSearchParameter.GetDerivedFromST : String;
begin
  if FDerivedFrom = nil then
    result := ''
  else
    result := FDerivedFrom.value;
end;

procedure TFhirSearchParameter.SetDerivedFromST(value : String);
begin
  if value <> '' then
  begin
    if FDerivedFrom = nil then
      FDerivedFrom := TFhirCanonical.create;
    FDerivedFrom.value := value
  end
  else if FDerivedFrom <> nil then
    FDerivedFrom.value := '';
end;

procedure TFhirSearchParameter.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirSearchParameter.GetStatusST : TFhirPublicationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirPublicationStatusEnum(0)
  else
    result := TFhirPublicationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirPublicationStatusEnum, FStatus.value));
end;

procedure TFhirSearchParameter.SetStatusST(value : TFhirPublicationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[value], CODES_TFhirPublicationStatusEnum[value]);
end;

procedure TFhirSearchParameter.SetExperimental(value : TFhirBoolean);
begin
  FExperimental.free;
  FExperimental := value;
end;

function TFhirSearchParameter.GetExperimentalST : Boolean;
begin
  if FExperimental = nil then
    result := false
  else
    result := FExperimental.value;
end;

procedure TFhirSearchParameter.SetExperimentalST(value : Boolean);
begin
  if FExperimental = nil then
    FExperimental := TFhirBoolean.create;
  FExperimental.value := value
end;

procedure TFhirSearchParameter.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

function TFhirSearchParameter.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirSearchParameter.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

procedure TFhirSearchParameter.SetPublisher(value : TFhirString);
begin
  FPublisher.free;
  FPublisher := value;
end;

function TFhirSearchParameter.GetPublisherST : String;
begin
  if FPublisher = nil then
    result := ''
  else
    result := FPublisher.value;
end;

procedure TFhirSearchParameter.SetPublisherST(value : String);
begin
  if value <> '' then
  begin
    if FPublisher = nil then
      FPublisher := TFhirString.create;
    FPublisher.value := value
  end
  else if FPublisher <> nil then
    FPublisher.value := '';
end;

function TFhirSearchParameter.GetContactList : TFhirContactDetailList;
begin
  if FContactList = nil then
    FContactList := TFhirContactDetailList.Create;
  result := FContactList;
end;

function TFhirSearchParameter.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

procedure TFhirSearchParameter.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirSearchParameter.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirSearchParameter.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirSearchParameter.GetUseContextList : TFhirUsageContextList;
begin
  if FUseContextList = nil then
    FUseContextList := TFhirUsageContextList.Create;
  result := FUseContextList;
end;

function TFhirSearchParameter.GetHasUseContextList : boolean;
begin
  result := (FUseContextList <> nil) and (FUseContextList.count > 0);
end;

function TFhirSearchParameter.GetJurisdictionList : TFhirCodeableConceptList;
begin
  if FJurisdictionList = nil then
    FJurisdictionList := TFhirCodeableConceptList.Create;
  result := FJurisdictionList;
end;

function TFhirSearchParameter.GetHasJurisdictionList : boolean;
begin
  result := (FJurisdictionList <> nil) and (FJurisdictionList.count > 0);
end;

procedure TFhirSearchParameter.SetPurpose(value : TFhirMarkdown);
begin
  FPurpose.free;
  FPurpose := value;
end;

function TFhirSearchParameter.GetPurposeST : String;
begin
  if FPurpose = nil then
    result := ''
  else
    result := FPurpose.value;
end;

procedure TFhirSearchParameter.SetPurposeST(value : String);
begin
  if value <> '' then
  begin
    if FPurpose = nil then
      FPurpose := TFhirMarkdown.create;
    FPurpose.value := value
  end
  else if FPurpose <> nil then
    FPurpose.value := '';
end;

procedure TFhirSearchParameter.SetCode(value : TFhirCode);
begin
  FCode.free;
  FCode := value;
end;

function TFhirSearchParameter.GetCodeST : String;
begin
  if FCode = nil then
    result := ''
  else
    result := FCode.value;
end;

procedure TFhirSearchParameter.SetCodeST(value : String);
begin
  if value <> '' then
  begin
    if FCode = nil then
      FCode := TFhirCode.create;
    FCode.value := value
  end
  else if FCode <> nil then
    FCode.value := '';
end;

function TFhirSearchParameter.GetBase : TFhirEnumList;
begin
  if FBase = nil then
    FBase := TFhirEnumList.Create(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum);
  result := FBase;
end;

function TFhirSearchParameter.GetHasBase : boolean;
begin
  result := (FBase <> nil) and (FBase.count > 0);
end;

procedure TFhirSearchParameter.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirSearchParameter.GetType_ST : TFhirSearchParamTypeEnum;
begin
  if FType_ = nil then
    result := TFhirSearchParamTypeEnum(0)
  else
    result := TFhirSearchParamTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirSearchParamTypeEnum, FType_.value));
end;

procedure TFhirSearchParameter.SetType_ST(value : TFhirSearchParamTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirSearchParamTypeEnum[value], CODES_TFhirSearchParamTypeEnum[value]);
end;

procedure TFhirSearchParameter.SetExpression(value : TFhirString);
begin
  FExpression.free;
  FExpression := value;
end;

function TFhirSearchParameter.GetExpressionST : String;
begin
  if FExpression = nil then
    result := ''
  else
    result := FExpression.value;
end;

procedure TFhirSearchParameter.SetExpressionST(value : String);
begin
  if value <> '' then
  begin
    if FExpression = nil then
      FExpression := TFhirString.create;
    FExpression.value := value
  end
  else if FExpression <> nil then
    FExpression.value := '';
end;

procedure TFhirSearchParameter.SetXpath(value : TFhirString);
begin
  FXpath.free;
  FXpath := value;
end;

function TFhirSearchParameter.GetXpathST : String;
begin
  if FXpath = nil then
    result := ''
  else
    result := FXpath.value;
end;

procedure TFhirSearchParameter.SetXpathST(value : String);
begin
  if value <> '' then
  begin
    if FXpath = nil then
      FXpath := TFhirString.create;
    FXpath.value := value
  end
  else if FXpath <> nil then
    FXpath.value := '';
end;

procedure TFhirSearchParameter.SetXpathUsage(value : TFhirEnum);
begin
  FXpathUsage.free;
  FXpathUsage := value;
end;

function TFhirSearchParameter.GetXpathUsageST : TFhirXPathUsageTypeEnum;
begin
  if FXpathUsage = nil then
    result := TFhirXPathUsageTypeEnum(0)
  else
    result := TFhirXPathUsageTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirXPathUsageTypeEnum, FXpathUsage.value));
end;

procedure TFhirSearchParameter.SetXpathUsageST(value : TFhirXPathUsageTypeEnum);
begin
  if ord(value) = 0 then
    XpathUsageElement := nil
  else
    XpathUsageElement := TFhirEnum.create(SYSTEMS_TFhirXPathUsageTypeEnum[value], CODES_TFhirXPathUsageTypeEnum[value]);
end;

function TFhirSearchParameter.GetTarget : TFhirEnumList;
begin
  if FTarget = nil then
    FTarget := TFhirEnumList.Create(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum);
  result := FTarget;
end;

function TFhirSearchParameter.GetHasTarget : boolean;
begin
  result := (FTarget <> nil) and (FTarget.count > 0);
end;

procedure TFhirSearchParameter.SetMultipleOr(value : TFhirBoolean);
begin
  FMultipleOr.free;
  FMultipleOr := value;
end;

function TFhirSearchParameter.GetMultipleOrST : Boolean;
begin
  if FMultipleOr = nil then
    result := false
  else
    result := FMultipleOr.value;
end;

procedure TFhirSearchParameter.SetMultipleOrST(value : Boolean);
begin
  if FMultipleOr = nil then
    FMultipleOr := TFhirBoolean.create;
  FMultipleOr.value := value
end;

procedure TFhirSearchParameter.SetMultipleAnd(value : TFhirBoolean);
begin
  FMultipleAnd.free;
  FMultipleAnd := value;
end;

function TFhirSearchParameter.GetMultipleAndST : Boolean;
begin
  if FMultipleAnd = nil then
    result := false
  else
    result := FMultipleAnd.value;
end;

procedure TFhirSearchParameter.SetMultipleAndST(value : Boolean);
begin
  if FMultipleAnd = nil then
    FMultipleAnd := TFhirBoolean.create;
  FMultipleAnd.value := value
end;

function TFhirSearchParameter.GetComparator : TFhirEnumList;
begin
  if FComparator = nil then
    FComparator := TFhirEnumList.Create(SYSTEMS_TFhirSearchComparatorEnum, CODES_TFhirSearchComparatorEnum);
  result := FComparator;
end;

function TFhirSearchParameter.GetHasComparator : boolean;
begin
  result := (FComparator <> nil) and (FComparator.count > 0);
end;

function TFhirSearchParameter.GetComparatorST : TFhirSearchComparatorEnumList;
  var i : integer;
begin
  result := [];
  if Fcomparator <> nil then
    for i := 0 to Fcomparator.count - 1 do
      result := result + [TFhirSearchComparatorEnum(StringArrayIndexOfSensitive(CODES_TFhirSearchComparatorEnum, Fcomparator[i].value))];
end;

procedure TFhirSearchParameter.SetComparatorST(value : TFhirSearchComparatorEnumList);
var a : TFhirSearchComparatorEnum;
begin
  if Fcomparator = nil then
    Fcomparator := TFhirEnumList.create(SYSTEMS_TFhirSearchComparatorEnum, CODES_TFhirSearchComparatorEnum);
  Fcomparator.clear;
  for a := low(TFhirSearchComparatorEnum) to high(TFhirSearchComparatorEnum) do
    if a in value then
      begin
         if Fcomparator = nil then
           Fcomparator := TFhirEnumList.create(SYSTEMS_TFhirSearchComparatorEnum, CODES_TFhirSearchComparatorEnum);
         Fcomparator.add(TFhirEnum.create(SYSTEMS_TFhirSearchComparatorEnum[a], CODES_TFhirSearchComparatorEnum[a]));
      end;
end;

function TFhirSearchParameter.GetModifier : TFhirEnumList;
begin
  if FModifier = nil then
    FModifier := TFhirEnumList.Create(SYSTEMS_TFhirSearchModifierCodeEnum, CODES_TFhirSearchModifierCodeEnum);
  result := FModifier;
end;

function TFhirSearchParameter.GetHasModifier : boolean;
begin
  result := (FModifier <> nil) and (FModifier.count > 0);
end;

function TFhirSearchParameter.GetModifierST : TFhirSearchModifierCodeEnumList;
  var i : integer;
begin
  result := [];
  if Fmodifier <> nil then
    for i := 0 to Fmodifier.count - 1 do
      result := result + [TFhirSearchModifierCodeEnum(StringArrayIndexOfSensitive(CODES_TFhirSearchModifierCodeEnum, Fmodifier[i].value))];
end;

procedure TFhirSearchParameter.SetModifierST(value : TFhirSearchModifierCodeEnumList);
var a : TFhirSearchModifierCodeEnum;
begin
  if Fmodifier = nil then
    Fmodifier := TFhirEnumList.create(SYSTEMS_TFhirSearchModifierCodeEnum, CODES_TFhirSearchModifierCodeEnum);
  Fmodifier.clear;
  for a := low(TFhirSearchModifierCodeEnum) to high(TFhirSearchModifierCodeEnum) do
    if a in value then
      begin
         if Fmodifier = nil then
           Fmodifier := TFhirEnumList.create(SYSTEMS_TFhirSearchModifierCodeEnum, CODES_TFhirSearchModifierCodeEnum);
         Fmodifier.add(TFhirEnum.create(SYSTEMS_TFhirSearchModifierCodeEnum[a], CODES_TFhirSearchModifierCodeEnum[a]));
      end;
end;

function TFhirSearchParameter.GetChainList : TFhirStringList;
begin
  if FChainList = nil then
    FChainList := TFhirStringList.Create;
  result := FChainList;
end;

function TFhirSearchParameter.GetHasChainList : boolean;
begin
  result := (FChainList <> nil) and (FChainList.count > 0);
end;

function TFhirSearchParameter.GetComponentList : TFhirSearchParameterComponentList;
begin
  if FComponentList = nil then
    FComponentList := TFhirSearchParameterComponentList.Create;
  result := FComponentList;
end;

function TFhirSearchParameter.GetHasComponentList : boolean;
begin
  result := (FComponentList <> nil) and (FComponentList.count > 0);
end;

{ TFhirSearchParameterListEnumerator }

constructor TFhirSearchParameterListEnumerator.Create(list : TFhirSearchParameterList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSearchParameterListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSearchParameterListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSearchParameterListEnumerator.GetCurrent : TFhirSearchParameter;
begin
  Result := FList[FIndex];
end;

function TFhirSearchParameterListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSearchParameterList }

function TFhirSearchParameterList.AddItem(value: TFhirSearchParameter): TFhirSearchParameter;
begin
  assert(value.ClassName = 'TFhirSearchParameter', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSearchParameter');
  add(value);
  result := value;
end;

function TFhirSearchParameterList.Append: TFhirSearchParameter;
begin
  result := TFhirSearchParameter.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSearchParameterList.ClearItems;
begin
  Clear;
end;

function TFhirSearchParameterList.GetEnumerator : TFhirSearchParameterListEnumerator;
begin
  result := TFhirSearchParameterListEnumerator.Create(self.link);
end;

function TFhirSearchParameterList.Clone: TFhirSearchParameterList;
begin
  result := TFhirSearchParameterList(inherited Clone);
end;

function TFhirSearchParameterList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSearchParameterList.GetItemN(index: Integer): TFhirSearchParameter;
begin
  result := TFhirSearchParameter(ObjectByIndex[index]);
end;

function TFhirSearchParameterList.ItemClass: TFslObjectClass;
begin
  result := TFhirSearchParameter;
end;
function TFhirSearchParameterList.IndexOf(value: TFhirSearchParameter): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSearchParameterList.Insert(index: Integer): TFhirSearchParameter;
begin
  result := TFhirSearchParameter.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSearchParameterList.InsertItem(index: Integer; value: TFhirSearchParameter);
begin
  assert(value is TFhirSearchParameter);
  Inherited Insert(index, value);
end;

function TFhirSearchParameterList.Item(index: Integer): TFhirSearchParameter;
begin
  result := TFhirSearchParameter(ObjectByIndex[index]);
end;

function TFhirSearchParameterList.Link: TFhirSearchParameterList;
begin
  result := TFhirSearchParameterList(inherited Link);
end;

procedure TFhirSearchParameterList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSearchParameterList.SetItemByIndex(index: Integer; value: TFhirSearchParameter);
begin
  assert(value is TFhirSearchParameter);
  FhirSearchParameters[index] := value;
end;

procedure TFhirSearchParameterList.SetItemN(index: Integer; value: TFhirSearchParameter);
begin
  assert(value is TFhirSearchParameter);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_SEARCHPARAMETER}
{$IFDEF FHIR_SPECIMENDEFINITION}
{ TFhirSpecimenDefinitionTypeTested }

constructor TFhirSpecimenDefinitionTypeTested.Create;
begin
  inherited;
end;

destructor TFhirSpecimenDefinitionTypeTested.Destroy;
begin
  FIsDerived.free;
  FType_.free;
  FPreference.free;
  FContainer.free;
  FRequirement.free;
  FRetentionTime.free;
  FRejectionCriterionList.Free;
  FHandlingList.Free;
  inherited;
end;

procedure TFhirSpecimenDefinitionTypeTested.Assign(oSource : TFslObject);
begin
  inherited;
  isDerivedElement := TFhirSpecimenDefinitionTypeTested(oSource).isDerivedElement.Clone;
  type_ := TFhirSpecimenDefinitionTypeTested(oSource).type_.Clone;
  preferenceElement := TFhirSpecimenDefinitionTypeTested(oSource).preferenceElement.Clone;
  container := TFhirSpecimenDefinitionTypeTested(oSource).container.Clone;
  requirementElement := TFhirSpecimenDefinitionTypeTested(oSource).requirementElement.Clone;
  retentionTime := TFhirSpecimenDefinitionTypeTested(oSource).retentionTime.Clone;
  if (TFhirSpecimenDefinitionTypeTested(oSource).FRejectionCriterionList = nil) then
  begin
    FRejectionCriterionList.free;
    FRejectionCriterionList := nil;
  end
  else
  begin
    if FRejectionCriterionList = nil then
      FRejectionCriterionList := TFhirCodeableConceptList.Create;
    FRejectionCriterionList.Assign(TFhirSpecimenDefinitionTypeTested(oSource).FRejectionCriterionList);
  end;
  if (TFhirSpecimenDefinitionTypeTested(oSource).FHandlingList = nil) then
  begin
    FHandlingList.free;
    FHandlingList := nil;
  end
  else
  begin
    if FHandlingList = nil then
      FHandlingList := TFhirSpecimenDefinitionTypeTestedHandlingList.Create;
    FHandlingList.Assign(TFhirSpecimenDefinitionTypeTested(oSource).FHandlingList);
  end;
end;

procedure TFhirSpecimenDefinitionTypeTested.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'isDerived') Then
     list.add(self.link, 'isDerived', FIsDerived.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'preference') Then
     list.add(self.link, 'preference', FPreference.Link);
  if (child_name = 'container') Then
     list.add(self.link, 'container', FContainer.Link);
  if (child_name = 'requirement') Then
     list.add(self.link, 'requirement', FRequirement.Link);
  if (child_name = 'retentionTime') Then
     list.add(self.link, 'retentionTime', FRetentionTime.Link);
  if (child_name = 'rejectionCriterion') Then
    list.addAll(self, 'rejectionCriterion', FRejectionCriterionList);
  if (child_name = 'handling') Then
    list.addAll(self, 'handling', FHandlingList);
end;

procedure TFhirSpecimenDefinitionTypeTested.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'isDerived', 'boolean', false, TFhirBoolean, FIsDerived.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'preference', 'code', false, TFhirEnum, FPreference.Link));
  oList.add(TFHIRProperty.create(self, 'container', 'BackboneElement', false, TFhirSpecimenDefinitionTypeTestedContainer, FContainer.Link));
  oList.add(TFHIRProperty.create(self, 'requirement', 'string', false, TFhirString, FRequirement.Link));
  oList.add(TFHIRProperty.create(self, 'retentionTime', 'Duration', false, TFhirDuration, FRetentionTime.Link));
  oList.add(TFHIRProperty.create(self, 'rejectionCriterion', 'CodeableConcept', true, TFhirCodeableConcept, FRejectionCriterionList.Link));
  oList.add(TFHIRProperty.create(self, 'handling', 'BackboneElement', true, TFhirSpecimenDefinitionTypeTestedHandling, FHandlingList.Link));
end;

function TFhirSpecimenDefinitionTypeTested.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'isDerived') then
  begin
    IsDerivedElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'preference') then
  begin
    PreferenceElement := asEnum(SYSTEMS_TFhirSpecimenContainedPreferenceEnum, CODES_TFhirSpecimenContainedPreferenceEnum, propValue);
    result := propValue;
  end
  else if (propName = 'container') then
  begin
    Container := propValue as TFhirSpecimenDefinitionTypeTestedContainer;
    result := propValue;
  end
  else if (propName = 'requirement') then
  begin
    RequirementElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'retentionTime') then
  begin
    RetentionTime := propValue as TFhirDuration;
    result := propValue;
  end
  else if (propName = 'rejectionCriterion') then
  begin
    RejectionCriterionList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'handling') then
  begin
    HandlingList.add(propValue as TFhirSpecimenDefinitionTypeTestedHandling);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSpecimenDefinitionTypeTested.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'rejectionCriterion') then RejectionCriterionList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'handling') then HandlingList.insertItem(index, propValue as TFhirSpecimenDefinitionTypeTestedHandling)
  else inherited;
end;

function TFhirSpecimenDefinitionTypeTested.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'isDerived') then result := TFhirBoolean.create()
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'preference') then result := TFhirEnum.create(SYSTEMS_TFhirSpecimenContainedPreferenceEnum[SpecimenContainedPreferenceNull], CODES_TFhirSpecimenContainedPreferenceEnum[SpecimenContainedPreferenceNull]) 
  else if (propName = 'container') then result := TFhirSpecimenDefinitionTypeTestedContainer.create()
  else if (propName = 'requirement') then result := TFhirString.create()
  else if (propName = 'retentionTime') then result := TFhirDuration.create()
  else if (propName = 'rejectionCriterion') then result := RejectionCriterionList.new()
  else if (propName = 'handling') then result := HandlingList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSpecimenDefinitionTypeTested.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'isDerived') then result := 'boolean'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'preference') then result := 'code'
  else if (propName = 'container') then result := 'BackboneElement'
  else if (propName = 'requirement') then result := 'string'
  else if (propName = 'retentionTime') then result := 'Duration'
  else if (propName = 'rejectionCriterion') then result := 'CodeableConcept'
  else if (propName = 'handling') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSpecimenDefinitionTypeTested.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'isDerived') then IsDerivedElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'preference') then PreferenceElement := nil
  else if (propName = 'container') then ContainerElement := nil
  else if (propName = 'requirement') then RequirementElement := nil
  else if (propName = 'retentionTime') then RetentionTimeElement := nil
  else if (propName = 'rejectionCriterion') then deletePropertyValue('rejectionCriterion', RejectionCriterionList, value)
  else if (propName = 'handling') then deletePropertyValue('handling', HandlingList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSpecimenDefinitionTypeTested.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'isDerived') then IsDerivedElement := asBoolean(new)
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'preference') then PreferenceElement := asEnum(SYSTEMS_TFhirSpecimenContainedPreferenceEnum, CODES_TFhirSpecimenContainedPreferenceEnum, new)
  else if (propName = 'container') then ContainerElement := new as TFhirSpecimenDefinitionTypeTestedContainer
  else if (propName = 'requirement') then RequirementElement := asString(new)
  else if (propName = 'retentionTime') then RetentionTimeElement := new as TFhirDuration
  else if (propName = 'rejectionCriterion') then replacePropertyValue('rejectionCriterion', RejectionCriterionList, existing, new)
  else if (propName = 'handling') then replacePropertyValue('handling', HandlingList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSpecimenDefinitionTypeTested.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'rejectionCriterion') then RejectionCriterionList.move(source, destination)
  else if (propName = 'handling') then HandlingList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSpecimenDefinitionTypeTested.fhirType : string;
begin
  result := 'SpecimenDefinition.typeTested';
end;

function TFhirSpecimenDefinitionTypeTested.Link : TFhirSpecimenDefinitionTypeTested;
begin
  result := TFhirSpecimenDefinitionTypeTested(inherited Link);
end;

function TFhirSpecimenDefinitionTypeTested.Clone : TFhirSpecimenDefinitionTypeTested;
begin
  result := TFhirSpecimenDefinitionTypeTested(inherited Clone);
end;

function TFhirSpecimenDefinitionTypeTested.equals(other : TObject) : boolean; 
var
  o : TFhirSpecimenDefinitionTypeTested;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSpecimenDefinitionTypeTested)) then
    result := false
  else
  begin
    o := TFhirSpecimenDefinitionTypeTested(other);
    result := compareDeep(isDerivedElement, o.isDerivedElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(preferenceElement, o.preferenceElement, true) and compareDeep(containerElement, o.containerElement, true) and 
      compareDeep(requirementElement, o.requirementElement, true) and compareDeep(retentionTimeElement, o.retentionTimeElement, true) and 
      compareDeep(rejectionCriterionList, o.rejectionCriterionList, true) and compareDeep(handlingList, o.handlingList, true);
  end;
end;

function TFhirSpecimenDefinitionTypeTested.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIsDerived) and isEmptyProp(FType_) and isEmptyProp(FPreference) and isEmptyProp(FContainer) and isEmptyProp(FRequirement) and isEmptyProp(FRetentionTime) and isEmptyProp(FrejectionCriterionList) and isEmptyProp(FhandlingList);
end;

procedure TFhirSpecimenDefinitionTypeTested.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('isDerived');
  fields.add('type');
  fields.add('preference');
  fields.add('container');
  fields.add('requirement');
  fields.add('retentionTime');
  fields.add('rejectionCriterion');
  fields.add('handling');
end;

function TFhirSpecimenDefinitionTypeTested.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FRejectionCriterionList.sizeInBytes(magic));
  inc(result, FHandlingList.sizeInBytes(magic));
end;

procedure TFhirSpecimenDefinitionTypeTested.SetIsDerived(value : TFhirBoolean);
begin
  FIsDerived.free;
  FIsDerived := value;
end;

function TFhirSpecimenDefinitionTypeTested.GetIsDerivedST : Boolean;
begin
  if FIsDerived = nil then
    result := false
  else
    result := FIsDerived.value;
end;

procedure TFhirSpecimenDefinitionTypeTested.SetIsDerivedST(value : Boolean);
begin
  if FIsDerived = nil then
    FIsDerived := TFhirBoolean.create;
  FIsDerived.value := value
end;

procedure TFhirSpecimenDefinitionTypeTested.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirSpecimenDefinitionTypeTested.SetPreference(value : TFhirEnum);
begin
  FPreference.free;
  FPreference := value;
end;

function TFhirSpecimenDefinitionTypeTested.GetPreferenceST : TFhirSpecimenContainedPreferenceEnum;
begin
  if FPreference = nil then
    result := TFhirSpecimenContainedPreferenceEnum(0)
  else
    result := TFhirSpecimenContainedPreferenceEnum(StringArrayIndexOfSensitive(CODES_TFhirSpecimenContainedPreferenceEnum, FPreference.value));
end;

procedure TFhirSpecimenDefinitionTypeTested.SetPreferenceST(value : TFhirSpecimenContainedPreferenceEnum);
begin
  if ord(value) = 0 then
    PreferenceElement := nil
  else
    PreferenceElement := TFhirEnum.create(SYSTEMS_TFhirSpecimenContainedPreferenceEnum[value], CODES_TFhirSpecimenContainedPreferenceEnum[value]);
end;

procedure TFhirSpecimenDefinitionTypeTested.SetContainer(value : TFhirSpecimenDefinitionTypeTestedContainer);
begin
  FContainer.free;
  FContainer := value;
end;

procedure TFhirSpecimenDefinitionTypeTested.SetRequirement(value : TFhirString);
begin
  FRequirement.free;
  FRequirement := value;
end;

function TFhirSpecimenDefinitionTypeTested.GetRequirementST : String;
begin
  if FRequirement = nil then
    result := ''
  else
    result := FRequirement.value;
end;

procedure TFhirSpecimenDefinitionTypeTested.SetRequirementST(value : String);
begin
  if value <> '' then
  begin
    if FRequirement = nil then
      FRequirement := TFhirString.create;
    FRequirement.value := value
  end
  else if FRequirement <> nil then
    FRequirement.value := '';
end;

procedure TFhirSpecimenDefinitionTypeTested.SetRetentionTime(value : TFhirDuration);
begin
  FRetentionTime.free;
  FRetentionTime := value;
end;

function TFhirSpecimenDefinitionTypeTested.GetRejectionCriterionList : TFhirCodeableConceptList;
begin
  if FRejectionCriterionList = nil then
    FRejectionCriterionList := TFhirCodeableConceptList.Create;
  result := FRejectionCriterionList;
end;

function TFhirSpecimenDefinitionTypeTested.GetHasRejectionCriterionList : boolean;
begin
  result := (FRejectionCriterionList <> nil) and (FRejectionCriterionList.count > 0);
end;

function TFhirSpecimenDefinitionTypeTested.GetHandlingList : TFhirSpecimenDefinitionTypeTestedHandlingList;
begin
  if FHandlingList = nil then
    FHandlingList := TFhirSpecimenDefinitionTypeTestedHandlingList.Create;
  result := FHandlingList;
end;

function TFhirSpecimenDefinitionTypeTested.GetHasHandlingList : boolean;
begin
  result := (FHandlingList <> nil) and (FHandlingList.count > 0);
end;

{ TFhirSpecimenDefinitionTypeTestedListEnumerator }

constructor TFhirSpecimenDefinitionTypeTestedListEnumerator.Create(list : TFhirSpecimenDefinitionTypeTestedList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSpecimenDefinitionTypeTestedListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSpecimenDefinitionTypeTestedListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSpecimenDefinitionTypeTestedListEnumerator.GetCurrent : TFhirSpecimenDefinitionTypeTested;
begin
  Result := FList[FIndex];
end;

function TFhirSpecimenDefinitionTypeTestedListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSpecimenDefinitionTypeTestedList }

function TFhirSpecimenDefinitionTypeTestedList.AddItem(value: TFhirSpecimenDefinitionTypeTested): TFhirSpecimenDefinitionTypeTested;
begin
  assert(value.ClassName = 'TFhirSpecimenDefinitionTypeTested', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSpecimenDefinitionTypeTested');
  add(value);
  result := value;
end;

function TFhirSpecimenDefinitionTypeTestedList.Append: TFhirSpecimenDefinitionTypeTested;
begin
  result := TFhirSpecimenDefinitionTypeTested.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSpecimenDefinitionTypeTestedList.ClearItems;
begin
  Clear;
end;

function TFhirSpecimenDefinitionTypeTestedList.GetEnumerator : TFhirSpecimenDefinitionTypeTestedListEnumerator;
begin
  result := TFhirSpecimenDefinitionTypeTestedListEnumerator.Create(self.link);
end;

function TFhirSpecimenDefinitionTypeTestedList.Clone: TFhirSpecimenDefinitionTypeTestedList;
begin
  result := TFhirSpecimenDefinitionTypeTestedList(inherited Clone);
end;

function TFhirSpecimenDefinitionTypeTestedList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSpecimenDefinitionTypeTestedList.GetItemN(index: Integer): TFhirSpecimenDefinitionTypeTested;
begin
  result := TFhirSpecimenDefinitionTypeTested(ObjectByIndex[index]);
end;

function TFhirSpecimenDefinitionTypeTestedList.ItemClass: TFslObjectClass;
begin
  result := TFhirSpecimenDefinitionTypeTested;
end;
function TFhirSpecimenDefinitionTypeTestedList.IndexOf(value: TFhirSpecimenDefinitionTypeTested): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSpecimenDefinitionTypeTestedList.Insert(index: Integer): TFhirSpecimenDefinitionTypeTested;
begin
  result := TFhirSpecimenDefinitionTypeTested.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSpecimenDefinitionTypeTestedList.InsertItem(index: Integer; value: TFhirSpecimenDefinitionTypeTested);
begin
  assert(value is TFhirSpecimenDefinitionTypeTested);
  Inherited Insert(index, value);
end;

function TFhirSpecimenDefinitionTypeTestedList.Item(index: Integer): TFhirSpecimenDefinitionTypeTested;
begin
  result := TFhirSpecimenDefinitionTypeTested(ObjectByIndex[index]);
end;

function TFhirSpecimenDefinitionTypeTestedList.Link: TFhirSpecimenDefinitionTypeTestedList;
begin
  result := TFhirSpecimenDefinitionTypeTestedList(inherited Link);
end;

procedure TFhirSpecimenDefinitionTypeTestedList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSpecimenDefinitionTypeTestedList.SetItemByIndex(index: Integer; value: TFhirSpecimenDefinitionTypeTested);
begin
  assert(value is TFhirSpecimenDefinitionTypeTested);
  FhirSpecimenDefinitionTypeTesteds[index] := value;
end;

procedure TFhirSpecimenDefinitionTypeTestedList.SetItemN(index: Integer; value: TFhirSpecimenDefinitionTypeTested);
begin
  assert(value is TFhirSpecimenDefinitionTypeTested);
  ObjectByIndex[index] := value;
end;

{ TFhirSpecimenDefinitionTypeTestedContainer }

constructor TFhirSpecimenDefinitionTypeTestedContainer.Create;
begin
  inherited;
end;

destructor TFhirSpecimenDefinitionTypeTestedContainer.Destroy;
begin
  FMaterial.free;
  FType_.free;
  FCap.free;
  FDescription.free;
  FCapacity.free;
  FMinimumVolume.free;
  FAdditiveList.Free;
  FPreparation.free;
  inherited;
end;

procedure TFhirSpecimenDefinitionTypeTestedContainer.Assign(oSource : TFslObject);
begin
  inherited;
  material := TFhirSpecimenDefinitionTypeTestedContainer(oSource).material.Clone;
  type_ := TFhirSpecimenDefinitionTypeTestedContainer(oSource).type_.Clone;
  cap := TFhirSpecimenDefinitionTypeTestedContainer(oSource).cap.Clone;
  descriptionElement := TFhirSpecimenDefinitionTypeTestedContainer(oSource).descriptionElement.Clone;
  capacity := TFhirSpecimenDefinitionTypeTestedContainer(oSource).capacity.Clone;
  minimumVolume := TFhirSpecimenDefinitionTypeTestedContainer(oSource).minimumVolume.Clone;
  if (TFhirSpecimenDefinitionTypeTestedContainer(oSource).FAdditiveList = nil) then
  begin
    FAdditiveList.free;
    FAdditiveList := nil;
  end
  else
  begin
    if FAdditiveList = nil then
      FAdditiveList := TFhirSpecimenDefinitionTypeTestedContainerAdditiveList.Create;
    FAdditiveList.Assign(TFhirSpecimenDefinitionTypeTestedContainer(oSource).FAdditiveList);
  end;
  preparationElement := TFhirSpecimenDefinitionTypeTestedContainer(oSource).preparationElement.Clone;
end;

procedure TFhirSpecimenDefinitionTypeTestedContainer.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'material') Then
     list.add(self.link, 'material', FMaterial.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'cap') Then
     list.add(self.link, 'cap', FCap.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'capacity') Then
     list.add(self.link, 'capacity', FCapacity.Link);
  if (child_name = 'minimumVolume[x]') or (child_name = 'minimumVolume') Then
     list.add(self.link, 'minimumVolume[x]', FMinimumVolume.Link);
  if (child_name = 'additive') Then
    list.addAll(self, 'additive', FAdditiveList);
  if (child_name = 'preparation') Then
     list.add(self.link, 'preparation', FPreparation.Link);
end;

procedure TFhirSpecimenDefinitionTypeTestedContainer.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'material', 'CodeableConcept', false, TFhirCodeableConcept, FMaterial.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'cap', 'CodeableConcept', false, TFhirCodeableConcept, FCap.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'capacity', 'Quantity', false, TFhirQuantity, FCapacity.Link));
  oList.add(TFHIRProperty.create(self, 'minimumVolume[x]', 'Quantity|string', false, TFhirDataType, FMinimumVolume.Link));
  oList.add(TFHIRProperty.create(self, 'additive', 'BackboneElement', true, TFhirSpecimenDefinitionTypeTestedContainerAdditive, FAdditiveList.Link));
  oList.add(TFHIRProperty.create(self, 'preparation', 'string', false, TFhirString, FPreparation.Link));
end;

function TFhirSpecimenDefinitionTypeTestedContainer.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'material') then
  begin
    Material := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'cap') then
  begin
    Cap := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'capacity') then
  begin
    Capacity := propValue as TFhirQuantity;
    result := propValue;
  end
  else if (isMatchingName(propName, 'minimumVolume', ['Quantity', 'String'])) then
  begin
    MinimumVolume := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'additive') then
  begin
    AdditiveList.add(propValue as TFhirSpecimenDefinitionTypeTestedContainerAdditive);
    result := propValue;
  end
  else if (propName = 'preparation') then
  begin
    PreparationElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSpecimenDefinitionTypeTestedContainer.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'additive') then AdditiveList.insertItem(index, propValue as TFhirSpecimenDefinitionTypeTestedContainerAdditive)
  else inherited;
end;

function TFhirSpecimenDefinitionTypeTestedContainer.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'material') then result := TFhirCodeableConcept.create()
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'cap') then result := TFhirCodeableConcept.create()
  else if (propName = 'description') then result := TFhirString.create()
  else if (propName = 'capacity') then result := TFhirQuantity.create()
  else if (isMatchingName(propName, 'minimumVolume', ['Quantity', 'String'])) then raise EFHIRException.create('Cannot make property MinimumVolume')
  else if (propName = 'additive') then result := AdditiveList.new()
  else if (propName = 'preparation') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSpecimenDefinitionTypeTestedContainer.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'material') then result := 'CodeableConcept'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'cap') then result := 'CodeableConcept'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'capacity') then result := 'Quantity'
  else if (propName = 'minimumVolume[x]') then result := 'Quantity|string'
  else if (propName = 'additive') then result := 'BackboneElement'
  else if (propName = 'preparation') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSpecimenDefinitionTypeTestedContainer.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'material') then MaterialElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'cap') then CapElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'capacity') then CapacityElement := nil
  else if (isMatchingName(propName, 'minimumVolume', ['Quantity', 'String'])) then MinimumVolumeElement := nil
  else if (propName = 'additive') then deletePropertyValue('additive', AdditiveList, value)
  else if (propName = 'preparation') then PreparationElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSpecimenDefinitionTypeTestedContainer.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'material') then MaterialElement := new as TFhirCodeableConcept
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'cap') then CapElement := new as TFhirCodeableConcept
  else if (propName = 'description') then DescriptionElement := asString(new)
  else if (propName = 'capacity') then CapacityElement := new as TFhirQuantity
  else if (isMatchingName(propName, 'minimumVolume', ['Quantity', 'String'])) then MinimumVolumeElement := new as TFhirDataType
  else if (propName = 'additive') then replacePropertyValue('additive', AdditiveList, existing, new)
  else if (propName = 'preparation') then PreparationElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSpecimenDefinitionTypeTestedContainer.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'additive') then AdditiveList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSpecimenDefinitionTypeTestedContainer.fhirType : string;
begin
  result := 'SpecimenDefinition.typeTested.container';
end;

function TFhirSpecimenDefinitionTypeTestedContainer.Link : TFhirSpecimenDefinitionTypeTestedContainer;
begin
  result := TFhirSpecimenDefinitionTypeTestedContainer(inherited Link);
end;

function TFhirSpecimenDefinitionTypeTestedContainer.Clone : TFhirSpecimenDefinitionTypeTestedContainer;
begin
  result := TFhirSpecimenDefinitionTypeTestedContainer(inherited Clone);
end;

function TFhirSpecimenDefinitionTypeTestedContainer.equals(other : TObject) : boolean; 
var
  o : TFhirSpecimenDefinitionTypeTestedContainer;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSpecimenDefinitionTypeTestedContainer)) then
    result := false
  else
  begin
    o := TFhirSpecimenDefinitionTypeTestedContainer(other);
    result := compareDeep(materialElement, o.materialElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(capElement, o.capElement, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(capacityElement, o.capacityElement, true) and compareDeep(minimumVolumeElement, o.minimumVolumeElement, true) and 
      compareDeep(additiveList, o.additiveList, true) and compareDeep(preparationElement, o.preparationElement, true);
  end;
end;

function TFhirSpecimenDefinitionTypeTestedContainer.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FMaterial) and isEmptyProp(FType_) and isEmptyProp(FCap) and isEmptyProp(FDescription) and isEmptyProp(FCapacity) and isEmptyProp(FMinimumVolume) and isEmptyProp(FadditiveList) and isEmptyProp(FPreparation);
end;

procedure TFhirSpecimenDefinitionTypeTestedContainer.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('material');
  fields.add('type');
  fields.add('cap');
  fields.add('description');
  fields.add('capacity');
  fields.add('minimumVolume[x]');
  fields.add('additive');
  fields.add('preparation');
end;

function TFhirSpecimenDefinitionTypeTestedContainer.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FAdditiveList.sizeInBytes(magic));
end;

procedure TFhirSpecimenDefinitionTypeTestedContainer.SetMaterial(value : TFhirCodeableConcept);
begin
  FMaterial.free;
  FMaterial := value;
end;

procedure TFhirSpecimenDefinitionTypeTestedContainer.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirSpecimenDefinitionTypeTestedContainer.SetCap(value : TFhirCodeableConcept);
begin
  FCap.free;
  FCap := value;
end;

procedure TFhirSpecimenDefinitionTypeTestedContainer.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirSpecimenDefinitionTypeTestedContainer.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirSpecimenDefinitionTypeTestedContainer.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirSpecimenDefinitionTypeTestedContainer.SetCapacity(value : TFhirQuantity);
begin
  FCapacity.free;
  FCapacity := value;
end;

procedure TFhirSpecimenDefinitionTypeTestedContainer.SetMinimumVolume(value : TFhirDataType);
begin
  FMinimumVolume.free;
  FMinimumVolume := value;
end;

function TFhirSpecimenDefinitionTypeTestedContainer.GetAdditiveList : TFhirSpecimenDefinitionTypeTestedContainerAdditiveList;
begin
  if FAdditiveList = nil then
    FAdditiveList := TFhirSpecimenDefinitionTypeTestedContainerAdditiveList.Create;
  result := FAdditiveList;
end;

function TFhirSpecimenDefinitionTypeTestedContainer.GetHasAdditiveList : boolean;
begin
  result := (FAdditiveList <> nil) and (FAdditiveList.count > 0);
end;

procedure TFhirSpecimenDefinitionTypeTestedContainer.SetPreparation(value : TFhirString);
begin
  FPreparation.free;
  FPreparation := value;
end;

function TFhirSpecimenDefinitionTypeTestedContainer.GetPreparationST : String;
begin
  if FPreparation = nil then
    result := ''
  else
    result := FPreparation.value;
end;

procedure TFhirSpecimenDefinitionTypeTestedContainer.SetPreparationST(value : String);
begin
  if value <> '' then
  begin
    if FPreparation = nil then
      FPreparation := TFhirString.create;
    FPreparation.value := value
  end
  else if FPreparation <> nil then
    FPreparation.value := '';
end;

{ TFhirSpecimenDefinitionTypeTestedContainerListEnumerator }

constructor TFhirSpecimenDefinitionTypeTestedContainerListEnumerator.Create(list : TFhirSpecimenDefinitionTypeTestedContainerList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSpecimenDefinitionTypeTestedContainerListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSpecimenDefinitionTypeTestedContainerListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSpecimenDefinitionTypeTestedContainerListEnumerator.GetCurrent : TFhirSpecimenDefinitionTypeTestedContainer;
begin
  Result := FList[FIndex];
end;

function TFhirSpecimenDefinitionTypeTestedContainerListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSpecimenDefinitionTypeTestedContainerList }

function TFhirSpecimenDefinitionTypeTestedContainerList.AddItem(value: TFhirSpecimenDefinitionTypeTestedContainer): TFhirSpecimenDefinitionTypeTestedContainer;
begin
  assert(value.ClassName = 'TFhirSpecimenDefinitionTypeTestedContainer', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSpecimenDefinitionTypeTestedContainer');
  add(value);
  result := value;
end;

function TFhirSpecimenDefinitionTypeTestedContainerList.Append: TFhirSpecimenDefinitionTypeTestedContainer;
begin
  result := TFhirSpecimenDefinitionTypeTestedContainer.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSpecimenDefinitionTypeTestedContainerList.ClearItems;
begin
  Clear;
end;

function TFhirSpecimenDefinitionTypeTestedContainerList.GetEnumerator : TFhirSpecimenDefinitionTypeTestedContainerListEnumerator;
begin
  result := TFhirSpecimenDefinitionTypeTestedContainerListEnumerator.Create(self.link);
end;

function TFhirSpecimenDefinitionTypeTestedContainerList.Clone: TFhirSpecimenDefinitionTypeTestedContainerList;
begin
  result := TFhirSpecimenDefinitionTypeTestedContainerList(inherited Clone);
end;

function TFhirSpecimenDefinitionTypeTestedContainerList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSpecimenDefinitionTypeTestedContainerList.GetItemN(index: Integer): TFhirSpecimenDefinitionTypeTestedContainer;
begin
  result := TFhirSpecimenDefinitionTypeTestedContainer(ObjectByIndex[index]);
end;

function TFhirSpecimenDefinitionTypeTestedContainerList.ItemClass: TFslObjectClass;
begin
  result := TFhirSpecimenDefinitionTypeTestedContainer;
end;
function TFhirSpecimenDefinitionTypeTestedContainerList.IndexOf(value: TFhirSpecimenDefinitionTypeTestedContainer): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSpecimenDefinitionTypeTestedContainerList.Insert(index: Integer): TFhirSpecimenDefinitionTypeTestedContainer;
begin
  result := TFhirSpecimenDefinitionTypeTestedContainer.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSpecimenDefinitionTypeTestedContainerList.InsertItem(index: Integer; value: TFhirSpecimenDefinitionTypeTestedContainer);
begin
  assert(value is TFhirSpecimenDefinitionTypeTestedContainer);
  Inherited Insert(index, value);
end;

function TFhirSpecimenDefinitionTypeTestedContainerList.Item(index: Integer): TFhirSpecimenDefinitionTypeTestedContainer;
begin
  result := TFhirSpecimenDefinitionTypeTestedContainer(ObjectByIndex[index]);
end;

function TFhirSpecimenDefinitionTypeTestedContainerList.Link: TFhirSpecimenDefinitionTypeTestedContainerList;
begin
  result := TFhirSpecimenDefinitionTypeTestedContainerList(inherited Link);
end;

procedure TFhirSpecimenDefinitionTypeTestedContainerList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSpecimenDefinitionTypeTestedContainerList.SetItemByIndex(index: Integer; value: TFhirSpecimenDefinitionTypeTestedContainer);
begin
  assert(value is TFhirSpecimenDefinitionTypeTestedContainer);
  FhirSpecimenDefinitionTypeTestedContainers[index] := value;
end;

procedure TFhirSpecimenDefinitionTypeTestedContainerList.SetItemN(index: Integer; value: TFhirSpecimenDefinitionTypeTestedContainer);
begin
  assert(value is TFhirSpecimenDefinitionTypeTestedContainer);
  ObjectByIndex[index] := value;
end;

{ TFhirSpecimenDefinitionTypeTestedContainerAdditive }

constructor TFhirSpecimenDefinitionTypeTestedContainerAdditive.Create;
begin
  inherited;
end;

destructor TFhirSpecimenDefinitionTypeTestedContainerAdditive.Destroy;
begin
  FAdditive.free;
  inherited;
end;

procedure TFhirSpecimenDefinitionTypeTestedContainerAdditive.Assign(oSource : TFslObject);
begin
  inherited;
  additive := TFhirSpecimenDefinitionTypeTestedContainerAdditive(oSource).additive.Clone;
end;

procedure TFhirSpecimenDefinitionTypeTestedContainerAdditive.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'additive[x]') or (child_name = 'additive') Then
     list.add(self.link, 'additive[x]', FAdditive.Link);
end;

procedure TFhirSpecimenDefinitionTypeTestedContainerAdditive.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'additive[x]', 'CodeableConcept|Reference', false, TFhirDataType, FAdditive.Link));
end;

function TFhirSpecimenDefinitionTypeTestedContainerAdditive.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'additive', ['CodeableConcept', 'Reference'])) then
  begin
    Additive := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSpecimenDefinitionTypeTestedContainerAdditive.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSpecimenDefinitionTypeTestedContainerAdditive.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'additive', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Additive')
  else result := inherited createPropertyValue(propName);
end;

function TFhirSpecimenDefinitionTypeTestedContainerAdditive.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'additive[x]') then result := 'CodeableConcept|Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSpecimenDefinitionTypeTestedContainerAdditive.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'additive', ['CodeableConcept', 'Reference'])) then AdditiveElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSpecimenDefinitionTypeTestedContainerAdditive.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'additive', ['CodeableConcept', 'Reference'])) then AdditiveElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSpecimenDefinitionTypeTestedContainerAdditive.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSpecimenDefinitionTypeTestedContainerAdditive.fhirType : string;
begin
  result := 'SpecimenDefinition.typeTested.container.additive';
end;

function TFhirSpecimenDefinitionTypeTestedContainerAdditive.Link : TFhirSpecimenDefinitionTypeTestedContainerAdditive;
begin
  result := TFhirSpecimenDefinitionTypeTestedContainerAdditive(inherited Link);
end;

function TFhirSpecimenDefinitionTypeTestedContainerAdditive.Clone : TFhirSpecimenDefinitionTypeTestedContainerAdditive;
begin
  result := TFhirSpecimenDefinitionTypeTestedContainerAdditive(inherited Clone);
end;

function TFhirSpecimenDefinitionTypeTestedContainerAdditive.equals(other : TObject) : boolean; 
var
  o : TFhirSpecimenDefinitionTypeTestedContainerAdditive;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSpecimenDefinitionTypeTestedContainerAdditive)) then
    result := false
  else
  begin
    o := TFhirSpecimenDefinitionTypeTestedContainerAdditive(other);
    result := compareDeep(additiveElement, o.additiveElement, true);
  end;
end;

function TFhirSpecimenDefinitionTypeTestedContainerAdditive.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FAdditive);
end;

procedure TFhirSpecimenDefinitionTypeTestedContainerAdditive.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('additive[x]');
end;

function TFhirSpecimenDefinitionTypeTestedContainerAdditive.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirSpecimenDefinitionTypeTestedContainerAdditive.SetAdditive(value : TFhirDataType);
begin
  FAdditive.free;
  FAdditive := value;
end;

{ TFhirSpecimenDefinitionTypeTestedContainerAdditiveListEnumerator }

constructor TFhirSpecimenDefinitionTypeTestedContainerAdditiveListEnumerator.Create(list : TFhirSpecimenDefinitionTypeTestedContainerAdditiveList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSpecimenDefinitionTypeTestedContainerAdditiveListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSpecimenDefinitionTypeTestedContainerAdditiveListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSpecimenDefinitionTypeTestedContainerAdditiveListEnumerator.GetCurrent : TFhirSpecimenDefinitionTypeTestedContainerAdditive;
begin
  Result := FList[FIndex];
end;

function TFhirSpecimenDefinitionTypeTestedContainerAdditiveListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSpecimenDefinitionTypeTestedContainerAdditiveList }

function TFhirSpecimenDefinitionTypeTestedContainerAdditiveList.AddItem(value: TFhirSpecimenDefinitionTypeTestedContainerAdditive): TFhirSpecimenDefinitionTypeTestedContainerAdditive;
begin
  assert(value.ClassName = 'TFhirSpecimenDefinitionTypeTestedContainerAdditive', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSpecimenDefinitionTypeTestedContainerAdditive');
  add(value);
  result := value;
end;

function TFhirSpecimenDefinitionTypeTestedContainerAdditiveList.Append: TFhirSpecimenDefinitionTypeTestedContainerAdditive;
begin
  result := TFhirSpecimenDefinitionTypeTestedContainerAdditive.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSpecimenDefinitionTypeTestedContainerAdditiveList.ClearItems;
begin
  Clear;
end;

function TFhirSpecimenDefinitionTypeTestedContainerAdditiveList.GetEnumerator : TFhirSpecimenDefinitionTypeTestedContainerAdditiveListEnumerator;
begin
  result := TFhirSpecimenDefinitionTypeTestedContainerAdditiveListEnumerator.Create(self.link);
end;

function TFhirSpecimenDefinitionTypeTestedContainerAdditiveList.Clone: TFhirSpecimenDefinitionTypeTestedContainerAdditiveList;
begin
  result := TFhirSpecimenDefinitionTypeTestedContainerAdditiveList(inherited Clone);
end;

function TFhirSpecimenDefinitionTypeTestedContainerAdditiveList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSpecimenDefinitionTypeTestedContainerAdditiveList.GetItemN(index: Integer): TFhirSpecimenDefinitionTypeTestedContainerAdditive;
begin
  result := TFhirSpecimenDefinitionTypeTestedContainerAdditive(ObjectByIndex[index]);
end;

function TFhirSpecimenDefinitionTypeTestedContainerAdditiveList.ItemClass: TFslObjectClass;
begin
  result := TFhirSpecimenDefinitionTypeTestedContainerAdditive;
end;
function TFhirSpecimenDefinitionTypeTestedContainerAdditiveList.IndexOf(value: TFhirSpecimenDefinitionTypeTestedContainerAdditive): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSpecimenDefinitionTypeTestedContainerAdditiveList.Insert(index: Integer): TFhirSpecimenDefinitionTypeTestedContainerAdditive;
begin
  result := TFhirSpecimenDefinitionTypeTestedContainerAdditive.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSpecimenDefinitionTypeTestedContainerAdditiveList.InsertItem(index: Integer; value: TFhirSpecimenDefinitionTypeTestedContainerAdditive);
begin
  assert(value is TFhirSpecimenDefinitionTypeTestedContainerAdditive);
  Inherited Insert(index, value);
end;

function TFhirSpecimenDefinitionTypeTestedContainerAdditiveList.Item(index: Integer): TFhirSpecimenDefinitionTypeTestedContainerAdditive;
begin
  result := TFhirSpecimenDefinitionTypeTestedContainerAdditive(ObjectByIndex[index]);
end;

function TFhirSpecimenDefinitionTypeTestedContainerAdditiveList.Link: TFhirSpecimenDefinitionTypeTestedContainerAdditiveList;
begin
  result := TFhirSpecimenDefinitionTypeTestedContainerAdditiveList(inherited Link);
end;

procedure TFhirSpecimenDefinitionTypeTestedContainerAdditiveList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSpecimenDefinitionTypeTestedContainerAdditiveList.SetItemByIndex(index: Integer; value: TFhirSpecimenDefinitionTypeTestedContainerAdditive);
begin
  assert(value is TFhirSpecimenDefinitionTypeTestedContainerAdditive);
  FhirSpecimenDefinitionTypeTestedContainerAdditives[index] := value;
end;

procedure TFhirSpecimenDefinitionTypeTestedContainerAdditiveList.SetItemN(index: Integer; value: TFhirSpecimenDefinitionTypeTestedContainerAdditive);
begin
  assert(value is TFhirSpecimenDefinitionTypeTestedContainerAdditive);
  ObjectByIndex[index] := value;
end;

{ TFhirSpecimenDefinitionTypeTestedHandling }

constructor TFhirSpecimenDefinitionTypeTestedHandling.Create;
begin
  inherited;
end;

destructor TFhirSpecimenDefinitionTypeTestedHandling.Destroy;
begin
  FTemperatureQualifier.free;
  FTemperatureRange.free;
  FMaxDuration.free;
  FInstruction.free;
  inherited;
end;

procedure TFhirSpecimenDefinitionTypeTestedHandling.Assign(oSource : TFslObject);
begin
  inherited;
  temperatureQualifier := TFhirSpecimenDefinitionTypeTestedHandling(oSource).temperatureQualifier.Clone;
  temperatureRange := TFhirSpecimenDefinitionTypeTestedHandling(oSource).temperatureRange.Clone;
  maxDuration := TFhirSpecimenDefinitionTypeTestedHandling(oSource).maxDuration.Clone;
  instructionElement := TFhirSpecimenDefinitionTypeTestedHandling(oSource).instructionElement.Clone;
end;

procedure TFhirSpecimenDefinitionTypeTestedHandling.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'temperatureQualifier') Then
     list.add(self.link, 'temperatureQualifier', FTemperatureQualifier.Link);
  if (child_name = 'temperatureRange') Then
     list.add(self.link, 'temperatureRange', FTemperatureRange.Link);
  if (child_name = 'maxDuration') Then
     list.add(self.link, 'maxDuration', FMaxDuration.Link);
  if (child_name = 'instruction') Then
     list.add(self.link, 'instruction', FInstruction.Link);
end;

procedure TFhirSpecimenDefinitionTypeTestedHandling.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'temperatureQualifier', 'CodeableConcept', false, TFhirCodeableConcept, FTemperatureQualifier.Link));
  oList.add(TFHIRProperty.create(self, 'temperatureRange', 'Range', false, TFhirRange, FTemperatureRange.Link));
  oList.add(TFHIRProperty.create(self, 'maxDuration', 'Duration', false, TFhirDuration, FMaxDuration.Link));
  oList.add(TFHIRProperty.create(self, 'instruction', 'string', false, TFhirString, FInstruction.Link));
end;

function TFhirSpecimenDefinitionTypeTestedHandling.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'temperatureQualifier') then
  begin
    TemperatureQualifier := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'temperatureRange') then
  begin
    TemperatureRange := propValue as TFhirRange;
    result := propValue;
  end
  else if (propName = 'maxDuration') then
  begin
    MaxDuration := propValue as TFhirDuration;
    result := propValue;
  end
  else if (propName = 'instruction') then
  begin
    InstructionElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSpecimenDefinitionTypeTestedHandling.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSpecimenDefinitionTypeTestedHandling.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'temperatureQualifier') then result := TFhirCodeableConcept.create()
  else if (propName = 'temperatureRange') then result := TFhirRange.create()
  else if (propName = 'maxDuration') then result := TFhirDuration.create()
  else if (propName = 'instruction') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSpecimenDefinitionTypeTestedHandling.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'temperatureQualifier') then result := 'CodeableConcept'
  else if (propName = 'temperatureRange') then result := 'Range'
  else if (propName = 'maxDuration') then result := 'Duration'
  else if (propName = 'instruction') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSpecimenDefinitionTypeTestedHandling.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'temperatureQualifier') then TemperatureQualifierElement := nil
  else if (propName = 'temperatureRange') then TemperatureRangeElement := nil
  else if (propName = 'maxDuration') then MaxDurationElement := nil
  else if (propName = 'instruction') then InstructionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSpecimenDefinitionTypeTestedHandling.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'temperatureQualifier') then TemperatureQualifierElement := new as TFhirCodeableConcept
  else if (propName = 'temperatureRange') then TemperatureRangeElement := new as TFhirRange
  else if (propName = 'maxDuration') then MaxDurationElement := new as TFhirDuration
  else if (propName = 'instruction') then InstructionElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSpecimenDefinitionTypeTestedHandling.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSpecimenDefinitionTypeTestedHandling.fhirType : string;
begin
  result := 'SpecimenDefinition.typeTested.handling';
end;

function TFhirSpecimenDefinitionTypeTestedHandling.Link : TFhirSpecimenDefinitionTypeTestedHandling;
begin
  result := TFhirSpecimenDefinitionTypeTestedHandling(inherited Link);
end;

function TFhirSpecimenDefinitionTypeTestedHandling.Clone : TFhirSpecimenDefinitionTypeTestedHandling;
begin
  result := TFhirSpecimenDefinitionTypeTestedHandling(inherited Clone);
end;

function TFhirSpecimenDefinitionTypeTestedHandling.equals(other : TObject) : boolean; 
var
  o : TFhirSpecimenDefinitionTypeTestedHandling;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSpecimenDefinitionTypeTestedHandling)) then
    result := false
  else
  begin
    o := TFhirSpecimenDefinitionTypeTestedHandling(other);
    result := compareDeep(temperatureQualifierElement, o.temperatureQualifierElement, true) and 
      compareDeep(temperatureRangeElement, o.temperatureRangeElement, true) and compareDeep(maxDurationElement, o.maxDurationElement, true) and 
      compareDeep(instructionElement, o.instructionElement, true);
  end;
end;

function TFhirSpecimenDefinitionTypeTestedHandling.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FTemperatureQualifier) and isEmptyProp(FTemperatureRange) and isEmptyProp(FMaxDuration) and isEmptyProp(FInstruction);
end;

procedure TFhirSpecimenDefinitionTypeTestedHandling.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('temperatureQualifier');
  fields.add('temperatureRange');
  fields.add('maxDuration');
  fields.add('instruction');
end;

function TFhirSpecimenDefinitionTypeTestedHandling.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirSpecimenDefinitionTypeTestedHandling.SetTemperatureQualifier(value : TFhirCodeableConcept);
begin
  FTemperatureQualifier.free;
  FTemperatureQualifier := value;
end;

procedure TFhirSpecimenDefinitionTypeTestedHandling.SetTemperatureRange(value : TFhirRange);
begin
  FTemperatureRange.free;
  FTemperatureRange := value;
end;

procedure TFhirSpecimenDefinitionTypeTestedHandling.SetMaxDuration(value : TFhirDuration);
begin
  FMaxDuration.free;
  FMaxDuration := value;
end;

procedure TFhirSpecimenDefinitionTypeTestedHandling.SetInstruction(value : TFhirString);
begin
  FInstruction.free;
  FInstruction := value;
end;

function TFhirSpecimenDefinitionTypeTestedHandling.GetInstructionST : String;
begin
  if FInstruction = nil then
    result := ''
  else
    result := FInstruction.value;
end;

procedure TFhirSpecimenDefinitionTypeTestedHandling.SetInstructionST(value : String);
begin
  if value <> '' then
  begin
    if FInstruction = nil then
      FInstruction := TFhirString.create;
    FInstruction.value := value
  end
  else if FInstruction <> nil then
    FInstruction.value := '';
end;

{ TFhirSpecimenDefinitionTypeTestedHandlingListEnumerator }

constructor TFhirSpecimenDefinitionTypeTestedHandlingListEnumerator.Create(list : TFhirSpecimenDefinitionTypeTestedHandlingList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSpecimenDefinitionTypeTestedHandlingListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSpecimenDefinitionTypeTestedHandlingListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSpecimenDefinitionTypeTestedHandlingListEnumerator.GetCurrent : TFhirSpecimenDefinitionTypeTestedHandling;
begin
  Result := FList[FIndex];
end;

function TFhirSpecimenDefinitionTypeTestedHandlingListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSpecimenDefinitionTypeTestedHandlingList }

function TFhirSpecimenDefinitionTypeTestedHandlingList.AddItem(value: TFhirSpecimenDefinitionTypeTestedHandling): TFhirSpecimenDefinitionTypeTestedHandling;
begin
  assert(value.ClassName = 'TFhirSpecimenDefinitionTypeTestedHandling', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSpecimenDefinitionTypeTestedHandling');
  add(value);
  result := value;
end;

function TFhirSpecimenDefinitionTypeTestedHandlingList.Append: TFhirSpecimenDefinitionTypeTestedHandling;
begin
  result := TFhirSpecimenDefinitionTypeTestedHandling.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSpecimenDefinitionTypeTestedHandlingList.ClearItems;
begin
  Clear;
end;

function TFhirSpecimenDefinitionTypeTestedHandlingList.GetEnumerator : TFhirSpecimenDefinitionTypeTestedHandlingListEnumerator;
begin
  result := TFhirSpecimenDefinitionTypeTestedHandlingListEnumerator.Create(self.link);
end;

function TFhirSpecimenDefinitionTypeTestedHandlingList.Clone: TFhirSpecimenDefinitionTypeTestedHandlingList;
begin
  result := TFhirSpecimenDefinitionTypeTestedHandlingList(inherited Clone);
end;

function TFhirSpecimenDefinitionTypeTestedHandlingList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSpecimenDefinitionTypeTestedHandlingList.GetItemN(index: Integer): TFhirSpecimenDefinitionTypeTestedHandling;
begin
  result := TFhirSpecimenDefinitionTypeTestedHandling(ObjectByIndex[index]);
end;

function TFhirSpecimenDefinitionTypeTestedHandlingList.ItemClass: TFslObjectClass;
begin
  result := TFhirSpecimenDefinitionTypeTestedHandling;
end;
function TFhirSpecimenDefinitionTypeTestedHandlingList.IndexOf(value: TFhirSpecimenDefinitionTypeTestedHandling): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSpecimenDefinitionTypeTestedHandlingList.Insert(index: Integer): TFhirSpecimenDefinitionTypeTestedHandling;
begin
  result := TFhirSpecimenDefinitionTypeTestedHandling.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSpecimenDefinitionTypeTestedHandlingList.InsertItem(index: Integer; value: TFhirSpecimenDefinitionTypeTestedHandling);
begin
  assert(value is TFhirSpecimenDefinitionTypeTestedHandling);
  Inherited Insert(index, value);
end;

function TFhirSpecimenDefinitionTypeTestedHandlingList.Item(index: Integer): TFhirSpecimenDefinitionTypeTestedHandling;
begin
  result := TFhirSpecimenDefinitionTypeTestedHandling(ObjectByIndex[index]);
end;

function TFhirSpecimenDefinitionTypeTestedHandlingList.Link: TFhirSpecimenDefinitionTypeTestedHandlingList;
begin
  result := TFhirSpecimenDefinitionTypeTestedHandlingList(inherited Link);
end;

procedure TFhirSpecimenDefinitionTypeTestedHandlingList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSpecimenDefinitionTypeTestedHandlingList.SetItemByIndex(index: Integer; value: TFhirSpecimenDefinitionTypeTestedHandling);
begin
  assert(value is TFhirSpecimenDefinitionTypeTestedHandling);
  FhirSpecimenDefinitionTypeTestedHandlings[index] := value;
end;

procedure TFhirSpecimenDefinitionTypeTestedHandlingList.SetItemN(index: Integer; value: TFhirSpecimenDefinitionTypeTestedHandling);
begin
  assert(value is TFhirSpecimenDefinitionTypeTestedHandling);
  ObjectByIndex[index] := value;
end;

{ TFhirSpecimenDefinition }

constructor TFhirSpecimenDefinition.Create;
begin
  inherited;
end;

destructor TFhirSpecimenDefinition.Destroy;
begin
  FIdentifier.free;
  FTypeCollected.free;
  FPatientPreparationList.Free;
  FTimeAspect.free;
  FCollectionList.Free;
  FTypeTestedList.Free;
  inherited;
end;

procedure TFhirSpecimenDefinition.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirSpecimenDefinition(oSource).identifier.Clone;
  typeCollected := TFhirSpecimenDefinition(oSource).typeCollected.Clone;
  if (TFhirSpecimenDefinition(oSource).FPatientPreparationList = nil) then
  begin
    FPatientPreparationList.free;
    FPatientPreparationList := nil;
  end
  else
  begin
    if FPatientPreparationList = nil then
      FPatientPreparationList := TFhirCodeableConceptList.Create;
    FPatientPreparationList.Assign(TFhirSpecimenDefinition(oSource).FPatientPreparationList);
  end;
  timeAspectElement := TFhirSpecimenDefinition(oSource).timeAspectElement.Clone;
  if (TFhirSpecimenDefinition(oSource).FCollectionList = nil) then
  begin
    FCollectionList.free;
    FCollectionList := nil;
  end
  else
  begin
    if FCollectionList = nil then
      FCollectionList := TFhirCodeableConceptList.Create;
    FCollectionList.Assign(TFhirSpecimenDefinition(oSource).FCollectionList);
  end;
  if (TFhirSpecimenDefinition(oSource).FTypeTestedList = nil) then
  begin
    FTypeTestedList.free;
    FTypeTestedList := nil;
  end
  else
  begin
    if FTypeTestedList = nil then
      FTypeTestedList := TFhirSpecimenDefinitionTypeTestedList.Create;
    FTypeTestedList.Assign(TFhirSpecimenDefinition(oSource).FTypeTestedList);
  end;
end;

function TFhirSpecimenDefinition.GetResourceType : TFhirResourceType;
begin
  result := frtSpecimenDefinition;
end;

procedure TFhirSpecimenDefinition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'typeCollected') Then
     list.add(self.link, 'typeCollected', FTypeCollected.Link);
  if (child_name = 'patientPreparation') Then
    list.addAll(self, 'patientPreparation', FPatientPreparationList);
  if (child_name = 'timeAspect') Then
     list.add(self.link, 'timeAspect', FTimeAspect.Link);
  if (child_name = 'collection') Then
    list.addAll(self, 'collection', FCollectionList);
  if (child_name = 'typeTested') Then
    list.addAll(self, 'typeTested', FTypeTestedList);
end;

procedure TFhirSpecimenDefinition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));
  oList.add(TFHIRProperty.create(self, 'typeCollected', 'CodeableConcept', false, TFhirCodeableConcept, FTypeCollected.Link));
  oList.add(TFHIRProperty.create(self, 'patientPreparation', 'CodeableConcept', true, TFhirCodeableConcept, FPatientPreparationList.Link));
  oList.add(TFHIRProperty.create(self, 'timeAspect', 'string', false, TFhirString, FTimeAspect.Link));
  oList.add(TFHIRProperty.create(self, 'collection', 'CodeableConcept', true, TFhirCodeableConcept, FCollectionList.Link));
  oList.add(TFHIRProperty.create(self, 'typeTested', 'BackboneElement', true, TFhirSpecimenDefinitionTypeTested, FTypeTestedList.Link));
end;

function TFhirSpecimenDefinition.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier;
    result := propValue;
  end
  else if (propName = 'typeCollected') then
  begin
    TypeCollected := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'patientPreparation') then
  begin
    PatientPreparationList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'timeAspect') then
  begin
    TimeAspectElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'collection') then
  begin
    CollectionList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'typeTested') then
  begin
    TypeTestedList.add(propValue as TFhirSpecimenDefinitionTypeTested);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSpecimenDefinition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'patientPreparation') then PatientPreparationList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'collection') then CollectionList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'typeTested') then TypeTestedList.insertItem(index, propValue as TFhirSpecimenDefinitionTypeTested)
  else inherited;
end;

function TFhirSpecimenDefinition.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create()
  else if (propName = 'typeCollected') then result := TFhirCodeableConcept.create()
  else if (propName = 'patientPreparation') then result := PatientPreparationList.new()
  else if (propName = 'timeAspect') then result := TFhirString.create()
  else if (propName = 'collection') then result := CollectionList.new()
  else if (propName = 'typeTested') then result := TypeTestedList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSpecimenDefinition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'typeCollected') then result := 'CodeableConcept'
  else if (propName = 'patientPreparation') then result := 'CodeableConcept'
  else if (propName = 'timeAspect') then result := 'string'
  else if (propName = 'collection') then result := 'CodeableConcept'
  else if (propName = 'typeTested') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSpecimenDefinition.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'typeCollected') then TypeCollectedElement := nil
  else if (propName = 'patientPreparation') then deletePropertyValue('patientPreparation', PatientPreparationList, value)
  else if (propName = 'timeAspect') then TimeAspectElement := nil
  else if (propName = 'collection') then deletePropertyValue('collection', CollectionList, value)
  else if (propName = 'typeTested') then deletePropertyValue('typeTested', TypeTestedList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSpecimenDefinition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier
  else if (propName = 'typeCollected') then TypeCollectedElement := new as TFhirCodeableConcept
  else if (propName = 'patientPreparation') then replacePropertyValue('patientPreparation', PatientPreparationList, existing, new)
  else if (propName = 'timeAspect') then TimeAspectElement := asString(new)
  else if (propName = 'collection') then replacePropertyValue('collection', CollectionList, existing, new)
  else if (propName = 'typeTested') then replacePropertyValue('typeTested', TypeTestedList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSpecimenDefinition.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'patientPreparation') then PatientPreparationList.move(source, destination)
  else if (propName = 'collection') then CollectionList.move(source, destination)
  else if (propName = 'typeTested') then TypeTestedList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSpecimenDefinition.fhirType : string;
begin
  result := 'SpecimenDefinition';
end;

function TFhirSpecimenDefinition.Link : TFhirSpecimenDefinition;
begin
  result := TFhirSpecimenDefinition(inherited Link);
end;

function TFhirSpecimenDefinition.Clone : TFhirSpecimenDefinition;
begin
  result := TFhirSpecimenDefinition(inherited Clone);
end;

function TFhirSpecimenDefinition.equals(other : TObject) : boolean; 
var
  o : TFhirSpecimenDefinition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSpecimenDefinition)) then
    result := false
  else
  begin
    o := TFhirSpecimenDefinition(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(typeCollectedElement, o.typeCollectedElement, true) and 
      compareDeep(patientPreparationList, o.patientPreparationList, true) and compareDeep(timeAspectElement, o.timeAspectElement, true) and 
      compareDeep(collectionList, o.collectionList, true) and compareDeep(typeTestedList, o.typeTestedList, true);
  end;
end;

function TFhirSpecimenDefinition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FTypeCollected) and isEmptyProp(FpatientPreparationList) and isEmptyProp(FTimeAspect) and isEmptyProp(FcollectionList) and isEmptyProp(FtypeTestedList);
end;

procedure TFhirSpecimenDefinition.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('typeCollected');
  fields.add('patientPreparation');
  fields.add('timeAspect');
  fields.add('collection');
  fields.add('typeTested');
end;

function TFhirSpecimenDefinition.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FPatientPreparationList.sizeInBytes(magic));
  inc(result, FCollectionList.sizeInBytes(magic));
  inc(result, FTypeTestedList.sizeInBytes(magic));
end;

procedure TFhirSpecimenDefinition.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

procedure TFhirSpecimenDefinition.SetTypeCollected(value : TFhirCodeableConcept);
begin
  FTypeCollected.free;
  FTypeCollected := value;
end;

function TFhirSpecimenDefinition.GetPatientPreparationList : TFhirCodeableConceptList;
begin
  if FPatientPreparationList = nil then
    FPatientPreparationList := TFhirCodeableConceptList.Create;
  result := FPatientPreparationList;
end;

function TFhirSpecimenDefinition.GetHasPatientPreparationList : boolean;
begin
  result := (FPatientPreparationList <> nil) and (FPatientPreparationList.count > 0);
end;

procedure TFhirSpecimenDefinition.SetTimeAspect(value : TFhirString);
begin
  FTimeAspect.free;
  FTimeAspect := value;
end;

function TFhirSpecimenDefinition.GetTimeAspectST : String;
begin
  if FTimeAspect = nil then
    result := ''
  else
    result := FTimeAspect.value;
end;

procedure TFhirSpecimenDefinition.SetTimeAspectST(value : String);
begin
  if value <> '' then
  begin
    if FTimeAspect = nil then
      FTimeAspect := TFhirString.create;
    FTimeAspect.value := value
  end
  else if FTimeAspect <> nil then
    FTimeAspect.value := '';
end;

function TFhirSpecimenDefinition.GetCollectionList : TFhirCodeableConceptList;
begin
  if FCollectionList = nil then
    FCollectionList := TFhirCodeableConceptList.Create;
  result := FCollectionList;
end;

function TFhirSpecimenDefinition.GetHasCollectionList : boolean;
begin
  result := (FCollectionList <> nil) and (FCollectionList.count > 0);
end;

function TFhirSpecimenDefinition.GetTypeTestedList : TFhirSpecimenDefinitionTypeTestedList;
begin
  if FTypeTestedList = nil then
    FTypeTestedList := TFhirSpecimenDefinitionTypeTestedList.Create;
  result := FTypeTestedList;
end;

function TFhirSpecimenDefinition.GetHasTypeTestedList : boolean;
begin
  result := (FTypeTestedList <> nil) and (FTypeTestedList.count > 0);
end;

{ TFhirSpecimenDefinitionListEnumerator }

constructor TFhirSpecimenDefinitionListEnumerator.Create(list : TFhirSpecimenDefinitionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSpecimenDefinitionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSpecimenDefinitionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSpecimenDefinitionListEnumerator.GetCurrent : TFhirSpecimenDefinition;
begin
  Result := FList[FIndex];
end;

function TFhirSpecimenDefinitionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSpecimenDefinitionList }

function TFhirSpecimenDefinitionList.AddItem(value: TFhirSpecimenDefinition): TFhirSpecimenDefinition;
begin
  assert(value.ClassName = 'TFhirSpecimenDefinition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSpecimenDefinition');
  add(value);
  result := value;
end;

function TFhirSpecimenDefinitionList.Append: TFhirSpecimenDefinition;
begin
  result := TFhirSpecimenDefinition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSpecimenDefinitionList.ClearItems;
begin
  Clear;
end;

function TFhirSpecimenDefinitionList.GetEnumerator : TFhirSpecimenDefinitionListEnumerator;
begin
  result := TFhirSpecimenDefinitionListEnumerator.Create(self.link);
end;

function TFhirSpecimenDefinitionList.Clone: TFhirSpecimenDefinitionList;
begin
  result := TFhirSpecimenDefinitionList(inherited Clone);
end;

function TFhirSpecimenDefinitionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSpecimenDefinitionList.GetItemN(index: Integer): TFhirSpecimenDefinition;
begin
  result := TFhirSpecimenDefinition(ObjectByIndex[index]);
end;

function TFhirSpecimenDefinitionList.ItemClass: TFslObjectClass;
begin
  result := TFhirSpecimenDefinition;
end;
function TFhirSpecimenDefinitionList.IndexOf(value: TFhirSpecimenDefinition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSpecimenDefinitionList.Insert(index: Integer): TFhirSpecimenDefinition;
begin
  result := TFhirSpecimenDefinition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSpecimenDefinitionList.InsertItem(index: Integer; value: TFhirSpecimenDefinition);
begin
  assert(value is TFhirSpecimenDefinition);
  Inherited Insert(index, value);
end;

function TFhirSpecimenDefinitionList.Item(index: Integer): TFhirSpecimenDefinition;
begin
  result := TFhirSpecimenDefinition(ObjectByIndex[index]);
end;

function TFhirSpecimenDefinitionList.Link: TFhirSpecimenDefinitionList;
begin
  result := TFhirSpecimenDefinitionList(inherited Link);
end;

procedure TFhirSpecimenDefinitionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSpecimenDefinitionList.SetItemByIndex(index: Integer; value: TFhirSpecimenDefinition);
begin
  assert(value is TFhirSpecimenDefinition);
  FhirSpecimenDefinitions[index] := value;
end;

procedure TFhirSpecimenDefinitionList.SetItemN(index: Integer; value: TFhirSpecimenDefinition);
begin
  assert(value is TFhirSpecimenDefinition);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_SPECIMENDEFINITION}
{$IFDEF FHIR_STRUCTUREDEFINITION}
{ TFhirStructureDefinitionMapping }

constructor TFhirStructureDefinitionMapping.Create;
begin
  inherited;
end;

destructor TFhirStructureDefinitionMapping.Destroy;
begin
  FIdentity.free;
  FUri.free;
  FName.free;
  FComment.free;
  inherited;
end;

procedure TFhirStructureDefinitionMapping.Assign(oSource : TFslObject);
begin
  inherited;
  identityElement := TFhirStructureDefinitionMapping(oSource).identityElement.Clone;
  uriElement := TFhirStructureDefinitionMapping(oSource).uriElement.Clone;
  nameElement := TFhirStructureDefinitionMapping(oSource).nameElement.Clone;
  commentElement := TFhirStructureDefinitionMapping(oSource).commentElement.Clone;
end;

procedure TFhirStructureDefinitionMapping.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identity') Then
     list.add(self.link, 'identity', FIdentity.Link);
  if (child_name = 'uri') Then
     list.add(self.link, 'uri', FUri.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'comment') Then
     list.add(self.link, 'comment', FComment.Link);
end;

procedure TFhirStructureDefinitionMapping.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identity', 'id', false, TFhirId, FIdentity.Link));
  oList.add(TFHIRProperty.create(self, 'uri', 'uri', false, TFhirUri, FUri.Link));
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'comment', 'string', false, TFhirString, FComment.Link));
end;

function TFhirStructureDefinitionMapping.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identity') then
  begin
    IdentityElement := asId(propValue);
    result := propValue;
  end
  else if (propName = 'uri') then
  begin
    UriElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'comment') then
  begin
    CommentElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirStructureDefinitionMapping.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirStructureDefinitionMapping.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identity') then result := TFhirId.create()
  else if (propName = 'uri') then result := TFhirUri.create()
  else if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'comment') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirStructureDefinitionMapping.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identity') then result := 'id'
  else if (propName = 'uri') then result := 'uri'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'comment') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirStructureDefinitionMapping.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identity') then IdentityElement := nil
  else if (propName = 'uri') then UriElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'comment') then CommentElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirStructureDefinitionMapping.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identity') then IdentityElement := asId(new)
  else if (propName = 'uri') then UriElement := asUri(new)
  else if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'comment') then CommentElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirStructureDefinitionMapping.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirStructureDefinitionMapping.fhirType : string;
begin
  result := 'StructureDefinition.mapping';
end;

function TFhirStructureDefinitionMapping.Link : TFhirStructureDefinitionMapping;
begin
  result := TFhirStructureDefinitionMapping(inherited Link);
end;

function TFhirStructureDefinitionMapping.Clone : TFhirStructureDefinitionMapping;
begin
  result := TFhirStructureDefinitionMapping(inherited Clone);
end;

function TFhirStructureDefinitionMapping.equals(other : TObject) : boolean; 
var
  o : TFhirStructureDefinitionMapping;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirStructureDefinitionMapping)) then
    result := false
  else
  begin
    o := TFhirStructureDefinitionMapping(other);
    result := compareDeep(identityElement, o.identityElement, true) and compareDeep(uriElement, o.uriElement, true) and 
      compareDeep(nameElement, o.nameElement, true) and compareDeep(commentElement, o.commentElement, true);
  end;
end;

function TFhirStructureDefinitionMapping.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentity) and isEmptyProp(FUri) and isEmptyProp(FName) and isEmptyProp(FComment);
end;

procedure TFhirStructureDefinitionMapping.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identity');
  fields.add('uri');
  fields.add('name');
  fields.add('comment');
end;

function TFhirStructureDefinitionMapping.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirStructureDefinitionMapping.SetIdentity(value : TFhirId);
begin
  FIdentity.free;
  FIdentity := value;
end;

function TFhirStructureDefinitionMapping.GetIdentityST : String;
begin
  if FIdentity = nil then
    result := ''
  else
    result := FIdentity.value;
end;

procedure TFhirStructureDefinitionMapping.SetIdentityST(value : String);
begin
  if value <> '' then
  begin
    if FIdentity = nil then
      FIdentity := TFhirId.create;
    FIdentity.value := value
  end
  else if FIdentity <> nil then
    FIdentity.value := '';
end;

procedure TFhirStructureDefinitionMapping.SetUri(value : TFhirUri);
begin
  FUri.free;
  FUri := value;
end;

function TFhirStructureDefinitionMapping.GetUriST : String;
begin
  if FUri = nil then
    result := ''
  else
    result := FUri.value;
end;

procedure TFhirStructureDefinitionMapping.SetUriST(value : String);
begin
  if value <> '' then
  begin
    if FUri = nil then
      FUri := TFhirUri.create;
    FUri.value := value
  end
  else if FUri <> nil then
    FUri.value := '';
end;

procedure TFhirStructureDefinitionMapping.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirStructureDefinitionMapping.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirStructureDefinitionMapping.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirStructureDefinitionMapping.SetComment(value : TFhirString);
begin
  FComment.free;
  FComment := value;
end;

function TFhirStructureDefinitionMapping.GetCommentST : String;
begin
  if FComment = nil then
    result := ''
  else
    result := FComment.value;
end;

procedure TFhirStructureDefinitionMapping.SetCommentST(value : String);
begin
  if value <> '' then
  begin
    if FComment = nil then
      FComment := TFhirString.create;
    FComment.value := value
  end
  else if FComment <> nil then
    FComment.value := '';
end;

{ TFhirStructureDefinitionMappingListEnumerator }

constructor TFhirStructureDefinitionMappingListEnumerator.Create(list : TFhirStructureDefinitionMappingList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirStructureDefinitionMappingListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirStructureDefinitionMappingListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirStructureDefinitionMappingListEnumerator.GetCurrent : TFhirStructureDefinitionMapping;
begin
  Result := FList[FIndex];
end;

function TFhirStructureDefinitionMappingListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirStructureDefinitionMappingList }

function TFhirStructureDefinitionMappingList.AddItem(value: TFhirStructureDefinitionMapping): TFhirStructureDefinitionMapping;
begin
  assert(value.ClassName = 'TFhirStructureDefinitionMapping', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirStructureDefinitionMapping');
  add(value);
  result := value;
end;

function TFhirStructureDefinitionMappingList.Append: TFhirStructureDefinitionMapping;
begin
  result := TFhirStructureDefinitionMapping.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirStructureDefinitionMappingList.ClearItems;
begin
  Clear;
end;

function TFhirStructureDefinitionMappingList.GetEnumerator : TFhirStructureDefinitionMappingListEnumerator;
begin
  result := TFhirStructureDefinitionMappingListEnumerator.Create(self.link);
end;

function TFhirStructureDefinitionMappingList.Clone: TFhirStructureDefinitionMappingList;
begin
  result := TFhirStructureDefinitionMappingList(inherited Clone);
end;

function TFhirStructureDefinitionMappingList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirStructureDefinitionMappingList.GetItemN(index: Integer): TFhirStructureDefinitionMapping;
begin
  result := TFhirStructureDefinitionMapping(ObjectByIndex[index]);
end;

function TFhirStructureDefinitionMappingList.ItemClass: TFslObjectClass;
begin
  result := TFhirStructureDefinitionMapping;
end;
function TFhirStructureDefinitionMappingList.IndexOf(value: TFhirStructureDefinitionMapping): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirStructureDefinitionMappingList.Insert(index: Integer): TFhirStructureDefinitionMapping;
begin
  result := TFhirStructureDefinitionMapping.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirStructureDefinitionMappingList.InsertItem(index: Integer; value: TFhirStructureDefinitionMapping);
begin
  assert(value is TFhirStructureDefinitionMapping);
  Inherited Insert(index, value);
end;

function TFhirStructureDefinitionMappingList.Item(index: Integer): TFhirStructureDefinitionMapping;
begin
  result := TFhirStructureDefinitionMapping(ObjectByIndex[index]);
end;

function TFhirStructureDefinitionMappingList.Link: TFhirStructureDefinitionMappingList;
begin
  result := TFhirStructureDefinitionMappingList(inherited Link);
end;

procedure TFhirStructureDefinitionMappingList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirStructureDefinitionMappingList.SetItemByIndex(index: Integer; value: TFhirStructureDefinitionMapping);
begin
  assert(value is TFhirStructureDefinitionMapping);
  FhirStructureDefinitionMappings[index] := value;
end;

procedure TFhirStructureDefinitionMappingList.SetItemN(index: Integer; value: TFhirStructureDefinitionMapping);
begin
  assert(value is TFhirStructureDefinitionMapping);
  ObjectByIndex[index] := value;
end;

{ TFhirStructureDefinitionContext }

constructor TFhirStructureDefinitionContext.Create;
begin
  inherited;
end;

destructor TFhirStructureDefinitionContext.Destroy;
begin
  FType_.free;
  FExpression.free;
  inherited;
end;

procedure TFhirStructureDefinitionContext.Assign(oSource : TFslObject);
begin
  inherited;
  type_Element := TFhirStructureDefinitionContext(oSource).type_Element.Clone;
  expressionElement := TFhirStructureDefinitionContext(oSource).expressionElement.Clone;
end;

procedure TFhirStructureDefinitionContext.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'expression') Then
     list.add(self.link, 'expression', FExpression.Link);
end;

procedure TFhirStructureDefinitionContext.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFhirEnum, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'expression', 'string', false, TFhirString, FExpression.Link));
end;

function TFhirStructureDefinitionContext.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirExtensionContextTypeEnum, CODES_TFhirExtensionContextTypeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'expression') then
  begin
    ExpressionElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirStructureDefinitionContext.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirStructureDefinitionContext.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirEnum.create(SYSTEMS_TFhirExtensionContextTypeEnum[ExtensionContextTypeNull], CODES_TFhirExtensionContextTypeEnum[ExtensionContextTypeNull]) 
  else if (propName = 'expression') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirStructureDefinitionContext.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'code'
  else if (propName = 'expression') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirStructureDefinitionContext.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'expression') then ExpressionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirStructureDefinitionContext.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirExtensionContextTypeEnum, CODES_TFhirExtensionContextTypeEnum, new)
  else if (propName = 'expression') then ExpressionElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirStructureDefinitionContext.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirStructureDefinitionContext.fhirType : string;
begin
  result := 'StructureDefinition.context';
end;

function TFhirStructureDefinitionContext.Link : TFhirStructureDefinitionContext;
begin
  result := TFhirStructureDefinitionContext(inherited Link);
end;

function TFhirStructureDefinitionContext.Clone : TFhirStructureDefinitionContext;
begin
  result := TFhirStructureDefinitionContext(inherited Clone);
end;

function TFhirStructureDefinitionContext.equals(other : TObject) : boolean; 
var
  o : TFhirStructureDefinitionContext;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirStructureDefinitionContext)) then
    result := false
  else
  begin
    o := TFhirStructureDefinitionContext(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(expressionElement, o.expressionElement, true);
  end;
end;

function TFhirStructureDefinitionContext.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FExpression);
end;

procedure TFhirStructureDefinitionContext.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('expression');
end;

function TFhirStructureDefinitionContext.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirStructureDefinitionContext.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirStructureDefinitionContext.GetType_ST : TFhirExtensionContextTypeEnum;
begin
  if FType_ = nil then
    result := TFhirExtensionContextTypeEnum(0)
  else
    result := TFhirExtensionContextTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirExtensionContextTypeEnum, FType_.value));
end;

procedure TFhirStructureDefinitionContext.SetType_ST(value : TFhirExtensionContextTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirExtensionContextTypeEnum[value], CODES_TFhirExtensionContextTypeEnum[value]);
end;

procedure TFhirStructureDefinitionContext.SetExpression(value : TFhirString);
begin
  FExpression.free;
  FExpression := value;
end;

function TFhirStructureDefinitionContext.GetExpressionST : String;
begin
  if FExpression = nil then
    result := ''
  else
    result := FExpression.value;
end;

procedure TFhirStructureDefinitionContext.SetExpressionST(value : String);
begin
  if value <> '' then
  begin
    if FExpression = nil then
      FExpression := TFhirString.create;
    FExpression.value := value
  end
  else if FExpression <> nil then
    FExpression.value := '';
end;

{ TFhirStructureDefinitionContextListEnumerator }

constructor TFhirStructureDefinitionContextListEnumerator.Create(list : TFhirStructureDefinitionContextList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirStructureDefinitionContextListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirStructureDefinitionContextListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirStructureDefinitionContextListEnumerator.GetCurrent : TFhirStructureDefinitionContext;
begin
  Result := FList[FIndex];
end;

function TFhirStructureDefinitionContextListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirStructureDefinitionContextList }

function TFhirStructureDefinitionContextList.AddItem(value: TFhirStructureDefinitionContext): TFhirStructureDefinitionContext;
begin
  assert(value.ClassName = 'TFhirStructureDefinitionContext', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirStructureDefinitionContext');
  add(value);
  result := value;
end;

function TFhirStructureDefinitionContextList.Append: TFhirStructureDefinitionContext;
begin
  result := TFhirStructureDefinitionContext.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirStructureDefinitionContextList.ClearItems;
begin
  Clear;
end;

function TFhirStructureDefinitionContextList.GetEnumerator : TFhirStructureDefinitionContextListEnumerator;
begin
  result := TFhirStructureDefinitionContextListEnumerator.Create(self.link);
end;

function TFhirStructureDefinitionContextList.Clone: TFhirStructureDefinitionContextList;
begin
  result := TFhirStructureDefinitionContextList(inherited Clone);
end;

function TFhirStructureDefinitionContextList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirStructureDefinitionContextList.GetItemN(index: Integer): TFhirStructureDefinitionContext;
begin
  result := TFhirStructureDefinitionContext(ObjectByIndex[index]);
end;

function TFhirStructureDefinitionContextList.ItemClass: TFslObjectClass;
begin
  result := TFhirStructureDefinitionContext;
end;
function TFhirStructureDefinitionContextList.IndexOf(value: TFhirStructureDefinitionContext): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirStructureDefinitionContextList.Insert(index: Integer): TFhirStructureDefinitionContext;
begin
  result := TFhirStructureDefinitionContext.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirStructureDefinitionContextList.InsertItem(index: Integer; value: TFhirStructureDefinitionContext);
begin
  assert(value is TFhirStructureDefinitionContext);
  Inherited Insert(index, value);
end;

function TFhirStructureDefinitionContextList.Item(index: Integer): TFhirStructureDefinitionContext;
begin
  result := TFhirStructureDefinitionContext(ObjectByIndex[index]);
end;

function TFhirStructureDefinitionContextList.Link: TFhirStructureDefinitionContextList;
begin
  result := TFhirStructureDefinitionContextList(inherited Link);
end;

procedure TFhirStructureDefinitionContextList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirStructureDefinitionContextList.SetItemByIndex(index: Integer; value: TFhirStructureDefinitionContext);
begin
  assert(value is TFhirStructureDefinitionContext);
  FhirStructureDefinitionContexts[index] := value;
end;

procedure TFhirStructureDefinitionContextList.SetItemN(index: Integer; value: TFhirStructureDefinitionContext);
begin
  assert(value is TFhirStructureDefinitionContext);
  ObjectByIndex[index] := value;
end;

{ TFhirStructureDefinitionSnapshot }

constructor TFhirStructureDefinitionSnapshot.Create;
begin
  inherited;
end;

destructor TFhirStructureDefinitionSnapshot.Destroy;
begin
  FElementList.Free;
  inherited;
end;

procedure TFhirStructureDefinitionSnapshot.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirStructureDefinitionSnapshot(oSource).FElementList = nil) then
  begin
    FElementList.free;
    FElementList := nil;
  end
  else
  begin
    if FElementList = nil then
      FElementList := TFhirElementDefinitionList.Create;
    FElementList.Assign(TFhirStructureDefinitionSnapshot(oSource).FElementList);
  end;
end;

procedure TFhirStructureDefinitionSnapshot.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'element') Then
    list.addAll(self, 'element', FElementList);
end;

procedure TFhirStructureDefinitionSnapshot.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'element', 'ElementDefinition', true, TFhirElementDefinition, FElementList.Link));
end;

function TFhirStructureDefinitionSnapshot.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'element') then
  begin
    ElementList.add(propValue as TFhirElementDefinition);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirStructureDefinitionSnapshot.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'element') then ElementList.insertItem(index, propValue as TFhirElementDefinition)
  else inherited;
end;

function TFhirStructureDefinitionSnapshot.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'element') then result := ElementList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirStructureDefinitionSnapshot.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'element') then result := 'ElementDefinition'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirStructureDefinitionSnapshot.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'element') then deletePropertyValue('element', ElementList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirStructureDefinitionSnapshot.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'element') then replacePropertyValue('element', ElementList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirStructureDefinitionSnapshot.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'element') then ElementList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirStructureDefinitionSnapshot.fhirType : string;
begin
  result := 'StructureDefinition.snapshot';
end;

function TFhirStructureDefinitionSnapshot.Link : TFhirStructureDefinitionSnapshot;
begin
  result := TFhirStructureDefinitionSnapshot(inherited Link);
end;

function TFhirStructureDefinitionSnapshot.Clone : TFhirStructureDefinitionSnapshot;
begin
  result := TFhirStructureDefinitionSnapshot(inherited Clone);
end;

function TFhirStructureDefinitionSnapshot.equals(other : TObject) : boolean; 
var
  o : TFhirStructureDefinitionSnapshot;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirStructureDefinitionSnapshot)) then
    result := false
  else
  begin
    o := TFhirStructureDefinitionSnapshot(other);
    result := compareDeep(elementList, o.elementList, true);
  end;
end;

function TFhirStructureDefinitionSnapshot.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FelementList);
end;

procedure TFhirStructureDefinitionSnapshot.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('element');
end;

function TFhirStructureDefinitionSnapshot.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FElementList.sizeInBytes(magic));
end;

function TFhirStructureDefinitionSnapshot.GetElementList : TFhirElementDefinitionList;
begin
  if FElementList = nil then
    FElementList := TFhirElementDefinitionList.Create;
  result := FElementList;
end;

function TFhirStructureDefinitionSnapshot.GetHasElementList : boolean;
begin
  result := (FElementList <> nil) and (FElementList.count > 0);
end;

{ TFhirStructureDefinitionSnapshotListEnumerator }

constructor TFhirStructureDefinitionSnapshotListEnumerator.Create(list : TFhirStructureDefinitionSnapshotList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirStructureDefinitionSnapshotListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirStructureDefinitionSnapshotListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirStructureDefinitionSnapshotListEnumerator.GetCurrent : TFhirStructureDefinitionSnapshot;
begin
  Result := FList[FIndex];
end;

function TFhirStructureDefinitionSnapshotListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirStructureDefinitionSnapshotList }

function TFhirStructureDefinitionSnapshotList.AddItem(value: TFhirStructureDefinitionSnapshot): TFhirStructureDefinitionSnapshot;
begin
  assert(value.ClassName = 'TFhirStructureDefinitionSnapshot', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirStructureDefinitionSnapshot');
  add(value);
  result := value;
end;

function TFhirStructureDefinitionSnapshotList.Append: TFhirStructureDefinitionSnapshot;
begin
  result := TFhirStructureDefinitionSnapshot.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirStructureDefinitionSnapshotList.ClearItems;
begin
  Clear;
end;

function TFhirStructureDefinitionSnapshotList.GetEnumerator : TFhirStructureDefinitionSnapshotListEnumerator;
begin
  result := TFhirStructureDefinitionSnapshotListEnumerator.Create(self.link);
end;

function TFhirStructureDefinitionSnapshotList.Clone: TFhirStructureDefinitionSnapshotList;
begin
  result := TFhirStructureDefinitionSnapshotList(inherited Clone);
end;

function TFhirStructureDefinitionSnapshotList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirStructureDefinitionSnapshotList.GetItemN(index: Integer): TFhirStructureDefinitionSnapshot;
begin
  result := TFhirStructureDefinitionSnapshot(ObjectByIndex[index]);
end;

function TFhirStructureDefinitionSnapshotList.ItemClass: TFslObjectClass;
begin
  result := TFhirStructureDefinitionSnapshot;
end;
function TFhirStructureDefinitionSnapshotList.IndexOf(value: TFhirStructureDefinitionSnapshot): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirStructureDefinitionSnapshotList.Insert(index: Integer): TFhirStructureDefinitionSnapshot;
begin
  result := TFhirStructureDefinitionSnapshot.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirStructureDefinitionSnapshotList.InsertItem(index: Integer; value: TFhirStructureDefinitionSnapshot);
begin
  assert(value is TFhirStructureDefinitionSnapshot);
  Inherited Insert(index, value);
end;

function TFhirStructureDefinitionSnapshotList.Item(index: Integer): TFhirStructureDefinitionSnapshot;
begin
  result := TFhirStructureDefinitionSnapshot(ObjectByIndex[index]);
end;

function TFhirStructureDefinitionSnapshotList.Link: TFhirStructureDefinitionSnapshotList;
begin
  result := TFhirStructureDefinitionSnapshotList(inherited Link);
end;

procedure TFhirStructureDefinitionSnapshotList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirStructureDefinitionSnapshotList.SetItemByIndex(index: Integer; value: TFhirStructureDefinitionSnapshot);
begin
  assert(value is TFhirStructureDefinitionSnapshot);
  FhirStructureDefinitionSnapshots[index] := value;
end;

procedure TFhirStructureDefinitionSnapshotList.SetItemN(index: Integer; value: TFhirStructureDefinitionSnapshot);
begin
  assert(value is TFhirStructureDefinitionSnapshot);
  ObjectByIndex[index] := value;
end;

{ TFhirStructureDefinitionDifferential }

constructor TFhirStructureDefinitionDifferential.Create;
begin
  inherited;
end;

destructor TFhirStructureDefinitionDifferential.Destroy;
begin
  FElementList.Free;
  inherited;
end;

procedure TFhirStructureDefinitionDifferential.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirStructureDefinitionDifferential(oSource).FElementList = nil) then
  begin
    FElementList.free;
    FElementList := nil;
  end
  else
  begin
    if FElementList = nil then
      FElementList := TFhirElementDefinitionList.Create;
    FElementList.Assign(TFhirStructureDefinitionDifferential(oSource).FElementList);
  end;
end;

procedure TFhirStructureDefinitionDifferential.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'element') Then
    list.addAll(self, 'element', FElementList);
end;

procedure TFhirStructureDefinitionDifferential.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'element', 'ElementDefinition', true, TFhirElementDefinition, FElementList.Link));
end;

function TFhirStructureDefinitionDifferential.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'element') then
  begin
    ElementList.add(propValue as TFhirElementDefinition);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirStructureDefinitionDifferential.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'element') then ElementList.insertItem(index, propValue as TFhirElementDefinition)
  else inherited;
end;

function TFhirStructureDefinitionDifferential.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'element') then result := ElementList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirStructureDefinitionDifferential.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'element') then result := 'ElementDefinition'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirStructureDefinitionDifferential.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'element') then deletePropertyValue('element', ElementList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirStructureDefinitionDifferential.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'element') then replacePropertyValue('element', ElementList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirStructureDefinitionDifferential.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'element') then ElementList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirStructureDefinitionDifferential.fhirType : string;
begin
  result := 'StructureDefinition.differential';
end;

function TFhirStructureDefinitionDifferential.Link : TFhirStructureDefinitionDifferential;
begin
  result := TFhirStructureDefinitionDifferential(inherited Link);
end;

function TFhirStructureDefinitionDifferential.Clone : TFhirStructureDefinitionDifferential;
begin
  result := TFhirStructureDefinitionDifferential(inherited Clone);
end;

function TFhirStructureDefinitionDifferential.equals(other : TObject) : boolean; 
var
  o : TFhirStructureDefinitionDifferential;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirStructureDefinitionDifferential)) then
    result := false
  else
  begin
    o := TFhirStructureDefinitionDifferential(other);
    result := compareDeep(elementList, o.elementList, true);
  end;
end;

function TFhirStructureDefinitionDifferential.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FelementList);
end;

procedure TFhirStructureDefinitionDifferential.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('element');
end;

function TFhirStructureDefinitionDifferential.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FElementList.sizeInBytes(magic));
end;

function TFhirStructureDefinitionDifferential.GetElementList : TFhirElementDefinitionList;
begin
  if FElementList = nil then
    FElementList := TFhirElementDefinitionList.Create;
  result := FElementList;
end;

function TFhirStructureDefinitionDifferential.GetHasElementList : boolean;
begin
  result := (FElementList <> nil) and (FElementList.count > 0);
end;

{ TFhirStructureDefinitionDifferentialListEnumerator }

constructor TFhirStructureDefinitionDifferentialListEnumerator.Create(list : TFhirStructureDefinitionDifferentialList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirStructureDefinitionDifferentialListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirStructureDefinitionDifferentialListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirStructureDefinitionDifferentialListEnumerator.GetCurrent : TFhirStructureDefinitionDifferential;
begin
  Result := FList[FIndex];
end;

function TFhirStructureDefinitionDifferentialListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirStructureDefinitionDifferentialList }

function TFhirStructureDefinitionDifferentialList.AddItem(value: TFhirStructureDefinitionDifferential): TFhirStructureDefinitionDifferential;
begin
  assert(value.ClassName = 'TFhirStructureDefinitionDifferential', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirStructureDefinitionDifferential');
  add(value);
  result := value;
end;

function TFhirStructureDefinitionDifferentialList.Append: TFhirStructureDefinitionDifferential;
begin
  result := TFhirStructureDefinitionDifferential.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirStructureDefinitionDifferentialList.ClearItems;
begin
  Clear;
end;

function TFhirStructureDefinitionDifferentialList.GetEnumerator : TFhirStructureDefinitionDifferentialListEnumerator;
begin
  result := TFhirStructureDefinitionDifferentialListEnumerator.Create(self.link);
end;

function TFhirStructureDefinitionDifferentialList.Clone: TFhirStructureDefinitionDifferentialList;
begin
  result := TFhirStructureDefinitionDifferentialList(inherited Clone);
end;

function TFhirStructureDefinitionDifferentialList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirStructureDefinitionDifferentialList.GetItemN(index: Integer): TFhirStructureDefinitionDifferential;
begin
  result := TFhirStructureDefinitionDifferential(ObjectByIndex[index]);
end;

function TFhirStructureDefinitionDifferentialList.ItemClass: TFslObjectClass;
begin
  result := TFhirStructureDefinitionDifferential;
end;
function TFhirStructureDefinitionDifferentialList.IndexOf(value: TFhirStructureDefinitionDifferential): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirStructureDefinitionDifferentialList.Insert(index: Integer): TFhirStructureDefinitionDifferential;
begin
  result := TFhirStructureDefinitionDifferential.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirStructureDefinitionDifferentialList.InsertItem(index: Integer; value: TFhirStructureDefinitionDifferential);
begin
  assert(value is TFhirStructureDefinitionDifferential);
  Inherited Insert(index, value);
end;

function TFhirStructureDefinitionDifferentialList.Item(index: Integer): TFhirStructureDefinitionDifferential;
begin
  result := TFhirStructureDefinitionDifferential(ObjectByIndex[index]);
end;

function TFhirStructureDefinitionDifferentialList.Link: TFhirStructureDefinitionDifferentialList;
begin
  result := TFhirStructureDefinitionDifferentialList(inherited Link);
end;

procedure TFhirStructureDefinitionDifferentialList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirStructureDefinitionDifferentialList.SetItemByIndex(index: Integer; value: TFhirStructureDefinitionDifferential);
begin
  assert(value is TFhirStructureDefinitionDifferential);
  FhirStructureDefinitionDifferentials[index] := value;
end;

procedure TFhirStructureDefinitionDifferentialList.SetItemN(index: Integer; value: TFhirStructureDefinitionDifferential);
begin
  assert(value is TFhirStructureDefinitionDifferential);
  ObjectByIndex[index] := value;
end;

{ TFhirStructureDefinition }

constructor TFhirStructureDefinition.Create;
begin
  inherited;
end;

destructor TFhirStructureDefinition.Destroy;
begin
  FUrl.free;
  FIdentifierList.Free;
  FVersion.free;
  FName.free;
  FTitle.free;
  FStatus.free;
  FExperimental.free;
  FDate.free;
  FPublisher.free;
  FContactList.Free;
  FDescription.free;
  FUseContextList.Free;
  FJurisdictionList.Free;
  FPurpose.free;
  FCopyright.free;
  FKeywordList.Free;
  FFhirVersion.free;
  FMappingList.Free;
  FKind.free;
  FAbstract.free;
  FContextList.Free;
  FContextInvariantList.Free;
  FType_.free;
  FBaseDefinition.free;
  FDerivation.free;
  FSnapshot.free;
  FDifferential.free;
  inherited;
end;

procedure TFhirStructureDefinition.Assign(oSource : TFslObject);
begin
  inherited;
  urlElement := TFhirStructureDefinition(oSource).urlElement.Clone;
  if (TFhirStructureDefinition(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirStructureDefinition(oSource).FIdentifierList);
  end;
  versionElement := TFhirStructureDefinition(oSource).versionElement.Clone;
  nameElement := TFhirStructureDefinition(oSource).nameElement.Clone;
  titleElement := TFhirStructureDefinition(oSource).titleElement.Clone;
  statusElement := TFhirStructureDefinition(oSource).statusElement.Clone;
  experimentalElement := TFhirStructureDefinition(oSource).experimentalElement.Clone;
  dateElement := TFhirStructureDefinition(oSource).dateElement.Clone;
  publisherElement := TFhirStructureDefinition(oSource).publisherElement.Clone;
  if (TFhirStructureDefinition(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirContactDetailList.Create;
    FContactList.Assign(TFhirStructureDefinition(oSource).FContactList);
  end;
  descriptionElement := TFhirStructureDefinition(oSource).descriptionElement.Clone;
  if (TFhirStructureDefinition(oSource).FUseContextList = nil) then
  begin
    FUseContextList.free;
    FUseContextList := nil;
  end
  else
  begin
    if FUseContextList = nil then
      FUseContextList := TFhirUsageContextList.Create;
    FUseContextList.Assign(TFhirStructureDefinition(oSource).FUseContextList);
  end;
  if (TFhirStructureDefinition(oSource).FJurisdictionList = nil) then
  begin
    FJurisdictionList.free;
    FJurisdictionList := nil;
  end
  else
  begin
    if FJurisdictionList = nil then
      FJurisdictionList := TFhirCodeableConceptList.Create;
    FJurisdictionList.Assign(TFhirStructureDefinition(oSource).FJurisdictionList);
  end;
  purposeElement := TFhirStructureDefinition(oSource).purposeElement.Clone;
  copyrightElement := TFhirStructureDefinition(oSource).copyrightElement.Clone;
  if (TFhirStructureDefinition(oSource).FKeywordList = nil) then
  begin
    FKeywordList.free;
    FKeywordList := nil;
  end
  else
  begin
    if FKeywordList = nil then
      FKeywordList := TFhirCodingList.Create;
    FKeywordList.Assign(TFhirStructureDefinition(oSource).FKeywordList);
  end;
  fhirVersionElement := TFhirStructureDefinition(oSource).fhirVersionElement.Clone;
  if (TFhirStructureDefinition(oSource).FMappingList = nil) then
  begin
    FMappingList.free;
    FMappingList := nil;
  end
  else
  begin
    if FMappingList = nil then
      FMappingList := TFhirStructureDefinitionMappingList.Create;
    FMappingList.Assign(TFhirStructureDefinition(oSource).FMappingList);
  end;
  kindElement := TFhirStructureDefinition(oSource).kindElement.Clone;
  abstractElement := TFhirStructureDefinition(oSource).abstractElement.Clone;
  if (TFhirStructureDefinition(oSource).FContextList = nil) then
  begin
    FContextList.free;
    FContextList := nil;
  end
  else
  begin
    if FContextList = nil then
      FContextList := TFhirStructureDefinitionContextList.Create;
    FContextList.Assign(TFhirStructureDefinition(oSource).FContextList);
  end;
  if (TFhirStructureDefinition(oSource).FContextInvariantList = nil) then
  begin
    FContextInvariantList.free;
    FContextInvariantList := nil;
  end
  else
  begin
    if FContextInvariantList = nil then
      FContextInvariantList := TFhirStringList.Create;
    FContextInvariantList.Assign(TFhirStructureDefinition(oSource).FContextInvariantList);
  end;
  type_Element := TFhirStructureDefinition(oSource).type_Element.Clone;
  baseDefinitionElement := TFhirStructureDefinition(oSource).baseDefinitionElement.Clone;
  derivationElement := TFhirStructureDefinition(oSource).derivationElement.Clone;
  snapshot := TFhirStructureDefinition(oSource).snapshot.Clone;
  differential := TFhirStructureDefinition(oSource).differential.Clone;
end;

function TFhirStructureDefinition.GetResourceType : TFhirResourceType;
begin
  result := frtStructureDefinition;
end;

procedure TFhirStructureDefinition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'version') Then
     list.add(self.link, 'version', FVersion.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'experimental') Then
     list.add(self.link, 'experimental', FExperimental.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'publisher') Then
     list.add(self.link, 'publisher', FPublisher.Link);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'useContext') Then
    list.addAll(self, 'useContext', FUseContextList);
  if (child_name = 'jurisdiction') Then
    list.addAll(self, 'jurisdiction', FJurisdictionList);
  if (child_name = 'purpose') Then
     list.add(self.link, 'purpose', FPurpose.Link);
  if (child_name = 'copyright') Then
     list.add(self.link, 'copyright', FCopyright.Link);
  if (child_name = 'keyword') Then
    list.addAll(self, 'keyword', FKeywordList);
  if (child_name = 'fhirVersion') Then
     list.add(self.link, 'fhirVersion', FFhirVersion.Link);
  if (child_name = 'mapping') Then
    list.addAll(self, 'mapping', FMappingList);
  if (child_name = 'kind') Then
     list.add(self.link, 'kind', FKind.Link);
  if (child_name = 'abstract') Then
     list.add(self.link, 'abstract', FAbstract.Link);
  if (child_name = 'context') Then
    list.addAll(self, 'context', FContextList);
  if (child_name = 'contextInvariant') Then
    list.addAll(self, 'contextInvariant', FContextInvariantList);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'baseDefinition') Then
     list.add(self.link, 'baseDefinition', FBaseDefinition.Link);
  if (child_name = 'derivation') Then
     list.add(self.link, 'derivation', FDerivation.Link);
  if (child_name = 'snapshot') Then
     list.add(self.link, 'snapshot', FSnapshot.Link);
  if (child_name = 'differential') Then
     list.add(self.link, 'differential', FDifferential.Link);
end;

procedure TFhirStructureDefinition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'url', 'uri', false, TFhirUri, FUrl.Link));
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'version', 'string', false, TFhirString, FVersion.Link));
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'experimental', 'boolean', false, TFhirBoolean, FExperimental.Link));
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));
  oList.add(TFHIRProperty.create(self, 'publisher', 'string', false, TFhirString, FPublisher.Link));
  oList.add(TFHIRProperty.create(self, 'contact', 'ContactDetail', true, TFhirContactDetail, FContactList.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'markdown', false, TFhirMarkdown, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'useContext', 'UsageContext', true, TFhirUsageContext, FUseContextList.Link));
  oList.add(TFHIRProperty.create(self, 'jurisdiction', 'CodeableConcept', true, TFhirCodeableConcept, FJurisdictionList.Link));
  oList.add(TFHIRProperty.create(self, 'purpose', 'markdown', false, TFhirMarkdown, FPurpose.Link));
  oList.add(TFHIRProperty.create(self, 'copyright', 'markdown', false, TFhirMarkdown, FCopyright.Link));
  oList.add(TFHIRProperty.create(self, 'keyword', 'Coding', true, TFhirCoding, FKeywordList.Link));
  oList.add(TFHIRProperty.create(self, 'fhirVersion', 'code', false, TFhirEnum, FFhirVersion.Link));
  oList.add(TFHIRProperty.create(self, 'mapping', 'BackboneElement', true, TFhirStructureDefinitionMapping, FMappingList.Link));
  oList.add(TFHIRProperty.create(self, 'kind', 'code', false, TFhirEnum, FKind.Link));
  oList.add(TFHIRProperty.create(self, 'abstract', 'boolean', false, TFhirBoolean, FAbstract.Link));
  oList.add(TFHIRProperty.create(self, 'context', 'BackboneElement', true, TFhirStructureDefinitionContext, FContextList.Link));
  oList.add(TFHIRProperty.create(self, 'contextInvariant', 'string', true, TFhirString, FContextInvariantList.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'uri', false, TFhirUri, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'baseDefinition', 'canonical', false, TFhirCanonical, FBaseDefinition.Link));
  oList.add(TFHIRProperty.create(self, 'derivation', 'code', false, TFhirEnum, FDerivation.Link));
  oList.add(TFHIRProperty.create(self, 'snapshot', 'BackboneElement', false, TFhirStructureDefinitionSnapshot, FSnapshot.Link));
  oList.add(TFHIRProperty.create(self, 'differential', 'BackboneElement', false, TFhirStructureDefinitionDifferential, FDifferential.Link));
end;

function TFhirStructureDefinition.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'url') then
  begin
    UrlElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'title') then
  begin
    TitleElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'experimental') then
  begin
    ExperimentalElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'publisher') then
  begin
    PublisherElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirContactDetail);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'useContext') then
  begin
    UseContextList.add(propValue as TFhirUsageContext);
    result := propValue;
  end
  else if (propName = 'jurisdiction') then
  begin
    JurisdictionList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'purpose') then
  begin
    PurposeElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'copyright') then
  begin
    CopyrightElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'keyword') then
  begin
    KeywordList.add(propValue as TFhirCoding);
    result := propValue;
  end
  else if (propName = 'fhirVersion') then
  begin
    FhirVersionElement := asEnum(SYSTEMS_TFhirFHIRVersionEnum, CODES_TFhirFHIRVersionEnum, propValue);
    result := propValue;
  end
  else if (propName = 'mapping') then
  begin
    MappingList.add(propValue as TFhirStructureDefinitionMapping);
    result := propValue;
  end
  else if (propName = 'kind') then
  begin
    KindElement := asEnum(SYSTEMS_TFhirStructureDefinitionKindEnum, CODES_TFhirStructureDefinitionKindEnum, propValue);
    result := propValue;
  end
  else if (propName = 'abstract') then
  begin
    AbstractElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'context') then
  begin
    ContextList.add(propValue as TFhirStructureDefinitionContext);
    result := propValue;
  end
  else if (propName = 'contextInvariant') then
  begin
    ContextInvariantList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'type') then
  begin
    Type_Element := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'baseDefinition') then
  begin
    BaseDefinitionElement := asCanonical(propValue);
    result := propValue;
  end
  else if (propName = 'derivation') then
  begin
    DerivationElement := asEnum(SYSTEMS_TFhirTypeDerivationRuleEnum, CODES_TFhirTypeDerivationRuleEnum, propValue);
    result := propValue;
  end
  else if (propName = 'snapshot') then
  begin
    Snapshot := propValue as TFhirStructureDefinitionSnapshot;
    result := propValue;
  end
  else if (propName = 'differential') then
  begin
    Differential := propValue as TFhirStructureDefinitionDifferential;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirStructureDefinition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirContactDetail)
  else if (propName = 'useContext') then UseContextList.insertItem(index, propValue as TFhirUsageContext)
  else if (propName = 'jurisdiction') then JurisdictionList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'keyword') then KeywordList.insertItem(index, propValue as TFhirCoding)
  else if (propName = 'mapping') then MappingList.insertItem(index, propValue as TFhirStructureDefinitionMapping)
  else if (propName = 'context') then ContextList.insertItem(index, propValue as TFhirStructureDefinitionContext)
  else if (propName = 'contextInvariant') then ContextInvariantList.insertItem(index, asString(propValue))
  else inherited;
end;

function TFhirStructureDefinition.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'url') then result := TFhirUri.create()
  else if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'version') then result := TFhirString.create()
  else if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'title') then result := TFhirString.create()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[PublicationStatusNull], CODES_TFhirPublicationStatusEnum[PublicationStatusNull]) 
  else if (propName = 'experimental') then result := TFhirBoolean.create()
  else if (propName = 'date') then result := TFhirDateTime.create()
  else if (propName = 'publisher') then result := TFhirString.create()
  else if (propName = 'contact') then result := ContactList.new()
  else if (propName = 'description') then result := TFhirMarkdown.create()
  else if (propName = 'useContext') then result := UseContextList.new()
  else if (propName = 'jurisdiction') then result := JurisdictionList.new()
  else if (propName = 'purpose') then result := TFhirMarkdown.create()
  else if (propName = 'copyright') then result := TFhirMarkdown.create()
  else if (propName = 'keyword') then result := KeywordList.new()
  else if (propName = 'fhirVersion') then result := TFhirEnum.create(SYSTEMS_TFhirFHIRVersionEnum[FHIRVersionNull], CODES_TFhirFHIRVersionEnum[FHIRVersionNull]) 
  else if (propName = 'mapping') then result := MappingList.new()
  else if (propName = 'kind') then result := TFhirEnum.create(SYSTEMS_TFhirStructureDefinitionKindEnum[StructureDefinitionKindNull], CODES_TFhirStructureDefinitionKindEnum[StructureDefinitionKindNull]) 
  else if (propName = 'abstract') then result := TFhirBoolean.create()
  else if (propName = 'context') then result := ContextList.new()
  else if (propName = 'contextInvariant') then result := ContextInvariantList.new()
  else if (propName = 'type') then result := TFhirUri.create()
  else if (propName = 'baseDefinition') then result := TFhirCanonical.create()
  else if (propName = 'derivation') then result := TFhirEnum.create(SYSTEMS_TFhirTypeDerivationRuleEnum[TypeDerivationRuleNull], CODES_TFhirTypeDerivationRuleEnum[TypeDerivationRuleNull]) 
  else if (propName = 'snapshot') then result := TFhirStructureDefinitionSnapshot.create()
  else if (propName = 'differential') then result := TFhirStructureDefinitionDifferential.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirStructureDefinition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'url') then result := 'uri'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'version') then result := 'string'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'title') then result := 'string'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'experimental') then result := 'boolean'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'publisher') then result := 'string'
  else if (propName = 'contact') then result := 'ContactDetail'
  else if (propName = 'description') then result := 'markdown'
  else if (propName = 'useContext') then result := 'UsageContext'
  else if (propName = 'jurisdiction') then result := 'CodeableConcept'
  else if (propName = 'purpose') then result := 'markdown'
  else if (propName = 'copyright') then result := 'markdown'
  else if (propName = 'keyword') then result := 'Coding'
  else if (propName = 'fhirVersion') then result := 'code'
  else if (propName = 'mapping') then result := 'BackboneElement'
  else if (propName = 'kind') then result := 'code'
  else if (propName = 'abstract') then result := 'boolean'
  else if (propName = 'context') then result := 'BackboneElement'
  else if (propName = 'contextInvariant') then result := 'string'
  else if (propName = 'type') then result := 'uri'
  else if (propName = 'baseDefinition') then result := 'canonical'
  else if (propName = 'derivation') then result := 'code'
  else if (propName = 'snapshot') then result := 'BackboneElement'
  else if (propName = 'differential') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirStructureDefinition.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := nil
  else if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'version') then VersionElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'title') then TitleElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'experimental') then ExperimentalElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'publisher') then PublisherElement := nil
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value)
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'useContext') then deletePropertyValue('useContext', UseContextList, value)
  else if (propName = 'jurisdiction') then deletePropertyValue('jurisdiction', JurisdictionList, value)
  else if (propName = 'purpose') then PurposeElement := nil
  else if (propName = 'copyright') then CopyrightElement := nil
  else if (propName = 'keyword') then deletePropertyValue('keyword', KeywordList, value)
  else if (propName = 'fhirVersion') then FhirVersionElement := nil
  else if (propName = 'mapping') then deletePropertyValue('mapping', MappingList, value)
  else if (propName = 'kind') then KindElement := nil
  else if (propName = 'abstract') then AbstractElement := nil
  else if (propName = 'context') then deletePropertyValue('context', ContextList, value)
  else if (propName = 'contextInvariant') then deletePropertyValue('contextInvariant', ContextInvariantList, value)
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'baseDefinition') then BaseDefinitionElement := nil
  else if (propName = 'derivation') then DerivationElement := nil
  else if (propName = 'snapshot') then SnapshotElement := nil
  else if (propName = 'differential') then DifferentialElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirStructureDefinition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := asUri(new)
  else if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'version') then VersionElement := asString(new)
  else if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'title') then TitleElement := asString(new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, new)
  else if (propName = 'experimental') then ExperimentalElement := asBoolean(new)
  else if (propName = 'date') then DateElement := asDateTime(new)
  else if (propName = 'publisher') then PublisherElement := asString(new)
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new)
  else if (propName = 'description') then DescriptionElement := asMarkdown(new)
  else if (propName = 'useContext') then replacePropertyValue('useContext', UseContextList, existing, new)
  else if (propName = 'jurisdiction') then replacePropertyValue('jurisdiction', JurisdictionList, existing, new)
  else if (propName = 'purpose') then PurposeElement := asMarkdown(new)
  else if (propName = 'copyright') then CopyrightElement := asMarkdown(new)
  else if (propName = 'keyword') then replacePropertyValue('keyword', KeywordList, existing, new)
  else if (propName = 'fhirVersion') then FhirVersionElement := asEnum(SYSTEMS_TFhirFHIRVersionEnum, CODES_TFhirFHIRVersionEnum, new)
  else if (propName = 'mapping') then replacePropertyValue('mapping', MappingList, existing, new)
  else if (propName = 'kind') then KindElement := asEnum(SYSTEMS_TFhirStructureDefinitionKindEnum, CODES_TFhirStructureDefinitionKindEnum, new)
  else if (propName = 'abstract') then AbstractElement := asBoolean(new)
  else if (propName = 'context') then replacePropertyValue('context', ContextList, existing, new)
  else if (propName = 'contextInvariant') then replacePropertyValue('contextInvariant', ContextInvariantList, existing, new)
  else if (propName = 'type') then Type_Element := asUri(new)
  else if (propName = 'baseDefinition') then BaseDefinitionElement := asCanonical(new)
  else if (propName = 'derivation') then DerivationElement := asEnum(SYSTEMS_TFhirTypeDerivationRuleEnum, CODES_TFhirTypeDerivationRuleEnum, new)
  else if (propName = 'snapshot') then SnapshotElement := new as TFhirStructureDefinitionSnapshot
  else if (propName = 'differential') then DifferentialElement := new as TFhirStructureDefinitionDifferential
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirStructureDefinition.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'contact') then ContactList.move(source, destination)
  else if (propName = 'useContext') then UseContextList.move(source, destination)
  else if (propName = 'jurisdiction') then JurisdictionList.move(source, destination)
  else if (propName = 'keyword') then KeywordList.move(source, destination)
  else if (propName = 'mapping') then MappingList.move(source, destination)
  else if (propName = 'context') then ContextList.move(source, destination)
  else if (propName = 'contextInvariant') then ContextInvariantList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirStructureDefinition.fhirType : string;
begin
  result := 'StructureDefinition';
end;

function TFhirStructureDefinition.Link : TFhirStructureDefinition;
begin
  result := TFhirStructureDefinition(inherited Link);
end;

function TFhirStructureDefinition.Clone : TFhirStructureDefinition;
begin
  result := TFhirStructureDefinition(inherited Clone);
end;

function TFhirStructureDefinition.equals(other : TObject) : boolean; 
var
  o : TFhirStructureDefinition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirStructureDefinition)) then
    result := false
  else
  begin
    o := TFhirStructureDefinition(other);
    result := compareDeep(urlElement, o.urlElement, true) and compareDeep(identifierList, o.identifierList, true) and 
      compareDeep(versionElement, o.versionElement, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(titleElement, o.titleElement, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(experimentalElement, o.experimentalElement, true) and compareDeep(dateElement, o.dateElement, true) and 
      compareDeep(publisherElement, o.publisherElement, true) and compareDeep(contactList, o.contactList, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(useContextList, o.useContextList, true) and 
      compareDeep(jurisdictionList, o.jurisdictionList, true) and compareDeep(purposeElement, o.purposeElement, true) and 
      compareDeep(copyrightElement, o.copyrightElement, true) and compareDeep(keywordList, o.keywordList, true) and 
      compareDeep(fhirVersionElement, o.fhirVersionElement, true) and compareDeep(mappingList, o.mappingList, true) and 
      compareDeep(kindElement, o.kindElement, true) and compareDeep(abstractElement, o.abstractElement, true) and 
      compareDeep(contextList, o.contextList, true) and compareDeep(contextInvariantList, o.contextInvariantList, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(baseDefinitionElement, o.baseDefinitionElement, true) and 
      compareDeep(derivationElement, o.derivationElement, true) and compareDeep(snapshotElement, o.snapshotElement, true) and 
      compareDeep(differentialElement, o.differentialElement, true);
  end;
end;

function TFhirStructureDefinition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FUrl) and isEmptyProp(FidentifierList) and isEmptyProp(FVersion) and isEmptyProp(FName) and isEmptyProp(FTitle) and isEmptyProp(FStatus) and isEmptyProp(FExperimental) and isEmptyProp(FDate) and isEmptyProp(FPublisher) and isEmptyProp(FcontactList) and isEmptyProp(FDescription) and isEmptyProp(FuseContextList) and isEmptyProp(FjurisdictionList) and isEmptyProp(FPurpose) and isEmptyProp(FCopyright) and isEmptyProp(FkeywordList) and isEmptyProp(FFhirVersion) and isEmptyProp(FmappingList) and isEmptyProp(FKind) and isEmptyProp(FAbstract) and isEmptyProp(FcontextList) and isEmptyProp(FcontextInvariantList) and isEmptyProp(FType_) and isEmptyProp(FBaseDefinition) and isEmptyProp(FDerivation) and isEmptyProp(FSnapshot) and isEmptyProp(FDifferential);
end;

procedure TFhirStructureDefinition.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('url');
  fields.add('identifier');
  fields.add('version');
  fields.add('name');
  fields.add('title');
  fields.add('status');
  fields.add('experimental');
  fields.add('date');
  fields.add('publisher');
  fields.add('contact');
  fields.add('description');
  fields.add('useContext');
  fields.add('jurisdiction');
  fields.add('purpose');
  fields.add('copyright');
  fields.add('keyword');
  fields.add('fhirVersion');
  fields.add('mapping');
  fields.add('kind');
  fields.add('abstract');
  fields.add('context');
  fields.add('contextInvariant');
  fields.add('type');
  fields.add('baseDefinition');
  fields.add('derivation');
  fields.add('snapshot');
  fields.add('differential');
end;

function TFhirStructureDefinition.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FContactList.sizeInBytes(magic));
  inc(result, FUseContextList.sizeInBytes(magic));
  inc(result, FJurisdictionList.sizeInBytes(magic));
  inc(result, FKeywordList.sizeInBytes(magic));
  inc(result, FMappingList.sizeInBytes(magic));
  inc(result, FContextList.sizeInBytes(magic));
  inc(result, FContextInvariantList.sizeInBytes(magic));
end;

procedure TFhirStructureDefinition.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

function TFhirStructureDefinition.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

procedure TFhirStructureDefinition.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

function TFhirStructureDefinition.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirStructureDefinition.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirStructureDefinition.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

function TFhirStructureDefinition.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

procedure TFhirStructureDefinition.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

procedure TFhirStructureDefinition.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirStructureDefinition.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirStructureDefinition.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirStructureDefinition.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

function TFhirStructureDefinition.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

procedure TFhirStructureDefinition.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

procedure TFhirStructureDefinition.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirStructureDefinition.GetStatusST : TFhirPublicationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirPublicationStatusEnum(0)
  else
    result := TFhirPublicationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirPublicationStatusEnum, FStatus.value));
end;

procedure TFhirStructureDefinition.SetStatusST(value : TFhirPublicationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[value], CODES_TFhirPublicationStatusEnum[value]);
end;

procedure TFhirStructureDefinition.SetExperimental(value : TFhirBoolean);
begin
  FExperimental.free;
  FExperimental := value;
end;

function TFhirStructureDefinition.GetExperimentalST : Boolean;
begin
  if FExperimental = nil then
    result := false
  else
    result := FExperimental.value;
end;

procedure TFhirStructureDefinition.SetExperimentalST(value : Boolean);
begin
  if FExperimental = nil then
    FExperimental := TFhirBoolean.create;
  FExperimental.value := value
end;

procedure TFhirStructureDefinition.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

function TFhirStructureDefinition.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirStructureDefinition.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

procedure TFhirStructureDefinition.SetPublisher(value : TFhirString);
begin
  FPublisher.free;
  FPublisher := value;
end;

function TFhirStructureDefinition.GetPublisherST : String;
begin
  if FPublisher = nil then
    result := ''
  else
    result := FPublisher.value;
end;

procedure TFhirStructureDefinition.SetPublisherST(value : String);
begin
  if value <> '' then
  begin
    if FPublisher = nil then
      FPublisher := TFhirString.create;
    FPublisher.value := value
  end
  else if FPublisher <> nil then
    FPublisher.value := '';
end;

function TFhirStructureDefinition.GetContactList : TFhirContactDetailList;
begin
  if FContactList = nil then
    FContactList := TFhirContactDetailList.Create;
  result := FContactList;
end;

function TFhirStructureDefinition.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

procedure TFhirStructureDefinition.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirStructureDefinition.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirStructureDefinition.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirStructureDefinition.GetUseContextList : TFhirUsageContextList;
begin
  if FUseContextList = nil then
    FUseContextList := TFhirUsageContextList.Create;
  result := FUseContextList;
end;

function TFhirStructureDefinition.GetHasUseContextList : boolean;
begin
  result := (FUseContextList <> nil) and (FUseContextList.count > 0);
end;

function TFhirStructureDefinition.GetJurisdictionList : TFhirCodeableConceptList;
begin
  if FJurisdictionList = nil then
    FJurisdictionList := TFhirCodeableConceptList.Create;
  result := FJurisdictionList;
end;

function TFhirStructureDefinition.GetHasJurisdictionList : boolean;
begin
  result := (FJurisdictionList <> nil) and (FJurisdictionList.count > 0);
end;

procedure TFhirStructureDefinition.SetPurpose(value : TFhirMarkdown);
begin
  FPurpose.free;
  FPurpose := value;
end;

function TFhirStructureDefinition.GetPurposeST : String;
begin
  if FPurpose = nil then
    result := ''
  else
    result := FPurpose.value;
end;

procedure TFhirStructureDefinition.SetPurposeST(value : String);
begin
  if value <> '' then
  begin
    if FPurpose = nil then
      FPurpose := TFhirMarkdown.create;
    FPurpose.value := value
  end
  else if FPurpose <> nil then
    FPurpose.value := '';
end;

procedure TFhirStructureDefinition.SetCopyright(value : TFhirMarkdown);
begin
  FCopyright.free;
  FCopyright := value;
end;

function TFhirStructureDefinition.GetCopyrightST : String;
begin
  if FCopyright = nil then
    result := ''
  else
    result := FCopyright.value;
end;

procedure TFhirStructureDefinition.SetCopyrightST(value : String);
begin
  if value <> '' then
  begin
    if FCopyright = nil then
      FCopyright := TFhirMarkdown.create;
    FCopyright.value := value
  end
  else if FCopyright <> nil then
    FCopyright.value := '';
end;

function TFhirStructureDefinition.GetKeywordList : TFhirCodingList;
begin
  if FKeywordList = nil then
    FKeywordList := TFhirCodingList.Create;
  result := FKeywordList;
end;

function TFhirStructureDefinition.GetHasKeywordList : boolean;
begin
  result := (FKeywordList <> nil) and (FKeywordList.count > 0);
end;

procedure TFhirStructureDefinition.SetFhirVersion(value : TFhirEnum);
begin
  FFhirVersion.free;
  FFhirVersion := value;
end;

function TFhirStructureDefinition.GetFhirVersionST : TFhirFHIRVersionEnum;
begin
  if FFhirVersion = nil then
    result := TFhirFHIRVersionEnum(0)
  else
    result := TFhirFHIRVersionEnum(StringArrayIndexOfSensitive(CODES_TFhirFHIRVersionEnum, FFhirVersion.value));
end;

procedure TFhirStructureDefinition.SetFhirVersionST(value : TFhirFHIRVersionEnum);
begin
  if ord(value) = 0 then
    FhirVersionElement := nil
  else
    FhirVersionElement := TFhirEnum.create(SYSTEMS_TFhirFHIRVersionEnum[value], CODES_TFhirFHIRVersionEnum[value]);
end;

function TFhirStructureDefinition.GetMappingList : TFhirStructureDefinitionMappingList;
begin
  if FMappingList = nil then
    FMappingList := TFhirStructureDefinitionMappingList.Create;
  result := FMappingList;
end;

function TFhirStructureDefinition.GetHasMappingList : boolean;
begin
  result := (FMappingList <> nil) and (FMappingList.count > 0);
end;

procedure TFhirStructureDefinition.SetKind(value : TFhirEnum);
begin
  FKind.free;
  FKind := value;
end;

function TFhirStructureDefinition.GetKindST : TFhirStructureDefinitionKindEnum;
begin
  if FKind = nil then
    result := TFhirStructureDefinitionKindEnum(0)
  else
    result := TFhirStructureDefinitionKindEnum(StringArrayIndexOfSensitive(CODES_TFhirStructureDefinitionKindEnum, FKind.value));
end;

procedure TFhirStructureDefinition.SetKindST(value : TFhirStructureDefinitionKindEnum);
begin
  if ord(value) = 0 then
    KindElement := nil
  else
    KindElement := TFhirEnum.create(SYSTEMS_TFhirStructureDefinitionKindEnum[value], CODES_TFhirStructureDefinitionKindEnum[value]);
end;

procedure TFhirStructureDefinition.SetAbstract(value : TFhirBoolean);
begin
  FAbstract.free;
  FAbstract := value;
end;

function TFhirStructureDefinition.GetAbstractST : Boolean;
begin
  if FAbstract = nil then
    result := false
  else
    result := FAbstract.value;
end;

procedure TFhirStructureDefinition.SetAbstractST(value : Boolean);
begin
  if FAbstract = nil then
    FAbstract := TFhirBoolean.create;
  FAbstract.value := value
end;

function TFhirStructureDefinition.GetContextList : TFhirStructureDefinitionContextList;
begin
  if FContextList = nil then
    FContextList := TFhirStructureDefinitionContextList.Create;
  result := FContextList;
end;

function TFhirStructureDefinition.GetHasContextList : boolean;
begin
  result := (FContextList <> nil) and (FContextList.count > 0);
end;

function TFhirStructureDefinition.GetContextInvariantList : TFhirStringList;
begin
  if FContextInvariantList = nil then
    FContextInvariantList := TFhirStringList.Create;
  result := FContextInvariantList;
end;

function TFhirStructureDefinition.GetHasContextInvariantList : boolean;
begin
  result := (FContextInvariantList <> nil) and (FContextInvariantList.count > 0);
end;

procedure TFhirStructureDefinition.SetType_(value : TFhirUri);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirStructureDefinition.GetType_ST : String;
begin
  if FType_ = nil then
    result := ''
  else
    result := FType_.value;
end;

procedure TFhirStructureDefinition.SetType_ST(value : String);
begin
  if value <> '' then
  begin
    if FType_ = nil then
      FType_ := TFhirUri.create;
    FType_.value := value
  end
  else if FType_ <> nil then
    FType_.value := '';
end;

procedure TFhirStructureDefinition.SetBaseDefinition(value : TFhirCanonical);
begin
  FBaseDefinition.free;
  FBaseDefinition := value;
end;

function TFhirStructureDefinition.GetBaseDefinitionST : String;
begin
  if FBaseDefinition = nil then
    result := ''
  else
    result := FBaseDefinition.value;
end;

procedure TFhirStructureDefinition.SetBaseDefinitionST(value : String);
begin
  if value <> '' then
  begin
    if FBaseDefinition = nil then
      FBaseDefinition := TFhirCanonical.create;
    FBaseDefinition.value := value
  end
  else if FBaseDefinition <> nil then
    FBaseDefinition.value := '';
end;

procedure TFhirStructureDefinition.SetDerivation(value : TFhirEnum);
begin
  FDerivation.free;
  FDerivation := value;
end;

function TFhirStructureDefinition.GetDerivationST : TFhirTypeDerivationRuleEnum;
begin
  if FDerivation = nil then
    result := TFhirTypeDerivationRuleEnum(0)
  else
    result := TFhirTypeDerivationRuleEnum(StringArrayIndexOfSensitive(CODES_TFhirTypeDerivationRuleEnum, FDerivation.value));
end;

procedure TFhirStructureDefinition.SetDerivationST(value : TFhirTypeDerivationRuleEnum);
begin
  if ord(value) = 0 then
    DerivationElement := nil
  else
    DerivationElement := TFhirEnum.create(SYSTEMS_TFhirTypeDerivationRuleEnum[value], CODES_TFhirTypeDerivationRuleEnum[value]);
end;

procedure TFhirStructureDefinition.SetSnapshot(value : TFhirStructureDefinitionSnapshot);
begin
  FSnapshot.free;
  FSnapshot := value;
end;

procedure TFhirStructureDefinition.SetDifferential(value : TFhirStructureDefinitionDifferential);
begin
  FDifferential.free;
  FDifferential := value;
end;

{ TFhirStructureDefinitionListEnumerator }

constructor TFhirStructureDefinitionListEnumerator.Create(list : TFhirStructureDefinitionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirStructureDefinitionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirStructureDefinitionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirStructureDefinitionListEnumerator.GetCurrent : TFhirStructureDefinition;
begin
  Result := FList[FIndex];
end;

function TFhirStructureDefinitionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirStructureDefinitionList }

function TFhirStructureDefinitionList.AddItem(value: TFhirStructureDefinition): TFhirStructureDefinition;
begin
  assert(value.ClassName = 'TFhirStructureDefinition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirStructureDefinition');
  add(value);
  result := value;
end;

function TFhirStructureDefinitionList.Append: TFhirStructureDefinition;
begin
  result := TFhirStructureDefinition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirStructureDefinitionList.ClearItems;
begin
  Clear;
end;

function TFhirStructureDefinitionList.GetEnumerator : TFhirStructureDefinitionListEnumerator;
begin
  result := TFhirStructureDefinitionListEnumerator.Create(self.link);
end;

function TFhirStructureDefinitionList.Clone: TFhirStructureDefinitionList;
begin
  result := TFhirStructureDefinitionList(inherited Clone);
end;

function TFhirStructureDefinitionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirStructureDefinitionList.GetItemN(index: Integer): TFhirStructureDefinition;
begin
  result := TFhirStructureDefinition(ObjectByIndex[index]);
end;

function TFhirStructureDefinitionList.ItemClass: TFslObjectClass;
begin
  result := TFhirStructureDefinition;
end;
function TFhirStructureDefinitionList.IndexOf(value: TFhirStructureDefinition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirStructureDefinitionList.Insert(index: Integer): TFhirStructureDefinition;
begin
  result := TFhirStructureDefinition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirStructureDefinitionList.InsertItem(index: Integer; value: TFhirStructureDefinition);
begin
  assert(value is TFhirStructureDefinition);
  Inherited Insert(index, value);
end;

function TFhirStructureDefinitionList.Item(index: Integer): TFhirStructureDefinition;
begin
  result := TFhirStructureDefinition(ObjectByIndex[index]);
end;

function TFhirStructureDefinitionList.Link: TFhirStructureDefinitionList;
begin
  result := TFhirStructureDefinitionList(inherited Link);
end;

procedure TFhirStructureDefinitionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirStructureDefinitionList.SetItemByIndex(index: Integer; value: TFhirStructureDefinition);
begin
  assert(value is TFhirStructureDefinition);
  FhirStructureDefinitions[index] := value;
end;

procedure TFhirStructureDefinitionList.SetItemN(index: Integer; value: TFhirStructureDefinition);
begin
  assert(value is TFhirStructureDefinition);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_STRUCTUREDEFINITION}
{$IFDEF FHIR_STRUCTUREMAP}
{ TFhirStructureMapStructure }

constructor TFhirStructureMapStructure.Create;
begin
  inherited;
end;

destructor TFhirStructureMapStructure.Destroy;
begin
  FUrl.free;
  FMode.free;
  FAlias.free;
  FDocumentation.free;
  inherited;
end;

procedure TFhirStructureMapStructure.Assign(oSource : TFslObject);
begin
  inherited;
  urlElement := TFhirStructureMapStructure(oSource).urlElement.Clone;
  modeElement := TFhirStructureMapStructure(oSource).modeElement.Clone;
  aliasElement := TFhirStructureMapStructure(oSource).aliasElement.Clone;
  documentationElement := TFhirStructureMapStructure(oSource).documentationElement.Clone;
end;

procedure TFhirStructureMapStructure.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
  if (child_name = 'mode') Then
     list.add(self.link, 'mode', FMode.Link);
  if (child_name = 'alias') Then
     list.add(self.link, 'alias', FAlias.Link);
  if (child_name = 'documentation') Then
     list.add(self.link, 'documentation', FDocumentation.Link);
end;

procedure TFhirStructureMapStructure.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'url', 'canonical', false, TFhirCanonical, FUrl.Link));
  oList.add(TFHIRProperty.create(self, 'mode', 'code', false, TFhirEnum, FMode.Link));
  oList.add(TFHIRProperty.create(self, 'alias', 'string', false, TFhirString, FAlias.Link));
  oList.add(TFHIRProperty.create(self, 'documentation', 'string', false, TFhirString, FDocumentation.Link));
end;

function TFhirStructureMapStructure.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'url') then
  begin
    UrlElement := asCanonical(propValue);
    result := propValue;
  end
  else if (propName = 'mode') then
  begin
    ModeElement := asEnum(SYSTEMS_TFhirStructureMapModelModeEnum, CODES_TFhirStructureMapModelModeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'alias') then
  begin
    AliasElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'documentation') then
  begin
    DocumentationElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirStructureMapStructure.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirStructureMapStructure.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'url') then result := TFhirCanonical.create()
  else if (propName = 'mode') then result := TFhirEnum.create(SYSTEMS_TFhirStructureMapModelModeEnum[StructureMapModelModeNull], CODES_TFhirStructureMapModelModeEnum[StructureMapModelModeNull]) 
  else if (propName = 'alias') then result := TFhirString.create()
  else if (propName = 'documentation') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirStructureMapStructure.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'url') then result := 'canonical'
  else if (propName = 'mode') then result := 'code'
  else if (propName = 'alias') then result := 'string'
  else if (propName = 'documentation') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirStructureMapStructure.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := nil
  else if (propName = 'mode') then ModeElement := nil
  else if (propName = 'alias') then AliasElement := nil
  else if (propName = 'documentation') then DocumentationElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirStructureMapStructure.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := asCanonical(new)
  else if (propName = 'mode') then ModeElement := asEnum(SYSTEMS_TFhirStructureMapModelModeEnum, CODES_TFhirStructureMapModelModeEnum, new)
  else if (propName = 'alias') then AliasElement := asString(new)
  else if (propName = 'documentation') then DocumentationElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirStructureMapStructure.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirStructureMapStructure.fhirType : string;
begin
  result := 'StructureMap.structure';
end;

function TFhirStructureMapStructure.Link : TFhirStructureMapStructure;
begin
  result := TFhirStructureMapStructure(inherited Link);
end;

function TFhirStructureMapStructure.Clone : TFhirStructureMapStructure;
begin
  result := TFhirStructureMapStructure(inherited Clone);
end;

function TFhirStructureMapStructure.equals(other : TObject) : boolean; 
var
  o : TFhirStructureMapStructure;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirStructureMapStructure)) then
    result := false
  else
  begin
    o := TFhirStructureMapStructure(other);
    result := compareDeep(urlElement, o.urlElement, true) and compareDeep(modeElement, o.modeElement, true) and 
      compareDeep(aliasElement, o.aliasElement, true) and compareDeep(documentationElement, o.documentationElement, true);
  end;
end;

function TFhirStructureMapStructure.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FUrl) and isEmptyProp(FMode) and isEmptyProp(FAlias) and isEmptyProp(FDocumentation);
end;

procedure TFhirStructureMapStructure.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('url');
  fields.add('mode');
  fields.add('alias');
  fields.add('documentation');
end;

function TFhirStructureMapStructure.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirStructureMapStructure.SetUrl(value : TFhirCanonical);
begin
  FUrl.free;
  FUrl := value;
end;

function TFhirStructureMapStructure.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

procedure TFhirStructureMapStructure.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirCanonical.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

procedure TFhirStructureMapStructure.SetMode(value : TFhirEnum);
begin
  FMode.free;
  FMode := value;
end;

function TFhirStructureMapStructure.GetModeST : TFhirStructureMapModelModeEnum;
begin
  if FMode = nil then
    result := TFhirStructureMapModelModeEnum(0)
  else
    result := TFhirStructureMapModelModeEnum(StringArrayIndexOfSensitive(CODES_TFhirStructureMapModelModeEnum, FMode.value));
end;

procedure TFhirStructureMapStructure.SetModeST(value : TFhirStructureMapModelModeEnum);
begin
  if ord(value) = 0 then
    ModeElement := nil
  else
    ModeElement := TFhirEnum.create(SYSTEMS_TFhirStructureMapModelModeEnum[value], CODES_TFhirStructureMapModelModeEnum[value]);
end;

procedure TFhirStructureMapStructure.SetAlias(value : TFhirString);
begin
  FAlias.free;
  FAlias := value;
end;

function TFhirStructureMapStructure.GetAliasST : String;
begin
  if FAlias = nil then
    result := ''
  else
    result := FAlias.value;
end;

procedure TFhirStructureMapStructure.SetAliasST(value : String);
begin
  if value <> '' then
  begin
    if FAlias = nil then
      FAlias := TFhirString.create;
    FAlias.value := value
  end
  else if FAlias <> nil then
    FAlias.value := '';
end;

procedure TFhirStructureMapStructure.SetDocumentation(value : TFhirString);
begin
  FDocumentation.free;
  FDocumentation := value;
end;

function TFhirStructureMapStructure.GetDocumentationST : String;
begin
  if FDocumentation = nil then
    result := ''
  else
    result := FDocumentation.value;
end;

procedure TFhirStructureMapStructure.SetDocumentationST(value : String);
begin
  if value <> '' then
  begin
    if FDocumentation = nil then
      FDocumentation := TFhirString.create;
    FDocumentation.value := value
  end
  else if FDocumentation <> nil then
    FDocumentation.value := '';
end;

{ TFhirStructureMapStructureListEnumerator }

constructor TFhirStructureMapStructureListEnumerator.Create(list : TFhirStructureMapStructureList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirStructureMapStructureListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirStructureMapStructureListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirStructureMapStructureListEnumerator.GetCurrent : TFhirStructureMapStructure;
begin
  Result := FList[FIndex];
end;

function TFhirStructureMapStructureListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirStructureMapStructureList }

function TFhirStructureMapStructureList.AddItem(value: TFhirStructureMapStructure): TFhirStructureMapStructure;
begin
  assert(value.ClassName = 'TFhirStructureMapStructure', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirStructureMapStructure');
  add(value);
  result := value;
end;

function TFhirStructureMapStructureList.Append: TFhirStructureMapStructure;
begin
  result := TFhirStructureMapStructure.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirStructureMapStructureList.ClearItems;
begin
  Clear;
end;

function TFhirStructureMapStructureList.GetEnumerator : TFhirStructureMapStructureListEnumerator;
begin
  result := TFhirStructureMapStructureListEnumerator.Create(self.link);
end;

function TFhirStructureMapStructureList.Clone: TFhirStructureMapStructureList;
begin
  result := TFhirStructureMapStructureList(inherited Clone);
end;

function TFhirStructureMapStructureList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirStructureMapStructureList.GetItemN(index: Integer): TFhirStructureMapStructure;
begin
  result := TFhirStructureMapStructure(ObjectByIndex[index]);
end;

function TFhirStructureMapStructureList.ItemClass: TFslObjectClass;
begin
  result := TFhirStructureMapStructure;
end;
function TFhirStructureMapStructureList.IndexOf(value: TFhirStructureMapStructure): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirStructureMapStructureList.Insert(index: Integer): TFhirStructureMapStructure;
begin
  result := TFhirStructureMapStructure.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirStructureMapStructureList.InsertItem(index: Integer; value: TFhirStructureMapStructure);
begin
  assert(value is TFhirStructureMapStructure);
  Inherited Insert(index, value);
end;

function TFhirStructureMapStructureList.Item(index: Integer): TFhirStructureMapStructure;
begin
  result := TFhirStructureMapStructure(ObjectByIndex[index]);
end;

function TFhirStructureMapStructureList.Link: TFhirStructureMapStructureList;
begin
  result := TFhirStructureMapStructureList(inherited Link);
end;

procedure TFhirStructureMapStructureList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirStructureMapStructureList.SetItemByIndex(index: Integer; value: TFhirStructureMapStructure);
begin
  assert(value is TFhirStructureMapStructure);
  FhirStructureMapStructures[index] := value;
end;

procedure TFhirStructureMapStructureList.SetItemN(index: Integer; value: TFhirStructureMapStructure);
begin
  assert(value is TFhirStructureMapStructure);
  ObjectByIndex[index] := value;
end;

{ TFhirStructureMapGroup }

constructor TFhirStructureMapGroup.Create;
begin
  inherited;
end;

destructor TFhirStructureMapGroup.Destroy;
begin
  FName.free;
  FExtends.free;
  FTypeMode.free;
  FDocumentation.free;
  FInputList.Free;
  FRuleList.Free;
  inherited;
end;

procedure TFhirStructureMapGroup.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirStructureMapGroup(oSource).nameElement.Clone;
  extendsElement := TFhirStructureMapGroup(oSource).extendsElement.Clone;
  typeModeElement := TFhirStructureMapGroup(oSource).typeModeElement.Clone;
  documentationElement := TFhirStructureMapGroup(oSource).documentationElement.Clone;
  if (TFhirStructureMapGroup(oSource).FInputList = nil) then
  begin
    FInputList.free;
    FInputList := nil;
  end
  else
  begin
    if FInputList = nil then
      FInputList := TFhirStructureMapGroupInputList.Create;
    FInputList.Assign(TFhirStructureMapGroup(oSource).FInputList);
  end;
  if (TFhirStructureMapGroup(oSource).FRuleList = nil) then
  begin
    FRuleList.free;
    FRuleList := nil;
  end
  else
  begin
    if FRuleList = nil then
      FRuleList := TFhirStructureMapGroupRuleList.Create;
    FRuleList.Assign(TFhirStructureMapGroup(oSource).FRuleList);
  end;
end;

procedure TFhirStructureMapGroup.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'extends') Then
     list.add(self.link, 'extends', FExtends.Link);
  if (child_name = 'typeMode') Then
     list.add(self.link, 'typeMode', FTypeMode.Link);
  if (child_name = 'documentation') Then
     list.add(self.link, 'documentation', FDocumentation.Link);
  if (child_name = 'input') Then
    list.addAll(self, 'input', FInputList);
  if (child_name = 'rule') Then
    list.addAll(self, 'rule', FRuleList);
end;

procedure TFhirStructureMapGroup.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'id', false, TFhirId, FName.Link));
  oList.add(TFHIRProperty.create(self, 'extends', 'id', false, TFhirId, FExtends.Link));
  oList.add(TFHIRProperty.create(self, 'typeMode', 'code', false, TFhirEnum, FTypeMode.Link));
  oList.add(TFHIRProperty.create(self, 'documentation', 'string', false, TFhirString, FDocumentation.Link));
  oList.add(TFHIRProperty.create(self, 'input', 'BackboneElement', true, TFhirStructureMapGroupInput, FInputList.Link));
  oList.add(TFHIRProperty.create(self, 'rule', 'BackboneElement', true, TFhirStructureMapGroupRule, FRuleList.Link));
end;

function TFhirStructureMapGroup.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asId(propValue);
    result := propValue;
  end
  else if (propName = 'extends') then
  begin
    ExtendsElement := asId(propValue);
    result := propValue;
  end
  else if (propName = 'typeMode') then
  begin
    TypeModeElement := asEnum(SYSTEMS_TFhirStructureMapGroupTypeModeEnum, CODES_TFhirStructureMapGroupTypeModeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'documentation') then
  begin
    DocumentationElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'input') then
  begin
    InputList.add(propValue as TFhirStructureMapGroupInput);
    result := propValue;
  end
  else if (propName = 'rule') then
  begin
    RuleList.add(propValue as TFhirStructureMapGroupRule);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirStructureMapGroup.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'input') then InputList.insertItem(index, propValue as TFhirStructureMapGroupInput)
  else if (propName = 'rule') then RuleList.insertItem(index, propValue as TFhirStructureMapGroupRule)
  else inherited;
end;

function TFhirStructureMapGroup.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirId.create()
  else if (propName = 'extends') then result := TFhirId.create()
  else if (propName = 'typeMode') then result := TFhirEnum.create(SYSTEMS_TFhirStructureMapGroupTypeModeEnum[StructureMapGroupTypeModeNull], CODES_TFhirStructureMapGroupTypeModeEnum[StructureMapGroupTypeModeNull]) 
  else if (propName = 'documentation') then result := TFhirString.create()
  else if (propName = 'input') then result := InputList.new()
  else if (propName = 'rule') then result := RuleList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirStructureMapGroup.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'id'
  else if (propName = 'extends') then result := 'id'
  else if (propName = 'typeMode') then result := 'code'
  else if (propName = 'documentation') then result := 'string'
  else if (propName = 'input') then result := 'BackboneElement'
  else if (propName = 'rule') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirStructureMapGroup.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'extends') then ExtendsElement := nil
  else if (propName = 'typeMode') then TypeModeElement := nil
  else if (propName = 'documentation') then DocumentationElement := nil
  else if (propName = 'input') then deletePropertyValue('input', InputList, value)
  else if (propName = 'rule') then deletePropertyValue('rule', RuleList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirStructureMapGroup.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asId(new)
  else if (propName = 'extends') then ExtendsElement := asId(new)
  else if (propName = 'typeMode') then TypeModeElement := asEnum(SYSTEMS_TFhirStructureMapGroupTypeModeEnum, CODES_TFhirStructureMapGroupTypeModeEnum, new)
  else if (propName = 'documentation') then DocumentationElement := asString(new)
  else if (propName = 'input') then replacePropertyValue('input', InputList, existing, new)
  else if (propName = 'rule') then replacePropertyValue('rule', RuleList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirStructureMapGroup.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'input') then InputList.move(source, destination)
  else if (propName = 'rule') then RuleList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirStructureMapGroup.fhirType : string;
begin
  result := 'StructureMap.group';
end;

function TFhirStructureMapGroup.Link : TFhirStructureMapGroup;
begin
  result := TFhirStructureMapGroup(inherited Link);
end;

function TFhirStructureMapGroup.Clone : TFhirStructureMapGroup;
begin
  result := TFhirStructureMapGroup(inherited Clone);
end;

function TFhirStructureMapGroup.equals(other : TObject) : boolean; 
var
  o : TFhirStructureMapGroup;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirStructureMapGroup)) then
    result := false
  else
  begin
    o := TFhirStructureMapGroup(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(extendsElement, o.extendsElement, true) and 
      compareDeep(typeModeElement, o.typeModeElement, true) and compareDeep(documentationElement, o.documentationElement, true) and 
      compareDeep(inputList, o.inputList, true) and compareDeep(ruleList, o.ruleList, true);
  end;
end;

function TFhirStructureMapGroup.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FExtends) and isEmptyProp(FTypeMode) and isEmptyProp(FDocumentation) and isEmptyProp(FinputList) and isEmptyProp(FruleList);
end;

procedure TFhirStructureMapGroup.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('name');
  fields.add('extends');
  fields.add('typeMode');
  fields.add('documentation');
  fields.add('input');
  fields.add('rule');
end;

function TFhirStructureMapGroup.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FInputList.sizeInBytes(magic));
  inc(result, FRuleList.sizeInBytes(magic));
end;

procedure TFhirStructureMapGroup.SetName(value : TFhirId);
begin
  FName.free;
  FName := value;
end;

function TFhirStructureMapGroup.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirStructureMapGroup.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirId.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirStructureMapGroup.SetExtends(value : TFhirId);
begin
  FExtends.free;
  FExtends := value;
end;

function TFhirStructureMapGroup.GetExtendsST : String;
begin
  if FExtends = nil then
    result := ''
  else
    result := FExtends.value;
end;

procedure TFhirStructureMapGroup.SetExtendsST(value : String);
begin
  if value <> '' then
  begin
    if FExtends = nil then
      FExtends := TFhirId.create;
    FExtends.value := value
  end
  else if FExtends <> nil then
    FExtends.value := '';
end;

procedure TFhirStructureMapGroup.SetTypeMode(value : TFhirEnum);
begin
  FTypeMode.free;
  FTypeMode := value;
end;

function TFhirStructureMapGroup.GetTypeModeST : TFhirStructureMapGroupTypeModeEnum;
begin
  if FTypeMode = nil then
    result := TFhirStructureMapGroupTypeModeEnum(0)
  else
    result := TFhirStructureMapGroupTypeModeEnum(StringArrayIndexOfSensitive(CODES_TFhirStructureMapGroupTypeModeEnum, FTypeMode.value));
end;

procedure TFhirStructureMapGroup.SetTypeModeST(value : TFhirStructureMapGroupTypeModeEnum);
begin
  if ord(value) = 0 then
    TypeModeElement := nil
  else
    TypeModeElement := TFhirEnum.create(SYSTEMS_TFhirStructureMapGroupTypeModeEnum[value], CODES_TFhirStructureMapGroupTypeModeEnum[value]);
end;

procedure TFhirStructureMapGroup.SetDocumentation(value : TFhirString);
begin
  FDocumentation.free;
  FDocumentation := value;
end;

function TFhirStructureMapGroup.GetDocumentationST : String;
begin
  if FDocumentation = nil then
    result := ''
  else
    result := FDocumentation.value;
end;

procedure TFhirStructureMapGroup.SetDocumentationST(value : String);
begin
  if value <> '' then
  begin
    if FDocumentation = nil then
      FDocumentation := TFhirString.create;
    FDocumentation.value := value
  end
  else if FDocumentation <> nil then
    FDocumentation.value := '';
end;

function TFhirStructureMapGroup.GetInputList : TFhirStructureMapGroupInputList;
begin
  if FInputList = nil then
    FInputList := TFhirStructureMapGroupInputList.Create;
  result := FInputList;
end;

function TFhirStructureMapGroup.GetHasInputList : boolean;
begin
  result := (FInputList <> nil) and (FInputList.count > 0);
end;

function TFhirStructureMapGroup.GetRuleList : TFhirStructureMapGroupRuleList;
begin
  if FRuleList = nil then
    FRuleList := TFhirStructureMapGroupRuleList.Create;
  result := FRuleList;
end;

function TFhirStructureMapGroup.GetHasRuleList : boolean;
begin
  result := (FRuleList <> nil) and (FRuleList.count > 0);
end;

{ TFhirStructureMapGroupListEnumerator }

constructor TFhirStructureMapGroupListEnumerator.Create(list : TFhirStructureMapGroupList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirStructureMapGroupListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirStructureMapGroupListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirStructureMapGroupListEnumerator.GetCurrent : TFhirStructureMapGroup;
begin
  Result := FList[FIndex];
end;

function TFhirStructureMapGroupListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirStructureMapGroupList }

function TFhirStructureMapGroupList.AddItem(value: TFhirStructureMapGroup): TFhirStructureMapGroup;
begin
  assert(value.ClassName = 'TFhirStructureMapGroup', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirStructureMapGroup');
  add(value);
  result := value;
end;

function TFhirStructureMapGroupList.Append: TFhirStructureMapGroup;
begin
  result := TFhirStructureMapGroup.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirStructureMapGroupList.ClearItems;
begin
  Clear;
end;

function TFhirStructureMapGroupList.GetEnumerator : TFhirStructureMapGroupListEnumerator;
begin
  result := TFhirStructureMapGroupListEnumerator.Create(self.link);
end;

function TFhirStructureMapGroupList.Clone: TFhirStructureMapGroupList;
begin
  result := TFhirStructureMapGroupList(inherited Clone);
end;

function TFhirStructureMapGroupList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirStructureMapGroupList.GetItemN(index: Integer): TFhirStructureMapGroup;
begin
  result := TFhirStructureMapGroup(ObjectByIndex[index]);
end;

function TFhirStructureMapGroupList.ItemClass: TFslObjectClass;
begin
  result := TFhirStructureMapGroup;
end;
function TFhirStructureMapGroupList.IndexOf(value: TFhirStructureMapGroup): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirStructureMapGroupList.Insert(index: Integer): TFhirStructureMapGroup;
begin
  result := TFhirStructureMapGroup.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirStructureMapGroupList.InsertItem(index: Integer; value: TFhirStructureMapGroup);
begin
  assert(value is TFhirStructureMapGroup);
  Inherited Insert(index, value);
end;

function TFhirStructureMapGroupList.Item(index: Integer): TFhirStructureMapGroup;
begin
  result := TFhirStructureMapGroup(ObjectByIndex[index]);
end;

function TFhirStructureMapGroupList.Link: TFhirStructureMapGroupList;
begin
  result := TFhirStructureMapGroupList(inherited Link);
end;

procedure TFhirStructureMapGroupList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirStructureMapGroupList.SetItemByIndex(index: Integer; value: TFhirStructureMapGroup);
begin
  assert(value is TFhirStructureMapGroup);
  FhirStructureMapGroups[index] := value;
end;

procedure TFhirStructureMapGroupList.SetItemN(index: Integer; value: TFhirStructureMapGroup);
begin
  assert(value is TFhirStructureMapGroup);
  ObjectByIndex[index] := value;
end;

{ TFhirStructureMapGroupInput }

constructor TFhirStructureMapGroupInput.Create;
begin
  inherited;
end;

destructor TFhirStructureMapGroupInput.Destroy;
begin
  FName.free;
  FType_.free;
  FMode.free;
  FDocumentation.free;
  inherited;
end;

procedure TFhirStructureMapGroupInput.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirStructureMapGroupInput(oSource).nameElement.Clone;
  type_Element := TFhirStructureMapGroupInput(oSource).type_Element.Clone;
  modeElement := TFhirStructureMapGroupInput(oSource).modeElement.Clone;
  documentationElement := TFhirStructureMapGroupInput(oSource).documentationElement.Clone;
end;

procedure TFhirStructureMapGroupInput.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'mode') Then
     list.add(self.link, 'mode', FMode.Link);
  if (child_name = 'documentation') Then
     list.add(self.link, 'documentation', FDocumentation.Link);
end;

procedure TFhirStructureMapGroupInput.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'id', false, TFhirId, FName.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'string', false, TFhirString, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'mode', 'code', false, TFhirEnum, FMode.Link));
  oList.add(TFHIRProperty.create(self, 'documentation', 'string', false, TFhirString, FDocumentation.Link));
end;

function TFhirStructureMapGroupInput.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asId(propValue);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_Element := asString(propValue);
    result := propValue;
  end
  else if (propName = 'mode') then
  begin
    ModeElement := asEnum(SYSTEMS_TFhirStructureMapInputModeEnum, CODES_TFhirStructureMapInputModeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'documentation') then
  begin
    DocumentationElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirStructureMapGroupInput.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirStructureMapGroupInput.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirId.create()
  else if (propName = 'type') then result := TFhirString.create()
  else if (propName = 'mode') then result := TFhirEnum.create(SYSTEMS_TFhirStructureMapInputModeEnum[StructureMapInputModeNull], CODES_TFhirStructureMapInputModeEnum[StructureMapInputModeNull]) 
  else if (propName = 'documentation') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirStructureMapGroupInput.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'id'
  else if (propName = 'type') then result := 'string'
  else if (propName = 'mode') then result := 'code'
  else if (propName = 'documentation') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirStructureMapGroupInput.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'mode') then ModeElement := nil
  else if (propName = 'documentation') then DocumentationElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirStructureMapGroupInput.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asId(new)
  else if (propName = 'type') then Type_Element := asString(new)
  else if (propName = 'mode') then ModeElement := asEnum(SYSTEMS_TFhirStructureMapInputModeEnum, CODES_TFhirStructureMapInputModeEnum, new)
  else if (propName = 'documentation') then DocumentationElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirStructureMapGroupInput.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirStructureMapGroupInput.fhirType : string;
begin
  result := 'StructureMap.group.input';
end;

function TFhirStructureMapGroupInput.Link : TFhirStructureMapGroupInput;
begin
  result := TFhirStructureMapGroupInput(inherited Link);
end;

function TFhirStructureMapGroupInput.Clone : TFhirStructureMapGroupInput;
begin
  result := TFhirStructureMapGroupInput(inherited Clone);
end;

function TFhirStructureMapGroupInput.equals(other : TObject) : boolean; 
var
  o : TFhirStructureMapGroupInput;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirStructureMapGroupInput)) then
    result := false
  else
  begin
    o := TFhirStructureMapGroupInput(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(modeElement, o.modeElement, true) and compareDeep(documentationElement, o.documentationElement, true);
  end;
end;

function TFhirStructureMapGroupInput.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FType_) and isEmptyProp(FMode) and isEmptyProp(FDocumentation);
end;

procedure TFhirStructureMapGroupInput.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('name');
  fields.add('type');
  fields.add('mode');
  fields.add('documentation');
end;

function TFhirStructureMapGroupInput.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirStructureMapGroupInput.SetName(value : TFhirId);
begin
  FName.free;
  FName := value;
end;

function TFhirStructureMapGroupInput.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirStructureMapGroupInput.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirId.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirStructureMapGroupInput.SetType_(value : TFhirString);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirStructureMapGroupInput.GetType_ST : String;
begin
  if FType_ = nil then
    result := ''
  else
    result := FType_.value;
end;

procedure TFhirStructureMapGroupInput.SetType_ST(value : String);
begin
  if value <> '' then
  begin
    if FType_ = nil then
      FType_ := TFhirString.create;
    FType_.value := value
  end
  else if FType_ <> nil then
    FType_.value := '';
end;

procedure TFhirStructureMapGroupInput.SetMode(value : TFhirEnum);
begin
  FMode.free;
  FMode := value;
end;

function TFhirStructureMapGroupInput.GetModeST : TFhirStructureMapInputModeEnum;
begin
  if FMode = nil then
    result := TFhirStructureMapInputModeEnum(0)
  else
    result := TFhirStructureMapInputModeEnum(StringArrayIndexOfSensitive(CODES_TFhirStructureMapInputModeEnum, FMode.value));
end;

procedure TFhirStructureMapGroupInput.SetModeST(value : TFhirStructureMapInputModeEnum);
begin
  if ord(value) = 0 then
    ModeElement := nil
  else
    ModeElement := TFhirEnum.create(SYSTEMS_TFhirStructureMapInputModeEnum[value], CODES_TFhirStructureMapInputModeEnum[value]);
end;

procedure TFhirStructureMapGroupInput.SetDocumentation(value : TFhirString);
begin
  FDocumentation.free;
  FDocumentation := value;
end;

function TFhirStructureMapGroupInput.GetDocumentationST : String;
begin
  if FDocumentation = nil then
    result := ''
  else
    result := FDocumentation.value;
end;

procedure TFhirStructureMapGroupInput.SetDocumentationST(value : String);
begin
  if value <> '' then
  begin
    if FDocumentation = nil then
      FDocumentation := TFhirString.create;
    FDocumentation.value := value
  end
  else if FDocumentation <> nil then
    FDocumentation.value := '';
end;

{ TFhirStructureMapGroupInputListEnumerator }

constructor TFhirStructureMapGroupInputListEnumerator.Create(list : TFhirStructureMapGroupInputList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirStructureMapGroupInputListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirStructureMapGroupInputListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirStructureMapGroupInputListEnumerator.GetCurrent : TFhirStructureMapGroupInput;
begin
  Result := FList[FIndex];
end;

function TFhirStructureMapGroupInputListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirStructureMapGroupInputList }

function TFhirStructureMapGroupInputList.AddItem(value: TFhirStructureMapGroupInput): TFhirStructureMapGroupInput;
begin
  assert(value.ClassName = 'TFhirStructureMapGroupInput', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirStructureMapGroupInput');
  add(value);
  result := value;
end;

function TFhirStructureMapGroupInputList.Append: TFhirStructureMapGroupInput;
begin
  result := TFhirStructureMapGroupInput.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirStructureMapGroupInputList.ClearItems;
begin
  Clear;
end;

function TFhirStructureMapGroupInputList.GetEnumerator : TFhirStructureMapGroupInputListEnumerator;
begin
  result := TFhirStructureMapGroupInputListEnumerator.Create(self.link);
end;

function TFhirStructureMapGroupInputList.Clone: TFhirStructureMapGroupInputList;
begin
  result := TFhirStructureMapGroupInputList(inherited Clone);
end;

function TFhirStructureMapGroupInputList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirStructureMapGroupInputList.GetItemN(index: Integer): TFhirStructureMapGroupInput;
begin
  result := TFhirStructureMapGroupInput(ObjectByIndex[index]);
end;

function TFhirStructureMapGroupInputList.ItemClass: TFslObjectClass;
begin
  result := TFhirStructureMapGroupInput;
end;
function TFhirStructureMapGroupInputList.IndexOf(value: TFhirStructureMapGroupInput): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirStructureMapGroupInputList.Insert(index: Integer): TFhirStructureMapGroupInput;
begin
  result := TFhirStructureMapGroupInput.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirStructureMapGroupInputList.InsertItem(index: Integer; value: TFhirStructureMapGroupInput);
begin
  assert(value is TFhirStructureMapGroupInput);
  Inherited Insert(index, value);
end;

function TFhirStructureMapGroupInputList.Item(index: Integer): TFhirStructureMapGroupInput;
begin
  result := TFhirStructureMapGroupInput(ObjectByIndex[index]);
end;

function TFhirStructureMapGroupInputList.Link: TFhirStructureMapGroupInputList;
begin
  result := TFhirStructureMapGroupInputList(inherited Link);
end;

procedure TFhirStructureMapGroupInputList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirStructureMapGroupInputList.SetItemByIndex(index: Integer; value: TFhirStructureMapGroupInput);
begin
  assert(value is TFhirStructureMapGroupInput);
  FhirStructureMapGroupInputs[index] := value;
end;

procedure TFhirStructureMapGroupInputList.SetItemN(index: Integer; value: TFhirStructureMapGroupInput);
begin
  assert(value is TFhirStructureMapGroupInput);
  ObjectByIndex[index] := value;
end;

{ TFhirStructureMapGroupRule }

constructor TFhirStructureMapGroupRule.Create;
begin
  inherited;
end;

destructor TFhirStructureMapGroupRule.Destroy;
begin
  FName.free;
  FSourceList.Free;
  FTargetList.Free;
  FRuleList.Free;
  FDependentList.Free;
  FDocumentation.free;
  inherited;
end;

procedure TFhirStructureMapGroupRule.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirStructureMapGroupRule(oSource).nameElement.Clone;
  if (TFhirStructureMapGroupRule(oSource).FSourceList = nil) then
  begin
    FSourceList.free;
    FSourceList := nil;
  end
  else
  begin
    if FSourceList = nil then
      FSourceList := TFhirStructureMapGroupRuleSourceList.Create;
    FSourceList.Assign(TFhirStructureMapGroupRule(oSource).FSourceList);
  end;
  if (TFhirStructureMapGroupRule(oSource).FTargetList = nil) then
  begin
    FTargetList.free;
    FTargetList := nil;
  end
  else
  begin
    if FTargetList = nil then
      FTargetList := TFhirStructureMapGroupRuleTargetList.Create;
    FTargetList.Assign(TFhirStructureMapGroupRule(oSource).FTargetList);
  end;
  if (TFhirStructureMapGroupRule(oSource).FRuleList = nil) then
  begin
    FRuleList.free;
    FRuleList := nil;
  end
  else
  begin
    if FRuleList = nil then
      FRuleList := TFhirStructureMapGroupRuleList.Create;
    FRuleList.Assign(TFhirStructureMapGroupRule(oSource).FRuleList);
  end;
  if (TFhirStructureMapGroupRule(oSource).FDependentList = nil) then
  begin
    FDependentList.free;
    FDependentList := nil;
  end
  else
  begin
    if FDependentList = nil then
      FDependentList := TFhirStructureMapGroupRuleDependentList.Create;
    FDependentList.Assign(TFhirStructureMapGroupRule(oSource).FDependentList);
  end;
  documentationElement := TFhirStructureMapGroupRule(oSource).documentationElement.Clone;
end;

procedure TFhirStructureMapGroupRule.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'source') Then
    list.addAll(self, 'source', FSourceList);
  if (child_name = 'target') Then
    list.addAll(self, 'target', FTargetList);
  if (child_name = 'rule') Then
    list.addAll(self, 'rule', FRuleList);
  if (child_name = 'dependent') Then
    list.addAll(self, 'dependent', FDependentList);
  if (child_name = 'documentation') Then
     list.add(self.link, 'documentation', FDocumentation.Link);
end;

procedure TFhirStructureMapGroupRule.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'id', false, TFhirId, FName.Link));
  oList.add(TFHIRProperty.create(self, 'source', 'BackboneElement', true, TFhirStructureMapGroupRuleSource, FSourceList.Link));
  oList.add(TFHIRProperty.create(self, 'target', 'BackboneElement', true, TFhirStructureMapGroupRuleTarget, FTargetList.Link));
  oList.add(TFHIRProperty.create(self, 'rule', '', true, TFhirStructureMapGroupRule, FRuleList.Link));
  oList.add(TFHIRProperty.create(self, 'dependent', 'BackboneElement', true, TFhirStructureMapGroupRuleDependent, FDependentList.Link));
  oList.add(TFHIRProperty.create(self, 'documentation', 'string', false, TFhirString, FDocumentation.Link));
end;

function TFhirStructureMapGroupRule.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asId(propValue);
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    SourceList.add(propValue as TFhirStructureMapGroupRuleSource);
    result := propValue;
  end
  else if (propName = 'target') then
  begin
    TargetList.add(propValue as TFhirStructureMapGroupRuleTarget);
    result := propValue;
  end
  else if (propName = 'rule') then
  begin
    RuleList.add(propValue as TFhirStructureMapGroupRule);
    result := propValue;
  end
  else if (propName = 'dependent') then
  begin
    DependentList.add(propValue as TFhirStructureMapGroupRuleDependent);
    result := propValue;
  end
  else if (propName = 'documentation') then
  begin
    DocumentationElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirStructureMapGroupRule.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'source') then SourceList.insertItem(index, propValue as TFhirStructureMapGroupRuleSource)
  else if (propName = 'target') then TargetList.insertItem(index, propValue as TFhirStructureMapGroupRuleTarget)
  else if (propName = 'rule') then RuleList.insertItem(index, propValue as TFhirStructureMapGroupRule)
  else if (propName = 'dependent') then DependentList.insertItem(index, propValue as TFhirStructureMapGroupRuleDependent)
  else inherited;
end;

function TFhirStructureMapGroupRule.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirId.create()
  else if (propName = 'source') then result := SourceList.new()
  else if (propName = 'target') then result := TargetList.new()
  else if (propName = 'rule') then result := RuleList.new()
  else if (propName = 'dependent') then result := DependentList.new()
  else if (propName = 'documentation') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirStructureMapGroupRule.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'id'
  else if (propName = 'source') then result := 'BackboneElement'
  else if (propName = 'target') then result := 'BackboneElement'
  else if (propName = 'rule') then result := ''
  else if (propName = 'dependent') then result := 'BackboneElement'
  else if (propName = 'documentation') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirStructureMapGroupRule.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'source') then deletePropertyValue('source', SourceList, value)
  else if (propName = 'target') then deletePropertyValue('target', TargetList, value)
  else if (propName = 'rule') then deletePropertyValue('rule', RuleList, value)
  else if (propName = 'dependent') then deletePropertyValue('dependent', DependentList, value)
  else if (propName = 'documentation') then DocumentationElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirStructureMapGroupRule.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asId(new)
  else if (propName = 'source') then replacePropertyValue('source', SourceList, existing, new)
  else if (propName = 'target') then replacePropertyValue('target', TargetList, existing, new)
  else if (propName = 'rule') then replacePropertyValue('rule', RuleList, existing, new)
  else if (propName = 'dependent') then replacePropertyValue('dependent', DependentList, existing, new)
  else if (propName = 'documentation') then DocumentationElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirStructureMapGroupRule.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'source') then SourceList.move(source, destination)
  else if (propName = 'target') then TargetList.move(source, destination)
  else if (propName = 'rule') then RuleList.move(source, destination)
  else if (propName = 'dependent') then DependentList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirStructureMapGroupRule.fhirType : string;
begin
  result := 'StructureMap.group.rule';
end;

function TFhirStructureMapGroupRule.Link : TFhirStructureMapGroupRule;
begin
  result := TFhirStructureMapGroupRule(inherited Link);
end;

function TFhirStructureMapGroupRule.Clone : TFhirStructureMapGroupRule;
begin
  result := TFhirStructureMapGroupRule(inherited Clone);
end;

function TFhirStructureMapGroupRule.equals(other : TObject) : boolean; 
var
  o : TFhirStructureMapGroupRule;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirStructureMapGroupRule)) then
    result := false
  else
  begin
    o := TFhirStructureMapGroupRule(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(sourceList, o.sourceList, true) and 
      compareDeep(targetList, o.targetList, true) and compareDeep(ruleList, o.ruleList, true) and 
      compareDeep(dependentList, o.dependentList, true) and compareDeep(documentationElement, o.documentationElement, true);
  end;
end;

function TFhirStructureMapGroupRule.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FsourceList) and isEmptyProp(FtargetList) and isEmptyProp(FruleList) and isEmptyProp(FdependentList) and isEmptyProp(FDocumentation);
end;

procedure TFhirStructureMapGroupRule.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('name');
  fields.add('source');
  fields.add('target');
  fields.add('rule');
  fields.add('dependent');
  fields.add('documentation');
end;

function TFhirStructureMapGroupRule.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FSourceList.sizeInBytes(magic));
  inc(result, FTargetList.sizeInBytes(magic));
  inc(result, FRuleList.sizeInBytes(magic));
  inc(result, FDependentList.sizeInBytes(magic));
end;

procedure TFhirStructureMapGroupRule.SetName(value : TFhirId);
begin
  FName.free;
  FName := value;
end;

function TFhirStructureMapGroupRule.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirStructureMapGroupRule.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirId.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

function TFhirStructureMapGroupRule.GetSourceList : TFhirStructureMapGroupRuleSourceList;
begin
  if FSourceList = nil then
    FSourceList := TFhirStructureMapGroupRuleSourceList.Create;
  result := FSourceList;
end;

function TFhirStructureMapGroupRule.GetHasSourceList : boolean;
begin
  result := (FSourceList <> nil) and (FSourceList.count > 0);
end;

function TFhirStructureMapGroupRule.GetTargetList : TFhirStructureMapGroupRuleTargetList;
begin
  if FTargetList = nil then
    FTargetList := TFhirStructureMapGroupRuleTargetList.Create;
  result := FTargetList;
end;

function TFhirStructureMapGroupRule.GetHasTargetList : boolean;
begin
  result := (FTargetList <> nil) and (FTargetList.count > 0);
end;

function TFhirStructureMapGroupRule.GetRuleList : TFhirStructureMapGroupRuleList;
begin
  if FRuleList = nil then
    FRuleList := TFhirStructureMapGroupRuleList.Create;
  result := FRuleList;
end;

function TFhirStructureMapGroupRule.GetHasRuleList : boolean;
begin
  result := (FRuleList <> nil) and (FRuleList.count > 0);
end;

function TFhirStructureMapGroupRule.GetDependentList : TFhirStructureMapGroupRuleDependentList;
begin
  if FDependentList = nil then
    FDependentList := TFhirStructureMapGroupRuleDependentList.Create;
  result := FDependentList;
end;

function TFhirStructureMapGroupRule.GetHasDependentList : boolean;
begin
  result := (FDependentList <> nil) and (FDependentList.count > 0);
end;

procedure TFhirStructureMapGroupRule.SetDocumentation(value : TFhirString);
begin
  FDocumentation.free;
  FDocumentation := value;
end;

function TFhirStructureMapGroupRule.GetDocumentationST : String;
begin
  if FDocumentation = nil then
    result := ''
  else
    result := FDocumentation.value;
end;

procedure TFhirStructureMapGroupRule.SetDocumentationST(value : String);
begin
  if value <> '' then
  begin
    if FDocumentation = nil then
      FDocumentation := TFhirString.create;
    FDocumentation.value := value
  end
  else if FDocumentation <> nil then
    FDocumentation.value := '';
end;

{ TFhirStructureMapGroupRuleListEnumerator }

constructor TFhirStructureMapGroupRuleListEnumerator.Create(list : TFhirStructureMapGroupRuleList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirStructureMapGroupRuleListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirStructureMapGroupRuleListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirStructureMapGroupRuleListEnumerator.GetCurrent : TFhirStructureMapGroupRule;
begin
  Result := FList[FIndex];
end;

function TFhirStructureMapGroupRuleListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirStructureMapGroupRuleList }

function TFhirStructureMapGroupRuleList.AddItem(value: TFhirStructureMapGroupRule): TFhirStructureMapGroupRule;
begin
  assert(value.ClassName = 'TFhirStructureMapGroupRule', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirStructureMapGroupRule');
  add(value);
  result := value;
end;

function TFhirStructureMapGroupRuleList.Append: TFhirStructureMapGroupRule;
begin
  result := TFhirStructureMapGroupRule.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirStructureMapGroupRuleList.ClearItems;
begin
  Clear;
end;

function TFhirStructureMapGroupRuleList.GetEnumerator : TFhirStructureMapGroupRuleListEnumerator;
begin
  result := TFhirStructureMapGroupRuleListEnumerator.Create(self.link);
end;

function TFhirStructureMapGroupRuleList.Clone: TFhirStructureMapGroupRuleList;
begin
  result := TFhirStructureMapGroupRuleList(inherited Clone);
end;

function TFhirStructureMapGroupRuleList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirStructureMapGroupRuleList.GetItemN(index: Integer): TFhirStructureMapGroupRule;
begin
  result := TFhirStructureMapGroupRule(ObjectByIndex[index]);
end;

function TFhirStructureMapGroupRuleList.ItemClass: TFslObjectClass;
begin
  result := TFhirStructureMapGroupRule;
end;
function TFhirStructureMapGroupRuleList.IndexOf(value: TFhirStructureMapGroupRule): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirStructureMapGroupRuleList.Insert(index: Integer): TFhirStructureMapGroupRule;
begin
  result := TFhirStructureMapGroupRule.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirStructureMapGroupRuleList.InsertItem(index: Integer; value: TFhirStructureMapGroupRule);
begin
  assert(value is TFhirStructureMapGroupRule);
  Inherited Insert(index, value);
end;

function TFhirStructureMapGroupRuleList.Item(index: Integer): TFhirStructureMapGroupRule;
begin
  result := TFhirStructureMapGroupRule(ObjectByIndex[index]);
end;

function TFhirStructureMapGroupRuleList.Link: TFhirStructureMapGroupRuleList;
begin
  result := TFhirStructureMapGroupRuleList(inherited Link);
end;

procedure TFhirStructureMapGroupRuleList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirStructureMapGroupRuleList.SetItemByIndex(index: Integer; value: TFhirStructureMapGroupRule);
begin
  assert(value is TFhirStructureMapGroupRule);
  FhirStructureMapGroupRules[index] := value;
end;

procedure TFhirStructureMapGroupRuleList.SetItemN(index: Integer; value: TFhirStructureMapGroupRule);
begin
  assert(value is TFhirStructureMapGroupRule);
  ObjectByIndex[index] := value;
end;

{ TFhirStructureMapGroupRuleSource }

constructor TFhirStructureMapGroupRuleSource.Create;
begin
  inherited;
end;

destructor TFhirStructureMapGroupRuleSource.Destroy;
begin
  FContext.free;
  FMin.free;
  FMax.free;
  FType_.free;
  FDefaultValue.free;
  FElement.free;
  FListMode.free;
  FVariable.free;
  FCondition.free;
  FCheck.free;
  FLogMessage.free;
  inherited;
end;

procedure TFhirStructureMapGroupRuleSource.Assign(oSource : TFslObject);
begin
  inherited;
  contextElement := TFhirStructureMapGroupRuleSource(oSource).contextElement.Clone;
  minElement := TFhirStructureMapGroupRuleSource(oSource).minElement.Clone;
  maxElement := TFhirStructureMapGroupRuleSource(oSource).maxElement.Clone;
  type_Element := TFhirStructureMapGroupRuleSource(oSource).type_Element.Clone;
  defaultValue := TFhirStructureMapGroupRuleSource(oSource).defaultValue.Clone;
  elementElement := TFhirStructureMapGroupRuleSource(oSource).elementElement.Clone;
  listModeElement := TFhirStructureMapGroupRuleSource(oSource).listModeElement.Clone;
  variableElement := TFhirStructureMapGroupRuleSource(oSource).variableElement.Clone;
  conditionElement := TFhirStructureMapGroupRuleSource(oSource).conditionElement.Clone;
  checkElement := TFhirStructureMapGroupRuleSource(oSource).checkElement.Clone;
  logMessageElement := TFhirStructureMapGroupRuleSource(oSource).logMessageElement.Clone;
end;

procedure TFhirStructureMapGroupRuleSource.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'context') Then
     list.add(self.link, 'context', FContext.Link);
  if (child_name = 'min') Then
     list.add(self.link, 'min', FMin.Link);
  if (child_name = 'max') Then
     list.add(self.link, 'max', FMax.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'defaultValue[x]') or (child_name = 'defaultValue') Then
     list.add(self.link, 'defaultValue[x]', FDefaultValue.Link);
  if (child_name = 'element') Then
     list.add(self.link, 'element', FElement.Link);
  if (child_name = 'listMode') Then
     list.add(self.link, 'listMode', FListMode.Link);
  if (child_name = 'variable') Then
     list.add(self.link, 'variable', FVariable.Link);
  if (child_name = 'condition') Then
     list.add(self.link, 'condition', FCondition.Link);
  if (child_name = 'check') Then
     list.add(self.link, 'check', FCheck.Link);
  if (child_name = 'logMessage') Then
     list.add(self.link, 'logMessage', FLogMessage.Link);
end;

procedure TFhirStructureMapGroupRuleSource.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'context', 'id', false, TFhirId, FContext.Link));
  oList.add(TFHIRProperty.create(self, 'min', 'integer', false, TFhirInteger, FMin.Link));
  oList.add(TFHIRProperty.create(self, 'max', 'string', false, TFhirString, FMax.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'string', false, TFhirString, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'defaultValue[x]', 'base64Binary|boolean|canonical|code|date|dateTime|decimal|id|instant|integer|markdown|oid|positiveInt|string|time|unsignedInt|uri|url|uuid|Address|Age|Annotation|Attachment|CodeableConcept|Coding|ContactPoint|Count|Distance|Duration|HumanName|Identif'+'ier|Money|Period|Quantity|Range|Ratio|Reference|SampledData|Signature|Timing|ContactDetail|Contributor|DataRequirement|Expression|ParameterDefinition|RelatedArtifact|TriggerDefinition|UsageContext|Dosage|Meta', false, TFhirDataType, FDefaultValue.Link));
  oList.add(TFHIRProperty.create(self, 'element', 'string', false, TFhirString, FElement.Link));
  oList.add(TFHIRProperty.create(self, 'listMode', 'code', false, TFhirEnum, FListMode.Link));
  oList.add(TFHIRProperty.create(self, 'variable', 'id', false, TFhirId, FVariable.Link));
  oList.add(TFHIRProperty.create(self, 'condition', 'string', false, TFhirString, FCondition.Link));
  oList.add(TFHIRProperty.create(self, 'check', 'string', false, TFhirString, FCheck.Link));
  oList.add(TFHIRProperty.create(self, 'logMessage', 'string', false, TFhirString, FLogMessage.Link));
end;

function TFhirStructureMapGroupRuleSource.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'context') then
  begin
    ContextElement := asId(propValue);
    result := propValue;
  end
  else if (propName = 'min') then
  begin
    MinElement := asInteger(propValue);
    result := propValue;
  end
  else if (propName = 'max') then
  begin
    MaxElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_Element := asString(propValue);
    result := propValue;
  end
  else if (isMatchingName(propName, 'defaultValue', ['Base64Binary', 'Boolean', 'Canonical', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Url', 'Uuid', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'Reference', 'SampledData', 'Signature', 'Timing', 'ContactDetail', 'Contributor', 'DataRequirement', 'Expression', 'ParameterDefinition', 'RelatedArtifact', 'TriggerDefinition', 'UsageContext', 'Dosage', 'Meta'])) then
  begin
    DefaultValue := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'element') then
  begin
    ElementElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'listMode') then
  begin
    ListModeElement := asEnum(SYSTEMS_TFhirStructureMapSourceListModeEnum, CODES_TFhirStructureMapSourceListModeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'variable') then
  begin
    VariableElement := asId(propValue);
    result := propValue;
  end
  else if (propName = 'condition') then
  begin
    ConditionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'check') then
  begin
    CheckElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'logMessage') then
  begin
    LogMessageElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirStructureMapGroupRuleSource.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirStructureMapGroupRuleSource.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'context') then result := TFhirId.create()
  else if (propName = 'min') then result := TFhirInteger.create()
  else if (propName = 'max') then result := TFhirString.create()
  else if (propName = 'type') then result := TFhirString.create()
  else if (isMatchingName(propName, 'defaultValue', ['Base64Binary', 'Boolean', 'Canonical', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Url', 'Uuid', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'Reference', 'SampledData', 'Signature', 'Timing', 'ContactDetail', 'Contributor', 'DataRequirement', 'Expression', 'ParameterDefinition', 'RelatedArtifact', 'TriggerDefinition', 'UsageContext', 'Dosage', 'Meta'])) then raise EFHIRException.create('Cannot make property DefaultValue')
  else if (propName = 'element') then result := TFhirString.create()
  else if (propName = 'listMode') then result := TFhirEnum.create(SYSTEMS_TFhirStructureMapSourceListModeEnum[StructureMapSourceListModeNull], CODES_TFhirStructureMapSourceListModeEnum[StructureMapSourceListModeNull]) 
  else if (propName = 'variable') then result := TFhirId.create()
  else if (propName = 'condition') then result := TFhirString.create()
  else if (propName = 'check') then result := TFhirString.create()
  else if (propName = 'logMessage') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirStructureMapGroupRuleSource.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'context') then result := 'id'
  else if (propName = 'min') then result := 'integer'
  else if (propName = 'max') then result := 'string'
  else if (propName = 'type') then result := 'string'
  else if (propName = 'defaultValue[x]') then result := 'base64Binary|boolean|canonical|code|date|dateTime|decimal|id|instant|integer|markdown|oid|positiveInt|string|time|unsignedInt|uri|url|uuid|Address|Age|Annotation|Attachment|CodeableConcept|Coding|ContactPoint|Count|Distance|Duration|HumanName|Identif'+'ier|Money|Period|Quantity|Range|Ratio|Reference|SampledData|Signature|Timing|ContactDetail|Contributor|DataRequirement|Expression|ParameterDefinition|RelatedArtifact|TriggerDefinition|UsageContext|Dosage|Meta'
  else if (propName = 'element') then result := 'string'
  else if (propName = 'listMode') then result := 'code'
  else if (propName = 'variable') then result := 'id'
  else if (propName = 'condition') then result := 'string'
  else if (propName = 'check') then result := 'string'
  else if (propName = 'logMessage') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirStructureMapGroupRuleSource.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'context') then ContextElement := nil
  else if (propName = 'min') then MinElement := nil
  else if (propName = 'max') then MaxElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (isMatchingName(propName, 'defaultValue', ['Base64Binary', 'Boolean', 'Canonical', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Url', 'Uuid', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'Reference', 'SampledData', 'Signature', 'Timing', 'ContactDetail', 'Contributor', 'DataRequirement', 'Expression', 'ParameterDefinition', 'RelatedArtifact', 'TriggerDefinition', 'UsageContext', 'Dosage', 'Meta'])) then DefaultValueElement := nil
  else if (propName = 'element') then ElementElement := nil
  else if (propName = 'listMode') then ListModeElement := nil
  else if (propName = 'variable') then VariableElement := nil
  else if (propName = 'condition') then ConditionElement := nil
  else if (propName = 'check') then CheckElement := nil
  else if (propName = 'logMessage') then LogMessageElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirStructureMapGroupRuleSource.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'context') then ContextElement := asId(new)
  else if (propName = 'min') then MinElement := asInteger(new)
  else if (propName = 'max') then MaxElement := asString(new)
  else if (propName = 'type') then Type_Element := asString(new)
  else if (isMatchingName(propName, 'defaultValue', ['Base64Binary', 'Boolean', 'Canonical', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Url', 'Uuid', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'Reference', 'SampledData', 'Signature', 'Timing', 'ContactDetail', 'Contributor', 'DataRequirement', 'Expression', 'ParameterDefinition', 'RelatedArtifact', 'TriggerDefinition', 'UsageContext', 'Dosage', 'Meta'])) then DefaultValueElement := new as TFhirDataType
  else if (propName = 'element') then ElementElement := asString(new)
  else if (propName = 'listMode') then ListModeElement := asEnum(SYSTEMS_TFhirStructureMapSourceListModeEnum, CODES_TFhirStructureMapSourceListModeEnum, new)
  else if (propName = 'variable') then VariableElement := asId(new)
  else if (propName = 'condition') then ConditionElement := asString(new)
  else if (propName = 'check') then CheckElement := asString(new)
  else if (propName = 'logMessage') then LogMessageElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirStructureMapGroupRuleSource.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirStructureMapGroupRuleSource.fhirType : string;
begin
  result := 'StructureMap.group.rule.source';
end;

function TFhirStructureMapGroupRuleSource.Link : TFhirStructureMapGroupRuleSource;
begin
  result := TFhirStructureMapGroupRuleSource(inherited Link);
end;

function TFhirStructureMapGroupRuleSource.Clone : TFhirStructureMapGroupRuleSource;
begin
  result := TFhirStructureMapGroupRuleSource(inherited Clone);
end;

function TFhirStructureMapGroupRuleSource.equals(other : TObject) : boolean; 
var
  o : TFhirStructureMapGroupRuleSource;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirStructureMapGroupRuleSource)) then
    result := false
  else
  begin
    o := TFhirStructureMapGroupRuleSource(other);
    result := compareDeep(contextElement, o.contextElement, true) and compareDeep(minElement, o.minElement, true) and 
      compareDeep(maxElement, o.maxElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(defaultValueElement, o.defaultValueElement, true) and compareDeep(elementElement, o.elementElement, true) and 
      compareDeep(listModeElement, o.listModeElement, true) and compareDeep(variableElement, o.variableElement, true) and 
      compareDeep(conditionElement, o.conditionElement, true) and compareDeep(checkElement, o.checkElement, true) and 
      compareDeep(logMessageElement, o.logMessageElement, true);
  end;
end;

function TFhirStructureMapGroupRuleSource.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FContext) and isEmptyProp(FMin) and isEmptyProp(FMax) and isEmptyProp(FType_) and isEmptyProp(FDefaultValue) and isEmptyProp(FElement) and isEmptyProp(FListMode) and isEmptyProp(FVariable) and isEmptyProp(FCondition) and isEmptyProp(FCheck) and isEmptyProp(FLogMessage);
end;

procedure TFhirStructureMapGroupRuleSource.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('context');
  fields.add('min');
  fields.add('max');
  fields.add('type');
  fields.add('defaultValue[x]');
  fields.add('element');
  fields.add('listMode');
  fields.add('variable');
  fields.add('condition');
  fields.add('check');
  fields.add('logMessage');
end;

function TFhirStructureMapGroupRuleSource.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirStructureMapGroupRuleSource.SetContext(value : TFhirId);
begin
  FContext.free;
  FContext := value;
end;

function TFhirStructureMapGroupRuleSource.GetContextST : String;
begin
  if FContext = nil then
    result := ''
  else
    result := FContext.value;
end;

procedure TFhirStructureMapGroupRuleSource.SetContextST(value : String);
begin
  if value <> '' then
  begin
    if FContext = nil then
      FContext := TFhirId.create;
    FContext.value := value
  end
  else if FContext <> nil then
    FContext.value := '';
end;

procedure TFhirStructureMapGroupRuleSource.SetMin(value : TFhirInteger);
begin
  FMin.free;
  FMin := value;
end;

function TFhirStructureMapGroupRuleSource.GetMinST : String;
begin
  if FMin = nil then
    result := ''
  else
    result := FMin.value;
end;

procedure TFhirStructureMapGroupRuleSource.SetMinST(value : String);
begin
  if value <> '' then
  begin
    if FMin = nil then
      FMin := TFhirInteger.create;
    FMin.value := value
  end
  else if FMin <> nil then
    FMin.value := '';
end;

procedure TFhirStructureMapGroupRuleSource.SetMax(value : TFhirString);
begin
  FMax.free;
  FMax := value;
end;

function TFhirStructureMapGroupRuleSource.GetMaxST : String;
begin
  if FMax = nil then
    result := ''
  else
    result := FMax.value;
end;

procedure TFhirStructureMapGroupRuleSource.SetMaxST(value : String);
begin
  if value <> '' then
  begin
    if FMax = nil then
      FMax := TFhirString.create;
    FMax.value := value
  end
  else if FMax <> nil then
    FMax.value := '';
end;

procedure TFhirStructureMapGroupRuleSource.SetType_(value : TFhirString);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirStructureMapGroupRuleSource.GetType_ST : String;
begin
  if FType_ = nil then
    result := ''
  else
    result := FType_.value;
end;

procedure TFhirStructureMapGroupRuleSource.SetType_ST(value : String);
begin
  if value <> '' then
  begin
    if FType_ = nil then
      FType_ := TFhirString.create;
    FType_.value := value
  end
  else if FType_ <> nil then
    FType_.value := '';
end;

procedure TFhirStructureMapGroupRuleSource.SetDefaultValue(value : TFhirDataType);
begin
  FDefaultValue.free;
  FDefaultValue := value;
end;

procedure TFhirStructureMapGroupRuleSource.SetElement(value : TFhirString);
begin
  FElement.free;
  FElement := value;
end;

function TFhirStructureMapGroupRuleSource.GetElementST : String;
begin
  if FElement = nil then
    result := ''
  else
    result := FElement.value;
end;

procedure TFhirStructureMapGroupRuleSource.SetElementST(value : String);
begin
  if value <> '' then
  begin
    if FElement = nil then
      FElement := TFhirString.create;
    FElement.value := value
  end
  else if FElement <> nil then
    FElement.value := '';
end;

procedure TFhirStructureMapGroupRuleSource.SetListMode(value : TFhirEnum);
begin
  FListMode.free;
  FListMode := value;
end;

function TFhirStructureMapGroupRuleSource.GetListModeST : TFhirStructureMapSourceListModeEnum;
begin
  if FListMode = nil then
    result := TFhirStructureMapSourceListModeEnum(0)
  else
    result := TFhirStructureMapSourceListModeEnum(StringArrayIndexOfSensitive(CODES_TFhirStructureMapSourceListModeEnum, FListMode.value));
end;

procedure TFhirStructureMapGroupRuleSource.SetListModeST(value : TFhirStructureMapSourceListModeEnum);
begin
  if ord(value) = 0 then
    ListModeElement := nil
  else
    ListModeElement := TFhirEnum.create(SYSTEMS_TFhirStructureMapSourceListModeEnum[value], CODES_TFhirStructureMapSourceListModeEnum[value]);
end;

procedure TFhirStructureMapGroupRuleSource.SetVariable(value : TFhirId);
begin
  FVariable.free;
  FVariable := value;
end;

function TFhirStructureMapGroupRuleSource.GetVariableST : String;
begin
  if FVariable = nil then
    result := ''
  else
    result := FVariable.value;
end;

procedure TFhirStructureMapGroupRuleSource.SetVariableST(value : String);
begin
  if value <> '' then
  begin
    if FVariable = nil then
      FVariable := TFhirId.create;
    FVariable.value := value
  end
  else if FVariable <> nil then
    FVariable.value := '';
end;

procedure TFhirStructureMapGroupRuleSource.SetCondition(value : TFhirString);
begin
  FCondition.free;
  FCondition := value;
end;

function TFhirStructureMapGroupRuleSource.GetConditionST : String;
begin
  if FCondition = nil then
    result := ''
  else
    result := FCondition.value;
end;

procedure TFhirStructureMapGroupRuleSource.SetConditionST(value : String);
begin
  if value <> '' then
  begin
    if FCondition = nil then
      FCondition := TFhirString.create;
    FCondition.value := value
  end
  else if FCondition <> nil then
    FCondition.value := '';
end;

procedure TFhirStructureMapGroupRuleSource.SetCheck(value : TFhirString);
begin
  FCheck.free;
  FCheck := value;
end;

function TFhirStructureMapGroupRuleSource.GetCheckST : String;
begin
  if FCheck = nil then
    result := ''
  else
    result := FCheck.value;
end;

procedure TFhirStructureMapGroupRuleSource.SetCheckST(value : String);
begin
  if value <> '' then
  begin
    if FCheck = nil then
      FCheck := TFhirString.create;
    FCheck.value := value
  end
  else if FCheck <> nil then
    FCheck.value := '';
end;

procedure TFhirStructureMapGroupRuleSource.SetLogMessage(value : TFhirString);
begin
  FLogMessage.free;
  FLogMessage := value;
end;

function TFhirStructureMapGroupRuleSource.GetLogMessageST : String;
begin
  if FLogMessage = nil then
    result := ''
  else
    result := FLogMessage.value;
end;

procedure TFhirStructureMapGroupRuleSource.SetLogMessageST(value : String);
begin
  if value <> '' then
  begin
    if FLogMessage = nil then
      FLogMessage := TFhirString.create;
    FLogMessage.value := value
  end
  else if FLogMessage <> nil then
    FLogMessage.value := '';
end;

{ TFhirStructureMapGroupRuleSourceListEnumerator }

constructor TFhirStructureMapGroupRuleSourceListEnumerator.Create(list : TFhirStructureMapGroupRuleSourceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirStructureMapGroupRuleSourceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirStructureMapGroupRuleSourceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirStructureMapGroupRuleSourceListEnumerator.GetCurrent : TFhirStructureMapGroupRuleSource;
begin
  Result := FList[FIndex];
end;

function TFhirStructureMapGroupRuleSourceListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirStructureMapGroupRuleSourceList }

function TFhirStructureMapGroupRuleSourceList.AddItem(value: TFhirStructureMapGroupRuleSource): TFhirStructureMapGroupRuleSource;
begin
  assert(value.ClassName = 'TFhirStructureMapGroupRuleSource', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirStructureMapGroupRuleSource');
  add(value);
  result := value;
end;

function TFhirStructureMapGroupRuleSourceList.Append: TFhirStructureMapGroupRuleSource;
begin
  result := TFhirStructureMapGroupRuleSource.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirStructureMapGroupRuleSourceList.ClearItems;
begin
  Clear;
end;

function TFhirStructureMapGroupRuleSourceList.GetEnumerator : TFhirStructureMapGroupRuleSourceListEnumerator;
begin
  result := TFhirStructureMapGroupRuleSourceListEnumerator.Create(self.link);
end;

function TFhirStructureMapGroupRuleSourceList.Clone: TFhirStructureMapGroupRuleSourceList;
begin
  result := TFhirStructureMapGroupRuleSourceList(inherited Clone);
end;

function TFhirStructureMapGroupRuleSourceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirStructureMapGroupRuleSourceList.GetItemN(index: Integer): TFhirStructureMapGroupRuleSource;
begin
  result := TFhirStructureMapGroupRuleSource(ObjectByIndex[index]);
end;

function TFhirStructureMapGroupRuleSourceList.ItemClass: TFslObjectClass;
begin
  result := TFhirStructureMapGroupRuleSource;
end;
function TFhirStructureMapGroupRuleSourceList.IndexOf(value: TFhirStructureMapGroupRuleSource): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirStructureMapGroupRuleSourceList.Insert(index: Integer): TFhirStructureMapGroupRuleSource;
begin
  result := TFhirStructureMapGroupRuleSource.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirStructureMapGroupRuleSourceList.InsertItem(index: Integer; value: TFhirStructureMapGroupRuleSource);
begin
  assert(value is TFhirStructureMapGroupRuleSource);
  Inherited Insert(index, value);
end;

function TFhirStructureMapGroupRuleSourceList.Item(index: Integer): TFhirStructureMapGroupRuleSource;
begin
  result := TFhirStructureMapGroupRuleSource(ObjectByIndex[index]);
end;

function TFhirStructureMapGroupRuleSourceList.Link: TFhirStructureMapGroupRuleSourceList;
begin
  result := TFhirStructureMapGroupRuleSourceList(inherited Link);
end;

procedure TFhirStructureMapGroupRuleSourceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirStructureMapGroupRuleSourceList.SetItemByIndex(index: Integer; value: TFhirStructureMapGroupRuleSource);
begin
  assert(value is TFhirStructureMapGroupRuleSource);
  FhirStructureMapGroupRuleSources[index] := value;
end;

procedure TFhirStructureMapGroupRuleSourceList.SetItemN(index: Integer; value: TFhirStructureMapGroupRuleSource);
begin
  assert(value is TFhirStructureMapGroupRuleSource);
  ObjectByIndex[index] := value;
end;

{ TFhirStructureMapGroupRuleTarget }

constructor TFhirStructureMapGroupRuleTarget.Create;
begin
  inherited;
end;

destructor TFhirStructureMapGroupRuleTarget.Destroy;
begin
  FContext.free;
  FContextType.free;
  FElement.free;
  FVariable.free;
  FListMode.Free;
  FListRuleId.free;
  FTransform.free;
  FParameterList.Free;
  inherited;
end;

procedure TFhirStructureMapGroupRuleTarget.Assign(oSource : TFslObject);
begin
  inherited;
  contextElement := TFhirStructureMapGroupRuleTarget(oSource).contextElement.Clone;
  contextTypeElement := TFhirStructureMapGroupRuleTarget(oSource).contextTypeElement.Clone;
  elementElement := TFhirStructureMapGroupRuleTarget(oSource).elementElement.Clone;
  variableElement := TFhirStructureMapGroupRuleTarget(oSource).variableElement.Clone;
  if (TFhirStructureMapGroupRuleTarget(oSource).FListMode = nil) then
  begin
    FListMode.free;
    FListMode := nil;
  end
  else
  begin
    FListMode := TFhirEnumList.Create(SYSTEMS_TFhirStructureMapTargetListModeEnum, CODES_TFhirStructureMapTargetListModeEnum);
    FListMode.Assign(TFhirStructureMapGroupRuleTarget(oSource).FListMode);
  end;
  listRuleIdElement := TFhirStructureMapGroupRuleTarget(oSource).listRuleIdElement.Clone;
  transformElement := TFhirStructureMapGroupRuleTarget(oSource).transformElement.Clone;
  if (TFhirStructureMapGroupRuleTarget(oSource).FParameterList = nil) then
  begin
    FParameterList.free;
    FParameterList := nil;
  end
  else
  begin
    if FParameterList = nil then
      FParameterList := TFhirStructureMapGroupRuleTargetParameterList.Create;
    FParameterList.Assign(TFhirStructureMapGroupRuleTarget(oSource).FParameterList);
  end;
end;

procedure TFhirStructureMapGroupRuleTarget.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'context') Then
     list.add(self.link, 'context', FContext.Link);
  if (child_name = 'contextType') Then
     list.add(self.link, 'contextType', FContextType.Link);
  if (child_name = 'element') Then
     list.add(self.link, 'element', FElement.Link);
  if (child_name = 'variable') Then
     list.add(self.link, 'variable', FVariable.Link);
  if (child_name = 'listMode') Then
     list.addAll(self, 'listMode', FListMode);
  if (child_name = 'listRuleId') Then
     list.add(self.link, 'listRuleId', FListRuleId.Link);
  if (child_name = 'transform') Then
     list.add(self.link, 'transform', FTransform.Link);
  if (child_name = 'parameter') Then
    list.addAll(self, 'parameter', FParameterList);
end;

procedure TFhirStructureMapGroupRuleTarget.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'context', 'id', false, TFhirId, FContext.Link));
  oList.add(TFHIRProperty.create(self, 'contextType', 'code', false, TFhirEnum, FContextType.Link));
  oList.add(TFHIRProperty.create(self, 'element', 'string', false, TFhirString, FElement.Link));
  oList.add(TFHIRProperty.create(self, 'variable', 'id', false, TFhirId, FVariable.Link));
  oList.add(TFHIRProperty.create(self, 'listMode', 'code', true, TFhirEnum, FListMode.Link));
  oList.add(TFHIRProperty.create(self, 'listRuleId', 'id', false, TFhirId, FListRuleId.Link));
  oList.add(TFHIRProperty.create(self, 'transform', 'code', false, TFhirEnum, FTransform.Link));
  oList.add(TFHIRProperty.create(self, 'parameter', 'BackboneElement', true, TFhirStructureMapGroupRuleTargetParameter, FParameterList.Link));
end;

function TFhirStructureMapGroupRuleTarget.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'context') then
  begin
    ContextElement := asId(propValue);
    result := propValue;
  end
  else if (propName = 'contextType') then
  begin
    ContextTypeElement := asEnum(SYSTEMS_TFhirStructureMapContextTypeEnum, CODES_TFhirStructureMapContextTypeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'element') then
  begin
    ElementElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'variable') then
  begin
    VariableElement := asId(propValue);
    result := propValue;
  end
  else if (propName = 'listMode') then
  begin
    ListModeList.add(asEnum(SYSTEMS_TFhirStructureMapTargetListModeEnum, CODES_TFhirStructureMapTargetListModeEnum, propValue));
    result := propValue;
  end
  else if (propName = 'listRuleId') then
  begin
    ListRuleIdElement := asId(propValue);
    result := propValue;
  end
  else if (propName = 'transform') then
  begin
    TransformElement := asEnum(SYSTEMS_TFhirStructureMapTransformEnum, CODES_TFhirStructureMapTransformEnum, propValue);
    result := propValue;
  end
  else if (propName = 'parameter') then
  begin
    ParameterList.add(propValue as TFhirStructureMapGroupRuleTargetParameter);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirStructureMapGroupRuleTarget.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'listMode') then FListMode.insertItem(index, asEnum(SYSTEMS_TFhirStructureMapTargetListModeEnum, CODES_TFhirStructureMapTargetListModeEnum, propValue))
  else if (propName = 'parameter') then ParameterList.insertItem(index, propValue as TFhirStructureMapGroupRuleTargetParameter)
  else inherited;
end;

function TFhirStructureMapGroupRuleTarget.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'context') then result := TFhirId.create()
  else if (propName = 'contextType') then result := TFhirEnum.create(SYSTEMS_TFhirStructureMapContextTypeEnum[StructureMapContextTypeNull], CODES_TFhirStructureMapContextTypeEnum[StructureMapContextTypeNull]) 
  else if (propName = 'element') then result := TFhirString.create()
  else if (propName = 'variable') then result := TFhirId.create()
  else if (propName = 'listRuleId') then result := TFhirId.create()
  else if (propName = 'transform') then result := TFhirEnum.create(SYSTEMS_TFhirStructureMapTransformEnum[StructureMapTransformNull], CODES_TFhirStructureMapTransformEnum[StructureMapTransformNull]) 
  else if (propName = 'parameter') then result := ParameterList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirStructureMapGroupRuleTarget.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'context') then result := 'id'
  else if (propName = 'contextType') then result := 'code'
  else if (propName = 'element') then result := 'string'
  else if (propName = 'variable') then result := 'id'
  else if (propName = 'listMode') then result := 'code'
  else if (propName = 'listRuleId') then result := 'id'
  else if (propName = 'transform') then result := 'code'
  else if (propName = 'parameter') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirStructureMapGroupRuleTarget.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'context') then ContextElement := nil
  else if (propName = 'contextType') then ContextTypeElement := nil
  else if (propName = 'element') then ElementElement := nil
  else if (propName = 'variable') then VariableElement := nil
  else if (propName = 'listRuleId') then ListRuleIdElement := nil
  else if (propName = 'transform') then TransformElement := nil
  else if (propName = 'parameter') then deletePropertyValue('parameter', ParameterList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirStructureMapGroupRuleTarget.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'context') then ContextElement := asId(new)
  else if (propName = 'contextType') then ContextTypeElement := asEnum(SYSTEMS_TFhirStructureMapContextTypeEnum, CODES_TFhirStructureMapContextTypeEnum, new)
  else if (propName = 'element') then ElementElement := asString(new)
  else if (propName = 'variable') then VariableElement := asId(new)
  else if (propName = 'listRuleId') then ListRuleIdElement := asId(new)
  else if (propName = 'transform') then TransformElement := asEnum(SYSTEMS_TFhirStructureMapTransformEnum, CODES_TFhirStructureMapTransformEnum, new)
  else if (propName = 'parameter') then replacePropertyValue('parameter', ParameterList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirStructureMapGroupRuleTarget.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'listMode') then FListMode.move(source, destination)
  else if (propName = 'parameter') then ParameterList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirStructureMapGroupRuleTarget.fhirType : string;
begin
  result := 'StructureMap.group.rule.target';
end;

function TFhirStructureMapGroupRuleTarget.Link : TFhirStructureMapGroupRuleTarget;
begin
  result := TFhirStructureMapGroupRuleTarget(inherited Link);
end;

function TFhirStructureMapGroupRuleTarget.Clone : TFhirStructureMapGroupRuleTarget;
begin
  result := TFhirStructureMapGroupRuleTarget(inherited Clone);
end;

function TFhirStructureMapGroupRuleTarget.equals(other : TObject) : boolean; 
var
  o : TFhirStructureMapGroupRuleTarget;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirStructureMapGroupRuleTarget)) then
    result := false
  else
  begin
    o := TFhirStructureMapGroupRuleTarget(other);
    result := compareDeep(contextElement, o.contextElement, true) and compareDeep(contextTypeElement, o.contextTypeElement, true) and 
      compareDeep(elementElement, o.elementElement, true) and compareDeep(variableElement, o.variableElement, true) and 
      compareDeep(listModeList, o.listModeList, true) and compareDeep(listRuleIdElement, o.listRuleIdElement, true) and 
      compareDeep(transformElement, o.transformElement, true) and compareDeep(parameterList, o.parameterList, true);
  end;
end;

function TFhirStructureMapGroupRuleTarget.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FContext) and isEmptyProp(FContextType) and isEmptyProp(FElement) and isEmptyProp(FVariable) and isEmptyProp(FListMode) and isEmptyProp(FListRuleId) and isEmptyProp(FTransform) and isEmptyProp(FparameterList);
end;

procedure TFhirStructureMapGroupRuleTarget.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('context');
  fields.add('contextType');
  fields.add('element');
  fields.add('variable');
  fields.add('listMode');
  fields.add('listRuleId');
  fields.add('transform');
  fields.add('parameter');
end;

function TFhirStructureMapGroupRuleTarget.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FListMode.sizeInBytes(magic));
  inc(result, FParameterList.sizeInBytes(magic));
end;

procedure TFhirStructureMapGroupRuleTarget.SetContext(value : TFhirId);
begin
  FContext.free;
  FContext := value;
end;

function TFhirStructureMapGroupRuleTarget.GetContextST : String;
begin
  if FContext = nil then
    result := ''
  else
    result := FContext.value;
end;

procedure TFhirStructureMapGroupRuleTarget.SetContextST(value : String);
begin
  if value <> '' then
  begin
    if FContext = nil then
      FContext := TFhirId.create;
    FContext.value := value
  end
  else if FContext <> nil then
    FContext.value := '';
end;

procedure TFhirStructureMapGroupRuleTarget.SetContextType(value : TFhirEnum);
begin
  FContextType.free;
  FContextType := value;
end;

function TFhirStructureMapGroupRuleTarget.GetContextTypeST : TFhirStructureMapContextTypeEnum;
begin
  if FContextType = nil then
    result := TFhirStructureMapContextTypeEnum(0)
  else
    result := TFhirStructureMapContextTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirStructureMapContextTypeEnum, FContextType.value));
end;

procedure TFhirStructureMapGroupRuleTarget.SetContextTypeST(value : TFhirStructureMapContextTypeEnum);
begin
  if ord(value) = 0 then
    ContextTypeElement := nil
  else
    ContextTypeElement := TFhirEnum.create(SYSTEMS_TFhirStructureMapContextTypeEnum[value], CODES_TFhirStructureMapContextTypeEnum[value]);
end;

procedure TFhirStructureMapGroupRuleTarget.SetElement(value : TFhirString);
begin
  FElement.free;
  FElement := value;
end;

function TFhirStructureMapGroupRuleTarget.GetElementST : String;
begin
  if FElement = nil then
    result := ''
  else
    result := FElement.value;
end;

procedure TFhirStructureMapGroupRuleTarget.SetElementST(value : String);
begin
  if value <> '' then
  begin
    if FElement = nil then
      FElement := TFhirString.create;
    FElement.value := value
  end
  else if FElement <> nil then
    FElement.value := '';
end;

procedure TFhirStructureMapGroupRuleTarget.SetVariable(value : TFhirId);
begin
  FVariable.free;
  FVariable := value;
end;

function TFhirStructureMapGroupRuleTarget.GetVariableST : String;
begin
  if FVariable = nil then
    result := ''
  else
    result := FVariable.value;
end;

procedure TFhirStructureMapGroupRuleTarget.SetVariableST(value : String);
begin
  if value <> '' then
  begin
    if FVariable = nil then
      FVariable := TFhirId.create;
    FVariable.value := value
  end
  else if FVariable <> nil then
    FVariable.value := '';
end;

function TFhirStructureMapGroupRuleTarget.GetListMode : TFhirEnumList;
begin
  if FListMode = nil then
    FListMode := TFhirEnumList.Create(SYSTEMS_TFhirStructureMapTargetListModeEnum, CODES_TFhirStructureMapTargetListModeEnum);
  result := FListMode;
end;

function TFhirStructureMapGroupRuleTarget.GetHasListMode : boolean;
begin
  result := (FListMode <> nil) and (FListMode.count > 0);
end;

function TFhirStructureMapGroupRuleTarget.GetListModeST : TFhirStructureMapTargetListModeEnumList;
  var i : integer;
begin
  result := [];
  if FlistMode <> nil then
    for i := 0 to FlistMode.count - 1 do
      result := result + [TFhirStructureMapTargetListModeEnum(StringArrayIndexOfSensitive(CODES_TFhirStructureMapTargetListModeEnum, FlistMode[i].value))];
end;

procedure TFhirStructureMapGroupRuleTarget.SetListModeST(value : TFhirStructureMapTargetListModeEnumList);
var a : TFhirStructureMapTargetListModeEnum;
begin
  if FlistMode = nil then
    FlistMode := TFhirEnumList.create(SYSTEMS_TFhirStructureMapTargetListModeEnum, CODES_TFhirStructureMapTargetListModeEnum);
  FlistMode.clear;
  for a := low(TFhirStructureMapTargetListModeEnum) to high(TFhirStructureMapTargetListModeEnum) do
    if a in value then
      begin
         if FlistMode = nil then
           FlistMode := TFhirEnumList.create(SYSTEMS_TFhirStructureMapTargetListModeEnum, CODES_TFhirStructureMapTargetListModeEnum);
         FlistMode.add(TFhirEnum.create(SYSTEMS_TFhirStructureMapTargetListModeEnum[a], CODES_TFhirStructureMapTargetListModeEnum[a]));
      end;
end;

procedure TFhirStructureMapGroupRuleTarget.SetListRuleId(value : TFhirId);
begin
  FListRuleId.free;
  FListRuleId := value;
end;

function TFhirStructureMapGroupRuleTarget.GetListRuleIdST : String;
begin
  if FListRuleId = nil then
    result := ''
  else
    result := FListRuleId.value;
end;

procedure TFhirStructureMapGroupRuleTarget.SetListRuleIdST(value : String);
begin
  if value <> '' then
  begin
    if FListRuleId = nil then
      FListRuleId := TFhirId.create;
    FListRuleId.value := value
  end
  else if FListRuleId <> nil then
    FListRuleId.value := '';
end;

procedure TFhirStructureMapGroupRuleTarget.SetTransform(value : TFhirEnum);
begin
  FTransform.free;
  FTransform := value;
end;

function TFhirStructureMapGroupRuleTarget.GetTransformST : TFhirStructureMapTransformEnum;
begin
  if FTransform = nil then
    result := TFhirStructureMapTransformEnum(0)
  else
    result := TFhirStructureMapTransformEnum(StringArrayIndexOfSensitive(CODES_TFhirStructureMapTransformEnum, FTransform.value));
end;

procedure TFhirStructureMapGroupRuleTarget.SetTransformST(value : TFhirStructureMapTransformEnum);
begin
  if ord(value) = 0 then
    TransformElement := nil
  else
    TransformElement := TFhirEnum.create(SYSTEMS_TFhirStructureMapTransformEnum[value], CODES_TFhirStructureMapTransformEnum[value]);
end;

function TFhirStructureMapGroupRuleTarget.GetParameterList : TFhirStructureMapGroupRuleTargetParameterList;
begin
  if FParameterList = nil then
    FParameterList := TFhirStructureMapGroupRuleTargetParameterList.Create;
  result := FParameterList;
end;

function TFhirStructureMapGroupRuleTarget.GetHasParameterList : boolean;
begin
  result := (FParameterList <> nil) and (FParameterList.count > 0);
end;

{ TFhirStructureMapGroupRuleTargetListEnumerator }

constructor TFhirStructureMapGroupRuleTargetListEnumerator.Create(list : TFhirStructureMapGroupRuleTargetList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirStructureMapGroupRuleTargetListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirStructureMapGroupRuleTargetListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirStructureMapGroupRuleTargetListEnumerator.GetCurrent : TFhirStructureMapGroupRuleTarget;
begin
  Result := FList[FIndex];
end;

function TFhirStructureMapGroupRuleTargetListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirStructureMapGroupRuleTargetList }

function TFhirStructureMapGroupRuleTargetList.AddItem(value: TFhirStructureMapGroupRuleTarget): TFhirStructureMapGroupRuleTarget;
begin
  assert(value.ClassName = 'TFhirStructureMapGroupRuleTarget', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirStructureMapGroupRuleTarget');
  add(value);
  result := value;
end;

function TFhirStructureMapGroupRuleTargetList.Append: TFhirStructureMapGroupRuleTarget;
begin
  result := TFhirStructureMapGroupRuleTarget.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirStructureMapGroupRuleTargetList.ClearItems;
begin
  Clear;
end;

function TFhirStructureMapGroupRuleTargetList.GetEnumerator : TFhirStructureMapGroupRuleTargetListEnumerator;
begin
  result := TFhirStructureMapGroupRuleTargetListEnumerator.Create(self.link);
end;

function TFhirStructureMapGroupRuleTargetList.Clone: TFhirStructureMapGroupRuleTargetList;
begin
  result := TFhirStructureMapGroupRuleTargetList(inherited Clone);
end;

function TFhirStructureMapGroupRuleTargetList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirStructureMapGroupRuleTargetList.GetItemN(index: Integer): TFhirStructureMapGroupRuleTarget;
begin
  result := TFhirStructureMapGroupRuleTarget(ObjectByIndex[index]);
end;

function TFhirStructureMapGroupRuleTargetList.ItemClass: TFslObjectClass;
begin
  result := TFhirStructureMapGroupRuleTarget;
end;
function TFhirStructureMapGroupRuleTargetList.IndexOf(value: TFhirStructureMapGroupRuleTarget): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirStructureMapGroupRuleTargetList.Insert(index: Integer): TFhirStructureMapGroupRuleTarget;
begin
  result := TFhirStructureMapGroupRuleTarget.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirStructureMapGroupRuleTargetList.InsertItem(index: Integer; value: TFhirStructureMapGroupRuleTarget);
begin
  assert(value is TFhirStructureMapGroupRuleTarget);
  Inherited Insert(index, value);
end;

function TFhirStructureMapGroupRuleTargetList.Item(index: Integer): TFhirStructureMapGroupRuleTarget;
begin
  result := TFhirStructureMapGroupRuleTarget(ObjectByIndex[index]);
end;

function TFhirStructureMapGroupRuleTargetList.Link: TFhirStructureMapGroupRuleTargetList;
begin
  result := TFhirStructureMapGroupRuleTargetList(inherited Link);
end;

procedure TFhirStructureMapGroupRuleTargetList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirStructureMapGroupRuleTargetList.SetItemByIndex(index: Integer; value: TFhirStructureMapGroupRuleTarget);
begin
  assert(value is TFhirStructureMapGroupRuleTarget);
  FhirStructureMapGroupRuleTargets[index] := value;
end;

procedure TFhirStructureMapGroupRuleTargetList.SetItemN(index: Integer; value: TFhirStructureMapGroupRuleTarget);
begin
  assert(value is TFhirStructureMapGroupRuleTarget);
  ObjectByIndex[index] := value;
end;

{ TFhirStructureMapGroupRuleTargetParameter }

constructor TFhirStructureMapGroupRuleTargetParameter.Create;
begin
  inherited;
end;

destructor TFhirStructureMapGroupRuleTargetParameter.Destroy;
begin
  FValue.free;
  inherited;
end;

procedure TFhirStructureMapGroupRuleTargetParameter.Assign(oSource : TFslObject);
begin
  inherited;
  value := TFhirStructureMapGroupRuleTargetParameter(oSource).value.Clone;
end;

procedure TFhirStructureMapGroupRuleTargetParameter.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
end;

procedure TFhirStructureMapGroupRuleTargetParameter.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'value[x]', 'id|string|boolean|integer|decimal', false, TFhirDataType, FValue.Link));
end;

function TFhirStructureMapGroupRuleTargetParameter.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'value', ['Id', 'String', 'Boolean', 'Integer', 'Decimal'])) then
  begin
    Value := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirStructureMapGroupRuleTargetParameter.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirStructureMapGroupRuleTargetParameter.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'value', ['Id', 'String', 'Boolean', 'Integer', 'Decimal'])) then raise EFHIRException.create('Cannot make property Value')
  else result := inherited createPropertyValue(propName);
end;

function TFhirStructureMapGroupRuleTargetParameter.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'value[x]') then result := 'id|string|boolean|integer|decimal'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirStructureMapGroupRuleTargetParameter.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'value', ['Id', 'String', 'Boolean', 'Integer', 'Decimal'])) then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirStructureMapGroupRuleTargetParameter.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'value', ['Id', 'String', 'Boolean', 'Integer', 'Decimal'])) then ValueElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirStructureMapGroupRuleTargetParameter.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirStructureMapGroupRuleTargetParameter.fhirType : string;
begin
  result := 'StructureMap.group.rule.target.parameter';
end;

function TFhirStructureMapGroupRuleTargetParameter.Link : TFhirStructureMapGroupRuleTargetParameter;
begin
  result := TFhirStructureMapGroupRuleTargetParameter(inherited Link);
end;

function TFhirStructureMapGroupRuleTargetParameter.Clone : TFhirStructureMapGroupRuleTargetParameter;
begin
  result := TFhirStructureMapGroupRuleTargetParameter(inherited Clone);
end;

function TFhirStructureMapGroupRuleTargetParameter.equals(other : TObject) : boolean; 
var
  o : TFhirStructureMapGroupRuleTargetParameter;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirStructureMapGroupRuleTargetParameter)) then
    result := false
  else
  begin
    o := TFhirStructureMapGroupRuleTargetParameter(other);
    result := compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirStructureMapGroupRuleTargetParameter.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FValue);
end;

procedure TFhirStructureMapGroupRuleTargetParameter.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('value[x]');
end;

function TFhirStructureMapGroupRuleTargetParameter.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirStructureMapGroupRuleTargetParameter.SetValue(value : TFhirDataType);
begin
  FValue.free;
  FValue := value;
end;

{ TFhirStructureMapGroupRuleTargetParameterListEnumerator }

constructor TFhirStructureMapGroupRuleTargetParameterListEnumerator.Create(list : TFhirStructureMapGroupRuleTargetParameterList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirStructureMapGroupRuleTargetParameterListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirStructureMapGroupRuleTargetParameterListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirStructureMapGroupRuleTargetParameterListEnumerator.GetCurrent : TFhirStructureMapGroupRuleTargetParameter;
begin
  Result := FList[FIndex];
end;

function TFhirStructureMapGroupRuleTargetParameterListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirStructureMapGroupRuleTargetParameterList }

function TFhirStructureMapGroupRuleTargetParameterList.AddItem(value: TFhirStructureMapGroupRuleTargetParameter): TFhirStructureMapGroupRuleTargetParameter;
begin
  assert(value.ClassName = 'TFhirStructureMapGroupRuleTargetParameter', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirStructureMapGroupRuleTargetParameter');
  add(value);
  result := value;
end;

function TFhirStructureMapGroupRuleTargetParameterList.Append: TFhirStructureMapGroupRuleTargetParameter;
begin
  result := TFhirStructureMapGroupRuleTargetParameter.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirStructureMapGroupRuleTargetParameterList.ClearItems;
begin
  Clear;
end;

function TFhirStructureMapGroupRuleTargetParameterList.GetEnumerator : TFhirStructureMapGroupRuleTargetParameterListEnumerator;
begin
  result := TFhirStructureMapGroupRuleTargetParameterListEnumerator.Create(self.link);
end;

function TFhirStructureMapGroupRuleTargetParameterList.Clone: TFhirStructureMapGroupRuleTargetParameterList;
begin
  result := TFhirStructureMapGroupRuleTargetParameterList(inherited Clone);
end;

function TFhirStructureMapGroupRuleTargetParameterList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirStructureMapGroupRuleTargetParameterList.GetItemN(index: Integer): TFhirStructureMapGroupRuleTargetParameter;
begin
  result := TFhirStructureMapGroupRuleTargetParameter(ObjectByIndex[index]);
end;

function TFhirStructureMapGroupRuleTargetParameterList.ItemClass: TFslObjectClass;
begin
  result := TFhirStructureMapGroupRuleTargetParameter;
end;
function TFhirStructureMapGroupRuleTargetParameterList.IndexOf(value: TFhirStructureMapGroupRuleTargetParameter): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirStructureMapGroupRuleTargetParameterList.Insert(index: Integer): TFhirStructureMapGroupRuleTargetParameter;
begin
  result := TFhirStructureMapGroupRuleTargetParameter.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirStructureMapGroupRuleTargetParameterList.InsertItem(index: Integer; value: TFhirStructureMapGroupRuleTargetParameter);
begin
  assert(value is TFhirStructureMapGroupRuleTargetParameter);
  Inherited Insert(index, value);
end;

function TFhirStructureMapGroupRuleTargetParameterList.Item(index: Integer): TFhirStructureMapGroupRuleTargetParameter;
begin
  result := TFhirStructureMapGroupRuleTargetParameter(ObjectByIndex[index]);
end;

function TFhirStructureMapGroupRuleTargetParameterList.Link: TFhirStructureMapGroupRuleTargetParameterList;
begin
  result := TFhirStructureMapGroupRuleTargetParameterList(inherited Link);
end;

procedure TFhirStructureMapGroupRuleTargetParameterList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirStructureMapGroupRuleTargetParameterList.SetItemByIndex(index: Integer; value: TFhirStructureMapGroupRuleTargetParameter);
begin
  assert(value is TFhirStructureMapGroupRuleTargetParameter);
  FhirStructureMapGroupRuleTargetParameters[index] := value;
end;

procedure TFhirStructureMapGroupRuleTargetParameterList.SetItemN(index: Integer; value: TFhirStructureMapGroupRuleTargetParameter);
begin
  assert(value is TFhirStructureMapGroupRuleTargetParameter);
  ObjectByIndex[index] := value;
end;

{ TFhirStructureMapGroupRuleDependent }

constructor TFhirStructureMapGroupRuleDependent.Create;
begin
  inherited;
end;

destructor TFhirStructureMapGroupRuleDependent.Destroy;
begin
  FName.free;
  FVariableList.Free;
  inherited;
end;

procedure TFhirStructureMapGroupRuleDependent.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirStructureMapGroupRuleDependent(oSource).nameElement.Clone;
  if (TFhirStructureMapGroupRuleDependent(oSource).FVariableList = nil) then
  begin
    FVariableList.free;
    FVariableList := nil;
  end
  else
  begin
    if FVariableList = nil then
      FVariableList := TFhirStringList.Create;
    FVariableList.Assign(TFhirStructureMapGroupRuleDependent(oSource).FVariableList);
  end;
end;

procedure TFhirStructureMapGroupRuleDependent.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'variable') Then
    list.addAll(self, 'variable', FVariableList);
end;

procedure TFhirStructureMapGroupRuleDependent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'id', false, TFhirId, FName.Link));
  oList.add(TFHIRProperty.create(self, 'variable', 'string', true, TFhirString, FVariableList.Link));
end;

function TFhirStructureMapGroupRuleDependent.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asId(propValue);
    result := propValue;
  end
  else if (propName = 'variable') then
  begin
    VariableList.add(asString(propValue)){2};     result := propValue;

  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirStructureMapGroupRuleDependent.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'variable') then VariableList.insertItem(index, asString(propValue))
  else inherited;
end;

function TFhirStructureMapGroupRuleDependent.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirId.create()
  else if (propName = 'variable') then result := VariableList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirStructureMapGroupRuleDependent.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'id'
  else if (propName = 'variable') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirStructureMapGroupRuleDependent.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'variable') then deletePropertyValue('variable', VariableList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirStructureMapGroupRuleDependent.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asId(new)
  else if (propName = 'variable') then replacePropertyValue('variable', VariableList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirStructureMapGroupRuleDependent.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'variable') then VariableList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirStructureMapGroupRuleDependent.fhirType : string;
begin
  result := 'StructureMap.group.rule.dependent';
end;

function TFhirStructureMapGroupRuleDependent.Link : TFhirStructureMapGroupRuleDependent;
begin
  result := TFhirStructureMapGroupRuleDependent(inherited Link);
end;

function TFhirStructureMapGroupRuleDependent.Clone : TFhirStructureMapGroupRuleDependent;
begin
  result := TFhirStructureMapGroupRuleDependent(inherited Clone);
end;

function TFhirStructureMapGroupRuleDependent.equals(other : TObject) : boolean; 
var
  o : TFhirStructureMapGroupRuleDependent;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirStructureMapGroupRuleDependent)) then
    result := false
  else
  begin
    o := TFhirStructureMapGroupRuleDependent(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(variableList, o.variableList, true);
  end;
end;

function TFhirStructureMapGroupRuleDependent.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FvariableList);
end;

procedure TFhirStructureMapGroupRuleDependent.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('name');
  fields.add('variable');
end;

function TFhirStructureMapGroupRuleDependent.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FVariableList.sizeInBytes(magic));
end;

procedure TFhirStructureMapGroupRuleDependent.SetName(value : TFhirId);
begin
  FName.free;
  FName := value;
end;

function TFhirStructureMapGroupRuleDependent.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirStructureMapGroupRuleDependent.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirId.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

function TFhirStructureMapGroupRuleDependent.GetVariableList : TFhirStringList;
begin
  if FVariableList = nil then
    FVariableList := TFhirStringList.Create;
  result := FVariableList;
end;

function TFhirStructureMapGroupRuleDependent.GetHasVariableList : boolean;
begin
  result := (FVariableList <> nil) and (FVariableList.count > 0);
end;

{ TFhirStructureMapGroupRuleDependentListEnumerator }

constructor TFhirStructureMapGroupRuleDependentListEnumerator.Create(list : TFhirStructureMapGroupRuleDependentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirStructureMapGroupRuleDependentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirStructureMapGroupRuleDependentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirStructureMapGroupRuleDependentListEnumerator.GetCurrent : TFhirStructureMapGroupRuleDependent;
begin
  Result := FList[FIndex];
end;

function TFhirStructureMapGroupRuleDependentListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirStructureMapGroupRuleDependentList }

function TFhirStructureMapGroupRuleDependentList.AddItem(value: TFhirStructureMapGroupRuleDependent): TFhirStructureMapGroupRuleDependent;
begin
  assert(value.ClassName = 'TFhirStructureMapGroupRuleDependent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirStructureMapGroupRuleDependent');
  add(value);
  result := value;
end;

function TFhirStructureMapGroupRuleDependentList.Append: TFhirStructureMapGroupRuleDependent;
begin
  result := TFhirStructureMapGroupRuleDependent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirStructureMapGroupRuleDependentList.ClearItems;
begin
  Clear;
end;

function TFhirStructureMapGroupRuleDependentList.GetEnumerator : TFhirStructureMapGroupRuleDependentListEnumerator;
begin
  result := TFhirStructureMapGroupRuleDependentListEnumerator.Create(self.link);
end;

function TFhirStructureMapGroupRuleDependentList.Clone: TFhirStructureMapGroupRuleDependentList;
begin
  result := TFhirStructureMapGroupRuleDependentList(inherited Clone);
end;

function TFhirStructureMapGroupRuleDependentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirStructureMapGroupRuleDependentList.GetItemN(index: Integer): TFhirStructureMapGroupRuleDependent;
begin
  result := TFhirStructureMapGroupRuleDependent(ObjectByIndex[index]);
end;

function TFhirStructureMapGroupRuleDependentList.ItemClass: TFslObjectClass;
begin
  result := TFhirStructureMapGroupRuleDependent;
end;
function TFhirStructureMapGroupRuleDependentList.IndexOf(value: TFhirStructureMapGroupRuleDependent): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirStructureMapGroupRuleDependentList.Insert(index: Integer): TFhirStructureMapGroupRuleDependent;
begin
  result := TFhirStructureMapGroupRuleDependent.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirStructureMapGroupRuleDependentList.InsertItem(index: Integer; value: TFhirStructureMapGroupRuleDependent);
begin
  assert(value is TFhirStructureMapGroupRuleDependent);
  Inherited Insert(index, value);
end;

function TFhirStructureMapGroupRuleDependentList.Item(index: Integer): TFhirStructureMapGroupRuleDependent;
begin
  result := TFhirStructureMapGroupRuleDependent(ObjectByIndex[index]);
end;

function TFhirStructureMapGroupRuleDependentList.Link: TFhirStructureMapGroupRuleDependentList;
begin
  result := TFhirStructureMapGroupRuleDependentList(inherited Link);
end;

procedure TFhirStructureMapGroupRuleDependentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirStructureMapGroupRuleDependentList.SetItemByIndex(index: Integer; value: TFhirStructureMapGroupRuleDependent);
begin
  assert(value is TFhirStructureMapGroupRuleDependent);
  FhirStructureMapGroupRuleDependents[index] := value;
end;

procedure TFhirStructureMapGroupRuleDependentList.SetItemN(index: Integer; value: TFhirStructureMapGroupRuleDependent);
begin
  assert(value is TFhirStructureMapGroupRuleDependent);
  ObjectByIndex[index] := value;
end;

{ TFhirStructureMap }

constructor TFhirStructureMap.Create;
begin
  inherited;
end;

destructor TFhirStructureMap.Destroy;
begin
  FUrl.free;
  FIdentifierList.Free;
  FVersion.free;
  FName.free;
  FTitle.free;
  FStatus.free;
  FExperimental.free;
  FDate.free;
  FPublisher.free;
  FContactList.Free;
  FDescription.free;
  FUseContextList.Free;
  FJurisdictionList.Free;
  FPurpose.free;
  FCopyright.free;
  FStructureList.Free;
  FImportList.Free;
  FGroupList.Free;
  inherited;
end;

procedure TFhirStructureMap.Assign(oSource : TFslObject);
begin
  inherited;
  urlElement := TFhirStructureMap(oSource).urlElement.Clone;
  if (TFhirStructureMap(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirStructureMap(oSource).FIdentifierList);
  end;
  versionElement := TFhirStructureMap(oSource).versionElement.Clone;
  nameElement := TFhirStructureMap(oSource).nameElement.Clone;
  titleElement := TFhirStructureMap(oSource).titleElement.Clone;
  statusElement := TFhirStructureMap(oSource).statusElement.Clone;
  experimentalElement := TFhirStructureMap(oSource).experimentalElement.Clone;
  dateElement := TFhirStructureMap(oSource).dateElement.Clone;
  publisherElement := TFhirStructureMap(oSource).publisherElement.Clone;
  if (TFhirStructureMap(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirContactDetailList.Create;
    FContactList.Assign(TFhirStructureMap(oSource).FContactList);
  end;
  descriptionElement := TFhirStructureMap(oSource).descriptionElement.Clone;
  if (TFhirStructureMap(oSource).FUseContextList = nil) then
  begin
    FUseContextList.free;
    FUseContextList := nil;
  end
  else
  begin
    if FUseContextList = nil then
      FUseContextList := TFhirUsageContextList.Create;
    FUseContextList.Assign(TFhirStructureMap(oSource).FUseContextList);
  end;
  if (TFhirStructureMap(oSource).FJurisdictionList = nil) then
  begin
    FJurisdictionList.free;
    FJurisdictionList := nil;
  end
  else
  begin
    if FJurisdictionList = nil then
      FJurisdictionList := TFhirCodeableConceptList.Create;
    FJurisdictionList.Assign(TFhirStructureMap(oSource).FJurisdictionList);
  end;
  purposeElement := TFhirStructureMap(oSource).purposeElement.Clone;
  copyrightElement := TFhirStructureMap(oSource).copyrightElement.Clone;
  if (TFhirStructureMap(oSource).FStructureList = nil) then
  begin
    FStructureList.free;
    FStructureList := nil;
  end
  else
  begin
    if FStructureList = nil then
      FStructureList := TFhirStructureMapStructureList.Create;
    FStructureList.Assign(TFhirStructureMap(oSource).FStructureList);
  end;
  if (TFhirStructureMap(oSource).FImportList = nil) then
  begin
    FImportList.free;
    FImportList := nil;
  end
  else
  begin
    if FImportList = nil then
      FImportList := TFhirCanonicalList.Create;
    FImportList.Assign(TFhirStructureMap(oSource).FImportList);
  end;
  if (TFhirStructureMap(oSource).FGroupList = nil) then
  begin
    FGroupList.free;
    FGroupList := nil;
  end
  else
  begin
    if FGroupList = nil then
      FGroupList := TFhirStructureMapGroupList.Create;
    FGroupList.Assign(TFhirStructureMap(oSource).FGroupList);
  end;
end;

function TFhirStructureMap.GetResourceType : TFhirResourceType;
begin
  result := frtStructureMap;
end;

procedure TFhirStructureMap.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'version') Then
     list.add(self.link, 'version', FVersion.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'experimental') Then
     list.add(self.link, 'experimental', FExperimental.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'publisher') Then
     list.add(self.link, 'publisher', FPublisher.Link);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'useContext') Then
    list.addAll(self, 'useContext', FUseContextList);
  if (child_name = 'jurisdiction') Then
    list.addAll(self, 'jurisdiction', FJurisdictionList);
  if (child_name = 'purpose') Then
     list.add(self.link, 'purpose', FPurpose.Link);
  if (child_name = 'copyright') Then
     list.add(self.link, 'copyright', FCopyright.Link);
  if (child_name = 'structure') Then
    list.addAll(self, 'structure', FStructureList);
  if (child_name = 'import') Then
    list.addAll(self, 'import', FImportList);
  if (child_name = 'group') Then
    list.addAll(self, 'group', FGroupList);
end;

procedure TFhirStructureMap.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'url', 'uri', false, TFhirUri, FUrl.Link));
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'version', 'string', false, TFhirString, FVersion.Link));
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'experimental', 'boolean', false, TFhirBoolean, FExperimental.Link));
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));
  oList.add(TFHIRProperty.create(self, 'publisher', 'string', false, TFhirString, FPublisher.Link));
  oList.add(TFHIRProperty.create(self, 'contact', 'ContactDetail', true, TFhirContactDetail, FContactList.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'markdown', false, TFhirMarkdown, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'useContext', 'UsageContext', true, TFhirUsageContext, FUseContextList.Link));
  oList.add(TFHIRProperty.create(self, 'jurisdiction', 'CodeableConcept', true, TFhirCodeableConcept, FJurisdictionList.Link));
  oList.add(TFHIRProperty.create(self, 'purpose', 'markdown', false, TFhirMarkdown, FPurpose.Link));
  oList.add(TFHIRProperty.create(self, 'copyright', 'markdown', false, TFhirMarkdown, FCopyright.Link));
  oList.add(TFHIRProperty.create(self, 'structure', 'BackboneElement', true, TFhirStructureMapStructure, FStructureList.Link));
  oList.add(TFHIRProperty.create(self, 'import', 'canonical', true, TFhirCanonical, FImportList.Link));
  oList.add(TFHIRProperty.create(self, 'group', 'BackboneElement', true, TFhirStructureMapGroup, FGroupList.Link));
end;

function TFhirStructureMap.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'url') then
  begin
    UrlElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'title') then
  begin
    TitleElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'experimental') then
  begin
    ExperimentalElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'publisher') then
  begin
    PublisherElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirContactDetail);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'useContext') then
  begin
    UseContextList.add(propValue as TFhirUsageContext);
    result := propValue;
  end
  else if (propName = 'jurisdiction') then
  begin
    JurisdictionList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'purpose') then
  begin
    PurposeElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'copyright') then
  begin
    CopyrightElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'structure') then
  begin
    StructureList.add(propValue as TFhirStructureMapStructure);
    result := propValue;
  end
  else if (propName = 'import') then
  begin
    ImportList.add(asCanonical(propValue)){2};     result := propValue;

  end
  else if (propName = 'group') then
  begin
    GroupList.add(propValue as TFhirStructureMapGroup);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirStructureMap.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirContactDetail)
  else if (propName = 'useContext') then UseContextList.insertItem(index, propValue as TFhirUsageContext)
  else if (propName = 'jurisdiction') then JurisdictionList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'structure') then StructureList.insertItem(index, propValue as TFhirStructureMapStructure)
  else if (propName = 'import') then ImportList.insertItem(index, asCanonical(propValue))
  else if (propName = 'group') then GroupList.insertItem(index, propValue as TFhirStructureMapGroup)
  else inherited;
end;

function TFhirStructureMap.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'url') then result := TFhirUri.create()
  else if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'version') then result := TFhirString.create()
  else if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'title') then result := TFhirString.create()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[PublicationStatusNull], CODES_TFhirPublicationStatusEnum[PublicationStatusNull]) 
  else if (propName = 'experimental') then result := TFhirBoolean.create()
  else if (propName = 'date') then result := TFhirDateTime.create()
  else if (propName = 'publisher') then result := TFhirString.create()
  else if (propName = 'contact') then result := ContactList.new()
  else if (propName = 'description') then result := TFhirMarkdown.create()
  else if (propName = 'useContext') then result := UseContextList.new()
  else if (propName = 'jurisdiction') then result := JurisdictionList.new()
  else if (propName = 'purpose') then result := TFhirMarkdown.create()
  else if (propName = 'copyright') then result := TFhirMarkdown.create()
  else if (propName = 'structure') then result := StructureList.new()
  else if (propName = 'import') then result := ImportList.new()
  else if (propName = 'group') then result := GroupList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirStructureMap.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'url') then result := 'uri'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'version') then result := 'string'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'title') then result := 'string'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'experimental') then result := 'boolean'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'publisher') then result := 'string'
  else if (propName = 'contact') then result := 'ContactDetail'
  else if (propName = 'description') then result := 'markdown'
  else if (propName = 'useContext') then result := 'UsageContext'
  else if (propName = 'jurisdiction') then result := 'CodeableConcept'
  else if (propName = 'purpose') then result := 'markdown'
  else if (propName = 'copyright') then result := 'markdown'
  else if (propName = 'structure') then result := 'BackboneElement'
  else if (propName = 'import') then result := 'canonical'
  else if (propName = 'group') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirStructureMap.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := nil
  else if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'version') then VersionElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'title') then TitleElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'experimental') then ExperimentalElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'publisher') then PublisherElement := nil
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value)
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'useContext') then deletePropertyValue('useContext', UseContextList, value)
  else if (propName = 'jurisdiction') then deletePropertyValue('jurisdiction', JurisdictionList, value)
  else if (propName = 'purpose') then PurposeElement := nil
  else if (propName = 'copyright') then CopyrightElement := nil
  else if (propName = 'structure') then deletePropertyValue('structure', StructureList, value)
  else if (propName = 'import') then deletePropertyValue('import', ImportList, value)
  else if (propName = 'group') then deletePropertyValue('group', GroupList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirStructureMap.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := asUri(new)
  else if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'version') then VersionElement := asString(new)
  else if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'title') then TitleElement := asString(new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, new)
  else if (propName = 'experimental') then ExperimentalElement := asBoolean(new)
  else if (propName = 'date') then DateElement := asDateTime(new)
  else if (propName = 'publisher') then PublisherElement := asString(new)
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new)
  else if (propName = 'description') then DescriptionElement := asMarkdown(new)
  else if (propName = 'useContext') then replacePropertyValue('useContext', UseContextList, existing, new)
  else if (propName = 'jurisdiction') then replacePropertyValue('jurisdiction', JurisdictionList, existing, new)
  else if (propName = 'purpose') then PurposeElement := asMarkdown(new)
  else if (propName = 'copyright') then CopyrightElement := asMarkdown(new)
  else if (propName = 'structure') then replacePropertyValue('structure', StructureList, existing, new)
  else if (propName = 'import') then replacePropertyValue('import', ImportList, existing, new)
  else if (propName = 'group') then replacePropertyValue('group', GroupList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirStructureMap.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'contact') then ContactList.move(source, destination)
  else if (propName = 'useContext') then UseContextList.move(source, destination)
  else if (propName = 'jurisdiction') then JurisdictionList.move(source, destination)
  else if (propName = 'structure') then StructureList.move(source, destination)
  else if (propName = 'import') then ImportList.move(source, destination)
  else if (propName = 'group') then GroupList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirStructureMap.fhirType : string;
begin
  result := 'StructureMap';
end;

function TFhirStructureMap.Link : TFhirStructureMap;
begin
  result := TFhirStructureMap(inherited Link);
end;

function TFhirStructureMap.Clone : TFhirStructureMap;
begin
  result := TFhirStructureMap(inherited Clone);
end;

function TFhirStructureMap.equals(other : TObject) : boolean; 
var
  o : TFhirStructureMap;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirStructureMap)) then
    result := false
  else
  begin
    o := TFhirStructureMap(other);
    result := compareDeep(urlElement, o.urlElement, true) and compareDeep(identifierList, o.identifierList, true) and 
      compareDeep(versionElement, o.versionElement, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(titleElement, o.titleElement, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(experimentalElement, o.experimentalElement, true) and compareDeep(dateElement, o.dateElement, true) and 
      compareDeep(publisherElement, o.publisherElement, true) and compareDeep(contactList, o.contactList, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(useContextList, o.useContextList, true) and 
      compareDeep(jurisdictionList, o.jurisdictionList, true) and compareDeep(purposeElement, o.purposeElement, true) and 
      compareDeep(copyrightElement, o.copyrightElement, true) and compareDeep(structureList, o.structureList, true) and 
      compareDeep(importList, o.importList, true) and compareDeep(groupList, o.groupList, true);
  end;
end;

function TFhirStructureMap.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FUrl) and isEmptyProp(FidentifierList) and isEmptyProp(FVersion) and isEmptyProp(FName) and isEmptyProp(FTitle) and isEmptyProp(FStatus) and isEmptyProp(FExperimental) and isEmptyProp(FDate) and isEmptyProp(FPublisher) and isEmptyProp(FcontactList) and isEmptyProp(FDescription) and isEmptyProp(FuseContextList) and isEmptyProp(FjurisdictionList) and isEmptyProp(FPurpose) and isEmptyProp(FCopyright) and isEmptyProp(FstructureList) and isEmptyProp(FimportList) and isEmptyProp(FgroupList);
end;

procedure TFhirStructureMap.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('url');
  fields.add('identifier');
  fields.add('version');
  fields.add('name');
  fields.add('title');
  fields.add('status');
  fields.add('experimental');
  fields.add('date');
  fields.add('publisher');
  fields.add('contact');
  fields.add('description');
  fields.add('useContext');
  fields.add('jurisdiction');
  fields.add('purpose');
  fields.add('copyright');
  fields.add('structure');
  fields.add('import');
  fields.add('group');
end;

function TFhirStructureMap.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FContactList.sizeInBytes(magic));
  inc(result, FUseContextList.sizeInBytes(magic));
  inc(result, FJurisdictionList.sizeInBytes(magic));
  inc(result, FStructureList.sizeInBytes(magic));
  inc(result, FImportList.sizeInBytes(magic));
  inc(result, FGroupList.sizeInBytes(magic));
end;

procedure TFhirStructureMap.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

function TFhirStructureMap.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

procedure TFhirStructureMap.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

function TFhirStructureMap.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirStructureMap.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirStructureMap.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

function TFhirStructureMap.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

procedure TFhirStructureMap.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

procedure TFhirStructureMap.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirStructureMap.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirStructureMap.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirStructureMap.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

function TFhirStructureMap.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

procedure TFhirStructureMap.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

procedure TFhirStructureMap.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirStructureMap.GetStatusST : TFhirPublicationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirPublicationStatusEnum(0)
  else
    result := TFhirPublicationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirPublicationStatusEnum, FStatus.value));
end;

procedure TFhirStructureMap.SetStatusST(value : TFhirPublicationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[value], CODES_TFhirPublicationStatusEnum[value]);
end;

procedure TFhirStructureMap.SetExperimental(value : TFhirBoolean);
begin
  FExperimental.free;
  FExperimental := value;
end;

function TFhirStructureMap.GetExperimentalST : Boolean;
begin
  if FExperimental = nil then
    result := false
  else
    result := FExperimental.value;
end;

procedure TFhirStructureMap.SetExperimentalST(value : Boolean);
begin
  if FExperimental = nil then
    FExperimental := TFhirBoolean.create;
  FExperimental.value := value
end;

procedure TFhirStructureMap.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

function TFhirStructureMap.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirStructureMap.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

procedure TFhirStructureMap.SetPublisher(value : TFhirString);
begin
  FPublisher.free;
  FPublisher := value;
end;

function TFhirStructureMap.GetPublisherST : String;
begin
  if FPublisher = nil then
    result := ''
  else
    result := FPublisher.value;
end;

procedure TFhirStructureMap.SetPublisherST(value : String);
begin
  if value <> '' then
  begin
    if FPublisher = nil then
      FPublisher := TFhirString.create;
    FPublisher.value := value
  end
  else if FPublisher <> nil then
    FPublisher.value := '';
end;

function TFhirStructureMap.GetContactList : TFhirContactDetailList;
begin
  if FContactList = nil then
    FContactList := TFhirContactDetailList.Create;
  result := FContactList;
end;

function TFhirStructureMap.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

procedure TFhirStructureMap.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirStructureMap.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirStructureMap.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirStructureMap.GetUseContextList : TFhirUsageContextList;
begin
  if FUseContextList = nil then
    FUseContextList := TFhirUsageContextList.Create;
  result := FUseContextList;
end;

function TFhirStructureMap.GetHasUseContextList : boolean;
begin
  result := (FUseContextList <> nil) and (FUseContextList.count > 0);
end;

function TFhirStructureMap.GetJurisdictionList : TFhirCodeableConceptList;
begin
  if FJurisdictionList = nil then
    FJurisdictionList := TFhirCodeableConceptList.Create;
  result := FJurisdictionList;
end;

function TFhirStructureMap.GetHasJurisdictionList : boolean;
begin
  result := (FJurisdictionList <> nil) and (FJurisdictionList.count > 0);
end;

procedure TFhirStructureMap.SetPurpose(value : TFhirMarkdown);
begin
  FPurpose.free;
  FPurpose := value;
end;

function TFhirStructureMap.GetPurposeST : String;
begin
  if FPurpose = nil then
    result := ''
  else
    result := FPurpose.value;
end;

procedure TFhirStructureMap.SetPurposeST(value : String);
begin
  if value <> '' then
  begin
    if FPurpose = nil then
      FPurpose := TFhirMarkdown.create;
    FPurpose.value := value
  end
  else if FPurpose <> nil then
    FPurpose.value := '';
end;

procedure TFhirStructureMap.SetCopyright(value : TFhirMarkdown);
begin
  FCopyright.free;
  FCopyright := value;
end;

function TFhirStructureMap.GetCopyrightST : String;
begin
  if FCopyright = nil then
    result := ''
  else
    result := FCopyright.value;
end;

procedure TFhirStructureMap.SetCopyrightST(value : String);
begin
  if value <> '' then
  begin
    if FCopyright = nil then
      FCopyright := TFhirMarkdown.create;
    FCopyright.value := value
  end
  else if FCopyright <> nil then
    FCopyright.value := '';
end;

function TFhirStructureMap.GetStructureList : TFhirStructureMapStructureList;
begin
  if FStructureList = nil then
    FStructureList := TFhirStructureMapStructureList.Create;
  result := FStructureList;
end;

function TFhirStructureMap.GetHasStructureList : boolean;
begin
  result := (FStructureList <> nil) and (FStructureList.count > 0);
end;

function TFhirStructureMap.GetImportList : TFhirCanonicalList;
begin
  if FImportList = nil then
    FImportList := TFhirCanonicalList.Create;
  result := FImportList;
end;

function TFhirStructureMap.GetHasImportList : boolean;
begin
  result := (FImportList <> nil) and (FImportList.count > 0);
end;

function TFhirStructureMap.GetGroupList : TFhirStructureMapGroupList;
begin
  if FGroupList = nil then
    FGroupList := TFhirStructureMapGroupList.Create;
  result := FGroupList;
end;

function TFhirStructureMap.GetHasGroupList : boolean;
begin
  result := (FGroupList <> nil) and (FGroupList.count > 0);
end;

{ TFhirStructureMapListEnumerator }

constructor TFhirStructureMapListEnumerator.Create(list : TFhirStructureMapList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirStructureMapListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirStructureMapListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirStructureMapListEnumerator.GetCurrent : TFhirStructureMap;
begin
  Result := FList[FIndex];
end;

function TFhirStructureMapListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirStructureMapList }

function TFhirStructureMapList.AddItem(value: TFhirStructureMap): TFhirStructureMap;
begin
  assert(value.ClassName = 'TFhirStructureMap', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirStructureMap');
  add(value);
  result := value;
end;

function TFhirStructureMapList.Append: TFhirStructureMap;
begin
  result := TFhirStructureMap.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirStructureMapList.ClearItems;
begin
  Clear;
end;

function TFhirStructureMapList.GetEnumerator : TFhirStructureMapListEnumerator;
begin
  result := TFhirStructureMapListEnumerator.Create(self.link);
end;

function TFhirStructureMapList.Clone: TFhirStructureMapList;
begin
  result := TFhirStructureMapList(inherited Clone);
end;

function TFhirStructureMapList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirStructureMapList.GetItemN(index: Integer): TFhirStructureMap;
begin
  result := TFhirStructureMap(ObjectByIndex[index]);
end;

function TFhirStructureMapList.ItemClass: TFslObjectClass;
begin
  result := TFhirStructureMap;
end;
function TFhirStructureMapList.IndexOf(value: TFhirStructureMap): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirStructureMapList.Insert(index: Integer): TFhirStructureMap;
begin
  result := TFhirStructureMap.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirStructureMapList.InsertItem(index: Integer; value: TFhirStructureMap);
begin
  assert(value is TFhirStructureMap);
  Inherited Insert(index, value);
end;

function TFhirStructureMapList.Item(index: Integer): TFhirStructureMap;
begin
  result := TFhirStructureMap(ObjectByIndex[index]);
end;

function TFhirStructureMapList.Link: TFhirStructureMapList;
begin
  result := TFhirStructureMapList(inherited Link);
end;

procedure TFhirStructureMapList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirStructureMapList.SetItemByIndex(index: Integer; value: TFhirStructureMap);
begin
  assert(value is TFhirStructureMap);
  FhirStructureMaps[index] := value;
end;

procedure TFhirStructureMapList.SetItemN(index: Integer; value: TFhirStructureMap);
begin
  assert(value is TFhirStructureMap);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_STRUCTUREMAP}
{$IFDEF FHIR_TERMINOLOGYCAPABILITIES}
{ TFhirTerminologyCapabilitiesSoftware }

constructor TFhirTerminologyCapabilitiesSoftware.Create;
begin
  inherited;
end;

destructor TFhirTerminologyCapabilitiesSoftware.Destroy;
begin
  FName.free;
  FVersion.free;
  inherited;
end;

procedure TFhirTerminologyCapabilitiesSoftware.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirTerminologyCapabilitiesSoftware(oSource).nameElement.Clone;
  versionElement := TFhirTerminologyCapabilitiesSoftware(oSource).versionElement.Clone;
end;

procedure TFhirTerminologyCapabilitiesSoftware.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'version') Then
     list.add(self.link, 'version', FVersion.Link);
end;

procedure TFhirTerminologyCapabilitiesSoftware.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'version', 'string', false, TFhirString, FVersion.Link));
end;

function TFhirTerminologyCapabilitiesSoftware.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTerminologyCapabilitiesSoftware.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirTerminologyCapabilitiesSoftware.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'version') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirTerminologyCapabilitiesSoftware.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'version') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTerminologyCapabilitiesSoftware.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'version') then VersionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTerminologyCapabilitiesSoftware.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'version') then VersionElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTerminologyCapabilitiesSoftware.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirTerminologyCapabilitiesSoftware.fhirType : string;
begin
  result := 'TerminologyCapabilities.software';
end;

function TFhirTerminologyCapabilitiesSoftware.Link : TFhirTerminologyCapabilitiesSoftware;
begin
  result := TFhirTerminologyCapabilitiesSoftware(inherited Link);
end;

function TFhirTerminologyCapabilitiesSoftware.Clone : TFhirTerminologyCapabilitiesSoftware;
begin
  result := TFhirTerminologyCapabilitiesSoftware(inherited Clone);
end;

function TFhirTerminologyCapabilitiesSoftware.equals(other : TObject) : boolean; 
var
  o : TFhirTerminologyCapabilitiesSoftware;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTerminologyCapabilitiesSoftware)) then
    result := false
  else
  begin
    o := TFhirTerminologyCapabilitiesSoftware(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(versionElement, o.versionElement, true);
  end;
end;

function TFhirTerminologyCapabilitiesSoftware.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FVersion);
end;

procedure TFhirTerminologyCapabilitiesSoftware.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('name');
  fields.add('version');
end;

function TFhirTerminologyCapabilitiesSoftware.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirTerminologyCapabilitiesSoftware.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirTerminologyCapabilitiesSoftware.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirTerminologyCapabilitiesSoftware.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirTerminologyCapabilitiesSoftware.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

function TFhirTerminologyCapabilitiesSoftware.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

procedure TFhirTerminologyCapabilitiesSoftware.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

{ TFhirTerminologyCapabilitiesSoftwareListEnumerator }

constructor TFhirTerminologyCapabilitiesSoftwareListEnumerator.Create(list : TFhirTerminologyCapabilitiesSoftwareList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTerminologyCapabilitiesSoftwareListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTerminologyCapabilitiesSoftwareListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTerminologyCapabilitiesSoftwareListEnumerator.GetCurrent : TFhirTerminologyCapabilitiesSoftware;
begin
  Result := FList[FIndex];
end;

function TFhirTerminologyCapabilitiesSoftwareListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirTerminologyCapabilitiesSoftwareList }

function TFhirTerminologyCapabilitiesSoftwareList.AddItem(value: TFhirTerminologyCapabilitiesSoftware): TFhirTerminologyCapabilitiesSoftware;
begin
  assert(value.ClassName = 'TFhirTerminologyCapabilitiesSoftware', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTerminologyCapabilitiesSoftware');
  add(value);
  result := value;
end;

function TFhirTerminologyCapabilitiesSoftwareList.Append: TFhirTerminologyCapabilitiesSoftware;
begin
  result := TFhirTerminologyCapabilitiesSoftware.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTerminologyCapabilitiesSoftwareList.ClearItems;
begin
  Clear;
end;

function TFhirTerminologyCapabilitiesSoftwareList.GetEnumerator : TFhirTerminologyCapabilitiesSoftwareListEnumerator;
begin
  result := TFhirTerminologyCapabilitiesSoftwareListEnumerator.Create(self.link);
end;

function TFhirTerminologyCapabilitiesSoftwareList.Clone: TFhirTerminologyCapabilitiesSoftwareList;
begin
  result := TFhirTerminologyCapabilitiesSoftwareList(inherited Clone);
end;

function TFhirTerminologyCapabilitiesSoftwareList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTerminologyCapabilitiesSoftwareList.GetItemN(index: Integer): TFhirTerminologyCapabilitiesSoftware;
begin
  result := TFhirTerminologyCapabilitiesSoftware(ObjectByIndex[index]);
end;

function TFhirTerminologyCapabilitiesSoftwareList.ItemClass: TFslObjectClass;
begin
  result := TFhirTerminologyCapabilitiesSoftware;
end;
function TFhirTerminologyCapabilitiesSoftwareList.IndexOf(value: TFhirTerminologyCapabilitiesSoftware): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTerminologyCapabilitiesSoftwareList.Insert(index: Integer): TFhirTerminologyCapabilitiesSoftware;
begin
  result := TFhirTerminologyCapabilitiesSoftware.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTerminologyCapabilitiesSoftwareList.InsertItem(index: Integer; value: TFhirTerminologyCapabilitiesSoftware);
begin
  assert(value is TFhirTerminologyCapabilitiesSoftware);
  Inherited Insert(index, value);
end;

function TFhirTerminologyCapabilitiesSoftwareList.Item(index: Integer): TFhirTerminologyCapabilitiesSoftware;
begin
  result := TFhirTerminologyCapabilitiesSoftware(ObjectByIndex[index]);
end;

function TFhirTerminologyCapabilitiesSoftwareList.Link: TFhirTerminologyCapabilitiesSoftwareList;
begin
  result := TFhirTerminologyCapabilitiesSoftwareList(inherited Link);
end;

procedure TFhirTerminologyCapabilitiesSoftwareList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTerminologyCapabilitiesSoftwareList.SetItemByIndex(index: Integer; value: TFhirTerminologyCapabilitiesSoftware);
begin
  assert(value is TFhirTerminologyCapabilitiesSoftware);
  FhirTerminologyCapabilitiesSoftwares[index] := value;
end;

procedure TFhirTerminologyCapabilitiesSoftwareList.SetItemN(index: Integer; value: TFhirTerminologyCapabilitiesSoftware);
begin
  assert(value is TFhirTerminologyCapabilitiesSoftware);
  ObjectByIndex[index] := value;
end;

{ TFhirTerminologyCapabilitiesImplementation }

constructor TFhirTerminologyCapabilitiesImplementation.Create;
begin
  inherited;
end;

destructor TFhirTerminologyCapabilitiesImplementation.Destroy;
begin
  FDescription.free;
  FUrl.free;
  inherited;
end;

procedure TFhirTerminologyCapabilitiesImplementation.Assign(oSource : TFslObject);
begin
  inherited;
  descriptionElement := TFhirTerminologyCapabilitiesImplementation(oSource).descriptionElement.Clone;
  urlElement := TFhirTerminologyCapabilitiesImplementation(oSource).urlElement.Clone;
end;

procedure TFhirTerminologyCapabilitiesImplementation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
end;

procedure TFhirTerminologyCapabilitiesImplementation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'url', 'url', false, TFhirUrl, FUrl.Link));
end;

function TFhirTerminologyCapabilitiesImplementation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'url') then
  begin
    UrlElement := asUrl(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTerminologyCapabilitiesImplementation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirTerminologyCapabilitiesImplementation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'description') then result := TFhirString.create()
  else if (propName = 'url') then result := TFhirUrl.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirTerminologyCapabilitiesImplementation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'description') then result := 'string'
  else if (propName = 'url') then result := 'url'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTerminologyCapabilitiesImplementation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'url') then UrlElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTerminologyCapabilitiesImplementation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := asString(new)
  else if (propName = 'url') then UrlElement := asUrl(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTerminologyCapabilitiesImplementation.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirTerminologyCapabilitiesImplementation.fhirType : string;
begin
  result := 'TerminologyCapabilities.implementation';
end;

function TFhirTerminologyCapabilitiesImplementation.Link : TFhirTerminologyCapabilitiesImplementation;
begin
  result := TFhirTerminologyCapabilitiesImplementation(inherited Link);
end;

function TFhirTerminologyCapabilitiesImplementation.Clone : TFhirTerminologyCapabilitiesImplementation;
begin
  result := TFhirTerminologyCapabilitiesImplementation(inherited Clone);
end;

function TFhirTerminologyCapabilitiesImplementation.equals(other : TObject) : boolean; 
var
  o : TFhirTerminologyCapabilitiesImplementation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTerminologyCapabilitiesImplementation)) then
    result := false
  else
  begin
    o := TFhirTerminologyCapabilitiesImplementation(other);
    result := compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(urlElement, o.urlElement, true);
  end;
end;

function TFhirTerminologyCapabilitiesImplementation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDescription) and isEmptyProp(FUrl);
end;

procedure TFhirTerminologyCapabilitiesImplementation.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('description');
  fields.add('url');
end;

function TFhirTerminologyCapabilitiesImplementation.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirTerminologyCapabilitiesImplementation.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirTerminologyCapabilitiesImplementation.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirTerminologyCapabilitiesImplementation.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirTerminologyCapabilitiesImplementation.SetUrl(value : TFhirUrl);
begin
  FUrl.free;
  FUrl := value;
end;

function TFhirTerminologyCapabilitiesImplementation.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

procedure TFhirTerminologyCapabilitiesImplementation.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUrl.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

{ TFhirTerminologyCapabilitiesImplementationListEnumerator }

constructor TFhirTerminologyCapabilitiesImplementationListEnumerator.Create(list : TFhirTerminologyCapabilitiesImplementationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTerminologyCapabilitiesImplementationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTerminologyCapabilitiesImplementationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTerminologyCapabilitiesImplementationListEnumerator.GetCurrent : TFhirTerminologyCapabilitiesImplementation;
begin
  Result := FList[FIndex];
end;

function TFhirTerminologyCapabilitiesImplementationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirTerminologyCapabilitiesImplementationList }

function TFhirTerminologyCapabilitiesImplementationList.AddItem(value: TFhirTerminologyCapabilitiesImplementation): TFhirTerminologyCapabilitiesImplementation;
begin
  assert(value.ClassName = 'TFhirTerminologyCapabilitiesImplementation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTerminologyCapabilitiesImplementation');
  add(value);
  result := value;
end;

function TFhirTerminologyCapabilitiesImplementationList.Append: TFhirTerminologyCapabilitiesImplementation;
begin
  result := TFhirTerminologyCapabilitiesImplementation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTerminologyCapabilitiesImplementationList.ClearItems;
begin
  Clear;
end;

function TFhirTerminologyCapabilitiesImplementationList.GetEnumerator : TFhirTerminologyCapabilitiesImplementationListEnumerator;
begin
  result := TFhirTerminologyCapabilitiesImplementationListEnumerator.Create(self.link);
end;

function TFhirTerminologyCapabilitiesImplementationList.Clone: TFhirTerminologyCapabilitiesImplementationList;
begin
  result := TFhirTerminologyCapabilitiesImplementationList(inherited Clone);
end;

function TFhirTerminologyCapabilitiesImplementationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTerminologyCapabilitiesImplementationList.GetItemN(index: Integer): TFhirTerminologyCapabilitiesImplementation;
begin
  result := TFhirTerminologyCapabilitiesImplementation(ObjectByIndex[index]);
end;

function TFhirTerminologyCapabilitiesImplementationList.ItemClass: TFslObjectClass;
begin
  result := TFhirTerminologyCapabilitiesImplementation;
end;
function TFhirTerminologyCapabilitiesImplementationList.IndexOf(value: TFhirTerminologyCapabilitiesImplementation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTerminologyCapabilitiesImplementationList.Insert(index: Integer): TFhirTerminologyCapabilitiesImplementation;
begin
  result := TFhirTerminologyCapabilitiesImplementation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTerminologyCapabilitiesImplementationList.InsertItem(index: Integer; value: TFhirTerminologyCapabilitiesImplementation);
begin
  assert(value is TFhirTerminologyCapabilitiesImplementation);
  Inherited Insert(index, value);
end;

function TFhirTerminologyCapabilitiesImplementationList.Item(index: Integer): TFhirTerminologyCapabilitiesImplementation;
begin
  result := TFhirTerminologyCapabilitiesImplementation(ObjectByIndex[index]);
end;

function TFhirTerminologyCapabilitiesImplementationList.Link: TFhirTerminologyCapabilitiesImplementationList;
begin
  result := TFhirTerminologyCapabilitiesImplementationList(inherited Link);
end;

procedure TFhirTerminologyCapabilitiesImplementationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTerminologyCapabilitiesImplementationList.SetItemByIndex(index: Integer; value: TFhirTerminologyCapabilitiesImplementation);
begin
  assert(value is TFhirTerminologyCapabilitiesImplementation);
  FhirTerminologyCapabilitiesImplementations[index] := value;
end;

procedure TFhirTerminologyCapabilitiesImplementationList.SetItemN(index: Integer; value: TFhirTerminologyCapabilitiesImplementation);
begin
  assert(value is TFhirTerminologyCapabilitiesImplementation);
  ObjectByIndex[index] := value;
end;

{ TFhirTerminologyCapabilitiesCodeSystem }

constructor TFhirTerminologyCapabilitiesCodeSystem.Create;
begin
  inherited;
end;

destructor TFhirTerminologyCapabilitiesCodeSystem.Destroy;
begin
  FUri.free;
  FVersionList.Free;
  FSubsumption.free;
  inherited;
end;

procedure TFhirTerminologyCapabilitiesCodeSystem.Assign(oSource : TFslObject);
begin
  inherited;
  uriElement := TFhirTerminologyCapabilitiesCodeSystem(oSource).uriElement.Clone;
  if (TFhirTerminologyCapabilitiesCodeSystem(oSource).FVersionList = nil) then
  begin
    FVersionList.free;
    FVersionList := nil;
  end
  else
  begin
    if FVersionList = nil then
      FVersionList := TFhirTerminologyCapabilitiesCodeSystemVersionList.Create;
    FVersionList.Assign(TFhirTerminologyCapabilitiesCodeSystem(oSource).FVersionList);
  end;
  subsumptionElement := TFhirTerminologyCapabilitiesCodeSystem(oSource).subsumptionElement.Clone;
end;

procedure TFhirTerminologyCapabilitiesCodeSystem.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'uri') Then
     list.add(self.link, 'uri', FUri.Link);
  if (child_name = 'version') Then
    list.addAll(self, 'version', FVersionList);
  if (child_name = 'subsumption') Then
     list.add(self.link, 'subsumption', FSubsumption.Link);
end;

procedure TFhirTerminologyCapabilitiesCodeSystem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'uri', 'canonical', false, TFhirCanonical, FUri.Link));
  oList.add(TFHIRProperty.create(self, 'version', 'BackboneElement', true, TFhirTerminologyCapabilitiesCodeSystemVersion, FVersionList.Link));
  oList.add(TFHIRProperty.create(self, 'subsumption', 'boolean', false, TFhirBoolean, FSubsumption.Link));
end;

function TFhirTerminologyCapabilitiesCodeSystem.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'uri') then
  begin
    UriElement := asCanonical(propValue);
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionList.add(propValue as TFhirTerminologyCapabilitiesCodeSystemVersion);
    result := propValue;
  end
  else if (propName = 'subsumption') then
  begin
    SubsumptionElement := asBoolean(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTerminologyCapabilitiesCodeSystem.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'version') then VersionList.insertItem(index, propValue as TFhirTerminologyCapabilitiesCodeSystemVersion)
  else inherited;
end;

function TFhirTerminologyCapabilitiesCodeSystem.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'uri') then result := TFhirCanonical.create()
  else if (propName = 'version') then result := VersionList.new()
  else if (propName = 'subsumption') then result := TFhirBoolean.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirTerminologyCapabilitiesCodeSystem.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'uri') then result := 'canonical'
  else if (propName = 'version') then result := 'BackboneElement'
  else if (propName = 'subsumption') then result := 'boolean'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTerminologyCapabilitiesCodeSystem.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'uri') then UriElement := nil
  else if (propName = 'version') then deletePropertyValue('version', VersionList, value)
  else if (propName = 'subsumption') then SubsumptionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTerminologyCapabilitiesCodeSystem.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'uri') then UriElement := asCanonical(new)
  else if (propName = 'version') then replacePropertyValue('version', VersionList, existing, new)
  else if (propName = 'subsumption') then SubsumptionElement := asBoolean(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTerminologyCapabilitiesCodeSystem.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'version') then VersionList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirTerminologyCapabilitiesCodeSystem.fhirType : string;
begin
  result := 'TerminologyCapabilities.codeSystem';
end;

function TFhirTerminologyCapabilitiesCodeSystem.Link : TFhirTerminologyCapabilitiesCodeSystem;
begin
  result := TFhirTerminologyCapabilitiesCodeSystem(inherited Link);
end;

function TFhirTerminologyCapabilitiesCodeSystem.Clone : TFhirTerminologyCapabilitiesCodeSystem;
begin
  result := TFhirTerminologyCapabilitiesCodeSystem(inherited Clone);
end;

function TFhirTerminologyCapabilitiesCodeSystem.equals(other : TObject) : boolean; 
var
  o : TFhirTerminologyCapabilitiesCodeSystem;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTerminologyCapabilitiesCodeSystem)) then
    result := false
  else
  begin
    o := TFhirTerminologyCapabilitiesCodeSystem(other);
    result := compareDeep(uriElement, o.uriElement, true) and compareDeep(versionList, o.versionList, true) and 
      compareDeep(subsumptionElement, o.subsumptionElement, true);
  end;
end;

function TFhirTerminologyCapabilitiesCodeSystem.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FUri) and isEmptyProp(FversionList) and isEmptyProp(FSubsumption);
end;

procedure TFhirTerminologyCapabilitiesCodeSystem.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('uri');
  fields.add('version');
  fields.add('subsumption');
end;

function TFhirTerminologyCapabilitiesCodeSystem.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FVersionList.sizeInBytes(magic));
end;

procedure TFhirTerminologyCapabilitiesCodeSystem.SetUri(value : TFhirCanonical);
begin
  FUri.free;
  FUri := value;
end;

function TFhirTerminologyCapabilitiesCodeSystem.GetUriST : String;
begin
  if FUri = nil then
    result := ''
  else
    result := FUri.value;
end;

procedure TFhirTerminologyCapabilitiesCodeSystem.SetUriST(value : String);
begin
  if value <> '' then
  begin
    if FUri = nil then
      FUri := TFhirCanonical.create;
    FUri.value := value
  end
  else if FUri <> nil then
    FUri.value := '';
end;

function TFhirTerminologyCapabilitiesCodeSystem.GetVersionList : TFhirTerminologyCapabilitiesCodeSystemVersionList;
begin
  if FVersionList = nil then
    FVersionList := TFhirTerminologyCapabilitiesCodeSystemVersionList.Create;
  result := FVersionList;
end;

function TFhirTerminologyCapabilitiesCodeSystem.GetHasVersionList : boolean;
begin
  result := (FVersionList <> nil) and (FVersionList.count > 0);
end;

procedure TFhirTerminologyCapabilitiesCodeSystem.SetSubsumption(value : TFhirBoolean);
begin
  FSubsumption.free;
  FSubsumption := value;
end;

function TFhirTerminologyCapabilitiesCodeSystem.GetSubsumptionST : Boolean;
begin
  if FSubsumption = nil then
    result := false
  else
    result := FSubsumption.value;
end;

procedure TFhirTerminologyCapabilitiesCodeSystem.SetSubsumptionST(value : Boolean);
begin
  if FSubsumption = nil then
    FSubsumption := TFhirBoolean.create;
  FSubsumption.value := value
end;

{ TFhirTerminologyCapabilitiesCodeSystemListEnumerator }

constructor TFhirTerminologyCapabilitiesCodeSystemListEnumerator.Create(list : TFhirTerminologyCapabilitiesCodeSystemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTerminologyCapabilitiesCodeSystemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTerminologyCapabilitiesCodeSystemListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTerminologyCapabilitiesCodeSystemListEnumerator.GetCurrent : TFhirTerminologyCapabilitiesCodeSystem;
begin
  Result := FList[FIndex];
end;

function TFhirTerminologyCapabilitiesCodeSystemListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirTerminologyCapabilitiesCodeSystemList }

function TFhirTerminologyCapabilitiesCodeSystemList.AddItem(value: TFhirTerminologyCapabilitiesCodeSystem): TFhirTerminologyCapabilitiesCodeSystem;
begin
  assert(value.ClassName = 'TFhirTerminologyCapabilitiesCodeSystem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTerminologyCapabilitiesCodeSystem');
  add(value);
  result := value;
end;

function TFhirTerminologyCapabilitiesCodeSystemList.Append: TFhirTerminologyCapabilitiesCodeSystem;
begin
  result := TFhirTerminologyCapabilitiesCodeSystem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTerminologyCapabilitiesCodeSystemList.ClearItems;
begin
  Clear;
end;

function TFhirTerminologyCapabilitiesCodeSystemList.GetEnumerator : TFhirTerminologyCapabilitiesCodeSystemListEnumerator;
begin
  result := TFhirTerminologyCapabilitiesCodeSystemListEnumerator.Create(self.link);
end;

function TFhirTerminologyCapabilitiesCodeSystemList.Clone: TFhirTerminologyCapabilitiesCodeSystemList;
begin
  result := TFhirTerminologyCapabilitiesCodeSystemList(inherited Clone);
end;

function TFhirTerminologyCapabilitiesCodeSystemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTerminologyCapabilitiesCodeSystemList.GetItemN(index: Integer): TFhirTerminologyCapabilitiesCodeSystem;
begin
  result := TFhirTerminologyCapabilitiesCodeSystem(ObjectByIndex[index]);
end;

function TFhirTerminologyCapabilitiesCodeSystemList.ItemClass: TFslObjectClass;
begin
  result := TFhirTerminologyCapabilitiesCodeSystem;
end;
function TFhirTerminologyCapabilitiesCodeSystemList.IndexOf(value: TFhirTerminologyCapabilitiesCodeSystem): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTerminologyCapabilitiesCodeSystemList.Insert(index: Integer): TFhirTerminologyCapabilitiesCodeSystem;
begin
  result := TFhirTerminologyCapabilitiesCodeSystem.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTerminologyCapabilitiesCodeSystemList.InsertItem(index: Integer; value: TFhirTerminologyCapabilitiesCodeSystem);
begin
  assert(value is TFhirTerminologyCapabilitiesCodeSystem);
  Inherited Insert(index, value);
end;

function TFhirTerminologyCapabilitiesCodeSystemList.Item(index: Integer): TFhirTerminologyCapabilitiesCodeSystem;
begin
  result := TFhirTerminologyCapabilitiesCodeSystem(ObjectByIndex[index]);
end;

function TFhirTerminologyCapabilitiesCodeSystemList.Link: TFhirTerminologyCapabilitiesCodeSystemList;
begin
  result := TFhirTerminologyCapabilitiesCodeSystemList(inherited Link);
end;

procedure TFhirTerminologyCapabilitiesCodeSystemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTerminologyCapabilitiesCodeSystemList.SetItemByIndex(index: Integer; value: TFhirTerminologyCapabilitiesCodeSystem);
begin
  assert(value is TFhirTerminologyCapabilitiesCodeSystem);
  FhirTerminologyCapabilitiesCodeSystems[index] := value;
end;

procedure TFhirTerminologyCapabilitiesCodeSystemList.SetItemN(index: Integer; value: TFhirTerminologyCapabilitiesCodeSystem);
begin
  assert(value is TFhirTerminologyCapabilitiesCodeSystem);
  ObjectByIndex[index] := value;
end;

{ TFhirTerminologyCapabilitiesCodeSystemVersion }

constructor TFhirTerminologyCapabilitiesCodeSystemVersion.Create;
begin
  inherited;
end;

destructor TFhirTerminologyCapabilitiesCodeSystemVersion.Destroy;
begin
  FCode.free;
  FIsDefault.free;
  FCompositional.free;
  FLanguageList.Free;
  FFilterList.Free;
  FProperty_List.Free;
  inherited;
end;

procedure TFhirTerminologyCapabilitiesCodeSystemVersion.Assign(oSource : TFslObject);
begin
  inherited;
  codeElement := TFhirTerminologyCapabilitiesCodeSystemVersion(oSource).codeElement.Clone;
  isDefaultElement := TFhirTerminologyCapabilitiesCodeSystemVersion(oSource).isDefaultElement.Clone;
  compositionalElement := TFhirTerminologyCapabilitiesCodeSystemVersion(oSource).compositionalElement.Clone;
  if (TFhirTerminologyCapabilitiesCodeSystemVersion(oSource).FLanguageList = nil) then
  begin
    FLanguageList.free;
    FLanguageList := nil;
  end
  else
  begin
    if FLanguageList = nil then
      FLanguageList := TFhirCodeList.Create;
    FLanguageList.Assign(TFhirTerminologyCapabilitiesCodeSystemVersion(oSource).FLanguageList);
  end;
  if (TFhirTerminologyCapabilitiesCodeSystemVersion(oSource).FFilterList = nil) then
  begin
    FFilterList.free;
    FFilterList := nil;
  end
  else
  begin
    if FFilterList = nil then
      FFilterList := TFhirTerminologyCapabilitiesCodeSystemVersionFilterList.Create;
    FFilterList.Assign(TFhirTerminologyCapabilitiesCodeSystemVersion(oSource).FFilterList);
  end;
  if (TFhirTerminologyCapabilitiesCodeSystemVersion(oSource).FProperty_List = nil) then
  begin
    FProperty_List.free;
    FProperty_List := nil;
  end
  else
  begin
    if FProperty_List = nil then
      FProperty_List := TFhirCodeList.Create;
    FProperty_List.Assign(TFhirTerminologyCapabilitiesCodeSystemVersion(oSource).FProperty_List);
  end;
end;

procedure TFhirTerminologyCapabilitiesCodeSystemVersion.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'isDefault') Then
     list.add(self.link, 'isDefault', FIsDefault.Link);
  if (child_name = 'compositional') Then
     list.add(self.link, 'compositional', FCompositional.Link);
  if (child_name = 'language') Then
    list.addAll(self, 'language', FLanguageList);
  if (child_name = 'filter') Then
    list.addAll(self, 'filter', FFilterList);
  if (child_name = 'property') Then
    list.addAll(self, 'property', FProperty_List);
end;

procedure TFhirTerminologyCapabilitiesCodeSystemVersion.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'string', false, TFhirString, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'isDefault', 'boolean', false, TFhirBoolean, FIsDefault.Link));
  oList.add(TFHIRProperty.create(self, 'compositional', 'boolean', false, TFhirBoolean, FCompositional.Link));
  oList.add(TFHIRProperty.create(self, 'language', 'code', true, TFhirCode, FLanguageList.Link));
  oList.add(TFHIRProperty.create(self, 'filter', 'BackboneElement', true, TFhirTerminologyCapabilitiesCodeSystemVersionFilter, FFilterList.Link));
  oList.add(TFHIRProperty.create(self, 'property', 'code', true, TFhirCode, FProperty_List.Link));
end;

function TFhirTerminologyCapabilitiesCodeSystemVersion.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    CodeElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'isDefault') then
  begin
    IsDefaultElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'compositional') then
  begin
    CompositionalElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'language') then
  begin
    LanguageList.add(asCode(propValue)){2};     result := propValue;

  end
  else if (propName = 'filter') then
  begin
    FilterList.add(propValue as TFhirTerminologyCapabilitiesCodeSystemVersionFilter);
    result := propValue;
  end
  else if (propName = 'property') then
  begin
    Property_List.add(asCode(propValue)){2};     result := propValue;

  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTerminologyCapabilitiesCodeSystemVersion.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'language') then LanguageList.insertItem(index, asCode(propValue))
  else if (propName = 'filter') then FilterList.insertItem(index, propValue as TFhirTerminologyCapabilitiesCodeSystemVersionFilter)
  else if (propName = 'property') then Property_List.insertItem(index, asCode(propValue))
  else inherited;
end;

function TFhirTerminologyCapabilitiesCodeSystemVersion.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirString.create()
  else if (propName = 'isDefault') then result := TFhirBoolean.create()
  else if (propName = 'compositional') then result := TFhirBoolean.create()
  else if (propName = 'language') then result := LanguageList.new()
  else if (propName = 'filter') then result := FilterList.new()
  else if (propName = 'property') then result := Property_List.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirTerminologyCapabilitiesCodeSystemVersion.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'string'
  else if (propName = 'isDefault') then result := 'boolean'
  else if (propName = 'compositional') then result := 'boolean'
  else if (propName = 'language') then result := 'code'
  else if (propName = 'filter') then result := 'BackboneElement'
  else if (propName = 'property') then result := 'code'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTerminologyCapabilitiesCodeSystemVersion.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'isDefault') then IsDefaultElement := nil
  else if (propName = 'compositional') then CompositionalElement := nil
  else if (propName = 'language') then deletePropertyValue('language', LanguageList, value)
  else if (propName = 'filter') then deletePropertyValue('filter', FilterList, value)
  else if (propName = 'property') then deletePropertyValue('property', Property_List, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTerminologyCapabilitiesCodeSystemVersion.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := asString(new)
  else if (propName = 'isDefault') then IsDefaultElement := asBoolean(new)
  else if (propName = 'compositional') then CompositionalElement := asBoolean(new)
  else if (propName = 'language') then replacePropertyValue('language', LanguageList, existing, new)
  else if (propName = 'filter') then replacePropertyValue('filter', FilterList, existing, new)
  else if (propName = 'property') then replacePropertyValue('property', Property_List, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTerminologyCapabilitiesCodeSystemVersion.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'language') then LanguageList.move(source, destination)
  else if (propName = 'filter') then FilterList.move(source, destination)
  else if (propName = 'property') then Property_List.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirTerminologyCapabilitiesCodeSystemVersion.fhirType : string;
begin
  result := 'TerminologyCapabilities.codeSystem.version';
end;

function TFhirTerminologyCapabilitiesCodeSystemVersion.Link : TFhirTerminologyCapabilitiesCodeSystemVersion;
begin
  result := TFhirTerminologyCapabilitiesCodeSystemVersion(inherited Link);
end;

function TFhirTerminologyCapabilitiesCodeSystemVersion.Clone : TFhirTerminologyCapabilitiesCodeSystemVersion;
begin
  result := TFhirTerminologyCapabilitiesCodeSystemVersion(inherited Clone);
end;

function TFhirTerminologyCapabilitiesCodeSystemVersion.equals(other : TObject) : boolean; 
var
  o : TFhirTerminologyCapabilitiesCodeSystemVersion;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTerminologyCapabilitiesCodeSystemVersion)) then
    result := false
  else
  begin
    o := TFhirTerminologyCapabilitiesCodeSystemVersion(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(isDefaultElement, o.isDefaultElement, true) and 
      compareDeep(compositionalElement, o.compositionalElement, true) and compareDeep(languageList, o.languageList, true) and 
      compareDeep(filterList, o.filterList, true) and compareDeep(property_List, o.property_List, true);
  end;
end;

function TFhirTerminologyCapabilitiesCodeSystemVersion.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FIsDefault) and isEmptyProp(FCompositional) and isEmptyProp(FlanguageList) and isEmptyProp(FfilterList) and isEmptyProp(Fproperty_List);
end;

procedure TFhirTerminologyCapabilitiesCodeSystemVersion.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('code');
  fields.add('isDefault');
  fields.add('compositional');
  fields.add('language');
  fields.add('filter');
  fields.add('property');
end;

function TFhirTerminologyCapabilitiesCodeSystemVersion.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FLanguageList.sizeInBytes(magic));
  inc(result, FFilterList.sizeInBytes(magic));
  inc(result, FProperty_List.sizeInBytes(magic));
end;

procedure TFhirTerminologyCapabilitiesCodeSystemVersion.SetCode(value : TFhirString);
begin
  FCode.free;
  FCode := value;
end;

function TFhirTerminologyCapabilitiesCodeSystemVersion.GetCodeST : String;
begin
  if FCode = nil then
    result := ''
  else
    result := FCode.value;
end;

procedure TFhirTerminologyCapabilitiesCodeSystemVersion.SetCodeST(value : String);
begin
  if value <> '' then
  begin
    if FCode = nil then
      FCode := TFhirString.create;
    FCode.value := value
  end
  else if FCode <> nil then
    FCode.value := '';
end;

procedure TFhirTerminologyCapabilitiesCodeSystemVersion.SetIsDefault(value : TFhirBoolean);
begin
  FIsDefault.free;
  FIsDefault := value;
end;

function TFhirTerminologyCapabilitiesCodeSystemVersion.GetIsDefaultST : Boolean;
begin
  if FIsDefault = nil then
    result := false
  else
    result := FIsDefault.value;
end;

procedure TFhirTerminologyCapabilitiesCodeSystemVersion.SetIsDefaultST(value : Boolean);
begin
  if FIsDefault = nil then
    FIsDefault := TFhirBoolean.create;
  FIsDefault.value := value
end;

procedure TFhirTerminologyCapabilitiesCodeSystemVersion.SetCompositional(value : TFhirBoolean);
begin
  FCompositional.free;
  FCompositional := value;
end;

function TFhirTerminologyCapabilitiesCodeSystemVersion.GetCompositionalST : Boolean;
begin
  if FCompositional = nil then
    result := false
  else
    result := FCompositional.value;
end;

procedure TFhirTerminologyCapabilitiesCodeSystemVersion.SetCompositionalST(value : Boolean);
begin
  if FCompositional = nil then
    FCompositional := TFhirBoolean.create;
  FCompositional.value := value
end;

function TFhirTerminologyCapabilitiesCodeSystemVersion.GetLanguageList : TFhirCodeList;
begin
  if FLanguageList = nil then
    FLanguageList := TFhirCodeList.Create;
  result := FLanguageList;
end;

function TFhirTerminologyCapabilitiesCodeSystemVersion.GetHasLanguageList : boolean;
begin
  result := (FLanguageList <> nil) and (FLanguageList.count > 0);
end;

function TFhirTerminologyCapabilitiesCodeSystemVersion.GetFilterList : TFhirTerminologyCapabilitiesCodeSystemVersionFilterList;
begin
  if FFilterList = nil then
    FFilterList := TFhirTerminologyCapabilitiesCodeSystemVersionFilterList.Create;
  result := FFilterList;
end;

function TFhirTerminologyCapabilitiesCodeSystemVersion.GetHasFilterList : boolean;
begin
  result := (FFilterList <> nil) and (FFilterList.count > 0);
end;

function TFhirTerminologyCapabilitiesCodeSystemVersion.GetProperty_List : TFhirCodeList;
begin
  if FProperty_List = nil then
    FProperty_List := TFhirCodeList.Create;
  result := FProperty_List;
end;

function TFhirTerminologyCapabilitiesCodeSystemVersion.GetHasProperty_List : boolean;
begin
  result := (FProperty_List <> nil) and (FProperty_List.count > 0);
end;

{ TFhirTerminologyCapabilitiesCodeSystemVersionListEnumerator }

constructor TFhirTerminologyCapabilitiesCodeSystemVersionListEnumerator.Create(list : TFhirTerminologyCapabilitiesCodeSystemVersionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTerminologyCapabilitiesCodeSystemVersionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTerminologyCapabilitiesCodeSystemVersionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTerminologyCapabilitiesCodeSystemVersionListEnumerator.GetCurrent : TFhirTerminologyCapabilitiesCodeSystemVersion;
begin
  Result := FList[FIndex];
end;

function TFhirTerminologyCapabilitiesCodeSystemVersionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirTerminologyCapabilitiesCodeSystemVersionList }

function TFhirTerminologyCapabilitiesCodeSystemVersionList.AddItem(value: TFhirTerminologyCapabilitiesCodeSystemVersion): TFhirTerminologyCapabilitiesCodeSystemVersion;
begin
  assert(value.ClassName = 'TFhirTerminologyCapabilitiesCodeSystemVersion', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTerminologyCapabilitiesCodeSystemVersion');
  add(value);
  result := value;
end;

function TFhirTerminologyCapabilitiesCodeSystemVersionList.Append: TFhirTerminologyCapabilitiesCodeSystemVersion;
begin
  result := TFhirTerminologyCapabilitiesCodeSystemVersion.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTerminologyCapabilitiesCodeSystemVersionList.ClearItems;
begin
  Clear;
end;

function TFhirTerminologyCapabilitiesCodeSystemVersionList.GetEnumerator : TFhirTerminologyCapabilitiesCodeSystemVersionListEnumerator;
begin
  result := TFhirTerminologyCapabilitiesCodeSystemVersionListEnumerator.Create(self.link);
end;

function TFhirTerminologyCapabilitiesCodeSystemVersionList.Clone: TFhirTerminologyCapabilitiesCodeSystemVersionList;
begin
  result := TFhirTerminologyCapabilitiesCodeSystemVersionList(inherited Clone);
end;

function TFhirTerminologyCapabilitiesCodeSystemVersionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTerminologyCapabilitiesCodeSystemVersionList.GetItemN(index: Integer): TFhirTerminologyCapabilitiesCodeSystemVersion;
begin
  result := TFhirTerminologyCapabilitiesCodeSystemVersion(ObjectByIndex[index]);
end;

function TFhirTerminologyCapabilitiesCodeSystemVersionList.ItemClass: TFslObjectClass;
begin
  result := TFhirTerminologyCapabilitiesCodeSystemVersion;
end;
function TFhirTerminologyCapabilitiesCodeSystemVersionList.IndexOf(value: TFhirTerminologyCapabilitiesCodeSystemVersion): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTerminologyCapabilitiesCodeSystemVersionList.Insert(index: Integer): TFhirTerminologyCapabilitiesCodeSystemVersion;
begin
  result := TFhirTerminologyCapabilitiesCodeSystemVersion.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTerminologyCapabilitiesCodeSystemVersionList.InsertItem(index: Integer; value: TFhirTerminologyCapabilitiesCodeSystemVersion);
begin
  assert(value is TFhirTerminologyCapabilitiesCodeSystemVersion);
  Inherited Insert(index, value);
end;

function TFhirTerminologyCapabilitiesCodeSystemVersionList.Item(index: Integer): TFhirTerminologyCapabilitiesCodeSystemVersion;
begin
  result := TFhirTerminologyCapabilitiesCodeSystemVersion(ObjectByIndex[index]);
end;

function TFhirTerminologyCapabilitiesCodeSystemVersionList.Link: TFhirTerminologyCapabilitiesCodeSystemVersionList;
begin
  result := TFhirTerminologyCapabilitiesCodeSystemVersionList(inherited Link);
end;

procedure TFhirTerminologyCapabilitiesCodeSystemVersionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTerminologyCapabilitiesCodeSystemVersionList.SetItemByIndex(index: Integer; value: TFhirTerminologyCapabilitiesCodeSystemVersion);
begin
  assert(value is TFhirTerminologyCapabilitiesCodeSystemVersion);
  FhirTerminologyCapabilitiesCodeSystemVersions[index] := value;
end;

procedure TFhirTerminologyCapabilitiesCodeSystemVersionList.SetItemN(index: Integer; value: TFhirTerminologyCapabilitiesCodeSystemVersion);
begin
  assert(value is TFhirTerminologyCapabilitiesCodeSystemVersion);
  ObjectByIndex[index] := value;
end;

{ TFhirTerminologyCapabilitiesCodeSystemVersionFilter }

constructor TFhirTerminologyCapabilitiesCodeSystemVersionFilter.Create;
begin
  inherited;
end;

destructor TFhirTerminologyCapabilitiesCodeSystemVersionFilter.Destroy;
begin
  FCode.free;
  FOpList.Free;
  inherited;
end;

procedure TFhirTerminologyCapabilitiesCodeSystemVersionFilter.Assign(oSource : TFslObject);
begin
  inherited;
  codeElement := TFhirTerminologyCapabilitiesCodeSystemVersionFilter(oSource).codeElement.Clone;
  if (TFhirTerminologyCapabilitiesCodeSystemVersionFilter(oSource).FOpList = nil) then
  begin
    FOpList.free;
    FOpList := nil;
  end
  else
  begin
    if FOpList = nil then
      FOpList := TFhirCodeList.Create;
    FOpList.Assign(TFhirTerminologyCapabilitiesCodeSystemVersionFilter(oSource).FOpList);
  end;
end;

procedure TFhirTerminologyCapabilitiesCodeSystemVersionFilter.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'op') Then
    list.addAll(self, 'op', FOpList);
end;

procedure TFhirTerminologyCapabilitiesCodeSystemVersionFilter.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'code', false, TFhirCode, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'op', 'code', true, TFhirCode, FOpList.Link));
end;

function TFhirTerminologyCapabilitiesCodeSystemVersionFilter.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    CodeElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'op') then
  begin
    OpList.add(asCode(propValue)){2};     result := propValue;

  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTerminologyCapabilitiesCodeSystemVersionFilter.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'op') then OpList.insertItem(index, asCode(propValue))
  else inherited;
end;

function TFhirTerminologyCapabilitiesCodeSystemVersionFilter.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCode.create()
  else if (propName = 'op') then result := OpList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirTerminologyCapabilitiesCodeSystemVersionFilter.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'code'
  else if (propName = 'op') then result := 'code'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTerminologyCapabilitiesCodeSystemVersionFilter.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'op') then deletePropertyValue('op', OpList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTerminologyCapabilitiesCodeSystemVersionFilter.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := asCode(new)
  else if (propName = 'op') then replacePropertyValue('op', OpList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTerminologyCapabilitiesCodeSystemVersionFilter.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'op') then OpList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirTerminologyCapabilitiesCodeSystemVersionFilter.fhirType : string;
begin
  result := 'TerminologyCapabilities.codeSystem.version.filter';
end;

function TFhirTerminologyCapabilitiesCodeSystemVersionFilter.Link : TFhirTerminologyCapabilitiesCodeSystemVersionFilter;
begin
  result := TFhirTerminologyCapabilitiesCodeSystemVersionFilter(inherited Link);
end;

function TFhirTerminologyCapabilitiesCodeSystemVersionFilter.Clone : TFhirTerminologyCapabilitiesCodeSystemVersionFilter;
begin
  result := TFhirTerminologyCapabilitiesCodeSystemVersionFilter(inherited Clone);
end;

function TFhirTerminologyCapabilitiesCodeSystemVersionFilter.equals(other : TObject) : boolean; 
var
  o : TFhirTerminologyCapabilitiesCodeSystemVersionFilter;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTerminologyCapabilitiesCodeSystemVersionFilter)) then
    result := false
  else
  begin
    o := TFhirTerminologyCapabilitiesCodeSystemVersionFilter(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(opList, o.opList, true);
  end;
end;

function TFhirTerminologyCapabilitiesCodeSystemVersionFilter.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FopList);
end;

procedure TFhirTerminologyCapabilitiesCodeSystemVersionFilter.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('code');
  fields.add('op');
end;

function TFhirTerminologyCapabilitiesCodeSystemVersionFilter.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FOpList.sizeInBytes(magic));
end;

procedure TFhirTerminologyCapabilitiesCodeSystemVersionFilter.SetCode(value : TFhirCode);
begin
  FCode.free;
  FCode := value;
end;

function TFhirTerminologyCapabilitiesCodeSystemVersionFilter.GetCodeST : String;
begin
  if FCode = nil then
    result := ''
  else
    result := FCode.value;
end;

procedure TFhirTerminologyCapabilitiesCodeSystemVersionFilter.SetCodeST(value : String);
begin
  if value <> '' then
  begin
    if FCode = nil then
      FCode := TFhirCode.create;
    FCode.value := value
  end
  else if FCode <> nil then
    FCode.value := '';
end;

function TFhirTerminologyCapabilitiesCodeSystemVersionFilter.GetOpList : TFhirCodeList;
begin
  if FOpList = nil then
    FOpList := TFhirCodeList.Create;
  result := FOpList;
end;

function TFhirTerminologyCapabilitiesCodeSystemVersionFilter.GetHasOpList : boolean;
begin
  result := (FOpList <> nil) and (FOpList.count > 0);
end;

{ TFhirTerminologyCapabilitiesCodeSystemVersionFilterListEnumerator }

constructor TFhirTerminologyCapabilitiesCodeSystemVersionFilterListEnumerator.Create(list : TFhirTerminologyCapabilitiesCodeSystemVersionFilterList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTerminologyCapabilitiesCodeSystemVersionFilterListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTerminologyCapabilitiesCodeSystemVersionFilterListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTerminologyCapabilitiesCodeSystemVersionFilterListEnumerator.GetCurrent : TFhirTerminologyCapabilitiesCodeSystemVersionFilter;
begin
  Result := FList[FIndex];
end;

function TFhirTerminologyCapabilitiesCodeSystemVersionFilterListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirTerminologyCapabilitiesCodeSystemVersionFilterList }

function TFhirTerminologyCapabilitiesCodeSystemVersionFilterList.AddItem(value: TFhirTerminologyCapabilitiesCodeSystemVersionFilter): TFhirTerminologyCapabilitiesCodeSystemVersionFilter;
begin
  assert(value.ClassName = 'TFhirTerminologyCapabilitiesCodeSystemVersionFilter', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTerminologyCapabilitiesCodeSystemVersionFilter');
  add(value);
  result := value;
end;

function TFhirTerminologyCapabilitiesCodeSystemVersionFilterList.Append: TFhirTerminologyCapabilitiesCodeSystemVersionFilter;
begin
  result := TFhirTerminologyCapabilitiesCodeSystemVersionFilter.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTerminologyCapabilitiesCodeSystemVersionFilterList.ClearItems;
begin
  Clear;
end;

function TFhirTerminologyCapabilitiesCodeSystemVersionFilterList.GetEnumerator : TFhirTerminologyCapabilitiesCodeSystemVersionFilterListEnumerator;
begin
  result := TFhirTerminologyCapabilitiesCodeSystemVersionFilterListEnumerator.Create(self.link);
end;

function TFhirTerminologyCapabilitiesCodeSystemVersionFilterList.Clone: TFhirTerminologyCapabilitiesCodeSystemVersionFilterList;
begin
  result := TFhirTerminologyCapabilitiesCodeSystemVersionFilterList(inherited Clone);
end;

function TFhirTerminologyCapabilitiesCodeSystemVersionFilterList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTerminologyCapabilitiesCodeSystemVersionFilterList.GetItemN(index: Integer): TFhirTerminologyCapabilitiesCodeSystemVersionFilter;
begin
  result := TFhirTerminologyCapabilitiesCodeSystemVersionFilter(ObjectByIndex[index]);
end;

function TFhirTerminologyCapabilitiesCodeSystemVersionFilterList.ItemClass: TFslObjectClass;
begin
  result := TFhirTerminologyCapabilitiesCodeSystemVersionFilter;
end;
function TFhirTerminologyCapabilitiesCodeSystemVersionFilterList.IndexOf(value: TFhirTerminologyCapabilitiesCodeSystemVersionFilter): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTerminologyCapabilitiesCodeSystemVersionFilterList.Insert(index: Integer): TFhirTerminologyCapabilitiesCodeSystemVersionFilter;
begin
  result := TFhirTerminologyCapabilitiesCodeSystemVersionFilter.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTerminologyCapabilitiesCodeSystemVersionFilterList.InsertItem(index: Integer; value: TFhirTerminologyCapabilitiesCodeSystemVersionFilter);
begin
  assert(value is TFhirTerminologyCapabilitiesCodeSystemVersionFilter);
  Inherited Insert(index, value);
end;

function TFhirTerminologyCapabilitiesCodeSystemVersionFilterList.Item(index: Integer): TFhirTerminologyCapabilitiesCodeSystemVersionFilter;
begin
  result := TFhirTerminologyCapabilitiesCodeSystemVersionFilter(ObjectByIndex[index]);
end;

function TFhirTerminologyCapabilitiesCodeSystemVersionFilterList.Link: TFhirTerminologyCapabilitiesCodeSystemVersionFilterList;
begin
  result := TFhirTerminologyCapabilitiesCodeSystemVersionFilterList(inherited Link);
end;

procedure TFhirTerminologyCapabilitiesCodeSystemVersionFilterList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTerminologyCapabilitiesCodeSystemVersionFilterList.SetItemByIndex(index: Integer; value: TFhirTerminologyCapabilitiesCodeSystemVersionFilter);
begin
  assert(value is TFhirTerminologyCapabilitiesCodeSystemVersionFilter);
  FhirTerminologyCapabilitiesCodeSystemVersionFilters[index] := value;
end;

procedure TFhirTerminologyCapabilitiesCodeSystemVersionFilterList.SetItemN(index: Integer; value: TFhirTerminologyCapabilitiesCodeSystemVersionFilter);
begin
  assert(value is TFhirTerminologyCapabilitiesCodeSystemVersionFilter);
  ObjectByIndex[index] := value;
end;

{ TFhirTerminologyCapabilitiesExpansion }

constructor TFhirTerminologyCapabilitiesExpansion.Create;
begin
  inherited;
end;

destructor TFhirTerminologyCapabilitiesExpansion.Destroy;
begin
  FHierarchical.free;
  FPaging.free;
  FIncomplete.free;
  FParameterList.Free;
  FTextFilter.free;
  inherited;
end;

procedure TFhirTerminologyCapabilitiesExpansion.Assign(oSource : TFslObject);
begin
  inherited;
  hierarchicalElement := TFhirTerminologyCapabilitiesExpansion(oSource).hierarchicalElement.Clone;
  pagingElement := TFhirTerminologyCapabilitiesExpansion(oSource).pagingElement.Clone;
  incompleteElement := TFhirTerminologyCapabilitiesExpansion(oSource).incompleteElement.Clone;
  if (TFhirTerminologyCapabilitiesExpansion(oSource).FParameterList = nil) then
  begin
    FParameterList.free;
    FParameterList := nil;
  end
  else
  begin
    if FParameterList = nil then
      FParameterList := TFhirTerminologyCapabilitiesExpansionParameterList.Create;
    FParameterList.Assign(TFhirTerminologyCapabilitiesExpansion(oSource).FParameterList);
  end;
  textFilterElement := TFhirTerminologyCapabilitiesExpansion(oSource).textFilterElement.Clone;
end;

procedure TFhirTerminologyCapabilitiesExpansion.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'hierarchical') Then
     list.add(self.link, 'hierarchical', FHierarchical.Link);
  if (child_name = 'paging') Then
     list.add(self.link, 'paging', FPaging.Link);
  if (child_name = 'incomplete') Then
     list.add(self.link, 'incomplete', FIncomplete.Link);
  if (child_name = 'parameter') Then
    list.addAll(self, 'parameter', FParameterList);
  if (child_name = 'textFilter') Then
     list.add(self.link, 'textFilter', FTextFilter.Link);
end;

procedure TFhirTerminologyCapabilitiesExpansion.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'hierarchical', 'boolean', false, TFhirBoolean, FHierarchical.Link));
  oList.add(TFHIRProperty.create(self, 'paging', 'boolean', false, TFhirBoolean, FPaging.Link));
  oList.add(TFHIRProperty.create(self, 'incomplete', 'boolean', false, TFhirBoolean, FIncomplete.Link));
  oList.add(TFHIRProperty.create(self, 'parameter', 'BackboneElement', true, TFhirTerminologyCapabilitiesExpansionParameter, FParameterList.Link));
  oList.add(TFHIRProperty.create(self, 'textFilter', 'markdown', false, TFhirMarkdown, FTextFilter.Link));
end;

function TFhirTerminologyCapabilitiesExpansion.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'hierarchical') then
  begin
    HierarchicalElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'paging') then
  begin
    PagingElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'incomplete') then
  begin
    IncompleteElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'parameter') then
  begin
    ParameterList.add(propValue as TFhirTerminologyCapabilitiesExpansionParameter);
    result := propValue;
  end
  else if (propName = 'textFilter') then
  begin
    TextFilterElement := asMarkdown(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTerminologyCapabilitiesExpansion.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'parameter') then ParameterList.insertItem(index, propValue as TFhirTerminologyCapabilitiesExpansionParameter)
  else inherited;
end;

function TFhirTerminologyCapabilitiesExpansion.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'hierarchical') then result := TFhirBoolean.create()
  else if (propName = 'paging') then result := TFhirBoolean.create()
  else if (propName = 'incomplete') then result := TFhirBoolean.create()
  else if (propName = 'parameter') then result := ParameterList.new()
  else if (propName = 'textFilter') then result := TFhirMarkdown.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirTerminologyCapabilitiesExpansion.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'hierarchical') then result := 'boolean'
  else if (propName = 'paging') then result := 'boolean'
  else if (propName = 'incomplete') then result := 'boolean'
  else if (propName = 'parameter') then result := 'BackboneElement'
  else if (propName = 'textFilter') then result := 'markdown'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTerminologyCapabilitiesExpansion.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'hierarchical') then HierarchicalElement := nil
  else if (propName = 'paging') then PagingElement := nil
  else if (propName = 'incomplete') then IncompleteElement := nil
  else if (propName = 'parameter') then deletePropertyValue('parameter', ParameterList, value)
  else if (propName = 'textFilter') then TextFilterElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTerminologyCapabilitiesExpansion.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'hierarchical') then HierarchicalElement := asBoolean(new)
  else if (propName = 'paging') then PagingElement := asBoolean(new)
  else if (propName = 'incomplete') then IncompleteElement := asBoolean(new)
  else if (propName = 'parameter') then replacePropertyValue('parameter', ParameterList, existing, new)
  else if (propName = 'textFilter') then TextFilterElement := asMarkdown(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTerminologyCapabilitiesExpansion.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'parameter') then ParameterList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirTerminologyCapabilitiesExpansion.fhirType : string;
begin
  result := 'TerminologyCapabilities.expansion';
end;

function TFhirTerminologyCapabilitiesExpansion.Link : TFhirTerminologyCapabilitiesExpansion;
begin
  result := TFhirTerminologyCapabilitiesExpansion(inherited Link);
end;

function TFhirTerminologyCapabilitiesExpansion.Clone : TFhirTerminologyCapabilitiesExpansion;
begin
  result := TFhirTerminologyCapabilitiesExpansion(inherited Clone);
end;

function TFhirTerminologyCapabilitiesExpansion.equals(other : TObject) : boolean; 
var
  o : TFhirTerminologyCapabilitiesExpansion;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTerminologyCapabilitiesExpansion)) then
    result := false
  else
  begin
    o := TFhirTerminologyCapabilitiesExpansion(other);
    result := compareDeep(hierarchicalElement, o.hierarchicalElement, true) and 
      compareDeep(pagingElement, o.pagingElement, true) and compareDeep(incompleteElement, o.incompleteElement, true) and 
      compareDeep(parameterList, o.parameterList, true) and compareDeep(textFilterElement, o.textFilterElement, true);
  end;
end;

function TFhirTerminologyCapabilitiesExpansion.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FHierarchical) and isEmptyProp(FPaging) and isEmptyProp(FIncomplete) and isEmptyProp(FparameterList) and isEmptyProp(FTextFilter);
end;

procedure TFhirTerminologyCapabilitiesExpansion.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('hierarchical');
  fields.add('paging');
  fields.add('incomplete');
  fields.add('parameter');
  fields.add('textFilter');
end;

function TFhirTerminologyCapabilitiesExpansion.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FParameterList.sizeInBytes(magic));
end;

procedure TFhirTerminologyCapabilitiesExpansion.SetHierarchical(value : TFhirBoolean);
begin
  FHierarchical.free;
  FHierarchical := value;
end;

function TFhirTerminologyCapabilitiesExpansion.GetHierarchicalST : Boolean;
begin
  if FHierarchical = nil then
    result := false
  else
    result := FHierarchical.value;
end;

procedure TFhirTerminologyCapabilitiesExpansion.SetHierarchicalST(value : Boolean);
begin
  if FHierarchical = nil then
    FHierarchical := TFhirBoolean.create;
  FHierarchical.value := value
end;

procedure TFhirTerminologyCapabilitiesExpansion.SetPaging(value : TFhirBoolean);
begin
  FPaging.free;
  FPaging := value;
end;

function TFhirTerminologyCapabilitiesExpansion.GetPagingST : Boolean;
begin
  if FPaging = nil then
    result := false
  else
    result := FPaging.value;
end;

procedure TFhirTerminologyCapabilitiesExpansion.SetPagingST(value : Boolean);
begin
  if FPaging = nil then
    FPaging := TFhirBoolean.create;
  FPaging.value := value
end;

procedure TFhirTerminologyCapabilitiesExpansion.SetIncomplete(value : TFhirBoolean);
begin
  FIncomplete.free;
  FIncomplete := value;
end;

function TFhirTerminologyCapabilitiesExpansion.GetIncompleteST : Boolean;
begin
  if FIncomplete = nil then
    result := false
  else
    result := FIncomplete.value;
end;

procedure TFhirTerminologyCapabilitiesExpansion.SetIncompleteST(value : Boolean);
begin
  if FIncomplete = nil then
    FIncomplete := TFhirBoolean.create;
  FIncomplete.value := value
end;

function TFhirTerminologyCapabilitiesExpansion.GetParameterList : TFhirTerminologyCapabilitiesExpansionParameterList;
begin
  if FParameterList = nil then
    FParameterList := TFhirTerminologyCapabilitiesExpansionParameterList.Create;
  result := FParameterList;
end;

function TFhirTerminologyCapabilitiesExpansion.GetHasParameterList : boolean;
begin
  result := (FParameterList <> nil) and (FParameterList.count > 0);
end;

procedure TFhirTerminologyCapabilitiesExpansion.SetTextFilter(value : TFhirMarkdown);
begin
  FTextFilter.free;
  FTextFilter := value;
end;

function TFhirTerminologyCapabilitiesExpansion.GetTextFilterST : String;
begin
  if FTextFilter = nil then
    result := ''
  else
    result := FTextFilter.value;
end;

procedure TFhirTerminologyCapabilitiesExpansion.SetTextFilterST(value : String);
begin
  if value <> '' then
  begin
    if FTextFilter = nil then
      FTextFilter := TFhirMarkdown.create;
    FTextFilter.value := value
  end
  else if FTextFilter <> nil then
    FTextFilter.value := '';
end;

{ TFhirTerminologyCapabilitiesExpansionListEnumerator }

constructor TFhirTerminologyCapabilitiesExpansionListEnumerator.Create(list : TFhirTerminologyCapabilitiesExpansionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTerminologyCapabilitiesExpansionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTerminologyCapabilitiesExpansionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTerminologyCapabilitiesExpansionListEnumerator.GetCurrent : TFhirTerminologyCapabilitiesExpansion;
begin
  Result := FList[FIndex];
end;

function TFhirTerminologyCapabilitiesExpansionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirTerminologyCapabilitiesExpansionList }

function TFhirTerminologyCapabilitiesExpansionList.AddItem(value: TFhirTerminologyCapabilitiesExpansion): TFhirTerminologyCapabilitiesExpansion;
begin
  assert(value.ClassName = 'TFhirTerminologyCapabilitiesExpansion', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTerminologyCapabilitiesExpansion');
  add(value);
  result := value;
end;

function TFhirTerminologyCapabilitiesExpansionList.Append: TFhirTerminologyCapabilitiesExpansion;
begin
  result := TFhirTerminologyCapabilitiesExpansion.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTerminologyCapabilitiesExpansionList.ClearItems;
begin
  Clear;
end;

function TFhirTerminologyCapabilitiesExpansionList.GetEnumerator : TFhirTerminologyCapabilitiesExpansionListEnumerator;
begin
  result := TFhirTerminologyCapabilitiesExpansionListEnumerator.Create(self.link);
end;

function TFhirTerminologyCapabilitiesExpansionList.Clone: TFhirTerminologyCapabilitiesExpansionList;
begin
  result := TFhirTerminologyCapabilitiesExpansionList(inherited Clone);
end;

function TFhirTerminologyCapabilitiesExpansionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTerminologyCapabilitiesExpansionList.GetItemN(index: Integer): TFhirTerminologyCapabilitiesExpansion;
begin
  result := TFhirTerminologyCapabilitiesExpansion(ObjectByIndex[index]);
end;

function TFhirTerminologyCapabilitiesExpansionList.ItemClass: TFslObjectClass;
begin
  result := TFhirTerminologyCapabilitiesExpansion;
end;
function TFhirTerminologyCapabilitiesExpansionList.IndexOf(value: TFhirTerminologyCapabilitiesExpansion): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTerminologyCapabilitiesExpansionList.Insert(index: Integer): TFhirTerminologyCapabilitiesExpansion;
begin
  result := TFhirTerminologyCapabilitiesExpansion.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTerminologyCapabilitiesExpansionList.InsertItem(index: Integer; value: TFhirTerminologyCapabilitiesExpansion);
begin
  assert(value is TFhirTerminologyCapabilitiesExpansion);
  Inherited Insert(index, value);
end;

function TFhirTerminologyCapabilitiesExpansionList.Item(index: Integer): TFhirTerminologyCapabilitiesExpansion;
begin
  result := TFhirTerminologyCapabilitiesExpansion(ObjectByIndex[index]);
end;

function TFhirTerminologyCapabilitiesExpansionList.Link: TFhirTerminologyCapabilitiesExpansionList;
begin
  result := TFhirTerminologyCapabilitiesExpansionList(inherited Link);
end;

procedure TFhirTerminologyCapabilitiesExpansionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTerminologyCapabilitiesExpansionList.SetItemByIndex(index: Integer; value: TFhirTerminologyCapabilitiesExpansion);
begin
  assert(value is TFhirTerminologyCapabilitiesExpansion);
  FhirTerminologyCapabilitiesExpansions[index] := value;
end;

procedure TFhirTerminologyCapabilitiesExpansionList.SetItemN(index: Integer; value: TFhirTerminologyCapabilitiesExpansion);
begin
  assert(value is TFhirTerminologyCapabilitiesExpansion);
  ObjectByIndex[index] := value;
end;

{ TFhirTerminologyCapabilitiesExpansionParameter }

constructor TFhirTerminologyCapabilitiesExpansionParameter.Create;
begin
  inherited;
end;

destructor TFhirTerminologyCapabilitiesExpansionParameter.Destroy;
begin
  FName.free;
  FDocumentation.free;
  inherited;
end;

procedure TFhirTerminologyCapabilitiesExpansionParameter.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirTerminologyCapabilitiesExpansionParameter(oSource).nameElement.Clone;
  documentationElement := TFhirTerminologyCapabilitiesExpansionParameter(oSource).documentationElement.Clone;
end;

procedure TFhirTerminologyCapabilitiesExpansionParameter.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'documentation') Then
     list.add(self.link, 'documentation', FDocumentation.Link);
end;

procedure TFhirTerminologyCapabilitiesExpansionParameter.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'code', false, TFhirCode, FName.Link));
  oList.add(TFHIRProperty.create(self, 'documentation', 'string', false, TFhirString, FDocumentation.Link));
end;

function TFhirTerminologyCapabilitiesExpansionParameter.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'documentation') then
  begin
    DocumentationElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTerminologyCapabilitiesExpansionParameter.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirTerminologyCapabilitiesExpansionParameter.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirCode.create()
  else if (propName = 'documentation') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirTerminologyCapabilitiesExpansionParameter.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'code'
  else if (propName = 'documentation') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTerminologyCapabilitiesExpansionParameter.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'documentation') then DocumentationElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTerminologyCapabilitiesExpansionParameter.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asCode(new)
  else if (propName = 'documentation') then DocumentationElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTerminologyCapabilitiesExpansionParameter.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirTerminologyCapabilitiesExpansionParameter.fhirType : string;
begin
  result := 'TerminologyCapabilities.expansion.parameter';
end;

function TFhirTerminologyCapabilitiesExpansionParameter.Link : TFhirTerminologyCapabilitiesExpansionParameter;
begin
  result := TFhirTerminologyCapabilitiesExpansionParameter(inherited Link);
end;

function TFhirTerminologyCapabilitiesExpansionParameter.Clone : TFhirTerminologyCapabilitiesExpansionParameter;
begin
  result := TFhirTerminologyCapabilitiesExpansionParameter(inherited Clone);
end;

function TFhirTerminologyCapabilitiesExpansionParameter.equals(other : TObject) : boolean; 
var
  o : TFhirTerminologyCapabilitiesExpansionParameter;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTerminologyCapabilitiesExpansionParameter)) then
    result := false
  else
  begin
    o := TFhirTerminologyCapabilitiesExpansionParameter(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(documentationElement, o.documentationElement, true);
  end;
end;

function TFhirTerminologyCapabilitiesExpansionParameter.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FDocumentation);
end;

procedure TFhirTerminologyCapabilitiesExpansionParameter.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('name');
  fields.add('documentation');
end;

function TFhirTerminologyCapabilitiesExpansionParameter.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirTerminologyCapabilitiesExpansionParameter.SetName(value : TFhirCode);
begin
  FName.free;
  FName := value;
end;

function TFhirTerminologyCapabilitiesExpansionParameter.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirTerminologyCapabilitiesExpansionParameter.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirCode.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirTerminologyCapabilitiesExpansionParameter.SetDocumentation(value : TFhirString);
begin
  FDocumentation.free;
  FDocumentation := value;
end;

function TFhirTerminologyCapabilitiesExpansionParameter.GetDocumentationST : String;
begin
  if FDocumentation = nil then
    result := ''
  else
    result := FDocumentation.value;
end;

procedure TFhirTerminologyCapabilitiesExpansionParameter.SetDocumentationST(value : String);
begin
  if value <> '' then
  begin
    if FDocumentation = nil then
      FDocumentation := TFhirString.create;
    FDocumentation.value := value
  end
  else if FDocumentation <> nil then
    FDocumentation.value := '';
end;

{ TFhirTerminologyCapabilitiesExpansionParameterListEnumerator }

constructor TFhirTerminologyCapabilitiesExpansionParameterListEnumerator.Create(list : TFhirTerminologyCapabilitiesExpansionParameterList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTerminologyCapabilitiesExpansionParameterListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTerminologyCapabilitiesExpansionParameterListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTerminologyCapabilitiesExpansionParameterListEnumerator.GetCurrent : TFhirTerminologyCapabilitiesExpansionParameter;
begin
  Result := FList[FIndex];
end;

function TFhirTerminologyCapabilitiesExpansionParameterListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirTerminologyCapabilitiesExpansionParameterList }

function TFhirTerminologyCapabilitiesExpansionParameterList.AddItem(value: TFhirTerminologyCapabilitiesExpansionParameter): TFhirTerminologyCapabilitiesExpansionParameter;
begin
  assert(value.ClassName = 'TFhirTerminologyCapabilitiesExpansionParameter', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTerminologyCapabilitiesExpansionParameter');
  add(value);
  result := value;
end;

function TFhirTerminologyCapabilitiesExpansionParameterList.Append: TFhirTerminologyCapabilitiesExpansionParameter;
begin
  result := TFhirTerminologyCapabilitiesExpansionParameter.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTerminologyCapabilitiesExpansionParameterList.ClearItems;
begin
  Clear;
end;

function TFhirTerminologyCapabilitiesExpansionParameterList.GetEnumerator : TFhirTerminologyCapabilitiesExpansionParameterListEnumerator;
begin
  result := TFhirTerminologyCapabilitiesExpansionParameterListEnumerator.Create(self.link);
end;

function TFhirTerminologyCapabilitiesExpansionParameterList.Clone: TFhirTerminologyCapabilitiesExpansionParameterList;
begin
  result := TFhirTerminologyCapabilitiesExpansionParameterList(inherited Clone);
end;

function TFhirTerminologyCapabilitiesExpansionParameterList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTerminologyCapabilitiesExpansionParameterList.GetItemN(index: Integer): TFhirTerminologyCapabilitiesExpansionParameter;
begin
  result := TFhirTerminologyCapabilitiesExpansionParameter(ObjectByIndex[index]);
end;

function TFhirTerminologyCapabilitiesExpansionParameterList.ItemClass: TFslObjectClass;
begin
  result := TFhirTerminologyCapabilitiesExpansionParameter;
end;
function TFhirTerminologyCapabilitiesExpansionParameterList.IndexOf(value: TFhirTerminologyCapabilitiesExpansionParameter): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTerminologyCapabilitiesExpansionParameterList.Insert(index: Integer): TFhirTerminologyCapabilitiesExpansionParameter;
begin
  result := TFhirTerminologyCapabilitiesExpansionParameter.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTerminologyCapabilitiesExpansionParameterList.InsertItem(index: Integer; value: TFhirTerminologyCapabilitiesExpansionParameter);
begin
  assert(value is TFhirTerminologyCapabilitiesExpansionParameter);
  Inherited Insert(index, value);
end;

function TFhirTerminologyCapabilitiesExpansionParameterList.Item(index: Integer): TFhirTerminologyCapabilitiesExpansionParameter;
begin
  result := TFhirTerminologyCapabilitiesExpansionParameter(ObjectByIndex[index]);
end;

function TFhirTerminologyCapabilitiesExpansionParameterList.Link: TFhirTerminologyCapabilitiesExpansionParameterList;
begin
  result := TFhirTerminologyCapabilitiesExpansionParameterList(inherited Link);
end;

procedure TFhirTerminologyCapabilitiesExpansionParameterList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTerminologyCapabilitiesExpansionParameterList.SetItemByIndex(index: Integer; value: TFhirTerminologyCapabilitiesExpansionParameter);
begin
  assert(value is TFhirTerminologyCapabilitiesExpansionParameter);
  FhirTerminologyCapabilitiesExpansionParameters[index] := value;
end;

procedure TFhirTerminologyCapabilitiesExpansionParameterList.SetItemN(index: Integer; value: TFhirTerminologyCapabilitiesExpansionParameter);
begin
  assert(value is TFhirTerminologyCapabilitiesExpansionParameter);
  ObjectByIndex[index] := value;
end;

{ TFhirTerminologyCapabilitiesValidateCode }

constructor TFhirTerminologyCapabilitiesValidateCode.Create;
begin
  inherited;
end;

destructor TFhirTerminologyCapabilitiesValidateCode.Destroy;
begin
  FTranslations.free;
  inherited;
end;

procedure TFhirTerminologyCapabilitiesValidateCode.Assign(oSource : TFslObject);
begin
  inherited;
  translationsElement := TFhirTerminologyCapabilitiesValidateCode(oSource).translationsElement.Clone;
end;

procedure TFhirTerminologyCapabilitiesValidateCode.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'translations') Then
     list.add(self.link, 'translations', FTranslations.Link);
end;

procedure TFhirTerminologyCapabilitiesValidateCode.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'translations', 'boolean', false, TFhirBoolean, FTranslations.Link));
end;

function TFhirTerminologyCapabilitiesValidateCode.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'translations') then
  begin
    TranslationsElement := asBoolean(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTerminologyCapabilitiesValidateCode.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirTerminologyCapabilitiesValidateCode.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'translations') then result := TFhirBoolean.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirTerminologyCapabilitiesValidateCode.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'translations') then result := 'boolean'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTerminologyCapabilitiesValidateCode.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'translations') then TranslationsElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTerminologyCapabilitiesValidateCode.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'translations') then TranslationsElement := asBoolean(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTerminologyCapabilitiesValidateCode.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirTerminologyCapabilitiesValidateCode.fhirType : string;
begin
  result := 'TerminologyCapabilities.validateCode';
end;

function TFhirTerminologyCapabilitiesValidateCode.Link : TFhirTerminologyCapabilitiesValidateCode;
begin
  result := TFhirTerminologyCapabilitiesValidateCode(inherited Link);
end;

function TFhirTerminologyCapabilitiesValidateCode.Clone : TFhirTerminologyCapabilitiesValidateCode;
begin
  result := TFhirTerminologyCapabilitiesValidateCode(inherited Clone);
end;

function TFhirTerminologyCapabilitiesValidateCode.equals(other : TObject) : boolean; 
var
  o : TFhirTerminologyCapabilitiesValidateCode;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTerminologyCapabilitiesValidateCode)) then
    result := false
  else
  begin
    o := TFhirTerminologyCapabilitiesValidateCode(other);
    result := compareDeep(translationsElement, o.translationsElement, true);
  end;
end;

function TFhirTerminologyCapabilitiesValidateCode.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FTranslations);
end;

procedure TFhirTerminologyCapabilitiesValidateCode.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('translations');
end;

function TFhirTerminologyCapabilitiesValidateCode.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirTerminologyCapabilitiesValidateCode.SetTranslations(value : TFhirBoolean);
begin
  FTranslations.free;
  FTranslations := value;
end;

function TFhirTerminologyCapabilitiesValidateCode.GetTranslationsST : Boolean;
begin
  if FTranslations = nil then
    result := false
  else
    result := FTranslations.value;
end;

procedure TFhirTerminologyCapabilitiesValidateCode.SetTranslationsST(value : Boolean);
begin
  if FTranslations = nil then
    FTranslations := TFhirBoolean.create;
  FTranslations.value := value
end;

{ TFhirTerminologyCapabilitiesValidateCodeListEnumerator }

constructor TFhirTerminologyCapabilitiesValidateCodeListEnumerator.Create(list : TFhirTerminologyCapabilitiesValidateCodeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTerminologyCapabilitiesValidateCodeListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTerminologyCapabilitiesValidateCodeListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTerminologyCapabilitiesValidateCodeListEnumerator.GetCurrent : TFhirTerminologyCapabilitiesValidateCode;
begin
  Result := FList[FIndex];
end;

function TFhirTerminologyCapabilitiesValidateCodeListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirTerminologyCapabilitiesValidateCodeList }

function TFhirTerminologyCapabilitiesValidateCodeList.AddItem(value: TFhirTerminologyCapabilitiesValidateCode): TFhirTerminologyCapabilitiesValidateCode;
begin
  assert(value.ClassName = 'TFhirTerminologyCapabilitiesValidateCode', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTerminologyCapabilitiesValidateCode');
  add(value);
  result := value;
end;

function TFhirTerminologyCapabilitiesValidateCodeList.Append: TFhirTerminologyCapabilitiesValidateCode;
begin
  result := TFhirTerminologyCapabilitiesValidateCode.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTerminologyCapabilitiesValidateCodeList.ClearItems;
begin
  Clear;
end;

function TFhirTerminologyCapabilitiesValidateCodeList.GetEnumerator : TFhirTerminologyCapabilitiesValidateCodeListEnumerator;
begin
  result := TFhirTerminologyCapabilitiesValidateCodeListEnumerator.Create(self.link);
end;

function TFhirTerminologyCapabilitiesValidateCodeList.Clone: TFhirTerminologyCapabilitiesValidateCodeList;
begin
  result := TFhirTerminologyCapabilitiesValidateCodeList(inherited Clone);
end;

function TFhirTerminologyCapabilitiesValidateCodeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTerminologyCapabilitiesValidateCodeList.GetItemN(index: Integer): TFhirTerminologyCapabilitiesValidateCode;
begin
  result := TFhirTerminologyCapabilitiesValidateCode(ObjectByIndex[index]);
end;

function TFhirTerminologyCapabilitiesValidateCodeList.ItemClass: TFslObjectClass;
begin
  result := TFhirTerminologyCapabilitiesValidateCode;
end;
function TFhirTerminologyCapabilitiesValidateCodeList.IndexOf(value: TFhirTerminologyCapabilitiesValidateCode): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTerminologyCapabilitiesValidateCodeList.Insert(index: Integer): TFhirTerminologyCapabilitiesValidateCode;
begin
  result := TFhirTerminologyCapabilitiesValidateCode.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTerminologyCapabilitiesValidateCodeList.InsertItem(index: Integer; value: TFhirTerminologyCapabilitiesValidateCode);
begin
  assert(value is TFhirTerminologyCapabilitiesValidateCode);
  Inherited Insert(index, value);
end;

function TFhirTerminologyCapabilitiesValidateCodeList.Item(index: Integer): TFhirTerminologyCapabilitiesValidateCode;
begin
  result := TFhirTerminologyCapabilitiesValidateCode(ObjectByIndex[index]);
end;

function TFhirTerminologyCapabilitiesValidateCodeList.Link: TFhirTerminologyCapabilitiesValidateCodeList;
begin
  result := TFhirTerminologyCapabilitiesValidateCodeList(inherited Link);
end;

procedure TFhirTerminologyCapabilitiesValidateCodeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTerminologyCapabilitiesValidateCodeList.SetItemByIndex(index: Integer; value: TFhirTerminologyCapabilitiesValidateCode);
begin
  assert(value is TFhirTerminologyCapabilitiesValidateCode);
  FhirTerminologyCapabilitiesValidateCodes[index] := value;
end;

procedure TFhirTerminologyCapabilitiesValidateCodeList.SetItemN(index: Integer; value: TFhirTerminologyCapabilitiesValidateCode);
begin
  assert(value is TFhirTerminologyCapabilitiesValidateCode);
  ObjectByIndex[index] := value;
end;

{ TFhirTerminologyCapabilitiesTranslation }

constructor TFhirTerminologyCapabilitiesTranslation.Create;
begin
  inherited;
end;

destructor TFhirTerminologyCapabilitiesTranslation.Destroy;
begin
  FNeedsMap.free;
  inherited;
end;

procedure TFhirTerminologyCapabilitiesTranslation.Assign(oSource : TFslObject);
begin
  inherited;
  needsMapElement := TFhirTerminologyCapabilitiesTranslation(oSource).needsMapElement.Clone;
end;

procedure TFhirTerminologyCapabilitiesTranslation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'needsMap') Then
     list.add(self.link, 'needsMap', FNeedsMap.Link);
end;

procedure TFhirTerminologyCapabilitiesTranslation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'needsMap', 'boolean', false, TFhirBoolean, FNeedsMap.Link));
end;

function TFhirTerminologyCapabilitiesTranslation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'needsMap') then
  begin
    NeedsMapElement := asBoolean(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTerminologyCapabilitiesTranslation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirTerminologyCapabilitiesTranslation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'needsMap') then result := TFhirBoolean.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirTerminologyCapabilitiesTranslation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'needsMap') then result := 'boolean'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTerminologyCapabilitiesTranslation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'needsMap') then NeedsMapElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTerminologyCapabilitiesTranslation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'needsMap') then NeedsMapElement := asBoolean(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTerminologyCapabilitiesTranslation.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirTerminologyCapabilitiesTranslation.fhirType : string;
begin
  result := 'TerminologyCapabilities.translation';
end;

function TFhirTerminologyCapabilitiesTranslation.Link : TFhirTerminologyCapabilitiesTranslation;
begin
  result := TFhirTerminologyCapabilitiesTranslation(inherited Link);
end;

function TFhirTerminologyCapabilitiesTranslation.Clone : TFhirTerminologyCapabilitiesTranslation;
begin
  result := TFhirTerminologyCapabilitiesTranslation(inherited Clone);
end;

function TFhirTerminologyCapabilitiesTranslation.equals(other : TObject) : boolean; 
var
  o : TFhirTerminologyCapabilitiesTranslation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTerminologyCapabilitiesTranslation)) then
    result := false
  else
  begin
    o := TFhirTerminologyCapabilitiesTranslation(other);
    result := compareDeep(needsMapElement, o.needsMapElement, true);
  end;
end;

function TFhirTerminologyCapabilitiesTranslation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FNeedsMap);
end;

procedure TFhirTerminologyCapabilitiesTranslation.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('needsMap');
end;

function TFhirTerminologyCapabilitiesTranslation.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirTerminologyCapabilitiesTranslation.SetNeedsMap(value : TFhirBoolean);
begin
  FNeedsMap.free;
  FNeedsMap := value;
end;

function TFhirTerminologyCapabilitiesTranslation.GetNeedsMapST : Boolean;
begin
  if FNeedsMap = nil then
    result := false
  else
    result := FNeedsMap.value;
end;

procedure TFhirTerminologyCapabilitiesTranslation.SetNeedsMapST(value : Boolean);
begin
  if FNeedsMap = nil then
    FNeedsMap := TFhirBoolean.create;
  FNeedsMap.value := value
end;

{ TFhirTerminologyCapabilitiesTranslationListEnumerator }

constructor TFhirTerminologyCapabilitiesTranslationListEnumerator.Create(list : TFhirTerminologyCapabilitiesTranslationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTerminologyCapabilitiesTranslationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTerminologyCapabilitiesTranslationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTerminologyCapabilitiesTranslationListEnumerator.GetCurrent : TFhirTerminologyCapabilitiesTranslation;
begin
  Result := FList[FIndex];
end;

function TFhirTerminologyCapabilitiesTranslationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirTerminologyCapabilitiesTranslationList }

function TFhirTerminologyCapabilitiesTranslationList.AddItem(value: TFhirTerminologyCapabilitiesTranslation): TFhirTerminologyCapabilitiesTranslation;
begin
  assert(value.ClassName = 'TFhirTerminologyCapabilitiesTranslation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTerminologyCapabilitiesTranslation');
  add(value);
  result := value;
end;

function TFhirTerminologyCapabilitiesTranslationList.Append: TFhirTerminologyCapabilitiesTranslation;
begin
  result := TFhirTerminologyCapabilitiesTranslation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTerminologyCapabilitiesTranslationList.ClearItems;
begin
  Clear;
end;

function TFhirTerminologyCapabilitiesTranslationList.GetEnumerator : TFhirTerminologyCapabilitiesTranslationListEnumerator;
begin
  result := TFhirTerminologyCapabilitiesTranslationListEnumerator.Create(self.link);
end;

function TFhirTerminologyCapabilitiesTranslationList.Clone: TFhirTerminologyCapabilitiesTranslationList;
begin
  result := TFhirTerminologyCapabilitiesTranslationList(inherited Clone);
end;

function TFhirTerminologyCapabilitiesTranslationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTerminologyCapabilitiesTranslationList.GetItemN(index: Integer): TFhirTerminologyCapabilitiesTranslation;
begin
  result := TFhirTerminologyCapabilitiesTranslation(ObjectByIndex[index]);
end;

function TFhirTerminologyCapabilitiesTranslationList.ItemClass: TFslObjectClass;
begin
  result := TFhirTerminologyCapabilitiesTranslation;
end;
function TFhirTerminologyCapabilitiesTranslationList.IndexOf(value: TFhirTerminologyCapabilitiesTranslation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTerminologyCapabilitiesTranslationList.Insert(index: Integer): TFhirTerminologyCapabilitiesTranslation;
begin
  result := TFhirTerminologyCapabilitiesTranslation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTerminologyCapabilitiesTranslationList.InsertItem(index: Integer; value: TFhirTerminologyCapabilitiesTranslation);
begin
  assert(value is TFhirTerminologyCapabilitiesTranslation);
  Inherited Insert(index, value);
end;

function TFhirTerminologyCapabilitiesTranslationList.Item(index: Integer): TFhirTerminologyCapabilitiesTranslation;
begin
  result := TFhirTerminologyCapabilitiesTranslation(ObjectByIndex[index]);
end;

function TFhirTerminologyCapabilitiesTranslationList.Link: TFhirTerminologyCapabilitiesTranslationList;
begin
  result := TFhirTerminologyCapabilitiesTranslationList(inherited Link);
end;

procedure TFhirTerminologyCapabilitiesTranslationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTerminologyCapabilitiesTranslationList.SetItemByIndex(index: Integer; value: TFhirTerminologyCapabilitiesTranslation);
begin
  assert(value is TFhirTerminologyCapabilitiesTranslation);
  FhirTerminologyCapabilitiesTranslations[index] := value;
end;

procedure TFhirTerminologyCapabilitiesTranslationList.SetItemN(index: Integer; value: TFhirTerminologyCapabilitiesTranslation);
begin
  assert(value is TFhirTerminologyCapabilitiesTranslation);
  ObjectByIndex[index] := value;
end;

{ TFhirTerminologyCapabilitiesClosure }

constructor TFhirTerminologyCapabilitiesClosure.Create;
begin
  inherited;
end;

destructor TFhirTerminologyCapabilitiesClosure.Destroy;
begin
  FTranslation.free;
  inherited;
end;

procedure TFhirTerminologyCapabilitiesClosure.Assign(oSource : TFslObject);
begin
  inherited;
  translationElement := TFhirTerminologyCapabilitiesClosure(oSource).translationElement.Clone;
end;

procedure TFhirTerminologyCapabilitiesClosure.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'translation') Then
     list.add(self.link, 'translation', FTranslation.Link);
end;

procedure TFhirTerminologyCapabilitiesClosure.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'translation', 'boolean', false, TFhirBoolean, FTranslation.Link));
end;

function TFhirTerminologyCapabilitiesClosure.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'translation') then
  begin
    TranslationElement := asBoolean(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTerminologyCapabilitiesClosure.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirTerminologyCapabilitiesClosure.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'translation') then result := TFhirBoolean.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirTerminologyCapabilitiesClosure.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'translation') then result := 'boolean'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTerminologyCapabilitiesClosure.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'translation') then TranslationElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTerminologyCapabilitiesClosure.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'translation') then TranslationElement := asBoolean(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTerminologyCapabilitiesClosure.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirTerminologyCapabilitiesClosure.fhirType : string;
begin
  result := 'TerminologyCapabilities.closure';
end;

function TFhirTerminologyCapabilitiesClosure.Link : TFhirTerminologyCapabilitiesClosure;
begin
  result := TFhirTerminologyCapabilitiesClosure(inherited Link);
end;

function TFhirTerminologyCapabilitiesClosure.Clone : TFhirTerminologyCapabilitiesClosure;
begin
  result := TFhirTerminologyCapabilitiesClosure(inherited Clone);
end;

function TFhirTerminologyCapabilitiesClosure.equals(other : TObject) : boolean; 
var
  o : TFhirTerminologyCapabilitiesClosure;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTerminologyCapabilitiesClosure)) then
    result := false
  else
  begin
    o := TFhirTerminologyCapabilitiesClosure(other);
    result := compareDeep(translationElement, o.translationElement, true);
  end;
end;

function TFhirTerminologyCapabilitiesClosure.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FTranslation);
end;

procedure TFhirTerminologyCapabilitiesClosure.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('translation');
end;

function TFhirTerminologyCapabilitiesClosure.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirTerminologyCapabilitiesClosure.SetTranslation(value : TFhirBoolean);
begin
  FTranslation.free;
  FTranslation := value;
end;

function TFhirTerminologyCapabilitiesClosure.GetTranslationST : Boolean;
begin
  if FTranslation = nil then
    result := false
  else
    result := FTranslation.value;
end;

procedure TFhirTerminologyCapabilitiesClosure.SetTranslationST(value : Boolean);
begin
  if FTranslation = nil then
    FTranslation := TFhirBoolean.create;
  FTranslation.value := value
end;

{ TFhirTerminologyCapabilitiesClosureListEnumerator }

constructor TFhirTerminologyCapabilitiesClosureListEnumerator.Create(list : TFhirTerminologyCapabilitiesClosureList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTerminologyCapabilitiesClosureListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTerminologyCapabilitiesClosureListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTerminologyCapabilitiesClosureListEnumerator.GetCurrent : TFhirTerminologyCapabilitiesClosure;
begin
  Result := FList[FIndex];
end;

function TFhirTerminologyCapabilitiesClosureListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirTerminologyCapabilitiesClosureList }

function TFhirTerminologyCapabilitiesClosureList.AddItem(value: TFhirTerminologyCapabilitiesClosure): TFhirTerminologyCapabilitiesClosure;
begin
  assert(value.ClassName = 'TFhirTerminologyCapabilitiesClosure', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTerminologyCapabilitiesClosure');
  add(value);
  result := value;
end;

function TFhirTerminologyCapabilitiesClosureList.Append: TFhirTerminologyCapabilitiesClosure;
begin
  result := TFhirTerminologyCapabilitiesClosure.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTerminologyCapabilitiesClosureList.ClearItems;
begin
  Clear;
end;

function TFhirTerminologyCapabilitiesClosureList.GetEnumerator : TFhirTerminologyCapabilitiesClosureListEnumerator;
begin
  result := TFhirTerminologyCapabilitiesClosureListEnumerator.Create(self.link);
end;

function TFhirTerminologyCapabilitiesClosureList.Clone: TFhirTerminologyCapabilitiesClosureList;
begin
  result := TFhirTerminologyCapabilitiesClosureList(inherited Clone);
end;

function TFhirTerminologyCapabilitiesClosureList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTerminologyCapabilitiesClosureList.GetItemN(index: Integer): TFhirTerminologyCapabilitiesClosure;
begin
  result := TFhirTerminologyCapabilitiesClosure(ObjectByIndex[index]);
end;

function TFhirTerminologyCapabilitiesClosureList.ItemClass: TFslObjectClass;
begin
  result := TFhirTerminologyCapabilitiesClosure;
end;
function TFhirTerminologyCapabilitiesClosureList.IndexOf(value: TFhirTerminologyCapabilitiesClosure): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTerminologyCapabilitiesClosureList.Insert(index: Integer): TFhirTerminologyCapabilitiesClosure;
begin
  result := TFhirTerminologyCapabilitiesClosure.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTerminologyCapabilitiesClosureList.InsertItem(index: Integer; value: TFhirTerminologyCapabilitiesClosure);
begin
  assert(value is TFhirTerminologyCapabilitiesClosure);
  Inherited Insert(index, value);
end;

function TFhirTerminologyCapabilitiesClosureList.Item(index: Integer): TFhirTerminologyCapabilitiesClosure;
begin
  result := TFhirTerminologyCapabilitiesClosure(ObjectByIndex[index]);
end;

function TFhirTerminologyCapabilitiesClosureList.Link: TFhirTerminologyCapabilitiesClosureList;
begin
  result := TFhirTerminologyCapabilitiesClosureList(inherited Link);
end;

procedure TFhirTerminologyCapabilitiesClosureList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTerminologyCapabilitiesClosureList.SetItemByIndex(index: Integer; value: TFhirTerminologyCapabilitiesClosure);
begin
  assert(value is TFhirTerminologyCapabilitiesClosure);
  FhirTerminologyCapabilitiesClosures[index] := value;
end;

procedure TFhirTerminologyCapabilitiesClosureList.SetItemN(index: Integer; value: TFhirTerminologyCapabilitiesClosure);
begin
  assert(value is TFhirTerminologyCapabilitiesClosure);
  ObjectByIndex[index] := value;
end;

{ TFhirTerminologyCapabilities }

constructor TFhirTerminologyCapabilities.Create;
begin
  inherited;
end;

destructor TFhirTerminologyCapabilities.Destroy;
begin
  FUrl.free;
  FVersion.free;
  FName.free;
  FTitle.free;
  FStatus.free;
  FExperimental.free;
  FDate.free;
  FPublisher.free;
  FContactList.Free;
  FDescription.free;
  FUseContextList.Free;
  FJurisdictionList.Free;
  FPurpose.free;
  FCopyright.free;
  FKind.free;
  FSoftware.free;
  FImplementation_.free;
  FLockedDate.free;
  FCodeSystemList.Free;
  FExpansion.free;
  FCodeSearch.free;
  FValidateCode.free;
  FTranslation.free;
  FClosure.free;
  inherited;
end;

procedure TFhirTerminologyCapabilities.Assign(oSource : TFslObject);
begin
  inherited;
  urlElement := TFhirTerminologyCapabilities(oSource).urlElement.Clone;
  versionElement := TFhirTerminologyCapabilities(oSource).versionElement.Clone;
  nameElement := TFhirTerminologyCapabilities(oSource).nameElement.Clone;
  titleElement := TFhirTerminologyCapabilities(oSource).titleElement.Clone;
  statusElement := TFhirTerminologyCapabilities(oSource).statusElement.Clone;
  experimentalElement := TFhirTerminologyCapabilities(oSource).experimentalElement.Clone;
  dateElement := TFhirTerminologyCapabilities(oSource).dateElement.Clone;
  publisherElement := TFhirTerminologyCapabilities(oSource).publisherElement.Clone;
  if (TFhirTerminologyCapabilities(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirContactDetailList.Create;
    FContactList.Assign(TFhirTerminologyCapabilities(oSource).FContactList);
  end;
  descriptionElement := TFhirTerminologyCapabilities(oSource).descriptionElement.Clone;
  if (TFhirTerminologyCapabilities(oSource).FUseContextList = nil) then
  begin
    FUseContextList.free;
    FUseContextList := nil;
  end
  else
  begin
    if FUseContextList = nil then
      FUseContextList := TFhirUsageContextList.Create;
    FUseContextList.Assign(TFhirTerminologyCapabilities(oSource).FUseContextList);
  end;
  if (TFhirTerminologyCapabilities(oSource).FJurisdictionList = nil) then
  begin
    FJurisdictionList.free;
    FJurisdictionList := nil;
  end
  else
  begin
    if FJurisdictionList = nil then
      FJurisdictionList := TFhirCodeableConceptList.Create;
    FJurisdictionList.Assign(TFhirTerminologyCapabilities(oSource).FJurisdictionList);
  end;
  purposeElement := TFhirTerminologyCapabilities(oSource).purposeElement.Clone;
  copyrightElement := TFhirTerminologyCapabilities(oSource).copyrightElement.Clone;
  kindElement := TFhirTerminologyCapabilities(oSource).kindElement.Clone;
  software := TFhirTerminologyCapabilities(oSource).software.Clone;
  implementation_ := TFhirTerminologyCapabilities(oSource).implementation_.Clone;
  lockedDateElement := TFhirTerminologyCapabilities(oSource).lockedDateElement.Clone;
  if (TFhirTerminologyCapabilities(oSource).FCodeSystemList = nil) then
  begin
    FCodeSystemList.free;
    FCodeSystemList := nil;
  end
  else
  begin
    if FCodeSystemList = nil then
      FCodeSystemList := TFhirTerminologyCapabilitiesCodeSystemList.Create;
    FCodeSystemList.Assign(TFhirTerminologyCapabilities(oSource).FCodeSystemList);
  end;
  expansion := TFhirTerminologyCapabilities(oSource).expansion.Clone;
  codeSearchElement := TFhirTerminologyCapabilities(oSource).codeSearchElement.Clone;
  validateCode := TFhirTerminologyCapabilities(oSource).validateCode.Clone;
  translation := TFhirTerminologyCapabilities(oSource).translation.Clone;
  closure := TFhirTerminologyCapabilities(oSource).closure.Clone;
end;

function TFhirTerminologyCapabilities.GetResourceType : TFhirResourceType;
begin
  result := frtTerminologyCapabilities;
end;

procedure TFhirTerminologyCapabilities.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
  if (child_name = 'version') Then
     list.add(self.link, 'version', FVersion.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'experimental') Then
     list.add(self.link, 'experimental', FExperimental.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'publisher') Then
     list.add(self.link, 'publisher', FPublisher.Link);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'useContext') Then
    list.addAll(self, 'useContext', FUseContextList);
  if (child_name = 'jurisdiction') Then
    list.addAll(self, 'jurisdiction', FJurisdictionList);
  if (child_name = 'purpose') Then
     list.add(self.link, 'purpose', FPurpose.Link);
  if (child_name = 'copyright') Then
     list.add(self.link, 'copyright', FCopyright.Link);
  if (child_name = 'kind') Then
     list.add(self.link, 'kind', FKind.Link);
  if (child_name = 'software') Then
     list.add(self.link, 'software', FSoftware.Link);
  if (child_name = 'implementation') Then
     list.add(self.link, 'implementation', FImplementation_.Link);
  if (child_name = 'lockedDate') Then
     list.add(self.link, 'lockedDate', FLockedDate.Link);
  if (child_name = 'codeSystem') Then
    list.addAll(self, 'codeSystem', FCodeSystemList);
  if (child_name = 'expansion') Then
     list.add(self.link, 'expansion', FExpansion.Link);
  if (child_name = 'codeSearch') Then
     list.add(self.link, 'codeSearch', FCodeSearch.Link);
  if (child_name = 'validateCode') Then
     list.add(self.link, 'validateCode', FValidateCode.Link);
  if (child_name = 'translation') Then
     list.add(self.link, 'translation', FTranslation.Link);
  if (child_name = 'closure') Then
     list.add(self.link, 'closure', FClosure.Link);
end;

procedure TFhirTerminologyCapabilities.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'url', 'uri', false, TFhirUri, FUrl.Link));
  oList.add(TFHIRProperty.create(self, 'version', 'string', false, TFhirString, FVersion.Link));
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'experimental', 'boolean', false, TFhirBoolean, FExperimental.Link));
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));
  oList.add(TFHIRProperty.create(self, 'publisher', 'string', false, TFhirString, FPublisher.Link));
  oList.add(TFHIRProperty.create(self, 'contact', 'ContactDetail', true, TFhirContactDetail, FContactList.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'markdown', false, TFhirMarkdown, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'useContext', 'UsageContext', true, TFhirUsageContext, FUseContextList.Link));
  oList.add(TFHIRProperty.create(self, 'jurisdiction', 'CodeableConcept', true, TFhirCodeableConcept, FJurisdictionList.Link));
  oList.add(TFHIRProperty.create(self, 'purpose', 'markdown', false, TFhirMarkdown, FPurpose.Link));
  oList.add(TFHIRProperty.create(self, 'copyright', 'markdown', false, TFhirMarkdown, FCopyright.Link));
  oList.add(TFHIRProperty.create(self, 'kind', 'code', false, TFhirEnum, FKind.Link));
  oList.add(TFHIRProperty.create(self, 'software', 'BackboneElement', false, TFhirTerminologyCapabilitiesSoftware, FSoftware.Link));
  oList.add(TFHIRProperty.create(self, 'implementation', 'BackboneElement', false, TFhirTerminologyCapabilitiesImplementation, FImplementation_.Link));
  oList.add(TFHIRProperty.create(self, 'lockedDate', 'boolean', false, TFhirBoolean, FLockedDate.Link));
  oList.add(TFHIRProperty.create(self, 'codeSystem', 'BackboneElement', true, TFhirTerminologyCapabilitiesCodeSystem, FCodeSystemList.Link));
  oList.add(TFHIRProperty.create(self, 'expansion', 'BackboneElement', false, TFhirTerminologyCapabilitiesExpansion, FExpansion.Link));
  oList.add(TFHIRProperty.create(self, 'codeSearch', 'code', false, TFhirEnum, FCodeSearch.Link));
  oList.add(TFHIRProperty.create(self, 'validateCode', 'BackboneElement', false, TFhirTerminologyCapabilitiesValidateCode, FValidateCode.Link));
  oList.add(TFHIRProperty.create(self, 'translation', 'BackboneElement', false, TFhirTerminologyCapabilitiesTranslation, FTranslation.Link));
  oList.add(TFHIRProperty.create(self, 'closure', 'BackboneElement', false, TFhirTerminologyCapabilitiesClosure, FClosure.Link));
end;

function TFhirTerminologyCapabilities.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'url') then
  begin
    UrlElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'title') then
  begin
    TitleElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'experimental') then
  begin
    ExperimentalElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'publisher') then
  begin
    PublisherElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirContactDetail);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'useContext') then
  begin
    UseContextList.add(propValue as TFhirUsageContext);
    result := propValue;
  end
  else if (propName = 'jurisdiction') then
  begin
    JurisdictionList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'purpose') then
  begin
    PurposeElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'copyright') then
  begin
    CopyrightElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'kind') then
  begin
    KindElement := asEnum(SYSTEMS_TFhirCapabilityStatementKindEnum, CODES_TFhirCapabilityStatementKindEnum, propValue);
    result := propValue;
  end
  else if (propName = 'software') then
  begin
    Software := propValue as TFhirTerminologyCapabilitiesSoftware;
    result := propValue;
  end
  else if (propName = 'implementation') then
  begin
    Implementation_ := propValue as TFhirTerminologyCapabilitiesImplementation;
    result := propValue;
  end
  else if (propName = 'lockedDate') then
  begin
    LockedDateElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'codeSystem') then
  begin
    CodeSystemList.add(propValue as TFhirTerminologyCapabilitiesCodeSystem);
    result := propValue;
  end
  else if (propName = 'expansion') then
  begin
    Expansion := propValue as TFhirTerminologyCapabilitiesExpansion;
    result := propValue;
  end
  else if (propName = 'codeSearch') then
  begin
    CodeSearchElement := asEnum(SYSTEMS_TFhirCodeSearchSupportEnum, CODES_TFhirCodeSearchSupportEnum, propValue);
    result := propValue;
  end
  else if (propName = 'validateCode') then
  begin
    ValidateCode := propValue as TFhirTerminologyCapabilitiesValidateCode;
    result := propValue;
  end
  else if (propName = 'translation') then
  begin
    Translation := propValue as TFhirTerminologyCapabilitiesTranslation;
    result := propValue;
  end
  else if (propName = 'closure') then
  begin
    Closure := propValue as TFhirTerminologyCapabilitiesClosure;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTerminologyCapabilities.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirContactDetail)
  else if (propName = 'useContext') then UseContextList.insertItem(index, propValue as TFhirUsageContext)
  else if (propName = 'jurisdiction') then JurisdictionList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'codeSystem') then CodeSystemList.insertItem(index, propValue as TFhirTerminologyCapabilitiesCodeSystem)
  else inherited;
end;

function TFhirTerminologyCapabilities.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'url') then result := TFhirUri.create()
  else if (propName = 'version') then result := TFhirString.create()
  else if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'title') then result := TFhirString.create()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[PublicationStatusNull], CODES_TFhirPublicationStatusEnum[PublicationStatusNull]) 
  else if (propName = 'experimental') then result := TFhirBoolean.create()
  else if (propName = 'date') then result := TFhirDateTime.create()
  else if (propName = 'publisher') then result := TFhirString.create()
  else if (propName = 'contact') then result := ContactList.new()
  else if (propName = 'description') then result := TFhirMarkdown.create()
  else if (propName = 'useContext') then result := UseContextList.new()
  else if (propName = 'jurisdiction') then result := JurisdictionList.new()
  else if (propName = 'purpose') then result := TFhirMarkdown.create()
  else if (propName = 'copyright') then result := TFhirMarkdown.create()
  else if (propName = 'kind') then result := TFhirEnum.create(SYSTEMS_TFhirCapabilityStatementKindEnum[CapabilityStatementKindNull], CODES_TFhirCapabilityStatementKindEnum[CapabilityStatementKindNull]) 
  else if (propName = 'software') then result := TFhirTerminologyCapabilitiesSoftware.create()
  else if (propName = 'implementation') then result := TFhirTerminologyCapabilitiesImplementation.create()
  else if (propName = 'lockedDate') then result := TFhirBoolean.create()
  else if (propName = 'codeSystem') then result := CodeSystemList.new()
  else if (propName = 'expansion') then result := TFhirTerminologyCapabilitiesExpansion.create()
  else if (propName = 'codeSearch') then result := TFhirEnum.create(SYSTEMS_TFhirCodeSearchSupportEnum[CodeSearchSupportNull], CODES_TFhirCodeSearchSupportEnum[CodeSearchSupportNull]) 
  else if (propName = 'validateCode') then result := TFhirTerminologyCapabilitiesValidateCode.create()
  else if (propName = 'translation') then result := TFhirTerminologyCapabilitiesTranslation.create()
  else if (propName = 'closure') then result := TFhirTerminologyCapabilitiesClosure.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirTerminologyCapabilities.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'url') then result := 'uri'
  else if (propName = 'version') then result := 'string'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'title') then result := 'string'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'experimental') then result := 'boolean'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'publisher') then result := 'string'
  else if (propName = 'contact') then result := 'ContactDetail'
  else if (propName = 'description') then result := 'markdown'
  else if (propName = 'useContext') then result := 'UsageContext'
  else if (propName = 'jurisdiction') then result := 'CodeableConcept'
  else if (propName = 'purpose') then result := 'markdown'
  else if (propName = 'copyright') then result := 'markdown'
  else if (propName = 'kind') then result := 'code'
  else if (propName = 'software') then result := 'BackboneElement'
  else if (propName = 'implementation') then result := 'BackboneElement'
  else if (propName = 'lockedDate') then result := 'boolean'
  else if (propName = 'codeSystem') then result := 'BackboneElement'
  else if (propName = 'expansion') then result := 'BackboneElement'
  else if (propName = 'codeSearch') then result := 'code'
  else if (propName = 'validateCode') then result := 'BackboneElement'
  else if (propName = 'translation') then result := 'BackboneElement'
  else if (propName = 'closure') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTerminologyCapabilities.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := nil
  else if (propName = 'version') then VersionElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'title') then TitleElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'experimental') then ExperimentalElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'publisher') then PublisherElement := nil
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value)
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'useContext') then deletePropertyValue('useContext', UseContextList, value)
  else if (propName = 'jurisdiction') then deletePropertyValue('jurisdiction', JurisdictionList, value)
  else if (propName = 'purpose') then PurposeElement := nil
  else if (propName = 'copyright') then CopyrightElement := nil
  else if (propName = 'kind') then KindElement := nil
  else if (propName = 'software') then SoftwareElement := nil
  else if (propName = 'implementation') then Implementation_Element := nil
  else if (propName = 'lockedDate') then LockedDateElement := nil
  else if (propName = 'codeSystem') then deletePropertyValue('codeSystem', CodeSystemList, value)
  else if (propName = 'expansion') then ExpansionElement := nil
  else if (propName = 'codeSearch') then CodeSearchElement := nil
  else if (propName = 'validateCode') then ValidateCodeElement := nil
  else if (propName = 'translation') then TranslationElement := nil
  else if (propName = 'closure') then ClosureElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTerminologyCapabilities.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := asUri(new)
  else if (propName = 'version') then VersionElement := asString(new)
  else if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'title') then TitleElement := asString(new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, new)
  else if (propName = 'experimental') then ExperimentalElement := asBoolean(new)
  else if (propName = 'date') then DateElement := asDateTime(new)
  else if (propName = 'publisher') then PublisherElement := asString(new)
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new)
  else if (propName = 'description') then DescriptionElement := asMarkdown(new)
  else if (propName = 'useContext') then replacePropertyValue('useContext', UseContextList, existing, new)
  else if (propName = 'jurisdiction') then replacePropertyValue('jurisdiction', JurisdictionList, existing, new)
  else if (propName = 'purpose') then PurposeElement := asMarkdown(new)
  else if (propName = 'copyright') then CopyrightElement := asMarkdown(new)
  else if (propName = 'kind') then KindElement := asEnum(SYSTEMS_TFhirCapabilityStatementKindEnum, CODES_TFhirCapabilityStatementKindEnum, new)
  else if (propName = 'software') then SoftwareElement := new as TFhirTerminologyCapabilitiesSoftware
  else if (propName = 'implementation') then Implementation_Element := new as TFhirTerminologyCapabilitiesImplementation
  else if (propName = 'lockedDate') then LockedDateElement := asBoolean(new)
  else if (propName = 'codeSystem') then replacePropertyValue('codeSystem', CodeSystemList, existing, new)
  else if (propName = 'expansion') then ExpansionElement := new as TFhirTerminologyCapabilitiesExpansion
  else if (propName = 'codeSearch') then CodeSearchElement := asEnum(SYSTEMS_TFhirCodeSearchSupportEnum, CODES_TFhirCodeSearchSupportEnum, new)
  else if (propName = 'validateCode') then ValidateCodeElement := new as TFhirTerminologyCapabilitiesValidateCode
  else if (propName = 'translation') then TranslationElement := new as TFhirTerminologyCapabilitiesTranslation
  else if (propName = 'closure') then ClosureElement := new as TFhirTerminologyCapabilitiesClosure
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTerminologyCapabilities.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'contact') then ContactList.move(source, destination)
  else if (propName = 'useContext') then UseContextList.move(source, destination)
  else if (propName = 'jurisdiction') then JurisdictionList.move(source, destination)
  else if (propName = 'codeSystem') then CodeSystemList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirTerminologyCapabilities.fhirType : string;
begin
  result := 'TerminologyCapabilities';
end;

function TFhirTerminologyCapabilities.Link : TFhirTerminologyCapabilities;
begin
  result := TFhirTerminologyCapabilities(inherited Link);
end;

function TFhirTerminologyCapabilities.Clone : TFhirTerminologyCapabilities;
begin
  result := TFhirTerminologyCapabilities(inherited Clone);
end;

function TFhirTerminologyCapabilities.equals(other : TObject) : boolean; 
var
  o : TFhirTerminologyCapabilities;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTerminologyCapabilities)) then
    result := false
  else
  begin
    o := TFhirTerminologyCapabilities(other);
    result := compareDeep(urlElement, o.urlElement, true) and compareDeep(versionElement, o.versionElement, true) and 
      compareDeep(nameElement, o.nameElement, true) and compareDeep(titleElement, o.titleElement, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(experimentalElement, o.experimentalElement, true) and 
      compareDeep(dateElement, o.dateElement, true) and compareDeep(publisherElement, o.publisherElement, true) and 
      compareDeep(contactList, o.contactList, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(useContextList, o.useContextList, true) and compareDeep(jurisdictionList, o.jurisdictionList, true) and 
      compareDeep(purposeElement, o.purposeElement, true) and compareDeep(copyrightElement, o.copyrightElement, true) and 
      compareDeep(kindElement, o.kindElement, true) and compareDeep(softwareElement, o.softwareElement, true) and 
      compareDeep(implementation_Element, o.implementation_Element, true) and compareDeep(lockedDateElement, o.lockedDateElement, true) and 
      compareDeep(codeSystemList, o.codeSystemList, true) and compareDeep(expansionElement, o.expansionElement, true) and 
      compareDeep(codeSearchElement, o.codeSearchElement, true) and compareDeep(validateCodeElement, o.validateCodeElement, true) and 
      compareDeep(translationElement, o.translationElement, true) and compareDeep(closureElement, o.closureElement, true);
  end;
end;

function TFhirTerminologyCapabilities.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FUrl) and isEmptyProp(FVersion) and isEmptyProp(FName) and isEmptyProp(FTitle) and isEmptyProp(FStatus) and isEmptyProp(FExperimental) and isEmptyProp(FDate) and isEmptyProp(FPublisher) and isEmptyProp(FcontactList) and isEmptyProp(FDescription) and isEmptyProp(FuseContextList) and isEmptyProp(FjurisdictionList) and isEmptyProp(FPurpose) and isEmptyProp(FCopyright) and isEmptyProp(FKind) and isEmptyProp(FSoftware) and isEmptyProp(FImplementation_) and isEmptyProp(FLockedDate) and isEmptyProp(FcodeSystemList) and isEmptyProp(FExpansion) and isEmptyProp(FCodeSearch) and isEmptyProp(FValidateCode) and isEmptyProp(FTranslation) and isEmptyProp(FClosure);
end;

procedure TFhirTerminologyCapabilities.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('url');
  fields.add('version');
  fields.add('name');
  fields.add('title');
  fields.add('status');
  fields.add('experimental');
  fields.add('date');
  fields.add('publisher');
  fields.add('contact');
  fields.add('description');
  fields.add('useContext');
  fields.add('jurisdiction');
  fields.add('purpose');
  fields.add('copyright');
  fields.add('kind');
  fields.add('software');
  fields.add('implementation');
  fields.add('lockedDate');
  fields.add('codeSystem');
  fields.add('expansion');
  fields.add('codeSearch');
  fields.add('validateCode');
  fields.add('translation');
  fields.add('closure');
end;

function TFhirTerminologyCapabilities.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FContactList.sizeInBytes(magic));
  inc(result, FUseContextList.sizeInBytes(magic));
  inc(result, FJurisdictionList.sizeInBytes(magic));
  inc(result, FCodeSystemList.sizeInBytes(magic));
end;

procedure TFhirTerminologyCapabilities.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

function TFhirTerminologyCapabilities.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

procedure TFhirTerminologyCapabilities.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

procedure TFhirTerminologyCapabilities.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

function TFhirTerminologyCapabilities.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

procedure TFhirTerminologyCapabilities.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

procedure TFhirTerminologyCapabilities.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirTerminologyCapabilities.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirTerminologyCapabilities.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirTerminologyCapabilities.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

function TFhirTerminologyCapabilities.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

procedure TFhirTerminologyCapabilities.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

procedure TFhirTerminologyCapabilities.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirTerminologyCapabilities.GetStatusST : TFhirPublicationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirPublicationStatusEnum(0)
  else
    result := TFhirPublicationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirPublicationStatusEnum, FStatus.value));
end;

procedure TFhirTerminologyCapabilities.SetStatusST(value : TFhirPublicationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[value], CODES_TFhirPublicationStatusEnum[value]);
end;

procedure TFhirTerminologyCapabilities.SetExperimental(value : TFhirBoolean);
begin
  FExperimental.free;
  FExperimental := value;
end;

function TFhirTerminologyCapabilities.GetExperimentalST : Boolean;
begin
  if FExperimental = nil then
    result := false
  else
    result := FExperimental.value;
end;

procedure TFhirTerminologyCapabilities.SetExperimentalST(value : Boolean);
begin
  if FExperimental = nil then
    FExperimental := TFhirBoolean.create;
  FExperimental.value := value
end;

procedure TFhirTerminologyCapabilities.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

function TFhirTerminologyCapabilities.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirTerminologyCapabilities.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

procedure TFhirTerminologyCapabilities.SetPublisher(value : TFhirString);
begin
  FPublisher.free;
  FPublisher := value;
end;

function TFhirTerminologyCapabilities.GetPublisherST : String;
begin
  if FPublisher = nil then
    result := ''
  else
    result := FPublisher.value;
end;

procedure TFhirTerminologyCapabilities.SetPublisherST(value : String);
begin
  if value <> '' then
  begin
    if FPublisher = nil then
      FPublisher := TFhirString.create;
    FPublisher.value := value
  end
  else if FPublisher <> nil then
    FPublisher.value := '';
end;

function TFhirTerminologyCapabilities.GetContactList : TFhirContactDetailList;
begin
  if FContactList = nil then
    FContactList := TFhirContactDetailList.Create;
  result := FContactList;
end;

function TFhirTerminologyCapabilities.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

procedure TFhirTerminologyCapabilities.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirTerminologyCapabilities.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirTerminologyCapabilities.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirTerminologyCapabilities.GetUseContextList : TFhirUsageContextList;
begin
  if FUseContextList = nil then
    FUseContextList := TFhirUsageContextList.Create;
  result := FUseContextList;
end;

function TFhirTerminologyCapabilities.GetHasUseContextList : boolean;
begin
  result := (FUseContextList <> nil) and (FUseContextList.count > 0);
end;

function TFhirTerminologyCapabilities.GetJurisdictionList : TFhirCodeableConceptList;
begin
  if FJurisdictionList = nil then
    FJurisdictionList := TFhirCodeableConceptList.Create;
  result := FJurisdictionList;
end;

function TFhirTerminologyCapabilities.GetHasJurisdictionList : boolean;
begin
  result := (FJurisdictionList <> nil) and (FJurisdictionList.count > 0);
end;

procedure TFhirTerminologyCapabilities.SetPurpose(value : TFhirMarkdown);
begin
  FPurpose.free;
  FPurpose := value;
end;

function TFhirTerminologyCapabilities.GetPurposeST : String;
begin
  if FPurpose = nil then
    result := ''
  else
    result := FPurpose.value;
end;

procedure TFhirTerminologyCapabilities.SetPurposeST(value : String);
begin
  if value <> '' then
  begin
    if FPurpose = nil then
      FPurpose := TFhirMarkdown.create;
    FPurpose.value := value
  end
  else if FPurpose <> nil then
    FPurpose.value := '';
end;

procedure TFhirTerminologyCapabilities.SetCopyright(value : TFhirMarkdown);
begin
  FCopyright.free;
  FCopyright := value;
end;

function TFhirTerminologyCapabilities.GetCopyrightST : String;
begin
  if FCopyright = nil then
    result := ''
  else
    result := FCopyright.value;
end;

procedure TFhirTerminologyCapabilities.SetCopyrightST(value : String);
begin
  if value <> '' then
  begin
    if FCopyright = nil then
      FCopyright := TFhirMarkdown.create;
    FCopyright.value := value
  end
  else if FCopyright <> nil then
    FCopyright.value := '';
end;

procedure TFhirTerminologyCapabilities.SetKind(value : TFhirEnum);
begin
  FKind.free;
  FKind := value;
end;

function TFhirTerminologyCapabilities.GetKindST : TFhirCapabilityStatementKindEnum;
begin
  if FKind = nil then
    result := TFhirCapabilityStatementKindEnum(0)
  else
    result := TFhirCapabilityStatementKindEnum(StringArrayIndexOfSensitive(CODES_TFhirCapabilityStatementKindEnum, FKind.value));
end;

procedure TFhirTerminologyCapabilities.SetKindST(value : TFhirCapabilityStatementKindEnum);
begin
  if ord(value) = 0 then
    KindElement := nil
  else
    KindElement := TFhirEnum.create(SYSTEMS_TFhirCapabilityStatementKindEnum[value], CODES_TFhirCapabilityStatementKindEnum[value]);
end;

procedure TFhirTerminologyCapabilities.SetSoftware(value : TFhirTerminologyCapabilitiesSoftware);
begin
  FSoftware.free;
  FSoftware := value;
end;

procedure TFhirTerminologyCapabilities.SetImplementation_(value : TFhirTerminologyCapabilitiesImplementation);
begin
  FImplementation_.free;
  FImplementation_ := value;
end;

procedure TFhirTerminologyCapabilities.SetLockedDate(value : TFhirBoolean);
begin
  FLockedDate.free;
  FLockedDate := value;
end;

function TFhirTerminologyCapabilities.GetLockedDateST : Boolean;
begin
  if FLockedDate = nil then
    result := false
  else
    result := FLockedDate.value;
end;

procedure TFhirTerminologyCapabilities.SetLockedDateST(value : Boolean);
begin
  if FLockedDate = nil then
    FLockedDate := TFhirBoolean.create;
  FLockedDate.value := value
end;

function TFhirTerminologyCapabilities.GetCodeSystemList : TFhirTerminologyCapabilitiesCodeSystemList;
begin
  if FCodeSystemList = nil then
    FCodeSystemList := TFhirTerminologyCapabilitiesCodeSystemList.Create;
  result := FCodeSystemList;
end;

function TFhirTerminologyCapabilities.GetHasCodeSystemList : boolean;
begin
  result := (FCodeSystemList <> nil) and (FCodeSystemList.count > 0);
end;

procedure TFhirTerminologyCapabilities.SetExpansion(value : TFhirTerminologyCapabilitiesExpansion);
begin
  FExpansion.free;
  FExpansion := value;
end;

procedure TFhirTerminologyCapabilities.SetCodeSearch(value : TFhirEnum);
begin
  FCodeSearch.free;
  FCodeSearch := value;
end;

function TFhirTerminologyCapabilities.GetCodeSearchST : TFhirCodeSearchSupportEnum;
begin
  if FCodeSearch = nil then
    result := TFhirCodeSearchSupportEnum(0)
  else
    result := TFhirCodeSearchSupportEnum(StringArrayIndexOfSensitive(CODES_TFhirCodeSearchSupportEnum, FCodeSearch.value));
end;

procedure TFhirTerminologyCapabilities.SetCodeSearchST(value : TFhirCodeSearchSupportEnum);
begin
  if ord(value) = 0 then
    CodeSearchElement := nil
  else
    CodeSearchElement := TFhirEnum.create(SYSTEMS_TFhirCodeSearchSupportEnum[value], CODES_TFhirCodeSearchSupportEnum[value]);
end;

procedure TFhirTerminologyCapabilities.SetValidateCode(value : TFhirTerminologyCapabilitiesValidateCode);
begin
  FValidateCode.free;
  FValidateCode := value;
end;

procedure TFhirTerminologyCapabilities.SetTranslation(value : TFhirTerminologyCapabilitiesTranslation);
begin
  FTranslation.free;
  FTranslation := value;
end;

procedure TFhirTerminologyCapabilities.SetClosure(value : TFhirTerminologyCapabilitiesClosure);
begin
  FClosure.free;
  FClosure := value;
end;

{ TFhirTerminologyCapabilitiesListEnumerator }

constructor TFhirTerminologyCapabilitiesListEnumerator.Create(list : TFhirTerminologyCapabilitiesList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTerminologyCapabilitiesListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTerminologyCapabilitiesListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTerminologyCapabilitiesListEnumerator.GetCurrent : TFhirTerminologyCapabilities;
begin
  Result := FList[FIndex];
end;

function TFhirTerminologyCapabilitiesListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirTerminologyCapabilitiesList }

function TFhirTerminologyCapabilitiesList.AddItem(value: TFhirTerminologyCapabilities): TFhirTerminologyCapabilities;
begin
  assert(value.ClassName = 'TFhirTerminologyCapabilities', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTerminologyCapabilities');
  add(value);
  result := value;
end;

function TFhirTerminologyCapabilitiesList.Append: TFhirTerminologyCapabilities;
begin
  result := TFhirTerminologyCapabilities.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTerminologyCapabilitiesList.ClearItems;
begin
  Clear;
end;

function TFhirTerminologyCapabilitiesList.GetEnumerator : TFhirTerminologyCapabilitiesListEnumerator;
begin
  result := TFhirTerminologyCapabilitiesListEnumerator.Create(self.link);
end;

function TFhirTerminologyCapabilitiesList.Clone: TFhirTerminologyCapabilitiesList;
begin
  result := TFhirTerminologyCapabilitiesList(inherited Clone);
end;

function TFhirTerminologyCapabilitiesList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTerminologyCapabilitiesList.GetItemN(index: Integer): TFhirTerminologyCapabilities;
begin
  result := TFhirTerminologyCapabilities(ObjectByIndex[index]);
end;

function TFhirTerminologyCapabilitiesList.ItemClass: TFslObjectClass;
begin
  result := TFhirTerminologyCapabilities;
end;
function TFhirTerminologyCapabilitiesList.IndexOf(value: TFhirTerminologyCapabilities): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTerminologyCapabilitiesList.Insert(index: Integer): TFhirTerminologyCapabilities;
begin
  result := TFhirTerminologyCapabilities.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTerminologyCapabilitiesList.InsertItem(index: Integer; value: TFhirTerminologyCapabilities);
begin
  assert(value is TFhirTerminologyCapabilities);
  Inherited Insert(index, value);
end;

function TFhirTerminologyCapabilitiesList.Item(index: Integer): TFhirTerminologyCapabilities;
begin
  result := TFhirTerminologyCapabilities(ObjectByIndex[index]);
end;

function TFhirTerminologyCapabilitiesList.Link: TFhirTerminologyCapabilitiesList;
begin
  result := TFhirTerminologyCapabilitiesList(inherited Link);
end;

procedure TFhirTerminologyCapabilitiesList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTerminologyCapabilitiesList.SetItemByIndex(index: Integer; value: TFhirTerminologyCapabilities);
begin
  assert(value is TFhirTerminologyCapabilities);
  FhirTerminologyCapabilities[index] := value;
end;

procedure TFhirTerminologyCapabilitiesList.SetItemN(index: Integer; value: TFhirTerminologyCapabilities);
begin
  assert(value is TFhirTerminologyCapabilities);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_TERMINOLOGYCAPABILITIES}
{$IFDEF FHIR_TESTSCRIPT}
{ TFhirTestScriptOrigin }

constructor TFhirTestScriptOrigin.Create;
begin
  inherited;
end;

destructor TFhirTestScriptOrigin.Destroy;
begin
  FIndex.free;
  FProfile.free;
  inherited;
end;

procedure TFhirTestScriptOrigin.Assign(oSource : TFslObject);
begin
  inherited;
  indexElement := TFhirTestScriptOrigin(oSource).indexElement.Clone;
  profile := TFhirTestScriptOrigin(oSource).profile.Clone;
end;

procedure TFhirTestScriptOrigin.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'index') Then
     list.add(self.link, 'index', FIndex.Link);
  if (child_name = 'profile') Then
     list.add(self.link, 'profile', FProfile.Link);
end;

procedure TFhirTestScriptOrigin.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'index', 'integer', false, TFhirInteger, FIndex.Link));
  oList.add(TFHIRProperty.create(self, 'profile', 'Coding', false, TFhirCoding, FProfile.Link));
end;

function TFhirTestScriptOrigin.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'index') then
  begin
    IndexElement := asInteger(propValue);
    result := propValue;
  end
  else if (propName = 'profile') then
  begin
    Profile := propValue as TFhirCoding;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestScriptOrigin.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirTestScriptOrigin.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'index') then result := TFhirInteger.create()
  else if (propName = 'profile') then result := TFhirCoding.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestScriptOrigin.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'index') then result := 'integer'
  else if (propName = 'profile') then result := 'Coding'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestScriptOrigin.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'index') then IndexElement := nil
  else if (propName = 'profile') then ProfileElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestScriptOrigin.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'index') then IndexElement := asInteger(new)
  else if (propName = 'profile') then ProfileElement := new as TFhirCoding
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestScriptOrigin.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirTestScriptOrigin.fhirType : string;
begin
  result := 'TestScript.origin';
end;

function TFhirTestScriptOrigin.Link : TFhirTestScriptOrigin;
begin
  result := TFhirTestScriptOrigin(inherited Link);
end;

function TFhirTestScriptOrigin.Clone : TFhirTestScriptOrigin;
begin
  result := TFhirTestScriptOrigin(inherited Clone);
end;

function TFhirTestScriptOrigin.equals(other : TObject) : boolean; 
var
  o : TFhirTestScriptOrigin;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestScriptOrigin)) then
    result := false
  else
  begin
    o := TFhirTestScriptOrigin(other);
    result := compareDeep(indexElement, o.indexElement, true) and compareDeep(profileElement, o.profileElement, true);
  end;
end;

function TFhirTestScriptOrigin.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIndex) and isEmptyProp(FProfile);
end;

procedure TFhirTestScriptOrigin.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('index');
  fields.add('profile');
end;

function TFhirTestScriptOrigin.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirTestScriptOrigin.SetIndex(value : TFhirInteger);
begin
  FIndex.free;
  FIndex := value;
end;

function TFhirTestScriptOrigin.GetIndexST : String;
begin
  if FIndex = nil then
    result := ''
  else
    result := FIndex.value;
end;

procedure TFhirTestScriptOrigin.SetIndexST(value : String);
begin
  if value <> '' then
  begin
    if FIndex = nil then
      FIndex := TFhirInteger.create;
    FIndex.value := value
  end
  else if FIndex <> nil then
    FIndex.value := '';
end;

procedure TFhirTestScriptOrigin.SetProfile(value : TFhirCoding);
begin
  FProfile.free;
  FProfile := value;
end;

{ TFhirTestScriptOriginListEnumerator }

constructor TFhirTestScriptOriginListEnumerator.Create(list : TFhirTestScriptOriginList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestScriptOriginListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestScriptOriginListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestScriptOriginListEnumerator.GetCurrent : TFhirTestScriptOrigin;
begin
  Result := FList[FIndex];
end;

function TFhirTestScriptOriginListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirTestScriptOriginList }

function TFhirTestScriptOriginList.AddItem(value: TFhirTestScriptOrigin): TFhirTestScriptOrigin;
begin
  assert(value.ClassName = 'TFhirTestScriptOrigin', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestScriptOrigin');
  add(value);
  result := value;
end;

function TFhirTestScriptOriginList.Append: TFhirTestScriptOrigin;
begin
  result := TFhirTestScriptOrigin.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptOriginList.ClearItems;
begin
  Clear;
end;

function TFhirTestScriptOriginList.GetEnumerator : TFhirTestScriptOriginListEnumerator;
begin
  result := TFhirTestScriptOriginListEnumerator.Create(self.link);
end;

function TFhirTestScriptOriginList.Clone: TFhirTestScriptOriginList;
begin
  result := TFhirTestScriptOriginList(inherited Clone);
end;

function TFhirTestScriptOriginList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestScriptOriginList.GetItemN(index: Integer): TFhirTestScriptOrigin;
begin
  result := TFhirTestScriptOrigin(ObjectByIndex[index]);
end;

function TFhirTestScriptOriginList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestScriptOrigin;
end;
function TFhirTestScriptOriginList.IndexOf(value: TFhirTestScriptOrigin): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestScriptOriginList.Insert(index: Integer): TFhirTestScriptOrigin;
begin
  result := TFhirTestScriptOrigin.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptOriginList.InsertItem(index: Integer; value: TFhirTestScriptOrigin);
begin
  assert(value is TFhirTestScriptOrigin);
  Inherited Insert(index, value);
end;

function TFhirTestScriptOriginList.Item(index: Integer): TFhirTestScriptOrigin;
begin
  result := TFhirTestScriptOrigin(ObjectByIndex[index]);
end;

function TFhirTestScriptOriginList.Link: TFhirTestScriptOriginList;
begin
  result := TFhirTestScriptOriginList(inherited Link);
end;

procedure TFhirTestScriptOriginList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestScriptOriginList.SetItemByIndex(index: Integer; value: TFhirTestScriptOrigin);
begin
  assert(value is TFhirTestScriptOrigin);
  FhirTestScriptOrigins[index] := value;
end;

procedure TFhirTestScriptOriginList.SetItemN(index: Integer; value: TFhirTestScriptOrigin);
begin
  assert(value is TFhirTestScriptOrigin);
  ObjectByIndex[index] := value;
end;

{ TFhirTestScriptDestination }

constructor TFhirTestScriptDestination.Create;
begin
  inherited;
end;

destructor TFhirTestScriptDestination.Destroy;
begin
  FIndex.free;
  FProfile.free;
  inherited;
end;

procedure TFhirTestScriptDestination.Assign(oSource : TFslObject);
begin
  inherited;
  indexElement := TFhirTestScriptDestination(oSource).indexElement.Clone;
  profile := TFhirTestScriptDestination(oSource).profile.Clone;
end;

procedure TFhirTestScriptDestination.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'index') Then
     list.add(self.link, 'index', FIndex.Link);
  if (child_name = 'profile') Then
     list.add(self.link, 'profile', FProfile.Link);
end;

procedure TFhirTestScriptDestination.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'index', 'integer', false, TFhirInteger, FIndex.Link));
  oList.add(TFHIRProperty.create(self, 'profile', 'Coding', false, TFhirCoding, FProfile.Link));
end;

function TFhirTestScriptDestination.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'index') then
  begin
    IndexElement := asInteger(propValue);
    result := propValue;
  end
  else if (propName = 'profile') then
  begin
    Profile := propValue as TFhirCoding;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestScriptDestination.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirTestScriptDestination.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'index') then result := TFhirInteger.create()
  else if (propName = 'profile') then result := TFhirCoding.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestScriptDestination.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'index') then result := 'integer'
  else if (propName = 'profile') then result := 'Coding'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestScriptDestination.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'index') then IndexElement := nil
  else if (propName = 'profile') then ProfileElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestScriptDestination.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'index') then IndexElement := asInteger(new)
  else if (propName = 'profile') then ProfileElement := new as TFhirCoding
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestScriptDestination.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirTestScriptDestination.fhirType : string;
begin
  result := 'TestScript.destination';
end;

function TFhirTestScriptDestination.Link : TFhirTestScriptDestination;
begin
  result := TFhirTestScriptDestination(inherited Link);
end;

function TFhirTestScriptDestination.Clone : TFhirTestScriptDestination;
begin
  result := TFhirTestScriptDestination(inherited Clone);
end;

function TFhirTestScriptDestination.equals(other : TObject) : boolean; 
var
  o : TFhirTestScriptDestination;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestScriptDestination)) then
    result := false
  else
  begin
    o := TFhirTestScriptDestination(other);
    result := compareDeep(indexElement, o.indexElement, true) and compareDeep(profileElement, o.profileElement, true);
  end;
end;

function TFhirTestScriptDestination.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIndex) and isEmptyProp(FProfile);
end;

procedure TFhirTestScriptDestination.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('index');
  fields.add('profile');
end;

function TFhirTestScriptDestination.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirTestScriptDestination.SetIndex(value : TFhirInteger);
begin
  FIndex.free;
  FIndex := value;
end;

function TFhirTestScriptDestination.GetIndexST : String;
begin
  if FIndex = nil then
    result := ''
  else
    result := FIndex.value;
end;

procedure TFhirTestScriptDestination.SetIndexST(value : String);
begin
  if value <> '' then
  begin
    if FIndex = nil then
      FIndex := TFhirInteger.create;
    FIndex.value := value
  end
  else if FIndex <> nil then
    FIndex.value := '';
end;

procedure TFhirTestScriptDestination.SetProfile(value : TFhirCoding);
begin
  FProfile.free;
  FProfile := value;
end;

{ TFhirTestScriptDestinationListEnumerator }

constructor TFhirTestScriptDestinationListEnumerator.Create(list : TFhirTestScriptDestinationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestScriptDestinationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestScriptDestinationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestScriptDestinationListEnumerator.GetCurrent : TFhirTestScriptDestination;
begin
  Result := FList[FIndex];
end;

function TFhirTestScriptDestinationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirTestScriptDestinationList }

function TFhirTestScriptDestinationList.AddItem(value: TFhirTestScriptDestination): TFhirTestScriptDestination;
begin
  assert(value.ClassName = 'TFhirTestScriptDestination', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestScriptDestination');
  add(value);
  result := value;
end;

function TFhirTestScriptDestinationList.Append: TFhirTestScriptDestination;
begin
  result := TFhirTestScriptDestination.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptDestinationList.ClearItems;
begin
  Clear;
end;

function TFhirTestScriptDestinationList.GetEnumerator : TFhirTestScriptDestinationListEnumerator;
begin
  result := TFhirTestScriptDestinationListEnumerator.Create(self.link);
end;

function TFhirTestScriptDestinationList.Clone: TFhirTestScriptDestinationList;
begin
  result := TFhirTestScriptDestinationList(inherited Clone);
end;

function TFhirTestScriptDestinationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestScriptDestinationList.GetItemN(index: Integer): TFhirTestScriptDestination;
begin
  result := TFhirTestScriptDestination(ObjectByIndex[index]);
end;

function TFhirTestScriptDestinationList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestScriptDestination;
end;
function TFhirTestScriptDestinationList.IndexOf(value: TFhirTestScriptDestination): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestScriptDestinationList.Insert(index: Integer): TFhirTestScriptDestination;
begin
  result := TFhirTestScriptDestination.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptDestinationList.InsertItem(index: Integer; value: TFhirTestScriptDestination);
begin
  assert(value is TFhirTestScriptDestination);
  Inherited Insert(index, value);
end;

function TFhirTestScriptDestinationList.Item(index: Integer): TFhirTestScriptDestination;
begin
  result := TFhirTestScriptDestination(ObjectByIndex[index]);
end;

function TFhirTestScriptDestinationList.Link: TFhirTestScriptDestinationList;
begin
  result := TFhirTestScriptDestinationList(inherited Link);
end;

procedure TFhirTestScriptDestinationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestScriptDestinationList.SetItemByIndex(index: Integer; value: TFhirTestScriptDestination);
begin
  assert(value is TFhirTestScriptDestination);
  FhirTestScriptDestinations[index] := value;
end;

procedure TFhirTestScriptDestinationList.SetItemN(index: Integer; value: TFhirTestScriptDestination);
begin
  assert(value is TFhirTestScriptDestination);
  ObjectByIndex[index] := value;
end;

{ TFhirTestScriptMetadata }

constructor TFhirTestScriptMetadata.Create;
begin
  inherited;
end;

destructor TFhirTestScriptMetadata.Destroy;
begin
  FLink_List.Free;
  FCapabilityList.Free;
  inherited;
end;

procedure TFhirTestScriptMetadata.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirTestScriptMetadata(oSource).FLink_List = nil) then
  begin
    FLink_List.free;
    FLink_List := nil;
  end
  else
  begin
    if FLink_List = nil then
      FLink_List := TFhirTestScriptMetadataLinkList.Create;
    FLink_List.Assign(TFhirTestScriptMetadata(oSource).FLink_List);
  end;
  if (TFhirTestScriptMetadata(oSource).FCapabilityList = nil) then
  begin
    FCapabilityList.free;
    FCapabilityList := nil;
  end
  else
  begin
    if FCapabilityList = nil then
      FCapabilityList := TFhirTestScriptMetadataCapabilityList.Create;
    FCapabilityList.Assign(TFhirTestScriptMetadata(oSource).FCapabilityList);
  end;
end;

procedure TFhirTestScriptMetadata.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'link') Then
    list.addAll(self, 'link', FLink_List);
  if (child_name = 'capability') Then
    list.addAll(self, 'capability', FCapabilityList);
end;

procedure TFhirTestScriptMetadata.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'link', 'BackboneElement', true, TFhirTestScriptMetadataLink, FLink_List.Link));
  oList.add(TFHIRProperty.create(self, 'capability', 'BackboneElement', true, TFhirTestScriptMetadataCapability, FCapabilityList.Link));
end;

function TFhirTestScriptMetadata.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'link') then
  begin
    Link_List.add(propValue as TFhirTestScriptMetadataLink);
    result := propValue;
  end
  else if (propName = 'capability') then
  begin
    CapabilityList.add(propValue as TFhirTestScriptMetadataCapability);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestScriptMetadata.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'link') then Link_List.insertItem(index, propValue as TFhirTestScriptMetadataLink)
  else if (propName = 'capability') then CapabilityList.insertItem(index, propValue as TFhirTestScriptMetadataCapability)
  else inherited;
end;

function TFhirTestScriptMetadata.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'link') then result := Link_List.new()
  else if (propName = 'capability') then result := CapabilityList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestScriptMetadata.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'link') then result := 'BackboneElement'
  else if (propName = 'capability') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestScriptMetadata.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'link') then deletePropertyValue('link', Link_List, value)
  else if (propName = 'capability') then deletePropertyValue('capability', CapabilityList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestScriptMetadata.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'link') then replacePropertyValue('link', Link_List, existing, new)
  else if (propName = 'capability') then replacePropertyValue('capability', CapabilityList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestScriptMetadata.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'link') then Link_List.move(source, destination)
  else if (propName = 'capability') then CapabilityList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirTestScriptMetadata.fhirType : string;
begin
  result := 'TestScript.metadata';
end;

function TFhirTestScriptMetadata.Link : TFhirTestScriptMetadata;
begin
  result := TFhirTestScriptMetadata(inherited Link);
end;

function TFhirTestScriptMetadata.Clone : TFhirTestScriptMetadata;
begin
  result := TFhirTestScriptMetadata(inherited Clone);
end;

function TFhirTestScriptMetadata.equals(other : TObject) : boolean; 
var
  o : TFhirTestScriptMetadata;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestScriptMetadata)) then
    result := false
  else
  begin
    o := TFhirTestScriptMetadata(other);
    result := compareDeep(link_List, o.link_List, true) and compareDeep(capabilityList, o.capabilityList, true);
  end;
end;

function TFhirTestScriptMetadata.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(Flink_List) and isEmptyProp(FcapabilityList);
end;

procedure TFhirTestScriptMetadata.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('link');
  fields.add('capability');
end;

function TFhirTestScriptMetadata.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FLink_List.sizeInBytes(magic));
  inc(result, FCapabilityList.sizeInBytes(magic));
end;

function TFhirTestScriptMetadata.GetLink_List : TFhirTestScriptMetadataLinkList;
begin
  if FLink_List = nil then
    FLink_List := TFhirTestScriptMetadataLinkList.Create;
  result := FLink_List;
end;

function TFhirTestScriptMetadata.GetHasLink_List : boolean;
begin
  result := (FLink_List <> nil) and (FLink_List.count > 0);
end;

function TFhirTestScriptMetadata.GetCapabilityList : TFhirTestScriptMetadataCapabilityList;
begin
  if FCapabilityList = nil then
    FCapabilityList := TFhirTestScriptMetadataCapabilityList.Create;
  result := FCapabilityList;
end;

function TFhirTestScriptMetadata.GetHasCapabilityList : boolean;
begin
  result := (FCapabilityList <> nil) and (FCapabilityList.count > 0);
end;

{ TFhirTestScriptMetadataListEnumerator }

constructor TFhirTestScriptMetadataListEnumerator.Create(list : TFhirTestScriptMetadataList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestScriptMetadataListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestScriptMetadataListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestScriptMetadataListEnumerator.GetCurrent : TFhirTestScriptMetadata;
begin
  Result := FList[FIndex];
end;

function TFhirTestScriptMetadataListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirTestScriptMetadataList }

function TFhirTestScriptMetadataList.AddItem(value: TFhirTestScriptMetadata): TFhirTestScriptMetadata;
begin
  assert(value.ClassName = 'TFhirTestScriptMetadata', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestScriptMetadata');
  add(value);
  result := value;
end;

function TFhirTestScriptMetadataList.Append: TFhirTestScriptMetadata;
begin
  result := TFhirTestScriptMetadata.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptMetadataList.ClearItems;
begin
  Clear;
end;

function TFhirTestScriptMetadataList.GetEnumerator : TFhirTestScriptMetadataListEnumerator;
begin
  result := TFhirTestScriptMetadataListEnumerator.Create(self.link);
end;

function TFhirTestScriptMetadataList.Clone: TFhirTestScriptMetadataList;
begin
  result := TFhirTestScriptMetadataList(inherited Clone);
end;

function TFhirTestScriptMetadataList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestScriptMetadataList.GetItemN(index: Integer): TFhirTestScriptMetadata;
begin
  result := TFhirTestScriptMetadata(ObjectByIndex[index]);
end;

function TFhirTestScriptMetadataList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestScriptMetadata;
end;
function TFhirTestScriptMetadataList.IndexOf(value: TFhirTestScriptMetadata): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestScriptMetadataList.Insert(index: Integer): TFhirTestScriptMetadata;
begin
  result := TFhirTestScriptMetadata.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptMetadataList.InsertItem(index: Integer; value: TFhirTestScriptMetadata);
begin
  assert(value is TFhirTestScriptMetadata);
  Inherited Insert(index, value);
end;

function TFhirTestScriptMetadataList.Item(index: Integer): TFhirTestScriptMetadata;
begin
  result := TFhirTestScriptMetadata(ObjectByIndex[index]);
end;

function TFhirTestScriptMetadataList.Link: TFhirTestScriptMetadataList;
begin
  result := TFhirTestScriptMetadataList(inherited Link);
end;

procedure TFhirTestScriptMetadataList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestScriptMetadataList.SetItemByIndex(index: Integer; value: TFhirTestScriptMetadata);
begin
  assert(value is TFhirTestScriptMetadata);
  FhirTestScriptMetadata[index] := value;
end;

procedure TFhirTestScriptMetadataList.SetItemN(index: Integer; value: TFhirTestScriptMetadata);
begin
  assert(value is TFhirTestScriptMetadata);
  ObjectByIndex[index] := value;
end;

{ TFhirTestScriptMetadataLink }

constructor TFhirTestScriptMetadataLink.Create;
begin
  inherited;
end;

destructor TFhirTestScriptMetadataLink.Destroy;
begin
  FUrl.free;
  FDescription.free;
  inherited;
end;

procedure TFhirTestScriptMetadataLink.Assign(oSource : TFslObject);
begin
  inherited;
  urlElement := TFhirTestScriptMetadataLink(oSource).urlElement.Clone;
  descriptionElement := TFhirTestScriptMetadataLink(oSource).descriptionElement.Clone;
end;

procedure TFhirTestScriptMetadataLink.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
end;

procedure TFhirTestScriptMetadataLink.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'url', 'uri', false, TFhirUri, FUrl.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));
end;

function TFhirTestScriptMetadataLink.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'url') then
  begin
    UrlElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestScriptMetadataLink.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirTestScriptMetadataLink.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'url') then result := TFhirUri.create()
  else if (propName = 'description') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestScriptMetadataLink.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'url') then result := 'uri'
  else if (propName = 'description') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestScriptMetadataLink.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestScriptMetadataLink.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := asUri(new)
  else if (propName = 'description') then DescriptionElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestScriptMetadataLink.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirTestScriptMetadataLink.fhirType : string;
begin
  result := 'TestScript.metadata.link';
end;

function TFhirTestScriptMetadataLink.Link : TFhirTestScriptMetadataLink;
begin
  result := TFhirTestScriptMetadataLink(inherited Link);
end;

function TFhirTestScriptMetadataLink.Clone : TFhirTestScriptMetadataLink;
begin
  result := TFhirTestScriptMetadataLink(inherited Clone);
end;

function TFhirTestScriptMetadataLink.equals(other : TObject) : boolean; 
var
  o : TFhirTestScriptMetadataLink;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestScriptMetadataLink)) then
    result := false
  else
  begin
    o := TFhirTestScriptMetadataLink(other);
    result := compareDeep(urlElement, o.urlElement, true) and compareDeep(descriptionElement, o.descriptionElement, true);
  end;
end;

function TFhirTestScriptMetadataLink.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FUrl) and isEmptyProp(FDescription);
end;

procedure TFhirTestScriptMetadataLink.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('url');
  fields.add('description');
end;

function TFhirTestScriptMetadataLink.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirTestScriptMetadataLink.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

function TFhirTestScriptMetadataLink.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

procedure TFhirTestScriptMetadataLink.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

procedure TFhirTestScriptMetadataLink.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirTestScriptMetadataLink.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirTestScriptMetadataLink.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

{ TFhirTestScriptMetadataLinkListEnumerator }

constructor TFhirTestScriptMetadataLinkListEnumerator.Create(list : TFhirTestScriptMetadataLinkList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestScriptMetadataLinkListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestScriptMetadataLinkListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestScriptMetadataLinkListEnumerator.GetCurrent : TFhirTestScriptMetadataLink;
begin
  Result := FList[FIndex];
end;

function TFhirTestScriptMetadataLinkListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirTestScriptMetadataLinkList }

function TFhirTestScriptMetadataLinkList.AddItem(value: TFhirTestScriptMetadataLink): TFhirTestScriptMetadataLink;
begin
  assert(value.ClassName = 'TFhirTestScriptMetadataLink', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestScriptMetadataLink');
  add(value);
  result := value;
end;

function TFhirTestScriptMetadataLinkList.Append: TFhirTestScriptMetadataLink;
begin
  result := TFhirTestScriptMetadataLink.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptMetadataLinkList.ClearItems;
begin
  Clear;
end;

function TFhirTestScriptMetadataLinkList.GetEnumerator : TFhirTestScriptMetadataLinkListEnumerator;
begin
  result := TFhirTestScriptMetadataLinkListEnumerator.Create(self.link);
end;

function TFhirTestScriptMetadataLinkList.Clone: TFhirTestScriptMetadataLinkList;
begin
  result := TFhirTestScriptMetadataLinkList(inherited Clone);
end;

function TFhirTestScriptMetadataLinkList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestScriptMetadataLinkList.GetItemN(index: Integer): TFhirTestScriptMetadataLink;
begin
  result := TFhirTestScriptMetadataLink(ObjectByIndex[index]);
end;

function TFhirTestScriptMetadataLinkList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestScriptMetadataLink;
end;
function TFhirTestScriptMetadataLinkList.IndexOf(value: TFhirTestScriptMetadataLink): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestScriptMetadataLinkList.Insert(index: Integer): TFhirTestScriptMetadataLink;
begin
  result := TFhirTestScriptMetadataLink.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptMetadataLinkList.InsertItem(index: Integer; value: TFhirTestScriptMetadataLink);
begin
  assert(value is TFhirTestScriptMetadataLink);
  Inherited Insert(index, value);
end;

function TFhirTestScriptMetadataLinkList.Item(index: Integer): TFhirTestScriptMetadataLink;
begin
  result := TFhirTestScriptMetadataLink(ObjectByIndex[index]);
end;

function TFhirTestScriptMetadataLinkList.Link: TFhirTestScriptMetadataLinkList;
begin
  result := TFhirTestScriptMetadataLinkList(inherited Link);
end;

procedure TFhirTestScriptMetadataLinkList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestScriptMetadataLinkList.SetItemByIndex(index: Integer; value: TFhirTestScriptMetadataLink);
begin
  assert(value is TFhirTestScriptMetadataLink);
  FhirTestScriptMetadataLinks[index] := value;
end;

procedure TFhirTestScriptMetadataLinkList.SetItemN(index: Integer; value: TFhirTestScriptMetadataLink);
begin
  assert(value is TFhirTestScriptMetadataLink);
  ObjectByIndex[index] := value;
end;

{ TFhirTestScriptMetadataCapability }

constructor TFhirTestScriptMetadataCapability.Create;
begin
  inherited;
end;

destructor TFhirTestScriptMetadataCapability.Destroy;
begin
  FRequired.free;
  FValidated.free;
  FDescription.free;
  FOriginList.Free;
  FDestination.free;
  FLink_List.Free;
  FCapabilities.free;
  inherited;
end;

procedure TFhirTestScriptMetadataCapability.Assign(oSource : TFslObject);
begin
  inherited;
  requiredElement := TFhirTestScriptMetadataCapability(oSource).requiredElement.Clone;
  validatedElement := TFhirTestScriptMetadataCapability(oSource).validatedElement.Clone;
  descriptionElement := TFhirTestScriptMetadataCapability(oSource).descriptionElement.Clone;
  if (TFhirTestScriptMetadataCapability(oSource).FOriginList = nil) then
  begin
    FOriginList.free;
    FOriginList := nil;
  end
  else
  begin
    if FOriginList = nil then
      FOriginList := TFhirIntegerList.Create;
    FOriginList.Assign(TFhirTestScriptMetadataCapability(oSource).FOriginList);
  end;
  destinationElement := TFhirTestScriptMetadataCapability(oSource).destinationElement.Clone;
  if (TFhirTestScriptMetadataCapability(oSource).FLink_List = nil) then
  begin
    FLink_List.free;
    FLink_List := nil;
  end
  else
  begin
    if FLink_List = nil then
      FLink_List := TFhirUriList.Create;
    FLink_List.Assign(TFhirTestScriptMetadataCapability(oSource).FLink_List);
  end;
  capabilitiesElement := TFhirTestScriptMetadataCapability(oSource).capabilitiesElement.Clone;
end;

procedure TFhirTestScriptMetadataCapability.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'required') Then
     list.add(self.link, 'required', FRequired.Link);
  if (child_name = 'validated') Then
     list.add(self.link, 'validated', FValidated.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'origin') Then
    list.addAll(self, 'origin', FOriginList);
  if (child_name = 'destination') Then
     list.add(self.link, 'destination', FDestination.Link);
  if (child_name = 'link') Then
    list.addAll(self, 'link', FLink_List);
  if (child_name = 'capabilities') Then
     list.add(self.link, 'capabilities', FCapabilities.Link);
end;

procedure TFhirTestScriptMetadataCapability.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'required', 'boolean', false, TFhirBoolean, FRequired.Link));
  oList.add(TFHIRProperty.create(self, 'validated', 'boolean', false, TFhirBoolean, FValidated.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'origin', 'integer', true, TFhirInteger, FOriginList.Link));
  oList.add(TFHIRProperty.create(self, 'destination', 'integer', false, TFhirInteger, FDestination.Link));
  oList.add(TFHIRProperty.create(self, 'link', 'uri', true, TFhirUri, FLink_List.Link));
  oList.add(TFHIRProperty.create(self, 'capabilities', 'canonical', false, TFhirCanonical, FCapabilities.Link));
end;

function TFhirTestScriptMetadataCapability.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'required') then
  begin
    RequiredElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'validated') then
  begin
    ValidatedElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'origin') then
  begin
    OriginList.add(asInteger(propValue)){2};     result := propValue;

  end
  else if (propName = 'destination') then
  begin
    DestinationElement := asInteger(propValue);
    result := propValue;
  end
  else if (propName = 'link') then
  begin
    Link_List.add(asUri(propValue)){2};     result := propValue;

  end
  else if (propName = 'capabilities') then
  begin
    CapabilitiesElement := asCanonical(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestScriptMetadataCapability.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'origin') then OriginList.insertItem(index, asInteger(propValue))
  else if (propName = 'link') then Link_List.insertItem(index, asUri(propValue))
  else inherited;
end;

function TFhirTestScriptMetadataCapability.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'required') then result := TFhirBoolean.create()
  else if (propName = 'validated') then result := TFhirBoolean.create()
  else if (propName = 'description') then result := TFhirString.create()
  else if (propName = 'origin') then result := OriginList.new()
  else if (propName = 'destination') then result := TFhirInteger.create()
  else if (propName = 'link') then result := Link_List.new()
  else if (propName = 'capabilities') then result := TFhirCanonical.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestScriptMetadataCapability.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'required') then result := 'boolean'
  else if (propName = 'validated') then result := 'boolean'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'origin') then result := 'integer'
  else if (propName = 'destination') then result := 'integer'
  else if (propName = 'link') then result := 'uri'
  else if (propName = 'capabilities') then result := 'canonical'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestScriptMetadataCapability.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'required') then RequiredElement := nil
  else if (propName = 'validated') then ValidatedElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'origin') then deletePropertyValue('origin', OriginList, value)
  else if (propName = 'destination') then DestinationElement := nil
  else if (propName = 'link') then deletePropertyValue('link', Link_List, value)
  else if (propName = 'capabilities') then CapabilitiesElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestScriptMetadataCapability.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'required') then RequiredElement := asBoolean(new)
  else if (propName = 'validated') then ValidatedElement := asBoolean(new)
  else if (propName = 'description') then DescriptionElement := asString(new)
  else if (propName = 'origin') then replacePropertyValue('origin', OriginList, existing, new)
  else if (propName = 'destination') then DestinationElement := asInteger(new)
  else if (propName = 'link') then replacePropertyValue('link', Link_List, existing, new)
  else if (propName = 'capabilities') then CapabilitiesElement := asCanonical(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestScriptMetadataCapability.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'origin') then OriginList.move(source, destination)
  else if (propName = 'link') then Link_List.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirTestScriptMetadataCapability.fhirType : string;
begin
  result := 'TestScript.metadata.capability';
end;

function TFhirTestScriptMetadataCapability.Link : TFhirTestScriptMetadataCapability;
begin
  result := TFhirTestScriptMetadataCapability(inherited Link);
end;

function TFhirTestScriptMetadataCapability.Clone : TFhirTestScriptMetadataCapability;
begin
  result := TFhirTestScriptMetadataCapability(inherited Clone);
end;

function TFhirTestScriptMetadataCapability.equals(other : TObject) : boolean; 
var
  o : TFhirTestScriptMetadataCapability;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestScriptMetadataCapability)) then
    result := false
  else
  begin
    o := TFhirTestScriptMetadataCapability(other);
    result := compareDeep(requiredElement, o.requiredElement, true) and compareDeep(validatedElement, o.validatedElement, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(originList, o.originList, true) and 
      compareDeep(destinationElement, o.destinationElement, true) and compareDeep(link_List, o.link_List, true) and 
      compareDeep(capabilitiesElement, o.capabilitiesElement, true);
  end;
end;

function TFhirTestScriptMetadataCapability.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FRequired) and isEmptyProp(FValidated) and isEmptyProp(FDescription) and isEmptyProp(ForiginList) and isEmptyProp(FDestination) and isEmptyProp(Flink_List) and isEmptyProp(FCapabilities);
end;

procedure TFhirTestScriptMetadataCapability.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('required');
  fields.add('validated');
  fields.add('description');
  fields.add('origin');
  fields.add('destination');
  fields.add('link');
  fields.add('capabilities');
end;

function TFhirTestScriptMetadataCapability.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FOriginList.sizeInBytes(magic));
  inc(result, FLink_List.sizeInBytes(magic));
end;

procedure TFhirTestScriptMetadataCapability.SetRequired(value : TFhirBoolean);
begin
  FRequired.free;
  FRequired := value;
end;

function TFhirTestScriptMetadataCapability.GetRequiredST : Boolean;
begin
  if FRequired = nil then
    result := false
  else
    result := FRequired.value;
end;

procedure TFhirTestScriptMetadataCapability.SetRequiredST(value : Boolean);
begin
  if FRequired = nil then
    FRequired := TFhirBoolean.create;
  FRequired.value := value
end;

procedure TFhirTestScriptMetadataCapability.SetValidated(value : TFhirBoolean);
begin
  FValidated.free;
  FValidated := value;
end;

function TFhirTestScriptMetadataCapability.GetValidatedST : Boolean;
begin
  if FValidated = nil then
    result := false
  else
    result := FValidated.value;
end;

procedure TFhirTestScriptMetadataCapability.SetValidatedST(value : Boolean);
begin
  if FValidated = nil then
    FValidated := TFhirBoolean.create;
  FValidated.value := value
end;

procedure TFhirTestScriptMetadataCapability.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirTestScriptMetadataCapability.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirTestScriptMetadataCapability.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirTestScriptMetadataCapability.GetOriginList : TFhirIntegerList;
begin
  if FOriginList = nil then
    FOriginList := TFhirIntegerList.Create;
  result := FOriginList;
end;

function TFhirTestScriptMetadataCapability.GetHasOriginList : boolean;
begin
  result := (FOriginList <> nil) and (FOriginList.count > 0);
end;

procedure TFhirTestScriptMetadataCapability.SetDestination(value : TFhirInteger);
begin
  FDestination.free;
  FDestination := value;
end;

function TFhirTestScriptMetadataCapability.GetDestinationST : String;
begin
  if FDestination = nil then
    result := ''
  else
    result := FDestination.value;
end;

procedure TFhirTestScriptMetadataCapability.SetDestinationST(value : String);
begin
  if value <> '' then
  begin
    if FDestination = nil then
      FDestination := TFhirInteger.create;
    FDestination.value := value
  end
  else if FDestination <> nil then
    FDestination.value := '';
end;

function TFhirTestScriptMetadataCapability.GetLink_List : TFhirUriList;
begin
  if FLink_List = nil then
    FLink_List := TFhirUriList.Create;
  result := FLink_List;
end;

function TFhirTestScriptMetadataCapability.GetHasLink_List : boolean;
begin
  result := (FLink_List <> nil) and (FLink_List.count > 0);
end;

procedure TFhirTestScriptMetadataCapability.SetCapabilities(value : TFhirCanonical);
begin
  FCapabilities.free;
  FCapabilities := value;
end;

function TFhirTestScriptMetadataCapability.GetCapabilitiesST : String;
begin
  if FCapabilities = nil then
    result := ''
  else
    result := FCapabilities.value;
end;

procedure TFhirTestScriptMetadataCapability.SetCapabilitiesST(value : String);
begin
  if value <> '' then
  begin
    if FCapabilities = nil then
      FCapabilities := TFhirCanonical.create;
    FCapabilities.value := value
  end
  else if FCapabilities <> nil then
    FCapabilities.value := '';
end;

{ TFhirTestScriptMetadataCapabilityListEnumerator }

constructor TFhirTestScriptMetadataCapabilityListEnumerator.Create(list : TFhirTestScriptMetadataCapabilityList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestScriptMetadataCapabilityListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestScriptMetadataCapabilityListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestScriptMetadataCapabilityListEnumerator.GetCurrent : TFhirTestScriptMetadataCapability;
begin
  Result := FList[FIndex];
end;

function TFhirTestScriptMetadataCapabilityListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirTestScriptMetadataCapabilityList }

function TFhirTestScriptMetadataCapabilityList.AddItem(value: TFhirTestScriptMetadataCapability): TFhirTestScriptMetadataCapability;
begin
  assert(value.ClassName = 'TFhirTestScriptMetadataCapability', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestScriptMetadataCapability');
  add(value);
  result := value;
end;

function TFhirTestScriptMetadataCapabilityList.Append: TFhirTestScriptMetadataCapability;
begin
  result := TFhirTestScriptMetadataCapability.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptMetadataCapabilityList.ClearItems;
begin
  Clear;
end;

function TFhirTestScriptMetadataCapabilityList.GetEnumerator : TFhirTestScriptMetadataCapabilityListEnumerator;
begin
  result := TFhirTestScriptMetadataCapabilityListEnumerator.Create(self.link);
end;

function TFhirTestScriptMetadataCapabilityList.Clone: TFhirTestScriptMetadataCapabilityList;
begin
  result := TFhirTestScriptMetadataCapabilityList(inherited Clone);
end;

function TFhirTestScriptMetadataCapabilityList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestScriptMetadataCapabilityList.GetItemN(index: Integer): TFhirTestScriptMetadataCapability;
begin
  result := TFhirTestScriptMetadataCapability(ObjectByIndex[index]);
end;

function TFhirTestScriptMetadataCapabilityList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestScriptMetadataCapability;
end;
function TFhirTestScriptMetadataCapabilityList.IndexOf(value: TFhirTestScriptMetadataCapability): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestScriptMetadataCapabilityList.Insert(index: Integer): TFhirTestScriptMetadataCapability;
begin
  result := TFhirTestScriptMetadataCapability.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptMetadataCapabilityList.InsertItem(index: Integer; value: TFhirTestScriptMetadataCapability);
begin
  assert(value is TFhirTestScriptMetadataCapability);
  Inherited Insert(index, value);
end;

function TFhirTestScriptMetadataCapabilityList.Item(index: Integer): TFhirTestScriptMetadataCapability;
begin
  result := TFhirTestScriptMetadataCapability(ObjectByIndex[index]);
end;

function TFhirTestScriptMetadataCapabilityList.Link: TFhirTestScriptMetadataCapabilityList;
begin
  result := TFhirTestScriptMetadataCapabilityList(inherited Link);
end;

procedure TFhirTestScriptMetadataCapabilityList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestScriptMetadataCapabilityList.SetItemByIndex(index: Integer; value: TFhirTestScriptMetadataCapability);
begin
  assert(value is TFhirTestScriptMetadataCapability);
  FhirTestScriptMetadataCapabilities[index] := value;
end;

procedure TFhirTestScriptMetadataCapabilityList.SetItemN(index: Integer; value: TFhirTestScriptMetadataCapability);
begin
  assert(value is TFhirTestScriptMetadataCapability);
  ObjectByIndex[index] := value;
end;

{ TFhirTestScriptFixture }

constructor TFhirTestScriptFixture.Create;
begin
  inherited;
end;

destructor TFhirTestScriptFixture.Destroy;
begin
  FAutocreate.free;
  FAutodelete.free;
  FResource.free;
  inherited;
end;

procedure TFhirTestScriptFixture.Assign(oSource : TFslObject);
begin
  inherited;
  autocreateElement := TFhirTestScriptFixture(oSource).autocreateElement.Clone;
  autodeleteElement := TFhirTestScriptFixture(oSource).autodeleteElement.Clone;
  resource := TFhirTestScriptFixture(oSource).resource.Clone;
end;

procedure TFhirTestScriptFixture.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'autocreate') Then
     list.add(self.link, 'autocreate', FAutocreate.Link);
  if (child_name = 'autodelete') Then
     list.add(self.link, 'autodelete', FAutodelete.Link);
  if (child_name = 'resource') Then
     list.add(self.link, 'resource', FResource.Link);
end;

procedure TFhirTestScriptFixture.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'autocreate', 'boolean', false, TFhirBoolean, FAutocreate.Link));
  oList.add(TFHIRProperty.create(self, 'autodelete', 'boolean', false, TFhirBoolean, FAutodelete.Link));
  oList.add(TFHIRProperty.create(self, 'resource', 'Reference', false, TFhirReference, FResource.Link));
end;

function TFhirTestScriptFixture.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'autocreate') then
  begin
    AutocreateElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'autodelete') then
  begin
    AutodeleteElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'resource') then
  begin
    Resource := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestScriptFixture.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirTestScriptFixture.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'autocreate') then result := TFhirBoolean.create()
  else if (propName = 'autodelete') then result := TFhirBoolean.create()
  else if (propName = 'resource') then result := TFhirReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestScriptFixture.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'autocreate') then result := 'boolean'
  else if (propName = 'autodelete') then result := 'boolean'
  else if (propName = 'resource') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestScriptFixture.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'autocreate') then AutocreateElement := nil
  else if (propName = 'autodelete') then AutodeleteElement := nil
  else if (propName = 'resource') then ResourceElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestScriptFixture.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'autocreate') then AutocreateElement := asBoolean(new)
  else if (propName = 'autodelete') then AutodeleteElement := asBoolean(new)
  else if (propName = 'resource') then ResourceElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestScriptFixture.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirTestScriptFixture.fhirType : string;
begin
  result := 'TestScript.fixture';
end;

function TFhirTestScriptFixture.Link : TFhirTestScriptFixture;
begin
  result := TFhirTestScriptFixture(inherited Link);
end;

function TFhirTestScriptFixture.Clone : TFhirTestScriptFixture;
begin
  result := TFhirTestScriptFixture(inherited Clone);
end;

function TFhirTestScriptFixture.equals(other : TObject) : boolean; 
var
  o : TFhirTestScriptFixture;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestScriptFixture)) then
    result := false
  else
  begin
    o := TFhirTestScriptFixture(other);
    result := compareDeep(autocreateElement, o.autocreateElement, true) and compareDeep(autodeleteElement, o.autodeleteElement, true) and 
      compareDeep(resourceElement, o.resourceElement, true);
  end;
end;

function TFhirTestScriptFixture.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FAutocreate) and isEmptyProp(FAutodelete) and isEmptyProp(FResource);
end;

procedure TFhirTestScriptFixture.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('autocreate');
  fields.add('autodelete');
  fields.add('resource');
end;

function TFhirTestScriptFixture.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirTestScriptFixture.SetAutocreate(value : TFhirBoolean);
begin
  FAutocreate.free;
  FAutocreate := value;
end;

function TFhirTestScriptFixture.GetAutocreateST : Boolean;
begin
  if FAutocreate = nil then
    result := false
  else
    result := FAutocreate.value;
end;

procedure TFhirTestScriptFixture.SetAutocreateST(value : Boolean);
begin
  if FAutocreate = nil then
    FAutocreate := TFhirBoolean.create;
  FAutocreate.value := value
end;

procedure TFhirTestScriptFixture.SetAutodelete(value : TFhirBoolean);
begin
  FAutodelete.free;
  FAutodelete := value;
end;

function TFhirTestScriptFixture.GetAutodeleteST : Boolean;
begin
  if FAutodelete = nil then
    result := false
  else
    result := FAutodelete.value;
end;

procedure TFhirTestScriptFixture.SetAutodeleteST(value : Boolean);
begin
  if FAutodelete = nil then
    FAutodelete := TFhirBoolean.create;
  FAutodelete.value := value
end;

procedure TFhirTestScriptFixture.SetResource(value : TFhirReference);
begin
  FResource.free;
  FResource := value;
end;

{ TFhirTestScriptFixtureListEnumerator }

constructor TFhirTestScriptFixtureListEnumerator.Create(list : TFhirTestScriptFixtureList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestScriptFixtureListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestScriptFixtureListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestScriptFixtureListEnumerator.GetCurrent : TFhirTestScriptFixture;
begin
  Result := FList[FIndex];
end;

function TFhirTestScriptFixtureListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirTestScriptFixtureList }

function TFhirTestScriptFixtureList.AddItem(value: TFhirTestScriptFixture): TFhirTestScriptFixture;
begin
  assert(value.ClassName = 'TFhirTestScriptFixture', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestScriptFixture');
  add(value);
  result := value;
end;

function TFhirTestScriptFixtureList.Append: TFhirTestScriptFixture;
begin
  result := TFhirTestScriptFixture.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptFixtureList.ClearItems;
begin
  Clear;
end;

function TFhirTestScriptFixtureList.GetEnumerator : TFhirTestScriptFixtureListEnumerator;
begin
  result := TFhirTestScriptFixtureListEnumerator.Create(self.link);
end;

function TFhirTestScriptFixtureList.Clone: TFhirTestScriptFixtureList;
begin
  result := TFhirTestScriptFixtureList(inherited Clone);
end;

function TFhirTestScriptFixtureList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestScriptFixtureList.GetItemN(index: Integer): TFhirTestScriptFixture;
begin
  result := TFhirTestScriptFixture(ObjectByIndex[index]);
end;

function TFhirTestScriptFixtureList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestScriptFixture;
end;
function TFhirTestScriptFixtureList.IndexOf(value: TFhirTestScriptFixture): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestScriptFixtureList.Insert(index: Integer): TFhirTestScriptFixture;
begin
  result := TFhirTestScriptFixture.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptFixtureList.InsertItem(index: Integer; value: TFhirTestScriptFixture);
begin
  assert(value is TFhirTestScriptFixture);
  Inherited Insert(index, value);
end;

function TFhirTestScriptFixtureList.Item(index: Integer): TFhirTestScriptFixture;
begin
  result := TFhirTestScriptFixture(ObjectByIndex[index]);
end;

function TFhirTestScriptFixtureList.Link: TFhirTestScriptFixtureList;
begin
  result := TFhirTestScriptFixtureList(inherited Link);
end;

procedure TFhirTestScriptFixtureList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestScriptFixtureList.SetItemByIndex(index: Integer; value: TFhirTestScriptFixture);
begin
  assert(value is TFhirTestScriptFixture);
  FhirTestScriptFixtures[index] := value;
end;

procedure TFhirTestScriptFixtureList.SetItemN(index: Integer; value: TFhirTestScriptFixture);
begin
  assert(value is TFhirTestScriptFixture);
  ObjectByIndex[index] := value;
end;

{ TFhirTestScriptVariable }

constructor TFhirTestScriptVariable.Create;
begin
  inherited;
end;

destructor TFhirTestScriptVariable.Destroy;
begin
  FName.free;
  FDefaultValue.free;
  FDescription.free;
  FExpression.free;
  FHeaderField.free;
  FHint.free;
  FPath.free;
  FSourceId.free;
  inherited;
end;

procedure TFhirTestScriptVariable.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirTestScriptVariable(oSource).nameElement.Clone;
  defaultValueElement := TFhirTestScriptVariable(oSource).defaultValueElement.Clone;
  descriptionElement := TFhirTestScriptVariable(oSource).descriptionElement.Clone;
  expressionElement := TFhirTestScriptVariable(oSource).expressionElement.Clone;
  headerFieldElement := TFhirTestScriptVariable(oSource).headerFieldElement.Clone;
  hintElement := TFhirTestScriptVariable(oSource).hintElement.Clone;
  pathElement := TFhirTestScriptVariable(oSource).pathElement.Clone;
  sourceIdElement := TFhirTestScriptVariable(oSource).sourceIdElement.Clone;
end;

procedure TFhirTestScriptVariable.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'defaultValue') Then
     list.add(self.link, 'defaultValue', FDefaultValue.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'expression') Then
     list.add(self.link, 'expression', FExpression.Link);
  if (child_name = 'headerField') Then
     list.add(self.link, 'headerField', FHeaderField.Link);
  if (child_name = 'hint') Then
     list.add(self.link, 'hint', FHint.Link);
  if (child_name = 'path') Then
     list.add(self.link, 'path', FPath.Link);
  if (child_name = 'sourceId') Then
     list.add(self.link, 'sourceId', FSourceId.Link);
end;

procedure TFhirTestScriptVariable.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'defaultValue', 'string', false, TFhirString, FDefaultValue.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'expression', 'string', false, TFhirString, FExpression.Link));
  oList.add(TFHIRProperty.create(self, 'headerField', 'string', false, TFhirString, FHeaderField.Link));
  oList.add(TFHIRProperty.create(self, 'hint', 'string', false, TFhirString, FHint.Link));
  oList.add(TFHIRProperty.create(self, 'path', 'string', false, TFhirString, FPath.Link));
  oList.add(TFHIRProperty.create(self, 'sourceId', 'id', false, TFhirId, FSourceId.Link));
end;

function TFhirTestScriptVariable.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'defaultValue') then
  begin
    DefaultValueElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'expression') then
  begin
    ExpressionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'headerField') then
  begin
    HeaderFieldElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'hint') then
  begin
    HintElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'path') then
  begin
    PathElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'sourceId') then
  begin
    SourceIdElement := asId(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestScriptVariable.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirTestScriptVariable.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'defaultValue') then result := TFhirString.create()
  else if (propName = 'description') then result := TFhirString.create()
  else if (propName = 'expression') then result := TFhirString.create()
  else if (propName = 'headerField') then result := TFhirString.create()
  else if (propName = 'hint') then result := TFhirString.create()
  else if (propName = 'path') then result := TFhirString.create()
  else if (propName = 'sourceId') then result := TFhirId.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestScriptVariable.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'defaultValue') then result := 'string'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'expression') then result := 'string'
  else if (propName = 'headerField') then result := 'string'
  else if (propName = 'hint') then result := 'string'
  else if (propName = 'path') then result := 'string'
  else if (propName = 'sourceId') then result := 'id'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestScriptVariable.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'defaultValue') then DefaultValueElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'expression') then ExpressionElement := nil
  else if (propName = 'headerField') then HeaderFieldElement := nil
  else if (propName = 'hint') then HintElement := nil
  else if (propName = 'path') then PathElement := nil
  else if (propName = 'sourceId') then SourceIdElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestScriptVariable.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'defaultValue') then DefaultValueElement := asString(new)
  else if (propName = 'description') then DescriptionElement := asString(new)
  else if (propName = 'expression') then ExpressionElement := asString(new)
  else if (propName = 'headerField') then HeaderFieldElement := asString(new)
  else if (propName = 'hint') then HintElement := asString(new)
  else if (propName = 'path') then PathElement := asString(new)
  else if (propName = 'sourceId') then SourceIdElement := asId(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestScriptVariable.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirTestScriptVariable.fhirType : string;
begin
  result := 'TestScript.variable';
end;

function TFhirTestScriptVariable.Link : TFhirTestScriptVariable;
begin
  result := TFhirTestScriptVariable(inherited Link);
end;

function TFhirTestScriptVariable.Clone : TFhirTestScriptVariable;
begin
  result := TFhirTestScriptVariable(inherited Clone);
end;

function TFhirTestScriptVariable.equals(other : TObject) : boolean; 
var
  o : TFhirTestScriptVariable;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestScriptVariable)) then
    result := false
  else
  begin
    o := TFhirTestScriptVariable(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(defaultValueElement, o.defaultValueElement, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(expressionElement, o.expressionElement, true) and 
      compareDeep(headerFieldElement, o.headerFieldElement, true) and compareDeep(hintElement, o.hintElement, true) and 
      compareDeep(pathElement, o.pathElement, true) and compareDeep(sourceIdElement, o.sourceIdElement, true);
  end;
end;

function TFhirTestScriptVariable.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FDefaultValue) and isEmptyProp(FDescription) and isEmptyProp(FExpression) and isEmptyProp(FHeaderField) and isEmptyProp(FHint) and isEmptyProp(FPath) and isEmptyProp(FSourceId);
end;

procedure TFhirTestScriptVariable.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('name');
  fields.add('defaultValue');
  fields.add('description');
  fields.add('expression');
  fields.add('headerField');
  fields.add('hint');
  fields.add('path');
  fields.add('sourceId');
end;

function TFhirTestScriptVariable.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirTestScriptVariable.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirTestScriptVariable.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirTestScriptVariable.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirTestScriptVariable.SetDefaultValue(value : TFhirString);
begin
  FDefaultValue.free;
  FDefaultValue := value;
end;

function TFhirTestScriptVariable.GetDefaultValueST : String;
begin
  if FDefaultValue = nil then
    result := ''
  else
    result := FDefaultValue.value;
end;

procedure TFhirTestScriptVariable.SetDefaultValueST(value : String);
begin
  if value <> '' then
  begin
    if FDefaultValue = nil then
      FDefaultValue := TFhirString.create;
    FDefaultValue.value := value
  end
  else if FDefaultValue <> nil then
    FDefaultValue.value := '';
end;

procedure TFhirTestScriptVariable.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirTestScriptVariable.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirTestScriptVariable.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirTestScriptVariable.SetExpression(value : TFhirString);
begin
  FExpression.free;
  FExpression := value;
end;

function TFhirTestScriptVariable.GetExpressionST : String;
begin
  if FExpression = nil then
    result := ''
  else
    result := FExpression.value;
end;

procedure TFhirTestScriptVariable.SetExpressionST(value : String);
begin
  if value <> '' then
  begin
    if FExpression = nil then
      FExpression := TFhirString.create;
    FExpression.value := value
  end
  else if FExpression <> nil then
    FExpression.value := '';
end;

procedure TFhirTestScriptVariable.SetHeaderField(value : TFhirString);
begin
  FHeaderField.free;
  FHeaderField := value;
end;

function TFhirTestScriptVariable.GetHeaderFieldST : String;
begin
  if FHeaderField = nil then
    result := ''
  else
    result := FHeaderField.value;
end;

procedure TFhirTestScriptVariable.SetHeaderFieldST(value : String);
begin
  if value <> '' then
  begin
    if FHeaderField = nil then
      FHeaderField := TFhirString.create;
    FHeaderField.value := value
  end
  else if FHeaderField <> nil then
    FHeaderField.value := '';
end;

procedure TFhirTestScriptVariable.SetHint(value : TFhirString);
begin
  FHint.free;
  FHint := value;
end;

function TFhirTestScriptVariable.GetHintST : String;
begin
  if FHint = nil then
    result := ''
  else
    result := FHint.value;
end;

procedure TFhirTestScriptVariable.SetHintST(value : String);
begin
  if value <> '' then
  begin
    if FHint = nil then
      FHint := TFhirString.create;
    FHint.value := value
  end
  else if FHint <> nil then
    FHint.value := '';
end;

procedure TFhirTestScriptVariable.SetPath(value : TFhirString);
begin
  FPath.free;
  FPath := value;
end;

function TFhirTestScriptVariable.GetPathST : String;
begin
  if FPath = nil then
    result := ''
  else
    result := FPath.value;
end;

procedure TFhirTestScriptVariable.SetPathST(value : String);
begin
  if value <> '' then
  begin
    if FPath = nil then
      FPath := TFhirString.create;
    FPath.value := value
  end
  else if FPath <> nil then
    FPath.value := '';
end;

procedure TFhirTestScriptVariable.SetSourceId(value : TFhirId);
begin
  FSourceId.free;
  FSourceId := value;
end;

function TFhirTestScriptVariable.GetSourceIdST : String;
begin
  if FSourceId = nil then
    result := ''
  else
    result := FSourceId.value;
end;

procedure TFhirTestScriptVariable.SetSourceIdST(value : String);
begin
  if value <> '' then
  begin
    if FSourceId = nil then
      FSourceId := TFhirId.create;
    FSourceId.value := value
  end
  else if FSourceId <> nil then
    FSourceId.value := '';
end;

{ TFhirTestScriptVariableListEnumerator }

constructor TFhirTestScriptVariableListEnumerator.Create(list : TFhirTestScriptVariableList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestScriptVariableListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestScriptVariableListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestScriptVariableListEnumerator.GetCurrent : TFhirTestScriptVariable;
begin
  Result := FList[FIndex];
end;

function TFhirTestScriptVariableListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirTestScriptVariableList }

function TFhirTestScriptVariableList.AddItem(value: TFhirTestScriptVariable): TFhirTestScriptVariable;
begin
  assert(value.ClassName = 'TFhirTestScriptVariable', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestScriptVariable');
  add(value);
  result := value;
end;

function TFhirTestScriptVariableList.Append: TFhirTestScriptVariable;
begin
  result := TFhirTestScriptVariable.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptVariableList.ClearItems;
begin
  Clear;
end;

function TFhirTestScriptVariableList.GetEnumerator : TFhirTestScriptVariableListEnumerator;
begin
  result := TFhirTestScriptVariableListEnumerator.Create(self.link);
end;

function TFhirTestScriptVariableList.Clone: TFhirTestScriptVariableList;
begin
  result := TFhirTestScriptVariableList(inherited Clone);
end;

function TFhirTestScriptVariableList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestScriptVariableList.GetItemN(index: Integer): TFhirTestScriptVariable;
begin
  result := TFhirTestScriptVariable(ObjectByIndex[index]);
end;

function TFhirTestScriptVariableList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestScriptVariable;
end;
function TFhirTestScriptVariableList.IndexOf(value: TFhirTestScriptVariable): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestScriptVariableList.Insert(index: Integer): TFhirTestScriptVariable;
begin
  result := TFhirTestScriptVariable.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptVariableList.InsertItem(index: Integer; value: TFhirTestScriptVariable);
begin
  assert(value is TFhirTestScriptVariable);
  Inherited Insert(index, value);
end;

function TFhirTestScriptVariableList.Item(index: Integer): TFhirTestScriptVariable;
begin
  result := TFhirTestScriptVariable(ObjectByIndex[index]);
end;

function TFhirTestScriptVariableList.Link: TFhirTestScriptVariableList;
begin
  result := TFhirTestScriptVariableList(inherited Link);
end;

procedure TFhirTestScriptVariableList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestScriptVariableList.SetItemByIndex(index: Integer; value: TFhirTestScriptVariable);
begin
  assert(value is TFhirTestScriptVariable);
  FhirTestScriptVariables[index] := value;
end;

procedure TFhirTestScriptVariableList.SetItemN(index: Integer; value: TFhirTestScriptVariable);
begin
  assert(value is TFhirTestScriptVariable);
  ObjectByIndex[index] := value;
end;

{ TFhirTestScriptSetup }

constructor TFhirTestScriptSetup.Create;
begin
  inherited;
end;

destructor TFhirTestScriptSetup.Destroy;
begin
  FActionList.Free;
  inherited;
end;

procedure TFhirTestScriptSetup.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirTestScriptSetup(oSource).FActionList = nil) then
  begin
    FActionList.free;
    FActionList := nil;
  end
  else
  begin
    if FActionList = nil then
      FActionList := TFhirTestScriptSetupActionList.Create;
    FActionList.Assign(TFhirTestScriptSetup(oSource).FActionList);
  end;
end;

procedure TFhirTestScriptSetup.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'action') Then
    list.addAll(self, 'action', FActionList);
end;

procedure TFhirTestScriptSetup.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'action', 'BackboneElement', true, TFhirTestScriptSetupAction, FActionList.Link));
end;

function TFhirTestScriptSetup.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'action') then
  begin
    ActionList.add(propValue as TFhirTestScriptSetupAction);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestScriptSetup.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'action') then ActionList.insertItem(index, propValue as TFhirTestScriptSetupAction)
  else inherited;
end;

function TFhirTestScriptSetup.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'action') then result := ActionList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestScriptSetup.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'action') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestScriptSetup.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'action') then deletePropertyValue('action', ActionList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestScriptSetup.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'action') then replacePropertyValue('action', ActionList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestScriptSetup.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'action') then ActionList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirTestScriptSetup.fhirType : string;
begin
  result := 'TestScript.setup';
end;

function TFhirTestScriptSetup.Link : TFhirTestScriptSetup;
begin
  result := TFhirTestScriptSetup(inherited Link);
end;

function TFhirTestScriptSetup.Clone : TFhirTestScriptSetup;
begin
  result := TFhirTestScriptSetup(inherited Clone);
end;

function TFhirTestScriptSetup.equals(other : TObject) : boolean; 
var
  o : TFhirTestScriptSetup;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestScriptSetup)) then
    result := false
  else
  begin
    o := TFhirTestScriptSetup(other);
    result := compareDeep(actionList, o.actionList, true);
  end;
end;

function TFhirTestScriptSetup.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FactionList);
end;

procedure TFhirTestScriptSetup.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('action');
end;

function TFhirTestScriptSetup.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FActionList.sizeInBytes(magic));
end;

function TFhirTestScriptSetup.GetActionList : TFhirTestScriptSetupActionList;
begin
  if FActionList = nil then
    FActionList := TFhirTestScriptSetupActionList.Create;
  result := FActionList;
end;

function TFhirTestScriptSetup.GetHasActionList : boolean;
begin
  result := (FActionList <> nil) and (FActionList.count > 0);
end;

{ TFhirTestScriptSetupListEnumerator }

constructor TFhirTestScriptSetupListEnumerator.Create(list : TFhirTestScriptSetupList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestScriptSetupListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestScriptSetupListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestScriptSetupListEnumerator.GetCurrent : TFhirTestScriptSetup;
begin
  Result := FList[FIndex];
end;

function TFhirTestScriptSetupListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirTestScriptSetupList }

function TFhirTestScriptSetupList.AddItem(value: TFhirTestScriptSetup): TFhirTestScriptSetup;
begin
  assert(value.ClassName = 'TFhirTestScriptSetup', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestScriptSetup');
  add(value);
  result := value;
end;

function TFhirTestScriptSetupList.Append: TFhirTestScriptSetup;
begin
  result := TFhirTestScriptSetup.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptSetupList.ClearItems;
begin
  Clear;
end;

function TFhirTestScriptSetupList.GetEnumerator : TFhirTestScriptSetupListEnumerator;
begin
  result := TFhirTestScriptSetupListEnumerator.Create(self.link);
end;

function TFhirTestScriptSetupList.Clone: TFhirTestScriptSetupList;
begin
  result := TFhirTestScriptSetupList(inherited Clone);
end;

function TFhirTestScriptSetupList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestScriptSetupList.GetItemN(index: Integer): TFhirTestScriptSetup;
begin
  result := TFhirTestScriptSetup(ObjectByIndex[index]);
end;

function TFhirTestScriptSetupList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestScriptSetup;
end;
function TFhirTestScriptSetupList.IndexOf(value: TFhirTestScriptSetup): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestScriptSetupList.Insert(index: Integer): TFhirTestScriptSetup;
begin
  result := TFhirTestScriptSetup.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptSetupList.InsertItem(index: Integer; value: TFhirTestScriptSetup);
begin
  assert(value is TFhirTestScriptSetup);
  Inherited Insert(index, value);
end;

function TFhirTestScriptSetupList.Item(index: Integer): TFhirTestScriptSetup;
begin
  result := TFhirTestScriptSetup(ObjectByIndex[index]);
end;

function TFhirTestScriptSetupList.Link: TFhirTestScriptSetupList;
begin
  result := TFhirTestScriptSetupList(inherited Link);
end;

procedure TFhirTestScriptSetupList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestScriptSetupList.SetItemByIndex(index: Integer; value: TFhirTestScriptSetup);
begin
  assert(value is TFhirTestScriptSetup);
  FhirTestScriptSetups[index] := value;
end;

procedure TFhirTestScriptSetupList.SetItemN(index: Integer; value: TFhirTestScriptSetup);
begin
  assert(value is TFhirTestScriptSetup);
  ObjectByIndex[index] := value;
end;

{ TFhirTestScriptSetupAction }

constructor TFhirTestScriptSetupAction.Create;
begin
  inherited;
end;

destructor TFhirTestScriptSetupAction.Destroy;
begin
  FOperation.free;
  FAssert.free;
  inherited;
end;

procedure TFhirTestScriptSetupAction.Assign(oSource : TFslObject);
begin
  inherited;
  operation := TFhirTestScriptSetupAction(oSource).operation.Clone;
  assert := TFhirTestScriptSetupAction(oSource).assert.Clone;
end;

procedure TFhirTestScriptSetupAction.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'operation') Then
     list.add(self.link, 'operation', FOperation.Link);
  if (child_name = 'assert') Then
     list.add(self.link, 'assert', FAssert.Link);
end;

procedure TFhirTestScriptSetupAction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'operation', 'BackboneElement', false, TFhirTestScriptSetupActionOperation, FOperation.Link));
  oList.add(TFHIRProperty.create(self, 'assert', 'BackboneElement', false, TFhirTestScriptSetupActionAssert, FAssert.Link));
end;

function TFhirTestScriptSetupAction.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'operation') then
  begin
    Operation := propValue as TFhirTestScriptSetupActionOperation;
    result := propValue;
  end
  else if (propName = 'assert') then
  begin
    Assert := propValue as TFhirTestScriptSetupActionAssert;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestScriptSetupAction.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirTestScriptSetupAction.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'operation') then result := TFhirTestScriptSetupActionOperation.create()
  else if (propName = 'assert') then result := TFhirTestScriptSetupActionAssert.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestScriptSetupAction.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'operation') then result := 'BackboneElement'
  else if (propName = 'assert') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestScriptSetupAction.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'operation') then OperationElement := nil
  else if (propName = 'assert') then AssertElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestScriptSetupAction.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'operation') then OperationElement := new as TFhirTestScriptSetupActionOperation
  else if (propName = 'assert') then AssertElement := new as TFhirTestScriptSetupActionAssert
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestScriptSetupAction.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirTestScriptSetupAction.fhirType : string;
begin
  result := 'TestScript.setup.action';
end;

function TFhirTestScriptSetupAction.Link : TFhirTestScriptSetupAction;
begin
  result := TFhirTestScriptSetupAction(inherited Link);
end;

function TFhirTestScriptSetupAction.Clone : TFhirTestScriptSetupAction;
begin
  result := TFhirTestScriptSetupAction(inherited Clone);
end;

function TFhirTestScriptSetupAction.equals(other : TObject) : boolean; 
var
  o : TFhirTestScriptSetupAction;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestScriptSetupAction)) then
    result := false
  else
  begin
    o := TFhirTestScriptSetupAction(other);
    result := compareDeep(operationElement, o.operationElement, true) and compareDeep(assertElement, o.assertElement, true);
  end;
end;

function TFhirTestScriptSetupAction.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FOperation) and isEmptyProp(FAssert);
end;

procedure TFhirTestScriptSetupAction.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('operation');
  fields.add('assert');
end;

function TFhirTestScriptSetupAction.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirTestScriptSetupAction.SetOperation(value : TFhirTestScriptSetupActionOperation);
begin
  FOperation.free;
  FOperation := value;
end;

procedure TFhirTestScriptSetupAction.SetAssert(value : TFhirTestScriptSetupActionAssert);
begin
  FAssert.free;
  FAssert := value;
end;

{ TFhirTestScriptSetupActionListEnumerator }

constructor TFhirTestScriptSetupActionListEnumerator.Create(list : TFhirTestScriptSetupActionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestScriptSetupActionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestScriptSetupActionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestScriptSetupActionListEnumerator.GetCurrent : TFhirTestScriptSetupAction;
begin
  Result := FList[FIndex];
end;

function TFhirTestScriptSetupActionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirTestScriptSetupActionList }

function TFhirTestScriptSetupActionList.AddItem(value: TFhirTestScriptSetupAction): TFhirTestScriptSetupAction;
begin
  assert(value.ClassName = 'TFhirTestScriptSetupAction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestScriptSetupAction');
  add(value);
  result := value;
end;

function TFhirTestScriptSetupActionList.Append: TFhirTestScriptSetupAction;
begin
  result := TFhirTestScriptSetupAction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptSetupActionList.ClearItems;
begin
  Clear;
end;

function TFhirTestScriptSetupActionList.GetEnumerator : TFhirTestScriptSetupActionListEnumerator;
begin
  result := TFhirTestScriptSetupActionListEnumerator.Create(self.link);
end;

function TFhirTestScriptSetupActionList.Clone: TFhirTestScriptSetupActionList;
begin
  result := TFhirTestScriptSetupActionList(inherited Clone);
end;

function TFhirTestScriptSetupActionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestScriptSetupActionList.GetItemN(index: Integer): TFhirTestScriptSetupAction;
begin
  result := TFhirTestScriptSetupAction(ObjectByIndex[index]);
end;

function TFhirTestScriptSetupActionList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestScriptSetupAction;
end;
function TFhirTestScriptSetupActionList.IndexOf(value: TFhirTestScriptSetupAction): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestScriptSetupActionList.Insert(index: Integer): TFhirTestScriptSetupAction;
begin
  result := TFhirTestScriptSetupAction.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptSetupActionList.InsertItem(index: Integer; value: TFhirTestScriptSetupAction);
begin
  assert(value is TFhirTestScriptSetupAction);
  Inherited Insert(index, value);
end;

function TFhirTestScriptSetupActionList.Item(index: Integer): TFhirTestScriptSetupAction;
begin
  result := TFhirTestScriptSetupAction(ObjectByIndex[index]);
end;

function TFhirTestScriptSetupActionList.Link: TFhirTestScriptSetupActionList;
begin
  result := TFhirTestScriptSetupActionList(inherited Link);
end;

procedure TFhirTestScriptSetupActionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestScriptSetupActionList.SetItemByIndex(index: Integer; value: TFhirTestScriptSetupAction);
begin
  assert(value is TFhirTestScriptSetupAction);
  FhirTestScriptSetupActions[index] := value;
end;

procedure TFhirTestScriptSetupActionList.SetItemN(index: Integer; value: TFhirTestScriptSetupAction);
begin
  assert(value is TFhirTestScriptSetupAction);
  ObjectByIndex[index] := value;
end;

{ TFhirTestScriptSetupActionOperation }

constructor TFhirTestScriptSetupActionOperation.Create;
begin
  inherited;
end;

destructor TFhirTestScriptSetupActionOperation.Destroy;
begin
  FType_.free;
  FResource.free;
  FLabel_.free;
  FDescription.free;
  FAccept.free;
  FContentType.free;
  FDestination.free;
  FEncodeRequestUrl.free;
  FMethod.free;
  FOrigin.free;
  FParams.free;
  FRequestHeaderList.Free;
  FRequestId.free;
  FResponseId.free;
  FSourceId.free;
  FTargetId.free;
  FUrl.free;
  inherited;
end;

procedure TFhirTestScriptSetupActionOperation.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirTestScriptSetupActionOperation(oSource).type_.Clone;
  resourceElement := TFhirTestScriptSetupActionOperation(oSource).resourceElement.Clone;
  label_Element := TFhirTestScriptSetupActionOperation(oSource).label_Element.Clone;
  descriptionElement := TFhirTestScriptSetupActionOperation(oSource).descriptionElement.Clone;
  acceptElement := TFhirTestScriptSetupActionOperation(oSource).acceptElement.Clone;
  contentTypeElement := TFhirTestScriptSetupActionOperation(oSource).contentTypeElement.Clone;
  destinationElement := TFhirTestScriptSetupActionOperation(oSource).destinationElement.Clone;
  encodeRequestUrlElement := TFhirTestScriptSetupActionOperation(oSource).encodeRequestUrlElement.Clone;
  methodElement := TFhirTestScriptSetupActionOperation(oSource).methodElement.Clone;
  originElement := TFhirTestScriptSetupActionOperation(oSource).originElement.Clone;
  paramsElement := TFhirTestScriptSetupActionOperation(oSource).paramsElement.Clone;
  if (TFhirTestScriptSetupActionOperation(oSource).FRequestHeaderList = nil) then
  begin
    FRequestHeaderList.free;
    FRequestHeaderList := nil;
  end
  else
  begin
    if FRequestHeaderList = nil then
      FRequestHeaderList := TFhirTestScriptSetupActionOperationRequestHeaderList.Create;
    FRequestHeaderList.Assign(TFhirTestScriptSetupActionOperation(oSource).FRequestHeaderList);
  end;
  requestIdElement := TFhirTestScriptSetupActionOperation(oSource).requestIdElement.Clone;
  responseIdElement := TFhirTestScriptSetupActionOperation(oSource).responseIdElement.Clone;
  sourceIdElement := TFhirTestScriptSetupActionOperation(oSource).sourceIdElement.Clone;
  targetIdElement := TFhirTestScriptSetupActionOperation(oSource).targetIdElement.Clone;
  urlElement := TFhirTestScriptSetupActionOperation(oSource).urlElement.Clone;
end;

procedure TFhirTestScriptSetupActionOperation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'resource') Then
     list.add(self.link, 'resource', FResource.Link);
  if (child_name = 'label') Then
     list.add(self.link, 'label', FLabel_.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'accept') Then
     list.add(self.link, 'accept', FAccept.Link);
  if (child_name = 'contentType') Then
     list.add(self.link, 'contentType', FContentType.Link);
  if (child_name = 'destination') Then
     list.add(self.link, 'destination', FDestination.Link);
  if (child_name = 'encodeRequestUrl') Then
     list.add(self.link, 'encodeRequestUrl', FEncodeRequestUrl.Link);
  if (child_name = 'method') Then
     list.add(self.link, 'method', FMethod.Link);
  if (child_name = 'origin') Then
     list.add(self.link, 'origin', FOrigin.Link);
  if (child_name = 'params') Then
     list.add(self.link, 'params', FParams.Link);
  if (child_name = 'requestHeader') Then
    list.addAll(self, 'requestHeader', FRequestHeaderList);
  if (child_name = 'requestId') Then
     list.add(self.link, 'requestId', FRequestId.Link);
  if (child_name = 'responseId') Then
     list.add(self.link, 'responseId', FResponseId.Link);
  if (child_name = 'sourceId') Then
     list.add(self.link, 'sourceId', FSourceId.Link);
  if (child_name = 'targetId') Then
     list.add(self.link, 'targetId', FTargetId.Link);
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
end;

procedure TFhirTestScriptSetupActionOperation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'Coding', false, TFhirCoding, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'resource', 'code', false, TFhirEnum, FResource.Link));
  oList.add(TFHIRProperty.create(self, 'label', 'string', false, TFhirString, FLabel_.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'accept', 'code', false, TFhirCode, FAccept.Link));
  oList.add(TFHIRProperty.create(self, 'contentType', 'code', false, TFhirCode, FContentType.Link));
  oList.add(TFHIRProperty.create(self, 'destination', 'integer', false, TFhirInteger, FDestination.Link));
  oList.add(TFHIRProperty.create(self, 'encodeRequestUrl', 'boolean', false, TFhirBoolean, FEncodeRequestUrl.Link));
  oList.add(TFHIRProperty.create(self, 'method', 'code', false, TFhirEnum, FMethod.Link));
  oList.add(TFHIRProperty.create(self, 'origin', 'integer', false, TFhirInteger, FOrigin.Link));
  oList.add(TFHIRProperty.create(self, 'params', 'string', false, TFhirString, FParams.Link));
  oList.add(TFHIRProperty.create(self, 'requestHeader', 'BackboneElement', true, TFhirTestScriptSetupActionOperationRequestHeader, FRequestHeaderList.Link));
  oList.add(TFHIRProperty.create(self, 'requestId', 'id', false, TFhirId, FRequestId.Link));
  oList.add(TFHIRProperty.create(self, 'responseId', 'id', false, TFhirId, FResponseId.Link));
  oList.add(TFHIRProperty.create(self, 'sourceId', 'id', false, TFhirId, FSourceId.Link));
  oList.add(TFHIRProperty.create(self, 'targetId', 'id', false, TFhirId, FTargetId.Link));
  oList.add(TFHIRProperty.create(self, 'url', 'string', false, TFhirString, FUrl.Link));
end;

function TFhirTestScriptSetupActionOperation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCoding;
    result := propValue;
  end
  else if (propName = 'resource') then
  begin
    ResourceElement := asEnum(SYSTEMS_TFhirFHIRDefinedTypeEnum, CODES_TFhirFHIRDefinedTypeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'label') then
  begin
    Label_Element := asString(propValue);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'accept') then
  begin
    AcceptElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'contentType') then
  begin
    ContentTypeElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'destination') then
  begin
    DestinationElement := asInteger(propValue);
    result := propValue;
  end
  else if (propName = 'encodeRequestUrl') then
  begin
    EncodeRequestUrlElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'method') then
  begin
    MethodElement := asEnum(SYSTEMS_TFhirTestScriptRequestMethodCodeEnum, CODES_TFhirTestScriptRequestMethodCodeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'origin') then
  begin
    OriginElement := asInteger(propValue);
    result := propValue;
  end
  else if (propName = 'params') then
  begin
    ParamsElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'requestHeader') then
  begin
    RequestHeaderList.add(propValue as TFhirTestScriptSetupActionOperationRequestHeader);
    result := propValue;
  end
  else if (propName = 'requestId') then
  begin
    RequestIdElement := asId(propValue);
    result := propValue;
  end
  else if (propName = 'responseId') then
  begin
    ResponseIdElement := asId(propValue);
    result := propValue;
  end
  else if (propName = 'sourceId') then
  begin
    SourceIdElement := asId(propValue);
    result := propValue;
  end
  else if (propName = 'targetId') then
  begin
    TargetIdElement := asId(propValue);
    result := propValue;
  end
  else if (propName = 'url') then
  begin
    UrlElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestScriptSetupActionOperation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'requestHeader') then RequestHeaderList.insertItem(index, propValue as TFhirTestScriptSetupActionOperationRequestHeader)
  else inherited;
end;

function TFhirTestScriptSetupActionOperation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCoding.create()
  else if (propName = 'resource') then result := TFhirEnum.create(SYSTEMS_TFhirFHIRDefinedTypeEnum[FHIRDefinedTypeNull], CODES_TFhirFHIRDefinedTypeEnum[FHIRDefinedTypeNull]) 
  else if (propName = 'label') then result := TFhirString.create()
  else if (propName = 'description') then result := TFhirString.create()
  else if (propName = 'accept') then result := TFhirCode.create()
  else if (propName = 'contentType') then result := TFhirCode.create()
  else if (propName = 'destination') then result := TFhirInteger.create()
  else if (propName = 'encodeRequestUrl') then result := TFhirBoolean.create()
  else if (propName = 'method') then result := TFhirEnum.create(SYSTEMS_TFhirTestScriptRequestMethodCodeEnum[TestScriptRequestMethodCodeNull], CODES_TFhirTestScriptRequestMethodCodeEnum[TestScriptRequestMethodCodeNull]) 
  else if (propName = 'origin') then result := TFhirInteger.create()
  else if (propName = 'params') then result := TFhirString.create()
  else if (propName = 'requestHeader') then result := RequestHeaderList.new()
  else if (propName = 'requestId') then result := TFhirId.create()
  else if (propName = 'responseId') then result := TFhirId.create()
  else if (propName = 'sourceId') then result := TFhirId.create()
  else if (propName = 'targetId') then result := TFhirId.create()
  else if (propName = 'url') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestScriptSetupActionOperation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'Coding'
  else if (propName = 'resource') then result := 'code'
  else if (propName = 'label') then result := 'string'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'accept') then result := 'code'
  else if (propName = 'contentType') then result := 'code'
  else if (propName = 'destination') then result := 'integer'
  else if (propName = 'encodeRequestUrl') then result := 'boolean'
  else if (propName = 'method') then result := 'code'
  else if (propName = 'origin') then result := 'integer'
  else if (propName = 'params') then result := 'string'
  else if (propName = 'requestHeader') then result := 'BackboneElement'
  else if (propName = 'requestId') then result := 'id'
  else if (propName = 'responseId') then result := 'id'
  else if (propName = 'sourceId') then result := 'id'
  else if (propName = 'targetId') then result := 'id'
  else if (propName = 'url') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestScriptSetupActionOperation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'resource') then ResourceElement := nil
  else if (propName = 'label') then Label_Element := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'accept') then AcceptElement := nil
  else if (propName = 'contentType') then ContentTypeElement := nil
  else if (propName = 'destination') then DestinationElement := nil
  else if (propName = 'encodeRequestUrl') then EncodeRequestUrlElement := nil
  else if (propName = 'method') then MethodElement := nil
  else if (propName = 'origin') then OriginElement := nil
  else if (propName = 'params') then ParamsElement := nil
  else if (propName = 'requestHeader') then deletePropertyValue('requestHeader', RequestHeaderList, value)
  else if (propName = 'requestId') then RequestIdElement := nil
  else if (propName = 'responseId') then ResponseIdElement := nil
  else if (propName = 'sourceId') then SourceIdElement := nil
  else if (propName = 'targetId') then TargetIdElement := nil
  else if (propName = 'url') then UrlElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestScriptSetupActionOperation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCoding
  else if (propName = 'resource') then ResourceElement := asEnum(SYSTEMS_TFhirFHIRDefinedTypeEnum, CODES_TFhirFHIRDefinedTypeEnum, new)
  else if (propName = 'label') then Label_Element := asString(new)
  else if (propName = 'description') then DescriptionElement := asString(new)
  else if (propName = 'accept') then AcceptElement := asCode(new)
  else if (propName = 'contentType') then ContentTypeElement := asCode(new)
  else if (propName = 'destination') then DestinationElement := asInteger(new)
  else if (propName = 'encodeRequestUrl') then EncodeRequestUrlElement := asBoolean(new)
  else if (propName = 'method') then MethodElement := asEnum(SYSTEMS_TFhirTestScriptRequestMethodCodeEnum, CODES_TFhirTestScriptRequestMethodCodeEnum, new)
  else if (propName = 'origin') then OriginElement := asInteger(new)
  else if (propName = 'params') then ParamsElement := asString(new)
  else if (propName = 'requestHeader') then replacePropertyValue('requestHeader', RequestHeaderList, existing, new)
  else if (propName = 'requestId') then RequestIdElement := asId(new)
  else if (propName = 'responseId') then ResponseIdElement := asId(new)
  else if (propName = 'sourceId') then SourceIdElement := asId(new)
  else if (propName = 'targetId') then TargetIdElement := asId(new)
  else if (propName = 'url') then UrlElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestScriptSetupActionOperation.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'requestHeader') then RequestHeaderList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirTestScriptSetupActionOperation.fhirType : string;
begin
  result := 'TestScript.setup.action.operation';
end;

function TFhirTestScriptSetupActionOperation.Link : TFhirTestScriptSetupActionOperation;
begin
  result := TFhirTestScriptSetupActionOperation(inherited Link);
end;

function TFhirTestScriptSetupActionOperation.Clone : TFhirTestScriptSetupActionOperation;
begin
  result := TFhirTestScriptSetupActionOperation(inherited Clone);
end;

function TFhirTestScriptSetupActionOperation.equals(other : TObject) : boolean; 
var
  o : TFhirTestScriptSetupActionOperation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestScriptSetupActionOperation)) then
    result := false
  else
  begin
    o := TFhirTestScriptSetupActionOperation(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(resourceElement, o.resourceElement, true) and 
      compareDeep(label_Element, o.label_Element, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(acceptElement, o.acceptElement, true) and compareDeep(contentTypeElement, o.contentTypeElement, true) and 
      compareDeep(destinationElement, o.destinationElement, true) and compareDeep(encodeRequestUrlElement, o.encodeRequestUrlElement, true) and 
      compareDeep(methodElement, o.methodElement, true) and compareDeep(originElement, o.originElement, true) and 
      compareDeep(paramsElement, o.paramsElement, true) and compareDeep(requestHeaderList, o.requestHeaderList, true) and 
      compareDeep(requestIdElement, o.requestIdElement, true) and compareDeep(responseIdElement, o.responseIdElement, true) and 
      compareDeep(sourceIdElement, o.sourceIdElement, true) and compareDeep(targetIdElement, o.targetIdElement, true) and 
      compareDeep(urlElement, o.urlElement, true);
  end;
end;

function TFhirTestScriptSetupActionOperation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FResource) and isEmptyProp(FLabel_) and isEmptyProp(FDescription) and isEmptyProp(FAccept) and isEmptyProp(FContentType) and isEmptyProp(FDestination) and isEmptyProp(FEncodeRequestUrl) and isEmptyProp(FMethod) and isEmptyProp(FOrigin) and isEmptyProp(FParams) and isEmptyProp(FrequestHeaderList) and isEmptyProp(FRequestId) and isEmptyProp(FResponseId) and isEmptyProp(FSourceId) and isEmptyProp(FTargetId) and isEmptyProp(FUrl);
end;

procedure TFhirTestScriptSetupActionOperation.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('resource');
  fields.add('label');
  fields.add('description');
  fields.add('accept');
  fields.add('contentType');
  fields.add('destination');
  fields.add('encodeRequestUrl');
  fields.add('method');
  fields.add('origin');
  fields.add('params');
  fields.add('requestHeader');
  fields.add('requestId');
  fields.add('responseId');
  fields.add('sourceId');
  fields.add('targetId');
  fields.add('url');
end;

function TFhirTestScriptSetupActionOperation.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FRequestHeaderList.sizeInBytes(magic));
end;

procedure TFhirTestScriptSetupActionOperation.SetType_(value : TFhirCoding);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirTestScriptSetupActionOperation.SetResource(value : TFhirEnum);
begin
  FResource.free;
  FResource := value;
end;

function TFhirTestScriptSetupActionOperation.GetResourceST : TFhirFHIRDefinedTypeEnum;
begin
  if FResource = nil then
    result := TFhirFHIRDefinedTypeEnum(0)
  else
    result := TFhirFHIRDefinedTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirFHIRDefinedTypeEnum, FResource.value));
end;

procedure TFhirTestScriptSetupActionOperation.SetResourceST(value : TFhirFHIRDefinedTypeEnum);
begin
  if ord(value) = 0 then
    ResourceElement := nil
  else
    ResourceElement := TFhirEnum.create(SYSTEMS_TFhirFHIRDefinedTypeEnum[value], CODES_TFhirFHIRDefinedTypeEnum[value]);
end;

procedure TFhirTestScriptSetupActionOperation.SetLabel_(value : TFhirString);
begin
  FLabel_.free;
  FLabel_ := value;
end;

function TFhirTestScriptSetupActionOperation.GetLabel_ST : String;
begin
  if FLabel_ = nil then
    result := ''
  else
    result := FLabel_.value;
end;

procedure TFhirTestScriptSetupActionOperation.SetLabel_ST(value : String);
begin
  if value <> '' then
  begin
    if FLabel_ = nil then
      FLabel_ := TFhirString.create;
    FLabel_.value := value
  end
  else if FLabel_ <> nil then
    FLabel_.value := '';
end;

procedure TFhirTestScriptSetupActionOperation.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirTestScriptSetupActionOperation.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirTestScriptSetupActionOperation.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirTestScriptSetupActionOperation.SetAccept(value : TFhirCode);
begin
  FAccept.free;
  FAccept := value;
end;

function TFhirTestScriptSetupActionOperation.GetAcceptST : String;
begin
  if FAccept = nil then
    result := ''
  else
    result := FAccept.value;
end;

procedure TFhirTestScriptSetupActionOperation.SetAcceptST(value : String);
begin
  if value <> '' then
  begin
    if FAccept = nil then
      FAccept := TFhirCode.create;
    FAccept.value := value
  end
  else if FAccept <> nil then
    FAccept.value := '';
end;

procedure TFhirTestScriptSetupActionOperation.SetContentType(value : TFhirCode);
begin
  FContentType.free;
  FContentType := value;
end;

function TFhirTestScriptSetupActionOperation.GetContentTypeST : String;
begin
  if FContentType = nil then
    result := ''
  else
    result := FContentType.value;
end;

procedure TFhirTestScriptSetupActionOperation.SetContentTypeST(value : String);
begin
  if value <> '' then
  begin
    if FContentType = nil then
      FContentType := TFhirCode.create;
    FContentType.value := value
  end
  else if FContentType <> nil then
    FContentType.value := '';
end;

procedure TFhirTestScriptSetupActionOperation.SetDestination(value : TFhirInteger);
begin
  FDestination.free;
  FDestination := value;
end;

function TFhirTestScriptSetupActionOperation.GetDestinationST : String;
begin
  if FDestination = nil then
    result := ''
  else
    result := FDestination.value;
end;

procedure TFhirTestScriptSetupActionOperation.SetDestinationST(value : String);
begin
  if value <> '' then
  begin
    if FDestination = nil then
      FDestination := TFhirInteger.create;
    FDestination.value := value
  end
  else if FDestination <> nil then
    FDestination.value := '';
end;

procedure TFhirTestScriptSetupActionOperation.SetEncodeRequestUrl(value : TFhirBoolean);
begin
  FEncodeRequestUrl.free;
  FEncodeRequestUrl := value;
end;

function TFhirTestScriptSetupActionOperation.GetEncodeRequestUrlST : Boolean;
begin
  if FEncodeRequestUrl = nil then
    result := false
  else
    result := FEncodeRequestUrl.value;
end;

procedure TFhirTestScriptSetupActionOperation.SetEncodeRequestUrlST(value : Boolean);
begin
  if FEncodeRequestUrl = nil then
    FEncodeRequestUrl := TFhirBoolean.create;
  FEncodeRequestUrl.value := value
end;

procedure TFhirTestScriptSetupActionOperation.SetMethod(value : TFhirEnum);
begin
  FMethod.free;
  FMethod := value;
end;

function TFhirTestScriptSetupActionOperation.GetMethodST : TFhirTestScriptRequestMethodCodeEnum;
begin
  if FMethod = nil then
    result := TFhirTestScriptRequestMethodCodeEnum(0)
  else
    result := TFhirTestScriptRequestMethodCodeEnum(StringArrayIndexOfSensitive(CODES_TFhirTestScriptRequestMethodCodeEnum, FMethod.value));
end;

procedure TFhirTestScriptSetupActionOperation.SetMethodST(value : TFhirTestScriptRequestMethodCodeEnum);
begin
  if ord(value) = 0 then
    MethodElement := nil
  else
    MethodElement := TFhirEnum.create(SYSTEMS_TFhirTestScriptRequestMethodCodeEnum[value], CODES_TFhirTestScriptRequestMethodCodeEnum[value]);
end;

procedure TFhirTestScriptSetupActionOperation.SetOrigin(value : TFhirInteger);
begin
  FOrigin.free;
  FOrigin := value;
end;

function TFhirTestScriptSetupActionOperation.GetOriginST : String;
begin
  if FOrigin = nil then
    result := ''
  else
    result := FOrigin.value;
end;

procedure TFhirTestScriptSetupActionOperation.SetOriginST(value : String);
begin
  if value <> '' then
  begin
    if FOrigin = nil then
      FOrigin := TFhirInteger.create;
    FOrigin.value := value
  end
  else if FOrigin <> nil then
    FOrigin.value := '';
end;

procedure TFhirTestScriptSetupActionOperation.SetParams(value : TFhirString);
begin
  FParams.free;
  FParams := value;
end;

function TFhirTestScriptSetupActionOperation.GetParamsST : String;
begin
  if FParams = nil then
    result := ''
  else
    result := FParams.value;
end;

procedure TFhirTestScriptSetupActionOperation.SetParamsST(value : String);
begin
  if value <> '' then
  begin
    if FParams = nil then
      FParams := TFhirString.create;
    FParams.value := value
  end
  else if FParams <> nil then
    FParams.value := '';
end;

function TFhirTestScriptSetupActionOperation.GetRequestHeaderList : TFhirTestScriptSetupActionOperationRequestHeaderList;
begin
  if FRequestHeaderList = nil then
    FRequestHeaderList := TFhirTestScriptSetupActionOperationRequestHeaderList.Create;
  result := FRequestHeaderList;
end;

function TFhirTestScriptSetupActionOperation.GetHasRequestHeaderList : boolean;
begin
  result := (FRequestHeaderList <> nil) and (FRequestHeaderList.count > 0);
end;

procedure TFhirTestScriptSetupActionOperation.SetRequestId(value : TFhirId);
begin
  FRequestId.free;
  FRequestId := value;
end;

function TFhirTestScriptSetupActionOperation.GetRequestIdST : String;
begin
  if FRequestId = nil then
    result := ''
  else
    result := FRequestId.value;
end;

procedure TFhirTestScriptSetupActionOperation.SetRequestIdST(value : String);
begin
  if value <> '' then
  begin
    if FRequestId = nil then
      FRequestId := TFhirId.create;
    FRequestId.value := value
  end
  else if FRequestId <> nil then
    FRequestId.value := '';
end;

procedure TFhirTestScriptSetupActionOperation.SetResponseId(value : TFhirId);
begin
  FResponseId.free;
  FResponseId := value;
end;

function TFhirTestScriptSetupActionOperation.GetResponseIdST : String;
begin
  if FResponseId = nil then
    result := ''
  else
    result := FResponseId.value;
end;

procedure TFhirTestScriptSetupActionOperation.SetResponseIdST(value : String);
begin
  if value <> '' then
  begin
    if FResponseId = nil then
      FResponseId := TFhirId.create;
    FResponseId.value := value
  end
  else if FResponseId <> nil then
    FResponseId.value := '';
end;

procedure TFhirTestScriptSetupActionOperation.SetSourceId(value : TFhirId);
begin
  FSourceId.free;
  FSourceId := value;
end;

function TFhirTestScriptSetupActionOperation.GetSourceIdST : String;
begin
  if FSourceId = nil then
    result := ''
  else
    result := FSourceId.value;
end;

procedure TFhirTestScriptSetupActionOperation.SetSourceIdST(value : String);
begin
  if value <> '' then
  begin
    if FSourceId = nil then
      FSourceId := TFhirId.create;
    FSourceId.value := value
  end
  else if FSourceId <> nil then
    FSourceId.value := '';
end;

procedure TFhirTestScriptSetupActionOperation.SetTargetId(value : TFhirId);
begin
  FTargetId.free;
  FTargetId := value;
end;

function TFhirTestScriptSetupActionOperation.GetTargetIdST : String;
begin
  if FTargetId = nil then
    result := ''
  else
    result := FTargetId.value;
end;

procedure TFhirTestScriptSetupActionOperation.SetTargetIdST(value : String);
begin
  if value <> '' then
  begin
    if FTargetId = nil then
      FTargetId := TFhirId.create;
    FTargetId.value := value
  end
  else if FTargetId <> nil then
    FTargetId.value := '';
end;

procedure TFhirTestScriptSetupActionOperation.SetUrl(value : TFhirString);
begin
  FUrl.free;
  FUrl := value;
end;

function TFhirTestScriptSetupActionOperation.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

procedure TFhirTestScriptSetupActionOperation.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirString.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

{ TFhirTestScriptSetupActionOperationListEnumerator }

constructor TFhirTestScriptSetupActionOperationListEnumerator.Create(list : TFhirTestScriptSetupActionOperationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestScriptSetupActionOperationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestScriptSetupActionOperationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestScriptSetupActionOperationListEnumerator.GetCurrent : TFhirTestScriptSetupActionOperation;
begin
  Result := FList[FIndex];
end;

function TFhirTestScriptSetupActionOperationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirTestScriptSetupActionOperationList }

function TFhirTestScriptSetupActionOperationList.AddItem(value: TFhirTestScriptSetupActionOperation): TFhirTestScriptSetupActionOperation;
begin
  assert(value.ClassName = 'TFhirTestScriptSetupActionOperation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestScriptSetupActionOperation');
  add(value);
  result := value;
end;

function TFhirTestScriptSetupActionOperationList.Append: TFhirTestScriptSetupActionOperation;
begin
  result := TFhirTestScriptSetupActionOperation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptSetupActionOperationList.ClearItems;
begin
  Clear;
end;

function TFhirTestScriptSetupActionOperationList.GetEnumerator : TFhirTestScriptSetupActionOperationListEnumerator;
begin
  result := TFhirTestScriptSetupActionOperationListEnumerator.Create(self.link);
end;

function TFhirTestScriptSetupActionOperationList.Clone: TFhirTestScriptSetupActionOperationList;
begin
  result := TFhirTestScriptSetupActionOperationList(inherited Clone);
end;

function TFhirTestScriptSetupActionOperationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestScriptSetupActionOperationList.GetItemN(index: Integer): TFhirTestScriptSetupActionOperation;
begin
  result := TFhirTestScriptSetupActionOperation(ObjectByIndex[index]);
end;

function TFhirTestScriptSetupActionOperationList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestScriptSetupActionOperation;
end;
function TFhirTestScriptSetupActionOperationList.IndexOf(value: TFhirTestScriptSetupActionOperation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestScriptSetupActionOperationList.Insert(index: Integer): TFhirTestScriptSetupActionOperation;
begin
  result := TFhirTestScriptSetupActionOperation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptSetupActionOperationList.InsertItem(index: Integer; value: TFhirTestScriptSetupActionOperation);
begin
  assert(value is TFhirTestScriptSetupActionOperation);
  Inherited Insert(index, value);
end;

function TFhirTestScriptSetupActionOperationList.Item(index: Integer): TFhirTestScriptSetupActionOperation;
begin
  result := TFhirTestScriptSetupActionOperation(ObjectByIndex[index]);
end;

function TFhirTestScriptSetupActionOperationList.Link: TFhirTestScriptSetupActionOperationList;
begin
  result := TFhirTestScriptSetupActionOperationList(inherited Link);
end;

procedure TFhirTestScriptSetupActionOperationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestScriptSetupActionOperationList.SetItemByIndex(index: Integer; value: TFhirTestScriptSetupActionOperation);
begin
  assert(value is TFhirTestScriptSetupActionOperation);
  FhirTestScriptSetupActionOperations[index] := value;
end;

procedure TFhirTestScriptSetupActionOperationList.SetItemN(index: Integer; value: TFhirTestScriptSetupActionOperation);
begin
  assert(value is TFhirTestScriptSetupActionOperation);
  ObjectByIndex[index] := value;
end;

{ TFhirTestScriptSetupActionOperationRequestHeader }

constructor TFhirTestScriptSetupActionOperationRequestHeader.Create;
begin
  inherited;
end;

destructor TFhirTestScriptSetupActionOperationRequestHeader.Destroy;
begin
  FField.free;
  FValue.free;
  inherited;
end;

procedure TFhirTestScriptSetupActionOperationRequestHeader.Assign(oSource : TFslObject);
begin
  inherited;
  fieldElement := TFhirTestScriptSetupActionOperationRequestHeader(oSource).fieldElement.Clone;
  valueElement := TFhirTestScriptSetupActionOperationRequestHeader(oSource).valueElement.Clone;
end;

procedure TFhirTestScriptSetupActionOperationRequestHeader.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'field') Then
     list.add(self.link, 'field', FField.Link);
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
end;

procedure TFhirTestScriptSetupActionOperationRequestHeader.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'field', 'string', false, TFhirString, FField.Link));
  oList.add(TFHIRProperty.create(self, 'value', 'string', false, TFhirString, FValue.Link));
end;

function TFhirTestScriptSetupActionOperationRequestHeader.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'field') then
  begin
    FieldElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'value') then
  begin
    ValueElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestScriptSetupActionOperationRequestHeader.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirTestScriptSetupActionOperationRequestHeader.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'field') then result := TFhirString.create()
  else if (propName = 'value') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestScriptSetupActionOperationRequestHeader.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'field') then result := 'string'
  else if (propName = 'value') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestScriptSetupActionOperationRequestHeader.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'field') then FieldElement := nil
  else if (propName = 'value') then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestScriptSetupActionOperationRequestHeader.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'field') then FieldElement := asString(new)
  else if (propName = 'value') then ValueElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestScriptSetupActionOperationRequestHeader.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirTestScriptSetupActionOperationRequestHeader.fhirType : string;
begin
  result := 'TestScript.setup.action.operation.requestHeader';
end;

function TFhirTestScriptSetupActionOperationRequestHeader.Link : TFhirTestScriptSetupActionOperationRequestHeader;
begin
  result := TFhirTestScriptSetupActionOperationRequestHeader(inherited Link);
end;

function TFhirTestScriptSetupActionOperationRequestHeader.Clone : TFhirTestScriptSetupActionOperationRequestHeader;
begin
  result := TFhirTestScriptSetupActionOperationRequestHeader(inherited Clone);
end;

function TFhirTestScriptSetupActionOperationRequestHeader.equals(other : TObject) : boolean; 
var
  o : TFhirTestScriptSetupActionOperationRequestHeader;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestScriptSetupActionOperationRequestHeader)) then
    result := false
  else
  begin
    o := TFhirTestScriptSetupActionOperationRequestHeader(other);
    result := compareDeep(fieldElement, o.fieldElement, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirTestScriptSetupActionOperationRequestHeader.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FField) and isEmptyProp(FValue);
end;

procedure TFhirTestScriptSetupActionOperationRequestHeader.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('field');
  fields.add('value');
end;

function TFhirTestScriptSetupActionOperationRequestHeader.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirTestScriptSetupActionOperationRequestHeader.SetField(value : TFhirString);
begin
  FField.free;
  FField := value;
end;

function TFhirTestScriptSetupActionOperationRequestHeader.GetFieldST : String;
begin
  if FField = nil then
    result := ''
  else
    result := FField.value;
end;

procedure TFhirTestScriptSetupActionOperationRequestHeader.SetFieldST(value : String);
begin
  if value <> '' then
  begin
    if FField = nil then
      FField := TFhirString.create;
    FField.value := value
  end
  else if FField <> nil then
    FField.value := '';
end;

procedure TFhirTestScriptSetupActionOperationRequestHeader.SetValue(value : TFhirString);
begin
  FValue.free;
  FValue := value;
end;

function TFhirTestScriptSetupActionOperationRequestHeader.GetValueST : String;
begin
  if FValue = nil then
    result := ''
  else
    result := FValue.value;
end;

procedure TFhirTestScriptSetupActionOperationRequestHeader.SetValueST(value : String);
begin
  if value <> '' then
  begin
    if FValue = nil then
      FValue := TFhirString.create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := '';
end;

{ TFhirTestScriptSetupActionOperationRequestHeaderListEnumerator }

constructor TFhirTestScriptSetupActionOperationRequestHeaderListEnumerator.Create(list : TFhirTestScriptSetupActionOperationRequestHeaderList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestScriptSetupActionOperationRequestHeaderListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestScriptSetupActionOperationRequestHeaderListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestScriptSetupActionOperationRequestHeaderListEnumerator.GetCurrent : TFhirTestScriptSetupActionOperationRequestHeader;
begin
  Result := FList[FIndex];
end;

function TFhirTestScriptSetupActionOperationRequestHeaderListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirTestScriptSetupActionOperationRequestHeaderList }

function TFhirTestScriptSetupActionOperationRequestHeaderList.AddItem(value: TFhirTestScriptSetupActionOperationRequestHeader): TFhirTestScriptSetupActionOperationRequestHeader;
begin
  assert(value.ClassName = 'TFhirTestScriptSetupActionOperationRequestHeader', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestScriptSetupActionOperationRequestHeader');
  add(value);
  result := value;
end;

function TFhirTestScriptSetupActionOperationRequestHeaderList.Append: TFhirTestScriptSetupActionOperationRequestHeader;
begin
  result := TFhirTestScriptSetupActionOperationRequestHeader.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptSetupActionOperationRequestHeaderList.ClearItems;
begin
  Clear;
end;

function TFhirTestScriptSetupActionOperationRequestHeaderList.GetEnumerator : TFhirTestScriptSetupActionOperationRequestHeaderListEnumerator;
begin
  result := TFhirTestScriptSetupActionOperationRequestHeaderListEnumerator.Create(self.link);
end;

function TFhirTestScriptSetupActionOperationRequestHeaderList.Clone: TFhirTestScriptSetupActionOperationRequestHeaderList;
begin
  result := TFhirTestScriptSetupActionOperationRequestHeaderList(inherited Clone);
end;

function TFhirTestScriptSetupActionOperationRequestHeaderList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestScriptSetupActionOperationRequestHeaderList.GetItemN(index: Integer): TFhirTestScriptSetupActionOperationRequestHeader;
begin
  result := TFhirTestScriptSetupActionOperationRequestHeader(ObjectByIndex[index]);
end;

function TFhirTestScriptSetupActionOperationRequestHeaderList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestScriptSetupActionOperationRequestHeader;
end;
function TFhirTestScriptSetupActionOperationRequestHeaderList.IndexOf(value: TFhirTestScriptSetupActionOperationRequestHeader): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestScriptSetupActionOperationRequestHeaderList.Insert(index: Integer): TFhirTestScriptSetupActionOperationRequestHeader;
begin
  result := TFhirTestScriptSetupActionOperationRequestHeader.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptSetupActionOperationRequestHeaderList.InsertItem(index: Integer; value: TFhirTestScriptSetupActionOperationRequestHeader);
begin
  assert(value is TFhirTestScriptSetupActionOperationRequestHeader);
  Inherited Insert(index, value);
end;

function TFhirTestScriptSetupActionOperationRequestHeaderList.Item(index: Integer): TFhirTestScriptSetupActionOperationRequestHeader;
begin
  result := TFhirTestScriptSetupActionOperationRequestHeader(ObjectByIndex[index]);
end;

function TFhirTestScriptSetupActionOperationRequestHeaderList.Link: TFhirTestScriptSetupActionOperationRequestHeaderList;
begin
  result := TFhirTestScriptSetupActionOperationRequestHeaderList(inherited Link);
end;

procedure TFhirTestScriptSetupActionOperationRequestHeaderList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestScriptSetupActionOperationRequestHeaderList.SetItemByIndex(index: Integer; value: TFhirTestScriptSetupActionOperationRequestHeader);
begin
  assert(value is TFhirTestScriptSetupActionOperationRequestHeader);
  FhirTestScriptSetupActionOperationRequestHeaders[index] := value;
end;

procedure TFhirTestScriptSetupActionOperationRequestHeaderList.SetItemN(index: Integer; value: TFhirTestScriptSetupActionOperationRequestHeader);
begin
  assert(value is TFhirTestScriptSetupActionOperationRequestHeader);
  ObjectByIndex[index] := value;
end;

{ TFhirTestScriptSetupActionAssert }

constructor TFhirTestScriptSetupActionAssert.Create;
begin
  inherited;
end;

destructor TFhirTestScriptSetupActionAssert.Destroy;
begin
  FLabel_.free;
  FDescription.free;
  FDirection.free;
  FCompareToSourceId.free;
  FCompareToSourceExpression.free;
  FCompareToSourcePath.free;
  FContentType.free;
  FExpression.free;
  FHeaderField.free;
  FMinimumId.free;
  FNavigationLinks.free;
  FOperator.free;
  FPath.free;
  FRequestMethod.free;
  FRequestURL.free;
  FResource.free;
  FResponse.free;
  FResponseCode.free;
  FSourceId.free;
  FValidateProfileId.free;
  FValue.free;
  FWarningOnly.free;
  inherited;
end;

procedure TFhirTestScriptSetupActionAssert.Assign(oSource : TFslObject);
begin
  inherited;
  label_Element := TFhirTestScriptSetupActionAssert(oSource).label_Element.Clone;
  descriptionElement := TFhirTestScriptSetupActionAssert(oSource).descriptionElement.Clone;
  directionElement := TFhirTestScriptSetupActionAssert(oSource).directionElement.Clone;
  compareToSourceIdElement := TFhirTestScriptSetupActionAssert(oSource).compareToSourceIdElement.Clone;
  compareToSourceExpressionElement := TFhirTestScriptSetupActionAssert(oSource).compareToSourceExpressionElement.Clone;
  compareToSourcePathElement := TFhirTestScriptSetupActionAssert(oSource).compareToSourcePathElement.Clone;
  contentTypeElement := TFhirTestScriptSetupActionAssert(oSource).contentTypeElement.Clone;
  expressionElement := TFhirTestScriptSetupActionAssert(oSource).expressionElement.Clone;
  headerFieldElement := TFhirTestScriptSetupActionAssert(oSource).headerFieldElement.Clone;
  minimumIdElement := TFhirTestScriptSetupActionAssert(oSource).minimumIdElement.Clone;
  navigationLinksElement := TFhirTestScriptSetupActionAssert(oSource).navigationLinksElement.Clone;
  operatorElement := TFhirTestScriptSetupActionAssert(oSource).operatorElement.Clone;
  pathElement := TFhirTestScriptSetupActionAssert(oSource).pathElement.Clone;
  requestMethodElement := TFhirTestScriptSetupActionAssert(oSource).requestMethodElement.Clone;
  requestURLElement := TFhirTestScriptSetupActionAssert(oSource).requestURLElement.Clone;
  resourceElement := TFhirTestScriptSetupActionAssert(oSource).resourceElement.Clone;
  responseElement := TFhirTestScriptSetupActionAssert(oSource).responseElement.Clone;
  responseCodeElement := TFhirTestScriptSetupActionAssert(oSource).responseCodeElement.Clone;
  sourceIdElement := TFhirTestScriptSetupActionAssert(oSource).sourceIdElement.Clone;
  validateProfileIdElement := TFhirTestScriptSetupActionAssert(oSource).validateProfileIdElement.Clone;
  valueElement := TFhirTestScriptSetupActionAssert(oSource).valueElement.Clone;
  warningOnlyElement := TFhirTestScriptSetupActionAssert(oSource).warningOnlyElement.Clone;
end;

procedure TFhirTestScriptSetupActionAssert.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'label') Then
     list.add(self.link, 'label', FLabel_.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'direction') Then
     list.add(self.link, 'direction', FDirection.Link);
  if (child_name = 'compareToSourceId') Then
     list.add(self.link, 'compareToSourceId', FCompareToSourceId.Link);
  if (child_name = 'compareToSourceExpression') Then
     list.add(self.link, 'compareToSourceExpression', FCompareToSourceExpression.Link);
  if (child_name = 'compareToSourcePath') Then
     list.add(self.link, 'compareToSourcePath', FCompareToSourcePath.Link);
  if (child_name = 'contentType') Then
     list.add(self.link, 'contentType', FContentType.Link);
  if (child_name = 'expression') Then
     list.add(self.link, 'expression', FExpression.Link);
  if (child_name = 'headerField') Then
     list.add(self.link, 'headerField', FHeaderField.Link);
  if (child_name = 'minimumId') Then
     list.add(self.link, 'minimumId', FMinimumId.Link);
  if (child_name = 'navigationLinks') Then
     list.add(self.link, 'navigationLinks', FNavigationLinks.Link);
  if (child_name = 'operator') Then
     list.add(self.link, 'operator', FOperator.Link);
  if (child_name = 'path') Then
     list.add(self.link, 'path', FPath.Link);
  if (child_name = 'requestMethod') Then
     list.add(self.link, 'requestMethod', FRequestMethod.Link);
  if (child_name = 'requestURL') Then
     list.add(self.link, 'requestURL', FRequestURL.Link);
  if (child_name = 'resource') Then
     list.add(self.link, 'resource', FResource.Link);
  if (child_name = 'response') Then
     list.add(self.link, 'response', FResponse.Link);
  if (child_name = 'responseCode') Then
     list.add(self.link, 'responseCode', FResponseCode.Link);
  if (child_name = 'sourceId') Then
     list.add(self.link, 'sourceId', FSourceId.Link);
  if (child_name = 'validateProfileId') Then
     list.add(self.link, 'validateProfileId', FValidateProfileId.Link);
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
  if (child_name = 'warningOnly') Then
     list.add(self.link, 'warningOnly', FWarningOnly.Link);
end;

procedure TFhirTestScriptSetupActionAssert.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'label', 'string', false, TFhirString, FLabel_.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'direction', 'code', false, TFhirEnum, FDirection.Link));
  oList.add(TFHIRProperty.create(self, 'compareToSourceId', 'string', false, TFhirString, FCompareToSourceId.Link));
  oList.add(TFHIRProperty.create(self, 'compareToSourceExpression', 'string', false, TFhirString, FCompareToSourceExpression.Link));
  oList.add(TFHIRProperty.create(self, 'compareToSourcePath', 'string', false, TFhirString, FCompareToSourcePath.Link));
  oList.add(TFHIRProperty.create(self, 'contentType', 'code', false, TFhirCode, FContentType.Link));
  oList.add(TFHIRProperty.create(self, 'expression', 'string', false, TFhirString, FExpression.Link));
  oList.add(TFHIRProperty.create(self, 'headerField', 'string', false, TFhirString, FHeaderField.Link));
  oList.add(TFHIRProperty.create(self, 'minimumId', 'string', false, TFhirString, FMinimumId.Link));
  oList.add(TFHIRProperty.create(self, 'navigationLinks', 'boolean', false, TFhirBoolean, FNavigationLinks.Link));
  oList.add(TFHIRProperty.create(self, 'operator', 'code', false, TFhirEnum, FOperator.Link));
  oList.add(TFHIRProperty.create(self, 'path', 'string', false, TFhirString, FPath.Link));
  oList.add(TFHIRProperty.create(self, 'requestMethod', 'code', false, TFhirEnum, FRequestMethod.Link));
  oList.add(TFHIRProperty.create(self, 'requestURL', 'string', false, TFhirString, FRequestURL.Link));
  oList.add(TFHIRProperty.create(self, 'resource', 'code', false, TFhirEnum, FResource.Link));
  oList.add(TFHIRProperty.create(self, 'response', 'code', false, TFhirEnum, FResponse.Link));
  oList.add(TFHIRProperty.create(self, 'responseCode', 'string', false, TFhirString, FResponseCode.Link));
  oList.add(TFHIRProperty.create(self, 'sourceId', 'id', false, TFhirId, FSourceId.Link));
  oList.add(TFHIRProperty.create(self, 'validateProfileId', 'id', false, TFhirId, FValidateProfileId.Link));
  oList.add(TFHIRProperty.create(self, 'value', 'string', false, TFhirString, FValue.Link));
  oList.add(TFHIRProperty.create(self, 'warningOnly', 'boolean', false, TFhirBoolean, FWarningOnly.Link));
end;

function TFhirTestScriptSetupActionAssert.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'label') then
  begin
    Label_Element := asString(propValue);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'direction') then
  begin
    DirectionElement := asEnum(SYSTEMS_TFhirAssertionDirectionTypeEnum, CODES_TFhirAssertionDirectionTypeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'compareToSourceId') then
  begin
    CompareToSourceIdElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'compareToSourceExpression') then
  begin
    CompareToSourceExpressionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'compareToSourcePath') then
  begin
    CompareToSourcePathElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'contentType') then
  begin
    ContentTypeElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'expression') then
  begin
    ExpressionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'headerField') then
  begin
    HeaderFieldElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'minimumId') then
  begin
    MinimumIdElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'navigationLinks') then
  begin
    NavigationLinksElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'operator') then
  begin
    OperatorElement := asEnum(SYSTEMS_TFhirAssertionOperatorTypeEnum, CODES_TFhirAssertionOperatorTypeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'path') then
  begin
    PathElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'requestMethod') then
  begin
    RequestMethodElement := asEnum(SYSTEMS_TFhirTestScriptRequestMethodCodeEnum, CODES_TFhirTestScriptRequestMethodCodeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'requestURL') then
  begin
    RequestURLElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'resource') then
  begin
    ResourceElement := asEnum(SYSTEMS_TFhirFHIRDefinedTypeEnum, CODES_TFhirFHIRDefinedTypeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'response') then
  begin
    ResponseElement := asEnum(SYSTEMS_TFhirAssertionResponseTypesEnum, CODES_TFhirAssertionResponseTypesEnum, propValue);
    result := propValue;
  end
  else if (propName = 'responseCode') then
  begin
    ResponseCodeElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'sourceId') then
  begin
    SourceIdElement := asId(propValue);
    result := propValue;
  end
  else if (propName = 'validateProfileId') then
  begin
    ValidateProfileIdElement := asId(propValue);
    result := propValue;
  end
  else if (propName = 'value') then
  begin
    ValueElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'warningOnly') then
  begin
    WarningOnlyElement := asBoolean(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestScriptSetupActionAssert.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirTestScriptSetupActionAssert.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'label') then result := TFhirString.create()
  else if (propName = 'description') then result := TFhirString.create()
  else if (propName = 'direction') then result := TFhirEnum.create(SYSTEMS_TFhirAssertionDirectionTypeEnum[AssertionDirectionTypeNull], CODES_TFhirAssertionDirectionTypeEnum[AssertionDirectionTypeNull]) 
  else if (propName = 'compareToSourceId') then result := TFhirString.create()
  else if (propName = 'compareToSourceExpression') then result := TFhirString.create()
  else if (propName = 'compareToSourcePath') then result := TFhirString.create()
  else if (propName = 'contentType') then result := TFhirCode.create()
  else if (propName = 'expression') then result := TFhirString.create()
  else if (propName = 'headerField') then result := TFhirString.create()
  else if (propName = 'minimumId') then result := TFhirString.create()
  else if (propName = 'navigationLinks') then result := TFhirBoolean.create()
  else if (propName = 'operator') then result := TFhirEnum.create(SYSTEMS_TFhirAssertionOperatorTypeEnum[AssertionOperatorTypeNull], CODES_TFhirAssertionOperatorTypeEnum[AssertionOperatorTypeNull]) 
  else if (propName = 'path') then result := TFhirString.create()
  else if (propName = 'requestMethod') then result := TFhirEnum.create(SYSTEMS_TFhirTestScriptRequestMethodCodeEnum[TestScriptRequestMethodCodeNull], CODES_TFhirTestScriptRequestMethodCodeEnum[TestScriptRequestMethodCodeNull]) 
  else if (propName = 'requestURL') then result := TFhirString.create()
  else if (propName = 'resource') then result := TFhirEnum.create(SYSTEMS_TFhirFHIRDefinedTypeEnum[FHIRDefinedTypeNull], CODES_TFhirFHIRDefinedTypeEnum[FHIRDefinedTypeNull]) 
  else if (propName = 'response') then result := TFhirEnum.create(SYSTEMS_TFhirAssertionResponseTypesEnum[AssertionResponseTypesNull], CODES_TFhirAssertionResponseTypesEnum[AssertionResponseTypesNull]) 
  else if (propName = 'responseCode') then result := TFhirString.create()
  else if (propName = 'sourceId') then result := TFhirId.create()
  else if (propName = 'validateProfileId') then result := TFhirId.create()
  else if (propName = 'value') then result := TFhirString.create()
  else if (propName = 'warningOnly') then result := TFhirBoolean.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestScriptSetupActionAssert.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'label') then result := 'string'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'direction') then result := 'code'
  else if (propName = 'compareToSourceId') then result := 'string'
  else if (propName = 'compareToSourceExpression') then result := 'string'
  else if (propName = 'compareToSourcePath') then result := 'string'
  else if (propName = 'contentType') then result := 'code'
  else if (propName = 'expression') then result := 'string'
  else if (propName = 'headerField') then result := 'string'
  else if (propName = 'minimumId') then result := 'string'
  else if (propName = 'navigationLinks') then result := 'boolean'
  else if (propName = 'operator') then result := 'code'
  else if (propName = 'path') then result := 'string'
  else if (propName = 'requestMethod') then result := 'code'
  else if (propName = 'requestURL') then result := 'string'
  else if (propName = 'resource') then result := 'code'
  else if (propName = 'response') then result := 'code'
  else if (propName = 'responseCode') then result := 'string'
  else if (propName = 'sourceId') then result := 'id'
  else if (propName = 'validateProfileId') then result := 'id'
  else if (propName = 'value') then result := 'string'
  else if (propName = 'warningOnly') then result := 'boolean'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestScriptSetupActionAssert.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'label') then Label_Element := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'direction') then DirectionElement := nil
  else if (propName = 'compareToSourceId') then CompareToSourceIdElement := nil
  else if (propName = 'compareToSourceExpression') then CompareToSourceExpressionElement := nil
  else if (propName = 'compareToSourcePath') then CompareToSourcePathElement := nil
  else if (propName = 'contentType') then ContentTypeElement := nil
  else if (propName = 'expression') then ExpressionElement := nil
  else if (propName = 'headerField') then HeaderFieldElement := nil
  else if (propName = 'minimumId') then MinimumIdElement := nil
  else if (propName = 'navigationLinks') then NavigationLinksElement := nil
  else if (propName = 'operator') then OperatorElement := nil
  else if (propName = 'path') then PathElement := nil
  else if (propName = 'requestMethod') then RequestMethodElement := nil
  else if (propName = 'requestURL') then RequestURLElement := nil
  else if (propName = 'resource') then ResourceElement := nil
  else if (propName = 'response') then ResponseElement := nil
  else if (propName = 'responseCode') then ResponseCodeElement := nil
  else if (propName = 'sourceId') then SourceIdElement := nil
  else if (propName = 'validateProfileId') then ValidateProfileIdElement := nil
  else if (propName = 'value') then ValueElement := nil
  else if (propName = 'warningOnly') then WarningOnlyElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestScriptSetupActionAssert.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'label') then Label_Element := asString(new)
  else if (propName = 'description') then DescriptionElement := asString(new)
  else if (propName = 'direction') then DirectionElement := asEnum(SYSTEMS_TFhirAssertionDirectionTypeEnum, CODES_TFhirAssertionDirectionTypeEnum, new)
  else if (propName = 'compareToSourceId') then CompareToSourceIdElement := asString(new)
  else if (propName = 'compareToSourceExpression') then CompareToSourceExpressionElement := asString(new)
  else if (propName = 'compareToSourcePath') then CompareToSourcePathElement := asString(new)
  else if (propName = 'contentType') then ContentTypeElement := asCode(new)
  else if (propName = 'expression') then ExpressionElement := asString(new)
  else if (propName = 'headerField') then HeaderFieldElement := asString(new)
  else if (propName = 'minimumId') then MinimumIdElement := asString(new)
  else if (propName = 'navigationLinks') then NavigationLinksElement := asBoolean(new)
  else if (propName = 'operator') then OperatorElement := asEnum(SYSTEMS_TFhirAssertionOperatorTypeEnum, CODES_TFhirAssertionOperatorTypeEnum, new)
  else if (propName = 'path') then PathElement := asString(new)
  else if (propName = 'requestMethod') then RequestMethodElement := asEnum(SYSTEMS_TFhirTestScriptRequestMethodCodeEnum, CODES_TFhirTestScriptRequestMethodCodeEnum, new)
  else if (propName = 'requestURL') then RequestURLElement := asString(new)
  else if (propName = 'resource') then ResourceElement := asEnum(SYSTEMS_TFhirFHIRDefinedTypeEnum, CODES_TFhirFHIRDefinedTypeEnum, new)
  else if (propName = 'response') then ResponseElement := asEnum(SYSTEMS_TFhirAssertionResponseTypesEnum, CODES_TFhirAssertionResponseTypesEnum, new)
  else if (propName = 'responseCode') then ResponseCodeElement := asString(new)
  else if (propName = 'sourceId') then SourceIdElement := asId(new)
  else if (propName = 'validateProfileId') then ValidateProfileIdElement := asId(new)
  else if (propName = 'value') then ValueElement := asString(new)
  else if (propName = 'warningOnly') then WarningOnlyElement := asBoolean(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestScriptSetupActionAssert.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirTestScriptSetupActionAssert.fhirType : string;
begin
  result := 'TestScript.setup.action.assert';
end;

function TFhirTestScriptSetupActionAssert.Link : TFhirTestScriptSetupActionAssert;
begin
  result := TFhirTestScriptSetupActionAssert(inherited Link);
end;

function TFhirTestScriptSetupActionAssert.Clone : TFhirTestScriptSetupActionAssert;
begin
  result := TFhirTestScriptSetupActionAssert(inherited Clone);
end;

function TFhirTestScriptSetupActionAssert.equals(other : TObject) : boolean; 
var
  o : TFhirTestScriptSetupActionAssert;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestScriptSetupActionAssert)) then
    result := false
  else
  begin
    o := TFhirTestScriptSetupActionAssert(other);
    result := compareDeep(label_Element, o.label_Element, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(directionElement, o.directionElement, true) and compareDeep(compareToSourceIdElement, o.compareToSourceIdElement, true) and 
      compareDeep(compareToSourceExpressionElement, o.compareToSourceExpressionElement, true) and 
      compareDeep(compareToSourcePathElement, o.compareToSourcePathElement, true) and 
      compareDeep(contentTypeElement, o.contentTypeElement, true) and compareDeep(expressionElement, o.expressionElement, true) and 
      compareDeep(headerFieldElement, o.headerFieldElement, true) and compareDeep(minimumIdElement, o.minimumIdElement, true) and 
      compareDeep(navigationLinksElement, o.navigationLinksElement, true) and compareDeep(operatorElement, o.operatorElement, true) and 
      compareDeep(pathElement, o.pathElement, true) and compareDeep(requestMethodElement, o.requestMethodElement, true) and 
      compareDeep(requestURLElement, o.requestURLElement, true) and compareDeep(resourceElement, o.resourceElement, true) and 
      compareDeep(responseElement, o.responseElement, true) and compareDeep(responseCodeElement, o.responseCodeElement, true) and 
      compareDeep(sourceIdElement, o.sourceIdElement, true) and compareDeep(validateProfileIdElement, o.validateProfileIdElement, true) and 
      compareDeep(valueElement, o.valueElement, true) and compareDeep(warningOnlyElement, o.warningOnlyElement, true);
  end;
end;

function TFhirTestScriptSetupActionAssert.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FLabel_) and isEmptyProp(FDescription) and isEmptyProp(FDirection) and isEmptyProp(FCompareToSourceId) and isEmptyProp(FCompareToSourceExpression) and isEmptyProp(FCompareToSourcePath) and isEmptyProp(FContentType) and isEmptyProp(FExpression) and isEmptyProp(FHeaderField) and isEmptyProp(FMinimumId) and isEmptyProp(FNavigationLinks) and isEmptyProp(FOperator) and isEmptyProp(FPath) and isEmptyProp(FRequestMethod) and isEmptyProp(FRequestURL) and isEmptyProp(FResource) and isEmptyProp(FResponse) and isEmptyProp(FResponseCode) and isEmptyProp(FSourceId) and isEmptyProp(FValidateProfileId) and isEmptyProp(FValue) and isEmptyProp(FWarningOnly);
end;

procedure TFhirTestScriptSetupActionAssert.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('label');
  fields.add('description');
  fields.add('direction');
  fields.add('compareToSourceId');
  fields.add('compareToSourceExpression');
  fields.add('compareToSourcePath');
  fields.add('contentType');
  fields.add('expression');
  fields.add('headerField');
  fields.add('minimumId');
  fields.add('navigationLinks');
  fields.add('operator');
  fields.add('path');
  fields.add('requestMethod');
  fields.add('requestURL');
  fields.add('resource');
  fields.add('response');
  fields.add('responseCode');
  fields.add('sourceId');
  fields.add('validateProfileId');
  fields.add('value');
  fields.add('warningOnly');
end;

function TFhirTestScriptSetupActionAssert.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirTestScriptSetupActionAssert.SetLabel_(value : TFhirString);
begin
  FLabel_.free;
  FLabel_ := value;
end;

function TFhirTestScriptSetupActionAssert.GetLabel_ST : String;
begin
  if FLabel_ = nil then
    result := ''
  else
    result := FLabel_.value;
end;

procedure TFhirTestScriptSetupActionAssert.SetLabel_ST(value : String);
begin
  if value <> '' then
  begin
    if FLabel_ = nil then
      FLabel_ := TFhirString.create;
    FLabel_.value := value
  end
  else if FLabel_ <> nil then
    FLabel_.value := '';
end;

procedure TFhirTestScriptSetupActionAssert.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirTestScriptSetupActionAssert.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirTestScriptSetupActionAssert.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirTestScriptSetupActionAssert.SetDirection(value : TFhirEnum);
begin
  FDirection.free;
  FDirection := value;
end;

function TFhirTestScriptSetupActionAssert.GetDirectionST : TFhirAssertionDirectionTypeEnum;
begin
  if FDirection = nil then
    result := TFhirAssertionDirectionTypeEnum(0)
  else
    result := TFhirAssertionDirectionTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirAssertionDirectionTypeEnum, FDirection.value));
end;

procedure TFhirTestScriptSetupActionAssert.SetDirectionST(value : TFhirAssertionDirectionTypeEnum);
begin
  if ord(value) = 0 then
    DirectionElement := nil
  else
    DirectionElement := TFhirEnum.create(SYSTEMS_TFhirAssertionDirectionTypeEnum[value], CODES_TFhirAssertionDirectionTypeEnum[value]);
end;

procedure TFhirTestScriptSetupActionAssert.SetCompareToSourceId(value : TFhirString);
begin
  FCompareToSourceId.free;
  FCompareToSourceId := value;
end;

function TFhirTestScriptSetupActionAssert.GetCompareToSourceIdST : String;
begin
  if FCompareToSourceId = nil then
    result := ''
  else
    result := FCompareToSourceId.value;
end;

procedure TFhirTestScriptSetupActionAssert.SetCompareToSourceIdST(value : String);
begin
  if value <> '' then
  begin
    if FCompareToSourceId = nil then
      FCompareToSourceId := TFhirString.create;
    FCompareToSourceId.value := value
  end
  else if FCompareToSourceId <> nil then
    FCompareToSourceId.value := '';
end;

procedure TFhirTestScriptSetupActionAssert.SetCompareToSourceExpression(value : TFhirString);
begin
  FCompareToSourceExpression.free;
  FCompareToSourceExpression := value;
end;

function TFhirTestScriptSetupActionAssert.GetCompareToSourceExpressionST : String;
begin
  if FCompareToSourceExpression = nil then
    result := ''
  else
    result := FCompareToSourceExpression.value;
end;

procedure TFhirTestScriptSetupActionAssert.SetCompareToSourceExpressionST(value : String);
begin
  if value <> '' then
  begin
    if FCompareToSourceExpression = nil then
      FCompareToSourceExpression := TFhirString.create;
    FCompareToSourceExpression.value := value
  end
  else if FCompareToSourceExpression <> nil then
    FCompareToSourceExpression.value := '';
end;

procedure TFhirTestScriptSetupActionAssert.SetCompareToSourcePath(value : TFhirString);
begin
  FCompareToSourcePath.free;
  FCompareToSourcePath := value;
end;

function TFhirTestScriptSetupActionAssert.GetCompareToSourcePathST : String;
begin
  if FCompareToSourcePath = nil then
    result := ''
  else
    result := FCompareToSourcePath.value;
end;

procedure TFhirTestScriptSetupActionAssert.SetCompareToSourcePathST(value : String);
begin
  if value <> '' then
  begin
    if FCompareToSourcePath = nil then
      FCompareToSourcePath := TFhirString.create;
    FCompareToSourcePath.value := value
  end
  else if FCompareToSourcePath <> nil then
    FCompareToSourcePath.value := '';
end;

procedure TFhirTestScriptSetupActionAssert.SetContentType(value : TFhirCode);
begin
  FContentType.free;
  FContentType := value;
end;

function TFhirTestScriptSetupActionAssert.GetContentTypeST : String;
begin
  if FContentType = nil then
    result := ''
  else
    result := FContentType.value;
end;

procedure TFhirTestScriptSetupActionAssert.SetContentTypeST(value : String);
begin
  if value <> '' then
  begin
    if FContentType = nil then
      FContentType := TFhirCode.create;
    FContentType.value := value
  end
  else if FContentType <> nil then
    FContentType.value := '';
end;

procedure TFhirTestScriptSetupActionAssert.SetExpression(value : TFhirString);
begin
  FExpression.free;
  FExpression := value;
end;

function TFhirTestScriptSetupActionAssert.GetExpressionST : String;
begin
  if FExpression = nil then
    result := ''
  else
    result := FExpression.value;
end;

procedure TFhirTestScriptSetupActionAssert.SetExpressionST(value : String);
begin
  if value <> '' then
  begin
    if FExpression = nil then
      FExpression := TFhirString.create;
    FExpression.value := value
  end
  else if FExpression <> nil then
    FExpression.value := '';
end;

procedure TFhirTestScriptSetupActionAssert.SetHeaderField(value : TFhirString);
begin
  FHeaderField.free;
  FHeaderField := value;
end;

function TFhirTestScriptSetupActionAssert.GetHeaderFieldST : String;
begin
  if FHeaderField = nil then
    result := ''
  else
    result := FHeaderField.value;
end;

procedure TFhirTestScriptSetupActionAssert.SetHeaderFieldST(value : String);
begin
  if value <> '' then
  begin
    if FHeaderField = nil then
      FHeaderField := TFhirString.create;
    FHeaderField.value := value
  end
  else if FHeaderField <> nil then
    FHeaderField.value := '';
end;

procedure TFhirTestScriptSetupActionAssert.SetMinimumId(value : TFhirString);
begin
  FMinimumId.free;
  FMinimumId := value;
end;

function TFhirTestScriptSetupActionAssert.GetMinimumIdST : String;
begin
  if FMinimumId = nil then
    result := ''
  else
    result := FMinimumId.value;
end;

procedure TFhirTestScriptSetupActionAssert.SetMinimumIdST(value : String);
begin
  if value <> '' then
  begin
    if FMinimumId = nil then
      FMinimumId := TFhirString.create;
    FMinimumId.value := value
  end
  else if FMinimumId <> nil then
    FMinimumId.value := '';
end;

procedure TFhirTestScriptSetupActionAssert.SetNavigationLinks(value : TFhirBoolean);
begin
  FNavigationLinks.free;
  FNavigationLinks := value;
end;

function TFhirTestScriptSetupActionAssert.GetNavigationLinksST : Boolean;
begin
  if FNavigationLinks = nil then
    result := false
  else
    result := FNavigationLinks.value;
end;

procedure TFhirTestScriptSetupActionAssert.SetNavigationLinksST(value : Boolean);
begin
  if FNavigationLinks = nil then
    FNavigationLinks := TFhirBoolean.create;
  FNavigationLinks.value := value
end;

procedure TFhirTestScriptSetupActionAssert.SetOperator(value : TFhirEnum);
begin
  FOperator.free;
  FOperator := value;
end;

function TFhirTestScriptSetupActionAssert.GetOperatorST : TFhirAssertionOperatorTypeEnum;
begin
  if FOperator = nil then
    result := TFhirAssertionOperatorTypeEnum(0)
  else
    result := TFhirAssertionOperatorTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirAssertionOperatorTypeEnum, FOperator.value));
end;

procedure TFhirTestScriptSetupActionAssert.SetOperatorST(value : TFhirAssertionOperatorTypeEnum);
begin
  if ord(value) = 0 then
    OperatorElement := nil
  else
    OperatorElement := TFhirEnum.create(SYSTEMS_TFhirAssertionOperatorTypeEnum[value], CODES_TFhirAssertionOperatorTypeEnum[value]);
end;

procedure TFhirTestScriptSetupActionAssert.SetPath(value : TFhirString);
begin
  FPath.free;
  FPath := value;
end;

function TFhirTestScriptSetupActionAssert.GetPathST : String;
begin
  if FPath = nil then
    result := ''
  else
    result := FPath.value;
end;

procedure TFhirTestScriptSetupActionAssert.SetPathST(value : String);
begin
  if value <> '' then
  begin
    if FPath = nil then
      FPath := TFhirString.create;
    FPath.value := value
  end
  else if FPath <> nil then
    FPath.value := '';
end;

procedure TFhirTestScriptSetupActionAssert.SetRequestMethod(value : TFhirEnum);
begin
  FRequestMethod.free;
  FRequestMethod := value;
end;

function TFhirTestScriptSetupActionAssert.GetRequestMethodST : TFhirTestScriptRequestMethodCodeEnum;
begin
  if FRequestMethod = nil then
    result := TFhirTestScriptRequestMethodCodeEnum(0)
  else
    result := TFhirTestScriptRequestMethodCodeEnum(StringArrayIndexOfSensitive(CODES_TFhirTestScriptRequestMethodCodeEnum, FRequestMethod.value));
end;

procedure TFhirTestScriptSetupActionAssert.SetRequestMethodST(value : TFhirTestScriptRequestMethodCodeEnum);
begin
  if ord(value) = 0 then
    RequestMethodElement := nil
  else
    RequestMethodElement := TFhirEnum.create(SYSTEMS_TFhirTestScriptRequestMethodCodeEnum[value], CODES_TFhirTestScriptRequestMethodCodeEnum[value]);
end;

procedure TFhirTestScriptSetupActionAssert.SetRequestURL(value : TFhirString);
begin
  FRequestURL.free;
  FRequestURL := value;
end;

function TFhirTestScriptSetupActionAssert.GetRequestURLST : String;
begin
  if FRequestURL = nil then
    result := ''
  else
    result := FRequestURL.value;
end;

procedure TFhirTestScriptSetupActionAssert.SetRequestURLST(value : String);
begin
  if value <> '' then
  begin
    if FRequestURL = nil then
      FRequestURL := TFhirString.create;
    FRequestURL.value := value
  end
  else if FRequestURL <> nil then
    FRequestURL.value := '';
end;

procedure TFhirTestScriptSetupActionAssert.SetResource(value : TFhirEnum);
begin
  FResource.free;
  FResource := value;
end;

function TFhirTestScriptSetupActionAssert.GetResourceST : TFhirFHIRDefinedTypeEnum;
begin
  if FResource = nil then
    result := TFhirFHIRDefinedTypeEnum(0)
  else
    result := TFhirFHIRDefinedTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirFHIRDefinedTypeEnum, FResource.value));
end;

procedure TFhirTestScriptSetupActionAssert.SetResourceST(value : TFhirFHIRDefinedTypeEnum);
begin
  if ord(value) = 0 then
    ResourceElement := nil
  else
    ResourceElement := TFhirEnum.create(SYSTEMS_TFhirFHIRDefinedTypeEnum[value], CODES_TFhirFHIRDefinedTypeEnum[value]);
end;

procedure TFhirTestScriptSetupActionAssert.SetResponse(value : TFhirEnum);
begin
  FResponse.free;
  FResponse := value;
end;

function TFhirTestScriptSetupActionAssert.GetResponseST : TFhirAssertionResponseTypesEnum;
begin
  if FResponse = nil then
    result := TFhirAssertionResponseTypesEnum(0)
  else
    result := TFhirAssertionResponseTypesEnum(StringArrayIndexOfSensitive(CODES_TFhirAssertionResponseTypesEnum, FResponse.value));
end;

procedure TFhirTestScriptSetupActionAssert.SetResponseST(value : TFhirAssertionResponseTypesEnum);
begin
  if ord(value) = 0 then
    ResponseElement := nil
  else
    ResponseElement := TFhirEnum.create(SYSTEMS_TFhirAssertionResponseTypesEnum[value], CODES_TFhirAssertionResponseTypesEnum[value]);
end;

procedure TFhirTestScriptSetupActionAssert.SetResponseCode(value : TFhirString);
begin
  FResponseCode.free;
  FResponseCode := value;
end;

function TFhirTestScriptSetupActionAssert.GetResponseCodeST : String;
begin
  if FResponseCode = nil then
    result := ''
  else
    result := FResponseCode.value;
end;

procedure TFhirTestScriptSetupActionAssert.SetResponseCodeST(value : String);
begin
  if value <> '' then
  begin
    if FResponseCode = nil then
      FResponseCode := TFhirString.create;
    FResponseCode.value := value
  end
  else if FResponseCode <> nil then
    FResponseCode.value := '';
end;

procedure TFhirTestScriptSetupActionAssert.SetSourceId(value : TFhirId);
begin
  FSourceId.free;
  FSourceId := value;
end;

function TFhirTestScriptSetupActionAssert.GetSourceIdST : String;
begin
  if FSourceId = nil then
    result := ''
  else
    result := FSourceId.value;
end;

procedure TFhirTestScriptSetupActionAssert.SetSourceIdST(value : String);
begin
  if value <> '' then
  begin
    if FSourceId = nil then
      FSourceId := TFhirId.create;
    FSourceId.value := value
  end
  else if FSourceId <> nil then
    FSourceId.value := '';
end;

procedure TFhirTestScriptSetupActionAssert.SetValidateProfileId(value : TFhirId);
begin
  FValidateProfileId.free;
  FValidateProfileId := value;
end;

function TFhirTestScriptSetupActionAssert.GetValidateProfileIdST : String;
begin
  if FValidateProfileId = nil then
    result := ''
  else
    result := FValidateProfileId.value;
end;

procedure TFhirTestScriptSetupActionAssert.SetValidateProfileIdST(value : String);
begin
  if value <> '' then
  begin
    if FValidateProfileId = nil then
      FValidateProfileId := TFhirId.create;
    FValidateProfileId.value := value
  end
  else if FValidateProfileId <> nil then
    FValidateProfileId.value := '';
end;

procedure TFhirTestScriptSetupActionAssert.SetValue(value : TFhirString);
begin
  FValue.free;
  FValue := value;
end;

function TFhirTestScriptSetupActionAssert.GetValueST : String;
begin
  if FValue = nil then
    result := ''
  else
    result := FValue.value;
end;

procedure TFhirTestScriptSetupActionAssert.SetValueST(value : String);
begin
  if value <> '' then
  begin
    if FValue = nil then
      FValue := TFhirString.create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := '';
end;

procedure TFhirTestScriptSetupActionAssert.SetWarningOnly(value : TFhirBoolean);
begin
  FWarningOnly.free;
  FWarningOnly := value;
end;

function TFhirTestScriptSetupActionAssert.GetWarningOnlyST : Boolean;
begin
  if FWarningOnly = nil then
    result := false
  else
    result := FWarningOnly.value;
end;

procedure TFhirTestScriptSetupActionAssert.SetWarningOnlyST(value : Boolean);
begin
  if FWarningOnly = nil then
    FWarningOnly := TFhirBoolean.create;
  FWarningOnly.value := value
end;

{ TFhirTestScriptSetupActionAssertListEnumerator }

constructor TFhirTestScriptSetupActionAssertListEnumerator.Create(list : TFhirTestScriptSetupActionAssertList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestScriptSetupActionAssertListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestScriptSetupActionAssertListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestScriptSetupActionAssertListEnumerator.GetCurrent : TFhirTestScriptSetupActionAssert;
begin
  Result := FList[FIndex];
end;

function TFhirTestScriptSetupActionAssertListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirTestScriptSetupActionAssertList }

function TFhirTestScriptSetupActionAssertList.AddItem(value: TFhirTestScriptSetupActionAssert): TFhirTestScriptSetupActionAssert;
begin
  assert(value.ClassName = 'TFhirTestScriptSetupActionAssert', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestScriptSetupActionAssert');
  add(value);
  result := value;
end;

function TFhirTestScriptSetupActionAssertList.Append: TFhirTestScriptSetupActionAssert;
begin
  result := TFhirTestScriptSetupActionAssert.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptSetupActionAssertList.ClearItems;
begin
  Clear;
end;

function TFhirTestScriptSetupActionAssertList.GetEnumerator : TFhirTestScriptSetupActionAssertListEnumerator;
begin
  result := TFhirTestScriptSetupActionAssertListEnumerator.Create(self.link);
end;

function TFhirTestScriptSetupActionAssertList.Clone: TFhirTestScriptSetupActionAssertList;
begin
  result := TFhirTestScriptSetupActionAssertList(inherited Clone);
end;

function TFhirTestScriptSetupActionAssertList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestScriptSetupActionAssertList.GetItemN(index: Integer): TFhirTestScriptSetupActionAssert;
begin
  result := TFhirTestScriptSetupActionAssert(ObjectByIndex[index]);
end;

function TFhirTestScriptSetupActionAssertList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestScriptSetupActionAssert;
end;
function TFhirTestScriptSetupActionAssertList.IndexOf(value: TFhirTestScriptSetupActionAssert): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestScriptSetupActionAssertList.Insert(index: Integer): TFhirTestScriptSetupActionAssert;
begin
  result := TFhirTestScriptSetupActionAssert.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptSetupActionAssertList.InsertItem(index: Integer; value: TFhirTestScriptSetupActionAssert);
begin
  assert(value is TFhirTestScriptSetupActionAssert);
  Inherited Insert(index, value);
end;

function TFhirTestScriptSetupActionAssertList.Item(index: Integer): TFhirTestScriptSetupActionAssert;
begin
  result := TFhirTestScriptSetupActionAssert(ObjectByIndex[index]);
end;

function TFhirTestScriptSetupActionAssertList.Link: TFhirTestScriptSetupActionAssertList;
begin
  result := TFhirTestScriptSetupActionAssertList(inherited Link);
end;

procedure TFhirTestScriptSetupActionAssertList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestScriptSetupActionAssertList.SetItemByIndex(index: Integer; value: TFhirTestScriptSetupActionAssert);
begin
  assert(value is TFhirTestScriptSetupActionAssert);
  FhirTestScriptSetupActionAsserts[index] := value;
end;

procedure TFhirTestScriptSetupActionAssertList.SetItemN(index: Integer; value: TFhirTestScriptSetupActionAssert);
begin
  assert(value is TFhirTestScriptSetupActionAssert);
  ObjectByIndex[index] := value;
end;

{ TFhirTestScriptTest }

constructor TFhirTestScriptTest.Create;
begin
  inherited;
end;

destructor TFhirTestScriptTest.Destroy;
begin
  FName.free;
  FDescription.free;
  FActionList.Free;
  inherited;
end;

procedure TFhirTestScriptTest.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirTestScriptTest(oSource).nameElement.Clone;
  descriptionElement := TFhirTestScriptTest(oSource).descriptionElement.Clone;
  if (TFhirTestScriptTest(oSource).FActionList = nil) then
  begin
    FActionList.free;
    FActionList := nil;
  end
  else
  begin
    if FActionList = nil then
      FActionList := TFhirTestScriptTestActionList.Create;
    FActionList.Assign(TFhirTestScriptTest(oSource).FActionList);
  end;
end;

procedure TFhirTestScriptTest.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'action') Then
    list.addAll(self, 'action', FActionList);
end;

procedure TFhirTestScriptTest.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'action', 'BackboneElement', true, TFhirTestScriptTestAction, FActionList.Link));
end;

function TFhirTestScriptTest.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'action') then
  begin
    ActionList.add(propValue as TFhirTestScriptTestAction);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestScriptTest.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'action') then ActionList.insertItem(index, propValue as TFhirTestScriptTestAction)
  else inherited;
end;

function TFhirTestScriptTest.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'description') then result := TFhirString.create()
  else if (propName = 'action') then result := ActionList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestScriptTest.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'action') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestScriptTest.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'action') then deletePropertyValue('action', ActionList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestScriptTest.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'description') then DescriptionElement := asString(new)
  else if (propName = 'action') then replacePropertyValue('action', ActionList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestScriptTest.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'action') then ActionList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirTestScriptTest.fhirType : string;
begin
  result := 'TestScript.test';
end;

function TFhirTestScriptTest.Link : TFhirTestScriptTest;
begin
  result := TFhirTestScriptTest(inherited Link);
end;

function TFhirTestScriptTest.Clone : TFhirTestScriptTest;
begin
  result := TFhirTestScriptTest(inherited Clone);
end;

function TFhirTestScriptTest.equals(other : TObject) : boolean; 
var
  o : TFhirTestScriptTest;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestScriptTest)) then
    result := false
  else
  begin
    o := TFhirTestScriptTest(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(actionList, o.actionList, true);
  end;
end;

function TFhirTestScriptTest.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FDescription) and isEmptyProp(FactionList);
end;

procedure TFhirTestScriptTest.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('name');
  fields.add('description');
  fields.add('action');
end;

function TFhirTestScriptTest.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FActionList.sizeInBytes(magic));
end;

procedure TFhirTestScriptTest.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirTestScriptTest.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirTestScriptTest.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirTestScriptTest.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirTestScriptTest.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirTestScriptTest.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirTestScriptTest.GetActionList : TFhirTestScriptTestActionList;
begin
  if FActionList = nil then
    FActionList := TFhirTestScriptTestActionList.Create;
  result := FActionList;
end;

function TFhirTestScriptTest.GetHasActionList : boolean;
begin
  result := (FActionList <> nil) and (FActionList.count > 0);
end;

{ TFhirTestScriptTestListEnumerator }

constructor TFhirTestScriptTestListEnumerator.Create(list : TFhirTestScriptTestList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestScriptTestListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestScriptTestListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestScriptTestListEnumerator.GetCurrent : TFhirTestScriptTest;
begin
  Result := FList[FIndex];
end;

function TFhirTestScriptTestListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirTestScriptTestList }

function TFhirTestScriptTestList.AddItem(value: TFhirTestScriptTest): TFhirTestScriptTest;
begin
  assert(value.ClassName = 'TFhirTestScriptTest', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestScriptTest');
  add(value);
  result := value;
end;

function TFhirTestScriptTestList.Append: TFhirTestScriptTest;
begin
  result := TFhirTestScriptTest.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptTestList.ClearItems;
begin
  Clear;
end;

function TFhirTestScriptTestList.GetEnumerator : TFhirTestScriptTestListEnumerator;
begin
  result := TFhirTestScriptTestListEnumerator.Create(self.link);
end;

function TFhirTestScriptTestList.Clone: TFhirTestScriptTestList;
begin
  result := TFhirTestScriptTestList(inherited Clone);
end;

function TFhirTestScriptTestList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestScriptTestList.GetItemN(index: Integer): TFhirTestScriptTest;
begin
  result := TFhirTestScriptTest(ObjectByIndex[index]);
end;

function TFhirTestScriptTestList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestScriptTest;
end;
function TFhirTestScriptTestList.IndexOf(value: TFhirTestScriptTest): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestScriptTestList.Insert(index: Integer): TFhirTestScriptTest;
begin
  result := TFhirTestScriptTest.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptTestList.InsertItem(index: Integer; value: TFhirTestScriptTest);
begin
  assert(value is TFhirTestScriptTest);
  Inherited Insert(index, value);
end;

function TFhirTestScriptTestList.Item(index: Integer): TFhirTestScriptTest;
begin
  result := TFhirTestScriptTest(ObjectByIndex[index]);
end;

function TFhirTestScriptTestList.Link: TFhirTestScriptTestList;
begin
  result := TFhirTestScriptTestList(inherited Link);
end;

procedure TFhirTestScriptTestList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestScriptTestList.SetItemByIndex(index: Integer; value: TFhirTestScriptTest);
begin
  assert(value is TFhirTestScriptTest);
  FhirTestScriptTests[index] := value;
end;

procedure TFhirTestScriptTestList.SetItemN(index: Integer; value: TFhirTestScriptTest);
begin
  assert(value is TFhirTestScriptTest);
  ObjectByIndex[index] := value;
end;

{ TFhirTestScriptTestAction }

constructor TFhirTestScriptTestAction.Create;
begin
  inherited;
end;

destructor TFhirTestScriptTestAction.Destroy;
begin
  FOperation.free;
  FAssert.free;
  inherited;
end;

procedure TFhirTestScriptTestAction.Assign(oSource : TFslObject);
begin
  inherited;
  operation := TFhirTestScriptTestAction(oSource).operation.Clone;
  assert := TFhirTestScriptTestAction(oSource).assert.Clone;
end;

procedure TFhirTestScriptTestAction.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'operation') Then
     list.add(self.link, 'operation', FOperation.Link);
  if (child_name = 'assert') Then
     list.add(self.link, 'assert', FAssert.Link);
end;

procedure TFhirTestScriptTestAction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'operation', '', false, TFhirTestScriptSetupActionOperation, FOperation.Link));
  oList.add(TFHIRProperty.create(self, 'assert', '', false, TFhirTestScriptSetupActionAssert, FAssert.Link));
end;

function TFhirTestScriptTestAction.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'operation') then
  begin
    Operation := propValue as TFhirTestScriptSetupActionOperation;
    result := propValue;
  end
  else if (propName = 'assert') then
  begin
    Assert := propValue as TFhirTestScriptSetupActionAssert;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestScriptTestAction.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirTestScriptTestAction.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'operation') then result := TFhirTestScriptSetupActionOperation.create()
  else if (propName = 'assert') then result := TFhirTestScriptSetupActionAssert.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestScriptTestAction.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'operation') then result := ''
  else if (propName = 'assert') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestScriptTestAction.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'operation') then OperationElement := nil
  else if (propName = 'assert') then AssertElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestScriptTestAction.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'operation') then OperationElement := new as TFhirTestScriptSetupActionOperation
  else if (propName = 'assert') then AssertElement := new as TFhirTestScriptSetupActionAssert
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestScriptTestAction.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirTestScriptTestAction.fhirType : string;
begin
  result := 'TestScript.test.action';
end;

function TFhirTestScriptTestAction.Link : TFhirTestScriptTestAction;
begin
  result := TFhirTestScriptTestAction(inherited Link);
end;

function TFhirTestScriptTestAction.Clone : TFhirTestScriptTestAction;
begin
  result := TFhirTestScriptTestAction(inherited Clone);
end;

function TFhirTestScriptTestAction.equals(other : TObject) : boolean; 
var
  o : TFhirTestScriptTestAction;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestScriptTestAction)) then
    result := false
  else
  begin
    o := TFhirTestScriptTestAction(other);
    result := compareDeep(operationElement, o.operationElement, true) and compareDeep(assertElement, o.assertElement, true);
  end;
end;

function TFhirTestScriptTestAction.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FOperation) and isEmptyProp(FAssert);
end;

procedure TFhirTestScriptTestAction.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('operation');
  fields.add('assert');
end;

function TFhirTestScriptTestAction.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirTestScriptTestAction.SetOperation(value : TFhirTestScriptSetupActionOperation);
begin
  FOperation.free;
  FOperation := value;
end;

procedure TFhirTestScriptTestAction.SetAssert(value : TFhirTestScriptSetupActionAssert);
begin
  FAssert.free;
  FAssert := value;
end;

{ TFhirTestScriptTestActionListEnumerator }

constructor TFhirTestScriptTestActionListEnumerator.Create(list : TFhirTestScriptTestActionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestScriptTestActionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestScriptTestActionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestScriptTestActionListEnumerator.GetCurrent : TFhirTestScriptTestAction;
begin
  Result := FList[FIndex];
end;

function TFhirTestScriptTestActionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirTestScriptTestActionList }

function TFhirTestScriptTestActionList.AddItem(value: TFhirTestScriptTestAction): TFhirTestScriptTestAction;
begin
  assert(value.ClassName = 'TFhirTestScriptTestAction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestScriptTestAction');
  add(value);
  result := value;
end;

function TFhirTestScriptTestActionList.Append: TFhirTestScriptTestAction;
begin
  result := TFhirTestScriptTestAction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptTestActionList.ClearItems;
begin
  Clear;
end;

function TFhirTestScriptTestActionList.GetEnumerator : TFhirTestScriptTestActionListEnumerator;
begin
  result := TFhirTestScriptTestActionListEnumerator.Create(self.link);
end;

function TFhirTestScriptTestActionList.Clone: TFhirTestScriptTestActionList;
begin
  result := TFhirTestScriptTestActionList(inherited Clone);
end;

function TFhirTestScriptTestActionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestScriptTestActionList.GetItemN(index: Integer): TFhirTestScriptTestAction;
begin
  result := TFhirTestScriptTestAction(ObjectByIndex[index]);
end;

function TFhirTestScriptTestActionList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestScriptTestAction;
end;
function TFhirTestScriptTestActionList.IndexOf(value: TFhirTestScriptTestAction): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestScriptTestActionList.Insert(index: Integer): TFhirTestScriptTestAction;
begin
  result := TFhirTestScriptTestAction.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptTestActionList.InsertItem(index: Integer; value: TFhirTestScriptTestAction);
begin
  assert(value is TFhirTestScriptTestAction);
  Inherited Insert(index, value);
end;

function TFhirTestScriptTestActionList.Item(index: Integer): TFhirTestScriptTestAction;
begin
  result := TFhirTestScriptTestAction(ObjectByIndex[index]);
end;

function TFhirTestScriptTestActionList.Link: TFhirTestScriptTestActionList;
begin
  result := TFhirTestScriptTestActionList(inherited Link);
end;

procedure TFhirTestScriptTestActionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestScriptTestActionList.SetItemByIndex(index: Integer; value: TFhirTestScriptTestAction);
begin
  assert(value is TFhirTestScriptTestAction);
  FhirTestScriptTestActions[index] := value;
end;

procedure TFhirTestScriptTestActionList.SetItemN(index: Integer; value: TFhirTestScriptTestAction);
begin
  assert(value is TFhirTestScriptTestAction);
  ObjectByIndex[index] := value;
end;

{ TFhirTestScriptTeardown }

constructor TFhirTestScriptTeardown.Create;
begin
  inherited;
end;

destructor TFhirTestScriptTeardown.Destroy;
begin
  FActionList.Free;
  inherited;
end;

procedure TFhirTestScriptTeardown.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirTestScriptTeardown(oSource).FActionList = nil) then
  begin
    FActionList.free;
    FActionList := nil;
  end
  else
  begin
    if FActionList = nil then
      FActionList := TFhirTestScriptTeardownActionList.Create;
    FActionList.Assign(TFhirTestScriptTeardown(oSource).FActionList);
  end;
end;

procedure TFhirTestScriptTeardown.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'action') Then
    list.addAll(self, 'action', FActionList);
end;

procedure TFhirTestScriptTeardown.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'action', 'BackboneElement', true, TFhirTestScriptTeardownAction, FActionList.Link));
end;

function TFhirTestScriptTeardown.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'action') then
  begin
    ActionList.add(propValue as TFhirTestScriptTeardownAction);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestScriptTeardown.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'action') then ActionList.insertItem(index, propValue as TFhirTestScriptTeardownAction)
  else inherited;
end;

function TFhirTestScriptTeardown.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'action') then result := ActionList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestScriptTeardown.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'action') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestScriptTeardown.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'action') then deletePropertyValue('action', ActionList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestScriptTeardown.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'action') then replacePropertyValue('action', ActionList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestScriptTeardown.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'action') then ActionList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirTestScriptTeardown.fhirType : string;
begin
  result := 'TestScript.teardown';
end;

function TFhirTestScriptTeardown.Link : TFhirTestScriptTeardown;
begin
  result := TFhirTestScriptTeardown(inherited Link);
end;

function TFhirTestScriptTeardown.Clone : TFhirTestScriptTeardown;
begin
  result := TFhirTestScriptTeardown(inherited Clone);
end;

function TFhirTestScriptTeardown.equals(other : TObject) : boolean; 
var
  o : TFhirTestScriptTeardown;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestScriptTeardown)) then
    result := false
  else
  begin
    o := TFhirTestScriptTeardown(other);
    result := compareDeep(actionList, o.actionList, true);
  end;
end;

function TFhirTestScriptTeardown.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FactionList);
end;

procedure TFhirTestScriptTeardown.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('action');
end;

function TFhirTestScriptTeardown.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FActionList.sizeInBytes(magic));
end;

function TFhirTestScriptTeardown.GetActionList : TFhirTestScriptTeardownActionList;
begin
  if FActionList = nil then
    FActionList := TFhirTestScriptTeardownActionList.Create;
  result := FActionList;
end;

function TFhirTestScriptTeardown.GetHasActionList : boolean;
begin
  result := (FActionList <> nil) and (FActionList.count > 0);
end;

{ TFhirTestScriptTeardownListEnumerator }

constructor TFhirTestScriptTeardownListEnumerator.Create(list : TFhirTestScriptTeardownList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestScriptTeardownListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestScriptTeardownListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestScriptTeardownListEnumerator.GetCurrent : TFhirTestScriptTeardown;
begin
  Result := FList[FIndex];
end;

function TFhirTestScriptTeardownListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirTestScriptTeardownList }

function TFhirTestScriptTeardownList.AddItem(value: TFhirTestScriptTeardown): TFhirTestScriptTeardown;
begin
  assert(value.ClassName = 'TFhirTestScriptTeardown', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestScriptTeardown');
  add(value);
  result := value;
end;

function TFhirTestScriptTeardownList.Append: TFhirTestScriptTeardown;
begin
  result := TFhirTestScriptTeardown.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptTeardownList.ClearItems;
begin
  Clear;
end;

function TFhirTestScriptTeardownList.GetEnumerator : TFhirTestScriptTeardownListEnumerator;
begin
  result := TFhirTestScriptTeardownListEnumerator.Create(self.link);
end;

function TFhirTestScriptTeardownList.Clone: TFhirTestScriptTeardownList;
begin
  result := TFhirTestScriptTeardownList(inherited Clone);
end;

function TFhirTestScriptTeardownList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestScriptTeardownList.GetItemN(index: Integer): TFhirTestScriptTeardown;
begin
  result := TFhirTestScriptTeardown(ObjectByIndex[index]);
end;

function TFhirTestScriptTeardownList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestScriptTeardown;
end;
function TFhirTestScriptTeardownList.IndexOf(value: TFhirTestScriptTeardown): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestScriptTeardownList.Insert(index: Integer): TFhirTestScriptTeardown;
begin
  result := TFhirTestScriptTeardown.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptTeardownList.InsertItem(index: Integer; value: TFhirTestScriptTeardown);
begin
  assert(value is TFhirTestScriptTeardown);
  Inherited Insert(index, value);
end;

function TFhirTestScriptTeardownList.Item(index: Integer): TFhirTestScriptTeardown;
begin
  result := TFhirTestScriptTeardown(ObjectByIndex[index]);
end;

function TFhirTestScriptTeardownList.Link: TFhirTestScriptTeardownList;
begin
  result := TFhirTestScriptTeardownList(inherited Link);
end;

procedure TFhirTestScriptTeardownList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestScriptTeardownList.SetItemByIndex(index: Integer; value: TFhirTestScriptTeardown);
begin
  assert(value is TFhirTestScriptTeardown);
  FhirTestScriptTeardowns[index] := value;
end;

procedure TFhirTestScriptTeardownList.SetItemN(index: Integer; value: TFhirTestScriptTeardown);
begin
  assert(value is TFhirTestScriptTeardown);
  ObjectByIndex[index] := value;
end;

{ TFhirTestScriptTeardownAction }

constructor TFhirTestScriptTeardownAction.Create;
begin
  inherited;
end;

destructor TFhirTestScriptTeardownAction.Destroy;
begin
  FOperation.free;
  inherited;
end;

procedure TFhirTestScriptTeardownAction.Assign(oSource : TFslObject);
begin
  inherited;
  operation := TFhirTestScriptTeardownAction(oSource).operation.Clone;
end;

procedure TFhirTestScriptTeardownAction.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'operation') Then
     list.add(self.link, 'operation', FOperation.Link);
end;

procedure TFhirTestScriptTeardownAction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'operation', '', false, TFhirTestScriptSetupActionOperation, FOperation.Link));
end;

function TFhirTestScriptTeardownAction.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'operation') then
  begin
    Operation := propValue as TFhirTestScriptSetupActionOperation;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestScriptTeardownAction.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirTestScriptTeardownAction.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'operation') then result := TFhirTestScriptSetupActionOperation.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestScriptTeardownAction.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'operation') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestScriptTeardownAction.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'operation') then OperationElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestScriptTeardownAction.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'operation') then OperationElement := new as TFhirTestScriptSetupActionOperation
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestScriptTeardownAction.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirTestScriptTeardownAction.fhirType : string;
begin
  result := 'TestScript.teardown.action';
end;

function TFhirTestScriptTeardownAction.Link : TFhirTestScriptTeardownAction;
begin
  result := TFhirTestScriptTeardownAction(inherited Link);
end;

function TFhirTestScriptTeardownAction.Clone : TFhirTestScriptTeardownAction;
begin
  result := TFhirTestScriptTeardownAction(inherited Clone);
end;

function TFhirTestScriptTeardownAction.equals(other : TObject) : boolean; 
var
  o : TFhirTestScriptTeardownAction;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestScriptTeardownAction)) then
    result := false
  else
  begin
    o := TFhirTestScriptTeardownAction(other);
    result := compareDeep(operationElement, o.operationElement, true);
  end;
end;

function TFhirTestScriptTeardownAction.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FOperation);
end;

procedure TFhirTestScriptTeardownAction.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('operation');
end;

function TFhirTestScriptTeardownAction.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirTestScriptTeardownAction.SetOperation(value : TFhirTestScriptSetupActionOperation);
begin
  FOperation.free;
  FOperation := value;
end;

{ TFhirTestScriptTeardownActionListEnumerator }

constructor TFhirTestScriptTeardownActionListEnumerator.Create(list : TFhirTestScriptTeardownActionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestScriptTeardownActionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestScriptTeardownActionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestScriptTeardownActionListEnumerator.GetCurrent : TFhirTestScriptTeardownAction;
begin
  Result := FList[FIndex];
end;

function TFhirTestScriptTeardownActionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirTestScriptTeardownActionList }

function TFhirTestScriptTeardownActionList.AddItem(value: TFhirTestScriptTeardownAction): TFhirTestScriptTeardownAction;
begin
  assert(value.ClassName = 'TFhirTestScriptTeardownAction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestScriptTeardownAction');
  add(value);
  result := value;
end;

function TFhirTestScriptTeardownActionList.Append: TFhirTestScriptTeardownAction;
begin
  result := TFhirTestScriptTeardownAction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptTeardownActionList.ClearItems;
begin
  Clear;
end;

function TFhirTestScriptTeardownActionList.GetEnumerator : TFhirTestScriptTeardownActionListEnumerator;
begin
  result := TFhirTestScriptTeardownActionListEnumerator.Create(self.link);
end;

function TFhirTestScriptTeardownActionList.Clone: TFhirTestScriptTeardownActionList;
begin
  result := TFhirTestScriptTeardownActionList(inherited Clone);
end;

function TFhirTestScriptTeardownActionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestScriptTeardownActionList.GetItemN(index: Integer): TFhirTestScriptTeardownAction;
begin
  result := TFhirTestScriptTeardownAction(ObjectByIndex[index]);
end;

function TFhirTestScriptTeardownActionList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestScriptTeardownAction;
end;
function TFhirTestScriptTeardownActionList.IndexOf(value: TFhirTestScriptTeardownAction): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestScriptTeardownActionList.Insert(index: Integer): TFhirTestScriptTeardownAction;
begin
  result := TFhirTestScriptTeardownAction.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptTeardownActionList.InsertItem(index: Integer; value: TFhirTestScriptTeardownAction);
begin
  assert(value is TFhirTestScriptTeardownAction);
  Inherited Insert(index, value);
end;

function TFhirTestScriptTeardownActionList.Item(index: Integer): TFhirTestScriptTeardownAction;
begin
  result := TFhirTestScriptTeardownAction(ObjectByIndex[index]);
end;

function TFhirTestScriptTeardownActionList.Link: TFhirTestScriptTeardownActionList;
begin
  result := TFhirTestScriptTeardownActionList(inherited Link);
end;

procedure TFhirTestScriptTeardownActionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestScriptTeardownActionList.SetItemByIndex(index: Integer; value: TFhirTestScriptTeardownAction);
begin
  assert(value is TFhirTestScriptTeardownAction);
  FhirTestScriptTeardownActions[index] := value;
end;

procedure TFhirTestScriptTeardownActionList.SetItemN(index: Integer; value: TFhirTestScriptTeardownAction);
begin
  assert(value is TFhirTestScriptTeardownAction);
  ObjectByIndex[index] := value;
end;

{ TFhirTestScript }

constructor TFhirTestScript.Create;
begin
  inherited;
end;

destructor TFhirTestScript.Destroy;
begin
  FUrl.free;
  FIdentifier.free;
  FVersion.free;
  FName.free;
  FTitle.free;
  FStatus.free;
  FExperimental.free;
  FDate.free;
  FPublisher.free;
  FContactList.Free;
  FDescription.free;
  FUseContextList.Free;
  FJurisdictionList.Free;
  FPurpose.free;
  FCopyright.free;
  FOriginList.Free;
  FDestinationList.Free;
  FMetadata.free;
  FFixtureList.Free;
  FProfileList.Free;
  FVariableList.Free;
  FSetup.free;
  FTestList.Free;
  FTeardown.free;
  inherited;
end;

procedure TFhirTestScript.Assign(oSource : TFslObject);
begin
  inherited;
  urlElement := TFhirTestScript(oSource).urlElement.Clone;
  identifier := TFhirTestScript(oSource).identifier.Clone;
  versionElement := TFhirTestScript(oSource).versionElement.Clone;
  nameElement := TFhirTestScript(oSource).nameElement.Clone;
  titleElement := TFhirTestScript(oSource).titleElement.Clone;
  statusElement := TFhirTestScript(oSource).statusElement.Clone;
  experimentalElement := TFhirTestScript(oSource).experimentalElement.Clone;
  dateElement := TFhirTestScript(oSource).dateElement.Clone;
  publisherElement := TFhirTestScript(oSource).publisherElement.Clone;
  if (TFhirTestScript(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirContactDetailList.Create;
    FContactList.Assign(TFhirTestScript(oSource).FContactList);
  end;
  descriptionElement := TFhirTestScript(oSource).descriptionElement.Clone;
  if (TFhirTestScript(oSource).FUseContextList = nil) then
  begin
    FUseContextList.free;
    FUseContextList := nil;
  end
  else
  begin
    if FUseContextList = nil then
      FUseContextList := TFhirUsageContextList.Create;
    FUseContextList.Assign(TFhirTestScript(oSource).FUseContextList);
  end;
  if (TFhirTestScript(oSource).FJurisdictionList = nil) then
  begin
    FJurisdictionList.free;
    FJurisdictionList := nil;
  end
  else
  begin
    if FJurisdictionList = nil then
      FJurisdictionList := TFhirCodeableConceptList.Create;
    FJurisdictionList.Assign(TFhirTestScript(oSource).FJurisdictionList);
  end;
  purposeElement := TFhirTestScript(oSource).purposeElement.Clone;
  copyrightElement := TFhirTestScript(oSource).copyrightElement.Clone;
  if (TFhirTestScript(oSource).FOriginList = nil) then
  begin
    FOriginList.free;
    FOriginList := nil;
  end
  else
  begin
    if FOriginList = nil then
      FOriginList := TFhirTestScriptOriginList.Create;
    FOriginList.Assign(TFhirTestScript(oSource).FOriginList);
  end;
  if (TFhirTestScript(oSource).FDestinationList = nil) then
  begin
    FDestinationList.free;
    FDestinationList := nil;
  end
  else
  begin
    if FDestinationList = nil then
      FDestinationList := TFhirTestScriptDestinationList.Create;
    FDestinationList.Assign(TFhirTestScript(oSource).FDestinationList);
  end;
  metadata := TFhirTestScript(oSource).metadata.Clone;
  if (TFhirTestScript(oSource).FFixtureList = nil) then
  begin
    FFixtureList.free;
    FFixtureList := nil;
  end
  else
  begin
    if FFixtureList = nil then
      FFixtureList := TFhirTestScriptFixtureList.Create;
    FFixtureList.Assign(TFhirTestScript(oSource).FFixtureList);
  end;
  if (TFhirTestScript(oSource).FProfileList = nil) then
  begin
    FProfileList.free;
    FProfileList := nil;
  end
  else
  begin
    if FProfileList = nil then
      FProfileList := TFhirReferenceList.Create;
    FProfileList.Assign(TFhirTestScript(oSource).FProfileList);
  end;
  if (TFhirTestScript(oSource).FVariableList = nil) then
  begin
    FVariableList.free;
    FVariableList := nil;
  end
  else
  begin
    if FVariableList = nil then
      FVariableList := TFhirTestScriptVariableList.Create;
    FVariableList.Assign(TFhirTestScript(oSource).FVariableList);
  end;
  setup := TFhirTestScript(oSource).setup.Clone;
  if (TFhirTestScript(oSource).FTestList = nil) then
  begin
    FTestList.free;
    FTestList := nil;
  end
  else
  begin
    if FTestList = nil then
      FTestList := TFhirTestScriptTestList.Create;
    FTestList.Assign(TFhirTestScript(oSource).FTestList);
  end;
  teardown := TFhirTestScript(oSource).teardown.Clone;
end;

function TFhirTestScript.GetResourceType : TFhirResourceType;
begin
  result := frtTestScript;
end;

procedure TFhirTestScript.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'version') Then
     list.add(self.link, 'version', FVersion.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'experimental') Then
     list.add(self.link, 'experimental', FExperimental.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'publisher') Then
     list.add(self.link, 'publisher', FPublisher.Link);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'useContext') Then
    list.addAll(self, 'useContext', FUseContextList);
  if (child_name = 'jurisdiction') Then
    list.addAll(self, 'jurisdiction', FJurisdictionList);
  if (child_name = 'purpose') Then
     list.add(self.link, 'purpose', FPurpose.Link);
  if (child_name = 'copyright') Then
     list.add(self.link, 'copyright', FCopyright.Link);
  if (child_name = 'origin') Then
    list.addAll(self, 'origin', FOriginList);
  if (child_name = 'destination') Then
    list.addAll(self, 'destination', FDestinationList);
  if (child_name = 'metadata') Then
     list.add(self.link, 'metadata', FMetadata.Link);
  if (child_name = 'fixture') Then
    list.addAll(self, 'fixture', FFixtureList);
  if (child_name = 'profile') Then
    list.addAll(self, 'profile', FProfileList);
  if (child_name = 'variable') Then
    list.addAll(self, 'variable', FVariableList);
  if (child_name = 'setup') Then
     list.add(self.link, 'setup', FSetup.Link);
  if (child_name = 'test') Then
    list.addAll(self, 'test', FTestList);
  if (child_name = 'teardown') Then
     list.add(self.link, 'teardown', FTeardown.Link);
end;

procedure TFhirTestScript.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'url', 'uri', false, TFhirUri, FUrl.Link));
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));
  oList.add(TFHIRProperty.create(self, 'version', 'string', false, TFhirString, FVersion.Link));
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'experimental', 'boolean', false, TFhirBoolean, FExperimental.Link));
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));
  oList.add(TFHIRProperty.create(self, 'publisher', 'string', false, TFhirString, FPublisher.Link));
  oList.add(TFHIRProperty.create(self, 'contact', 'ContactDetail', true, TFhirContactDetail, FContactList.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'markdown', false, TFhirMarkdown, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'useContext', 'UsageContext', true, TFhirUsageContext, FUseContextList.Link));
  oList.add(TFHIRProperty.create(self, 'jurisdiction', 'CodeableConcept', true, TFhirCodeableConcept, FJurisdictionList.Link));
  oList.add(TFHIRProperty.create(self, 'purpose', 'markdown', false, TFhirMarkdown, FPurpose.Link));
  oList.add(TFHIRProperty.create(self, 'copyright', 'markdown', false, TFhirMarkdown, FCopyright.Link));
  oList.add(TFHIRProperty.create(self, 'origin', 'BackboneElement', true, TFhirTestScriptOrigin, FOriginList.Link));
  oList.add(TFHIRProperty.create(self, 'destination', 'BackboneElement', true, TFhirTestScriptDestination, FDestinationList.Link));
  oList.add(TFHIRProperty.create(self, 'metadata', 'BackboneElement', false, TFhirTestScriptMetadata, FMetadata.Link));
  oList.add(TFHIRProperty.create(self, 'fixture', 'BackboneElement', true, TFhirTestScriptFixture, FFixtureList.Link));
  oList.add(TFHIRProperty.create(self, 'profile', 'Reference', true, TFhirReference, FProfileList.Link));
  oList.add(TFHIRProperty.create(self, 'variable', 'BackboneElement', true, TFhirTestScriptVariable, FVariableList.Link));
  oList.add(TFHIRProperty.create(self, 'setup', 'BackboneElement', false, TFhirTestScriptSetup, FSetup.Link));
  oList.add(TFHIRProperty.create(self, 'test', 'BackboneElement', true, TFhirTestScriptTest, FTestList.Link));
  oList.add(TFHIRProperty.create(self, 'teardown', 'BackboneElement', false, TFhirTestScriptTeardown, FTeardown.Link));
end;

function TFhirTestScript.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'url') then
  begin
    UrlElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier;
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'title') then
  begin
    TitleElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'experimental') then
  begin
    ExperimentalElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'publisher') then
  begin
    PublisherElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirContactDetail);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'useContext') then
  begin
    UseContextList.add(propValue as TFhirUsageContext);
    result := propValue;
  end
  else if (propName = 'jurisdiction') then
  begin
    JurisdictionList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'purpose') then
  begin
    PurposeElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'copyright') then
  begin
    CopyrightElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'origin') then
  begin
    OriginList.add(propValue as TFhirTestScriptOrigin);
    result := propValue;
  end
  else if (propName = 'destination') then
  begin
    DestinationList.add(propValue as TFhirTestScriptDestination);
    result := propValue;
  end
  else if (propName = 'metadata') then
  begin
    Metadata := propValue as TFhirTestScriptMetadata;
    result := propValue;
  end
  else if (propName = 'fixture') then
  begin
    FixtureList.add(propValue as TFhirTestScriptFixture);
    result := propValue;
  end
  else if (propName = 'profile') then
  begin
    ProfileList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'variable') then
  begin
    VariableList.add(propValue as TFhirTestScriptVariable);
    result := propValue;
  end
  else if (propName = 'setup') then
  begin
    Setup := propValue as TFhirTestScriptSetup;
    result := propValue;
  end
  else if (propName = 'test') then
  begin
    TestList.add(propValue as TFhirTestScriptTest);
    result := propValue;
  end
  else if (propName = 'teardown') then
  begin
    Teardown := propValue as TFhirTestScriptTeardown;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestScript.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirContactDetail)
  else if (propName = 'useContext') then UseContextList.insertItem(index, propValue as TFhirUsageContext)
  else if (propName = 'jurisdiction') then JurisdictionList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'origin') then OriginList.insertItem(index, propValue as TFhirTestScriptOrigin)
  else if (propName = 'destination') then DestinationList.insertItem(index, propValue as TFhirTestScriptDestination)
  else if (propName = 'fixture') then FixtureList.insertItem(index, propValue as TFhirTestScriptFixture)
  else if (propName = 'profile') then ProfileList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'variable') then VariableList.insertItem(index, propValue as TFhirTestScriptVariable)
  else if (propName = 'test') then TestList.insertItem(index, propValue as TFhirTestScriptTest)
  else inherited;
end;

function TFhirTestScript.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'url') then result := TFhirUri.create()
  else if (propName = 'identifier') then result := TFhirIdentifier.create()
  else if (propName = 'version') then result := TFhirString.create()
  else if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'title') then result := TFhirString.create()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[PublicationStatusNull], CODES_TFhirPublicationStatusEnum[PublicationStatusNull]) 
  else if (propName = 'experimental') then result := TFhirBoolean.create()
  else if (propName = 'date') then result := TFhirDateTime.create()
  else if (propName = 'publisher') then result := TFhirString.create()
  else if (propName = 'contact') then result := ContactList.new()
  else if (propName = 'description') then result := TFhirMarkdown.create()
  else if (propName = 'useContext') then result := UseContextList.new()
  else if (propName = 'jurisdiction') then result := JurisdictionList.new()
  else if (propName = 'purpose') then result := TFhirMarkdown.create()
  else if (propName = 'copyright') then result := TFhirMarkdown.create()
  else if (propName = 'origin') then result := OriginList.new()
  else if (propName = 'destination') then result := DestinationList.new()
  else if (propName = 'metadata') then result := TFhirTestScriptMetadata.create()
  else if (propName = 'fixture') then result := FixtureList.new()
  else if (propName = 'profile') then result := ProfileList.new()
  else if (propName = 'variable') then result := VariableList.new()
  else if (propName = 'setup') then result := TFhirTestScriptSetup.create()
  else if (propName = 'test') then result := TestList.new()
  else if (propName = 'teardown') then result := TFhirTestScriptTeardown.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestScript.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'url') then result := 'uri'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'version') then result := 'string'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'title') then result := 'string'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'experimental') then result := 'boolean'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'publisher') then result := 'string'
  else if (propName = 'contact') then result := 'ContactDetail'
  else if (propName = 'description') then result := 'markdown'
  else if (propName = 'useContext') then result := 'UsageContext'
  else if (propName = 'jurisdiction') then result := 'CodeableConcept'
  else if (propName = 'purpose') then result := 'markdown'
  else if (propName = 'copyright') then result := 'markdown'
  else if (propName = 'origin') then result := 'BackboneElement'
  else if (propName = 'destination') then result := 'BackboneElement'
  else if (propName = 'metadata') then result := 'BackboneElement'
  else if (propName = 'fixture') then result := 'BackboneElement'
  else if (propName = 'profile') then result := 'Reference'
  else if (propName = 'variable') then result := 'BackboneElement'
  else if (propName = 'setup') then result := 'BackboneElement'
  else if (propName = 'test') then result := 'BackboneElement'
  else if (propName = 'teardown') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestScript.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := nil
  else if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'version') then VersionElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'title') then TitleElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'experimental') then ExperimentalElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'publisher') then PublisherElement := nil
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value)
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'useContext') then deletePropertyValue('useContext', UseContextList, value)
  else if (propName = 'jurisdiction') then deletePropertyValue('jurisdiction', JurisdictionList, value)
  else if (propName = 'purpose') then PurposeElement := nil
  else if (propName = 'copyright') then CopyrightElement := nil
  else if (propName = 'origin') then deletePropertyValue('origin', OriginList, value)
  else if (propName = 'destination') then deletePropertyValue('destination', DestinationList, value)
  else if (propName = 'metadata') then MetadataElement := nil
  else if (propName = 'fixture') then deletePropertyValue('fixture', FixtureList, value)
  else if (propName = 'profile') then deletePropertyValue('profile', ProfileList, value)
  else if (propName = 'variable') then deletePropertyValue('variable', VariableList, value)
  else if (propName = 'setup') then SetupElement := nil
  else if (propName = 'test') then deletePropertyValue('test', TestList, value)
  else if (propName = 'teardown') then TeardownElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestScript.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := asUri(new)
  else if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier
  else if (propName = 'version') then VersionElement := asString(new)
  else if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'title') then TitleElement := asString(new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, new)
  else if (propName = 'experimental') then ExperimentalElement := asBoolean(new)
  else if (propName = 'date') then DateElement := asDateTime(new)
  else if (propName = 'publisher') then PublisherElement := asString(new)
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new)
  else if (propName = 'description') then DescriptionElement := asMarkdown(new)
  else if (propName = 'useContext') then replacePropertyValue('useContext', UseContextList, existing, new)
  else if (propName = 'jurisdiction') then replacePropertyValue('jurisdiction', JurisdictionList, existing, new)
  else if (propName = 'purpose') then PurposeElement := asMarkdown(new)
  else if (propName = 'copyright') then CopyrightElement := asMarkdown(new)
  else if (propName = 'origin') then replacePropertyValue('origin', OriginList, existing, new)
  else if (propName = 'destination') then replacePropertyValue('destination', DestinationList, existing, new)
  else if (propName = 'metadata') then MetadataElement := new as TFhirTestScriptMetadata
  else if (propName = 'fixture') then replacePropertyValue('fixture', FixtureList, existing, new)
  else if (propName = 'profile') then replacePropertyValue('profile', ProfileList, existing, new)
  else if (propName = 'variable') then replacePropertyValue('variable', VariableList, existing, new)
  else if (propName = 'setup') then SetupElement := new as TFhirTestScriptSetup
  else if (propName = 'test') then replacePropertyValue('test', TestList, existing, new)
  else if (propName = 'teardown') then TeardownElement := new as TFhirTestScriptTeardown
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestScript.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'contact') then ContactList.move(source, destination)
  else if (propName = 'useContext') then UseContextList.move(source, destination)
  else if (propName = 'jurisdiction') then JurisdictionList.move(source, destination)
  else if (propName = 'origin') then OriginList.move(source, destination)
  else if (propName = 'destination') then DestinationList.move(source, destination)
  else if (propName = 'fixture') then FixtureList.move(source, destination)
  else if (propName = 'profile') then ProfileList.move(source, destination)
  else if (propName = 'variable') then VariableList.move(source, destination)
  else if (propName = 'test') then TestList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirTestScript.fhirType : string;
begin
  result := 'TestScript';
end;

function TFhirTestScript.Link : TFhirTestScript;
begin
  result := TFhirTestScript(inherited Link);
end;

function TFhirTestScript.Clone : TFhirTestScript;
begin
  result := TFhirTestScript(inherited Clone);
end;

function TFhirTestScript.equals(other : TObject) : boolean; 
var
  o : TFhirTestScript;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestScript)) then
    result := false
  else
  begin
    o := TFhirTestScript(other);
    result := compareDeep(urlElement, o.urlElement, true) and compareDeep(identifierElement, o.identifierElement, true) and 
      compareDeep(versionElement, o.versionElement, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(titleElement, o.titleElement, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(experimentalElement, o.experimentalElement, true) and compareDeep(dateElement, o.dateElement, true) and 
      compareDeep(publisherElement, o.publisherElement, true) and compareDeep(contactList, o.contactList, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(useContextList, o.useContextList, true) and 
      compareDeep(jurisdictionList, o.jurisdictionList, true) and compareDeep(purposeElement, o.purposeElement, true) and 
      compareDeep(copyrightElement, o.copyrightElement, true) and compareDeep(originList, o.originList, true) and 
      compareDeep(destinationList, o.destinationList, true) and compareDeep(metadataElement, o.metadataElement, true) and 
      compareDeep(fixtureList, o.fixtureList, true) and compareDeep(profileList, o.profileList, true) and 
      compareDeep(variableList, o.variableList, true) and compareDeep(setupElement, o.setupElement, true) and 
      compareDeep(testList, o.testList, true) and compareDeep(teardownElement, o.teardownElement, true);
  end;
end;

function TFhirTestScript.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FUrl) and isEmptyProp(FIdentifier) and isEmptyProp(FVersion) and isEmptyProp(FName) and isEmptyProp(FTitle) and isEmptyProp(FStatus) and isEmptyProp(FExperimental) and isEmptyProp(FDate) and isEmptyProp(FPublisher) and isEmptyProp(FcontactList) and isEmptyProp(FDescription) and isEmptyProp(FuseContextList) and isEmptyProp(FjurisdictionList) and isEmptyProp(FPurpose) and isEmptyProp(FCopyright) and isEmptyProp(ForiginList) and isEmptyProp(FdestinationList) and isEmptyProp(FMetadata) and isEmptyProp(FfixtureList) and isEmptyProp(FprofileList) and isEmptyProp(FvariableList) and isEmptyProp(FSetup) and isEmptyProp(FtestList) and isEmptyProp(FTeardown);
end;

procedure TFhirTestScript.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('url');
  fields.add('identifier');
  fields.add('version');
  fields.add('name');
  fields.add('title');
  fields.add('status');
  fields.add('experimental');
  fields.add('date');
  fields.add('publisher');
  fields.add('contact');
  fields.add('description');
  fields.add('useContext');
  fields.add('jurisdiction');
  fields.add('purpose');
  fields.add('copyright');
  fields.add('origin');
  fields.add('destination');
  fields.add('metadata');
  fields.add('fixture');
  fields.add('profile');
  fields.add('variable');
  fields.add('setup');
  fields.add('test');
  fields.add('teardown');
end;

function TFhirTestScript.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FContactList.sizeInBytes(magic));
  inc(result, FUseContextList.sizeInBytes(magic));
  inc(result, FJurisdictionList.sizeInBytes(magic));
  inc(result, FOriginList.sizeInBytes(magic));
  inc(result, FDestinationList.sizeInBytes(magic));
  inc(result, FFixtureList.sizeInBytes(magic));
  inc(result, FProfileList.sizeInBytes(magic));
  inc(result, FVariableList.sizeInBytes(magic));
  inc(result, FTestList.sizeInBytes(magic));
end;

procedure TFhirTestScript.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

function TFhirTestScript.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

procedure TFhirTestScript.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

procedure TFhirTestScript.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

procedure TFhirTestScript.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

function TFhirTestScript.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

procedure TFhirTestScript.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

procedure TFhirTestScript.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirTestScript.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirTestScript.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirTestScript.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

function TFhirTestScript.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

procedure TFhirTestScript.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

procedure TFhirTestScript.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirTestScript.GetStatusST : TFhirPublicationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirPublicationStatusEnum(0)
  else
    result := TFhirPublicationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirPublicationStatusEnum, FStatus.value));
end;

procedure TFhirTestScript.SetStatusST(value : TFhirPublicationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[value], CODES_TFhirPublicationStatusEnum[value]);
end;

procedure TFhirTestScript.SetExperimental(value : TFhirBoolean);
begin
  FExperimental.free;
  FExperimental := value;
end;

function TFhirTestScript.GetExperimentalST : Boolean;
begin
  if FExperimental = nil then
    result := false
  else
    result := FExperimental.value;
end;

procedure TFhirTestScript.SetExperimentalST(value : Boolean);
begin
  if FExperimental = nil then
    FExperimental := TFhirBoolean.create;
  FExperimental.value := value
end;

procedure TFhirTestScript.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

function TFhirTestScript.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirTestScript.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

procedure TFhirTestScript.SetPublisher(value : TFhirString);
begin
  FPublisher.free;
  FPublisher := value;
end;

function TFhirTestScript.GetPublisherST : String;
begin
  if FPublisher = nil then
    result := ''
  else
    result := FPublisher.value;
end;

procedure TFhirTestScript.SetPublisherST(value : String);
begin
  if value <> '' then
  begin
    if FPublisher = nil then
      FPublisher := TFhirString.create;
    FPublisher.value := value
  end
  else if FPublisher <> nil then
    FPublisher.value := '';
end;

function TFhirTestScript.GetContactList : TFhirContactDetailList;
begin
  if FContactList = nil then
    FContactList := TFhirContactDetailList.Create;
  result := FContactList;
end;

function TFhirTestScript.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

procedure TFhirTestScript.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirTestScript.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirTestScript.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirTestScript.GetUseContextList : TFhirUsageContextList;
begin
  if FUseContextList = nil then
    FUseContextList := TFhirUsageContextList.Create;
  result := FUseContextList;
end;

function TFhirTestScript.GetHasUseContextList : boolean;
begin
  result := (FUseContextList <> nil) and (FUseContextList.count > 0);
end;

function TFhirTestScript.GetJurisdictionList : TFhirCodeableConceptList;
begin
  if FJurisdictionList = nil then
    FJurisdictionList := TFhirCodeableConceptList.Create;
  result := FJurisdictionList;
end;

function TFhirTestScript.GetHasJurisdictionList : boolean;
begin
  result := (FJurisdictionList <> nil) and (FJurisdictionList.count > 0);
end;

procedure TFhirTestScript.SetPurpose(value : TFhirMarkdown);
begin
  FPurpose.free;
  FPurpose := value;
end;

function TFhirTestScript.GetPurposeST : String;
begin
  if FPurpose = nil then
    result := ''
  else
    result := FPurpose.value;
end;

procedure TFhirTestScript.SetPurposeST(value : String);
begin
  if value <> '' then
  begin
    if FPurpose = nil then
      FPurpose := TFhirMarkdown.create;
    FPurpose.value := value
  end
  else if FPurpose <> nil then
    FPurpose.value := '';
end;

procedure TFhirTestScript.SetCopyright(value : TFhirMarkdown);
begin
  FCopyright.free;
  FCopyright := value;
end;

function TFhirTestScript.GetCopyrightST : String;
begin
  if FCopyright = nil then
    result := ''
  else
    result := FCopyright.value;
end;

procedure TFhirTestScript.SetCopyrightST(value : String);
begin
  if value <> '' then
  begin
    if FCopyright = nil then
      FCopyright := TFhirMarkdown.create;
    FCopyright.value := value
  end
  else if FCopyright <> nil then
    FCopyright.value := '';
end;

function TFhirTestScript.GetOriginList : TFhirTestScriptOriginList;
begin
  if FOriginList = nil then
    FOriginList := TFhirTestScriptOriginList.Create;
  result := FOriginList;
end;

function TFhirTestScript.GetHasOriginList : boolean;
begin
  result := (FOriginList <> nil) and (FOriginList.count > 0);
end;

function TFhirTestScript.GetDestinationList : TFhirTestScriptDestinationList;
begin
  if FDestinationList = nil then
    FDestinationList := TFhirTestScriptDestinationList.Create;
  result := FDestinationList;
end;

function TFhirTestScript.GetHasDestinationList : boolean;
begin
  result := (FDestinationList <> nil) and (FDestinationList.count > 0);
end;

procedure TFhirTestScript.SetMetadata(value : TFhirTestScriptMetadata);
begin
  FMetadata.free;
  FMetadata := value;
end;

function TFhirTestScript.GetFixtureList : TFhirTestScriptFixtureList;
begin
  if FFixtureList = nil then
    FFixtureList := TFhirTestScriptFixtureList.Create;
  result := FFixtureList;
end;

function TFhirTestScript.GetHasFixtureList : boolean;
begin
  result := (FFixtureList <> nil) and (FFixtureList.count > 0);
end;

function TFhirTestScript.GetProfileList : TFhirReferenceList;
begin
  if FProfileList = nil then
    FProfileList := TFhirReferenceList.Create;
  result := FProfileList;
end;

function TFhirTestScript.GetHasProfileList : boolean;
begin
  result := (FProfileList <> nil) and (FProfileList.count > 0);
end;

function TFhirTestScript.GetVariableList : TFhirTestScriptVariableList;
begin
  if FVariableList = nil then
    FVariableList := TFhirTestScriptVariableList.Create;
  result := FVariableList;
end;

function TFhirTestScript.GetHasVariableList : boolean;
begin
  result := (FVariableList <> nil) and (FVariableList.count > 0);
end;

procedure TFhirTestScript.SetSetup(value : TFhirTestScriptSetup);
begin
  FSetup.free;
  FSetup := value;
end;

function TFhirTestScript.GetTestList : TFhirTestScriptTestList;
begin
  if FTestList = nil then
    FTestList := TFhirTestScriptTestList.Create;
  result := FTestList;
end;

function TFhirTestScript.GetHasTestList : boolean;
begin
  result := (FTestList <> nil) and (FTestList.count > 0);
end;

procedure TFhirTestScript.SetTeardown(value : TFhirTestScriptTeardown);
begin
  FTeardown.free;
  FTeardown := value;
end;

{ TFhirTestScriptListEnumerator }

constructor TFhirTestScriptListEnumerator.Create(list : TFhirTestScriptList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestScriptListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestScriptListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestScriptListEnumerator.GetCurrent : TFhirTestScript;
begin
  Result := FList[FIndex];
end;

function TFhirTestScriptListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirTestScriptList }

function TFhirTestScriptList.AddItem(value: TFhirTestScript): TFhirTestScript;
begin
  assert(value.ClassName = 'TFhirTestScript', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestScript');
  add(value);
  result := value;
end;

function TFhirTestScriptList.Append: TFhirTestScript;
begin
  result := TFhirTestScript.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptList.ClearItems;
begin
  Clear;
end;

function TFhirTestScriptList.GetEnumerator : TFhirTestScriptListEnumerator;
begin
  result := TFhirTestScriptListEnumerator.Create(self.link);
end;

function TFhirTestScriptList.Clone: TFhirTestScriptList;
begin
  result := TFhirTestScriptList(inherited Clone);
end;

function TFhirTestScriptList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestScriptList.GetItemN(index: Integer): TFhirTestScript;
begin
  result := TFhirTestScript(ObjectByIndex[index]);
end;

function TFhirTestScriptList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestScript;
end;
function TFhirTestScriptList.IndexOf(value: TFhirTestScript): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestScriptList.Insert(index: Integer): TFhirTestScript;
begin
  result := TFhirTestScript.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptList.InsertItem(index: Integer; value: TFhirTestScript);
begin
  assert(value is TFhirTestScript);
  Inherited Insert(index, value);
end;

function TFhirTestScriptList.Item(index: Integer): TFhirTestScript;
begin
  result := TFhirTestScript(ObjectByIndex[index]);
end;

function TFhirTestScriptList.Link: TFhirTestScriptList;
begin
  result := TFhirTestScriptList(inherited Link);
end;

procedure TFhirTestScriptList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestScriptList.SetItemByIndex(index: Integer; value: TFhirTestScript);
begin
  assert(value is TFhirTestScript);
  FhirTestScripts[index] := value;
end;

procedure TFhirTestScriptList.SetItemN(index: Integer; value: TFhirTestScript);
begin
  assert(value is TFhirTestScript);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_TESTSCRIPT}
{$IFDEF FHIR_VALUESET}
{ TFhirValueSetCompose }

constructor TFhirValueSetCompose.Create;
begin
  inherited;
end;

destructor TFhirValueSetCompose.Destroy;
begin
  FLockedDate.free;
  FInactive.free;
  FIncludeList.Free;
  FExcludeList.Free;
  inherited;
end;

procedure TFhirValueSetCompose.Assign(oSource : TFslObject);
begin
  inherited;
  lockedDateElement := TFhirValueSetCompose(oSource).lockedDateElement.Clone;
  inactiveElement := TFhirValueSetCompose(oSource).inactiveElement.Clone;
  if (TFhirValueSetCompose(oSource).FIncludeList = nil) then
  begin
    FIncludeList.free;
    FIncludeList := nil;
  end
  else
  begin
    if FIncludeList = nil then
      FIncludeList := TFhirValueSetComposeIncludeList.Create;
    FIncludeList.Assign(TFhirValueSetCompose(oSource).FIncludeList);
  end;
  if (TFhirValueSetCompose(oSource).FExcludeList = nil) then
  begin
    FExcludeList.free;
    FExcludeList := nil;
  end
  else
  begin
    if FExcludeList = nil then
      FExcludeList := TFhirValueSetComposeIncludeList.Create;
    FExcludeList.Assign(TFhirValueSetCompose(oSource).FExcludeList);
  end;
end;

procedure TFhirValueSetCompose.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'lockedDate') Then
     list.add(self.link, 'lockedDate', FLockedDate.Link);
  if (child_name = 'inactive') Then
     list.add(self.link, 'inactive', FInactive.Link);
  if (child_name = 'include') Then
    list.addAll(self, 'include', FIncludeList);
  if (child_name = 'exclude') Then
    list.addAll(self, 'exclude', FExcludeList);
end;

procedure TFhirValueSetCompose.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'lockedDate', 'date', false, TFhirDate, FLockedDate.Link));
  oList.add(TFHIRProperty.create(self, 'inactive', 'boolean', false, TFhirBoolean, FInactive.Link));
  oList.add(TFHIRProperty.create(self, 'include', 'BackboneElement', true, TFhirValueSetComposeInclude, FIncludeList.Link));
  oList.add(TFHIRProperty.create(self, 'exclude', '', true, TFhirValueSetComposeInclude, FExcludeList.Link));
end;

function TFhirValueSetCompose.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'lockedDate') then
  begin
    LockedDateElement := asDate(propValue);
    result := propValue;
  end
  else if (propName = 'inactive') then
  begin
    InactiveElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'include') then
  begin
    IncludeList.add(propValue as TFhirValueSetComposeInclude);
    result := propValue;
  end
  else if (propName = 'exclude') then
  begin
    ExcludeList.add(propValue as TFhirValueSetComposeInclude);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirValueSetCompose.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'include') then IncludeList.insertItem(index, propValue as TFhirValueSetComposeInclude)
  else if (propName = 'exclude') then ExcludeList.insertItem(index, propValue as TFhirValueSetComposeInclude)
  else inherited;
end;

function TFhirValueSetCompose.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'lockedDate') then result := TFhirDate.create()
  else if (propName = 'inactive') then result := TFhirBoolean.create()
  else if (propName = 'include') then result := IncludeList.new()
  else if (propName = 'exclude') then result := ExcludeList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirValueSetCompose.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'lockedDate') then result := 'date'
  else if (propName = 'inactive') then result := 'boolean'
  else if (propName = 'include') then result := 'BackboneElement'
  else if (propName = 'exclude') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirValueSetCompose.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'lockedDate') then LockedDateElement := nil
  else if (propName = 'inactive') then InactiveElement := nil
  else if (propName = 'include') then deletePropertyValue('include', IncludeList, value)
  else if (propName = 'exclude') then deletePropertyValue('exclude', ExcludeList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirValueSetCompose.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'lockedDate') then LockedDateElement := asDate(new)
  else if (propName = 'inactive') then InactiveElement := asBoolean(new)
  else if (propName = 'include') then replacePropertyValue('include', IncludeList, existing, new)
  else if (propName = 'exclude') then replacePropertyValue('exclude', ExcludeList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirValueSetCompose.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'include') then IncludeList.move(source, destination)
  else if (propName = 'exclude') then ExcludeList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirValueSetCompose.fhirType : string;
begin
  result := 'ValueSet.compose';
end;

function TFhirValueSetCompose.Link : TFhirValueSetCompose;
begin
  result := TFhirValueSetCompose(inherited Link);
end;

function TFhirValueSetCompose.Clone : TFhirValueSetCompose;
begin
  result := TFhirValueSetCompose(inherited Clone);
end;

function TFhirValueSetCompose.equals(other : TObject) : boolean; 
var
  o : TFhirValueSetCompose;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirValueSetCompose)) then
    result := false
  else
  begin
    o := TFhirValueSetCompose(other);
    result := compareDeep(lockedDateElement, o.lockedDateElement, true) and compareDeep(inactiveElement, o.inactiveElement, true) and 
      compareDeep(includeList, o.includeList, true) and compareDeep(excludeList, o.excludeList, true);
  end;
end;

function TFhirValueSetCompose.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FLockedDate) and isEmptyProp(FInactive) and isEmptyProp(FincludeList) and isEmptyProp(FexcludeList);
end;

procedure TFhirValueSetCompose.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('lockedDate');
  fields.add('inactive');
  fields.add('include');
  fields.add('exclude');
end;

function TFhirValueSetCompose.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIncludeList.sizeInBytes(magic));
  inc(result, FExcludeList.sizeInBytes(magic));
end;

procedure TFhirValueSetCompose.SetLockedDate(value : TFhirDate);
begin
  FLockedDate.free;
  FLockedDate := value;
end;

function TFhirValueSetCompose.GetLockedDateST : TFslDateTime;
begin
  if FLockedDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FLockedDate.value;
end;

procedure TFhirValueSetCompose.SetLockedDateST(value : TFslDateTime);
begin
  if FLockedDate = nil then
    FLockedDate := TFhirDate.create;
  FLockedDate.value := value
end;

procedure TFhirValueSetCompose.SetInactive(value : TFhirBoolean);
begin
  FInactive.free;
  FInactive := value;
end;

function TFhirValueSetCompose.GetInactiveST : Boolean;
begin
  if FInactive = nil then
    result := false
  else
    result := FInactive.value;
end;

procedure TFhirValueSetCompose.SetInactiveST(value : Boolean);
begin
  if FInactive = nil then
    FInactive := TFhirBoolean.create;
  FInactive.value := value
end;

function TFhirValueSetCompose.GetIncludeList : TFhirValueSetComposeIncludeList;
begin
  if FIncludeList = nil then
    FIncludeList := TFhirValueSetComposeIncludeList.Create;
  result := FIncludeList;
end;

function TFhirValueSetCompose.GetHasIncludeList : boolean;
begin
  result := (FIncludeList <> nil) and (FIncludeList.count > 0);
end;

function TFhirValueSetCompose.GetExcludeList : TFhirValueSetComposeIncludeList;
begin
  if FExcludeList = nil then
    FExcludeList := TFhirValueSetComposeIncludeList.Create;
  result := FExcludeList;
end;

function TFhirValueSetCompose.GetHasExcludeList : boolean;
begin
  result := (FExcludeList <> nil) and (FExcludeList.count > 0);
end;

{ TFhirValueSetComposeListEnumerator }

constructor TFhirValueSetComposeListEnumerator.Create(list : TFhirValueSetComposeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirValueSetComposeListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirValueSetComposeListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirValueSetComposeListEnumerator.GetCurrent : TFhirValueSetCompose;
begin
  Result := FList[FIndex];
end;

function TFhirValueSetComposeListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirValueSetComposeList }

function TFhirValueSetComposeList.AddItem(value: TFhirValueSetCompose): TFhirValueSetCompose;
begin
  assert(value.ClassName = 'TFhirValueSetCompose', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirValueSetCompose');
  add(value);
  result := value;
end;

function TFhirValueSetComposeList.Append: TFhirValueSetCompose;
begin
  result := TFhirValueSetCompose.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirValueSetComposeList.ClearItems;
begin
  Clear;
end;

function TFhirValueSetComposeList.GetEnumerator : TFhirValueSetComposeListEnumerator;
begin
  result := TFhirValueSetComposeListEnumerator.Create(self.link);
end;

function TFhirValueSetComposeList.Clone: TFhirValueSetComposeList;
begin
  result := TFhirValueSetComposeList(inherited Clone);
end;

function TFhirValueSetComposeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirValueSetComposeList.GetItemN(index: Integer): TFhirValueSetCompose;
begin
  result := TFhirValueSetCompose(ObjectByIndex[index]);
end;

function TFhirValueSetComposeList.ItemClass: TFslObjectClass;
begin
  result := TFhirValueSetCompose;
end;
function TFhirValueSetComposeList.IndexOf(value: TFhirValueSetCompose): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirValueSetComposeList.Insert(index: Integer): TFhirValueSetCompose;
begin
  result := TFhirValueSetCompose.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirValueSetComposeList.InsertItem(index: Integer; value: TFhirValueSetCompose);
begin
  assert(value is TFhirValueSetCompose);
  Inherited Insert(index, value);
end;

function TFhirValueSetComposeList.Item(index: Integer): TFhirValueSetCompose;
begin
  result := TFhirValueSetCompose(ObjectByIndex[index]);
end;

function TFhirValueSetComposeList.Link: TFhirValueSetComposeList;
begin
  result := TFhirValueSetComposeList(inherited Link);
end;

procedure TFhirValueSetComposeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirValueSetComposeList.SetItemByIndex(index: Integer; value: TFhirValueSetCompose);
begin
  assert(value is TFhirValueSetCompose);
  FhirValueSetComposes[index] := value;
end;

procedure TFhirValueSetComposeList.SetItemN(index: Integer; value: TFhirValueSetCompose);
begin
  assert(value is TFhirValueSetCompose);
  ObjectByIndex[index] := value;
end;

{ TFhirValueSetComposeInclude }

constructor TFhirValueSetComposeInclude.Create;
begin
  inherited;
end;

destructor TFhirValueSetComposeInclude.Destroy;
begin
  FSystem.free;
  FVersion.free;
  FConceptList.Free;
  FFilterList.Free;
  FValueSetList.Free;
  inherited;
end;

procedure TFhirValueSetComposeInclude.Assign(oSource : TFslObject);
begin
  inherited;
  systemElement := TFhirValueSetComposeInclude(oSource).systemElement.Clone;
  versionElement := TFhirValueSetComposeInclude(oSource).versionElement.Clone;
  if (TFhirValueSetComposeInclude(oSource).FConceptList = nil) then
  begin
    FConceptList.free;
    FConceptList := nil;
  end
  else
  begin
    if FConceptList = nil then
      FConceptList := TFhirValueSetComposeIncludeConceptList.Create;
    FConceptList.Assign(TFhirValueSetComposeInclude(oSource).FConceptList);
  end;
  if (TFhirValueSetComposeInclude(oSource).FFilterList = nil) then
  begin
    FFilterList.free;
    FFilterList := nil;
  end
  else
  begin
    if FFilterList = nil then
      FFilterList := TFhirValueSetComposeIncludeFilterList.Create;
    FFilterList.Assign(TFhirValueSetComposeInclude(oSource).FFilterList);
  end;
  if (TFhirValueSetComposeInclude(oSource).FValueSetList = nil) then
  begin
    FValueSetList.free;
    FValueSetList := nil;
  end
  else
  begin
    if FValueSetList = nil then
      FValueSetList := TFhirCanonicalList.Create;
    FValueSetList.Assign(TFhirValueSetComposeInclude(oSource).FValueSetList);
  end;
end;

procedure TFhirValueSetComposeInclude.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'system') Then
     list.add(self.link, 'system', FSystem.Link);
  if (child_name = 'version') Then
     list.add(self.link, 'version', FVersion.Link);
  if (child_name = 'concept') Then
    list.addAll(self, 'concept', FConceptList);
  if (child_name = 'filter') Then
    list.addAll(self, 'filter', FFilterList);
  if (child_name = 'valueSet') Then
    list.addAll(self, 'valueSet', FValueSetList);
end;

procedure TFhirValueSetComposeInclude.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'system', 'uri', false, TFhirUri, FSystem.Link));
  oList.add(TFHIRProperty.create(self, 'version', 'string', false, TFhirString, FVersion.Link));
  oList.add(TFHIRProperty.create(self, 'concept', 'BackboneElement', true, TFhirValueSetComposeIncludeConcept, FConceptList.Link));
  oList.add(TFHIRProperty.create(self, 'filter', 'BackboneElement', true, TFhirValueSetComposeIncludeFilter, FFilterList.Link));
  oList.add(TFHIRProperty.create(self, 'valueSet', 'canonical', true, TFhirCanonical, FValueSetList.Link));
end;

function TFhirValueSetComposeInclude.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'system') then
  begin
    SystemElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'concept') then
  begin
    ConceptList.add(propValue as TFhirValueSetComposeIncludeConcept);
    result := propValue;
  end
  else if (propName = 'filter') then
  begin
    FilterList.add(propValue as TFhirValueSetComposeIncludeFilter);
    result := propValue;
  end
  else if (propName = 'valueSet') then
  begin
    ValueSetList.add(asCanonical(propValue)){2};     result := propValue;

  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirValueSetComposeInclude.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'concept') then ConceptList.insertItem(index, propValue as TFhirValueSetComposeIncludeConcept)
  else if (propName = 'filter') then FilterList.insertItem(index, propValue as TFhirValueSetComposeIncludeFilter)
  else if (propName = 'valueSet') then ValueSetList.insertItem(index, asCanonical(propValue))
  else inherited;
end;

function TFhirValueSetComposeInclude.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'system') then result := TFhirUri.create()
  else if (propName = 'version') then result := TFhirString.create()
  else if (propName = 'concept') then result := ConceptList.new()
  else if (propName = 'filter') then result := FilterList.new()
  else if (propName = 'valueSet') then result := ValueSetList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirValueSetComposeInclude.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'system') then result := 'uri'
  else if (propName = 'version') then result := 'string'
  else if (propName = 'concept') then result := 'BackboneElement'
  else if (propName = 'filter') then result := 'BackboneElement'
  else if (propName = 'valueSet') then result := 'canonical'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirValueSetComposeInclude.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'system') then SystemElement := nil
  else if (propName = 'version') then VersionElement := nil
  else if (propName = 'concept') then deletePropertyValue('concept', ConceptList, value)
  else if (propName = 'filter') then deletePropertyValue('filter', FilterList, value)
  else if (propName = 'valueSet') then deletePropertyValue('valueSet', ValueSetList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirValueSetComposeInclude.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'system') then SystemElement := asUri(new)
  else if (propName = 'version') then VersionElement := asString(new)
  else if (propName = 'concept') then replacePropertyValue('concept', ConceptList, existing, new)
  else if (propName = 'filter') then replacePropertyValue('filter', FilterList, existing, new)
  else if (propName = 'valueSet') then replacePropertyValue('valueSet', ValueSetList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirValueSetComposeInclude.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'concept') then ConceptList.move(source, destination)
  else if (propName = 'filter') then FilterList.move(source, destination)
  else if (propName = 'valueSet') then ValueSetList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirValueSetComposeInclude.fhirType : string;
begin
  result := 'ValueSet.compose.include';
end;

function TFhirValueSetComposeInclude.Link : TFhirValueSetComposeInclude;
begin
  result := TFhirValueSetComposeInclude(inherited Link);
end;

function TFhirValueSetComposeInclude.Clone : TFhirValueSetComposeInclude;
begin
  result := TFhirValueSetComposeInclude(inherited Clone);
end;

function TFhirValueSetComposeInclude.equals(other : TObject) : boolean; 
var
  o : TFhirValueSetComposeInclude;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirValueSetComposeInclude)) then
    result := false
  else
  begin
    o := TFhirValueSetComposeInclude(other);
    result := compareDeep(systemElement, o.systemElement, true) and compareDeep(versionElement, o.versionElement, true) and 
      compareDeep(conceptList, o.conceptList, true) and compareDeep(filterList, o.filterList, true) and 
      compareDeep(valueSetList, o.valueSetList, true);
  end;
end;

function TFhirValueSetComposeInclude.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSystem) and isEmptyProp(FVersion) and isEmptyProp(FconceptList) and isEmptyProp(FfilterList) and isEmptyProp(FvalueSetList);
end;

procedure TFhirValueSetComposeInclude.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('system');
  fields.add('version');
  fields.add('concept');
  fields.add('filter');
  fields.add('valueSet');
end;

function TFhirValueSetComposeInclude.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FConceptList.sizeInBytes(magic));
  inc(result, FFilterList.sizeInBytes(magic));
  inc(result, FValueSetList.sizeInBytes(magic));
end;

procedure TFhirValueSetComposeInclude.SetSystem(value : TFhirUri);
begin
  FSystem.free;
  FSystem := value;
end;

function TFhirValueSetComposeInclude.GetSystemST : String;
begin
  if FSystem = nil then
    result := ''
  else
    result := FSystem.value;
end;

procedure TFhirValueSetComposeInclude.SetSystemST(value : String);
begin
  if value <> '' then
  begin
    if FSystem = nil then
      FSystem := TFhirUri.create;
    FSystem.value := value
  end
  else if FSystem <> nil then
    FSystem.value := '';
end;

procedure TFhirValueSetComposeInclude.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

function TFhirValueSetComposeInclude.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

procedure TFhirValueSetComposeInclude.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

function TFhirValueSetComposeInclude.GetConceptList : TFhirValueSetComposeIncludeConceptList;
begin
  if FConceptList = nil then
    FConceptList := TFhirValueSetComposeIncludeConceptList.Create;
  result := FConceptList;
end;

function TFhirValueSetComposeInclude.GetHasConceptList : boolean;
begin
  result := (FConceptList <> nil) and (FConceptList.count > 0);
end;

function TFhirValueSetComposeInclude.GetFilterList : TFhirValueSetComposeIncludeFilterList;
begin
  if FFilterList = nil then
    FFilterList := TFhirValueSetComposeIncludeFilterList.Create;
  result := FFilterList;
end;

function TFhirValueSetComposeInclude.GetHasFilterList : boolean;
begin
  result := (FFilterList <> nil) and (FFilterList.count > 0);
end;

function TFhirValueSetComposeInclude.GetValueSetList : TFhirCanonicalList;
begin
  if FValueSetList = nil then
    FValueSetList := TFhirCanonicalList.Create;
  result := FValueSetList;
end;

function TFhirValueSetComposeInclude.GetHasValueSetList : boolean;
begin
  result := (FValueSetList <> nil) and (FValueSetList.count > 0);
end;

{ TFhirValueSetComposeIncludeListEnumerator }

constructor TFhirValueSetComposeIncludeListEnumerator.Create(list : TFhirValueSetComposeIncludeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirValueSetComposeIncludeListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirValueSetComposeIncludeListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirValueSetComposeIncludeListEnumerator.GetCurrent : TFhirValueSetComposeInclude;
begin
  Result := FList[FIndex];
end;

function TFhirValueSetComposeIncludeListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirValueSetComposeIncludeList }

function TFhirValueSetComposeIncludeList.AddItem(value: TFhirValueSetComposeInclude): TFhirValueSetComposeInclude;
begin
  assert(value.ClassName = 'TFhirValueSetComposeInclude', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirValueSetComposeInclude');
  add(value);
  result := value;
end;

function TFhirValueSetComposeIncludeList.Append: TFhirValueSetComposeInclude;
begin
  result := TFhirValueSetComposeInclude.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirValueSetComposeIncludeList.ClearItems;
begin
  Clear;
end;

function TFhirValueSetComposeIncludeList.GetEnumerator : TFhirValueSetComposeIncludeListEnumerator;
begin
  result := TFhirValueSetComposeIncludeListEnumerator.Create(self.link);
end;

function TFhirValueSetComposeIncludeList.Clone: TFhirValueSetComposeIncludeList;
begin
  result := TFhirValueSetComposeIncludeList(inherited Clone);
end;

function TFhirValueSetComposeIncludeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirValueSetComposeIncludeList.GetItemN(index: Integer): TFhirValueSetComposeInclude;
begin
  result := TFhirValueSetComposeInclude(ObjectByIndex[index]);
end;

function TFhirValueSetComposeIncludeList.ItemClass: TFslObjectClass;
begin
  result := TFhirValueSetComposeInclude;
end;
function TFhirValueSetComposeIncludeList.IndexOf(value: TFhirValueSetComposeInclude): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirValueSetComposeIncludeList.Insert(index: Integer): TFhirValueSetComposeInclude;
begin
  result := TFhirValueSetComposeInclude.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirValueSetComposeIncludeList.InsertItem(index: Integer; value: TFhirValueSetComposeInclude);
begin
  assert(value is TFhirValueSetComposeInclude);
  Inherited Insert(index, value);
end;

function TFhirValueSetComposeIncludeList.Item(index: Integer): TFhirValueSetComposeInclude;
begin
  result := TFhirValueSetComposeInclude(ObjectByIndex[index]);
end;

function TFhirValueSetComposeIncludeList.Link: TFhirValueSetComposeIncludeList;
begin
  result := TFhirValueSetComposeIncludeList(inherited Link);
end;

procedure TFhirValueSetComposeIncludeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirValueSetComposeIncludeList.SetItemByIndex(index: Integer; value: TFhirValueSetComposeInclude);
begin
  assert(value is TFhirValueSetComposeInclude);
  FhirValueSetComposeIncludes[index] := value;
end;

procedure TFhirValueSetComposeIncludeList.SetItemN(index: Integer; value: TFhirValueSetComposeInclude);
begin
  assert(value is TFhirValueSetComposeInclude);
  ObjectByIndex[index] := value;
end;

{ TFhirValueSetComposeIncludeConcept }

constructor TFhirValueSetComposeIncludeConcept.Create;
begin
  inherited;
end;

destructor TFhirValueSetComposeIncludeConcept.Destroy;
begin
  FCode.free;
  FDisplay.free;
  FDesignationList.Free;
  inherited;
end;

procedure TFhirValueSetComposeIncludeConcept.Assign(oSource : TFslObject);
begin
  inherited;
  codeElement := TFhirValueSetComposeIncludeConcept(oSource).codeElement.Clone;
  displayElement := TFhirValueSetComposeIncludeConcept(oSource).displayElement.Clone;
  if (TFhirValueSetComposeIncludeConcept(oSource).FDesignationList = nil) then
  begin
    FDesignationList.free;
    FDesignationList := nil;
  end
  else
  begin
    if FDesignationList = nil then
      FDesignationList := TFhirValueSetComposeIncludeConceptDesignationList.Create;
    FDesignationList.Assign(TFhirValueSetComposeIncludeConcept(oSource).FDesignationList);
  end;
end;

procedure TFhirValueSetComposeIncludeConcept.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'display') Then
     list.add(self.link, 'display', FDisplay.Link);
  if (child_name = 'designation') Then
    list.addAll(self, 'designation', FDesignationList);
end;

procedure TFhirValueSetComposeIncludeConcept.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'code', false, TFhirCode, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'display', 'string', false, TFhirString, FDisplay.Link));
  oList.add(TFHIRProperty.create(self, 'designation', 'BackboneElement', true, TFhirValueSetComposeIncludeConceptDesignation, FDesignationList.Link));
end;

function TFhirValueSetComposeIncludeConcept.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    CodeElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'display') then
  begin
    DisplayElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'designation') then
  begin
    DesignationList.add(propValue as TFhirValueSetComposeIncludeConceptDesignation);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirValueSetComposeIncludeConcept.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'designation') then DesignationList.insertItem(index, propValue as TFhirValueSetComposeIncludeConceptDesignation)
  else inherited;
end;

function TFhirValueSetComposeIncludeConcept.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCode.create()
  else if (propName = 'display') then result := TFhirString.create()
  else if (propName = 'designation') then result := DesignationList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirValueSetComposeIncludeConcept.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'code'
  else if (propName = 'display') then result := 'string'
  else if (propName = 'designation') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirValueSetComposeIncludeConcept.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'display') then DisplayElement := nil
  else if (propName = 'designation') then deletePropertyValue('designation', DesignationList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirValueSetComposeIncludeConcept.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := asCode(new)
  else if (propName = 'display') then DisplayElement := asString(new)
  else if (propName = 'designation') then replacePropertyValue('designation', DesignationList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirValueSetComposeIncludeConcept.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'designation') then DesignationList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirValueSetComposeIncludeConcept.fhirType : string;
begin
  result := 'ValueSet.compose.include.concept';
end;

function TFhirValueSetComposeIncludeConcept.Link : TFhirValueSetComposeIncludeConcept;
begin
  result := TFhirValueSetComposeIncludeConcept(inherited Link);
end;

function TFhirValueSetComposeIncludeConcept.Clone : TFhirValueSetComposeIncludeConcept;
begin
  result := TFhirValueSetComposeIncludeConcept(inherited Clone);
end;

function TFhirValueSetComposeIncludeConcept.equals(other : TObject) : boolean; 
var
  o : TFhirValueSetComposeIncludeConcept;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirValueSetComposeIncludeConcept)) then
    result := false
  else
  begin
    o := TFhirValueSetComposeIncludeConcept(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(displayElement, o.displayElement, true) and 
      compareDeep(designationList, o.designationList, true);
  end;
end;

function TFhirValueSetComposeIncludeConcept.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FDisplay) and isEmptyProp(FdesignationList);
end;

procedure TFhirValueSetComposeIncludeConcept.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('code');
  fields.add('display');
  fields.add('designation');
end;

function TFhirValueSetComposeIncludeConcept.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FDesignationList.sizeInBytes(magic));
end;

procedure TFhirValueSetComposeIncludeConcept.SetCode(value : TFhirCode);
begin
  FCode.free;
  FCode := value;
end;

function TFhirValueSetComposeIncludeConcept.GetCodeST : String;
begin
  if FCode = nil then
    result := ''
  else
    result := FCode.value;
end;

procedure TFhirValueSetComposeIncludeConcept.SetCodeST(value : String);
begin
  if value <> '' then
  begin
    if FCode = nil then
      FCode := TFhirCode.create;
    FCode.value := value
  end
  else if FCode <> nil then
    FCode.value := '';
end;

procedure TFhirValueSetComposeIncludeConcept.SetDisplay(value : TFhirString);
begin
  FDisplay.free;
  FDisplay := value;
end;

function TFhirValueSetComposeIncludeConcept.GetDisplayST : String;
begin
  if FDisplay = nil then
    result := ''
  else
    result := FDisplay.value;
end;

procedure TFhirValueSetComposeIncludeConcept.SetDisplayST(value : String);
begin
  if value <> '' then
  begin
    if FDisplay = nil then
      FDisplay := TFhirString.create;
    FDisplay.value := value
  end
  else if FDisplay <> nil then
    FDisplay.value := '';
end;

function TFhirValueSetComposeIncludeConcept.GetDesignationList : TFhirValueSetComposeIncludeConceptDesignationList;
begin
  if FDesignationList = nil then
    FDesignationList := TFhirValueSetComposeIncludeConceptDesignationList.Create;
  result := FDesignationList;
end;

function TFhirValueSetComposeIncludeConcept.GetHasDesignationList : boolean;
begin
  result := (FDesignationList <> nil) and (FDesignationList.count > 0);
end;

{ TFhirValueSetComposeIncludeConceptListEnumerator }

constructor TFhirValueSetComposeIncludeConceptListEnumerator.Create(list : TFhirValueSetComposeIncludeConceptList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirValueSetComposeIncludeConceptListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirValueSetComposeIncludeConceptListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirValueSetComposeIncludeConceptListEnumerator.GetCurrent : TFhirValueSetComposeIncludeConcept;
begin
  Result := FList[FIndex];
end;

function TFhirValueSetComposeIncludeConceptListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirValueSetComposeIncludeConceptList }

function TFhirValueSetComposeIncludeConceptList.AddItem(value: TFhirValueSetComposeIncludeConcept): TFhirValueSetComposeIncludeConcept;
begin
  assert(value.ClassName = 'TFhirValueSetComposeIncludeConcept', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirValueSetComposeIncludeConcept');
  add(value);
  result := value;
end;

function TFhirValueSetComposeIncludeConceptList.Append: TFhirValueSetComposeIncludeConcept;
begin
  result := TFhirValueSetComposeIncludeConcept.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirValueSetComposeIncludeConceptList.ClearItems;
begin
  Clear;
end;

function TFhirValueSetComposeIncludeConceptList.GetEnumerator : TFhirValueSetComposeIncludeConceptListEnumerator;
begin
  result := TFhirValueSetComposeIncludeConceptListEnumerator.Create(self.link);
end;

function TFhirValueSetComposeIncludeConceptList.Clone: TFhirValueSetComposeIncludeConceptList;
begin
  result := TFhirValueSetComposeIncludeConceptList(inherited Clone);
end;

function TFhirValueSetComposeIncludeConceptList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirValueSetComposeIncludeConceptList.GetItemN(index: Integer): TFhirValueSetComposeIncludeConcept;
begin
  result := TFhirValueSetComposeIncludeConcept(ObjectByIndex[index]);
end;

function TFhirValueSetComposeIncludeConceptList.ItemClass: TFslObjectClass;
begin
  result := TFhirValueSetComposeIncludeConcept;
end;
function TFhirValueSetComposeIncludeConceptList.IndexOf(value: TFhirValueSetComposeIncludeConcept): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirValueSetComposeIncludeConceptList.Insert(index: Integer): TFhirValueSetComposeIncludeConcept;
begin
  result := TFhirValueSetComposeIncludeConcept.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirValueSetComposeIncludeConceptList.InsertItem(index: Integer; value: TFhirValueSetComposeIncludeConcept);
begin
  assert(value is TFhirValueSetComposeIncludeConcept);
  Inherited Insert(index, value);
end;

function TFhirValueSetComposeIncludeConceptList.Item(index: Integer): TFhirValueSetComposeIncludeConcept;
begin
  result := TFhirValueSetComposeIncludeConcept(ObjectByIndex[index]);
end;

function TFhirValueSetComposeIncludeConceptList.Link: TFhirValueSetComposeIncludeConceptList;
begin
  result := TFhirValueSetComposeIncludeConceptList(inherited Link);
end;

procedure TFhirValueSetComposeIncludeConceptList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirValueSetComposeIncludeConceptList.SetItemByIndex(index: Integer; value: TFhirValueSetComposeIncludeConcept);
begin
  assert(value is TFhirValueSetComposeIncludeConcept);
  FhirValueSetComposeIncludeConcepts[index] := value;
end;

procedure TFhirValueSetComposeIncludeConceptList.SetItemN(index: Integer; value: TFhirValueSetComposeIncludeConcept);
begin
  assert(value is TFhirValueSetComposeIncludeConcept);
  ObjectByIndex[index] := value;
end;

{ TFhirValueSetComposeIncludeConceptDesignation }

constructor TFhirValueSetComposeIncludeConceptDesignation.Create;
begin
  inherited;
end;

destructor TFhirValueSetComposeIncludeConceptDesignation.Destroy;
begin
  FLanguage.free;
  FUse.free;
  FValue.free;
  inherited;
end;

procedure TFhirValueSetComposeIncludeConceptDesignation.Assign(oSource : TFslObject);
begin
  inherited;
  languageElement := TFhirValueSetComposeIncludeConceptDesignation(oSource).languageElement.Clone;
  use := TFhirValueSetComposeIncludeConceptDesignation(oSource).use.Clone;
  valueElement := TFhirValueSetComposeIncludeConceptDesignation(oSource).valueElement.Clone;
end;

procedure TFhirValueSetComposeIncludeConceptDesignation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'language') Then
     list.add(self.link, 'language', FLanguage.Link);
  if (child_name = 'use') Then
     list.add(self.link, 'use', FUse.Link);
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
end;

procedure TFhirValueSetComposeIncludeConceptDesignation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'language', 'code', false, TFhirCode, FLanguage.Link));
  oList.add(TFHIRProperty.create(self, 'use', 'Coding', false, TFhirCoding, FUse.Link));
  oList.add(TFHIRProperty.create(self, 'value', 'string', false, TFhirString, FValue.Link));
end;

function TFhirValueSetComposeIncludeConceptDesignation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'language') then
  begin
    LanguageElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'use') then
  begin
    Use := propValue as TFhirCoding;
    result := propValue;
  end
  else if (propName = 'value') then
  begin
    ValueElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirValueSetComposeIncludeConceptDesignation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirValueSetComposeIncludeConceptDesignation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'language') then result := TFhirCode.create()
  else if (propName = 'use') then result := TFhirCoding.create()
  else if (propName = 'value') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirValueSetComposeIncludeConceptDesignation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'language') then result := 'code'
  else if (propName = 'use') then result := 'Coding'
  else if (propName = 'value') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirValueSetComposeIncludeConceptDesignation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'language') then LanguageElement := nil
  else if (propName = 'use') then UseElement := nil
  else if (propName = 'value') then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirValueSetComposeIncludeConceptDesignation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'language') then LanguageElement := asCode(new)
  else if (propName = 'use') then UseElement := new as TFhirCoding
  else if (propName = 'value') then ValueElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirValueSetComposeIncludeConceptDesignation.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirValueSetComposeIncludeConceptDesignation.fhirType : string;
begin
  result := 'ValueSet.compose.include.concept.designation';
end;

function TFhirValueSetComposeIncludeConceptDesignation.Link : TFhirValueSetComposeIncludeConceptDesignation;
begin
  result := TFhirValueSetComposeIncludeConceptDesignation(inherited Link);
end;

function TFhirValueSetComposeIncludeConceptDesignation.Clone : TFhirValueSetComposeIncludeConceptDesignation;
begin
  result := TFhirValueSetComposeIncludeConceptDesignation(inherited Clone);
end;

function TFhirValueSetComposeIncludeConceptDesignation.equals(other : TObject) : boolean; 
var
  o : TFhirValueSetComposeIncludeConceptDesignation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirValueSetComposeIncludeConceptDesignation)) then
    result := false
  else
  begin
    o := TFhirValueSetComposeIncludeConceptDesignation(other);
    result := compareDeep(languageElement, o.languageElement, true) and compareDeep(useElement, o.useElement, true) and 
      compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirValueSetComposeIncludeConceptDesignation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FLanguage) and isEmptyProp(FUse) and isEmptyProp(FValue);
end;

procedure TFhirValueSetComposeIncludeConceptDesignation.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('language');
  fields.add('use');
  fields.add('value');
end;

function TFhirValueSetComposeIncludeConceptDesignation.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirValueSetComposeIncludeConceptDesignation.SetLanguage(value : TFhirCode);
begin
  FLanguage.free;
  FLanguage := value;
end;

function TFhirValueSetComposeIncludeConceptDesignation.GetLanguageST : String;
begin
  if FLanguage = nil then
    result := ''
  else
    result := FLanguage.value;
end;

procedure TFhirValueSetComposeIncludeConceptDesignation.SetLanguageST(value : String);
begin
  if value <> '' then
  begin
    if FLanguage = nil then
      FLanguage := TFhirCode.create;
    FLanguage.value := value
  end
  else if FLanguage <> nil then
    FLanguage.value := '';
end;

procedure TFhirValueSetComposeIncludeConceptDesignation.SetUse(value : TFhirCoding);
begin
  FUse.free;
  FUse := value;
end;

procedure TFhirValueSetComposeIncludeConceptDesignation.SetValue(value : TFhirString);
begin
  FValue.free;
  FValue := value;
end;

function TFhirValueSetComposeIncludeConceptDesignation.GetValueST : String;
begin
  if FValue = nil then
    result := ''
  else
    result := FValue.value;
end;

procedure TFhirValueSetComposeIncludeConceptDesignation.SetValueST(value : String);
begin
  if value <> '' then
  begin
    if FValue = nil then
      FValue := TFhirString.create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := '';
end;

{ TFhirValueSetComposeIncludeConceptDesignationListEnumerator }

constructor TFhirValueSetComposeIncludeConceptDesignationListEnumerator.Create(list : TFhirValueSetComposeIncludeConceptDesignationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirValueSetComposeIncludeConceptDesignationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirValueSetComposeIncludeConceptDesignationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirValueSetComposeIncludeConceptDesignationListEnumerator.GetCurrent : TFhirValueSetComposeIncludeConceptDesignation;
begin
  Result := FList[FIndex];
end;

function TFhirValueSetComposeIncludeConceptDesignationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirValueSetComposeIncludeConceptDesignationList }

function TFhirValueSetComposeIncludeConceptDesignationList.AddItem(value: TFhirValueSetComposeIncludeConceptDesignation): TFhirValueSetComposeIncludeConceptDesignation;
begin
  assert(value.ClassName = 'TFhirValueSetComposeIncludeConceptDesignation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirValueSetComposeIncludeConceptDesignation');
  add(value);
  result := value;
end;

function TFhirValueSetComposeIncludeConceptDesignationList.Append: TFhirValueSetComposeIncludeConceptDesignation;
begin
  result := TFhirValueSetComposeIncludeConceptDesignation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirValueSetComposeIncludeConceptDesignationList.ClearItems;
begin
  Clear;
end;

function TFhirValueSetComposeIncludeConceptDesignationList.GetEnumerator : TFhirValueSetComposeIncludeConceptDesignationListEnumerator;
begin
  result := TFhirValueSetComposeIncludeConceptDesignationListEnumerator.Create(self.link);
end;

function TFhirValueSetComposeIncludeConceptDesignationList.Clone: TFhirValueSetComposeIncludeConceptDesignationList;
begin
  result := TFhirValueSetComposeIncludeConceptDesignationList(inherited Clone);
end;

function TFhirValueSetComposeIncludeConceptDesignationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirValueSetComposeIncludeConceptDesignationList.GetItemN(index: Integer): TFhirValueSetComposeIncludeConceptDesignation;
begin
  result := TFhirValueSetComposeIncludeConceptDesignation(ObjectByIndex[index]);
end;

function TFhirValueSetComposeIncludeConceptDesignationList.ItemClass: TFslObjectClass;
begin
  result := TFhirValueSetComposeIncludeConceptDesignation;
end;
function TFhirValueSetComposeIncludeConceptDesignationList.IndexOf(value: TFhirValueSetComposeIncludeConceptDesignation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirValueSetComposeIncludeConceptDesignationList.Insert(index: Integer): TFhirValueSetComposeIncludeConceptDesignation;
begin
  result := TFhirValueSetComposeIncludeConceptDesignation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirValueSetComposeIncludeConceptDesignationList.InsertItem(index: Integer; value: TFhirValueSetComposeIncludeConceptDesignation);
begin
  assert(value is TFhirValueSetComposeIncludeConceptDesignation);
  Inherited Insert(index, value);
end;

function TFhirValueSetComposeIncludeConceptDesignationList.Item(index: Integer): TFhirValueSetComposeIncludeConceptDesignation;
begin
  result := TFhirValueSetComposeIncludeConceptDesignation(ObjectByIndex[index]);
end;

function TFhirValueSetComposeIncludeConceptDesignationList.Link: TFhirValueSetComposeIncludeConceptDesignationList;
begin
  result := TFhirValueSetComposeIncludeConceptDesignationList(inherited Link);
end;

procedure TFhirValueSetComposeIncludeConceptDesignationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirValueSetComposeIncludeConceptDesignationList.SetItemByIndex(index: Integer; value: TFhirValueSetComposeIncludeConceptDesignation);
begin
  assert(value is TFhirValueSetComposeIncludeConceptDesignation);
  FhirValueSetComposeIncludeConceptDesignations[index] := value;
end;

procedure TFhirValueSetComposeIncludeConceptDesignationList.SetItemN(index: Integer; value: TFhirValueSetComposeIncludeConceptDesignation);
begin
  assert(value is TFhirValueSetComposeIncludeConceptDesignation);
  ObjectByIndex[index] := value;
end;

{ TFhirValueSetComposeIncludeFilter }

constructor TFhirValueSetComposeIncludeFilter.Create;
begin
  inherited;
end;

destructor TFhirValueSetComposeIncludeFilter.Destroy;
begin
  FProperty_.free;
  FOp.free;
  FValue.free;
  inherited;
end;

procedure TFhirValueSetComposeIncludeFilter.Assign(oSource : TFslObject);
begin
  inherited;
  property_Element := TFhirValueSetComposeIncludeFilter(oSource).property_Element.Clone;
  opElement := TFhirValueSetComposeIncludeFilter(oSource).opElement.Clone;
  valueElement := TFhirValueSetComposeIncludeFilter(oSource).valueElement.Clone;
end;

procedure TFhirValueSetComposeIncludeFilter.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'property') Then
     list.add(self.link, 'property', FProperty_.Link);
  if (child_name = 'op') Then
     list.add(self.link, 'op', FOp.Link);
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
end;

procedure TFhirValueSetComposeIncludeFilter.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'property', 'code', false, TFhirCode, FProperty_.Link));
  oList.add(TFHIRProperty.create(self, 'op', 'code', false, TFhirEnum, FOp.Link));
  oList.add(TFHIRProperty.create(self, 'value', 'string', false, TFhirString, FValue.Link));
end;

function TFhirValueSetComposeIncludeFilter.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'property') then
  begin
    Property_Element := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'op') then
  begin
    OpElement := asEnum(SYSTEMS_TFhirFilterOperatorEnum, CODES_TFhirFilterOperatorEnum, propValue);
    result := propValue;
  end
  else if (propName = 'value') then
  begin
    ValueElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirValueSetComposeIncludeFilter.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirValueSetComposeIncludeFilter.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'property') then result := TFhirCode.create()
  else if (propName = 'op') then result := TFhirEnum.create(SYSTEMS_TFhirFilterOperatorEnum[FilterOperatorNull], CODES_TFhirFilterOperatorEnum[FilterOperatorNull]) 
  else if (propName = 'value') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirValueSetComposeIncludeFilter.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'property') then result := 'code'
  else if (propName = 'op') then result := 'code'
  else if (propName = 'value') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirValueSetComposeIncludeFilter.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'property') then Property_Element := nil
  else if (propName = 'op') then OpElement := nil
  else if (propName = 'value') then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirValueSetComposeIncludeFilter.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'property') then Property_Element := asCode(new)
  else if (propName = 'op') then OpElement := asEnum(SYSTEMS_TFhirFilterOperatorEnum, CODES_TFhirFilterOperatorEnum, new)
  else if (propName = 'value') then ValueElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirValueSetComposeIncludeFilter.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirValueSetComposeIncludeFilter.fhirType : string;
begin
  result := 'ValueSet.compose.include.filter';
end;

function TFhirValueSetComposeIncludeFilter.Link : TFhirValueSetComposeIncludeFilter;
begin
  result := TFhirValueSetComposeIncludeFilter(inherited Link);
end;

function TFhirValueSetComposeIncludeFilter.Clone : TFhirValueSetComposeIncludeFilter;
begin
  result := TFhirValueSetComposeIncludeFilter(inherited Clone);
end;

function TFhirValueSetComposeIncludeFilter.equals(other : TObject) : boolean; 
var
  o : TFhirValueSetComposeIncludeFilter;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirValueSetComposeIncludeFilter)) then
    result := false
  else
  begin
    o := TFhirValueSetComposeIncludeFilter(other);
    result := compareDeep(property_Element, o.property_Element, true) and compareDeep(opElement, o.opElement, true) and 
      compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirValueSetComposeIncludeFilter.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FProperty_) and isEmptyProp(FOp) and isEmptyProp(FValue);
end;

procedure TFhirValueSetComposeIncludeFilter.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('property');
  fields.add('op');
  fields.add('value');
end;

function TFhirValueSetComposeIncludeFilter.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirValueSetComposeIncludeFilter.SetProperty_(value : TFhirCode);
begin
  FProperty_.free;
  FProperty_ := value;
end;

function TFhirValueSetComposeIncludeFilter.GetProperty_ST : String;
begin
  if FProperty_ = nil then
    result := ''
  else
    result := FProperty_.value;
end;

procedure TFhirValueSetComposeIncludeFilter.SetProperty_ST(value : String);
begin
  if value <> '' then
  begin
    if FProperty_ = nil then
      FProperty_ := TFhirCode.create;
    FProperty_.value := value
  end
  else if FProperty_ <> nil then
    FProperty_.value := '';
end;

procedure TFhirValueSetComposeIncludeFilter.SetOp(value : TFhirEnum);
begin
  FOp.free;
  FOp := value;
end;

function TFhirValueSetComposeIncludeFilter.GetOpST : TFhirFilterOperatorEnum;
begin
  if FOp = nil then
    result := TFhirFilterOperatorEnum(0)
  else
    result := TFhirFilterOperatorEnum(StringArrayIndexOfSensitive(CODES_TFhirFilterOperatorEnum, FOp.value));
end;

procedure TFhirValueSetComposeIncludeFilter.SetOpST(value : TFhirFilterOperatorEnum);
begin
  if ord(value) = 0 then
    OpElement := nil
  else
    OpElement := TFhirEnum.create(SYSTEMS_TFhirFilterOperatorEnum[value], CODES_TFhirFilterOperatorEnum[value]);
end;

procedure TFhirValueSetComposeIncludeFilter.SetValue(value : TFhirString);
begin
  FValue.free;
  FValue := value;
end;

function TFhirValueSetComposeIncludeFilter.GetValueST : String;
begin
  if FValue = nil then
    result := ''
  else
    result := FValue.value;
end;

procedure TFhirValueSetComposeIncludeFilter.SetValueST(value : String);
begin
  if value <> '' then
  begin
    if FValue = nil then
      FValue := TFhirString.create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := '';
end;

{ TFhirValueSetComposeIncludeFilterListEnumerator }

constructor TFhirValueSetComposeIncludeFilterListEnumerator.Create(list : TFhirValueSetComposeIncludeFilterList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirValueSetComposeIncludeFilterListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirValueSetComposeIncludeFilterListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirValueSetComposeIncludeFilterListEnumerator.GetCurrent : TFhirValueSetComposeIncludeFilter;
begin
  Result := FList[FIndex];
end;

function TFhirValueSetComposeIncludeFilterListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirValueSetComposeIncludeFilterList }

function TFhirValueSetComposeIncludeFilterList.AddItem(value: TFhirValueSetComposeIncludeFilter): TFhirValueSetComposeIncludeFilter;
begin
  assert(value.ClassName = 'TFhirValueSetComposeIncludeFilter', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirValueSetComposeIncludeFilter');
  add(value);
  result := value;
end;

function TFhirValueSetComposeIncludeFilterList.Append: TFhirValueSetComposeIncludeFilter;
begin
  result := TFhirValueSetComposeIncludeFilter.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirValueSetComposeIncludeFilterList.ClearItems;
begin
  Clear;
end;

function TFhirValueSetComposeIncludeFilterList.GetEnumerator : TFhirValueSetComposeIncludeFilterListEnumerator;
begin
  result := TFhirValueSetComposeIncludeFilterListEnumerator.Create(self.link);
end;

function TFhirValueSetComposeIncludeFilterList.Clone: TFhirValueSetComposeIncludeFilterList;
begin
  result := TFhirValueSetComposeIncludeFilterList(inherited Clone);
end;

function TFhirValueSetComposeIncludeFilterList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirValueSetComposeIncludeFilterList.GetItemN(index: Integer): TFhirValueSetComposeIncludeFilter;
begin
  result := TFhirValueSetComposeIncludeFilter(ObjectByIndex[index]);
end;

function TFhirValueSetComposeIncludeFilterList.ItemClass: TFslObjectClass;
begin
  result := TFhirValueSetComposeIncludeFilter;
end;
function TFhirValueSetComposeIncludeFilterList.IndexOf(value: TFhirValueSetComposeIncludeFilter): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirValueSetComposeIncludeFilterList.Insert(index: Integer): TFhirValueSetComposeIncludeFilter;
begin
  result := TFhirValueSetComposeIncludeFilter.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirValueSetComposeIncludeFilterList.InsertItem(index: Integer; value: TFhirValueSetComposeIncludeFilter);
begin
  assert(value is TFhirValueSetComposeIncludeFilter);
  Inherited Insert(index, value);
end;

function TFhirValueSetComposeIncludeFilterList.Item(index: Integer): TFhirValueSetComposeIncludeFilter;
begin
  result := TFhirValueSetComposeIncludeFilter(ObjectByIndex[index]);
end;

function TFhirValueSetComposeIncludeFilterList.Link: TFhirValueSetComposeIncludeFilterList;
begin
  result := TFhirValueSetComposeIncludeFilterList(inherited Link);
end;

procedure TFhirValueSetComposeIncludeFilterList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirValueSetComposeIncludeFilterList.SetItemByIndex(index: Integer; value: TFhirValueSetComposeIncludeFilter);
begin
  assert(value is TFhirValueSetComposeIncludeFilter);
  FhirValueSetComposeIncludeFilters[index] := value;
end;

procedure TFhirValueSetComposeIncludeFilterList.SetItemN(index: Integer; value: TFhirValueSetComposeIncludeFilter);
begin
  assert(value is TFhirValueSetComposeIncludeFilter);
  ObjectByIndex[index] := value;
end;

{ TFhirValueSetExpansion }

constructor TFhirValueSetExpansion.Create;
begin
  inherited;
end;

destructor TFhirValueSetExpansion.Destroy;
begin
  FIdentifier.free;
  FTimestamp.free;
  FTotal.free;
  FOffset.free;
  FParameterList.Free;
  FContainsList.Free;
  inherited;
end;

procedure TFhirValueSetExpansion.Assign(oSource : TFslObject);
begin
  inherited;
  identifierElement := TFhirValueSetExpansion(oSource).identifierElement.Clone;
  timestampElement := TFhirValueSetExpansion(oSource).timestampElement.Clone;
  totalElement := TFhirValueSetExpansion(oSource).totalElement.Clone;
  offsetElement := TFhirValueSetExpansion(oSource).offsetElement.Clone;
  if (TFhirValueSetExpansion(oSource).FParameterList = nil) then
  begin
    FParameterList.free;
    FParameterList := nil;
  end
  else
  begin
    if FParameterList = nil then
      FParameterList := TFhirValueSetExpansionParameterList.Create;
    FParameterList.Assign(TFhirValueSetExpansion(oSource).FParameterList);
  end;
  if (TFhirValueSetExpansion(oSource).FContainsList = nil) then
  begin
    FContainsList.free;
    FContainsList := nil;
  end
  else
  begin
    if FContainsList = nil then
      FContainsList := TFhirValueSetExpansionContainsList.Create;
    FContainsList.Assign(TFhirValueSetExpansion(oSource).FContainsList);
  end;
end;

procedure TFhirValueSetExpansion.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'timestamp') Then
     list.add(self.link, 'timestamp', FTimestamp.Link);
  if (child_name = 'total') Then
     list.add(self.link, 'total', FTotal.Link);
  if (child_name = 'offset') Then
     list.add(self.link, 'offset', FOffset.Link);
  if (child_name = 'parameter') Then
    list.addAll(self, 'parameter', FParameterList);
  if (child_name = 'contains') Then
    list.addAll(self, 'contains', FContainsList);
end;

procedure TFhirValueSetExpansion.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'uri', false, TFhirUri, FIdentifier.Link));
  oList.add(TFHIRProperty.create(self, 'timestamp', 'dateTime', false, TFhirDateTime, FTimestamp.Link));
  oList.add(TFHIRProperty.create(self, 'total', 'integer', false, TFhirInteger, FTotal.Link));
  oList.add(TFHIRProperty.create(self, 'offset', 'integer', false, TFhirInteger, FOffset.Link));
  oList.add(TFHIRProperty.create(self, 'parameter', 'BackboneElement', true, TFhirValueSetExpansionParameter, FParameterList.Link));
  oList.add(TFHIRProperty.create(self, 'contains', 'BackboneElement', true, TFhirValueSetExpansionContains, FContainsList.Link));
end;

function TFhirValueSetExpansion.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'timestamp') then
  begin
    TimestampElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'total') then
  begin
    TotalElement := asInteger(propValue);
    result := propValue;
  end
  else if (propName = 'offset') then
  begin
    OffsetElement := asInteger(propValue);
    result := propValue;
  end
  else if (propName = 'parameter') then
  begin
    ParameterList.add(propValue as TFhirValueSetExpansionParameter);
    result := propValue;
  end
  else if (propName = 'contains') then
  begin
    ContainsList.add(propValue as TFhirValueSetExpansionContains);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirValueSetExpansion.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'parameter') then ParameterList.insertItem(index, propValue as TFhirValueSetExpansionParameter)
  else if (propName = 'contains') then ContainsList.insertItem(index, propValue as TFhirValueSetExpansionContains)
  else inherited;
end;

function TFhirValueSetExpansion.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirUri.create()
  else if (propName = 'timestamp') then result := TFhirDateTime.create()
  else if (propName = 'total') then result := TFhirInteger.create()
  else if (propName = 'offset') then result := TFhirInteger.create()
  else if (propName = 'parameter') then result := ParameterList.new()
  else if (propName = 'contains') then result := ContainsList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirValueSetExpansion.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'uri'
  else if (propName = 'timestamp') then result := 'dateTime'
  else if (propName = 'total') then result := 'integer'
  else if (propName = 'offset') then result := 'integer'
  else if (propName = 'parameter') then result := 'BackboneElement'
  else if (propName = 'contains') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirValueSetExpansion.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'timestamp') then TimestampElement := nil
  else if (propName = 'total') then TotalElement := nil
  else if (propName = 'offset') then OffsetElement := nil
  else if (propName = 'parameter') then deletePropertyValue('parameter', ParameterList, value)
  else if (propName = 'contains') then deletePropertyValue('contains', ContainsList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirValueSetExpansion.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := asUri(new)
  else if (propName = 'timestamp') then TimestampElement := asDateTime(new)
  else if (propName = 'total') then TotalElement := asInteger(new)
  else if (propName = 'offset') then OffsetElement := asInteger(new)
  else if (propName = 'parameter') then replacePropertyValue('parameter', ParameterList, existing, new)
  else if (propName = 'contains') then replacePropertyValue('contains', ContainsList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirValueSetExpansion.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'parameter') then ParameterList.move(source, destination)
  else if (propName = 'contains') then ContainsList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirValueSetExpansion.fhirType : string;
begin
  result := 'ValueSet.expansion';
end;

function TFhirValueSetExpansion.Link : TFhirValueSetExpansion;
begin
  result := TFhirValueSetExpansion(inherited Link);
end;

function TFhirValueSetExpansion.Clone : TFhirValueSetExpansion;
begin
  result := TFhirValueSetExpansion(inherited Clone);
end;

function TFhirValueSetExpansion.equals(other : TObject) : boolean; 
var
  o : TFhirValueSetExpansion;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirValueSetExpansion)) then
    result := false
  else
  begin
    o := TFhirValueSetExpansion(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(timestampElement, o.timestampElement, true) and 
      compareDeep(totalElement, o.totalElement, true) and compareDeep(offsetElement, o.offsetElement, true) and 
      compareDeep(parameterList, o.parameterList, true) and compareDeep(containsList, o.containsList, true);
  end;
end;

function TFhirValueSetExpansion.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FTimestamp) and isEmptyProp(FTotal) and isEmptyProp(FOffset) and isEmptyProp(FparameterList) and isEmptyProp(FcontainsList);
end;

procedure TFhirValueSetExpansion.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('timestamp');
  fields.add('total');
  fields.add('offset');
  fields.add('parameter');
  fields.add('contains');
end;

function TFhirValueSetExpansion.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FParameterList.sizeInBytes(magic));
  inc(result, FContainsList.sizeInBytes(magic));
end;

procedure TFhirValueSetExpansion.SetIdentifier(value : TFhirUri);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

function TFhirValueSetExpansion.GetIdentifierST : String;
begin
  if FIdentifier = nil then
    result := ''
  else
    result := FIdentifier.value;
end;

procedure TFhirValueSetExpansion.SetIdentifierST(value : String);
begin
  if value <> '' then
  begin
    if FIdentifier = nil then
      FIdentifier := TFhirUri.create;
    FIdentifier.value := value
  end
  else if FIdentifier <> nil then
    FIdentifier.value := '';
end;

procedure TFhirValueSetExpansion.SetTimestamp(value : TFhirDateTime);
begin
  FTimestamp.free;
  FTimestamp := value;
end;

function TFhirValueSetExpansion.GetTimestampST : TFslDateTime;
begin
  if FTimestamp = nil then
    result := TFslDateTime.makeNull
  else
    result := FTimestamp.value;
end;

procedure TFhirValueSetExpansion.SetTimestampST(value : TFslDateTime);
begin
  if FTimestamp = nil then
    FTimestamp := TFhirDateTime.create;
  FTimestamp.value := value
end;

procedure TFhirValueSetExpansion.SetTotal(value : TFhirInteger);
begin
  FTotal.free;
  FTotal := value;
end;

function TFhirValueSetExpansion.GetTotalST : String;
begin
  if FTotal = nil then
    result := ''
  else
    result := FTotal.value;
end;

procedure TFhirValueSetExpansion.SetTotalST(value : String);
begin
  if value <> '' then
  begin
    if FTotal = nil then
      FTotal := TFhirInteger.create;
    FTotal.value := value
  end
  else if FTotal <> nil then
    FTotal.value := '';
end;

procedure TFhirValueSetExpansion.SetOffset(value : TFhirInteger);
begin
  FOffset.free;
  FOffset := value;
end;

function TFhirValueSetExpansion.GetOffsetST : String;
begin
  if FOffset = nil then
    result := ''
  else
    result := FOffset.value;
end;

procedure TFhirValueSetExpansion.SetOffsetST(value : String);
begin
  if value <> '' then
  begin
    if FOffset = nil then
      FOffset := TFhirInteger.create;
    FOffset.value := value
  end
  else if FOffset <> nil then
    FOffset.value := '';
end;

function TFhirValueSetExpansion.GetParameterList : TFhirValueSetExpansionParameterList;
begin
  if FParameterList = nil then
    FParameterList := TFhirValueSetExpansionParameterList.Create;
  result := FParameterList;
end;

function TFhirValueSetExpansion.GetHasParameterList : boolean;
begin
  result := (FParameterList <> nil) and (FParameterList.count > 0);
end;

function TFhirValueSetExpansion.GetContainsList : TFhirValueSetExpansionContainsList;
begin
  if FContainsList = nil then
    FContainsList := TFhirValueSetExpansionContainsList.Create;
  result := FContainsList;
end;

function TFhirValueSetExpansion.GetHasContainsList : boolean;
begin
  result := (FContainsList <> nil) and (FContainsList.count > 0);
end;

{ TFhirValueSetExpansionListEnumerator }

constructor TFhirValueSetExpansionListEnumerator.Create(list : TFhirValueSetExpansionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirValueSetExpansionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirValueSetExpansionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirValueSetExpansionListEnumerator.GetCurrent : TFhirValueSetExpansion;
begin
  Result := FList[FIndex];
end;

function TFhirValueSetExpansionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirValueSetExpansionList }

function TFhirValueSetExpansionList.AddItem(value: TFhirValueSetExpansion): TFhirValueSetExpansion;
begin
  assert(value.ClassName = 'TFhirValueSetExpansion', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirValueSetExpansion');
  add(value);
  result := value;
end;

function TFhirValueSetExpansionList.Append: TFhirValueSetExpansion;
begin
  result := TFhirValueSetExpansion.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirValueSetExpansionList.ClearItems;
begin
  Clear;
end;

function TFhirValueSetExpansionList.GetEnumerator : TFhirValueSetExpansionListEnumerator;
begin
  result := TFhirValueSetExpansionListEnumerator.Create(self.link);
end;

function TFhirValueSetExpansionList.Clone: TFhirValueSetExpansionList;
begin
  result := TFhirValueSetExpansionList(inherited Clone);
end;

function TFhirValueSetExpansionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirValueSetExpansionList.GetItemN(index: Integer): TFhirValueSetExpansion;
begin
  result := TFhirValueSetExpansion(ObjectByIndex[index]);
end;

function TFhirValueSetExpansionList.ItemClass: TFslObjectClass;
begin
  result := TFhirValueSetExpansion;
end;
function TFhirValueSetExpansionList.IndexOf(value: TFhirValueSetExpansion): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirValueSetExpansionList.Insert(index: Integer): TFhirValueSetExpansion;
begin
  result := TFhirValueSetExpansion.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirValueSetExpansionList.InsertItem(index: Integer; value: TFhirValueSetExpansion);
begin
  assert(value is TFhirValueSetExpansion);
  Inherited Insert(index, value);
end;

function TFhirValueSetExpansionList.Item(index: Integer): TFhirValueSetExpansion;
begin
  result := TFhirValueSetExpansion(ObjectByIndex[index]);
end;

function TFhirValueSetExpansionList.Link: TFhirValueSetExpansionList;
begin
  result := TFhirValueSetExpansionList(inherited Link);
end;

procedure TFhirValueSetExpansionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirValueSetExpansionList.SetItemByIndex(index: Integer; value: TFhirValueSetExpansion);
begin
  assert(value is TFhirValueSetExpansion);
  FhirValueSetExpansions[index] := value;
end;

procedure TFhirValueSetExpansionList.SetItemN(index: Integer; value: TFhirValueSetExpansion);
begin
  assert(value is TFhirValueSetExpansion);
  ObjectByIndex[index] := value;
end;

{ TFhirValueSetExpansionParameter }

constructor TFhirValueSetExpansionParameter.Create;
begin
  inherited;
end;

destructor TFhirValueSetExpansionParameter.Destroy;
begin
  FName.free;
  FValue.free;
  inherited;
end;

procedure TFhirValueSetExpansionParameter.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirValueSetExpansionParameter(oSource).nameElement.Clone;
  value := TFhirValueSetExpansionParameter(oSource).value.Clone;
end;

procedure TFhirValueSetExpansionParameter.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
end;

procedure TFhirValueSetExpansionParameter.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'value[x]', 'string|boolean|integer|decimal|uri|code|dateTime', false, TFhirDataType, FValue.Link));
end;

function TFhirValueSetExpansionParameter.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['String', 'Boolean', 'Integer', 'Decimal', 'Uri', 'Code', 'DateTime'])) then
  begin
    Value := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirValueSetExpansionParameter.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirValueSetExpansionParameter.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create()
  else if (isMatchingName(propName, 'value', ['String', 'Boolean', 'Integer', 'Decimal', 'Uri', 'Code', 'DateTime'])) then raise EFHIRException.create('Cannot make property Value')
  else result := inherited createPropertyValue(propName);
end;

function TFhirValueSetExpansionParameter.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'value[x]') then result := 'string|boolean|integer|decimal|uri|code|dateTime'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirValueSetExpansionParameter.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (isMatchingName(propName, 'value', ['String', 'Boolean', 'Integer', 'Decimal', 'Uri', 'Code', 'DateTime'])) then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirValueSetExpansionParameter.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new)
  else if (isMatchingName(propName, 'value', ['String', 'Boolean', 'Integer', 'Decimal', 'Uri', 'Code', 'DateTime'])) then ValueElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirValueSetExpansionParameter.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirValueSetExpansionParameter.fhirType : string;
begin
  result := 'ValueSet.expansion.parameter';
end;

function TFhirValueSetExpansionParameter.Link : TFhirValueSetExpansionParameter;
begin
  result := TFhirValueSetExpansionParameter(inherited Link);
end;

function TFhirValueSetExpansionParameter.Clone : TFhirValueSetExpansionParameter;
begin
  result := TFhirValueSetExpansionParameter(inherited Clone);
end;

function TFhirValueSetExpansionParameter.equals(other : TObject) : boolean; 
var
  o : TFhirValueSetExpansionParameter;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirValueSetExpansionParameter)) then
    result := false
  else
  begin
    o := TFhirValueSetExpansionParameter(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirValueSetExpansionParameter.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FValue);
end;

procedure TFhirValueSetExpansionParameter.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('name');
  fields.add('value[x]');
end;

function TFhirValueSetExpansionParameter.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirValueSetExpansionParameter.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirValueSetExpansionParameter.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirValueSetExpansionParameter.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirValueSetExpansionParameter.SetValue(value : TFhirDataType);
begin
  FValue.free;
  FValue := value;
end;

{ TFhirValueSetExpansionParameterListEnumerator }

constructor TFhirValueSetExpansionParameterListEnumerator.Create(list : TFhirValueSetExpansionParameterList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirValueSetExpansionParameterListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirValueSetExpansionParameterListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirValueSetExpansionParameterListEnumerator.GetCurrent : TFhirValueSetExpansionParameter;
begin
  Result := FList[FIndex];
end;

function TFhirValueSetExpansionParameterListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirValueSetExpansionParameterList }

function TFhirValueSetExpansionParameterList.AddItem(value: TFhirValueSetExpansionParameter): TFhirValueSetExpansionParameter;
begin
  assert(value.ClassName = 'TFhirValueSetExpansionParameter', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirValueSetExpansionParameter');
  add(value);
  result := value;
end;

function TFhirValueSetExpansionParameterList.Append: TFhirValueSetExpansionParameter;
begin
  result := TFhirValueSetExpansionParameter.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirValueSetExpansionParameterList.ClearItems;
begin
  Clear;
end;

function TFhirValueSetExpansionParameterList.GetEnumerator : TFhirValueSetExpansionParameterListEnumerator;
begin
  result := TFhirValueSetExpansionParameterListEnumerator.Create(self.link);
end;

function TFhirValueSetExpansionParameterList.Clone: TFhirValueSetExpansionParameterList;
begin
  result := TFhirValueSetExpansionParameterList(inherited Clone);
end;

function TFhirValueSetExpansionParameterList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirValueSetExpansionParameterList.GetItemN(index: Integer): TFhirValueSetExpansionParameter;
begin
  result := TFhirValueSetExpansionParameter(ObjectByIndex[index]);
end;

function TFhirValueSetExpansionParameterList.ItemClass: TFslObjectClass;
begin
  result := TFhirValueSetExpansionParameter;
end;
function TFhirValueSetExpansionParameterList.IndexOf(value: TFhirValueSetExpansionParameter): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirValueSetExpansionParameterList.Insert(index: Integer): TFhirValueSetExpansionParameter;
begin
  result := TFhirValueSetExpansionParameter.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirValueSetExpansionParameterList.InsertItem(index: Integer; value: TFhirValueSetExpansionParameter);
begin
  assert(value is TFhirValueSetExpansionParameter);
  Inherited Insert(index, value);
end;

function TFhirValueSetExpansionParameterList.Item(index: Integer): TFhirValueSetExpansionParameter;
begin
  result := TFhirValueSetExpansionParameter(ObjectByIndex[index]);
end;

function TFhirValueSetExpansionParameterList.Link: TFhirValueSetExpansionParameterList;
begin
  result := TFhirValueSetExpansionParameterList(inherited Link);
end;

procedure TFhirValueSetExpansionParameterList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirValueSetExpansionParameterList.SetItemByIndex(index: Integer; value: TFhirValueSetExpansionParameter);
begin
  assert(value is TFhirValueSetExpansionParameter);
  FhirValueSetExpansionParameters[index] := value;
end;

procedure TFhirValueSetExpansionParameterList.SetItemN(index: Integer; value: TFhirValueSetExpansionParameter);
begin
  assert(value is TFhirValueSetExpansionParameter);
  ObjectByIndex[index] := value;
end;

{ TFhirValueSetExpansionContains }

constructor TFhirValueSetExpansionContains.Create;
begin
  inherited;
end;

destructor TFhirValueSetExpansionContains.Destroy;
begin
  FSystem.free;
  FAbstract.free;
  FInactive.free;
  FVersion.free;
  FCode.free;
  FDisplay.free;
  FDesignationList.Free;
  FContainsList.Free;
  inherited;
end;

procedure TFhirValueSetExpansionContains.Assign(oSource : TFslObject);
begin
  inherited;
  systemElement := TFhirValueSetExpansionContains(oSource).systemElement.Clone;
  abstractElement := TFhirValueSetExpansionContains(oSource).abstractElement.Clone;
  inactiveElement := TFhirValueSetExpansionContains(oSource).inactiveElement.Clone;
  versionElement := TFhirValueSetExpansionContains(oSource).versionElement.Clone;
  codeElement := TFhirValueSetExpansionContains(oSource).codeElement.Clone;
  displayElement := TFhirValueSetExpansionContains(oSource).displayElement.Clone;
  if (TFhirValueSetExpansionContains(oSource).FDesignationList = nil) then
  begin
    FDesignationList.free;
    FDesignationList := nil;
  end
  else
  begin
    if FDesignationList = nil then
      FDesignationList := TFhirValueSetComposeIncludeConceptDesignationList.Create;
    FDesignationList.Assign(TFhirValueSetExpansionContains(oSource).FDesignationList);
  end;
  if (TFhirValueSetExpansionContains(oSource).FContainsList = nil) then
  begin
    FContainsList.free;
    FContainsList := nil;
  end
  else
  begin
    if FContainsList = nil then
      FContainsList := TFhirValueSetExpansionContainsList.Create;
    FContainsList.Assign(TFhirValueSetExpansionContains(oSource).FContainsList);
  end;
end;

procedure TFhirValueSetExpansionContains.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'system') Then
     list.add(self.link, 'system', FSystem.Link);
  if (child_name = 'abstract') Then
     list.add(self.link, 'abstract', FAbstract.Link);
  if (child_name = 'inactive') Then
     list.add(self.link, 'inactive', FInactive.Link);
  if (child_name = 'version') Then
     list.add(self.link, 'version', FVersion.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'display') Then
     list.add(self.link, 'display', FDisplay.Link);
  if (child_name = 'designation') Then
    list.addAll(self, 'designation', FDesignationList);
  if (child_name = 'contains') Then
    list.addAll(self, 'contains', FContainsList);
end;

procedure TFhirValueSetExpansionContains.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'system', 'uri', false, TFhirUri, FSystem.Link));
  oList.add(TFHIRProperty.create(self, 'abstract', 'boolean', false, TFhirBoolean, FAbstract.Link));
  oList.add(TFHIRProperty.create(self, 'inactive', 'boolean', false, TFhirBoolean, FInactive.Link));
  oList.add(TFHIRProperty.create(self, 'version', 'string', false, TFhirString, FVersion.Link));
  oList.add(TFHIRProperty.create(self, 'code', 'code', false, TFhirCode, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'display', 'string', false, TFhirString, FDisplay.Link));
  oList.add(TFHIRProperty.create(self, 'designation', '', true, TFhirValueSetComposeIncludeConceptDesignation, FDesignationList.Link));
  oList.add(TFHIRProperty.create(self, 'contains', '', true, TFhirValueSetExpansionContains, FContainsList.Link));
end;

function TFhirValueSetExpansionContains.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'system') then
  begin
    SystemElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'abstract') then
  begin
    AbstractElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'inactive') then
  begin
    InactiveElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    CodeElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'display') then
  begin
    DisplayElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'designation') then
  begin
    DesignationList.add(propValue as TFhirValueSetComposeIncludeConceptDesignation);
    result := propValue;
  end
  else if (propName = 'contains') then
  begin
    ContainsList.add(propValue as TFhirValueSetExpansionContains);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirValueSetExpansionContains.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'designation') then DesignationList.insertItem(index, propValue as TFhirValueSetComposeIncludeConceptDesignation)
  else if (propName = 'contains') then ContainsList.insertItem(index, propValue as TFhirValueSetExpansionContains)
  else inherited;
end;

function TFhirValueSetExpansionContains.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'system') then result := TFhirUri.create()
  else if (propName = 'abstract') then result := TFhirBoolean.create()
  else if (propName = 'inactive') then result := TFhirBoolean.create()
  else if (propName = 'version') then result := TFhirString.create()
  else if (propName = 'code') then result := TFhirCode.create()
  else if (propName = 'display') then result := TFhirString.create()
  else if (propName = 'designation') then result := DesignationList.new()
  else if (propName = 'contains') then result := ContainsList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirValueSetExpansionContains.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'system') then result := 'uri'
  else if (propName = 'abstract') then result := 'boolean'
  else if (propName = 'inactive') then result := 'boolean'
  else if (propName = 'version') then result := 'string'
  else if (propName = 'code') then result := 'code'
  else if (propName = 'display') then result := 'string'
  else if (propName = 'designation') then result := ''
  else if (propName = 'contains') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirValueSetExpansionContains.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'system') then SystemElement := nil
  else if (propName = 'abstract') then AbstractElement := nil
  else if (propName = 'inactive') then InactiveElement := nil
  else if (propName = 'version') then VersionElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'display') then DisplayElement := nil
  else if (propName = 'designation') then deletePropertyValue('designation', DesignationList, value)
  else if (propName = 'contains') then deletePropertyValue('contains', ContainsList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirValueSetExpansionContains.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'system') then SystemElement := asUri(new)
  else if (propName = 'abstract') then AbstractElement := asBoolean(new)
  else if (propName = 'inactive') then InactiveElement := asBoolean(new)
  else if (propName = 'version') then VersionElement := asString(new)
  else if (propName = 'code') then CodeElement := asCode(new)
  else if (propName = 'display') then DisplayElement := asString(new)
  else if (propName = 'designation') then replacePropertyValue('designation', DesignationList, existing, new)
  else if (propName = 'contains') then replacePropertyValue('contains', ContainsList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirValueSetExpansionContains.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'designation') then DesignationList.move(source, destination)
  else if (propName = 'contains') then ContainsList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirValueSetExpansionContains.fhirType : string;
begin
  result := 'ValueSet.expansion.contains';
end;

function TFhirValueSetExpansionContains.Link : TFhirValueSetExpansionContains;
begin
  result := TFhirValueSetExpansionContains(inherited Link);
end;

function TFhirValueSetExpansionContains.Clone : TFhirValueSetExpansionContains;
begin
  result := TFhirValueSetExpansionContains(inherited Clone);
end;

function TFhirValueSetExpansionContains.equals(other : TObject) : boolean; 
var
  o : TFhirValueSetExpansionContains;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirValueSetExpansionContains)) then
    result := false
  else
  begin
    o := TFhirValueSetExpansionContains(other);
    result := compareDeep(systemElement, o.systemElement, true) and compareDeep(abstractElement, o.abstractElement, true) and 
      compareDeep(inactiveElement, o.inactiveElement, true) and compareDeep(versionElement, o.versionElement, true) and 
      compareDeep(codeElement, o.codeElement, true) and compareDeep(displayElement, o.displayElement, true) and 
      compareDeep(designationList, o.designationList, true) and compareDeep(containsList, o.containsList, true);
  end;
end;

function TFhirValueSetExpansionContains.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSystem) and isEmptyProp(FAbstract) and isEmptyProp(FInactive) and isEmptyProp(FVersion) and isEmptyProp(FCode) and isEmptyProp(FDisplay) and isEmptyProp(FdesignationList) and isEmptyProp(FcontainsList);
end;

procedure TFhirValueSetExpansionContains.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('system');
  fields.add('abstract');
  fields.add('inactive');
  fields.add('version');
  fields.add('code');
  fields.add('display');
  fields.add('designation');
  fields.add('contains');
end;

function TFhirValueSetExpansionContains.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FDesignationList.sizeInBytes(magic));
  inc(result, FContainsList.sizeInBytes(magic));
end;

procedure TFhirValueSetExpansionContains.SetSystem(value : TFhirUri);
begin
  FSystem.free;
  FSystem := value;
end;

function TFhirValueSetExpansionContains.GetSystemST : String;
begin
  if FSystem = nil then
    result := ''
  else
    result := FSystem.value;
end;

procedure TFhirValueSetExpansionContains.SetSystemST(value : String);
begin
  if value <> '' then
  begin
    if FSystem = nil then
      FSystem := TFhirUri.create;
    FSystem.value := value
  end
  else if FSystem <> nil then
    FSystem.value := '';
end;

procedure TFhirValueSetExpansionContains.SetAbstract(value : TFhirBoolean);
begin
  FAbstract.free;
  FAbstract := value;
end;

function TFhirValueSetExpansionContains.GetAbstractST : Boolean;
begin
  if FAbstract = nil then
    result := false
  else
    result := FAbstract.value;
end;

procedure TFhirValueSetExpansionContains.SetAbstractST(value : Boolean);
begin
  if FAbstract = nil then
    FAbstract := TFhirBoolean.create;
  FAbstract.value := value
end;

procedure TFhirValueSetExpansionContains.SetInactive(value : TFhirBoolean);
begin
  FInactive.free;
  FInactive := value;
end;

function TFhirValueSetExpansionContains.GetInactiveST : Boolean;
begin
  if FInactive = nil then
    result := false
  else
    result := FInactive.value;
end;

procedure TFhirValueSetExpansionContains.SetInactiveST(value : Boolean);
begin
  if FInactive = nil then
    FInactive := TFhirBoolean.create;
  FInactive.value := value
end;

procedure TFhirValueSetExpansionContains.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

function TFhirValueSetExpansionContains.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

procedure TFhirValueSetExpansionContains.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

procedure TFhirValueSetExpansionContains.SetCode(value : TFhirCode);
begin
  FCode.free;
  FCode := value;
end;

function TFhirValueSetExpansionContains.GetCodeST : String;
begin
  if FCode = nil then
    result := ''
  else
    result := FCode.value;
end;

procedure TFhirValueSetExpansionContains.SetCodeST(value : String);
begin
  if value <> '' then
  begin
    if FCode = nil then
      FCode := TFhirCode.create;
    FCode.value := value
  end
  else if FCode <> nil then
    FCode.value := '';
end;

procedure TFhirValueSetExpansionContains.SetDisplay(value : TFhirString);
begin
  FDisplay.free;
  FDisplay := value;
end;

function TFhirValueSetExpansionContains.GetDisplayST : String;
begin
  if FDisplay = nil then
    result := ''
  else
    result := FDisplay.value;
end;

procedure TFhirValueSetExpansionContains.SetDisplayST(value : String);
begin
  if value <> '' then
  begin
    if FDisplay = nil then
      FDisplay := TFhirString.create;
    FDisplay.value := value
  end
  else if FDisplay <> nil then
    FDisplay.value := '';
end;

function TFhirValueSetExpansionContains.GetDesignationList : TFhirValueSetComposeIncludeConceptDesignationList;
begin
  if FDesignationList = nil then
    FDesignationList := TFhirValueSetComposeIncludeConceptDesignationList.Create;
  result := FDesignationList;
end;

function TFhirValueSetExpansionContains.GetHasDesignationList : boolean;
begin
  result := (FDesignationList <> nil) and (FDesignationList.count > 0);
end;

function TFhirValueSetExpansionContains.GetContainsList : TFhirValueSetExpansionContainsList;
begin
  if FContainsList = nil then
    FContainsList := TFhirValueSetExpansionContainsList.Create;
  result := FContainsList;
end;

function TFhirValueSetExpansionContains.GetHasContainsList : boolean;
begin
  result := (FContainsList <> nil) and (FContainsList.count > 0);
end;

{ TFhirValueSetExpansionContainsListEnumerator }

constructor TFhirValueSetExpansionContainsListEnumerator.Create(list : TFhirValueSetExpansionContainsList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirValueSetExpansionContainsListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirValueSetExpansionContainsListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirValueSetExpansionContainsListEnumerator.GetCurrent : TFhirValueSetExpansionContains;
begin
  Result := FList[FIndex];
end;

function TFhirValueSetExpansionContainsListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirValueSetExpansionContainsList }

function TFhirValueSetExpansionContainsList.AddItem(value: TFhirValueSetExpansionContains): TFhirValueSetExpansionContains;
begin
  assert(value.ClassName = 'TFhirValueSetExpansionContains', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirValueSetExpansionContains');
  add(value);
  result := value;
end;

function TFhirValueSetExpansionContainsList.Append: TFhirValueSetExpansionContains;
begin
  result := TFhirValueSetExpansionContains.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirValueSetExpansionContainsList.ClearItems;
begin
  Clear;
end;

function TFhirValueSetExpansionContainsList.GetEnumerator : TFhirValueSetExpansionContainsListEnumerator;
begin
  result := TFhirValueSetExpansionContainsListEnumerator.Create(self.link);
end;

function TFhirValueSetExpansionContainsList.Clone: TFhirValueSetExpansionContainsList;
begin
  result := TFhirValueSetExpansionContainsList(inherited Clone);
end;

function TFhirValueSetExpansionContainsList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirValueSetExpansionContainsList.GetItemN(index: Integer): TFhirValueSetExpansionContains;
begin
  result := TFhirValueSetExpansionContains(ObjectByIndex[index]);
end;

function TFhirValueSetExpansionContainsList.ItemClass: TFslObjectClass;
begin
  result := TFhirValueSetExpansionContains;
end;
function TFhirValueSetExpansionContainsList.IndexOf(value: TFhirValueSetExpansionContains): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirValueSetExpansionContainsList.Insert(index: Integer): TFhirValueSetExpansionContains;
begin
  result := TFhirValueSetExpansionContains.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirValueSetExpansionContainsList.InsertItem(index: Integer; value: TFhirValueSetExpansionContains);
begin
  assert(value is TFhirValueSetExpansionContains);
  Inherited Insert(index, value);
end;

function TFhirValueSetExpansionContainsList.Item(index: Integer): TFhirValueSetExpansionContains;
begin
  result := TFhirValueSetExpansionContains(ObjectByIndex[index]);
end;

function TFhirValueSetExpansionContainsList.Link: TFhirValueSetExpansionContainsList;
begin
  result := TFhirValueSetExpansionContainsList(inherited Link);
end;

procedure TFhirValueSetExpansionContainsList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirValueSetExpansionContainsList.SetItemByIndex(index: Integer; value: TFhirValueSetExpansionContains);
begin
  assert(value is TFhirValueSetExpansionContains);
  FhirValueSetExpansionContains[index] := value;
end;

procedure TFhirValueSetExpansionContainsList.SetItemN(index: Integer; value: TFhirValueSetExpansionContains);
begin
  assert(value is TFhirValueSetExpansionContains);
  ObjectByIndex[index] := value;
end;

{ TFhirValueSet }

constructor TFhirValueSet.Create;
begin
  inherited;
end;

destructor TFhirValueSet.Destroy;
begin
  FUrl.free;
  FIdentifierList.Free;
  FVersion.free;
  FName.free;
  FTitle.free;
  FStatus.free;
  FExperimental.free;
  FDate.free;
  FPublisher.free;
  FContactList.Free;
  FDescription.free;
  FUseContextList.Free;
  FJurisdictionList.Free;
  FImmutable.free;
  FPurpose.free;
  FCopyright.free;
  FCompose.free;
  FExpansion.free;
  inherited;
end;

procedure TFhirValueSet.Assign(oSource : TFslObject);
begin
  inherited;
  urlElement := TFhirValueSet(oSource).urlElement.Clone;
  if (TFhirValueSet(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirValueSet(oSource).FIdentifierList);
  end;
  versionElement := TFhirValueSet(oSource).versionElement.Clone;
  nameElement := TFhirValueSet(oSource).nameElement.Clone;
  titleElement := TFhirValueSet(oSource).titleElement.Clone;
  statusElement := TFhirValueSet(oSource).statusElement.Clone;
  experimentalElement := TFhirValueSet(oSource).experimentalElement.Clone;
  dateElement := TFhirValueSet(oSource).dateElement.Clone;
  publisherElement := TFhirValueSet(oSource).publisherElement.Clone;
  if (TFhirValueSet(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirContactDetailList.Create;
    FContactList.Assign(TFhirValueSet(oSource).FContactList);
  end;
  descriptionElement := TFhirValueSet(oSource).descriptionElement.Clone;
  if (TFhirValueSet(oSource).FUseContextList = nil) then
  begin
    FUseContextList.free;
    FUseContextList := nil;
  end
  else
  begin
    if FUseContextList = nil then
      FUseContextList := TFhirUsageContextList.Create;
    FUseContextList.Assign(TFhirValueSet(oSource).FUseContextList);
  end;
  if (TFhirValueSet(oSource).FJurisdictionList = nil) then
  begin
    FJurisdictionList.free;
    FJurisdictionList := nil;
  end
  else
  begin
    if FJurisdictionList = nil then
      FJurisdictionList := TFhirCodeableConceptList.Create;
    FJurisdictionList.Assign(TFhirValueSet(oSource).FJurisdictionList);
  end;
  immutableElement := TFhirValueSet(oSource).immutableElement.Clone;
  purposeElement := TFhirValueSet(oSource).purposeElement.Clone;
  copyrightElement := TFhirValueSet(oSource).copyrightElement.Clone;
  compose := TFhirValueSet(oSource).compose.Clone;
  expansion := TFhirValueSet(oSource).expansion.Clone;
end;

function TFhirValueSet.GetResourceType : TFhirResourceType;
begin
  result := frtValueSet;
end;

procedure TFhirValueSet.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'version') Then
     list.add(self.link, 'version', FVersion.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'experimental') Then
     list.add(self.link, 'experimental', FExperimental.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'publisher') Then
     list.add(self.link, 'publisher', FPublisher.Link);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'useContext') Then
    list.addAll(self, 'useContext', FUseContextList);
  if (child_name = 'jurisdiction') Then
    list.addAll(self, 'jurisdiction', FJurisdictionList);
  if (child_name = 'immutable') Then
     list.add(self.link, 'immutable', FImmutable.Link);
  if (child_name = 'purpose') Then
     list.add(self.link, 'purpose', FPurpose.Link);
  if (child_name = 'copyright') Then
     list.add(self.link, 'copyright', FCopyright.Link);
  if (child_name = 'compose') Then
     list.add(self.link, 'compose', FCompose.Link);
  if (child_name = 'expansion') Then
     list.add(self.link, 'expansion', FExpansion.Link);
end;

procedure TFhirValueSet.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'url', 'uri', false, TFhirUri, FUrl.Link));
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'version', 'string', false, TFhirString, FVersion.Link));
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'experimental', 'boolean', false, TFhirBoolean, FExperimental.Link));
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));
  oList.add(TFHIRProperty.create(self, 'publisher', 'string', false, TFhirString, FPublisher.Link));
  oList.add(TFHIRProperty.create(self, 'contact', 'ContactDetail', true, TFhirContactDetail, FContactList.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'markdown', false, TFhirMarkdown, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'useContext', 'UsageContext', true, TFhirUsageContext, FUseContextList.Link));
  oList.add(TFHIRProperty.create(self, 'jurisdiction', 'CodeableConcept', true, TFhirCodeableConcept, FJurisdictionList.Link));
  oList.add(TFHIRProperty.create(self, 'immutable', 'boolean', false, TFhirBoolean, FImmutable.Link));
  oList.add(TFHIRProperty.create(self, 'purpose', 'markdown', false, TFhirMarkdown, FPurpose.Link));
  oList.add(TFHIRProperty.create(self, 'copyright', 'markdown', false, TFhirMarkdown, FCopyright.Link));
  oList.add(TFHIRProperty.create(self, 'compose', 'BackboneElement', false, TFhirValueSetCompose, FCompose.Link));
  oList.add(TFHIRProperty.create(self, 'expansion', 'BackboneElement', false, TFhirValueSetExpansion, FExpansion.Link));
end;

function TFhirValueSet.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'url') then
  begin
    UrlElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'title') then
  begin
    TitleElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'experimental') then
  begin
    ExperimentalElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'publisher') then
  begin
    PublisherElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirContactDetail);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'useContext') then
  begin
    UseContextList.add(propValue as TFhirUsageContext);
    result := propValue;
  end
  else if (propName = 'jurisdiction') then
  begin
    JurisdictionList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'immutable') then
  begin
    ImmutableElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'purpose') then
  begin
    PurposeElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'copyright') then
  begin
    CopyrightElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'compose') then
  begin
    Compose := propValue as TFhirValueSetCompose;
    result := propValue;
  end
  else if (propName = 'expansion') then
  begin
    Expansion := propValue as TFhirValueSetExpansion;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirValueSet.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirContactDetail)
  else if (propName = 'useContext') then UseContextList.insertItem(index, propValue as TFhirUsageContext)
  else if (propName = 'jurisdiction') then JurisdictionList.insertItem(index, propValue as TFhirCodeableConcept)
  else inherited;
end;

function TFhirValueSet.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'url') then result := TFhirUri.create()
  else if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'version') then result := TFhirString.create()
  else if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'title') then result := TFhirString.create()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[PublicationStatusNull], CODES_TFhirPublicationStatusEnum[PublicationStatusNull]) 
  else if (propName = 'experimental') then result := TFhirBoolean.create()
  else if (propName = 'date') then result := TFhirDateTime.create()
  else if (propName = 'publisher') then result := TFhirString.create()
  else if (propName = 'contact') then result := ContactList.new()
  else if (propName = 'description') then result := TFhirMarkdown.create()
  else if (propName = 'useContext') then result := UseContextList.new()
  else if (propName = 'jurisdiction') then result := JurisdictionList.new()
  else if (propName = 'immutable') then result := TFhirBoolean.create()
  else if (propName = 'purpose') then result := TFhirMarkdown.create()
  else if (propName = 'copyright') then result := TFhirMarkdown.create()
  else if (propName = 'compose') then result := TFhirValueSetCompose.create()
  else if (propName = 'expansion') then result := TFhirValueSetExpansion.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirValueSet.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'url') then result := 'uri'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'version') then result := 'string'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'title') then result := 'string'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'experimental') then result := 'boolean'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'publisher') then result := 'string'
  else if (propName = 'contact') then result := 'ContactDetail'
  else if (propName = 'description') then result := 'markdown'
  else if (propName = 'useContext') then result := 'UsageContext'
  else if (propName = 'jurisdiction') then result := 'CodeableConcept'
  else if (propName = 'immutable') then result := 'boolean'
  else if (propName = 'purpose') then result := 'markdown'
  else if (propName = 'copyright') then result := 'markdown'
  else if (propName = 'compose') then result := 'BackboneElement'
  else if (propName = 'expansion') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirValueSet.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := nil
  else if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'version') then VersionElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'title') then TitleElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'experimental') then ExperimentalElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'publisher') then PublisherElement := nil
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value)
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'useContext') then deletePropertyValue('useContext', UseContextList, value)
  else if (propName = 'jurisdiction') then deletePropertyValue('jurisdiction', JurisdictionList, value)
  else if (propName = 'immutable') then ImmutableElement := nil
  else if (propName = 'purpose') then PurposeElement := nil
  else if (propName = 'copyright') then CopyrightElement := nil
  else if (propName = 'compose') then ComposeElement := nil
  else if (propName = 'expansion') then ExpansionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirValueSet.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := asUri(new)
  else if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'version') then VersionElement := asString(new)
  else if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'title') then TitleElement := asString(new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, new)
  else if (propName = 'experimental') then ExperimentalElement := asBoolean(new)
  else if (propName = 'date') then DateElement := asDateTime(new)
  else if (propName = 'publisher') then PublisherElement := asString(new)
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new)
  else if (propName = 'description') then DescriptionElement := asMarkdown(new)
  else if (propName = 'useContext') then replacePropertyValue('useContext', UseContextList, existing, new)
  else if (propName = 'jurisdiction') then replacePropertyValue('jurisdiction', JurisdictionList, existing, new)
  else if (propName = 'immutable') then ImmutableElement := asBoolean(new)
  else if (propName = 'purpose') then PurposeElement := asMarkdown(new)
  else if (propName = 'copyright') then CopyrightElement := asMarkdown(new)
  else if (propName = 'compose') then ComposeElement := new as TFhirValueSetCompose
  else if (propName = 'expansion') then ExpansionElement := new as TFhirValueSetExpansion
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirValueSet.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'contact') then ContactList.move(source, destination)
  else if (propName = 'useContext') then UseContextList.move(source, destination)
  else if (propName = 'jurisdiction') then JurisdictionList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirValueSet.fhirType : string;
begin
  result := 'ValueSet';
end;

function TFhirValueSet.Link : TFhirValueSet;
begin
  result := TFhirValueSet(inherited Link);
end;

function TFhirValueSet.Clone : TFhirValueSet;
begin
  result := TFhirValueSet(inherited Clone);
end;

function TFhirValueSet.equals(other : TObject) : boolean; 
var
  o : TFhirValueSet;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirValueSet)) then
    result := false
  else
  begin
    o := TFhirValueSet(other);
    result := compareDeep(urlElement, o.urlElement, true) and compareDeep(identifierList, o.identifierList, true) and 
      compareDeep(versionElement, o.versionElement, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(titleElement, o.titleElement, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(experimentalElement, o.experimentalElement, true) and compareDeep(dateElement, o.dateElement, true) and 
      compareDeep(publisherElement, o.publisherElement, true) and compareDeep(contactList, o.contactList, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(useContextList, o.useContextList, true) and 
      compareDeep(jurisdictionList, o.jurisdictionList, true) and compareDeep(immutableElement, o.immutableElement, true) and 
      compareDeep(purposeElement, o.purposeElement, true) and compareDeep(copyrightElement, o.copyrightElement, true) and 
      compareDeep(composeElement, o.composeElement, true) and compareDeep(expansionElement, o.expansionElement, true);
  end;
end;

function TFhirValueSet.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FUrl) and isEmptyProp(FidentifierList) and isEmptyProp(FVersion) and isEmptyProp(FName) and isEmptyProp(FTitle) and isEmptyProp(FStatus) and isEmptyProp(FExperimental) and isEmptyProp(FDate) and isEmptyProp(FPublisher) and isEmptyProp(FcontactList) and isEmptyProp(FDescription) and isEmptyProp(FuseContextList) and isEmptyProp(FjurisdictionList) and isEmptyProp(FImmutable) and isEmptyProp(FPurpose) and isEmptyProp(FCopyright) and isEmptyProp(FCompose) and isEmptyProp(FExpansion);
end;

procedure TFhirValueSet.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('url');
  fields.add('identifier');
  fields.add('version');
  fields.add('name');
  fields.add('title');
  fields.add('status');
  fields.add('experimental');
  fields.add('date');
  fields.add('publisher');
  fields.add('contact');
  fields.add('description');
  fields.add('useContext');
  fields.add('jurisdiction');
  fields.add('immutable');
  fields.add('purpose');
  fields.add('copyright');
  fields.add('compose');
  fields.add('expansion');
end;

function TFhirValueSet.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FContactList.sizeInBytes(magic));
  inc(result, FUseContextList.sizeInBytes(magic));
  inc(result, FJurisdictionList.sizeInBytes(magic));
end;

procedure TFhirValueSet.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

function TFhirValueSet.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

procedure TFhirValueSet.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

function TFhirValueSet.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirValueSet.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirValueSet.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

function TFhirValueSet.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

procedure TFhirValueSet.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

procedure TFhirValueSet.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirValueSet.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirValueSet.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirValueSet.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

function TFhirValueSet.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

procedure TFhirValueSet.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

procedure TFhirValueSet.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirValueSet.GetStatusST : TFhirPublicationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirPublicationStatusEnum(0)
  else
    result := TFhirPublicationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirPublicationStatusEnum, FStatus.value));
end;

procedure TFhirValueSet.SetStatusST(value : TFhirPublicationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[value], CODES_TFhirPublicationStatusEnum[value]);
end;

procedure TFhirValueSet.SetExperimental(value : TFhirBoolean);
begin
  FExperimental.free;
  FExperimental := value;
end;

function TFhirValueSet.GetExperimentalST : Boolean;
begin
  if FExperimental = nil then
    result := false
  else
    result := FExperimental.value;
end;

procedure TFhirValueSet.SetExperimentalST(value : Boolean);
begin
  if FExperimental = nil then
    FExperimental := TFhirBoolean.create;
  FExperimental.value := value
end;

procedure TFhirValueSet.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

function TFhirValueSet.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirValueSet.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

procedure TFhirValueSet.SetPublisher(value : TFhirString);
begin
  FPublisher.free;
  FPublisher := value;
end;

function TFhirValueSet.GetPublisherST : String;
begin
  if FPublisher = nil then
    result := ''
  else
    result := FPublisher.value;
end;

procedure TFhirValueSet.SetPublisherST(value : String);
begin
  if value <> '' then
  begin
    if FPublisher = nil then
      FPublisher := TFhirString.create;
    FPublisher.value := value
  end
  else if FPublisher <> nil then
    FPublisher.value := '';
end;

function TFhirValueSet.GetContactList : TFhirContactDetailList;
begin
  if FContactList = nil then
    FContactList := TFhirContactDetailList.Create;
  result := FContactList;
end;

function TFhirValueSet.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

procedure TFhirValueSet.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirValueSet.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirValueSet.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirValueSet.GetUseContextList : TFhirUsageContextList;
begin
  if FUseContextList = nil then
    FUseContextList := TFhirUsageContextList.Create;
  result := FUseContextList;
end;

function TFhirValueSet.GetHasUseContextList : boolean;
begin
  result := (FUseContextList <> nil) and (FUseContextList.count > 0);
end;

function TFhirValueSet.GetJurisdictionList : TFhirCodeableConceptList;
begin
  if FJurisdictionList = nil then
    FJurisdictionList := TFhirCodeableConceptList.Create;
  result := FJurisdictionList;
end;

function TFhirValueSet.GetHasJurisdictionList : boolean;
begin
  result := (FJurisdictionList <> nil) and (FJurisdictionList.count > 0);
end;

procedure TFhirValueSet.SetImmutable(value : TFhirBoolean);
begin
  FImmutable.free;
  FImmutable := value;
end;

function TFhirValueSet.GetImmutableST : Boolean;
begin
  if FImmutable = nil then
    result := false
  else
    result := FImmutable.value;
end;

procedure TFhirValueSet.SetImmutableST(value : Boolean);
begin
  if FImmutable = nil then
    FImmutable := TFhirBoolean.create;
  FImmutable.value := value
end;

procedure TFhirValueSet.SetPurpose(value : TFhirMarkdown);
begin
  FPurpose.free;
  FPurpose := value;
end;

function TFhirValueSet.GetPurposeST : String;
begin
  if FPurpose = nil then
    result := ''
  else
    result := FPurpose.value;
end;

procedure TFhirValueSet.SetPurposeST(value : String);
begin
  if value <> '' then
  begin
    if FPurpose = nil then
      FPurpose := TFhirMarkdown.create;
    FPurpose.value := value
  end
  else if FPurpose <> nil then
    FPurpose.value := '';
end;

procedure TFhirValueSet.SetCopyright(value : TFhirMarkdown);
begin
  FCopyright.free;
  FCopyright := value;
end;

function TFhirValueSet.GetCopyrightST : String;
begin
  if FCopyright = nil then
    result := ''
  else
    result := FCopyright.value;
end;

procedure TFhirValueSet.SetCopyrightST(value : String);
begin
  if value <> '' then
  begin
    if FCopyright = nil then
      FCopyright := TFhirMarkdown.create;
    FCopyright.value := value
  end
  else if FCopyright <> nil then
    FCopyright.value := '';
end;

procedure TFhirValueSet.SetCompose(value : TFhirValueSetCompose);
begin
  FCompose.free;
  FCompose := value;
end;

procedure TFhirValueSet.SetExpansion(value : TFhirValueSetExpansion);
begin
  FExpansion.free;
  FExpansion := value;
end;

{ TFhirValueSetListEnumerator }

constructor TFhirValueSetListEnumerator.Create(list : TFhirValueSetList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirValueSetListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirValueSetListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirValueSetListEnumerator.GetCurrent : TFhirValueSet;
begin
  Result := FList[FIndex];
end;

function TFhirValueSetListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirValueSetList }

function TFhirValueSetList.AddItem(value: TFhirValueSet): TFhirValueSet;
begin
  assert(value.ClassName = 'TFhirValueSet', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirValueSet');
  add(value);
  result := value;
end;

function TFhirValueSetList.Append: TFhirValueSet;
begin
  result := TFhirValueSet.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirValueSetList.ClearItems;
begin
  Clear;
end;

function TFhirValueSetList.GetEnumerator : TFhirValueSetListEnumerator;
begin
  result := TFhirValueSetListEnumerator.Create(self.link);
end;

function TFhirValueSetList.Clone: TFhirValueSetList;
begin
  result := TFhirValueSetList(inherited Clone);
end;

function TFhirValueSetList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirValueSetList.GetItemN(index: Integer): TFhirValueSet;
begin
  result := TFhirValueSet(ObjectByIndex[index]);
end;

function TFhirValueSetList.ItemClass: TFslObjectClass;
begin
  result := TFhirValueSet;
end;
function TFhirValueSetList.IndexOf(value: TFhirValueSet): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirValueSetList.Insert(index: Integer): TFhirValueSet;
begin
  result := TFhirValueSet.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirValueSetList.InsertItem(index: Integer; value: TFhirValueSet);
begin
  assert(value is TFhirValueSet);
  Inherited Insert(index, value);
end;

function TFhirValueSetList.Item(index: Integer): TFhirValueSet;
begin
  result := TFhirValueSet(ObjectByIndex[index]);
end;

function TFhirValueSetList.Link: TFhirValueSetList;
begin
  result := TFhirValueSetList(inherited Link);
end;

procedure TFhirValueSetList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirValueSetList.SetItemByIndex(index: Integer; value: TFhirValueSet);
begin
  assert(value is TFhirValueSet);
  FhirValueSets[index] := value;
end;

procedure TFhirValueSetList.SetItemN(index: Integer; value: TFhirValueSet);
begin
  assert(value is TFhirValueSet);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_VALUESET}


end.

